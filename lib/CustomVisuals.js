var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var PixelConverter = jsCommon.PixelConverter;
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var AsterPlotVisualClassName = 'asterPlot';
            var AsterPlotLegendObjectName = 'legend';
            var AsterDefaultOuterLineThickness = 1;
            var AsterDefaultLabelFill = { solid: { color: '#333' } };
            var AsterDefaultLegendFontSize = 8;
            var AsterRadiusRatio = 0.9;
            var AsterConflictRatio = 0.9;
            var MaxPrecision = 17;
            var AsterPlotWebBehavior = (function () {
                function AsterPlotWebBehavior() {
                }
                AsterPlotWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    this.selection = options.selection;
                    this.highlightedSelection = options.highlightedSelection;
                    this.clearCatcher = options.clearCatcher;
                    this.interactivityService = options.interactivityService;
                    this.selection.on('click', function (d, i) {
                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                    });
                    if (this.highlightedSelection)
                        this.highlightedSelection.on('click', function (d, i) {
                            selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                        });
                    this.clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                AsterPlotWebBehavior.prototype.renderSelection = function (hasSelection) {
                    var hasHighlights = this.interactivityService.hasSelection();
                    this.selection.style("fill-opacity", function (d) {
                        return visuals.ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, !d.data.highlight && hasSelection, !d.data.selected && hasHighlights);
                    });
                };
                return AsterPlotWebBehavior;
            }());
            var AsterPlotWarning = (function () {
                function AsterPlotWarning(message) {
                    this.message = message;
                }
                Object.defineProperty(AsterPlotWarning.prototype, "code", {
                    get: function () {
                        return "AsterPlotWarning";
                    },
                    enumerable: true,
                    configurable: true
                });
                AsterPlotWarning.prototype.getMessages = function (resourceProvider) {
                    return {
                        message: this.message,
                        title: resourceProvider.get(""),
                        detail: resourceProvider.get("")
                    };
                };
                return AsterPlotWarning;
            }());
            samples.AsterPlotWarning = AsterPlotWarning;
            var AsterPlot = (function () {
                function AsterPlot() {
                    this.margin = {
                        top: 10,
                        right: 10,
                        bottom: 15,
                        left: 10
                    };
                }
                AsterPlot.prototype.getDefaultAsterData = function () {
                    return {
                        dataPoints: [],
                        highlightedDataPoints: [],
                        legendData: {
                            dataPoints: [],
                            title: null,
                            fontSize: AsterDefaultLegendFontSize,
                            labelColor: visuals.LegendData.DefaultLegendLabelFillColor
                        },
                        legendSettings: {
                            show: false,
                            position: 'Top',
                            showTitle: true,
                            labelColor: visuals.LegendData.DefaultLegendLabelFillColor,
                            titleText: '',
                            fontSize: AsterDefaultLegendFontSize,
                        },
                        valueFormatter: null,
                        labelSettings: {
                            show: false,
                            displayUnits: 0,
                            precision: visuals.dataLabelUtils.defaultLabelPrecision,
                            labelColor: visuals.dataLabelUtils.defaultLabelColor,
                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,
                        },
                        showOuterLine: false,
                        outerLineThickness: AsterDefaultOuterLineThickness,
                    };
                };
                AsterPlot.prototype.converter = function (dataView, colors) {
                    var asterDataResult = this.getDefaultAsterData();
                    if (!this.dataViewContainsCategory(dataView) || dataView.categorical.categories.length !== 1)
                        return asterDataResult;
                    var catDv = dataView.categorical;
                    var cat = catDv.categories[0];
                    var catSource = cat.source;
                    var catValues = cat.values;
                    var values = catDv.values;
                    var catObjects = cat.objects;
                    var colorHelper = new visuals.ColorHelper(colors, AsterPlot.Properties.dataPoint.fill);
                    var hasHighlights = this.hasHighlights = !!(values && values.length > 0 && values[0].highlights);
                    if (dataView.metadata || dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        asterDataResult.labelSettings = this.getLabelSettings(objects, asterDataResult.labelSettings);
                        this.updateLegendSettings(objects, catSource, asterDataResult.legendSettings);
                        asterDataResult.showOuterLine = powerbi.DataViewObjects.getValue(objects, AsterPlot.Properties.outerLine.show, asterDataResult.showOuterLine);
                        asterDataResult.outerLineThickness = powerbi.DataViewObjects.getValue(objects, AsterPlot.Properties.outerLine.thickness, AsterDefaultOuterLineThickness);
                    }
                    var labelSettings = asterDataResult.labelSettings;
                    if (!catValues || catValues.length < 1 || !values || values.length < 1)
                        return asterDataResult;
                    var formatStringProp = AsterPlot.Properties.general.formatString;
                    var maxValue = Math.max(d3.min(values[0].values));
                    var minValue = Math.min(0, d3.min(values[0].values));
                    var labelFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(values[0].source, formatStringProp),
                        precision: labelSettings.precision,
                        value: (labelSettings.displayUnits === 0) && (maxValue != null) ? maxValue : labelSettings.displayUnits,
                    });
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(catSource, formatStringProp);
                    var fontSizeInPx = PixelConverter.fromPoint(labelSettings.fontSize);
                    for (var i = 0; i < catValues.length; i++) {
                        var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString);
                        var currentValue = values[0].values[i];
                        var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, currentValue, null, null, 0);
                        if (values.length > 1) {
                            var toolTip = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, values[1].values[i], null, null, 1)[1];
                            if (toolTip)
                                tooltipInfo.push(toolTip);
                            currentValue += values[1].values[i];
                        }
                        var identity = cat.identity[i];
                        var color = colorHelper.getColorForMeasure(catObjects && catObjects[i], identity.key);
                        var selector = visuals.SelectionId.createWithId(identity);
                        var sliceWidth = Math.max(0, values.length > 1 ? values[1].values[i] : 1);
                        asterDataResult.dataPoints.push({
                            sliceHeight: values[0].values[i] - minValue,
                            sliceWidth: sliceWidth,
                            label: labelFormatter.format(currentValue),
                            color: color,
                            identity: selector,
                            selected: false,
                            tooltipInfo: tooltipInfo,
                            labelFontSize: fontSizeInPx,
                            highlight: false,
                        });
                        // Handle legend data
                        if (asterDataResult.legendSettings.show)
                            asterDataResult.legendData.dataPoints.push({
                                label: catValues[i],
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                selected: false,
                                identity: selector
                            });
                        // Handle highlights
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(selector);
                            var notNull = values[0].highlights[i] != null;
                            currentValue = notNull ? values[0].highlights[i] : 0;
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, currentValue, null, null, 0);
                            if (values.length > 1) {
                                var toolTip = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, values[1].highlights[i], null, null, 1)[1];
                                if (toolTip)
                                    tooltipInfo.push(toolTip);
                                currentValue += values[1].highlights[i] !== null ? values[1].highlights[i] : 0;
                            }
                            asterDataResult.highlightedDataPoints.push({
                                sliceHeight: notNull ? values[0].highlights[i] - minValue : null,
                                sliceWidth: Math.max(0, (values.length > 1 && values[1].highlights[i] !== null) ? values[1].highlights[i] : sliceWidth),
                                label: labelFormatter.format(currentValue),
                                color: color,
                                identity: highlightIdentity,
                                selected: false,
                                tooltipInfo: tooltipInfo,
                                labelFontSize: fontSizeInPx,
                                highlight: true,
                            });
                        }
                    }
                    return asterDataResult;
                };
                AsterPlot.prototype.dataViewContainsCategory = function (dataView) {
                    return dataView &&
                        dataView.categorical &&
                        dataView.categorical.values &&
                        dataView.categorical.categories &&
                        dataView.categorical.categories[0];
                };
                AsterPlot.prototype.getLabelSettings = function (objects, labelSettings) {
                    var asterPlotLabelsProperties = AsterPlot.Properties;
                    var precision = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.labelPrecision, labelSettings.precision);
                    labelSettings.precision = precision === undefined ? precision : Math.min(precision, MaxPrecision);
                    labelSettings.show = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.show, labelSettings.show);
                    labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.fontSize, labelSettings.fontSize);
                    labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, asterPlotLabelsProperties.labels.labelDisplayUnits, labelSettings.displayUnits);
                    var colorHelper = new visuals.ColorHelper(this.colors, asterPlotLabelsProperties.labels.color, labelSettings.labelColor);
                    labelSettings.labelColor = colorHelper.getColorForMeasure(objects, "");
                    return labelSettings;
                };
                AsterPlot.prototype.updateLegendSettings = function (objects, catSource, legendSettings) {
                    var legendProperties = AsterPlot.Properties.legend;
                    legendSettings.show = powerbi.DataViewObjects.getValue(objects, legendProperties.show, legendSettings.show);
                    legendSettings.position = powerbi.DataViewObjects.getValue(objects, legendProperties.position, legendSettings.position);
                    legendSettings.showTitle = powerbi.DataViewObjects.getValue(objects, legendProperties.showTitle, legendSettings.showTitle);
                    var titleText = powerbi.DataViewObjects.getValue(objects, legendProperties.titleText, '');
                    legendSettings.titleText = _.isEmpty(titleText) && catSource ? catSource.displayName : titleText;
                    legendSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, legendProperties.labelColor, legendSettings.labelColor);
                    legendSettings.fontSize = powerbi.DataViewObjects.getValue(objects, legendProperties.fontSize, legendSettings.fontSize);
                };
                AsterPlot.prototype.init = function (options) {
                    this.hostService = options.host;
                    var element = options.element;
                    var svg = this.svg = d3.select(element.get(0))
                        .append('svg')
                        .classed(AsterPlotVisualClassName, true)
                        .style('position', 'absolute');
                    this.colors = options.style.colorPalette.dataColors;
                    this.mainGroupElement = svg.append('g');
                    this.mainLabelsElement = svg.append('g');
                    this.behavior = new AsterPlotWebBehavior();
                    this.clearCatcher = visuals.appendClearCatcher(this.mainGroupElement);
                    var interactivity = options.interactivity;
                    this.interactivityService = visuals.createInteractivityService(this.hostService);
                    this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);
                };
                AsterPlot.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0])
                        return; // or clear the view, display an error, etc.
                    var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                    this.currentViewport = {
                        height: Math.max(0, options.viewport.height),
                        width: Math.max(0, options.viewport.width)
                    };
                    var dataView = this.dataView = options.dataViews[0];
                    var convertedData = this.data = this.converter(dataView, this.colors);
                    if (!convertedData || !convertedData.dataPoints || convertedData.dataPoints.length === 0) {
                        this.clearData();
                        return;
                    }
                    if (this.interactivityService) {
                        this.interactivityService.applySelectionStateToData(convertedData.dataPoints);
                        this.interactivityService.applySelectionStateToData(convertedData.highlightedDataPoints);
                    }
                    this.renderLegend(convertedData);
                    this.updateViewPortAccordingToLegend();
                    this.svg
                        .attr({
                        height: Math.max(0, this.currentViewport.height),
                        width: Math.max(0, this.currentViewport.width)
                    });
                    var margin = this.margin;
                    var transformX = (this.currentViewport.width - margin.left) / 2;
                    var transformY = (this.currentViewport.height - margin.top) / 2;
                    this.mainGroupElement.attr('transform', visuals.SVGUtil.translate(transformX, transformY));
                    this.mainLabelsElement.attr('transform', visuals.SVGUtil.translate(transformX, transformY));
                    // Move back the clearCatcher
                    this.clearCatcher.attr('transform', visuals.SVGUtil.translate(-transformX, -transformY));
                    // Clear previous data
                    this.mainGroupElement.selectAll(AsterPlot.AsterSlice.selector).remove();
                    this.mainGroupElement.selectAll(AsterPlot.AsterHighlightedSlice.selector).remove();
                    visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);
                    var dataPoints = convertedData.dataPoints;
                    if (!dataPoints || dataPoints.length === 0)
                        return;
                    var selection = this.renderArcsAndLabels(dataPoints, duration, convertedData.labelSettings);
                    var highlightedSelection;
                    if (this.hasHighlights)
                        highlightedSelection = this.renderArcsAndLabels(convertedData.highlightedDataPoints, duration, convertedData.labelSettings, true);
                    var interactivityService = this.interactivityService;
                    if (interactivityService) {
                        var behaviorOptions = {
                            selection: selection,
                            highlightedSelection: highlightedSelection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService,
                        };
                        interactivityService.bind(convertedData.dataPoints.concat(convertedData.highlightedDataPoints), this.behavior, behaviorOptions);
                    }
                };
                AsterPlot.prototype.renderArcsAndLabels = function (dataPoints, duration, labelSettings, isHighlight) {
                    if (isHighlight === void 0) { isHighlight = false; }
                    var margin = this.margin;
                    var width = this.currentViewport.width - margin.left - margin.right;
                    var height = this.currentViewport.height - margin.top - margin.bottom;
                    var radius = Math.min(width, height) / 2;
                    var innerRadius = 0.3 * (labelSettings.show ? radius * AsterRadiusRatio : radius);
                    var maxScore = d3.max(dataPoints, function (d) { return d.sliceHeight; });
                    var totalWeight = d3.sum(dataPoints, function (d) { return d.sliceWidth; });
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                    var hasHighlights = this.hasHighlights;
                    var pie = d3.layout.pie()
                        .sort(null)
                        .value(function (d) { return (d && !isNaN(d.sliceWidth) ? d.sliceWidth : 0) / totalWeight; });
                    var arc = d3.svg.arc()
                        .innerRadius(innerRadius)
                        .outerRadius(function (d) {
                        var height = (radius - innerRadius) * (d && d.data && !isNaN(d.data.sliceHeight) ? d.data.sliceHeight : 1) / maxScore;
                        //The chart should shrink if data labels are on
                        var heightIsLabelsOn = innerRadius + (labelSettings.show ? height * AsterRadiusRatio : height);
                        // Prevent from data to be inside the inner radius
                        return Math.max(heightIsLabelsOn, innerRadius);
                    });
                    var arcDescriptorDataPoints = pie(dataPoints);
                    var classSelector = isHighlight ? AsterPlot.AsterHighlightedSlice : AsterPlot.AsterSlice;
                    var selection = this.mainGroupElement.selectAll(classSelector.selector)
                        .data(arcDescriptorDataPoints, function (d, idx) { return d.data ? d.data.identity.getKey() : idx; });
                    selection.enter()
                        .append('path')
                        .attr('stroke', '#333')
                        .classed(classSelector.class, true);
                    selection
                        .attr('fill', function (d) { return d.data.color; })
                        .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, d.data.highlight, hasSelection, hasHighlights); })
                        .transition().duration(duration)
                        .attrTween('d', function (data) {
                        if (!this.oldData) {
                            this.oldData = data;
                            return function () { return arc(data); };
                        }
                        var interpolation = d3.interpolate(this.oldData, data);
                        this.oldData = interpolation(0);
                        return function (x) { return arc(interpolation(x)); };
                    });
                    selection
                        .exit()
                        .remove();
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    // Draw data labels only if they are on and there are no highlights or there are highlights and this is the highlighted data labels
                    if (labelSettings.show && (!hasHighlights || (hasHighlights && isHighlight))) {
                        var labelRadCalc_1 = function (d) {
                            var height = radius * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore + innerRadius;
                            return Math.max(height, innerRadius);
                        };
                        var labelArc = d3.svg.arc()
                            .innerRadius(function (d) { return labelRadCalc_1(d.data); })
                            .outerRadius(function (d) { return labelRadCalc_1(d.data); });
                        var lineRadCalc_1 = function (d) {
                            var height = (radius - innerRadius) * (d && !isNaN(d.sliceHeight) ? d.sliceHeight : 1) / maxScore;
                            height = innerRadius + height * AsterRadiusRatio;
                            return Math.max(height, innerRadius);
                        };
                        var outlineArc = d3.svg.arc()
                            .innerRadius(function (d) { return lineRadCalc_1(d.data); })
                            .outerRadius(function (d) { return lineRadCalc_1(d.data); });
                        var layout = this.getLabelLayout(labelSettings, labelArc, this.currentViewport);
                        this.drawLabels(arcDescriptorDataPoints, this.mainLabelsElement, layout, this.currentViewport, outlineArc, labelArc);
                    }
                    else
                        visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);
                    // Draw center text and outline once for original data points
                    if (!isHighlight) {
                        this.drawCenterText(innerRadius);
                        this.drawOuterLine(innerRadius, radius, arcDescriptorDataPoints);
                    }
                    return selection;
                };
                AsterPlot.prototype.getLabelLayout = function (labelSettings, arc, viewport) {
                    var midAngle = function (d) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };
                    var textProperties = {
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                        text: '',
                    };
                    var isLabelsHasConflict = function (d) {
                        var pos = arc.centroid(d);
                        textProperties.text = d.data.label;
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                        var horizontalSpaceAvaliableForLabels = viewport.width / 2 - Math.abs(pos[0]);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                        var verticalSpaceAvaliableForLabels = viewport.height / 2 - Math.abs(pos[1]);
                        d.isLabelHasConflict = textWidth > horizontalSpaceAvaliableForLabels || textHeight > verticalSpaceAvaliableForLabels;
                        return d.isLabelHasConflict;
                    };
                    return {
                        labelText: function (d) {
                            textProperties.text = d.data.label;
                            var pos = arc.centroid(d);
                            var xPos = isLabelsHasConflict(d) ? pos[0] * AsterConflictRatio : pos[0];
                            var spaceAvaliableForLabels = viewport.width / 2 - Math.abs(xPos);
                            return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
                        },
                        labelLayout: {
                            x: function (d) {
                                var pos = arc.centroid(d);
                                textProperties.text = d.data.label;
                                var xPos = d.isLabelHasConflict ? pos[0] * AsterConflictRatio : pos[0];
                                return xPos;
                            },
                            y: function (d) {
                                var pos = arc.centroid(d);
                                var yPos = d.isLabelHasConflict ? pos[1] * AsterConflictRatio : pos[1];
                                return yPos;
                            },
                        },
                        filter: function (d) { return (d != null && !_.isEmpty(d.data.label)); },
                        style: {
                            'fill': labelSettings.labelColor,
                            'font-size': textProperties.fontSize,
                            'text-anchor': function (d) { return midAngle(d) < Math.PI ? 'start' : 'end'; },
                        },
                    };
                };
                AsterPlot.prototype.drawLabels = function (data, context, layout, viewport, outlineArc, labelArc) {
                    var _this = this;
                    // Hide and reposition labels that overlap
                    var dataLabelManager = new powerbi.DataLabelManager();
                    var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, true /* addTransform */);
                    if (filteredData.length === 0) {
                        visuals.dataLabelUtils.cleanDataLabels(context, true);
                        return;
                    }
                    // Draw labels
                    if (context.select(AsterPlot.labelGraphicsContextClass.selector).empty())
                        context.append('g').classed(AsterPlot.labelGraphicsContextClass.class, true);
                    var labels = context
                        .select(AsterPlot.labelGraphicsContextClass.selector)
                        .selectAll('.data-labels').data(filteredData, function (d) { return d.data.identity.getKey(); });
                    labels.enter().append('text').classed('data-labels', true);
                    if (!labels)
                        return;
                    labels
                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; }, dy: '.35em' })
                        .text(function (d) { return d.labeltext; })
                        .style(layout.style);
                    labels
                        .exit()
                        .remove();
                    // Draw lines
                    if (context.select(AsterPlot.linesGraphicsContextClass.selector).empty())
                        context.append('g').classed(AsterPlot.linesGraphicsContextClass.class, true);
                    // Remove lines for null and zero values
                    filteredData = _.filter(filteredData, function (d) { return d.data.sliceHeight !== null && d.data.sliceHeight !== 0; });
                    var lines = context.select(AsterPlot.linesGraphicsContextClass.selector).selectAll('polyline')
                        .data(filteredData, function (d) { return d.data.identity.getKey(); });
                    var labelLinePadding = 4;
                    var chartLinePadding = 1.02;
                    var midAngle = function (d) { return d.startAngle + (d.endAngle - d.startAngle) / 2; };
                    lines.enter()
                        .append('polyline')
                        .classed('line-label', true);
                    lines
                        .attr('points', function (d) {
                        var textPoint = [d.labelX, d.labelY];
                        textPoint[0] = textPoint[0] + ((midAngle(d) < Math.PI ? -1 : 1) * labelLinePadding);
                        var chartPoint = outlineArc.centroid(d);
                        chartPoint[0] *= chartLinePadding;
                        chartPoint[1] *= chartLinePadding;
                        return [chartPoint, textPoint];
                    }).
                        style({
                        'opacity': 0.5,
                        'fill-opacity': 0,
                        'stroke': function (d) { return _this.data.labelSettings.labelColor; },
                    });
                    lines
                        .exit()
                        .remove();
                };
                AsterPlot.prototype.renderLegend = function (asterPlotData) {
                    if (!asterPlotData || !asterPlotData.legendData)
                        return;
                    var legendData = asterPlotData.legendData;
                    var objects = this.dataView && this.dataView.metadata ? this.dataView.metadata.objects : null;
                    var legendObjectProperties = powerbi.DataViewObjects.getObject(objects, AsterPlotLegendObjectName, {});
                    if (legendObjectProperties) {
                        var legendSettings = asterPlotData.legendSettings;
                        // Force update for title text
                        legendObjectProperties['titleText'] = legendSettings.titleText;
                        visuals.LegendData.update(legendData, legendObjectProperties);
                        this.legend.changeOrientation(visuals.LegendPosition[legendSettings.position]);
                    }
                    this.legend.drawLegend(legendData, _.clone(this.currentViewport));
                    visuals.Legend.positionChartArea(this.svg, this.legend);
                };
                AsterPlot.prototype.updateViewPortAccordingToLegend = function () {
                    var legendSettings = this.data.legendSettings;
                    if (!legendSettings || !legendSettings.show)
                        return;
                    var legendMargins = this.legend.getMargins();
                    var legendPosition = visuals.LegendPosition[legendSettings.position];
                    switch (legendPosition) {
                        case visuals.LegendPosition.Top:
                        case visuals.LegendPosition.TopCenter:
                        case visuals.LegendPosition.Bottom:
                        case visuals.LegendPosition.BottomCenter: {
                            this.currentViewport.height -= legendMargins.height;
                            break;
                        }
                        case visuals.LegendPosition.Left:
                        case visuals.LegendPosition.LeftCenter:
                        case visuals.LegendPosition.Right:
                        case visuals.LegendPosition.RightCenter: {
                            this.currentViewport.width -= legendMargins.width;
                            break;
                        }
                        default:
                            break;
                    }
                };
                AsterPlot.prototype.drawOuterLine = function (innerRadius, radius, data) {
                    var mainGroup = this.mainGroupElement;
                    var outlineArc = d3.svg.arc()
                        .innerRadius(innerRadius)
                        .outerRadius(radius);
                    if (this.data.showOuterLine) {
                        var OuterThickness = this.data.outerLineThickness + 'px';
                        var outerLine = mainGroup.selectAll(AsterPlot.OuterLine.selector).data(data);
                        outerLine.enter().append('path');
                        outerLine.attr("fill", "none")
                            .attr({
                            'stroke': '#333',
                            'stroke-width': OuterThickness,
                            'd': outlineArc
                        })
                            .style('opacity', 1)
                            .classed(AsterPlot.OuterLine.class, true);
                        outerLine.exit().remove();
                    }
                    else
                        mainGroup.selectAll(AsterPlot.OuterLine.selector).remove();
                };
                AsterPlot.prototype.getCenterText = function (dataView) {
                    if (dataView && dataView.metadata && dataView.metadata.columns && dataView.categorical && dataView.categorical.values)
                        for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                            var column = _a[_i];
                            if (!column.isMeasure)
                                return column.displayName;
                        }
                    return '';
                };
                AsterPlot.prototype.drawCenterText = function (innerRadius) {
                    var text = this.getCenterText(this.dataView);
                    if (_.isEmpty(text)) {
                        this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).remove();
                        return;
                    }
                    var centerTextProperties = {
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontWeight: 'bold',
                        fontSize: PixelConverter.toString(innerRadius * AsterPlot.CenterTextFontHeightCoefficient),
                        text: text
                    };
                    if (this.mainGroupElement.select(AsterPlot.CenterLabelClass.selector).empty())
                        this.centerText = this.mainGroupElement.append('text').classed(AsterPlot.CenterLabelClass.class, true);
                    this.centerText
                        .style({
                        'line-height': 1,
                        'font-weight': centerTextProperties.fontWeight,
                        'font-size': centerTextProperties.fontSize,
                        'fill': this.getLabelFill(this.dataView).solid.color
                    })
                        .attr({
                        'dy': '0.35em',
                        'text-anchor': 'middle'
                    })
                        .text(powerbi.TextMeasurementService.getTailoredTextOrDefault(centerTextProperties, innerRadius * AsterPlot.CenterTextFontWidthCoefficient));
                };
                // This extracts fill color of the label from the DataView
                AsterPlot.prototype.getLabelFill = function (dataView) {
                    if (this.dataViewContainsObjects(dataView))
                        return powerbi.DataViewObjects.getValue(dataView.metadata.objects, AsterPlot.Properties.label.fill, AsterDefaultLabelFill);
                    return AsterDefaultLabelFill;
                };
                AsterPlot.prototype.dataViewContainsObjects = function (dataView) {
                    return dataView && dataView.metadata && dataView.metadata.objects;
                };
                AsterPlot.prototype.enumerateLegend = function (instances) {
                    var legendSettings = this.data.legendSettings;
                    var instance = {
                        selector: null,
                        objectName: AsterPlotLegendObjectName,
                        displayName: 'Legend',
                        properties: {
                            show: legendSettings.show,
                            position: legendSettings.position,
                            showTitle: legendSettings.showTitle,
                            titleText: legendSettings.titleText,
                            labelColor: legendSettings.labelColor,
                            fontSize: legendSettings.fontSize,
                        }
                    };
                    instances.push(instance);
                };
                AsterPlot.prototype.clearData = function () {
                    this.mainGroupElement.selectAll("path").remove();
                    visuals.dataLabelUtils.cleanDataLabels(this.mainLabelsElement, true);
                    this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);
                };
                AsterPlot.prototype.onClearSelection = function () {
                    if (this.interactivityService)
                        this.interactivityService.clearSelection();
                };
                AsterPlot.prototype.enumerateLabels = function (instances) {
                    var labelSettings = this.data.labelSettings;
                    var labels = {
                        objectName: 'labels',
                        displayName: 'Labels',
                        selector: null,
                        properties: {
                            show: labelSettings.show,
                            fontSize: labelSettings.fontSize,
                            labelPrecision: labelSettings.precision,
                            labelDisplayUnits: labelSettings.displayUnits,
                            color: labelSettings.labelColor,
                        }
                    };
                    instances.push(labels);
                };
                // This function retruns the values to be displayed in the property pane for each object.
                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do
                // validation and return other values/defaults
                AsterPlot.prototype.enumerateObjectInstances = function (options) {
                    var instances = [];
                    if (!this.dataViewContainsCategory(this.dataView))
                        return instances;
                    switch (options.objectName) {
                        case AsterPlotLegendObjectName:
                            if (this.data)
                                this.enumerateLegend(instances);
                            break;
                        case 'label':
                            var label = {
                                objectName: 'label',
                                displayName: 'Label',
                                selector: null,
                                properties: {
                                    fill: this.getLabelFill(this.dataView)
                                }
                            };
                            instances.push(label);
                            break;
                        case 'labels':
                            this.enumerateLabels(instances);
                            break;
                        case 'outerLine':
                            var outerLine = {
                                objectName: 'outerLine',
                                displayName: 'Outer Line',
                                selector: null,
                                properties: {
                                    show: this.data.showOuterLine,
                                    thickness: this.data.outerLineThickness,
                                }
                            };
                            instances.push(outerLine);
                            break;
                    }
                    return instances;
                };
                AsterPlot.capabilities = {
                    dataRoles: [
                        {
                            displayName: 'Category',
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                        },
                        {
                            displayName: 'Y Axis',
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                        },
                    ],
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Y': { max: 2 } }
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [{ bind: { to: 'Y' } }]
                                },
                            }
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        legend: {
                            displayName: 'Legend',
                            description: 'Display legend options',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: 'Position',
                                    description: 'Select the location for the legend',
                                    type: { enumeration: visuals.legendPosition.type }
                                },
                                showTitle: {
                                    displayName: 'Title',
                                    description: 'Display a title for legend symbols',
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: 'Legend Name',
                                    description: 'Title text',
                                    type: { text: true },
                                    suppressFormatPainterCopy: true
                                },
                                labelColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        label: {
                            displayName: 'Center Label',
                            properties: {
                                fill: {
                                    displayName: 'Fill',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        labels: {
                            displayName: 'Detail Labels',
                            properties: {
                                show: {
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                labelDisplayUnits: {
                                    displayName: 'Display Units',
                                    type: { formatting: { labelDisplayUnits: true } },
                                },
                                labelPrecision: {
                                    displayName: 'Decimal Places',
                                    placeHolderText: 'Auto',
                                    type: { numeric: true },
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } },
                                },
                            },
                        },
                        outerLine: {
                            displayName: 'Outer line',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                thickness: {
                                    displayName: 'Thickness',
                                    type: { numeric: true }
                                }
                            }
                        }
                    },
                    supportsHighlight: true,
                };
                AsterPlot.Properties = {
                    general: {
                        formatString: { objectName: 'general', propertyName: 'formatString' },
                    },
                    dataPoint: {
                        fill: { objectName: 'dataPoint', propertyName: 'fill' },
                    },
                    legend: {
                        show: { objectName: AsterPlotLegendObjectName, propertyName: 'show' },
                        position: { objectName: AsterPlotLegendObjectName, propertyName: 'position' },
                        showTitle: { objectName: AsterPlotLegendObjectName, propertyName: 'showTitle' },
                        titleText: { objectName: AsterPlotLegendObjectName, propertyName: 'titleText' },
                        labelColor: { objectName: AsterPlotLegendObjectName, propertyName: 'labelColor' },
                        fontSize: { objectName: AsterPlotLegendObjectName, propertyName: 'fontSize' },
                    },
                    label: {
                        fill: { objectName: 'label', propertyName: 'fill' },
                    },
                    labels: {
                        show: { objectName: 'labels', propertyName: 'show' },
                        color: { objectName: 'labels', propertyName: 'color' },
                        labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                        labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
                        fontSize: { objectName: 'labels', propertyName: 'fontSize' },
                    },
                    outerLine: {
                        show: { objectName: 'outerLine', propertyName: 'show' },
                        thickness: { objectName: 'outerLine', propertyName: 'thickness' },
                    }
                };
                AsterPlot.AsterSlice = createClassAndSelector('asterSlice');
                AsterPlot.AsterHighlightedSlice = createClassAndSelector('asterHighlightedSlice');
                AsterPlot.OuterLine = createClassAndSelector('outerLine');
                AsterPlot.labelGraphicsContextClass = createClassAndSelector('labels');
                AsterPlot.linesGraphicsContextClass = createClassAndSelector('lines');
                AsterPlot.CenterLabelClass = createClassAndSelector('centerLabel');
                AsterPlot.CenterTextFontHeightCoefficient = 0.4;
                AsterPlot.CenterTextFontWidthCoefficient = 1.9;
                return AsterPlot;
            }());
            samples.AsterPlot = AsterPlot;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var PixelConverter = jsCommon.PixelConverter;
            var TornadoWebBehavior = (function () {
                function TornadoWebBehavior() {
                }
                TornadoWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    this.columns = options.columns;
                    this.clearCatcher = options.clearCatcher;
                    this.interactivityService = options.interactivityService;
                    this.columns.on('click', function (d, i) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    });
                    this.clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                TornadoWebBehavior.prototype.renderSelection = function (hasSelection) {
                    var hasHighlights = this.interactivityService.hasSelection();
                    this.columns.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });
                };
                return TornadoWebBehavior;
            }());
            var TornadoChartScrolling = (function () {
                function TornadoChartScrolling(getRoot, getViewport, getMargin, isScrollable) {
                    this.scrollYBrush = d3.svg.brush();
                    this.getRoot = getRoot;
                    this.getViewport = getViewport;
                    this.isScrollable = isScrollable;
                }
                Object.defineProperty(TornadoChartScrolling.prototype, "root", {
                    get: function () {
                        return this.getRoot();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TornadoChartScrolling.prototype, "viewport", {
                    get: function () {
                        return this.getViewport();
                    },
                    enumerable: true,
                    configurable: true
                });
                TornadoChartScrolling.prototype.renderY = function (data, prefferedHeight, onScroll) {
                    var _this = this;
                    this.isYScrollBarVisible = prefferedHeight > this.viewport.height
                        && this.viewport.height > 0
                        && this.viewport.width > 0;
                    this.brushGraphicsContextY = this.createOrRemoveScrollbar(this.isYScrollBarVisible, this.brushGraphicsContextY, 'y brush');
                    this.updateScrollViewport();
                    if (!this.isYScrollBarVisible) {
                        onScroll.call(this, jQuery.extend(true, {}, data), 0, 1);
                        return;
                    }
                    var scrollSpaceLength = this.viewport.height;
                    var extentData = this.getExtentData(prefferedHeight, scrollSpaceLength);
                    var onRender = function (wheelDelta) {
                        if (wheelDelta === void 0) { wheelDelta = 0; }
                        var position = _this.scrollYBrush.extent();
                        if (wheelDelta !== 0) {
                            // Handle mouse wheel manually by moving the scrollbar half of its size
                            var halfScrollsize = (position[1] - position[0]) / 2;
                            position[0] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;
                            position[1] += (wheelDelta > 0) ? halfScrollsize : -halfScrollsize;
                            if (position[0] < 0) {
                                var offset = 0 - position[0];
                                position[0] += offset;
                                position[1] += offset;
                            }
                            if (position[1] > scrollSpaceLength) {
                                var offset = position[1] - scrollSpaceLength;
                                position[0] -= offset;
                                position[1] -= offset;
                            }
                            // Update the scroll bar accordingly and redraw
                            _this.scrollYBrush.extent(position);
                            _this.brushGraphicsContextY.select('.extent').attr('y', position[0]);
                        }
                        var scrollPosition = extentData.toScrollPosition(position, scrollSpaceLength);
                        onScroll.call(_this, jQuery.extend(true, {}, data), scrollPosition[0], scrollPosition[1]);
                        _this.setScrollBarSize(_this.brushGraphicsContextY, extentData.value[1], true);
                    };
                    var scrollYScale = d3.scale.ordinal().rangeBands([0, scrollSpaceLength]);
                    this.scrollYBrush.y(scrollYScale).extent(extentData.value);
                    this.renderScrollbar(this.scrollYBrush, this.brushGraphicsContextY, this.viewport.width, onRender);
                    onRender();
                };
                TornadoChartScrolling.prototype.updateScrollViewport = function () {
                    this.scrollViewport = { height: this.viewport.height, width: this.viewport.width };
                    if (this.isYScrollBarVisible && this.isScrollable) {
                        this.scrollViewport.width -= TornadoChart.ScrollBarWidth;
                    }
                };
                TornadoChartScrolling.prototype.createOrRemoveScrollbar = function (isVisible, brushGraphicsContext, brushClass) {
                    if (isVisible && this.isScrollable) {
                        return brushGraphicsContext || this.root.append("g").classed(brushClass, true);
                    }
                    return brushGraphicsContext ? void brushGraphicsContext.remove() : undefined;
                };
                TornadoChartScrolling.prototype.renderScrollbar = function (brush, brushGraphicsContext, brushX, onRender) {
                    var _this = this;
                    brush.on("brush", function () { return window.requestAnimationFrame(function () { return onRender(0); }); });
                    this.root.on('wheel', function () {
                        if (!_this.isYScrollBarVisible)
                            return;
                        var wheelEvent = d3.event; // Casting to any to avoid compilation errors
                        onRender(wheelEvent.deltaY);
                    });
                    brushGraphicsContext.attr({
                        "transform": visuals.SVGUtil.translate(brushX, 0),
                        "drag-resize-disabled": "true" /*disables resizing of the visual when dragging the scrollbar in edit mode*/
                    });
                    brushGraphicsContext.call(brush); /*call the brush function, causing it to create the rectangles   */
                    /* Disabling the zooming feature */
                    brushGraphicsContext.selectAll(".resize").remove();
                    brushGraphicsContext.select(".background").remove();
                    brushGraphicsContext.selectAll(".extent").style({
                        "fill-opacity": 0.125,
                        "cursor": "default",
                    });
                };
                TornadoChartScrolling.prototype.setScrollBarSize = function (brushGraphicsContext, minExtent, isVertical) {
                    brushGraphicsContext.selectAll("rect").attr(isVertical ? "width" : "height", TornadoChart.ScrollBarWidth);
                    brushGraphicsContext.selectAll("rect").attr(isVertical ? "height" : "width", minExtent);
                };
                TornadoChartScrolling.prototype.getExtentData = function (svgLength, scrollSpaceLength) {
                    var value = scrollSpaceLength * scrollSpaceLength / svgLength;
                    var scaleMultipler = TornadoChartScrolling.ScrollBarMinLength <= value
                        ? 1
                        : value / TornadoChartScrolling.ScrollBarMinLength;
                    value = Math.max(value, TornadoChartScrolling.ScrollBarMinLength);
                    var toScrollPosition = function (extent, scrollSpaceLength) {
                        var scrollSize = extent[1] - extent[0];
                        var scrollPosition = extent[0] / (scrollSpaceLength - scrollSize);
                        scrollSize *= scaleMultipler;
                        var start = (scrollPosition * (scrollSpaceLength - scrollSize));
                        var end = (start + scrollSize);
                        return [start / scrollSpaceLength, end / scrollSpaceLength];
                    };
                    return { value: [0, value], toScrollPosition: toScrollPosition };
                };
                TornadoChartScrolling.prototype.clearData = function () {
                    if (this.brushGraphicsContextY)
                        this.brushGraphicsContextY.selectAll("*").remove();
                };
                TornadoChartScrolling.ScrollBarMinLength = 15;
                return TornadoChartScrolling;
            }());
            var TornadoChartWarning = (function () {
                function TornadoChartWarning() {
                }
                Object.defineProperty(TornadoChartWarning.prototype, "code", {
                    get: function () {
                        return "TornadoChartWarning";
                    },
                    enumerable: true,
                    configurable: true
                });
                TornadoChartWarning.prototype.getMessages = function (resourceProvider) {
                    var message = "This visual requires two distinct values to be returned for the Legend field.", titleKey = "", detailKey = "", visualMessage;
                    visualMessage = {
                        message: message,
                        title: resourceProvider.get(titleKey),
                        detail: resourceProvider.get(detailKey)
                    };
                    return visualMessage;
                };
                return TornadoChartWarning;
            }());
            samples.TornadoChartWarning = TornadoChartWarning;
            function getTornadoChartWarning() {
                return new TornadoChartWarning();
            }
            samples.getTornadoChartWarning = getTornadoChartWarning;
            var TornadoChart = (function () {
                function TornadoChart(tornadoChartConstructorOptions) {
                    this.DefaultTornadoChartSettings = {
                        labelOutsideFillColor: visuals.dataLabelUtils.defaultLabelColor,
                        labelSettings: {
                            show: true,
                            precision: null,
                            fontSize: TornadoChart.DefaultFontSize,
                            displayUnits: 0,
                            labelColor: visuals.dataLabelUtils.defaultInsideLabelColor,
                        },
                        showCategories: true,
                        showLegend: true,
                        legendFontSize: TornadoChart.DefaultLegendFontSize,
                        legendColor: visuals.LegendData.DefaultLegendLabelFillColor,
                        categoriesFillColor: "#777"
                    };
                    this.DefaultFillColors = [
                        "purple", "teal"
                    ];
                    this.columnPadding = 5;
                    this.leftLabelMargin = 4;
                    this.InnerTextHeightDelta = 2;
                    this.textOptions = {};
                    this.margin = {
                        top: 10,
                        right: 5,
                        bottom: 10,
                        left: 10
                    };
                    this.heightColumn = 0;
                    this.widthLeftSection = 0;
                    this.widthRightSection = 0;
                    if (tornadoChartConstructorOptions) {
                        this.svg = tornadoChartConstructorOptions.svg || this.svg;
                        this.margin = tornadoChartConstructorOptions.margin || this.margin;
                        this.columnPadding = tornadoChartConstructorOptions.columnPadding || this.columnPadding;
                        this.animator = tornadoChartConstructorOptions.animator;
                    }
                }
                TornadoChart.prototype.init = function (visualInitOptions) {
                    var _this = this;
                    var style = visualInitOptions.style, fontSize;
                    this.hostService = visualInitOptions.host;
                    var element = visualInitOptions.element;
                    this.colors = style.colorPalette.dataColors;
                    var interactivity = visualInitOptions.interactivity;
                    this.interactivityService = visuals.createInteractivityService(this.hostService);
                    var root;
                    if (this.svg)
                        this.root = root = this.svg;
                    else
                        this.root = root = d3.select(element.get(0))
                            .append("svg");
                    root
                        .classed(TornadoChart.ClassName, true)
                        .style('position', 'absolute');
                    fontSize = root.style("font-size");
                    this.textOptions.sizeUnit = fontSize.slice(fontSize.length - 2);
                    this.textOptions.fontSize = Number(fontSize.slice(0, fontSize.length - 2));
                    this.textOptions.fontFamily = root.style("font-family");
                    this.scrolling = new TornadoChartScrolling(function () { return root; }, function () { return _this.viewport; }, function () { return _this.margin; }, true);
                    var main = this.main = root.append("g");
                    this.clearCatcher = visuals.appendClearCatcher(main);
                    this.columns = main
                        .append("g")
                        .classed(TornadoChart.Columns.class, true);
                    this.axes = main
                        .append("g")
                        .classed(TornadoChart.Axes.class, true);
                    this.labels = main
                        .append("g")
                        .classed(TornadoChart.Labels.class, true);
                    this.categories = main
                        .append("g")
                        .classed(TornadoChart.Categories.class, true);
                    this.behavior = new TornadoWebBehavior();
                    this.defaultTornadoChartDataView = {
                        categories: [],
                        series: [],
                        settings: null,
                        legend: null,
                        dataPoints: [],
                        highlightedDataPoints: [],
                    };
                    this.legend = visuals.createLegend(element, interactivity && interactivity.isInteractiveLegend, this.interactivityService, true);
                };
                TornadoChart.prototype.update = function (visualUpdateOptions) {
                    if (!visualUpdateOptions ||
                        !visualUpdateOptions.dataViews ||
                        !visualUpdateOptions.dataViews[0]) {
                        return;
                    }
                    this.viewport = {
                        height: Math.max(0, visualUpdateOptions.viewport.height - this.margin.top - this.margin.bottom),
                        width: Math.max(0, visualUpdateOptions.viewport.width - this.margin.left - this.margin.right)
                    };
                    if (this.animator)
                        this.durationAnimations = visuals.AnimatorCommon.GetAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);
                    else
                        this.durationAnimations = visualUpdateOptions.suppressAnimations ? 0 : 250;
                    this.tornadoChartDataView = this.converter(visualUpdateOptions.dataViews[0]);
                    if (this.interactivityService) {
                        this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.dataPoints);
                        this.interactivityService.applySelectionStateToData(this.tornadoChartDataView.highlightedDataPoints);
                    }
                    this.render();
                };
                TornadoChart.prototype.updateElements = function () {
                    var elementsTranslate = visuals.SVGUtil.translate(this.widthLeftSection, 0);
                    this.root.attr({
                        "height": this.viewport.height + this.margin.top + this.margin.bottom,
                        "width": this.viewport.width + this.margin.left + this.margin.right
                    });
                    this.columns
                        .attr("transform", elementsTranslate);
                    this.labels
                        .attr("transform", elementsTranslate);
                    this.axes
                        .attr("transform", elementsTranslate);
                };
                TornadoChart.prototype.converter = function (dataView) {
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[0].source ||
                        !dataView.categorical.values ||
                        !dataView.categorical.values[0]) {
                        return this.defaultTornadoChartDataView;
                    }
                    var categorical = dataView.categorical;
                    var categories = categorical.categories || [];
                    var values = categorical.values;
                    if (values.length > TornadoChart.MaxSeries) {
                        this.hostService.setWarnings([getTornadoChartWarning()]);
                        return this.defaultTornadoChartDataView;
                    }
                    var category = categories[0];
                    var categoryValues = category.values;
                    var categoryValuesLength = categoryValues.length;
                    var objects = this.getObjectsFromDataView(dataView);
                    var formatStringProp = TornadoChart.Properties.general.formatString;
                    var valuesSourceFormatString = visuals.valueFormatter.getFormatString(values[0].source, formatStringProp);
                    var maxValue = d3.max(values[0].values);
                    var settings = this.parseSettings(objects, valuesSourceFormatString, maxValue);
                    this.hasDynamicSeries = !!values.source;
                    var hasHighlights = this.hasHighlights = !!(values.length > 0 && values[0].highlights);
                    this.labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight({
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontSize: PixelConverter.fromPoint(settings.labelSettings.fontSize),
                    });
                    var series = [];
                    var dataPoints = [];
                    var highlightedDataPoints = [];
                    var categoriesLabels = [];
                    var groupedValues = [];
                    if (values.grouped)
                        groupedValues = values.grouped();
                    // Parse category labels and compute maximum category length
                    var maxCategoryLength = 0;
                    var showCategories = settings.showCategories;
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp);
                    for (var i = 0; i < categoryValuesLength; i++) {
                        var formattedCategoryValue = visuals.valueFormatter.format(categoryValues[i], categorySourceFormatString);
                        var textData = this.getTextData(formattedCategoryValue, true);
                        categoriesLabels.push(textData);
                        if (showCategories && textData.width > maxCategoryLength)
                            maxCategoryLength = textData.width;
                    }
                    var scrollBarWidth = (categoryValuesLength * TornadoChart.CategoryMinHeight > this.viewport.height) ? TornadoChart.ScrollBarWidth : 0;
                    this.widthLeftSection = maxCategoryLength + TornadoChart.LabelPadding;
                    var maxColumnWidth = this.widthRightSection = this.viewport.width - this.widthLeftSection - scrollBarWidth;
                    this.updateElements();
                    var minValue = Math.min(d3.min(values[0].values), 0);
                    if (values.length === TornadoChart.MaxSeries) {
                        minValue = d3.min([minValue, d3.min(values[1].values)]);
                        maxValue = d3.max([maxValue, d3.max(values[1].values)]);
                        maxColumnWidth = maxColumnWidth / TornadoChart.MaxSeries;
                    }
                    for (var seriesIndex = 0; seriesIndex < values.length; seriesIndex++) {
                        var parsedSeries = this.parseSeries(values, seriesIndex, this.hasDynamicSeries, groupedValues);
                        series.push(parsedSeries);
                        var currentSeries = values[seriesIndex];
                        var measureName = currentSeries.source.queryName;
                        for (var i = 0; i < categoryValuesLength; i++) {
                            var value = currentSeries.values[i] == null || isNaN(currentSeries.values[i]) ? 0 : currentSeries.values[i];
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(category, i)
                                .withSeries(values, currentSeries)
                                .withMeasure(measureName)
                                .createSelectionId();
                            var formattedCategoryValue = categoriesLabels[i].text;
                            var tooltipInfo = void 0;
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null);
                            // Limit maximum value with what the user choose
                            var currentMaxValue = parsedSeries.categoryAxisEnd ? Math.min(parsedSeries.categoryAxisEnd, maxValue) : maxValue;
                            var formatString = dataView.categorical.values[seriesIndex].source.format;
                            dataPoints.push({
                                value: value,
                                minValue: minValue,
                                maxValue: currentMaxValue,
                                formatString: formatString,
                                color: parsedSeries.fill,
                                selected: false,
                                identity: identity,
                                tooltipData: tooltipInfo,
                                categoryIndex: i,
                            });
                            if (hasHighlights) {
                                var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                                var highlight = currentSeries.highlights[i];
                                var highlightedValue = highlight != null ? highlight : 0;
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue);
                                highlightedDataPoints.push({
                                    value: highlightedValue,
                                    minValue: minValue,
                                    maxValue: currentMaxValue,
                                    formatString: formatString,
                                    color: parsedSeries.fill,
                                    selected: false,
                                    identity: highlightIdentity,
                                    tooltipData: tooltipInfo,
                                    categoryIndex: i,
                                    highlight: true,
                                });
                            }
                        }
                    }
                    return {
                        categories: categoriesLabels,
                        series: series,
                        settings: settings,
                        legend: this.getLegendData(series),
                        dataPoints: dataPoints,
                        highlightedDataPoints: highlightedDataPoints,
                    };
                };
                TornadoChart.prototype.parseSettings = function (objects, formatString, value) {
                    var precision = this.getPrecision(objects);
                    var displayUnits = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelDisplayUnits, this.DefaultTornadoChartSettings.labelSettings.displayUnits);
                    var labelSettings = this.DefaultTornadoChartSettings.labelSettings;
                    var labelValueFormatter = visuals.valueFormatter.create({
                        format: formatString,
                        precision: precision,
                        value: (displayUnits === 0) && (value != null) ? value : displayUnits,
                    });
                    return {
                        labelOutsideFillColor: this.getColor(TornadoChart.Properties.labels.outsideFill, this.DefaultTornadoChartSettings.labelOutsideFillColor, objects),
                        labelSettings: {
                            show: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.show, labelSettings.show),
                            precision: precision,
                            fontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.fontSize, labelSettings.fontSize),
                            displayUnits: displayUnits,
                            labelColor: this.getColor(TornadoChart.Properties.labels.insideFill, labelSettings.labelColor, objects),
                        },
                        showCategories: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.categories.show, this.DefaultTornadoChartSettings.showCategories),
                        showLegend: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.show, this.DefaultTornadoChartSettings.showLegend),
                        legendFontSize: powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.legend.fontSize, this.DefaultTornadoChartSettings.legendFontSize),
                        legendColor: this.getColor(TornadoChart.Properties.legend.labelColor, this.DefaultTornadoChartSettings.legendColor, objects),
                        categoriesFillColor: this.getColor(TornadoChart.Properties.categories.fill, this.DefaultTornadoChartSettings.categoriesFillColor, objects),
                        labelValueFormatter: labelValueFormatter
                    };
                };
                TornadoChart.prototype.getColor = function (properties, defaultColor, objects) {
                    var colorHelper = new visuals.ColorHelper(this.colors, properties, defaultColor);
                    return colorHelper.getColorForMeasure(objects, "");
                };
                TornadoChart.prototype.getPrecision = function (objects) {
                    var precision = powerbi.DataViewObjects.getValue(objects, TornadoChart.Properties.labels.labelPrecision, this.DefaultTornadoChartSettings.labelSettings.precision);
                    if (precision >= TornadoChart.MaxPrecision) {
                        return TornadoChart.MaxPrecision;
                    }
                    return precision;
                };
                TornadoChart.prototype.getObjectsFromDataView = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.objects) {
                        this.legendObjectProperties = {};
                        return null;
                    }
                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {});
                    return dataView.metadata.objects;
                };
                TornadoChart.prototype.parseSeries = function (dataViewValueColumns, index, isGrouped, grouped) {
                    var dataViewValueColumn = dataViewValueColumns[index];
                    var seriesGroup = isGrouped ? grouped[index] : grouped[0].values[index];
                    var source = dataViewValueColumn.source;
                    var selectionId = seriesGroup.identity
                        ? visuals.SelectionId.createWithId(seriesGroup.identity)
                        : visuals.SelectionIdBuilder.builder()
                            .withSeries(dataViewValueColumns, seriesGroup)
                            .withMeasure(source.queryName)
                            .createSelectionId();
                    var displayName = source.groupName ? source.groupName : source.displayName;
                    var objects;
                    var categoryAxisObject;
                    if (isGrouped) {
                        categoryAxisObject = seriesGroup.objects ? seriesGroup.objects['categoryAxis'] : null;
                        objects = seriesGroup.objects;
                    }
                    else {
                        objects = source.objects;
                        categoryAxisObject = objects ? objects['categoryAxis'] : null;
                    }
                    var color = this.getColor(TornadoChart.Properties.dataPoint.fill, this.DefaultFillColors[index], objects);
                    var categoryAxisEnd = categoryAxisObject ? categoryAxisObject['end'] : null;
                    return {
                        fill: color,
                        name: displayName,
                        selectionId: selectionId,
                        categoryAxisEnd: categoryAxisEnd,
                    };
                };
                TornadoChart.prototype.getLegendData = function (series) {
                    var legendDataPoints = [];
                    if (this.hasDynamicSeries)
                        legendDataPoints = series.map(function (series) {
                            return {
                                label: series.name,
                                color: series.fill,
                                icon: visuals.LegendIcon.Box,
                                selected: false,
                                identity: series.selectionId
                            };
                        });
                    return {
                        dataPoints: legendDataPoints
                    };
                };
                TornadoChart.prototype.clearData = function () {
                    this.columns.selectAll("*").remove();
                    this.axes.selectAll("*").remove();
                    this.labels.selectAll("*").remove();
                    this.categories.selectAll("*").remove();
                    this.legend.drawLegend({ dataPoints: [] }, this.viewport);
                    this.scrolling.clearData();
                };
                TornadoChart.prototype.onClearSelection = function () {
                    if (this.interactivityService)
                        this.interactivityService.clearSelection();
                };
                TornadoChart.prototype.render = function () {
                    var tornadoChartDataView = this.tornadoChartDataView;
                    if (!tornadoChartDataView ||
                        !tornadoChartDataView.settings) {
                        this.clearData();
                        return;
                    }
                    this.renderLegend();
                    this.scrolling.renderY(tornadoChartDataView, tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight, this.renderWithScrolling.bind(this));
                };
                TornadoChart.prototype.renderWithScrolling = function (tornadoChartDataView, scrollStart, scrollEnd) {
                    if (!this.tornadoChartDataView || !this.tornadoChartDataView.settings)
                        return;
                    var categoriesLength = tornadoChartDataView.categories.length;
                    var startIndex = scrollStart * categoriesLength;
                    var endIndex = scrollEnd * categoriesLength;
                    var startIndexRound = Math.floor(startIndex);
                    var endIndexRound = Math.floor(endIndex);
                    var maxValues = Math.floor(this.scrolling.scrollViewport.height / TornadoChart.CategoryMinHeight);
                    if (scrollEnd - scrollStart < 1 && maxValues < endIndexRound - startIndexRound) {
                        if (startIndex - startIndexRound > endIndex - endIndexRound) {
                            startIndexRound++;
                        }
                        else {
                            endIndex--;
                        }
                    }
                    if (this.interactivityService) {
                        this.interactivityService.applySelectionStateToData(tornadoChartDataView.dataPoints);
                        this.interactivityService.applySelectionStateToData(tornadoChartDataView.highlightedDataPoints);
                    }
                    var scrollBarWidth = (tornadoChartDataView.categories.length * TornadoChart.CategoryMinHeight > this.viewport.height) ? TornadoChart.ScrollBarWidth : 0;
                    // Filter data according to the visible visual area
                    tornadoChartDataView.categories = tornadoChartDataView.categories.slice(startIndexRound, endIndexRound);
                    tornadoChartDataView.dataPoints = _.filter(tornadoChartDataView.dataPoints, function (d) { return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound; });
                    tornadoChartDataView.highlightedDataPoints = _.filter(tornadoChartDataView.highlightedDataPoints, function (d) { return d.categoryIndex >= startIndexRound && d.categoryIndex < endIndexRound; });
                    this.tornadoChartDataView = tornadoChartDataView;
                    this.computeHeightColumn();
                    this.renderMiddleSection(scrollBarWidth);
                    this.renderAxes();
                    this.renderCategories();
                };
                TornadoChart.prototype.updateViewport = function () {
                    var legendMargins = this.legend.getMargins(), legendPosition;
                    legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];
                    switch (legendPosition) {
                        case visuals.LegendPosition.Top:
                        case visuals.LegendPosition.TopCenter:
                        case visuals.LegendPosition.Bottom:
                        case visuals.LegendPosition.BottomCenter: {
                            this.viewport.height -= legendMargins.height;
                            break;
                        }
                        case visuals.LegendPosition.Left:
                        case visuals.LegendPosition.LeftCenter:
                        case visuals.LegendPosition.Right:
                        case visuals.LegendPosition.RightCenter: {
                            this.viewport.width -= legendMargins.width;
                            break;
                        }
                    }
                };
                TornadoChart.prototype.computeHeightColumn = function () {
                    var length = this.tornadoChartDataView.categories.length;
                    this.heightColumn = (this.scrolling.scrollViewport.height - ((length - 1) * this.columnPadding)) / length;
                };
                TornadoChart.prototype.renderMiddleSection = function (scrollBarWidth) {
                    var tornadoChartDataView = this.tornadoChartDataView;
                    this.calculateDataPoints(tornadoChartDataView.dataPoints, scrollBarWidth);
                    this.calculateDataPoints(tornadoChartDataView.highlightedDataPoints, scrollBarWidth);
                    var dataPointsWithHighlights = tornadoChartDataView.dataPoints.concat(tornadoChartDataView.highlightedDataPoints);
                    this.renderColumns(dataPointsWithHighlights, tornadoChartDataView.series.length === 2);
                    this.renderLabels(this.hasHighlights ? tornadoChartDataView.highlightedDataPoints : tornadoChartDataView.dataPoints, tornadoChartDataView.settings.labelSettings);
                };
                /**
                 * Calculate the width, dx value and label info for every data point
                 */
                TornadoChart.prototype.calculateDataPoints = function (dataPoints, scrollBarWidth) {
                    var maxColumnWidth = this.widthRightSection = (this.viewport.width - this.widthLeftSection - scrollBarWidth);
                    var categoriesLength = this.tornadoChartDataView.categories.length;
                    var settings = this.tornadoChartDataView.settings;
                    var hasHighlights = this.hasHighlights;
                    var heightColumn = Math.max(this.heightColumn, 0);
                    var py = heightColumn / 2;
                    var pyHighlighted = heightColumn * TornadoChart.HighlightedShapeFactor / 2;
                    var maxSeries = this.tornadoChartDataView.series.length === TornadoChart.MaxSeries;
                    if (maxSeries)
                        maxColumnWidth /= 2;
                    for (var i = 0; i < dataPoints.length; i++) {
                        var dataPoint = dataPoints[i];
                        var shiftToMiddle = i < categoriesLength && maxSeries;
                        var shiftToRight = i > categoriesLength - 1;
                        var widthOfColumn = this.getColumnWidth(dataPoint.value, dataPoint.minValue, dataPoint.maxValue, maxColumnWidth);
                        var dx = (maxColumnWidth - widthOfColumn) * Number(shiftToMiddle) + maxColumnWidth * Number(shiftToRight) - scrollBarWidth;
                        dx = Math.max(dx, 0);
                        var highlighted = hasHighlights && dataPoint.highlight;
                        var highlightOffset = highlighted ? heightColumn * (1 - TornadoChart.HighlightedShapeFactor) / 2 : 0;
                        var dy = (heightColumn + this.columnPadding) * (i % categoriesLength) + highlightOffset;
                        var label = this.getLabelData(dataPoint.value, dx, widthOfColumn, shiftToMiddle, dataPoint.formatString, settings);
                        dataPoint.dx = dx;
                        dataPoint.dy = dy;
                        dataPoint.px = widthOfColumn / 2;
                        dataPoint.py = highlighted ? pyHighlighted : py;
                        dataPoint.angle = shiftToMiddle ? 180 : 0;
                        dataPoint.width = widthOfColumn;
                        dataPoint.height = highlighted ? heightColumn * TornadoChart.HighlightedShapeFactor : heightColumn;
                        dataPoint.label = label;
                    }
                };
                TornadoChart.prototype.renderColumns = function (columnsData, selectSecondSeries) {
                    if (selectSecondSeries === void 0) { selectSecondSeries = false; }
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                    var hasHighlights = this.hasHighlights;
                    var columnsSelection = this.columns
                        .selectAll(TornadoChart.Column.selector)
                        .data(columnsData);
                    columnsSelection
                        .enter()
                        .append("svg:rect")
                        .classed(TornadoChart.Column.class, true);
                    columnsSelection
                        .style("fill", function (p) { return p.color; })
                        .style("fill-opacity", function (p) { return visuals.ColumnUtil.getFillOpacity(p.selected, p.highlight, hasSelection, hasHighlights); })
                        .attr("transform", function (p) { return visuals.SVGUtil.translateAndRotate(p.dx, p.dy, p.px, p.py, p.angle); })
                        .attr("height", function (p) { return p.height; })
                        .attr("width", function (p) { return p.width; });
                    columnsSelection
                        .exit()
                        .remove();
                    var interactivityService = this.interactivityService;
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(columnsData);
                        var behaviorOptions = {
                            columns: columnsSelection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService,
                        };
                        interactivityService.bind(columnsData, this.behavior, behaviorOptions);
                    }
                    this.renderTooltip(columnsSelection);
                };
                TornadoChart.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipData;
                    });
                };
                TornadoChart.prototype.getColumnWidth = function (value, minValue, maxValue, width) {
                    if (minValue === maxValue) {
                        return width;
                    }
                    var columnWidth = width * (value - minValue) / (maxValue - minValue);
                    // In case the user specifies a custom category axis end we limit the
                    // column width to the maximum available width
                    return Math.max(0, Math.min(width, columnWidth));
                };
                TornadoChart.prototype.getLabelData = function (value, dxColumn, columnWidth, isColumnPositionLeft, formatStringProp, settings) {
                    var dx, tornadoChartSettings = settings ? settings : this.tornadoChartDataView.settings, labelSettings = tornadoChartSettings.labelSettings, fontSize = labelSettings.fontSize, color = labelSettings.labelColor;
                    var maxOutsideLabelWidth = isColumnPositionLeft
                        ? dxColumn - this.leftLabelMargin
                        : this.widthRightSection - (dxColumn + columnWidth + this.leftLabelMargin);
                    var maxLabelWidth = Math.max(maxOutsideLabelWidth, columnWidth - this.leftLabelMargin);
                    var textProperties = {
                        fontFamily: visuals.dataLabelUtils.StandardFontFamily,
                        fontSize: PixelConverter.fromPoint(fontSize),
                        text: tornadoChartSettings.labelValueFormatter.format(value)
                    };
                    var valueAfterValueFormatter = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxLabelWidth);
                    var textDataAfterValueFormatter = this.getTextData(valueAfterValueFormatter, true, false, fontSize);
                    if (columnWidth > textDataAfterValueFormatter.width + TornadoChart.LabelPadding) {
                        dx = dxColumn + columnWidth / 2 - textDataAfterValueFormatter.width / 2;
                    }
                    else {
                        if (isColumnPositionLeft) {
                            dx = dxColumn - this.leftLabelMargin - textDataAfterValueFormatter.width;
                        }
                        else {
                            dx = dxColumn + columnWidth + this.leftLabelMargin;
                        }
                        color = tornadoChartSettings.labelOutsideFillColor;
                    }
                    return {
                        dx: dx,
                        source: value,
                        value: valueAfterValueFormatter,
                        color: color
                    };
                };
                TornadoChart.prototype.renderAxes = function () {
                    var linesData, axesSelection, axesElements = this.main
                        .select(TornadoChart.Axes.selector)
                        .selectAll(TornadoChart.Axis.selector);
                    if (this.tornadoChartDataView.series.length !== TornadoChart.MaxSeries) {
                        axesElements.remove();
                        return;
                    }
                    linesData = this.generateAxesData();
                    axesSelection = axesElements.data(linesData);
                    axesSelection
                        .enter()
                        .append("svg:line")
                        .classed(TornadoChart.Axis.class, true);
                    axesSelection
                        .transition()
                        .duration(this.durationAnimations)
                        .attr("x1", function (data) { return data.x1; })
                        .attr("y1", function (data) { return data.y1; })
                        .attr("x2", function (data) { return data.x2; })
                        .attr("y2", function (data) { return data.y2; });
                    axesSelection
                        .exit()
                        .remove();
                };
                TornadoChart.prototype.generateAxesData = function () {
                    var x, y1, y2;
                    x = this.widthRightSection / 2;
                    y1 = 0;
                    y2 = this.scrolling.scrollViewport.height;
                    return [{
                            x1: x,
                            y1: y1,
                            x2: x,
                            y2: y2
                        }];
                };
                TornadoChart.prototype.renderLabels = function (dataPoints, labelsSettings) {
                    var _this = this;
                    var labelEnterSelection, labelSelection = this.main
                        .select(TornadoChart.Labels.selector)
                        .selectAll(TornadoChart.Label.selector)
                        .data(_.filter(dataPoints, function (p) { return p.label.dx >= 0; }));
                    // Check if labels can be displayed
                    if (!labelsSettings.show || this.labelHeight >= this.heightColumn) {
                        this.labels.selectAll("*").remove();
                        return;
                    }
                    var fontSizeInPx = PixelConverter.fromPoint(labelsSettings.fontSize);
                    var labelYOffset = this.heightColumn / 2 + this.labelHeight / 2 - this.InnerTextHeightDelta;
                    var categoriesLength = this.tornadoChartDataView.categories.length;
                    labelEnterSelection = labelSelection
                        .enter()
                        .append("g");
                    labelEnterSelection
                        .append("svg:title")
                        .classed(TornadoChart.LabelTitle.class, true);
                    labelEnterSelection
                        .append("svg:text")
                        .attr("dy", visuals.dataLabelUtils.DefaultDy)
                        .classed(TornadoChart.LabelText.class, true);
                    labelSelection
                        .attr("pointer-events", "none")
                        .classed(TornadoChart.Label.class, true);
                    labelSelection
                        .select(TornadoChart.LabelTitle.selector)
                        .text(function (p) { return p.label.source; });
                    labelSelection
                        .attr("transform", function (p, index) {
                        var dy = (_this.heightColumn + _this.columnPadding) * (index % categoriesLength);
                        return visuals.SVGUtil.translate(p.label.dx, dy + labelYOffset);
                    });
                    labelSelection
                        .select(TornadoChart.LabelText.selector)
                        .attr("fill", function (p) { return p.label.color; })
                        .attr("font-size", function (p) { return fontSizeInPx; })
                        .text(function (p) { return p.label.value; });
                    labelSelection
                        .exit()
                        .remove();
                };
                TornadoChart.prototype.renderCategories = function () {
                    var _this = this;
                    var settings = this.tornadoChartDataView.settings, color = settings.categoriesFillColor, categoriesEnterSelection, categoriesSelection, categoryElements = this.main
                        .select(TornadoChart.Categories.selector)
                        .selectAll(TornadoChart.Category.selector), self = this;
                    if (!settings.showCategories) {
                        categoryElements.remove();
                        return;
                    }
                    categoriesSelection = categoryElements.data(this.tornadoChartDataView.categories);
                    categoriesEnterSelection = categoriesSelection
                        .enter()
                        .append("g");
                    categoriesEnterSelection
                        .append("svg:title")
                        .classed(TornadoChart.CategoryTitle.class, true);
                    categoriesEnterSelection
                        .append("svg:text")
                        .classed(TornadoChart.CategoryText.class, true);
                    categoriesSelection
                        .attr("transform", function (text, index) {
                        var shift = (_this.heightColumn + _this.columnPadding) * index + _this.heightColumn / 2, textData = _this.getTextData(text, false, true);
                        shift = shift + textData.height / 2 - _this.InnerTextHeightDelta;
                        return visuals.SVGUtil.translate(0, shift);
                    })
                        .classed(TornadoChart.Category.class, true);
                    categoriesSelection
                        .select(TornadoChart.CategoryTitle.selector)
                        .text(function (text) { return text.text; });
                    categoriesSelection
                        .select(TornadoChart.CategoryText.selector)
                        .attr("fill", color)
                        .text(function (data) {
                        var textData = self.getTextData(data.text);
                        return powerbi.TextMeasurementService.getTailoredTextOrDefault(textData.textProperties, self.widthLeftSection);
                    });
                    categoriesSelection
                        .exit()
                        .remove();
                };
                TornadoChart.prototype.renderLegend = function () {
                    var legend = this.tornadoChartDataView.legend;
                    if (!legend) {
                        return;
                    }
                    var settings = this.tornadoChartDataView.settings;
                    var legendData = {
                        title: legend.title,
                        dataPoints: legend.dataPoints,
                        fontSize: settings.legendFontSize,
                        labelColor: settings.legendColor,
                    };
                    if (this.legendObjectProperties) {
                        var position = void 0;
                        visuals.LegendData.update(legendData, this.legendObjectProperties);
                        position = this.legendObjectProperties[visuals.legendProps.position];
                        if (position) {
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                        }
                    }
                    // Draw the legend on a viewport with the original height and width
                    var viewport = {
                        height: this.viewport.height + this.margin.top + this.margin.bottom,
                        width: this.viewport.width + this.margin.left + this.margin.right,
                    };
                    this.legend.drawLegend(legendData, viewport);
                    visuals.Legend.positionChartArea(this.root, this.legend);
                    if (legendData.dataPoints.length > 0 && settings.showLegend)
                        this.updateViewport();
                };
                TornadoChart.prototype.getTextData = function (text, measureWidth, measureHeight, overrideFontSize) {
                    if (measureWidth === void 0) { measureWidth = false; }
                    if (measureHeight === void 0) { measureHeight = false; }
                    var width = 0, height = 0, fontSize, textProperties;
                    text = text || "";
                    fontSize = overrideFontSize
                        ? PixelConverter.fromPoint(overrideFontSize)
                        : "" + this.textOptions.fontSize + this.textOptions.sizeUnit;
                    textProperties = {
                        text: text,
                        fontFamily: this.textOptions.fontFamily,
                        fontSize: fontSize
                    };
                    if (measureWidth) {
                        width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    }
                    if (measureHeight) {
                        height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                    }
                    return {
                        text: text,
                        width: width,
                        height: height,
                        textProperties: textProperties
                    };
                };
                TornadoChart.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder(), settings;
                    if (!this.tornadoChartDataView ||
                        !this.tornadoChartDataView.settings) {
                        return [];
                    }
                    settings = this.tornadoChartDataView.settings;
                    switch (options.objectName) {
                        case "dataPoint": {
                            this.enumerateDataPoint(enumeration);
                            break;
                        }
                        case "categoryAxis": {
                            this.enumerateCategoryAxis(enumeration);
                            break;
                        }
                        case "labels": {
                            var labelSettings = settings.labelSettings;
                            var labels = {
                                objectName: "labels",
                                displayName: "Labels",
                                selector: null,
                                properties: {
                                    show: labelSettings.show,
                                    fontSize: labelSettings.fontSize,
                                    labelPrecision: labelSettings.precision,
                                    labelDisplayUnits: labelSettings.displayUnits,
                                    insideFill: labelSettings.labelColor,
                                    outsideFill: settings.labelOutsideFillColor
                                }
                            };
                            enumeration.pushInstance(labels);
                            break;
                        }
                        case "legend": {
                            if (!this.hasDynamicSeries)
                                return;
                            var showTitle = true, titleText = "", legend = void 0;
                            showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle);
                            titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText);
                            legend = {
                                objectName: "legend",
                                displayName: "Legend",
                                selector: null,
                                properties: {
                                    show: settings.showLegend,
                                    position: visuals.LegendPosition[this.legend.getOrientation()],
                                    showTitle: showTitle,
                                    titleText: titleText,
                                    fontSize: settings.legendFontSize,
                                    labelColor: settings.legendColor,
                                }
                            };
                            enumeration.pushInstance(legend);
                            break;
                        }
                        case "categories": {
                            var categories = {
                                objectName: "categories",
                                displayName: "Categories",
                                selector: null,
                                properties: {
                                    show: settings.showCategories,
                                    fill: settings.categoriesFillColor
                                }
                            };
                            enumeration.pushInstance(categories);
                            break;
                        }
                    }
                    return enumeration.complete();
                };
                TornadoChart.prototype.enumerateDataPoint = function (enumeration) {
                    if (!this.tornadoChartDataView ||
                        !this.tornadoChartDataView.series) {
                        return;
                    }
                    var series = this.tornadoChartDataView.series;
                    for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
                        var currentSeries = series_1[_i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: currentSeries.name,
                            selector: visuals.ColorHelper.normalizeSelector(currentSeries.selectionId.getSelector(), false),
                            properties: {
                                fill: { solid: { color: currentSeries.fill } }
                            }
                        });
                    }
                };
                TornadoChart.prototype.enumerateCategoryAxis = function (enumeration) {
                    if (!this.tornadoChartDataView || !this.tornadoChartDataView.series)
                        return;
                    var series = this.tornadoChartDataView.series;
                    for (var _i = 0, series_2 = series; _i < series_2.length; _i++) {
                        var currentSeries = series_2[_i];
                        enumeration.pushInstance({
                            objectName: "categoryAxis",
                            displayName: currentSeries.name,
                            selector: currentSeries.selectionId ? currentSeries.selectionId.getSelector() : null,
                            properties: {
                                end: currentSeries.categoryAxisEnd,
                            }
                        });
                    }
                };
                TornadoChart.prototype.destroy = function () {
                    this.root = null;
                };
                TornadoChart.ClassName = "tornado-chart";
                TornadoChart.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    labels: {
                        show: {
                            objectName: "labels",
                            propertyName: "show"
                        },
                        fontSize: {
                            objectName: "labels",
                            propertyName: "fontSize"
                        },
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        },
                        labelDisplayUnits: {
                            objectName: "labels",
                            propertyName: "labelDisplayUnits"
                        },
                        insideFill: {
                            objectName: "labels",
                            propertyName: "insideFill"
                        },
                        outsideFill: {
                            objectName: "labels",
                            propertyName: "outsideFill"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    legend: {
                        show: {
                            objectName: "legend",
                            propertyName: "show"
                        },
                        labelColor: {
                            objectName: "legend",
                            propertyName: "labelColor"
                        },
                        fontSize: {
                            objectName: "legend",
                            propertyName: "fontSize"
                        },
                    },
                    categories: {
                        show: {
                            objectName: "categories",
                            propertyName: "show"
                        },
                        fill: {
                            objectName: "categories",
                            propertyName: "fill"
                        }
                    }
                };
                TornadoChart.Columns = {
                    "class": "columns",
                    selector: ".columns"
                };
                TornadoChart.Column = {
                    "class": "column",
                    selector: ".column"
                };
                TornadoChart.Axes = {
                    "class": "axes",
                    selector: ".axes"
                };
                TornadoChart.Axis = {
                    "class": "axis",
                    selector: ".axis"
                };
                TornadoChart.Labels = {
                    "class": "labels",
                    selector: ".labels"
                };
                TornadoChart.Label = {
                    "class": "label",
                    selector: ".label"
                };
                TornadoChart.LabelTitle = {
                    "class": "label-title",
                    selector: ".label-title"
                };
                TornadoChart.LabelText = {
                    "class": "label-text",
                    selector: ".label-text"
                };
                TornadoChart.Categories = {
                    "class": "categories",
                    selector: ".categories"
                };
                TornadoChart.Category = {
                    "class": "category",
                    selector: ".category"
                };
                TornadoChart.CategoryTitle = {
                    "class": "category-title",
                    selector: ".category-title"
                };
                TornadoChart.CategoryText = {
                    "class": "category-text",
                    selector: ".category-text"
                };
                TornadoChart.MaxSeries = 2;
                TornadoChart.MaxPrecision = 17; // max number of decimals in float
                TornadoChart.LabelPadding = 2.5;
                TornadoChart.CategoryMinHeight = 25;
                TornadoChart.DefaultFontSize = 9;
                TornadoChart.DefaultLegendFontSize = 8;
                TornadoChart.HighlightedShapeFactor = 0.5;
                TornadoChart.ScrollBarWidth = 10;
                TornadoChart.capabilities = {
                    dataRoles: [{
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Group")
                        }, {
                            name: "Series",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend')
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        }],
                    dataViewMappings: [{
                            conditions: [
                                { "Category": { max: 1 }, "Values": { min: 0, max: 1 }, "Series": { min: 0, max: 1 } },
                                { "Category": { max: 1 }, "Values": { min: 2, max: 2 }, "Series": { max: 0 } }
                            ],
                            categorical: {
                                categories: {
                                    for: {
                                        in: "Category"
                                    }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [{ for: { in: "Values" } }],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                }
                            }
                        }],
                    objects: {
                        general: {
                            displayName: 'General',
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: true
                                        }
                                    },
                                }
                            }
                        },
                        dataPoint: {
                            displayName: 'Data Colors',
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        categoryAxis: {
                            displayName: 'X-Axis',
                            properties: {
                                end: {
                                    displayName: 'End',
                                    type: { numeric: true },
                                    suppressFormatPainterCopy: true,
                                },
                            }
                        },
                        labels: {
                            displayName: 'Data Labels',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                labelPrecision: {
                                    displayName: 'Decimal Places',
                                    placeHolderText: 'Auto',
                                    type: { numeric: true }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                },
                                labelDisplayUnits: {
                                    displayName: 'Display Units',
                                    type: { formatting: { labelDisplayUnits: true } },
                                },
                                insideFill: {
                                    displayName: 'Inside fill',
                                    type: { fill: { solid: { color: true } } }
                                },
                                outsideFill: {
                                    displayName: 'Outside fill',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        legend: {
                            displayName: 'Legend',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: 'Position',
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                                    type: { enumeration: visuals.legendPosition.type }
                                },
                                showTitle: {
                                    displayName: 'Title',
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: 'Legend Name',
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                                    type: { text: true }
                                },
                                labelColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'TextSize',
                                    type: { formatting: { fontSize: true } }
                                },
                            }
                        },
                        categories: {
                            displayName: 'Group',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        }
                    },
                    supportsHighlight: true,
                };
                return TornadoChart;
            }());
            samples.TornadoChart = TornadoChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
            var MekkoDataWrapper = (function () {
                function MekkoDataWrapper(columnChartData, isScalar) {
                    this.data = columnChartData;
                    this.isScalar = isScalar;
                }
                MekkoDataWrapper.prototype.lookupXValue = function (index, type) {
                    debug.assertValue(this.data, 'this.data');
                    var isDateTime = visuals.AxisHelper.isDateTime(type);
                    if (isDateTime && this.isScalar) {
                        return new Date(index);
                    }
                    var data = this.data;
                    if (type.text) {
                        debug.assert(index < data.categories.length, 'category index out of range');
                        return data.categories[index];
                    }
                    else {
                        var firstSeries = data.series[0];
                        if (firstSeries) {
                            var seriesValues = firstSeries.data;
                            if (seriesValues) {
                                if (this.data.hasHighlights) {
                                    index = index * 2;
                                }
                                var dataPoint = seriesValues[index];
                                if (dataPoint) {
                                    if (isDateTime) {
                                        return new Date(dataPoint.categoryValue);
                                    }
                                    return dataPoint.categoryValue;
                                }
                            }
                        }
                    }
                    return index;
                };
                return MekkoDataWrapper;
            }());
            samples.MekkoDataWrapper = MekkoDataWrapper;
            var MekkoColumnChartStrategy = (function () {
                function MekkoColumnChartStrategy() {
                }
                MekkoColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
                    this.graphicsContext = columnChartProps;
                    this.margin = columnChartProps.margin;
                    this.width = this.graphicsContext.width;
                    this.height = this.graphicsContext.height;
                    this.categoryLayout = columnChartProps.layout;
                    this.animator = columnChartProps.animator;
                    this.interactivityService = columnChartProps.interactivityService;
                    this.viewportHeight = columnChartProps.viewportHeight;
                    this.viewportWidth = columnChartProps.viewportWidth;
                };
                MekkoColumnChartStrategy.prototype.setData = function (data) {
                    this.data = data;
                };
                MekkoColumnChartStrategy.createFormatter = function (scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits) {
                    if (useTickIntervalForDisplayUnits === void 0) { useTickIntervalForDisplayUnits = false; }
                    var formatter;
                    if (dataType.dateTime) {
                        if (isScalar) {
                            var value = new Date(scaleDomain[0]);
                            var value2 = new Date(scaleDomain[1]);
                            // datetime with only one value needs to pass the same value
                            // (from the original dataDomain value, not the adjusted scaleDomain)
                            // so formatting works correctly.
                            if (bestTickCount === 1)
                                value = value2 = new Date(dataDomain[0]);
                            formatter = visuals.valueFormatter.create({ format: formatString, value: value, value2: value2, tickCount: bestTickCount });
                        }
                        else {
                            if (getValueFn == null) {
                                debug.assertFail('getValueFn must be supplied for ordinal datetime tickValues');
                            }
                            var minDate = getValueFn(0, dataType);
                            var maxDate = getValueFn(scaleDomain.length - 1, dataType);
                            formatter = visuals.valueFormatter.create({ format: formatString, value: minDate, value2: maxDate, tickCount: bestTickCount });
                        }
                    }
                    else {
                        if (getValueFn == null && !isScalar) {
                            debug.assertFail('getValueFn must be supplied for ordinal tickValues');
                        }
                        if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                            var domainMin = tickValues[1] - tickValues[0];
                            var domainMax = 0; //force tickInterval to be used with display units
                            formatter = visuals.valueFormatter.create({ format: formatString, value: domainMin, value2: domainMax, allowFormatBeautification: true });
                        }
                        else {
                            // do not use display units, just the basic value formatter
                            // datetime is handled above, so we are ordinal and either boolean, numeric, or text.
                            formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                        }
                    }
                    return formatter;
                };
                /**
                 * Format the linear tick labels or the category labels.
                 */
                MekkoColumnChartStrategy.formatAxisTickValues = function (axis, tickValues, formatter, dataType, isScalar, getValueFn) {
                    var formattedTickValues = [];
                    if (formatter) {
                        // getValueFn takes an ordinal axis index or builds DateTime from milliseconds, do not pass a numeric scalar value.
                        if (getValueFn && !(dataType.numeric && isScalar)) {
                            axis.tickFormat(function (d) { return formatter.format(getValueFn(d, dataType)); });
                            formattedTickValues = tickValues.map(function (d) { return formatter.format(getValueFn(d, dataType)); });
                        }
                        else {
                            axis.tickFormat(function (d) { return formatter.format(d); });
                            formattedTickValues = tickValues.map(function (d) { return formatter.format(d); });
                        }
                    }
                    else {
                        formattedTickValues = tickValues.map(function (d) { return getValueFn(d, dataType); });
                    }
                    return formattedTickValues;
                };
                /**
                 * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.
                 * @param options The properties used to create the axis.
                 */
                MekkoColumnChartStrategy.prototype.createAxis = function (options) {
                    var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatStringProp = options.formatStringProp, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?
                    getValueFn = options.getValueFn, categoryThickness = options.categoryThickness;
                    var formatString = visuals.valueFormatter.getFormatString(metaDataColumn, formatStringProp);
                    var dataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn, isScalar);
                    var isLogScaleAllowed = visuals.AxisHelper.isLogScalePossible(dataDomain, dataType);
                    var scale = d3.scale.linear();
                    var scaleDomain = [0, 1];
                    var bestTickCount = dataDomain.length || 1;
                    var borderWidth = MekkoColumnChart.getBorderWidth(options.borderSettings);
                    var chartWidth = pixelSpan - borderWidth * (bestTickCount - 1);
                    if (chartWidth < MekkoChart.MinOrdinalRectThickness) {
                        chartWidth = MekkoChart.MinOrdinalRectThickness;
                    }
                    scale.domain(scaleDomain)
                        .range([0, chartWidth]);
                    var tickValues = dataDomain;
                    var formatter = MekkoColumnChartStrategy.createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits);
                    // sets default orientation only, cartesianChart will fix y2 for comboChart
                    // tickSize(pixelSpan) is used to create gridLines
                    var axis = d3.svg.axis()
                        .scale(scale)
                        .tickSize(6, 0)
                        .orient(isVertical ? 'left' : 'bottom')
                        .ticks(bestTickCount)
                        .tickValues(dataDomain);
                    var formattedTickValues = [];
                    if (metaDataColumn) {
                        formattedTickValues = MekkoColumnChartStrategy.formatAxisTickValues(axis, tickValues, formatter, dataType, isScalar, getValueFn);
                    }
                    var xLabelMaxWidth;
                    // Use category layout of labels if specified, otherwise use scalar layout of labels
                    if (!isScalar && categoryThickness) {
                        xLabelMaxWidth = Math.max(1, categoryThickness - visuals.CartesianChart.TickLabelPadding * 2);
                    }
                    else {
                        // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan
                        // When there is > 1 ticks then we need to +1 so that their widths don't overlap
                        // Example: 2 ticks are drawn at 33.33% and 66.66%, their width needs to be 33.33% so they don't overlap.
                        var labelAreaCount = tickValues.length > 1 ? tickValues.length + 1 : tickValues.length;
                        xLabelMaxWidth = labelAreaCount > 1 ? pixelSpan / labelAreaCount : pixelSpan;
                        xLabelMaxWidth = Math.max(1, xLabelMaxWidth - visuals.CartesianChart.TickLabelPadding * 2);
                    }
                    return {
                        scale: scale,
                        axis: axis,
                        formatter: formatter,
                        values: formattedTickValues,
                        axisType: dataType,
                        axisLabel: null,
                        isCategoryAxis: isCategoryAxis,
                        xLabelMaxWidth: xLabelMaxWidth,
                        categoryThickness: categoryThickness,
                        outerPadding: outerPadding,
                        usingDefaultDomain: false,
                        isLogScaleAllowed: isLogScaleAllowed
                    };
                };
                MekkoColumnChartStrategy.prototype.getCategoryAxis = function (data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType) {
                    var categoryThickness = layout.categoryThickness;
                    var isScalar = layout.isScalar;
                    var outerPaddingRatio = layout.outerPaddingRatio;
                    var dw = new MekkoDataWrapper(data, isScalar);
                    var domain = [];
                    if (data.series &&
                        (data.series.length > 0) &&
                        data.series[0].data &&
                        (data.series[0].data.length > 0)) {
                        var domainDoubles = data.series[0].data.map(function (item) {
                            return item.originalPosition + (item.value / 2);
                        });
                        domain = domainDoubles.filter(function (item, pos) {
                            return domainDoubles.indexOf(item) === pos;
                        });
                    }
                    var axisProperties = this.createAxis({
                        pixelSpan: size,
                        dataDomain: domain,
                        metaDataColumn: data.categoryMetadata,
                        formatStringProp: visuals.columnChartProps.general.formatString,
                        outerPadding: categoryThickness * outerPaddingRatio,
                        isCategoryAxis: true,
                        isScalar: isScalar,
                        isVertical: isVertical,
                        categoryThickness: categoryThickness,
                        useTickIntervalForDisplayUnits: true,
                        getValueFn: function (index, type) {
                            var domainIndex = domain.indexOf(index);
                            var value = dw.lookupXValue(domainIndex, type);
                            return value;
                        },
                        scaleType: axisScaleType,
                        borderSettings: data.borderSettings
                    });
                    // intentionally updating the input layout by ref
                    layout.categoryThickness = axisProperties.categoryThickness;
                    return axisProperties;
                };
                MekkoColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType) {
                    var width = this.width;
                    var forcedXMin, forcedXMax;
                    if (forcedXDomain && forcedXDomain.length === 2) {
                        forcedXMin = forcedXDomain[0];
                        forcedXMax = forcedXDomain[1];
                    }
                    var props = this.xProps = this.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType);
                    return props;
                };
                MekkoColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType) {
                    var height = this.viewportHeight;
                    var valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct);
                    var valueDomainArr = [valueDomain.min, valueDomain.max];
                    var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr);
                    var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);
                    var metadataColumn = this.data.valuesMetadata[0];
                    var formatString = is100Pct ?
                        this.graphicsContext.hostService.getLocalizedString('Percentage')
                        : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                    var mekkoMekkoCreateAxisOptions = {
                        pixelSpan: height,
                        dataDomain: combinedDomain,
                        metaDataColumn: metadataColumn,
                        formatString: formatString,
                        outerPadding: 0,
                        isScalar: true,
                        isVertical: true,
                        forcedTickCount: forcedTickCount,
                        useTickIntervalForDisplayUnits: true,
                        isCategoryAxis: false,
                        scaleType: axisScaleType,
                        axisDisplayUnits: 0,
                        axisPrecision: 0,
                        is100Pct: is100Pct,
                        shouldClamp: shouldClamp,
                        formatStringProp: undefined,
                    };
                    this.yProps = visuals.AxisHelper.createAxis(mekkoMekkoCreateAxisOptions);
                    return this.yProps;
                };
                MekkoColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
                    var data = this.data;
                    debug.assertValue(data, 'data should not be null or undefined');
                    this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
                    var axisOptions = {
                        columnWidth: 0,
                        xScale: this.xProps.scale,
                        yScale: this.yProps.scale,
                        isScalar: this.categoryLayout.isScalar,
                        margin: this.margin,
                    };
                    var stackedColumnLayout = this.layout = MekkoColumnChartStrategy.getLayout(data, axisOptions);
                    //var dataLabelSettings = data.labelSettings;
                    var labelDataPoints = this.createMekkoLabelDataPoints();
                    var result;
                    var shapes;
                    var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                    if (this.animator && useAnimation) {
                        result = this.animator.animate({
                            viewModel: data,
                            series: series,
                            layout: stackedColumnLayout,
                            itemCS: MekkoColumnChartStrategy.classes.item,
                            interactivityService: this.interactivityService,
                            mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                            viewPort: { height: this.height, width: this.width },
                        });
                        shapes = result.shapes;
                    }
                    if (!this.animator || !useAnimation || result.failed) {
                        shapes = MekkoColumnChartStrategy.drawDefaultShapes(data, series, stackedColumnLayout, MekkoColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                    }
                    visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                    return {
                        shapesSelection: shapes,
                        viewport: { height: this.height, width: this.width },
                        axisOptions: axisOptions,
                        labelDataPoints: labelDataPoints,
                    };
                };
                MekkoColumnChartStrategy.drawDefaultShapes = function (data, series, layout, itemCS, filterZeros, hasSelection) {
                    // We filter out invisible (0, null, etc.) values from the dataset
                    // based on whether animations are enabled or not, Dashboard and
                    // Exploration mode, respectively.
                    var rectName = 'rect';
                    filterZeros = false;
                    var dataSelector;
                    if (filterZeros) {
                        dataSelector = function (d) {
                            var filteredData = _.filter(d.data, function (datapoint) { return !!datapoint.value; });
                            return filteredData;
                        };
                    }
                    else {
                        dataSelector = function (d) { return d.data; };
                    }
                    var shapeSelection = series.selectAll(itemCS.selector);
                    var shapes = shapeSelection.data(dataSelector, function (d) { return d.key; });
                    shapes.enter()
                        .append(rectName)
                        .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                    shapes
                        .style("fill", function (d) { return d.color; })
                        .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights); })
                        .attr(layout.shapeLayout);
                    shapes
                        .exit()
                        .remove();
                    var borderSelection = series.selectAll(MekkoColumnChart.BorderClass.selector);
                    var borders = borderSelection.data(dataSelector, function (d) { return d.key; });
                    var borderColor = MekkoColumnChart.getBorderColor(data.borderSettings);
                    borders.enter()
                        .append(rectName)
                        .classed(MekkoColumnChart.BorderClass.class, true);
                    borders
                        .style("fill", function (d) { return borderColor; })
                        .style("fill-opacity", function (d) {
                        return data.hasHighlights ? visuals.ColumnUtil.DimmedOpacity : visuals.ColumnUtil.DefaultOpacity;
                    })
                        .attr(layout.shapeBorder);
                    borders
                        .exit()
                        .remove();
                    return shapes;
                };
                MekkoColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                    visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, MekkoColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                    this.moveHandle(selectedColumnIndex);
                };
                MekkoColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                    return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
                };
                /**
                 * Get the chart's columns centers (x value).
                 */
                MekkoColumnChartStrategy.prototype.getColumnsCenters = function () {
                    var _this = this;
                    if (!this.columnsCenters) {
                        var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                        // use the axis scale and first series data to get category centers
                        if (this.data.series.length > 0) {
                            var xScaleOffset = 0;
                            if (!this.categoryLayout.isScalar) {
                                xScaleOffset = categoryWidth / 2;
                            }
                            var firstSeries = this.data.series[0];
                            if (firstSeries &&
                                firstSeries.data) {
                                this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset; });
                            }
                        }
                    }
                    return this.columnsCenters;
                };
                MekkoColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                    var columnCenters = this.getColumnsCenters();
                    var x = columnCenters[selectedColumnIndex];
                    if (!this.columnSelectionLineHandle) {
                        var handle = this.columnSelectionLineHandle = this.graphicsContext.mainGraphicsContext.append('g');
                        handle.append('line')
                            .classed('interactive-hover-line', true)
                            .attr({
                            x1: x,
                            x2: x,
                            y1: 0,
                            y2: this.height,
                        });
                        handle.append('circle')
                            .attr({
                            cx: x,
                            cy: this.height,
                            r: '6px',
                        })
                            .classed('drag-handle', true);
                    }
                    else {
                        var handle = this.columnSelectionLineHandle;
                        handle.select('line').attr({ x1: x, x2: x });
                        handle.select('circle').attr({ cx: x });
                    }
                };
                MekkoColumnChartStrategy.getLayout = function (data, axisOptions) {
                    var xScale = axisOptions.xScale;
                    var yScale = axisOptions.yScale;
                    var scaledY0 = yScale(0);
                    var scaledX0 = xScale(0);
                    var borderWidth = MekkoColumnChart.getBorderWidth(data.borderSettings);
                    var columnWidthScale = function (d) {
                        var value = visuals.AxisHelper.diffScaled(xScale, d.value, 0);
                        return value;
                    };
                    var columnStart = function (d) {
                        var value = scaledX0 +
                            visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) +
                            borderWidth * d.categoryIndex;
                        return value;
                    };
                    var borderStart = function (d) {
                        var value = scaledX0 +
                            visuals.AxisHelper.diffScaled(xScale, d.originalPosition, 0) +
                            visuals.AxisHelper.diffScaled(xScale, d.value, 0) +
                            borderWidth * d.categoryIndex;
                        return value;
                    };
                    return {
                        shapeLayout: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },
                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }
                        },
                        shapeBorder: {
                            width: function (d) { return borderWidth; },
                            x: borderStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },
                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }
                        },
                        shapeLayoutWithoutHighlights: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },
                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.originalValueAbsolute); }
                        },
                        zeroShapeLayout: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) + visuals.StackedUtil.getSize(yScale, d.valueAbsolute); },
                            height: function (d) { return 0; }
                        },
                        shapeXAxis: {
                            width: columnWidthScale,
                            x: columnStart,
                            y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0); },
                            height: function (d) { return visuals.StackedUtil.getSize(yScale, d.valueAbsolute); }
                        },
                    };
                };
                MekkoColumnChartStrategy.prototype.createMekkoLabelDataPoints = function () {
                    var labelDataPoints = [];
                    var data = this.data;
                    var series = data.series;
                    var formattersCache = NewDataLabelUtils.createColumnFormatterCacheManager();
                    var shapeLayout = this.layout.shapeLayout;
                    for (var i = 0, ilen = series.length; i < ilen; i++) {
                        var currentSeries = series[i];
                        var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                        if (!labelSettings.show) {
                            continue;
                        }
                        if (!currentSeries.data) {
                            continue;
                        }
                        var axisFormatter = NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                        for (var j = 0; j < currentSeries.data.length; j++) {
                            var dataPoint = currentSeries.data[j];
                            if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                                continue;
                            }
                            // Calculate parent rectangle
                            var parentRect = {
                                left: shapeLayout.x(dataPoint),
                                top: shapeLayout.y(dataPoint),
                                width: shapeLayout.width(dataPoint),
                                height: shapeLayout.height(dataPoint),
                            };
                            // Calculate label text
                            var formatString = null;
                            var value = dataPoint.valueOriginal;
                            if (!labelSettings.displayUnits) {
                                formatString = NewDataLabelUtils.hundredPercentFormat;
                                value = dataPoint.valueAbsolute;
                            }
                            var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                            var text = NewDataLabelUtils.getLabelFormattedText(formatter.format(value));
                            // Calculate text size
                            var properties = {
                                text: text,
                                fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: NewDataLabelUtils.LabelTextProperties.fontSize,
                                fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight,
                            };
                            var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                            var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                            labelDataPoints.push({
                                isPreferred: true,
                                text: text,
                                textSize: {
                                    width: textWidth,
                                    height: textHeight,
                                },
                                outsideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultLabelColor,
                                insideFill: labelSettings.labelColor ? labelSettings.labelColor : NewDataLabelUtils.defaultInsideLabelColor,
                                isParentRect: true,
                                parentShape: {
                                    rect: parentRect,
                                    orientation: 1,
                                    validPositions: MekkoColumnChartStrategy.validLabelPositions,
                                },
                                identity: dataPoint.identity,
                                parentType: 1,
                            });
                        }
                    }
                    return labelDataPoints;
                };
                MekkoColumnChartStrategy.classes = {
                    item: createClassAndSelector('column'),
                    highlightItem: createClassAndSelector('highlightColumn')
                };
                MekkoColumnChartStrategy.validLabelPositions = [1];
                return MekkoColumnChartStrategy;
            }());
            samples.MekkoColumnChartStrategy = MekkoColumnChartStrategy;
            /**
             * Renders a data series as a cartestian visual.
             */
            var MekkoChart = (function () {
                function MekkoChart(options) {
                    this.isScrollable = false;
                    if (options) {
                        this.type = options.chartType;
                        if (options.isScrollable)
                            this.isScrollable = options.isScrollable;
                        this.animator = options.animator;
                        if (options.cartesianSmallViewPortProperties) {
                            this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;
                        }
                        if (options.behavior) {
                            this.behavior = options.behavior;
                        }
                    }
                    else {
                        this.behavior = new MekkoChartBehavior([new visuals.ColumnChartWebBehavior()]);
                    }
                }
                MekkoChart.getTextProperties = function (fontSize) {
                    if (fontSize === void 0) { fontSize = MekkoChart.FontSize; }
                    return {
                        fontFamily: 'wf_segoe-ui_normal',
                        fontSize: jsCommon.PixelConverter.toString(fontSize),
                    };
                };
                MekkoChart.prototype.init = function (options) {
                    this.visualInitOptions = options;
                    this.layers = [];
                    var element = this.element = options.element;
                    var viewport = this.currentViewport = options.viewport;
                    this.hostServices = options.host;
                    this.brush = d3.svg.brush();
                    element.addClass(MekkoChart.ClassName);
                    this.margin = {
                        top: 1,
                        right: 1,
                        bottom: 1,
                        left: 1
                    };
                    this.yAxisOrientation = visuals.yAxisPosition.left;
                    this.adjustMargins(viewport);
                    this.sharedColorPalette = new visuals.SharedColorPalette(options.style.colorPalette.dataColors);
                    var showLinesOnX = true;
                    var showLinesOnY = true;
                    var svg = this.svg = d3.select(element.get(0)).append('svg');
                    svg.style('position', 'absolute');
                    var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')
                        .classed(MekkoChart.AxisGraphicsContextClassName, true);
                    this.svgScrollable = svg.append('svg')
                        .classed('svgScrollable', true)
                        .style('overflow', 'hidden');
                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')
                        .classed(MekkoChart.AxisGraphicsContextClassName, true);
                    this.labelGraphicsContextScrollable = this.svgScrollable.append('g')
                        .classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);
                    if (this.behavior) {
                        this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);
                    }
                    var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                    this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
                    this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
                    this.y2AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
                    this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);
                    this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                    this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                    this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);
                    this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                    this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                    if (this.behavior) {
                        this.interactivityService = visuals.createInteractivityService(this.hostServices);
                    }
                    this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, true);
                };
                MekkoChart.prototype.renderAxesLabels = function (options) {
                    debug.assertValue(options, 'options');
                    debug.assertValue(options.viewport, 'options.viewport');
                    debug.assertValue(options.axisLabels, 'options.axisLabels');
                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                    var margin = this.margin;
                    var width = options.viewport.width - (margin.left + margin.right);
                    var height = options.viewport.height;
                    var fontSize = MekkoChart.FontSize;
                    var heightOffset = fontSize;
                    var showOnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                    if (!options.hideXAxisTitle) {
                        var xAxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(options.axisLabels.x)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "xAxisLabel",
                                    "transform": visuals.SVGUtil.translate(width / 2, height - heightOffset)
                                });
                            });
                        });
                        xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null);
                        xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!options.hideYAxisTitle) {
                        var yAxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(options.axisLabels.y)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    "transform": "rotate(-90)",
                                    "y": showOnRight ? width + margin.right - fontSize : -margin.left,
                                    "x": -((height - margin.top - options.legendMargin) / 2),
                                    "dy": "1em"
                                });
                            });
                        });
                        yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null);
                        yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                        var y2AxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(options.axisLabels.y2)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    "transform": "rotate(-90)",
                                    "y": showOnRight ? -margin.left : width + margin.right - fontSize,
                                    "x": -((height - margin.top - options.legendMargin) / 2),
                                    "dy": "1em"
                                });
                            });
                        });
                        y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null);
                        y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                };
                MekkoChart.prototype.adjustMargins = function (viewport) {
                    var margin = this.margin;
                    var width = viewport.width - (margin.left + margin.right);
                    var height = viewport.height - (margin.top + margin.bottom);
                    // Adjust margins if ticks are not going to be shown on either axis
                    var xAxis = this.element.find('.x.axis');
                    if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0
                        && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {
                        this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        };
                        xAxis.hide();
                    }
                    else {
                        xAxis.show();
                    }
                };
                MekkoChart.prototype.translateAxes = function (viewport) {
                    this.adjustMargins(viewport);
                    var margin = this.margin;
                    var width = viewport.width - (margin.left + margin.right);
                    var height = viewport.height - (margin.top + margin.bottom);
                    var showY1OnRight = this.yAxisOrientation === visuals.yAxisPosition.right;
                    this.xAxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(0, height));
                    this.y1AxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0));
                    this.y2AxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0));
                    this.svg.attr({
                        'width': viewport.width,
                        'height': viewport.height
                    });
                    this.svg.style('top', this.legend.isVisible() ? this.legend.getMargins().height + 'px' : 0);
                    this.svgScrollable.attr({
                        'width': viewport.width,
                        'height': viewport.height
                    });
                    this.svgScrollable.attr({
                        'x': 0
                    });
                    this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                    this.labelGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                    if (this.isXScrollBarVisible) {
                        this.svgScrollable.attr({
                            'x': this.margin.left
                        });
                        this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                        this.labelGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                        this.svgScrollable.attr('width', width);
                        this.svg.attr('width', viewport.width)
                            .attr('height', viewport.height + MekkoChart.ScrollBarWidth);
                    }
                    else if (this.isYScrollBarVisible) {
                        this.svgScrollable.attr('height', height + margin.top);
                        this.svg.attr('width', viewport.width + MekkoChart.ScrollBarWidth)
                            .attr('height', viewport.height);
                    }
                };
                MekkoChart.getIsScalar = function (objects, propertyId, type) {
                    var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                    if (!objects || axisTypeValue === undefined) {
                        // If we don't have anything set (Auto), show charts as Scalar if the category type is numeric or time.
                        // If we have the property, it will override the type.
                        return !visuals.AxisHelper.isOrdinal(type);
                    }
                    // also checking type here to be in sync with AxisHelper, which ignores scalar if the type is non-numeric.
                    return (axisTypeValue === visuals.axisType.scalar) && !visuals.AxisHelper.isOrdinal(type);
                };
                MekkoChart.prototype.populateObjectProperties = function (dataViews) {
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        if (dataViewMetadata) {
                            this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});
                            this.borderObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'columnBorder', {});
                        }
                        else {
                            this.legendObjectProperties = {};
                            this.borderObjectProperties = {};
                        }
                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                        if (dataViewMetadata &&
                            dataViewMetadata.objects) {
                            var categoryAxis = dataViewMetadata.objects['categoryAxis'];
                            var valueAxis = dataViewMetadata.objects['valueAxis'];
                            if (categoryAxis) {
                                this.categoryAxisProperties['showBorder'] = categoryAxis['showBorder'];
                                this.categoryAxisProperties['fontSize'] = categoryAxis['fontSize'];
                            }
                            if (valueAxis) {
                                this.valueAxisProperties['fontSize'] = valueAxis['fontSize'];
                            }
                        }
                        var axisPosition = this.valueAxisProperties['position'];
                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                    }
                };
                MekkoChart.prototype.update = function (options) {
                    debug.assertValue(options, 'options');
                    var dataViews = this.dataViews = options.dataViews;
                    this.currentViewport = options.viewport;
                    if (!dataViews) {
                        return;
                    }
                    if ((this.currentViewport.width < MekkoChart.MinWidth) ||
                        (this.currentViewport.height < MekkoChart.MinHeight)) {
                        return;
                    }
                    if (this.layers.length === 0) {
                        // Lazily instantiate the chart layers on the first data load.
                        this.layers = this.createAndInitLayers(dataViews);
                        debug.assert(this.layers.length > 0, 'createAndInitLayers should update the layers.');
                    }
                    var layers = this.layers;
                    if (dataViews && dataViews.length > 0) {
                        var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                        if (warnings && warnings.length > 0) {
                            this.hostServices.setWarnings(warnings);
                        }
                        this.populateObjectProperties(dataViews);
                    }
                    this.sharedColorPalette.clearPreferredScale();
                    for (var i = 0, len = layers.length; i < len; i++) {
                        layers[i].setData(getLayerData(dataViews, i, len));
                        if (len > 1) {
                            this.sharedColorPalette.rotateScale();
                        }
                    }
                    // Note: interactive legend shouldn't be rendered explicitly here
                    // The interactive legend is being rendered in the render method of ICartesianVisual
                    if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {
                        this.renderLegend();
                    }
                    this.render(!this.hasSetData || options.suppressAnimations);
                    this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);
                };
                MekkoChart.parseLabelSettings = function (objects) {
                    var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(true);
                    var labelsObj = objects['labels'];
                    var minPrecision = MekkoChart.DefaultSettings.labelSettings.minPrecision, maxPrecision = MekkoChart.DefaultSettings.labelSettings.maxPrecision;
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
                    if (labelSettings.precision < minPrecision) {
                        labelSettings.precision = minPrecision;
                    }
                    if (labelSettings.precision > maxPrecision) {
                        labelSettings.precision = maxPrecision;
                    }
                    return labelSettings;
                };
                MekkoChart.parseBorderSettings = function (objects) {
                    var show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);
                    var color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);
                    var width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);
                    var maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                    if (width > maxWidth) {
                        width = maxWidth;
                    }
                    else if (width < 0) {
                        width = 0;
                    }
                    if (!show) {
                        width = 0;
                    }
                    return {
                        show: show,
                        color: color,
                        width: width,
                    };
                };
                MekkoChart.prototype.enumerateBorder = function (enumeration) {
                    var objects = {
                        columnBorder: this.borderObjectProperties
                    };
                    var show = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.show, MekkoChart.DefaultSettings.columnBorder.show);
                    var color = powerbi.DataViewObjects.getFillColor(objects, MekkoChart.properties.columnBorder.color, MekkoChart.DefaultSettings.columnBorder.color);
                    var width = powerbi.DataViewObjects.getValue(objects, MekkoChart.properties.columnBorder.width, MekkoChart.DefaultSettings.columnBorder.width);
                    var maxWidth = MekkoChart.DefaultSettings.columnBorder.maxWidth;
                    if (width > maxWidth) {
                        width = maxWidth;
                    }
                    else if (width < 0) {
                        width = 0;
                    }
                    var instance = {
                        objectName: 'columnBorder',
                        selector: null,
                        properties: {
                            show: show,
                            color: color,
                            width: width,
                        },
                    };
                    enumeration
                        .pushInstance(instance);
                };
                MekkoChart.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    var layersLength = this.layers ? this.layers.length : 0;
                    if (options.objectName === 'columnBorder') {
                        this.enumerateBorder(enumeration);
                    }
                    else if (options.objectName === 'legend') {
                        if (!this.shouldShowLegendCard()) {
                            return;
                        }
                        var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());
                        var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);
                        var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData && this.layerLegendData.title ? this.layerLegendData.title : '');
                        var fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : NewDataLabelUtils.DefaultLabelFontSizeInPt);
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                show: show,
                                position: visuals.LegendPosition[this.legend.getOrientation()],
                                showTitle: showTitle,
                                titleText: titleText,
                                fontSize: fontSize
                            },
                            objectName: options.objectName
                        });
                    }
                    else if (options.objectName === 'categoryAxis' && this.hasCategoryAxis) {
                        this.getCategoryAxisValues(enumeration);
                    }
                    else if (options.objectName === 'valueAxis') {
                        this.getValueAxisValues(enumeration);
                    }
                    for (var i = 0, len = layersLength; i < len; i++) {
                        var layer = this.layers[i];
                        if (layer.enumerateObjectInstances) {
                            layer.enumerateObjectInstances(enumeration, options);
                        }
                    }
                    return enumeration.complete();
                };
                MekkoChart.prototype.shouldShowLegendCard = function () {
                    var layers = this.layers;
                    var dataViews = this.dataViews;
                    if (layers && dataViews) {
                        var layersLength = layers.length;
                        var layersWithValuesCtr = 0;
                        for (var i = 0; i < layersLength; i++) {
                            if (layers[i].hasLegend()) {
                                return true;
                            }
                            // if there are at least two layers with values legend card should be shown (even if each of the individual layers don't have legend)
                            var dataView = dataViews[i];
                            if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0) {
                                layersWithValuesCtr++;
                                if (layersWithValuesCtr > 1) {
                                    return true;
                                }
                            }
                        }
                    }
                    return false;
                };
                MekkoChart.prototype.getCategoryAxisValues = function (enumeration) {
                    var supportedType = visuals.axisType.both;
                    var isScalar = false;
                    var logPossible = !!this.axes.x.isLogScaleAllowed;
                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options
                    if (this.layers && this.layers[0].getSupportedCategoryAxisType) {
                        supportedType = this.layers[0].getSupportedCategoryAxisType();
                        if (supportedType === visuals.axisType.scalar) {
                            isScalar = true;
                        }
                        else {
                            isScalar = visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties);
                        }
                    }
                    if (!isScalar) {
                        if (this.categoryAxisProperties) {
                            this.categoryAxisProperties['start'] = null;
                            this.categoryAxisProperties['end'] = null;
                        }
                    }
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: 'categoryAxis',
                        validValues: {
                            axisScale: scaleOptions
                        }
                    };
                    instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;
                    if (this.yAxisIsCategorical)
                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                    if (supportedType === visuals.axisType.both) {
                        instance.properties['axisType'] = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical;
                    }
                    if (isScalar) {
                        instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : visuals.axisScale.linear;
                        instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;
                        instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;
                    }
                    instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
                    instance.properties['showBorder'] = this.categoryAxisProperties && this.categoryAxisProperties['showBorder'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
                    instance.properties['fontSize'] = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
                    enumeration
                        .pushInstance(instance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null,
                            fontSize: this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt
                        },
                        objectName: 'categoryAxis',
                        validValues: {
                            axisStyle: this.categoryAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly],
                        }
                    });
                };
                //todo: wrap all these object getters and other related stuff into an interface
                MekkoChart.prototype.getValueAxisValues = function (enumeration) {
                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options
                    var logPossible = !!this.axes.y1.isLogScaleAllowed;
                    //var secLogPossible = this.axes.y2 != null && this.axes.y2.isLogScaleAllowed;
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: 'valueAxis',
                        validValues: {
                            axisScale: scaleOptions,
                            secAxisScale: scaleOptions
                        }
                    };
                    instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;
                    if (!this.yAxisIsCategorical) {
                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                    }
                    instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : visuals.axisScale.linear;
                    instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;
                    instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;
                    instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;
                    instance.properties['fontSize'] = this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
                    enumeration
                        .pushInstance(instance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null,
                            fontSize: this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt
                        },
                        objectName: 'valueAxis',
                        validValues: {
                            axisStyle: this.valueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                        },
                    });
                    if (this.layers.length === 2) {
                        instance.properties['secShow'] = this.valueAxisProperties && this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : this.y2AxisExists;
                        if (instance.properties['secShow']) {
                            instance.properties['axisLabel'] = ''; //this.layers[0].getVisualType();//I will keep or remove this, depending on the decision made
                        }
                    }
                };
                MekkoChart.prototype.onClearSelection = function () {
                    if (this.hasSetData) {
                        for (var i = 0, len = this.layers.length; i < len; i++) {
                            var layer = this.layers[i];
                            layer.onClearSelection();
                            layer.render(true /* suppressAnimations */);
                        }
                    }
                };
                MekkoChart.prototype.createAndInitLayers = function (dataViews) {
                    var _this = this;
                    var objects;
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        if (dataViewMetadata)
                            objects = dataViewMetadata.objects;
                    }
                    // Create the layers
                    var layers = createLayers(this.type, objects, this.interactivityService, this.animator, this.isScrollable);
                    // Initialize the layers
                    var cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                    cartesianOptions.svg = this.axisGraphicsContextScrollable;
                    cartesianOptions.cartesianHost = {
                        updateLegend: function (data) { return _this.legend.drawLegend(data, _this.currentViewport); },
                        getSharedColors: function () { return _this.sharedColorPalette; },
                        triggerRender: undefined,
                    };
                    for (var i = 0, len = layers.length; i < len; i++) {
                        layers[i].init(cartesianOptions);
                    }
                    return layers;
                };
                MekkoChart.prototype.renderLegend = function () {
                    var layers = this.layers;
                    var legendData = { title: "", dataPoints: [] };
                    for (var i = 0, len = layers.length; i < len; i++) {
                        this.layerLegendData = layers[i].calculateLegend();
                        if (this.layerLegendData) {
                            legendData.title = i === 0 ? this.layerLegendData.title || ""
                                : legendData.title;
                            legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
                            if (this.layerLegendData.grouped) {
                                legendData.grouped = true;
                            }
                        }
                    }
                    var legendProperties = this.legendObjectProperties;
                    if (legendProperties) {
                        if (!legendProperties['fontSize']) {
                            legendProperties['fontSize'] = NewDataLabelUtils.DefaultLabelFontSizeInPt;
                        }
                        visuals.LegendData.update(legendData, legendProperties);
                        var position = legendProperties[visuals.legendProps.position];
                        if (position) {
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                        }
                    }
                    else {
                        this.legend.changeOrientation(visuals.LegendPosition.Top);
                    }
                    if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {
                        legendData.dataPoints = [];
                    }
                    this.legend.drawLegend(legendData, this.currentViewport);
                };
                MekkoChart.prototype.hideLegends = function () {
                    if (this.cartesianSmallViewPortProperties) {
                        if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {
                            return true;
                        }
                    }
                    return false;
                };
                MekkoChart.prototype.addUnitTypeToAxisLabel = function (axes) {
                    var unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.x; });
                    if (axes.x.isCategoryAxis) {
                        this.categoryAxisHasUnitType = unitType !== null;
                    }
                    else {
                        this.valueAxisHasUnitType = unitType !== null;
                    }
                    if (axes.x.axisLabel && unitType) {
                        if (axes.x.isCategoryAxis) {
                            axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType);
                        }
                        else {
                            axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType);
                        }
                    }
                    unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.y1; });
                    if (!axes.y1.isCategoryAxis) {
                        this.valueAxisHasUnitType = unitType !== null;
                    }
                    else {
                        this.categoryAxisHasUnitType = unitType !== null;
                    }
                    if (axes.y1.axisLabel && unitType) {
                        if (!axes.y1.isCategoryAxis) {
                            axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType);
                        }
                        else {
                            axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType);
                        }
                    }
                    if (axes.y2) {
                        var unitType = MekkoChart.getUnitType(axes, function (axis) { return axis.y2; });
                        this.secValueAxisHasUnitType = unitType !== null;
                        if (axes.y2.axisLabel && unitType) {
                            if (this.valueAxisProperties && this.valueAxisProperties['secAxisStyle']) {
                                if (this.valueAxisProperties['secAxisStyle'] === visuals.axisStyle.showBoth) {
                                    axes.y2.axisLabel = axes.y2.axisLabel + ' (' + unitType + ')';
                                }
                                else if (this.valueAxisProperties['secAxisStyle'] === visuals.axisStyle.showUnitOnly) {
                                    axes.y2.axisLabel = unitType;
                                }
                            }
                        }
                    }
                };
                MekkoChart.prototype.shouldRenderSecondaryAxis = function (axisProperties) {
                    if (!axisProperties) {
                        return false;
                    }
                    if (!this.valueAxisProperties || this.valueAxisProperties["secShow"] == null || this.valueAxisProperties["secShow"]) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    return false;
                };
                MekkoChart.prototype.shouldRenderAxis = function (axisProperties, propertyName) {
                    if (propertyName === void 0) { propertyName = "show"; }
                    if (!axisProperties) {
                        return false;
                    }
                    else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    return false;
                };
                MekkoChart.prototype.render = function (suppressAnimations) {
                    var legendMargins = this.legendMargins = this.legend.getMargins();
                    var viewport = {
                        height: this.currentViewport.height - legendMargins.height,
                        width: this.currentViewport.width - legendMargins.width
                    };
                    var maxMarginFactor = this.getMaxMarginFactor();
                    var leftRightMarginLimit = this.leftRightMarginLimit = viewport.width * maxMarginFactor;
                    this.bottomMarginLimit = Math.max(MekkoChart.MinBottomMargin, Math.ceil(viewport.height * maxMarginFactor));
                    var xAxisTextProperties = MekkoChart.getTextProperties(parseFloat(this.categoryAxisProperties['fontSize']) || undefined);
                    var y1AxisTextProperties = MekkoChart.getTextProperties(parseFloat(this.valueAxisProperties['fontSize']) || undefined);
                    var margin = this.margin;
                    // reset defaults
                    margin.top = parseFloat(y1AxisTextProperties.fontSize) / 2;
                    margin.bottom = MekkoChart.MinBottomMargin;
                    margin.right = 0;
                    var axes = this.axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                    this.yAxisIsCategorical = axes.y1.isCategoryAxis;
                    this.hasCategoryAxis = this.yAxisIsCategorical ? axes.y1 && axes.y1.values.length > 0 : axes.x && axes.x.values.length > 0;
                    var renderXAxis = this.shouldRenderAxis(axes.x);
                    var renderY1Axis = this.shouldRenderAxis(axes.y1);
                    var renderY2Axis = this.shouldRenderSecondaryAxis(axes.y2);
                    var width = viewport.width - (margin.left + margin.right);
                    var isScalar = false;
                    var mainAxisScale;
                    var preferredViewport;
                    this.isXScrollBarVisible = false;
                    this.isYScrollBarVisible = false;
                    var yAxisOrientation = this.yAxisOrientation;
                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    if (this.layers) {
                        if (this.layers[0].getVisualCategoryAxisIsScalar) {
                            isScalar = this.layers[0].getVisualCategoryAxisIsScalar();
                        }
                        if (!isScalar && this.isScrollable && this.layers[0].getPreferredPlotArea) {
                            var categoryThickness = this.scrollX ? axes.x.categoryThickness : axes.y1.categoryThickness;
                            var categoryCount = this.scrollX ? axes.x.values.length : axes.y1.values.length;
                            preferredViewport = this.layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
                            if (this.scrollX && preferredViewport && preferredViewport.width > viewport.width) {
                                this.isXScrollBarVisible = true;
                                viewport.height -= MekkoChart.ScrollBarWidth;
                            }
                            if (this.scrollY && preferredViewport && preferredViewport.height > viewport.height) {
                                this.isYScrollBarVisible = true;
                                viewport.width -= MekkoChart.ScrollBarWidth;
                                width = viewport.width - (margin.left + margin.right);
                            }
                        }
                    }
                    // Only create the g tag where there is a scrollbar
                    if (this.isXScrollBarVisible || this.isYScrollBarVisible) {
                        if (!this.brushGraphicsContext) {
                            this.brushGraphicsContext = this.svg.append("g")
                                .classed('x brush', true);
                        }
                    }
                    else {
                        // clear any existing brush if no scrollbar is shown
                        this.svg.selectAll('.brush').remove();
                        this.brushGraphicsContext = undefined;
                    }
                    // Recalculate axes now that scrollbar visible variables have been set
                    axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, null);
                    // we need to make two passes because the margin changes affect the chosen tick values, which then affect the margins again.
                    // after the second pass the margins are correct.
                    var doneWithMargins = false, maxIterations = 2, numIterations = 0;
                    var tickLabelMargins = undefined;
                    var chartHasAxisLabels = undefined;
                    var axisLabels = undefined;
                    while (!doneWithMargins && numIterations < maxIterations) {
                        numIterations++;
                        tickLabelMargins = getTickLabelMargins({ width: width, height: viewport.height }, leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, this.bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, null, false, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                        // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side
                        var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = renderXAxis ? (tickLabelMargins.xMax / 1.8) : 0;
                        maxMainYaxisSide += MekkoChart.LeftPadding;
                        maxSecondYaxisSide += MekkoChart.RightPadding;
                        xMax += MekkoChart.BottomPadding;
                        if (this.hideAxisLabels(legendMargins)) {
                            axes.x.axisLabel = null;
                            axes.y1.axisLabel = null;
                            if (axes.y2) {
                                axes.y2.axisLabel = null;
                            }
                        }
                        this.addUnitTypeToAxisLabel(axes);
                        axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
                        chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                        if (axisLabels.x != null) {
                            xMax += MekkoChart.XAxisLabelPadding;
                        }
                        if (axisLabels.y != null) {
                            maxMainYaxisSide += MekkoChart.YAxisLabelPadding;
                        }
                        if (axisLabels.y2 != null) {
                            maxSecondYaxisSide += MekkoChart.YAxisLabelPadding;
                        }
                        margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;
                        margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;
                        margin.bottom = xMax;
                        this.margin = margin;
                        width = viewport.width - (margin.left + margin.right);
                        // re-calculate the axes with the new margins
                        var previousTickCountY1 = axes.y1.values.length;
                        var previousTickCountY2 = axes.y2 && axes.y2.values.length;
                        axes = calculateAxes(this.layers, viewport, margin, this.categoryAxisProperties, this.valueAxisProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, axes);
                        // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again
                        // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.
                        if (axes.y1.values.length === previousTickCountY1 && (!axes.y2 || axes.y2.values.length === previousTickCountY2))
                            doneWithMargins = true;
                    }
                    this.renderChart(mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations);
                };
                MekkoChart.prototype.hideAxisLabels = function (legendMargins) {
                    if (this.cartesianSmallViewPortProperties) {
                        if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && ((this.currentViewport.height + legendMargins.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {
                            return true;
                        }
                    }
                    return false;
                };
                MekkoChart.getUnitType = function (axis, axisPropertiesLookup) {
                    if (axisPropertiesLookup(axis).formatter &&
                        axisPropertiesLookup(axis).formatter.displayUnit &&
                        axisPropertiesLookup(axis).formatter.displayUnit.value > 1) {
                        return axisPropertiesLookup(axis).formatter.displayUnit.title;
                    }
                    return null;
                };
                MekkoChart.prototype.getMaxMarginFactor = function () {
                    return this.visualInitOptions.style.maxMarginFactor || MekkoChart.MaxMarginFactor;
                };
                MekkoChart.getChartViewport = function (viewport, margin) {
                    return {
                        width: viewport.width - margin.left - margin.right,
                        height: viewport.height - margin.top - margin.bottom,
                    };
                };
                MekkoChart.wordBreak = function (text, axisProperties, columnsWidth, maxHeight, borderWidth) {
                    //var allowedLength = axisProperties.xLabelMaxWidth;
                    text.each(function (data, index) {
                        var width, allowedLength;
                        var node = d3.select(this);
                        if (columnsWidth.length >= index) {
                            width = columnsWidth[index];
                            allowedLength = axisProperties.scale(width);
                        }
                        else {
                            allowedLength = axisProperties.xLabelMaxWidth;
                        }
                        // Reset style of text node
                        node
                            .style('text-anchor', 'middle')
                            .attr({
                            'dx': '0em',
                            'dy': '1em',
                            'transform': 'rotate(0)'
                        });
                        powerbi.TextMeasurementService.wordBreak(this, allowedLength, axisProperties.willLabelsWordBreak ? maxHeight : 0);
                    });
                };
                MekkoChart.prototype.renderChart = function (mainAxisScale, axes, width, tickLabelMargins, chartHasAxisLabels, axisLabels, viewport, suppressAnimations, scrollScale, extent) {
                    var bottomMarginLimit = this.bottomMarginLimit;
                    var leftRightMarginLimit = this.leftRightMarginLimit;
                    var layers = this.layers;
                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    var chartViewport = MekkoChart.getChartViewport(viewport, this.margin);
                    debug.assertValue(layers, 'layers');
                    var xLabelColor;
                    var yLabelColor;
                    var y2LabelColor;
                    var xFontSize;
                    var yFontSize;
                    //hide show x-axis here
                    if (this.shouldRenderAxis(axes.x)) {
                        if (axes.x.isCategoryAxis) {
                            xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
                            xFontSize = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
                        }
                        else {
                            xLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
                            xFontSize = this.valueAxisProperties && this.valueAxisProperties['fontSize'] ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
                        }
                        axes.x.axis.orient("bottom");
                        if (!axes.x.willLabelsFit) {
                            axes.x.axis.tickPadding(MekkoChart.TickPaddingRotatedX);
                        }
                        var xAxisGraphicsElement = this.xAxisGraphicsContext;
                        if (duration) {
                            xAxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(axes.x.axis);
                        }
                        else {
                            xAxisGraphicsElement
                                .call(axes.x.axis);
                        }
                        xAxisGraphicsElement
                            .call(MekkoChart.darkenZeroLine)
                            .call(MekkoChart.setAxisLabelColor, xLabelColor)
                            .call(MekkoChart.setAxisLabelFontSize, xFontSize);
                        var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');
                        var columnWidth = [];
                        var borderWidth = 0;
                        if (this.layers && this.layers.length) {
                            columnWidth = this.layers[0].getColumnsWidth();
                            borderWidth = this.layers[0].getBorderWidth();
                        }
                        xAxisGraphicsElement
                            .call(MekkoChart.moveBorder, axes.x.scale, borderWidth, xFontSize / 2 - 8);
                        xAxisTextNodes
                            .call(MekkoChart.wordBreak, axes.x, columnWidth, bottomMarginLimit, borderWidth);
                    }
                    else {
                        this.xAxisGraphicsContext.selectAll('*').remove();
                    }
                    if (this.shouldRenderAxis(axes.y1)) {
                        if (axes.y1.isCategoryAxis) {
                            yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
                            yFontSize = this.categoryAxisProperties && this.categoryAxisProperties['fontSize'] != null ? this.categoryAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
                        }
                        else {
                            yLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
                            yFontSize = this.valueAxisProperties && this.valueAxisProperties['fontSize'] != null ? this.valueAxisProperties['fontSize'] : NewDataLabelUtils.DefaultLabelFontSizeInPt;
                        }
                        var yAxisOrientation = this.yAxisOrientation;
                        var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                        axes.y1.axis
                            .tickSize(-width)
                            .tickPadding(MekkoChart.TickPaddingY)
                            .orient(yAxisOrientation.toLowerCase());
                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                        if (duration) {
                            y1AxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(axes.y1.axis);
                        }
                        else {
                            y1AxisGraphicsElement
                                .call(axes.y1.axis);
                        }
                        y1AxisGraphicsElement
                            .call(MekkoChart.darkenZeroLine)
                            .call(MekkoChart.setAxisLabelColor, yLabelColor)
                            .call(MekkoChart.setAxisLabelFontSize, yFontSize);
                        if (tickLabelMargins.yLeft >= leftRightMarginLimit) {
                            y1AxisGraphicsElement.selectAll('text')
                                .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                            leftRightMarginLimit - MekkoChart.LeftPadding, powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {
                            y2LabelColor = this.valueAxisProperties && this.valueAxisProperties['secLabelColor'] ? this.valueAxisProperties['secLabelColor'] : null;
                            axes.y2.axis
                                .tickPadding(MekkoChart.TickPaddingY)
                                .orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase());
                            if (duration) {
                                this.y2AxisGraphicsContext
                                    .transition()
                                    .duration(duration)
                                    .call(axes.y2.axis);
                            }
                            else {
                                this.y2AxisGraphicsContext
                                    .call(axes.y2.axis);
                            }
                            this.y2AxisGraphicsContext
                                .call(MekkoChart.darkenZeroLine)
                                .call(MekkoChart.setAxisLabelColor, y2LabelColor);
                            if (tickLabelMargins.yRight >= leftRightMarginLimit) {
                                this.y2AxisGraphicsContext.selectAll('text')
                                    .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                                // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                                leftRightMarginLimit - MekkoChart.RightPadding, powerbi.TextMeasurementService.svgEllipsis);
                            }
                        }
                        else {
                            this.y2AxisGraphicsContext.selectAll('*').remove();
                        }
                    }
                    else {
                        this.y1AxisGraphicsContext.selectAll('*').remove();
                        this.y2AxisGraphicsContext.selectAll('*').remove();
                    }
                    // Axis labels
                    if (chartHasAxisLabels) {
                        var hideXAxisTitle = !this.shouldRenderAxis(axes.x, "showAxisTitle");
                        var hideYAxisTitle = !this.shouldRenderAxis(axes.y1, "showAxisTitle");
                        var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties["secShowAxisTitle"] != null && this.valueAxisProperties["secShowAxisTitle"] === false;
                        var renderAxisOptions = {
                            axisLabels: axisLabels,
                            legendMargin: this.legendMargins.height,
                            viewport: viewport,
                            hideXAxisTitle: hideXAxisTitle,
                            hideYAxisTitle: hideYAxisTitle,
                            hideY2AxisTitle: hideY2AxisTitle,
                            xLabelColor: xLabelColor,
                            yLabelColor: yLabelColor,
                            y2LabelColor: y2LabelColor,
                            margin: undefined,
                        };
                        this.renderAxesLabels(renderAxisOptions);
                    }
                    else {
                        this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                        this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                    }
                    this.translateAxes(viewport);
                    var dataPoints = [];
                    var layerBehaviorOptions = [];
                    var labelDataPointsGroup = [];
                    //Render chart columns
                    if (this.behavior) {
                        for (var i = 0, len = layers.length; i < len; i++) {
                            var result = layers[i].render(suppressAnimations);
                            if (result) {
                                dataPoints = dataPoints.concat(result.dataPoints);
                                layerBehaviorOptions.push(result.behaviorOptions);
                                if (result.labelDataPointGroups) {
                                    var resultLabelDataPointsGroups = result.labelDataPointGroups;
                                    for (var j = 0, jlen = resultLabelDataPointsGroups.length; j < jlen; j++) {
                                        var resultLabelDataPointsGroup = resultLabelDataPointsGroups[j];
                                        labelDataPointsGroup.push({
                                            labelDataPoints: resultLabelDataPointsGroup.labelDataPoints,
                                            maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels,
                                        });
                                    }
                                }
                                else {
                                    var resultsLabelDataPoints = result.labelDataPoints;
                                    var reducedDataPoints = resultsLabelDataPoints;
                                    labelDataPointsGroup.push({
                                        labelDataPoints: reducedDataPoints,
                                        maxNumberOfLabels: reducedDataPoints.length,
                                    });
                                }
                            }
                        }
                        var labelLayoutOptions = {
                            maximumOffset: NewDataLabelUtils.maxLabelOffset,
                            startingOffset: NewDataLabelUtils.startingLabelOffset
                        };
                        var labelLayout = new powerbi.LabelLayout(labelLayoutOptions);
                        var dataLabels = labelLayout.layout(labelDataPointsGroup, chartViewport);
                        if (layers.length > 1) {
                            NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContextScrollable, dataLabels, "#FFFFFF", 0.7);
                        }
                        if (this.animator && !suppressAnimations) {
                            NewDataLabelUtils.animateDefaultLabels(this.labelGraphicsContextScrollable, dataLabels, this.animator.getDuration());
                        }
                        else {
                            NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContextScrollable, dataLabels);
                        }
                        this.labelGraphicsContextScrollable.selectAll("text.label").style("pointer-events", "none");
                        if (this.interactivityService) {
                            var behaviorOptions = {
                                layerOptions: layerBehaviorOptions,
                                clearCatcher: this.clearCatcher,
                            };
                            this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                        }
                    }
                };
                /**
                 * Within the context of the given selection (g), find the offset of
                 * the zero tick using the d3 attached datum of g.tick elements.
                 * 'Classed' is undefined for transition selections
                 */
                MekkoChart.darkenZeroLine = function (g) {
                    var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();
                    if (zeroTick) {
                        d3.select(zeroTick).select('line').classed('zero-line', true);
                    }
                };
                MekkoChart.setAxisLabelColor = function (g, fill) {
                    g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);
                };
                MekkoChart.setAxisLabelFontSize = function (g, fontSize) {
                    var value = jsCommon.PixelConverter.toString(fontSize);
                    g.selectAll('g.tick text').attr('font-size', value);
                };
                MekkoChart.moveBorder = function (g, scale, borderWidth, yOffset) {
                    if (yOffset === void 0) { yOffset = 0; }
                    g.selectAll('g.tick')
                        .attr("transform", function (value, index) {
                        return visuals.SVGUtil.translate(scale(value) + (borderWidth * index), yOffset);
                    });
                };
                MekkoChart.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Category',
                        }, {
                            name: 'Series',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Series',
                        }, {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Y Axis',
                        }, {
                            name: 'Width',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Axis width',
                        }
                    ],
                    objects: {
                        columnBorder: {
                            displayName: 'Column Border',
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                width: {
                                    displayName: 'Width',
                                    type: { numeric: true }
                                },
                            },
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                showSeries: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                labelDisplayUnits: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                                    type: { formatting: { labelDisplayUnits: true } },
                                    suppressFormatPainterCopy: true
                                },
                                labelPrecision: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                                    placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                                    type: { numeric: true },
                                    suppressFormatPainterCopy: true
                                },
                                showAll: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_ShowAll'),
                                    type: { bool: true }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                },
                            },
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    type: { formatting: { legendPosition: true } }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: 'Title text',
                                    type: { text: true }
                                },
                                fontSize: {
                                    displayName: 'Text size',
                                    type: { formatting: { fontSize: true } }
                                },
                            }
                        },
                        categoryAxis: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                    type: { formatting: { yAxisPosition: true } }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                    type: { formatting: { axisScale: true } }
                                },
                                /*start: {
                                    displayName: data.createDisplayNameGetter('Visual_Axis_Start'),
                                    type: { numeric: true }
                                },
                                end: {
                                    displayName: data.createDisplayNameGetter('Visual_Axis_End'),
                                    type: { numeric: true }
                                },*/
                                axisType: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
                                    type: { formatting: { axisType: true } }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                    type: { bool: true }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                    type: { formatting: { axisStyle: true } }
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                },
                            }
                        },
                        valueAxis: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                    type: { formatting: { yAxisPosition: true } }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                    type: { formatting: { axisScale: true } }
                                },
                                /*start: {
                                    displayName: data.createDisplayNameGetter('Visual_Axis_Start'),
                                    type: { numeric: true }
                                },
                                end: {
                                    displayName: data.createDisplayNameGetter('Visual_Axis_End'),
                                    type: { numeric: true }
                                },*/
                                intersection: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Intersection'),
                                    type: { numeric: true }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                    type: { bool: true }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                    type: { formatting: { axisStyle: true } }
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_LabelColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                },
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                    type: { fillRule: {} },
                                    rule: {
                                        inputRole: 'Gradient',
                                        output: {
                                            property: 'fill',
                                            selector: ['Category'],
                                        },
                                    },
                                }
                            }
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { min: 0, max: 1 }, 'Series': { min: 0, max: 1 }, 'Y': { min: 0, max: 1 }, 'Width': { min: 0, max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Series',
                                        select: [{ for: { in: 'Y' } }, { for: { in: 'Width' } }],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                },
                                rowCount: { preferred: { min: 1, max: 1 }, supported: { min: 0 } }
                            },
                        }],
                    supportsHighlight: true,
                    sorting: {
                        default: {},
                    },
                    drilldown: {
                        roles: ['Category']
                    },
                };
                MekkoChart.properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    columnBorder: {
                        show: { objectName: 'columnBorder', propertyName: 'show', },
                        color: { objectName: 'columnBorder', propertyName: 'color' },
                        width: { objectName: 'columnBorder', propertyName: 'width' },
                    },
                };
                MekkoChart.DefaultSettings = {
                    columnBorder: {
                        show: true,
                        color: '#fff',
                        width: 2,
                        maxWidth: 5,
                    },
                    labelSettings: {
                        maxPrecision: 4,
                        minPrecision: 0,
                    }
                };
                MekkoChart.MinOrdinalRectThickness = 20;
                MekkoChart.MinScalarRectThickness = 2;
                MekkoChart.OuterPaddingRatio = 0.4;
                MekkoChart.InnerPaddingRatio = 0.2;
                MekkoChart.TickLabelPadding = 2;
                MekkoChart.ClassName = 'cartesianChart';
                MekkoChart.AxisGraphicsContextClassName = 'axisGraphicsContext';
                MekkoChart.MaxMarginFactor = 0.25;
                MekkoChart.MinBottomMargin = 50;
                MekkoChart.LeftPadding = 10;
                MekkoChart.RightPadding = 10;
                MekkoChart.BottomPadding = 16;
                MekkoChart.YAxisLabelPadding = 20;
                MekkoChart.XAxisLabelPadding = 20;
                MekkoChart.TickPaddingY = 10;
                MekkoChart.TickPaddingRotatedX = 5;
                MekkoChart.FontSize = 11;
                MekkoChart.MaxNumberOfLabels = 100;
                MekkoChart.MinWidth = 100;
                MekkoChart.MinHeight = 100;
                MekkoChart.ScrollBarWidth = 10;
                return MekkoChart;
            }());
            samples.MekkoChart = MekkoChart;
            function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, xAxisTextProperties, y1AxisTextProperties, y2AxisTextProperties, enableOverflowCheck, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                var XLabelMaxAllowedOverflow = 35;
                debug.assertValue(axes, 'axes');
                var xAxisProperties = axes.x;
                var y1AxisProperties = axes.y1;
                var y2AxisProperties = axes.y2;
                debug.assertValue(viewport, 'viewport');
                debug.assertValue(textWidthMeasurer, 'textWidthMeasurer');
                debug.assertValue(textHeightMeasurer, 'textHeightMeasurer');
                debug.assertValue(xAxisProperties, 'xAxis');
                debug.assertValue(y1AxisProperties, 'yAxis');
                var xLabels = xAxisProperties.values;
                var y1Labels = y1AxisProperties.values;
                var leftOverflow = 0;
                var rightOverflow = 0;
                var maxWidthY1 = 0;
                var maxWidthY2 = 0;
                var xMax = 0; // bottom margin
                var ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0;
                var scaleIsOrdinal = visuals.AxisHelper.isOrdinalScale(xAxisProperties.scale);
                var xLabelOuterPadding = 0;
                if (xAxisProperties.outerPadding !== undefined) {
                    xLabelOuterPadding = xAxisProperties.outerPadding;
                }
                else if (xAxisProperties.xLabelMaxWidth !== undefined) {
                    xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);
                }
                if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0
                    || visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {
                    var rotation;
                    if (scrollbarVisible)
                        rotation = visuals.AxisHelper.LabelLayoutStrategy.DefaultRotationWithScrollbar;
                    else
                        rotation = visuals.AxisHelper.LabelLayoutStrategy.DefaultRotation;
                    if (renderY1Axis) {
                        for (var i = 0, len = y1Labels.length; i < len; i++) {
                            y1AxisTextProperties.text = y1Labels[i];
                            maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(y1AxisTextProperties));
                        }
                    }
                    if (y2AxisProperties && renderY2Axis) {
                        var y2Labels = y2AxisProperties.values;
                        for (var i = 0, len = y2Labels.length; i < len; i++) {
                            y2AxisTextProperties.text = y2Labels[i];
                            maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(y2AxisTextProperties));
                        }
                    }
                    var textHeight = textHeightMeasurer(xAxisTextProperties);
                    var maxNumLines = Math.floor(bottomMarginLimit / textHeight);
                    var xScale = xAxisProperties.scale;
                    var xDomain = xScale.domain();
                    if (renderXAxis && xLabels.length > 0) {
                        for (var i = 0, len = xLabels.length; i < len; i++) {
                            // find the max height of the x-labels, perhaps rotated or wrapped
                            var height;
                            xAxisTextProperties.text = xLabels[i];
                            var width = textWidthMeasurer(xAxisTextProperties);
                            if (xAxisProperties.willLabelsWordBreak) {
                                // Split label and count rows
                                var wordBreaks = jsCommon.WordBreaker.splitByWidth(xAxisTextProperties.text, xAxisTextProperties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
                                height = wordBreaks.length * textHeight;
                                // word wrapping will truncate at xLabelMaxWidth
                                width = xAxisProperties.xLabelMaxWidth;
                            }
                            else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {
                                height = width * rotation.sine;
                                width = width * rotation.cosine;
                            }
                            else {
                                height = textHeight;
                            }
                            // calculate left and right overflow due to wide X labels
                            // (Note: no right overflow when rotated)
                            if (i === 0) {
                                if (scaleIsOrdinal) {
                                    if (!xAxisProperties.willLabelsFit /*rotated text*/)
                                        leftOverflow = width - ordinalLabelOffset - xLabelOuterPadding;
                                    else
                                        leftOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
                                    leftOverflow = Math.max(leftOverflow, 0);
                                }
                                else if (xDomain.length > 1) {
                                    // Scalar - do some math
                                    var xPos = xScale(xDomain[0]);
                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
                                    leftOverflow = (width / 2) - xPos;
                                    leftOverflow = Math.max(leftOverflow, 0);
                                }
                            }
                            else if (i === len - 1) {
                                if (scaleIsOrdinal) {
                                    // if we are rotating text (!willLabelsFit) there won't be any right overflow
                                    if (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) {
                                        // assume this label is placed near the edge
                                        rightOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
                                        rightOverflow = Math.max(rightOverflow, 0);
                                    }
                                }
                                else if (xDomain.length > 1) {
                                    // Scalar - do some math
                                    var xPos = xScale(xDomain[1]);
                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
                                    rightOverflow = (width / 2) - (viewport.width - xPos);
                                    rightOverflow = Math.max(rightOverflow, 0);
                                }
                            }
                            xMax = Math.max(xMax, height);
                        }
                        // trim any actual overflow to the limit
                        leftOverflow = enableOverflowCheck ? Math.min(leftOverflow, XLabelMaxAllowedOverflow) : 0;
                        rightOverflow = enableOverflowCheck ? Math.min(rightOverflow, XLabelMaxAllowedOverflow) : 0;
                    }
                }
                var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
                if (showOnRight) {
                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit);
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit);
                }
                else {
                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit);
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit);
                }
                return {
                    xMax: Math.ceil(bottomMargin),
                    yLeft: Math.ceil(leftMargin),
                    yRight: Math.ceil(rightMargin),
                };
            }
            function getLayerData(dataViews, currentIdx, totalLayers) {
                if (totalLayers > 1) {
                    if (dataViews && dataViews.length > currentIdx)
                        return [dataViews[currentIdx]];
                    return [];
                }
                return dataViews;
            }
            /**
             * Returns a boolean, that indicates if y axis title should be displayed.
             * @return True if y axis title should be displayed,
             * otherwise false.
             */
            function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
                return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) ||
                    (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));
            }
            /**
             * Computes the Cartesian Chart axes from the set of layers.
             */
            function calculateAxes(layers, viewport, margin, categoryAxisProperties, valueAxisProperties, scrollbarVisible, existingAxisProperties) {
                debug.assertValue(layers, 'layers');
                var visualOptions = {
                    viewport: viewport,
                    margin: margin,
                    forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],
                    forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,
                    showCategoryAxisLabel: false,
                    showValueAxisLabel: false,
                    categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? categoryAxisProperties['axisScale'] : visuals.axisScale.linear,
                    valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? valueAxisProperties['axisScale'] : visuals.axisScale.linear,
                    trimOrdinalDataOnOverflow: false
                };
                var yAxisWillMerge = false;
                if (valueAxisProperties) {
                    visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);
                }
                var result;
                for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
                    var currentlayer = layers[layerNumber];
                    visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']); //here
                    //visualOptions.showBorder = (!!categoryAxisProperties && !!categoryAxisProperties['showBorder']);//here
                    visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                    var axes = currentlayer.calculateAxesProperties(visualOptions);
                    if (layerNumber === 0) {
                        result = {
                            x: axes[0],
                            y1: axes[1]
                        };
                    }
                    result.x.willLabelsFit = false;
                    result.x.willLabelsWordBreak = false;
                }
                return result;
            }
            function createLayers(type, objects, interactivityService, animator, isScrollable) {
                if (isScrollable === void 0) { isScrollable = true; }
                var layers = [];
                var cartesianOptions = {
                    isScrollable: isScrollable,
                    animator: animator,
                    interactivityService: interactivityService
                };
                layers.push(createMekkoChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions));
                return layers;
            }
            samples.createLayers = createLayers;
            function createMekkoChartLayer(type, defaultOptions) {
                var options = {
                    animator: defaultOptions.animator,
                    interactivityService: defaultOptions.interactivityService,
                    isScrollable: defaultOptions.isScrollable,
                    chartType: type
                };
                return new MekkoColumnChart(options);
            }
            var EnumExtensions = jsCommon.EnumExtensions;
            var ArrayExtensions = jsCommon.ArrayExtensions;
            var flagBar = 1 << 1;
            //var flagColumn: number = 1 << 2;
            var flagStacked = 1 << 4;
            var RoleNames = {
                category: 'Category',
                series: 'Series',
                y: 'Y',
                width: 'Width'
            };
            var MekkoColumnChart = (function () {
                function MekkoColumnChart(options) {
                    debug.assertValue(options, 'options');
                    var chartType = options.chartType;
                    debug.assertValue(chartType, 'chartType');
                    this.chartType = chartType;
                    this.categoryAxisType = null;
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable;
                    this.interactivityService = options.interactivityService;
                }
                MekkoColumnChart.prototype.init = function (options) {
                    this.svg = options.svg;
                    this.unclippedGraphicsContext = this.svg.append('g').classed('columnChartUnclippedGraphicsContext', true);
                    this.mainGraphicsContext = this.unclippedGraphicsContext.append('svg').classed('columnChartMainGraphicsContext', true);
                    this.labelGraphicsContext = this.svg.append('g').classed(NewDataLabelUtils.labelGraphicsContextClass.class, true);
                    this.style = options.style;
                    this.currentViewport = options.viewport;
                    this.hostService = options.host;
                    this.interactivity = options.interactivity;
                    this.colors = this.style.colorPalette.dataColors;
                    this.cartesianVisualHost = options.cartesianHost;
                    this.options = options;
                    this.supportsOverflow = !EnumExtensions.hasFlag(this.chartType, flagStacked);
                    var element = this.element = options.element;
                    element.addClass(MekkoColumnChart.ColumnChartClassName);
                    this.columnChart = new MekkoColumnChartStrategy();
                };
                MekkoColumnChart.prototype.getCategoryLayout = function (numCategoryValues, options) {
                    var availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right);
                    var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                    var categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                    var isScalar = this.data ? this.data.scalarCategoryAxis : false;
                    var domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain);
                    return visuals.CartesianChart.getLayout(this.data, {
                        availableWidth: availableWidth,
                        categoryCount: numCategoryValues,
                        domain: domain,
                        isScalar: isScalar,
                        isScrollable: this.isScrollable,
                        trimOrdinalDataOnOverflow: false
                    });
                };
                MekkoColumnChart.getBorderWidth = function (border) {
                    if (!border ||
                        !border.show ||
                        !border.width) {
                        return 0;
                    }
                    var width = border.width;
                    if (width < 0) {
                        return 0;
                    }
                    if (width > border.maxWidth) {
                        return border.maxWidth;
                    }
                    return width;
                };
                MekkoColumnChart.getBorderColor = function (border) {
                    if (!border) {
                        return MekkoChart.DefaultSettings.columnBorder.color;
                    }
                    return border.color;
                };
                MekkoColumnChart.converter = function (dataView, colors, is100PercentStacked, isScalar, supportsOverflow, dataViewMetadata, chartType) {
                    if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                    if (isScalar === void 0) { isScalar = false; }
                    if (supportsOverflow === void 0) { supportsOverflow = false; }
                    if (dataViewMetadata === void 0) { dataViewMetadata = null; }
                    debug.assertValue(dataView, 'dataView');
                    debug.assertValue(colors, 'colors');
                    var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                    var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                    isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                    dataView = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView, xAxisCardProperties);
                    var converterStrategy = new ColumnChartConverterHelper(dataView);
                    var categoryInfo = visuals.converterHelper.getPivotedCategories(dataView, visuals.columnChartProps.general.formatString);
                    var categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataView.categories && dataView.categories.length > 0 ? dataView.categories[0].source : undefined;
                    //labelFormatString: string = dataView.values && dataView.values[0] ? valueFormatter.getFormatString(dataView.values[0].source, columnChartProps.general.formatString) : undefined;
                    var borderSettings = MekkoChart.DefaultSettings.columnBorder;
                    var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(true);
                    var defaultDataPointColor = undefined;
                    var showAllDataPoints = undefined;
                    if (dataViewMetadata && dataViewMetadata.objects) {
                        var objects = dataViewMetadata.objects;
                        defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                        showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                        labelSettings = MekkoChart.parseLabelSettings(objects);
                        borderSettings = MekkoChart.parseBorderSettings(objects);
                    }
                    // Allocate colors
                    var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultDataPointColor);
                    var legend = legendAndSeriesInfo.legend.dataPoints;
                    var seriesSources = legendAndSeriesInfo.seriesSources;
                    // Determine data points
                    var result = MekkoColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, supportsOverflow, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata);
                    var columnSeries = result.series;
                    var valuesMetadata = [];
                    for (var j = 0, jlen = legend.length; j < jlen; j++) {
                        valuesMetadata.push(seriesSources[j]);
                    }
                    var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                    return {
                        categories: categories,
                        categoriesWidth: result.categoriesWidth,
                        categoryFormatter: categoryFormatter,
                        series: columnSeries,
                        valuesMetadata: valuesMetadata,
                        legendData: legendAndSeriesInfo.legend,
                        hasHighlights: result.hasHighlights,
                        categoryMetadata: categoryMetadata,
                        scalarCategoryAxis: isScalar,
                        borderSettings: borderSettings,
                        labelSettings: labelSettings,
                        axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },
                        hasDynamicSeries: result.hasDynamicSeries,
                        defaultDataPointColor: defaultDataPointColor,
                        showAllDataPoints: showAllDataPoints,
                        isMultiMeasure: false,
                    };
                };
                MekkoColumnChart.getStackedMultiplier = function (rawValues, rowIdx, seriesCount, categoryCount) {
                    var pos = 0, neg = 0;
                    for (var i = 0; i < seriesCount; i++) {
                        var value = rawValues[i][rowIdx];
                        value = visuals.AxisHelper.normalizeNonFiniteNumber(value);
                        if (value > 0) {
                            pos += value;
                        }
                        else if (value < 0) {
                            neg -= value;
                        }
                    }
                    var absTotal = pos + neg;
                    return {
                        pos: pos ? (pos / absTotal) / pos : 1,
                        neg: neg ? (neg / absTotal) / neg : 1,
                    };
                };
                MekkoColumnChart.createDataPoints = function (dataViewCat, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, supportsOverflow, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata) {
                    if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                    if (isScalar === void 0) { isScalar = false; }
                    if (supportsOverflow === void 0) { supportsOverflow = false; }
                    var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;
                    var categoryCount = categories.length;
                    var seriesCount = legend.length;
                    var columnSeries = [];
                    if (seriesCount < 1 || categoryCount < 1 || categories[0] === null) {
                        return { series: columnSeries,
                            hasHighlights: false,
                            hasDynamicSeries: false,
                            categoriesWidth: [],
                        };
                    }
                    var dvCategories = dataViewCat.categories;
                    categoryMetadata = (dvCategories && dvCategories.length > 0)
                        ? dvCategories[0].source
                        : null;
                    var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                    var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                    var baseValuesPos = [], baseValuesNeg = [];
                    var rawValues = [];
                    var rawHighlightValues = [];
                    var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);
                    var widthColumns = [];
                    var widthIndex = -1;
                    var seriesIndex = 0;
                    var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different
                    var hasHighlights = converterStrategy.hasHighlightValues(0);
                    for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {
                        if (dataViewCat.values[seriesIndex].source.roles &&
                            dataViewCat.values[seriesIndex].source.roles[RoleNames.width] &&
                            !dataViewCat.values[seriesIndex].source.roles[RoleNames.y]) {
                            widthIndex = seriesIndex;
                            var widthValues = dataViewCat.values[seriesIndex].values;
                            for (var i = 0, valuesLen = widthValues.length; i < valuesLen; i++) {
                                widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);
                            }
                            continue;
                        }
                        var seriesValues = [];
                        var seriesHighlightValues = [];
                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                            var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                            seriesValues[categoryIndex] = value;
                            if (hasHighlights) {
                                var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                                seriesHighlightValues[categoryIndex] = highlightValue;
                                // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.
                                if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) ||
                                    (value <= 0 && highlightValue <= 0 && value <= highlightValue))) {
                                    highlightsOverflow = true;
                                }
                            }
                        }
                        rawValues.push(seriesValues);
                        if (hasHighlights) {
                            rawHighlightValues.push(seriesHighlightValues);
                        }
                    }
                    //console.log(dataViewCat);
                    if (highlightsOverflow && !supportsOverflow) {
                        highlightsOverflow = false;
                        hasHighlights = false;
                        rawValues = rawHighlightValues;
                    }
                    if (widthColumns.length < 1) {
                        for (seriesIndex = 0; seriesIndex < dataViewCat.values.length; seriesIndex++) {
                            if (dataViewCat.values[seriesIndex].source.roles &&
                                dataViewCat.values[seriesIndex].source.roles[RoleNames.width]) {
                                widthIndex = seriesIndex;
                                var widthValues = dataViewCat.values[seriesIndex].values;
                                for (var i = 0, valuesLen = widthValues.length; i < valuesLen; i++) {
                                    widthColumns[i] = d3.sum([0, widthColumns[i], widthValues[i]]);
                                }
                                continue;
                            }
                        }
                    }
                    if (widthColumns.length < 1) {
                        for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {
                            widthColumns.push(1);
                        }
                    }
                    var totalSum = d3.sum(widthColumns);
                    var linearScale = d3.scale.linear()
                        .domain([0, totalSum])
                        .range([0, 1]);
                    var columnStartX = [0];
                    var columnWidth = [];
                    for (seriesIndex = 0; seriesIndex < (categoryCount - 1); seriesIndex++) {
                        var stepWidth = columnStartX[columnStartX.length - 1] + (widthColumns[seriesIndex] || 0);
                        columnStartX.push(stepWidth);
                    }
                    for (seriesIndex = 0; seriesIndex < categoryCount; seriesIndex++) {
                        columnStartX[seriesIndex] = linearScale(columnStartX[seriesIndex]);
                        columnWidth[seriesIndex] = linearScale(widthColumns[seriesIndex]);
                    }
                    var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
                    for (seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                        var seriesDataPoints = [], legendItem = legend[seriesIndex], seriesLabelSettings;
                        if (!hasDynamicSeries) {
                            var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;
                            var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
                            if (labelObjects) {
                                seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings);
                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);
                            }
                        }
                        var series = {
                            displayName: legendItem.label,
                            key: 'series' + seriesIndex,
                            index: seriesIndex,
                            data: seriesDataPoints,
                            identity: legendItem.identity,
                            color: legendItem.color,
                            labelSettings: seriesLabelSettings,
                        };
                        if (seriesCount > 1) {
                            dataPointObjects = seriesObjectsList[seriesIndex];
                        }
                        var metadata = dataViewCat.values[seriesIndex].source;
                        for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                            if (seriesIndex === 0) {
                                baseValuesPos.push(0);
                                baseValuesNeg.push(0);
                            }
                            var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                            if (value == null) {
                                // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.
                                // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.
                                if (seriesIndex > 0) {
                                    continue;
                                }
                            }
                            var originalValue = value;
                            var categoryValue = categories[categoryIndex];
                            if (isDateTime && categoryValue) {
                                categoryValue = categoryValue.getTime();
                            }
                            if (isScalar && (categoryValue == null || isNaN(categoryValue))) {
                                continue;
                            }
                            var multipliers;
                            if (is100PercentStacked) {
                                //multipliers = StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);
                                multipliers = MekkoColumnChart.getStackedMultiplier(rawValues, categoryIndex, seriesCount, categoryCount);
                            }
                            var unadjustedValue = value, isNegative = value < 0;
                            if (multipliers) {
                                if (isNegative) {
                                    value *= multipliers.neg;
                                }
                                else {
                                    value *= multipliers.pos;
                                }
                            }
                            var valueAbsolute = Math.abs(value);
                            var position;
                            if (isNegative) {
                                position = baseValuesNeg[categoryIndex];
                                if (!isNaN(valueAbsolute)) {
                                    baseValuesNeg[categoryIndex] -= valueAbsolute;
                                }
                            }
                            else {
                                if (!isNaN(valueAbsolute)) {
                                    baseValuesPos[categoryIndex] += valueAbsolute;
                                }
                                position = baseValuesPos[categoryIndex];
                            }
                            var columnGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex] : null;
                            var category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null;
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(category, categoryIndex)
                                .withSeries(dataViewCat.values, columnGroup)
                                .withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex))
                                .createSelectionId();
                            var rawCategoryValue = categories[categoryIndex];
                            var color = MekkoColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);
                            var seriesData = [];
                            if (columnGroup) {
                                var seriesValueColumn = {
                                    values: [],
                                    source: dataViewCat.values.source,
                                };
                                seriesData.push({
                                    value: columnGroup.name,
                                    metadata: seriesValueColumn,
                                });
                                for (var columnIndex = 0; columnIndex < columnGroup.values.length; columnIndex++) {
                                    var columnValues = columnGroup.values[columnIndex];
                                    seriesData.push({
                                        value: columnValues.values[categoryIndex],
                                        metadata: columnValues,
                                    });
                                }
                            }
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null /*dataViewCat*/, rawCategoryValue, originalValue, [category], seriesData, null /*seriesIndex*/, categoryIndex);
                            var dataPointLabelSettings = (series && series.labelSettings) ? series.labelSettings : defaultLabelSettings;
                            var labelColor = dataPointLabelSettings.labelColor;
                            var lastValue = undefined;
                            //Stacked column/bar label color is white by default (except last series)
                            if ((EnumExtensions.hasFlag(chartType, flagStacked))) {
                                lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);
                                labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor;
                            }
                            value = columnWidth[categoryIndex];
                            var originalPosition = columnStartX[categoryIndex];
                            var dataPoint = {
                                categoryValue: categoryValue,
                                value: value,
                                position: position,
                                valueAbsolute: valueAbsolute,
                                valueOriginal: unadjustedValue,
                                seriesIndex: seriesIndex,
                                labelSettings: dataPointLabelSettings,
                                categoryIndex: categoryIndex,
                                color: color,
                                selected: false,
                                originalValue: value,
                                originalPosition: originalPosition,
                                originalValueAbsolute: valueAbsolute,
                                identity: identity,
                                key: identity.getKey(),
                                tooltipInfo: tooltipInfo,
                                labelFill: labelColor,
                                labelFormatString: metadata.format,
                                lastSeries: lastValue,
                                chartType: chartType,
                            };
                            seriesDataPoints.push(dataPoint);
                            if (hasHighlights) {
                                var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];
                                var unadjustedValueHighlight = valueHighlight;
                                var highlightedTooltip = true;
                                if (valueHighlight === null) {
                                    valueHighlight = 0;
                                    highlightedTooltip = false;
                                }
                                if (is100PercentStacked) {
                                    valueHighlight *= multipliers.pos;
                                }
                                var absoluteValueHighlight = Math.abs(valueHighlight);
                                var highlightPosition = position;
                                if (valueHighlight > 0) {
                                    highlightPosition -= valueAbsolute - absoluteValueHighlight;
                                }
                                else if (valueHighlight === 0 && value > 0) {
                                    highlightPosition -= valueAbsolute;
                                }
                                var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                                var rawCategoryValue = categories[categoryIndex];
                                //var highlightedValue: number = highlightedTooltip ? valueHighlight : undefined;
                                //var tooltipInfo: TooltipDataItem[] = TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValue, null, null, seriesIndex, categoryIndex, highlightedValue);
                                if (highlightedTooltip) {
                                    // Override non highlighted data point
                                    dataPoint.tooltipInfo = tooltipInfo;
                                }
                                var highlightDataPoint = {
                                    categoryValue: categoryValue,
                                    value: value,
                                    position: highlightPosition,
                                    valueAbsolute: absoluteValueHighlight,
                                    valueOriginal: unadjustedValueHighlight,
                                    seriesIndex: seriesIndex,
                                    labelSettings: dataPointLabelSettings,
                                    categoryIndex: categoryIndex,
                                    color: color,
                                    selected: false,
                                    highlight: true,
                                    originalValue: value,
                                    originalPosition: originalPosition,
                                    originalValueAbsolute: valueAbsolute,
                                    drawThinner: highlightsOverflow,
                                    identity: highlightIdentity,
                                    key: highlightIdentity.getKey(),
                                    tooltipInfo: tooltipInfo,
                                    labelFormatString: metadata.format,
                                    labelFill: labelColor,
                                    lastSeries: lastValue,
                                    chartType: chartType,
                                };
                                seriesDataPoints.push(highlightDataPoint);
                            }
                        }
                        columnSeries.push(series);
                    }
                    return {
                        series: columnSeries,
                        categoriesWidth: columnWidth,
                        hasHighlights: hasHighlights,
                        hasDynamicSeries: hasDynamicSeries,
                    };
                };
                MekkoColumnChart.getDataPointColor = function (legendItem, categoryIndex, dataPointObjects) {
                    debug.assertValue(legendItem, 'legendItem');
                    debug.assertValue(categoryIndex, 'categoryIndex');
                    debug.assertAnyValue(dataPointObjects, 'dataPointObjects');
                    if (dataPointObjects) {
                        var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                        if (colorOverride) {
                            return colorOverride;
                        }
                    }
                    return legendItem.color;
                };
                MekkoColumnChart.getStackedLabelColor = function (isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                    var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);
                    //run for the next series and check if current series is last
                    for (var i = seriesIndex + 1; i < seriesCount; i++) {
                        var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                        if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {
                            lastValue = false;
                            break;
                        }
                    }
                    return lastValue;
                };
                MekkoColumnChart.sliceSeries = function (series, endIndex, startIndex) {
                    if (startIndex === void 0) { startIndex = 0; }
                    var newSeries = [];
                    if (series && series.length > 0) {
                        for (var i = 0, len = series.length; i < len; i++) {
                            var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                            iNewSeries.data = series[i].data.filter(function (d) { return d.categoryIndex >= startIndex && d.categoryIndex < endIndex; });
                        }
                    }
                    return newSeries;
                };
                MekkoColumnChart.getInteractiveColumnChartDomElement = function (element) {
                    return element.children("svg").get(0);
                };
                MekkoColumnChart.prototype.getColumnsWidth = function () {
                    var data = this.data;
                    if (!data ||
                        !data.series ||
                        !data.series[0] ||
                        !data.series[0].data) {
                        return [];
                    }
                    return data.categoriesWidth;
                };
                MekkoColumnChart.prototype.getBorderWidth = function () {
                    return MekkoColumnChart.getBorderWidth(this.data.borderSettings);
                };
                MekkoColumnChart.prototype.setData = function (dataViews) {
                    debug.assertValue(dataViews, "dataViews");
                    var is100PctStacked = true;
                    this.data = {
                        categories: [],
                        categoriesWidth: [],
                        categoryFormatter: null,
                        series: [],
                        valuesMetadata: [],
                        legendData: null,
                        hasHighlights: false,
                        categoryMetadata: null,
                        scalarCategoryAxis: false,
                        borderSettings: null,
                        labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked),
                        axesLabels: { x: null, y: null },
                        hasDynamicSeries: false,
                        defaultDataPointColor: null,
                        isMultiMeasure: false,
                    };
                    if (dataViews.length > 0) {
                        var dataView = dataViews[0];
                        if (dataView && dataView.categorical) {
                            var dataViewCat = this.dataViewCat = dataView.categorical;
                            /*
                            var dvCategories = dataViewCat.categories;
                            var categoryMetadata = (dvCategories && dvCategories.length > 0)
                                ? dvCategories[0].source
                                : null;
                            var categoryType = AxisHelper.getCategoryValueType(categoryMetadata);
                            */
                            this.data = MekkoColumnChart.converter(dataViewCat, this.cartesianVisualHost.getSharedColors(), true, //s100PctStacked,
                            false, //CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, columnChartProps.categoryAxis.axisType, categoryType),
                            this.supportsOverflow, dataView.metadata, this.chartType);
                            var series = this.data.series;
                            for (var i = 0, ilen = series.length; i < ilen; i++) {
                                var currentSeries = series[i];
                                if (this.interactivityService) {
                                    this.interactivityService.applySelectionStateToData(currentSeries.data);
                                }
                            }
                        }
                    }
                };
                MekkoColumnChart.prototype.calculateLegend = function () {
                    // if we're in interactive mode, return the interactive legend
                    if (this.interactivity && this.interactivity.isInteractiveLegend) {
                        return this.createInteractiveMekkoLegendDataPoints(0);
                    }
                    var legendData = this.data ? this.data.legendData : null;
                    var MekkoLegendDataPoints = legendData ? legendData.dataPoints : [];
                    if (ArrayExtensions.isUndefinedOrEmpty(MekkoLegendDataPoints))
                        return null;
                    return legendData;
                };
                MekkoColumnChart.prototype.hasLegend = function () {
                    return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
                };
                MekkoColumnChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                    switch (options.objectName) {
                        case 'dataPoint':
                            if (!visuals.GradientUtils.hasGradientRole(this.dataViewCat))
                                this.enumerateDataPoints(enumeration);
                            break;
                        case 'labels':
                            this.enumerateDataLabels(enumeration);
                            break;
                    }
                };
                MekkoColumnChart.prototype.enumerateDataLabels = function (enumeration) {
                    var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length;
                    //Draw default settings
                    visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, false));
                    if (seriesCount === 0) {
                        return;
                    }
                    //Draw series settings
                    if (!data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata)) {
                        for (var i = 0; i < seriesCount; i++) {
                            var series = data.series[i], labelSettings = (series.labelSettings) ? series.labelSettings : this.data.labelSettings;
                            //enumeration.pushContainer({ displayName: series.displayName });
                            visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, true, series));
                        }
                    }
                };
                MekkoColumnChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, isSeries, series) {
                    var is100PctStacked = true;
                    return {
                        enumeration: enumeration,
                        dataLabelsSettings: labelSettings,
                        show: !isSeries,
                        displayUnits: is100PctStacked,
                        precision: true,
                        selector: series && series.identity ? series.identity.getSelector() : null
                    };
                };
                MekkoColumnChart.prototype.enumerateDataPoints = function (enumeration) {
                    var data = this.data;
                    if (!data || !data.series) {
                        return;
                    }
                    var seriesCount = data.series.length;
                    if (seriesCount === 0) {
                        return;
                    }
                    if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) {
                        for (var i = 0; i < seriesCount; i++) {
                            var series = data.series[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: series.displayName,
                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                properties: {
                                    fill: { solid: { color: series.color } }
                                },
                            });
                        }
                    }
                    else {
                        // For single-category, single-measure column charts, the user can color the individual bars.
                        var singleSeriesData = data.series[0].data;
                        var categoryFormatter = data.categoryFormatter;
                        // Add default color and show all slices
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            selector: null,
                            properties: {
                                defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                            }
                        }).pushInstance({
                            objectName: 'dataPoint',
                            selector: null,
                            properties: {
                                showAllDataPoints: !!data.showAllDataPoints
                            }
                        });
                        for (var i = 0; i < singleSeriesData.length; i++) {
                            var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                                selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
                                properties: {
                                    fill: { solid: { color: singleSeriesDataPoints.color } }
                                },
                            });
                        }
                    }
                };
                MekkoColumnChart.prototype.calculateAxesProperties = function (options) {
                    var data = this.data;
                    this.currentViewport = options.viewport;
                    var margin = this.margin = options.margin;
                    var origCatgSize = (data && data.categories) ? data.categories.length : 0;
                    var chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                        categoryCount: 0,
                        categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                        outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                        isScalar: false
                    };
                    this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null;
                    this.columnChart.setData(data);
                    var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                    /* preferredPlotArea would be same as currentViewport width when there is no scrollbar.
                     In that case we want to calculate the available plot area for the shapes by subtracting the margin from available viewport */
                    if (preferredPlotArea.width === this.currentViewport.width) {
                        preferredPlotArea.width -= (margin.left + margin.right);
                    }
                    preferredPlotArea.height -= (margin.top + margin.bottom);
                    var is100Pct = true;
                    // When the category axis is scrollable the height of the category axis and value axis will be different
                    // The height of the value axis would be same as viewportHeight
                    var chartContext = {
                        height: preferredPlotArea.height,
                        width: preferredPlotArea.width,
                        duration: 0,
                        hostService: this.hostService,
                        unclippedGraphicsContext: this.unclippedGraphicsContext,
                        mainGraphicsContext: this.mainGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        margin: this.margin,
                        layout: chartLayout,
                        animator: this.animator,
                        interactivityService: this.interactivityService,
                        viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                        viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                        is100Pct: is100Pct,
                        isComboChart: true,
                    };
                    this.ApplyInteractivity(chartContext);
                    this.columnChart.setupVisualProps(chartContext);
                    var isBarChart = EnumExtensions.hasFlag(this.chartType, flagBar);
                    if (isBarChart) {
                        var temp = options.forcedXDomain;
                        options.forcedXDomain = options.forcedYDomain;
                        options.forcedYDomain = temp;
                    }
                    this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType);
                    this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType);
                    if (options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis) {
                        this.xAxisProperties.axisLabel = data.axesLabels.x;
                    }
                    else {
                        this.xAxisProperties.axisLabel = null;
                    }
                    if (options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis) {
                        this.yAxisProperties.axisLabel = data.axesLabels.y;
                    }
                    else {
                        this.yAxisProperties.axisLabel = null;
                    }
                    return [this.xAxisProperties, this.yAxisProperties];
                };
                MekkoColumnChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                    var viewport = {
                        height: this.currentViewport.height,
                        width: this.currentViewport.width
                    };
                    if (this.isScrollable && !isScalar) {
                        var preferredWidth = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                        if (EnumExtensions.hasFlag(this.chartType, flagBar)) {
                            viewport.height = Math.max(preferredWidth, viewport.height);
                        }
                        else
                            viewport.width = Math.max(preferredWidth, viewport.width);
                    }
                    return viewport;
                };
                MekkoColumnChart.prototype.ApplyInteractivity = function (chartContext) {
                    var _this = this;
                    var interactivity = this.interactivity;
                    if (interactivity) {
                        if (interactivity.dragDataPoint) {
                            chartContext.onDragStart = function (datum) {
                                if (!datum.identity)
                                    return;
                                _this.hostService.onDragStart({
                                    event: d3.event,
                                    data: {
                                        data: datum.identity.getSelector()
                                    }
                                });
                            };
                        }
                        if (interactivity.isInteractiveLegend) {
                            var dragMove = function () {
                                var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]); // get the x and y for the column area itself
                                var x = mousePoint[0];
                                var y = mousePoint[1];
                                var index = _this.columnChart.getClosestColumnIndex(x, y);
                                _this.selectColumn(index);
                            };
                            var ColumnChartSvg = visuals.ColumnChart.getInteractiveColumnChartDomElement(this.element);
                            //set click interaction on the visual
                            this.svg.on('click', dragMove);
                            //set click interaction on the background
                            d3.select(ColumnChartSvg).on('click', dragMove);
                            var drag = d3.behavior.drag()
                                .origin(Object)
                                .on("drag", dragMove);
                            //set drag interaction on the visual
                            this.svg.call(drag);
                            //set drag interaction on the background
                            d3.select(ColumnChartSvg).call(drag);
                        }
                    }
                };
                MekkoColumnChart.prototype.selectColumn = function (indexOfColumnSelected, force) {
                    if (force === void 0) { force = false; }
                    if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected)
                        return; // same column, nothing to do here
                    var legendData = this.createInteractiveMekkoLegendDataPoints(indexOfColumnSelected);
                    var MekkoLegendDataPoints = legendData.dataPoints;
                    this.cartesianVisualHost.updateLegend(legendData);
                    if (MekkoLegendDataPoints.length > 0) {
                        this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);
                    }
                    this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
                };
                MekkoColumnChart.prototype.createInteractiveMekkoLegendDataPoints = function (columnIndex) {
                    var data = this.data;
                    if (!data || ArrayExtensions.isUndefinedOrEmpty(data.series)) {
                        return { dataPoints: [] };
                    }
                    var formatStringProp = visuals.columnChartProps.general.formatString;
                    var MekkoLegendDataPoints = [];
                    var category = data.categories && data.categories[columnIndex];
                    var allSeries = data.series;
                    var dataPoints = data.legendData && data.legendData.dataPoints;
                    var converterStrategy = new ColumnChartConverterHelper(this.dataViewCat);
                    for (var i = 0, len = allSeries.length; i < len; i++) {
                        var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex);
                        var valueMetadata = data.valuesMetadata[i];
                        var formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataViewCat.values, formatStringProp);
                        var dataPointColor;
                        if (allSeries.length === 1) {
                            var series = allSeries[0];
                            dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                        }
                        else {
                            dataPointColor = dataPoints.length > i && dataPoints[i].color;
                        }
                        MekkoLegendDataPoints.push({
                            color: dataPointColor,
                            icon: visuals.LegendIcon.Box,
                            label: formattedLabel,
                            category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                            measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                            identity: visuals.SelectionId.createNull(),
                            selected: false,
                        });
                    }
                    return { dataPoints: MekkoLegendDataPoints };
                };
                MekkoColumnChart.prototype.overrideXScale = function (xProperties) {
                    this.xAxisProperties = xProperties;
                };
                MekkoColumnChart.prototype.render = function (suppressAnimations) {
                    var MekkoColumnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations /* useAnimations */);
                    var data = this.data;
                    var margin = this.margin;
                    var viewport = this.currentViewport;
                    var height = viewport.height - (margin.top + margin.bottom);
                    var width = viewport.width - (margin.left + margin.right);
                    this.mainGraphicsContext
                        .attr('height', height)
                        .attr('width', width);
                    visuals.TooltipManager.addTooltip(MekkoColumnChartDrawInfo.shapesSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    var allDataPoints = [];
                    var behaviorOptions = undefined;
                    if (this.interactivityService) {
                        for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                            allDataPoints = allDataPoints.concat(data.series[i].data);
                        }
                        behaviorOptions = {
                            datapoints: allDataPoints,
                            bars: MekkoColumnChartDrawInfo.shapesSelection,
                            hasHighlights: data.hasHighlights,
                            eventGroup: this.mainGraphicsContext,
                            mainGraphicsContext: this.mainGraphicsContext,
                            viewport: MekkoColumnChartDrawInfo.viewport,
                            axisOptions: MekkoColumnChartDrawInfo.axisOptions,
                            showLabel: data.labelSettings.show
                        };
                    }
                    if (this.interactivity && this.interactivity.isInteractiveLegend) {
                        if (this.data.series.length > 0) {
                            this.selectColumn(0, true); // start with the first column
                        }
                    }
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                    return {
                        dataPoints: allDataPoints,
                        behaviorOptions: behaviorOptions,
                        labelDataPoints: MekkoColumnChartDrawInfo.labelDataPoints,
                        labelsAreNumeric: true
                    };
                };
                MekkoColumnChart.prototype.onClearSelection = function () {
                    if (this.interactivityService) {
                        this.interactivityService.clearSelection();
                    }
                };
                MekkoColumnChart.prototype.getVisualCategoryAxisIsScalar = function () {
                    return this.data ? this.data.scalarCategoryAxis : false;
                };
                MekkoColumnChart.prototype.getSupportedCategoryAxisType = function () {
                    var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                    var valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                    var isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                    return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
                };
                MekkoColumnChart.prototype.setFilteredData = function (startIndex, endIndex) {
                    var data = powerbi.Prototype.inherit(this.data);
                    data.series = visuals.ColumnChart.sliceSeries(data.series, endIndex, startIndex);
                    data.categories = data.categories.slice(startIndex, endIndex);
                    this.columnChart.setData(data);
                    return data;
                };
                MekkoColumnChart.ColumnChartClassName = 'columnChart';
                MekkoColumnChart.SeriesClasses = createClassAndSelector("series");
                MekkoColumnChart.BorderClass = createClassAndSelector("mekkoborder");
                return MekkoColumnChart;
            }());
            samples.MekkoColumnChart = MekkoColumnChart;
            var ColumnChartConverterHelper = (function () {
                function ColumnChartConverterHelper(dataView) {
                    this.dataView = dataView;
                }
                ColumnChartConverterHelper.hasRole = function (column, name) {
                    var roles = column.roles;
                    return roles && roles[name];
                };
                ColumnChartConverterHelper.prototype.getLegend = function (colors, defaultColor) {
                    var legend = [];
                    var seriesSources = [];
                    var seriesObjects = [];
                    var grouped = false;
                    var colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor);
                    var legendTitle = undefined;
                    if (this.dataView && this.dataView.values) {
                        var allValues = this.dataView.values;
                        var valueGroups = allValues.grouped();
                        var hasDynamicSeries = !!(allValues && allValues.source);
                        var formatStringProp = visuals.columnChartProps.general.formatString;
                        for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {
                            var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values;
                            for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {
                                var series = values[valueIndex];
                                var source = series.source;
                                // Gradient measures do not create series.
                                if (ColumnChartConverterHelper.hasRole(source, 'Width') && !ColumnChartConverterHelper.hasRole(source, 'Y')) {
                                    continue;
                                }
                                seriesSources.push(source);
                                seriesObjects.push(series.objects);
                                var selectionId = series.identity ?
                                    visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) :
                                    visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));
                                var label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);
                                var color = hasDynamicSeries
                                    ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName)
                                    : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                                legend.push({
                                    icon: visuals.LegendIcon.Box,
                                    color: color,
                                    label: label,
                                    identity: selectionId,
                                    selected: false,
                                });
                                if (series.identity && source.groupName !== undefined) {
                                    grouped = true;
                                }
                            }
                        }
                        var dvValues = this.dataView.values;
                        legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                    }
                    var legendData = {
                        title: legendTitle,
                        dataPoints: legend,
                        grouped: grouped,
                    };
                    return {
                        legend: legendData,
                        seriesSources: seriesSources,
                        seriesObjects: seriesObjects,
                    };
                };
                ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function (series, category) {
                    return this.dataView.values[series].values[category];
                };
                ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function (index) {
                    return this.dataView.values[index].source.queryName;
                };
                ColumnChartConverterHelper.prototype.hasHighlightValues = function (series) {
                    var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;
                    return column && !!column.highlights;
                };
                ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function (series, category) {
                    return this.dataView.values[series].highlights[category];
                };
                return ColumnChartConverterHelper;
            }());
            var MekkoChartBehavior = (function () {
                function MekkoChartBehavior(behaviors) {
                    this.behaviors = behaviors;
                }
                MekkoChartBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    var behaviors = this.behaviors;
                    for (var i = 0, ilen = behaviors.length; i < ilen; i++) {
                        behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                    }
                    options.clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                MekkoChartBehavior.prototype.renderSelection = function (hasSelection) {
                    for (var i = 0; i < this.behaviors.length; i++) {
                        this.behaviors[i].renderSelection(hasSelection);
                    }
                };
                return MekkoChartBehavior;
            }());
            samples.MekkoChartBehavior = MekkoChartBehavior;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var SankeyDiagram = (function () {
                function SankeyDiagram(constructorOptions) {
                    this.margin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    };
                    this.nodeWidth = 21.5;
                    this.curvatureOfLinks = 0.5;
                    if (constructorOptions) {
                        this.svg = constructorOptions.svg;
                        this.margin = constructorOptions.margin || this.margin;
                        this.curvatureOfLinks = constructorOptions.curvatureOfLinks || this.curvatureOfLinks;
                    }
                }
                SankeyDiagram.getProperties = function (capabilities) {
                    var result = {};
                    for (var objectKey in capabilities.objects) {
                        result[objectKey] = {};
                        for (var propKey in capabilities.objects[objectKey].properties) {
                            result[objectKey][propKey] = {
                                objectName: objectKey,
                                propertyName: propKey
                            };
                        }
                    }
                    return result;
                };
                Object.defineProperty(SankeyDiagram.prototype, "textProperties", {
                    get: function () {
                        return {
                            fontFamily: this.root.style("font-family"),
                            fontSize: jsCommon.PixelConverter.fromPoint(this.dataView ? this.dataView.settings.fontSize : SankeyDiagram.DefaultSettings.fontSize)
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                SankeyDiagram.prototype.init = function (visualsInitOptions) {
                    if (this.svg) {
                        this.root = this.svg;
                    }
                    else {
                        this.root = d3.select(visualsInitOptions.element.get(0))
                            .append("svg");
                    }
                    this.selectionManager = new SelectionManager({ hostServices: visualsInitOptions.host });
                    var style = visualsInitOptions.style;
                    this.colours = style && style.colorPalette
                        ? style.colorPalette.dataColors
                        : new visuals.DataColorPalette();
                    this.root.classed(SankeyDiagram.ClassName, true);
                    this.main = this.root.append("g");
                    this.links = this.main
                        .append("g")
                        .classed(SankeyDiagram.Links["class"], true);
                    this.nodes = this.main
                        .append("g")
                        .classed(SankeyDiagram.Nodes["class"], true);
                };
                SankeyDiagram.prototype.update = function (visualUpdateOptions) {
                    if (!visualUpdateOptions ||
                        !visualUpdateOptions.dataViews) {
                        return;
                    }
                    var dataView = visualUpdateOptions.dataViews[0], sankeyDiagramDataView;
                    this.updateViewport(visualUpdateOptions.viewport);
                    sankeyDiagramDataView = this.converter(dataView);
                    this.findNodePosition(sankeyDiagramDataView);
                    this.dataView = sankeyDiagramDataView;
                    this.render(sankeyDiagramDataView);
                };
                SankeyDiagram.prototype.updateViewport = function (viewport) {
                    var height, width;
                    height = this.getPositiveNumber(viewport.height);
                    width = this.getPositiveNumber(viewport.width);
                    this.viewport = {
                        height: this.getPositiveNumber(height - this.margin.top - this.margin.bottom),
                        width: this.getPositiveNumber(width - this.margin.left - this.margin.right)
                    };
                    this.updateElements(height, width);
                };
                SankeyDiagram.prototype.getPositiveNumber = function (value) {
                    return value < 0 || isNaN(value) || value === Infinity || value === -Infinity
                        ? 0
                        : value;
                };
                SankeyDiagram.prototype.updateElements = function (height, width) {
                    this.root.attr({
                        "height": height,
                        "width": width
                    });
                    this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                };
                SankeyDiagram.prototype.converter = function (dataView) {
                    var _this = this;
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[1] ||
                        !dataView.categorical.categories[0].values ||
                        !dataView.categorical.categories[1].values) {
                        return {
                            nodes: [],
                            links: [],
                            settings: {
                                scale: { x: 1, y: 1 },
                                colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                                fontSize: SankeyDiagram.DefaultSettings.fontSize
                            }
                        };
                    }
                    var nodes = [], links = [], dataPoints = [], categories = dataView.categorical.categories[0].values, secondCategories = dataView.categorical.categories[1].values, valuesColumn = dataView.categorical.values && dataView.categorical.values[0], weightValues = valuesColumn && valuesColumn.values && valuesColumn.values.map(function (x) { return x || 0; }) || [], allCategories, valueFormatterForCategories, formatOfWeigth = "g", valuesFormatterForWeigth, objects, linksObjects = dataView.categorical.categories[0].objects || [], labelColour, settings, shiftOfColour, identities = [];
                    if (dataView.categorical.categories[0].identity) {
                        identities = identities.concat(dataView.categorical.categories[0].identity);
                    }
                    if (dataView.categorical.categories[1].identity) {
                        identities = identities.concat(dataView.categorical.categories[1].identity);
                    }
                    objects = this.getObjectsFromDataView(dataView);
                    labelColour = this.getColour(SankeyDiagram.Properties["labels"]["fill"], SankeyDiagram.DefaultSettings.colourOfLabels, objects);
                    if (valuesColumn && valuesColumn.source) {
                        formatOfWeigth = ValueFormatter.getFormatString(valuesColumn.source, SankeyDiagram.Properties["general"]["formatString"]);
                    }
                    dataPoints = categories.map(function (item, index) {
                        return {
                            source: item,
                            destination: secondCategories[index],
                            weigth: valuesColumn ? Math.max(weightValues[index] || 0, 0) : 1
                        };
                    });
                    allCategories = categories.concat(secondCategories);
                    valueFormatterForCategories = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, SankeyDiagram.Properties["general"]["formatString"]),
                        value: allCategories[0],
                        value2: allCategories[allCategories.length - 1]
                    });
                    valuesFormatterForWeigth = ValueFormatter.create({
                        format: formatOfWeigth,
                        value: Math.max(d3.max(weightValues) || 1, 1),
                    });
                    allCategories.forEach(function (item, index) {
                        if (!nodes.some(function (node) {
                            if (item === node.label.name) {
                                node.selectionIds.push(visuals.SelectionId.createWithId(identities[index]));
                                return true;
                            }
                            return false;
                        })) {
                            var formattedValue = valueFormatterForCategories.format(item), label, selectionId, textProperties = {
                                text: formattedValue,
                                fontFamily: _this.textProperties.fontFamily,
                                fontSize: _this.textProperties.fontSize
                            };
                            label = {
                                name: item,
                                formattedName: valueFormatterForCategories.format(item),
                                width: powerbi.TextMeasurementService.measureSvgTextWidth(textProperties),
                                height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties),
                                colour: labelColour
                            };
                            selectionId = visuals.SelectionId.createWithId(identities[index]);
                            nodes.push({
                                label: label,
                                links: [],
                                inputWeight: 0,
                                outputWeight: 0,
                                width: _this.nodeWidth,
                                height: 0,
                                colour: SankeyDiagram.DefaultColourOfNode,
                                tooltipData: [],
                                selectionIds: [selectionId]
                            });
                        }
                    });
                    shiftOfColour = this.colours.getAllColors().length / nodes.length;
                    nodes.forEach(function (node, index) {
                        node.colour = _this.colours.getColorByIndex(Math.floor(index * shiftOfColour)).value;
                    });
                    dataPoints.forEach(function (dataPoint, index) {
                        var sourceNode, destinationNode, link, linkColour;
                        if (dataPoint.source === dataPoint.destination) {
                            return;
                        }
                        nodes.forEach(function (node) {
                            if (node.label.name === dataPoint.source) {
                                sourceNode = node;
                            }
                            if (node.label.name === dataPoint.destination) {
                                destinationNode = node;
                            }
                        });
                        linkColour = _this.getColour(SankeyDiagram.Properties["links"]["fill"], SankeyDiagram.DefaultColourOfLink, linksObjects[index]);
                        link = {
                            source: sourceNode,
                            destination: destinationNode,
                            weigth: dataPoint.weigth,
                            height: dataPoint.weigth,
                            colour: linkColour,
                            tooltipData: _this.getTooltipDataForLink(valuesFormatterForWeigth, sourceNode.label.formattedName, destinationNode.label.formattedName, dataPoint.weigth),
                            selectionId: visuals.SelectionId.createWithId(identities[index])
                        };
                        links.push(link);
                        sourceNode.links.push(link);
                        destinationNode.links.push(link);
                        _this.updateValueOfNode(sourceNode);
                        _this.updateValueOfNode(destinationNode);
                        sourceNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, sourceNode.label.formattedName, sourceNode.inputWeight ? sourceNode.inputWeight : sourceNode.outputWeight);
                        destinationNode.tooltipData = _this.getTooltipForNode(valuesFormatterForWeigth, destinationNode.label.formattedName, destinationNode.inputWeight ? destinationNode.inputWeight : destinationNode.outputWeight);
                    });
                    settings = this.parseSettings(objects);
                    settings.colourOfLabels = labelColour;
                    return {
                        nodes: nodes,
                        links: links,
                        settings: settings
                    };
                };
                SankeyDiagram.prototype.getObjectsFromDataView = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.objects) {
                        return null;
                    }
                    return dataView.metadata.objects;
                };
                SankeyDiagram.prototype.getColour = function (properties, defaultColor, objects) {
                    var colorHelper;
                    colorHelper = new visuals.ColorHelper(this.colours, properties, defaultColor);
                    return colorHelper.getColorForMeasure(objects, "");
                };
                SankeyDiagram.prototype.getTooltipDataForLink = function (valueFormatter, sourceNodeName, destinationNodeName, linkWeight) {
                    var formattedLinkWeight;
                    if (valueFormatter && valueFormatter.format) {
                        formattedLinkWeight = valueFormatter.format(linkWeight);
                    }
                    else {
                        formattedLinkWeight = linkWeight.toString();
                    }
                    return [{
                            displayName: SankeyDiagram.RoleNames.rows,
                            value: sourceNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.columns,
                            value: destinationNodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedLinkWeight
                        }];
                };
                SankeyDiagram.prototype.updateValueOfNode = function (node) {
                    node.inputWeight = node.links.reduce(function (previousValue, currentValue) {
                        return previousValue + (currentValue.destination === node ? currentValue.weigth : 0);
                    }, 0);
                    node.outputWeight = node.links.reduce(function (previousValue, currentValue) {
                        return previousValue + (currentValue.source === node ? currentValue.weigth : 0);
                    }, 0);
                };
                SankeyDiagram.prototype.getTooltipForNode = function (valueFormatter, nodeName, nodeWeight) {
                    var formattedNodeWeigth;
                    if (valueFormatter && valueFormatter.format) {
                        formattedNodeWeigth = valueFormatter.format(nodeWeight);
                    }
                    else {
                        formattedNodeWeigth = nodeWeight.toString();
                    }
                    return [{
                            displayName: "Name",
                            value: nodeName
                        }, {
                            displayName: SankeyDiagram.RoleNames.values,
                            value: formattedNodeWeigth
                        }];
                };
                SankeyDiagram.prototype.parseSettings = function (objects) {
                    var isVisibleLabels = false;
                    isVisibleLabels = powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties["labels"]["show"], SankeyDiagram.DefaultSettings.isVisibleLabels);
                    return {
                        isVisibleLabels: isVisibleLabels,
                        scale: {
                            x: SankeyDiagram.DefaultSettings.scale.x,
                            y: SankeyDiagram.DefaultSettings.scale.y
                        },
                        colourOfLabels: SankeyDiagram.DefaultSettings.colourOfLabels,
                        fontSize: powerbi.DataViewObjects.getValue(objects, SankeyDiagram.Properties["labels"]["fontSize"], SankeyDiagram.DefaultSettings.fontSize)
                    };
                };
                SankeyDiagram.prototype.findNodePosition = function (sankeyDiagramDataView) {
                    this.findNodePositionByX(sankeyDiagramDataView);
                    this.findNodePositionByY(sankeyDiagramDataView);
                };
                SankeyDiagram.prototype.findNodePositionByX = function (sankeyDiagramDataView) {
                    var nodes = sankeyDiagramDataView.nodes, nextNodes = [], previousNodes = [], x = 0, isRecursiveDependencies = false;
                    while (nodes.length > 0) {
                        nextNodes = [];
                        nodes.forEach(function (node) {
                            node.x = x;
                            node.links.forEach(function (link) {
                                if (node === link.source && node !== link.destination) {
                                    if (nextNodes.every(function (item) {
                                        return item !== link.destination;
                                    })) {
                                        nextNodes.push(link.destination);
                                    }
                                }
                            });
                        });
                        isRecursiveDependencies = nextNodes.length === previousNodes.length &&
                            previousNodes.every(function (previousNode) {
                                return nextNodes.some(function (nextNode) {
                                    return nextNode === previousNode;
                                });
                            });
                        if (isRecursiveDependencies) {
                            previousNodes.forEach(function (element) {
                                element.x = x;
                                x++;
                            });
                            nodes = [];
                        }
                        else {
                            nodes = nextNodes;
                            previousNodes = nodes;
                            x++;
                        }
                    }
                    sankeyDiagramDataView.settings.scale.x = this.getScaleByAxisX(x - 1);
                    this.scaleByAxisX(sankeyDiagramDataView.nodes, sankeyDiagramDataView.settings.scale.x);
                };
                SankeyDiagram.prototype.scaleByAxisX = function (nodes, scale) {
                    nodes.forEach(function (node) {
                        node.x *= scale;
                    });
                };
                SankeyDiagram.prototype.getScaleByAxisX = function (numberOfColumns) {
                    if (numberOfColumns === void 0) { numberOfColumns = 1; }
                    return this.getPositiveNumber((this.viewport.width - this.nodeWidth) / numberOfColumns);
                };
                SankeyDiagram.prototype.findNodePositionByY = function (sankeyDiagramDataView) {
                    var nodes = sankeyDiagramDataView.nodes, links = sankeyDiagramDataView.links, currentX = 0, index = 0, maxIndex = 0, sumValueOfNodes = 0, maxValueOfNodes = 0;
                    nodes = nodes.sort(function (firstNode, secondNode) {
                        return firstNode.x - secondNode.x;
                    });
                    nodes.forEach(function (node) {
                        if (currentX !== node.x) {
                            index = 0;
                            currentX = node.x;
                            sumValueOfNodes = 0;
                        }
                        sumValueOfNodes += Math.max(node.inputWeight, node.outputWeight);
                        if (sumValueOfNodes > maxValueOfNodes) {
                            maxValueOfNodes = sumValueOfNodes;
                        }
                        if (index > maxIndex) {
                            maxIndex = index;
                        }
                        index++;
                    });
                    sankeyDiagramDataView.settings.scale.y = this.getScaleByAxisY(maxIndex + 1, maxValueOfNodes);
                    this.scaleByAxisY(nodes, links, sankeyDiagramDataView.settings.scale.y);
                };
                SankeyDiagram.prototype.getScaleByAxisY = function (numberOfRows, sumValueOfNodes) {
                    return this.getPositiveNumber((this.viewport.height - numberOfRows * SankeyDiagram.NodePadding) / sumValueOfNodes);
                };
                SankeyDiagram.prototype.scaleByAxisY = function (nodes, links, scale) {
                    var shiftByAxisY = 0, currentX = 0, index = 0;
                    nodes.forEach(function (node) {
                        if (currentX !== node.x) {
                            currentX = node.x;
                            shiftByAxisY = 0;
                            index = 0;
                        }
                        node.height = Math.max(node.inputWeight, node.outputWeight) * scale;
                        node.y = shiftByAxisY + SankeyDiagram.NodePadding * index;
                        shiftByAxisY += node.height;
                        index++;
                    });
                    nodes.forEach(function (node) {
                        node.links = node.links.sort(function (firstLink, secondLink) {
                            var firstY, secondY;
                            firstY = firstLink.source === node
                                ? firstLink.destination.y
                                : firstLink.source.y;
                            secondY = secondLink.source === node
                                ? secondLink.destination.y
                                : secondLink.source.y;
                            return firstY - secondY;
                        });
                        var shiftByAxisYOfLeftLink = 0, shiftByAxisYOfRightLink = 0;
                        node.links.forEach(function (link) {
                            var shiftByAxisY = 0;
                            link.height = link.weigth * scale;
                            if (link.source.x < node.x || link.destination.x < node.x) {
                                shiftByAxisY = shiftByAxisYOfLeftLink;
                                shiftByAxisYOfLeftLink += link.height;
                            }
                            else if (link.source.x > node.x || link.destination.x > node.x) {
                                shiftByAxisY = shiftByAxisYOfRightLink;
                                shiftByAxisYOfRightLink += link.height;
                            }
                            if (link.source === node) {
                                link.dySource = shiftByAxisY;
                            }
                            else if (link.destination === node) {
                                link.dyDestination = shiftByAxisY;
                            }
                        });
                    });
                };
                SankeyDiagram.prototype.render = function (sankeyDiagramDataView) {
                    var nodesSelection, linksSelection;
                    linksSelection = this.renderLinks(sankeyDiagramDataView);
                    nodesSelection = this.renderNodes(sankeyDiagramDataView);
                    this.bindSelectionHandler(sankeyDiagramDataView, nodesSelection, linksSelection);
                };
                SankeyDiagram.prototype.renderNodes = function (sankeyDiagramDataView) {
                    var _this = this;
                    var nodesEnterSelection, nodesSelection, nodeElements;
                    nodeElements = this.main
                        .select(SankeyDiagram.Nodes.selector)
                        .selectAll(SankeyDiagram.Node.selector);
                    nodesSelection = nodeElements.data(sankeyDiagramDataView.nodes.filter(function (x) { return x.height > 0; }));
                    nodesEnterSelection = nodesSelection
                        .enter()
                        .append("g");
                    nodesSelection
                        .attr("transform", function (node) {
                        return visuals.SVGUtil.translate(node.x, node.y);
                    })
                        .classed(SankeyDiagram.Node["class"], true);
                    nodesEnterSelection
                        .append("rect")
                        .classed(SankeyDiagram.NodeRect["class"], true);
                    nodesEnterSelection
                        .append("text")
                        .classed(SankeyDiagram.NodeLabel["class"], true);
                    nodesSelection
                        .select(SankeyDiagram.NodeRect.selector)
                        .style({
                        "fill": function (node) { return node.colour; },
                        "stroke": function (node) { return d3.rgb(node.colour).darker(1.5); }
                    })
                        .attr({
                        x: 0,
                        y: 0,
                        height: function (node) { return node.height; },
                        width: function (node) { return node.width; }
                    });
                    nodesSelection
                        .select(SankeyDiagram.NodeLabel.selector)
                        .attr({
                        x: function (node) { return _this.getLabelPositionByAxisX(node); },
                        y: function (node) { return node.height / 2; },
                        dy: "0.35em"
                    })
                        .style("fill", function (node) { return node.label.colour; })
                        .style("font-size", this.textProperties.fontSize)
                        .style("display", function (node) {
                        var isNotVisibleLabel = false, labelPositionByAxisX = _this.getCurrentPositionOfLabelByAxisX(node);
                        isNotVisibleLabel =
                            labelPositionByAxisX >= _this.viewport.width ||
                                labelPositionByAxisX <= 0 ||
                                (node.height + SankeyDiagram.NodePadding) < node.label.height;
                        if (isNotVisibleLabel || !sankeyDiagramDataView.settings.isVisibleLabels
                            || sankeyDiagramDataView.settings.scale.x / 2 < SankeyDiagram.MinWidthOfLabel) {
                            return "none";
                        }
                        return null;
                    })
                        .style("text-anchor", function (node) {
                        if (_this.isLabelLargerWidth(node)) {
                            return "end";
                        }
                        return null;
                    })
                        .text(function (node) {
                        var maxWidth = sankeyDiagramDataView.settings.scale.x / 2 - node.width - SankeyDiagram.NodePadding;
                        if (_this.getCurrentPositionOfLabelByAxisX(node) > maxWidth) {
                            return powerbi.TextMeasurementService.getTailoredTextOrDefault({
                                text: node.label.formattedName,
                                fontFamily: _this.textProperties.fontFamily,
                                fontSize: _this.textProperties.fontSize
                            }, maxWidth);
                        }
                        return node.label.formattedName;
                    });
                    nodesSelection
                        .exit()
                        .remove();
                    this.renderTooltip(nodesSelection);
                    return nodesSelection;
                };
                SankeyDiagram.prototype.getLabelPositionByAxisX = function (node) {
                    if (this.isLabelLargerWidth(node)) {
                        return -(SankeyDiagram.LabelPadding);
                    }
                    return node.width + SankeyDiagram.LabelPadding;
                };
                SankeyDiagram.prototype.isLabelLargerWidth = function (node) {
                    var shiftByAxisX = node.x + node.width + SankeyDiagram.LabelPadding;
                    return shiftByAxisX + node.label.width > this.viewport.width;
                };
                SankeyDiagram.prototype.getCurrentPositionOfLabelByAxisX = function (node) {
                    var labelPositionByAxisX = this.getLabelPositionByAxisX(node);
                    labelPositionByAxisX = labelPositionByAxisX > 0
                        ? labelPositionByAxisX + node.x + node.label.width + node.width
                        : node.x + labelPositionByAxisX - node.label.width - node.width;
                    return labelPositionByAxisX;
                };
                SankeyDiagram.prototype.renderLinks = function (sankeyDiagramDataView) {
                    var _this = this;
                    var linksSelection, linksElements;
                    linksElements = this.main
                        .select(SankeyDiagram.Links.selector)
                        .selectAll(SankeyDiagram.Link.selector);
                    linksSelection = linksElements.data(sankeyDiagramDataView.links.filter(function (x) { return x.height > 0; }));
                    linksSelection
                        .enter()
                        .append("path")
                        .classed(SankeyDiagram.Link["class"], true);
                    linksSelection
                        .attr("d", function (link) {
                        return _this.getSvgPath(link);
                    })
                        .style({
                        "stroke-width": function (link) { return link.height; },
                        "stroke": function (link) { return link.colour; }
                    });
                    linksSelection
                        .exit()
                        .remove();
                    this.renderTooltip(linksSelection);
                    return linksSelection;
                };
                SankeyDiagram.prototype.getSvgPath = function (link) {
                    var x0, x1, xi, x2, x3, y0, y1;
                    if (link.destination.x < link.source.x) {
                        x0 = link.source.x;
                        x1 = link.destination.x + link.destination.width;
                    }
                    else {
                        x0 = link.source.x + link.source.width;
                        x1 = link.destination.x;
                    }
                    xi = d3.interpolateNumber(x0, x1);
                    x2 = xi(this.curvatureOfLinks);
                    x3 = xi(1 - this.curvatureOfLinks);
                    y0 = link.source.y + link.dySource + link.height / 2;
                    y1 = link.destination.y + link.dyDestination + link.height / 2;
                    return "M " + x0 + " " + y0 + " C " + x2 + " " + y0 + ", " + x3 + " " + y1 + ", " + x1 + " " + y1;
                };
                SankeyDiagram.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipData;
                    });
                };
                SankeyDiagram.prototype.bindSelectionHandler = function (sankeyDiagramDataView, nodesSelection, linksSelection) {
                    var _this = this;
                    nodesSelection.on("click", function (node) {
                        var selectionIds = _.isEqual(node.selectionIds.map(function (x) { return x.getKey(); }), _this.selectionManager.getSelectionIds().map(function (x) { return x.getKey(); }))
                            ? []
                            : node.selectionIds;
                        _this.selectMany(selectionIds, true).then(function () { return _this.setSelection(nodesSelection, linksSelection); });
                        d3.event.stopPropagation();
                    });
                    linksSelection.on("click", function (link) {
                        _this.selectionManager.select(link.selectionId, d3.event.ctrlKey).then(function () {
                            return _this.setSelection(nodesSelection, linksSelection);
                        });
                        d3.event.stopPropagation();
                    });
                    this.root.on("click", function () {
                        _this.selectionManager.clear().then(function () { return _this.setSelection(nodesSelection, linksSelection); });
                    });
                    this.setSelection(nodesSelection, linksSelection);
                };
                SankeyDiagram.prototype.selectMany = function (selectionIds, clear) {
                    var _this = this;
                    if (clear === void 0) { clear = false; }
                    if (clear) {
                        return this.selectionManager.clear().then(function () { return _this.selectMany(selectionIds, false); });
                    }
                    var selectionDeffered = selectionIds.map(function (id) { return _this.selectionManager.select(id, true); });
                    return $.when.apply(null, selectionDeffered);
                };
                SankeyDiagram.prototype.setSelection = function (nodes, links) {
                    var selectionIds = this.selectionManager.getSelectionIds();
                    nodes.classed("selected", selectionIds.length > 0);
                    links.classed("selected", false);
                    if (selectionIds.length === 0) {
                        return;
                    }
                    var selectedNodesSelection = nodes.filter(function (node) { return selectionIds
                        .some(function (selectedId) { return node.selectionIds
                        .some(function (x) { return x.getKey() === selectedId.getKey(); }); }); });
                    var selectedLinksSelection = links.filter(function (link) {
                        return selectionIds.some(function (selectionId) { return selectionId.getKey() === link.selectionId.getKey(); });
                    });
                    selectedNodesSelection.classed("selected", false);
                    selectedLinksSelection.classed("selected", true);
                };
                SankeyDiagram.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    if (!this.dataView) {
                        return [];
                    }
                    switch (options.objectName) {
                        case "labels": {
                            this.enumerateLabels(enumeration);
                            break;
                        }
                        case "links": {
                            this.enumerateLinks(enumeration);
                            break;
                        }
                    }
                    return enumeration.complete();
                };
                SankeyDiagram.prototype.enumerateLabels = function (enumeration) {
                    var settings = this.dataView.settings, labels;
                    if (!settings) {
                        return;
                    }
                    labels = {
                        objectName: "labels",
                        displayName: "labels",
                        selector: null,
                        properties: {
                            show: settings.isVisibleLabels,
                            fill: settings.colourOfLabels,
                            fontSize: settings.fontSize
                        }
                    };
                    enumeration.pushInstance(labels);
                };
                SankeyDiagram.prototype.enumerateLinks = function (enumeration) {
                    var links = this.dataView.links;
                    if (!links || !(links.length > 0)) {
                        return;
                    }
                    links.forEach(function (link) {
                        enumeration.pushInstance({
                            objectName: "links",
                            displayName: link.source.label.formattedName + " - " + link.destination.label.formattedName,
                            selector: visuals.ColorHelper.normalizeSelector(link.selectionId.getSelector(), false),
                            properties: {
                                fill: { solid: { color: link.colour } }
                            }
                        });
                    });
                };
                SankeyDiagram.ClassName = "sankeyDiagram";
                SankeyDiagram.Nodes = {
                    "class": "nodes",
                    selector: ".nodes"
                };
                SankeyDiagram.Node = {
                    "class": "node",
                    selector: ".node"
                };
                SankeyDiagram.NodeRect = {
                    "class": "nodeRect",
                    selector: ".nodeRect"
                };
                SankeyDiagram.NodeLabel = {
                    "class": "nodeLabel",
                    selector: ".nodeLabel"
                };
                SankeyDiagram.Links = {
                    "class": "links",
                    selector: ".links"
                };
                SankeyDiagram.Link = {
                    "class": "link",
                    selector: ".link"
                };
                SankeyDiagram.DefaultColourOfNode = "rgb(62, 187, 162)";
                SankeyDiagram.DefaultColourOfLink = "black";
                SankeyDiagram.DefaultSettings = {
                    isVisibleLabels: true,
                    scale: { x: 1, y: 1 },
                    colourOfLabels: "black",
                    fontSize: 12
                };
                SankeyDiagram.MinWidthOfLabel = 35;
                SankeyDiagram.NodePadding = 5;
                SankeyDiagram.LabelPadding = 4;
                SankeyDiagram.RoleNames = {
                    rows: "Source",
                    columns: "Destination",
                    values: "Weight"
                };
                SankeyDiagram.capabilities = {
                    dataRoles: [{
                            name: SankeyDiagram.RoleNames.rows,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.rows
                        }, {
                            name: SankeyDiagram.RoleNames.columns,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: SankeyDiagram.RoleNames.columns
                        }, {
                            name: SankeyDiagram.RoleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: SankeyDiagram.RoleNames.values
                        }],
                    dataViewMappings: [{
                            conditions: [
                                { "Source": { min: 0, max: 1 }, "Destination": { min: 0, max: 1 }, "Weight": { min: 0, max: 0 } },
                                { "Source": { min: 0, max: 1 }, "Destination": { min: 0, max: 1 }, "Weight": { min: 1, max: 1 } }
                            ],
                            categorical: {
                                categories: {
                                    for: { in: SankeyDiagram.RoleNames.rows },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [
                                        { bind: { to: SankeyDiagram.RoleNames.columns } },
                                        { bind: { to: SankeyDiagram.RoleNames.values } }
                                    ]
                                }
                            }
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: { type: { formatting: { formatString: true } } }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Show"),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        links: {
                            displayName: "Links",
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        }
                    }
                };
                SankeyDiagram.Properties = SankeyDiagram.getProperties(SankeyDiagram.capabilities);
                return SankeyDiagram;
            }());
            samples.SankeyDiagram = SankeyDiagram;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var PixelConverter = jsCommon.PixelConverter;
            samples.bulletChartProps = {
                values: {
                    targetValue: { objectName: 'values', propertyName: 'targetValue' },
                    minimumPercent: { objectName: 'values', propertyName: 'minimumPercent' },
                    needsImprovementPercent: { objectName: 'values', propertyName: 'needsImprovementPercent' },
                    satisfactoryPercent: { objectName: 'values', propertyName: 'satisfactoryPercent' },
                    goodPercent: { objectName: 'values', propertyName: 'goodPercent' },
                    veryGoodPercent: { objectName: 'values', propertyName: 'veryGoodPercent' },
                    maximumPercent: { objectName: 'values', propertyName: 'maximumPercent' },
                    targetValue2: { objectName: 'values', propertyName: 'targetValue2' },
                },
                orientation: {
                    orientation: { objectName: 'orientation', propertyName: 'orientation' },
                },
                colors: {
                    badColor: { objectName: 'colors', propertyName: 'badColor' },
                    needsImprovementColor: { objectName: 'colors', propertyName: 'needsImprovementColor' },
                    satisfactoryColor: { objectName: 'colors', propertyName: 'satisfactoryColor' },
                    goodColor: { objectName: 'colors', propertyName: 'goodColor' },
                    veryGoodColor: { objectName: 'colors', propertyName: 'veryGoodColor' },
                    bulletColor: { objectName: 'colors', propertyName: 'bulletColor' },
                },
                axis: {
                    axis: { objectName: 'axis', propertyName: 'axis' },
                    axisColor: { objectName: 'axis', propertyName: 'axisColor' },
                    measureUnits: { objectName: 'axis', propertyName: 'measureUnits' },
                    unitsColor: { objectName: 'axis', propertyName: 'unitsColor' },
                },
                formatString: { objectName: 'general', propertyName: 'formatString' },
                labels: {
                    fontSize: { objectName: 'labels', propertyName: 'fontSize' },
                    show: { objectName: 'labels', propertyName: 'show' },
                    labelColor: { objectName: 'labels', propertyName: 'labelColor' }
                }
            };
            samples.bulletChartRoleNames = {
                value: 'Value',
                targetValue: 'TargetValue',
                minValue: 'Minimum',
                needsImprovementValue: 'NeedsImprovement',
                satisfactoryValue: 'Satisfactory',
                goodValue: 'Good',
                veryGoodValue: 'VeryGood',
                maxValue: 'Maximum',
                targetValue2: 'TargetValue2',
            };
            var Orientation;
            (function (Orientation) {
                Orientation.HORIZONTALLEFT = 'Horizontal Left';
                Orientation.HORIZONTALRIGHT = 'Horizontal Right';
                Orientation.VERTICALTOP = 'Vertical Top';
                Orientation.VERTICALBOTTOM = 'Vertical Bottom';
                Orientation.type = powerbi.createEnumType([
                    { value: Orientation.HORIZONTALLEFT, displayName: Orientation.HORIZONTALLEFT },
                    { value: Orientation.HORIZONTALRIGHT, displayName: Orientation.HORIZONTALRIGHT },
                    { value: Orientation.VERTICALTOP, displayName: Orientation.VERTICALTOP },
                    { value: Orientation.VERTICALBOTTOM, displayName: Orientation.VERTICALBOTTOM }
                ]);
            })(Orientation || (Orientation = {}));
            var BulletChart = (function () {
                function BulletChart() {
                    this.baselineDelta = 0;
                }
                Object.defineProperty(BulletChart.prototype, "reverse", {
                    get: function () {
                        return this.model.bulletChartSettings.orientation.reverse;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BulletChart.prototype, "vertical", {
                    get: function () {
                        return this.model.bulletChartSettings.orientation.vertical;
                    },
                    enumerable: true,
                    configurable: true
                });
                BulletChart.DefaultStyleProperties = function () {
                    return {
                        values: {
                            targetValue: 0,
                            targetValue2: 0,
                            minimumPercent: 0,
                            needsImprovementPercent: 25,
                            satisfactoryPercent: 50,
                            goodPercent: 100,
                            veryGoodPercent: 125,
                            maximumPercent: 200,
                        },
                        orientation: {
                            orientation: Orientation.HORIZONTALLEFT,
                            reverse: false,
                            vertical: false
                        },
                        colors: {
                            badColor: 'Darkred',
                            needsImprovementColor: 'Red',
                            satisfactoryColor: 'Yellow',
                            goodColor: 'Green',
                            veryGoodColor: 'Darkgreen',
                            bulletColor: 'Black'
                        },
                        axis: {
                            axis: true,
                            axisColor: 'Grey',
                            measureUnits: '',
                            unitsColor: 'Grey',
                        },
                        labelSettings: {
                            fontSize: 11,
                            show: true,
                            labelColor: 'Black',
                        },
                    };
                };
                Object.defineProperty(BulletChart.prototype, "viewportIn", {
                    get: function () {
                        return {
                            width: this.viewport.width,
                            height: this.viewport.height
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(BulletChart.prototype, "viewportScroll", {
                    get: function () {
                        var viewportIn = this.viewportIn;
                        return {
                            width: viewportIn.width - BulletChart.ScrollBarSize,
                            height: viewportIn.height - BulletChart.ScrollBarSize
                        };
                    },
                    enumerable: true,
                    configurable: true
                });
                BulletChart.getTextProperties = function (text, fontSize) {
                    return {
                        fontFamily: BulletChart.FontFamily,
                        fontSize: PixelConverter.fromPoint(fontSize),
                        text: text,
                    };
                };
                // Convert a DataView into a view model
                BulletChart.converter = function (dataView, options) {
                    var defaultSettings = BulletChart.DefaultStyleProperties();
                    var bulletModel = {
                        bulletValueFormatString: null,
                        bulletChartSettings: defaultSettings,
                        bars: [],
                        barRects: [],
                        valueRects: [],
                        targetValues: [],
                    };
                    if (!dataView || !dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length === 0
                        || !dataView.metadata || !dataView.metadata.columns || dataView.metadata.columns.length === 0) {
                        return bulletModel;
                    }
                    var objects = dataView.metadata.objects;
                    var settings = bulletModel.bulletChartSettings;
                    if (objects) {
                        settings.values.targetValue = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue, defaultSettings.values.targetValue);
                        settings.values.targetValue2 = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.targetValue2, defaultSettings.values.targetValue2);
                        settings.values.minimumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.minimumPercent, defaultSettings.values.minimumPercent);
                        settings.values.needsImprovementPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.needsImprovementPercent, defaultSettings.values.needsImprovementPercent);
                        settings.values.satisfactoryPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.satisfactoryPercent, defaultSettings.values.satisfactoryPercent);
                        settings.values.goodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.goodPercent, defaultSettings.values.goodPercent);
                        settings.values.veryGoodPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.veryGoodPercent, defaultSettings.values.veryGoodPercent);
                        settings.values.maximumPercent = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.values.maximumPercent, defaultSettings.values.maximumPercent);
                        settings.orientation.orientation = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.orientation.orientation, defaultSettings.orientation.orientation);
                        settings.colors.badColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.badColor, defaultSettings.colors.badColor);
                        settings.colors.needsImprovementColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.needsImprovementColor, defaultSettings.colors.needsImprovementColor);
                        settings.colors.satisfactoryColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.satisfactoryColor, defaultSettings.colors.satisfactoryColor);
                        settings.colors.goodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.goodColor, defaultSettings.colors.goodColor);
                        settings.colors.veryGoodColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.veryGoodColor, defaultSettings.colors.veryGoodColor);
                        settings.colors.bulletColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.colors.bulletColor, defaultSettings.colors.bulletColor);
                        settings.axis.axis = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.axis, defaultSettings.axis.axis);
                        settings.axis.axisColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.axisColor, defaultSettings.axis.axisColor);
                        settings.axis.measureUnits = powerbi.TextMeasurementService.getTailoredTextOrDefault(BulletChart.getTextProperties(powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.axis.measureUnits, defaultSettings.axis.measureUnits), BulletChart.DefaultSubtitleFontSizeInPt), BulletChart.MaxLabelWidth);
                        settings.axis.unitsColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.axis.unitsColor, defaultSettings.axis.unitsColor);
                        settings.labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.fontSize, defaultSettings.labelSettings.fontSize);
                        settings.labelSettings.show = powerbi.DataViewObjects.getValue(objects, samples.bulletChartProps.labels.show, defaultSettings.labelSettings.show);
                        settings.labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.bulletChartProps.labels.labelColor, defaultSettings.labelSettings.labelColor);
                    }
                    if (settings.orientation.orientation === Orientation.HORIZONTALRIGHT || settings.orientation.orientation === Orientation.VERTICALBOTTOM)
                        settings.orientation.reverse = true;
                    if (settings.orientation.orientation === Orientation.VERTICALTOP || settings.orientation.orientation === Orientation.VERTICALBOTTOM)
                        settings.orientation.vertical = true;
                    var categories, categoryValues, categoryValuesLen = 1, categoryFormatString;
                    if (dataView.categorical.categories) {
                        categories = dataView.categorical.categories[0];
                        categoryValues = categories.values;
                        categoryValuesLen = categoryValues.length;
                        categoryFormatString = visuals.valueFormatter.getFormatString(categories.source, samples.bulletChartProps.formatString);
                    }
                    bulletModel.bulletValueFormatString = visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, samples.bulletChartProps.formatString);
                    for (var idx = 0; idx < categoryValuesLen; idx++) {
                        var toolTipItems = [];
                        var category = void 0, value = void 0, targetValue = void 0, targetValue2 = void 0, minimum = void 0, satisfactory = void 0, good = void 0, maximum = void 0, needsImprovement = void 0, veryGood = void 0;
                        var highlight = false, categoryIdentity = void 0;
                        if (categoryValues) {
                            var categoryValue = categoryValues[idx];
                            category = visuals.valueFormatter.format(categoryValue, categoryFormatString);
                            categoryIdentity = categories.identity ? categories.identity[idx] : null;
                            var textProperties = BulletChart.getTextProperties(category, settings.labelSettings.fontSize);
                            category = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, BulletChart.MaxLabelWidth - BulletChart.StartMarginHorizontal);
                            var labelWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                            var labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                            BulletChart.BiggestLabelWidth = Math.max(BulletChart.BiggestLabelWidth, labelWidth);
                            BulletChart.BiggestLabelHeight = Math.max(BulletChart.BiggestLabelHeight, labelHeight);
                        }
                        var values = dataView.categorical.values;
                        targetValue = settings.values.targetValue;
                        targetValue2 = settings.values.targetValue2;
                        for (var i = 0; i < values.length; i++) {
                            var col = values[i].source;
                            var currentVal = values[i].values[idx] || 0;
                            if (col && col.roles) {
                                if (col.roles[samples.bulletChartRoleNames.value]) {
                                    if (values[i].highlights)
                                        highlight = values[i].highlights[idx] !== null;
                                    toolTipItems.push({ value: currentVal, metadata: values[i] });
                                    value = currentVal;
                                }
                                else if (col.roles[samples.bulletChartRoleNames.targetValue]) {
                                    toolTipItems.push({ value: currentVal, metadata: values[i] });
                                    targetValue = currentVal;
                                }
                                else if (col.roles[samples.bulletChartRoleNames.targetValue2]) {
                                    toolTipItems.push({ value: currentVal, metadata: values[i] });
                                    targetValue2 = currentVal;
                                }
                                else if (col.roles[samples.bulletChartRoleNames.minValue])
                                    minimum = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.needsImprovementValue])
                                    needsImprovement = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.satisfactoryValue])
                                    satisfactory = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.goodValue])
                                    good = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.veryGoodValue])
                                    veryGood = currentVal;
                                else if (col.roles[samples.bulletChartRoleNames.maxValue])
                                    maximum = currentVal;
                            }
                        }
                        if (!minimum)
                            minimum = settings.values.minimumPercent * targetValue / 100;
                        if (!needsImprovement)
                            needsImprovement = settings.values.needsImprovementPercent * targetValue / 100;
                        if (!satisfactory)
                            satisfactory = settings.values.satisfactoryPercent * targetValue / 100;
                        if (!good)
                            good = settings.values.goodPercent * targetValue / 100;
                        if (!veryGood)
                            veryGood = settings.values.veryGoodPercent * targetValue / 100;
                        if (!maximum)
                            maximum = settings.values.maximumPercent * targetValue / 100;
                        var viewportLength = (settings.orientation.vertical ? (options.viewport.height - BulletChart.MaxLabelHeight) : (options.viewport.width - BulletChart.MaxLabelWidth)) -
                            BulletChart.StartMarginHorizontal - BulletChart.ScrollBarSize;
                        var sortedRanges = [minimum, needsImprovement, satisfactory, good, veryGood, maximum].sort(d3.descending);
                        var scale = (d3.scale.linear()
                            .clamp(true)
                            .domain([minimum, Math.max(sortedRanges[0], targetValue, value)])
                            .range(settings.orientation.vertical ? [viewportLength, 0] : [0, viewportLength]));
                        // Scalles without
                        var firstScale = scale(minimum);
                        var secondScale = scale(needsImprovement);
                        var thirdScale = scale(satisfactory);
                        var fourthScale = scale(good);
                        var fifthScale = scale(veryGood);
                        var lastScale = scale(maximum);
                        var valueScale = scale(value);
                        var firstColor = settings.colors.badColor, secondColor = settings.colors.needsImprovementColor, thirdColor = settings.colors.satisfactoryColor, fourthColor = settings.colors.goodColor, lastColor = settings.colors.veryGoodColor;
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, firstScale, secondScale, firstColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, secondScale, thirdScale, secondColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, thirdScale, fourthScale, thirdColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fourthScale, fifthScale, fourthColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.barRects, idx, fifthScale, lastScale, lastColor, toolTipItems, categoryIdentity);
                        BulletChart.addItemToBarArray(bulletModel.valueRects, idx, firstScale, valueScale, settings.colors.bulletColor, toolTipItems, categoryIdentity);
                        // markerValue
                        bulletModel.targetValues.push({
                            barIndex: idx,
                            value: scale(targetValue),
                            fill: settings.colors.bulletColor,
                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, scale(targetValue).toString()).getKey(),
                            value2: scale(targetValue2),
                        });
                        var xAxis = null;
                        if (settings.axis.axis) {
                            xAxis = d3.svg.axis();
                            xAxis.orient(settings.orientation.vertical ? "left" : "bottom");
                            var minTickSize = Math.round(Math.max(3, viewportLength / 100));
                            var axisValues = [value, targetValue, good, satisfactory, maximum, minimum, needsImprovement, veryGood]
                                .filter(function (x) { return !isNaN(x); });
                            xAxis.tickFormat(visuals.valueFormatter.create({
                                format: bulletModel.bulletValueFormatString,
                                value: axisValues.length ? Math.max.apply(null, axisValues) : 0
                            }).format);
                            xAxis.ticks(minTickSize);
                            xAxis.scale(scale);
                        }
                        var bar = {
                            scale: scale,
                            barIndex: idx,
                            categoryLabel: category,
                            x: (settings.orientation.vertical) ? BulletChart.StartMarginVertical + BulletChart.SpaceRequiredForBarVertically * idx : BulletChart.StartMarginHorizontal,
                            y: (settings.orientation.vertical) ? BulletChart.StartMarginVertical : BulletChart.StartMarginHorizontal + BulletChart.SpaceRequiredForBar * idx,
                            axis: xAxis,
                            key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, idx.toString()).getKey(),
                        };
                        bulletModel.bars.push(bar);
                    }
                    return bulletModel;
                };
                BulletChart.addItemToBarArray = function (collection, barIndex, start, end, fill, tooltipInfo, categoryIdentity) {
                    collection.push({
                        barIndex: barIndex,
                        start: start,
                        end: end,
                        fill: fill,
                        tooltipInfo: visuals.TooltipBuilder.createTooltipInfo(samples.bulletChartProps.formatString, null, null, null, null, tooltipInfo),
                        selected: false,
                        identity: visuals.SelectionId.createWithId(categoryIdentity),
                        key: visuals.SelectionId.createWithIdAndMeasure(categoryIdentity, start + " " + end).getKey(),
                    });
                };
                /* One time setup*/
                BulletChart.prototype.init = function (options) {
                    var body = d3.select(options.element.get(0));
                    this.hostService = options.host;
                    this.bulletBody = body
                        .append('div')
                        .classed('bulletChart', true);
                    this.scrollContainer = this.bulletBody.append('svg')
                        .classed('bullet-scroll-region', true);
                    this.clearCatcher = visuals.appendClearCatcher(this.scrollContainer);
                    this.labelGraphicsContext = this.scrollContainer.append('g');
                    this.bulletGraphicsContext = this.scrollContainer.append('g');
                    this.behavior = new BulletWebBehavior();
                    this.interactivityService = visuals.createInteractivityService(options.host);
                };
                /* Called for data, size, formatting changes*/
                BulletChart.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    BulletChart.BiggestLabelHeight = BulletChart.BiggestLabelWidth = 0;
                    var dataView = options.dataViews[0];
                    this.viewport = options.viewport;
                    this.model = BulletChart.converter(dataView, options);
                    //TODO: Calculating the baseline delta of the text. needs to be removed once the TExtMeasurementService.estimateSVGTextBaselineDelta is available.
                    this.baselineDelta = TextMeasurementHelper.estimateSvgTextBaselineDelta(BulletChart.getTextProperties("1", this.model.bulletChartSettings.labelSettings.fontSize));
                    this.ClearViewport();
                    if (!this.model) {
                        return;
                    }
                    if (this.interactivityService) {
                        this.interactivityService.applySelectionStateToData(this.model.barRects);
                    }
                    this.bulletBody.style({
                        'height': this.viewportIn.height + 'px',
                        'width': this.viewportIn.width + 'px',
                    });
                    if (this.vertical) {
                        this.scrollContainer.attr({
                            width: (this.model.bars.length * BulletChart.SpaceRequiredForBarVertically) + 'px',
                            height: this.viewportScroll.height + 'px'
                        });
                    }
                    else {
                        this.scrollContainer.attr({
                            height: (this.model.bars.length * BulletChart.SpaceRequiredForBar) + 'px',
                            width: this.viewportScroll.width + 'px'
                        });
                    }
                    if (this.vertical)
                        this.setUpBulletsVertically(this.bulletBody, this.model, this.reverse);
                    else
                        this.setUpBulletsHorizontally(this.bulletBody, this.model, this.reverse);
                };
                BulletChart.prototype.ClearViewport = function () {
                    this.labelGraphicsContext.selectAll("text").remove();
                    this.bulletGraphicsContext.selectAll("rect").remove();
                    this.bulletGraphicsContext.selectAll('axis').remove();
                    this.bulletGraphicsContext.selectAll('path').remove();
                    this.bulletGraphicsContext.selectAll('line').remove();
                    this.bulletGraphicsContext.selectAll('tick').remove();
                    this.bulletGraphicsContext.selectAll('g').remove();
                };
                BulletChart.prototype.calculateLabelWidth = function (barData, bar, reversed) {
                    if (reversed)
                        return BulletChart.StartMarginHorizontal + ((bar) ? bar.start : 0);
                    var textSize = powerbi.TextMeasurementService.measureSvgTextWidth(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));
                    if (textSize > BulletChart.BiggestLabelWidth)
                        return barData.x + BulletChart.MaxLabelWidth + ((bar) ? bar.start : 0);
                    return barData.x + BulletChart.BiggestLabelWidth + BulletChart.BarMargin + ((bar) ? bar.start : 0);
                };
                BulletChart.prototype.calculateLabelHeight = function (barData, bar, reversed) {
                    if (reversed)
                        return BulletChart.StartMarginVertical + ((bar) ? bar.end : 0);
                    var textSize = powerbi.TextMeasurementService.measureSvgTextHeight(BulletChart.getTextProperties(barData.categoryLabel, this.model.bulletChartSettings.labelSettings.fontSize));
                    if (textSize > BulletChart.BiggestLabelHeight)
                        return barData.y + BulletChart.MaxLabelHeight + ((bar) ? bar.end : 0);
                    return barData.y + textSize + BulletChart.BarMargin + ((bar) ? bar.end : 0);
                };
                BulletChart.prototype.setUpBulletsHorizontally = function (bulletBody, model, reveresed) {
                    var _this = this;
                    var bars = model.bars;
                    var rects = model.barRects;
                    var valueRects = model.valueRects;
                    var targetValues = model.targetValues;
                    var barSelection = this.labelGraphicsContext.selectAll('text').data(bars, function (d) { return d.key; });
                    var rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, function (d) { return d.key; });
                    // Draw bullets
                    var bullets = rectSelection.enter().append('rect').attr({
                        'x': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),
                        'y': (function (d) { return bars[d.barIndex].y - BulletChart.BulletSize / 2; }),
                        'width': (function (d) { return d.end - d.start; }),
                        'height': BulletChart.BulletSize,
                    }).classed('range', true).style({
                        'fill': (function (d) { return d.fill; })
                    });
                    rectSelection.exit();
                    // Draw value rects
                    var valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, function (d) { return d.key; });
                    valueSelection.enter().append('rect').attr({
                        'x': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], d, reveresed); }),
                        'y': (function (d) { return bars[d.barIndex].y - BulletChart.BulletSize / 8; }),
                        'width': (function (d) { return d.end - d.start; }),
                        'height': BulletChart.BulletSize * 1 / 4,
                    }).classed('value', true).style({
                        'fill': (function (d) { return d.fill; }),
                    });
                    valueSelection.exit();
                    // Draw markers
                    var markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, function (d) { return d.key; });
                    markerSelection.enter().append('line').attr({
                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),
                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value; }),
                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),
                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                    });
                    markerSelection.enter().append('line').attr({
                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),
                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                        'transform': 'rotate(45deg)',
                        'transform-origin': '50% 50% 0',
                    });
                    markerSelection.enter().append('line').attr({
                        'x1': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'x2': (function (d) { return _this.calculateLabelWidth(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'y1': (function (d) { return bars[d.barIndex].y - BulletChart.MarkerMarginHorizontal; }),
                        'y2': (function (d) { return bars[d.barIndex].y + BulletChart.MarkerMarginHorizontal; }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                        'transform': 'rotate(315deg)',
                        'transform-origin': '50% 50% 0',
                    });
                    markerSelection.exit();
                    // Draw axes
                    if (model.bulletChartSettings.axis.axis) {
                        // Using var instead of let since you can't pass let parameters to functions inside loops.
                        // needs to be changed to let when typescript 1.8 comes out.
                        for (var idx = 0; idx < bars.length; idx++) {
                            var bar = bars[idx];
                            this.bulletGraphicsContext.append("g").attr({
                                'transform': function () {
                                    var xLocation = _this.calculateLabelWidth(bar, null, reveresed);
                                    var yLocation = bar.y + BulletChart.BulletSize / 2;
                                    return 'translate(' + xLocation + ',' + yLocation + ')';
                                },
                            }).classed("axis", true).call(bar.axis.scale(bar.scale)).style({
                                'fill': model.bulletChartSettings.axis.axisColor,
                                'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt)
                            }).selectAll('line').style({
                                'stroke': model.bulletChartSettings.axis.axisColor,
                            });
                        }
                    }
                    // Draw Labels
                    if (model.bulletChartSettings.labelSettings.show) {
                        barSelection.enter().append('text').classed("title", true).attr({
                            'x': (function (d) {
                                if (reveresed)
                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().width + BulletChart.StartMarginHorizontal;
                                return d.x;
                            }),
                            'y': (function (d) { return d.y + _this.baselineDelta; }),
                            'fill': model.bulletChartSettings.labelSettings.labelColor,
                            'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),
                        }).text(function (d) { return d.categoryLabel; });
                    }
                    // Draw measure label
                    if (model.bulletChartSettings.axis.measureUnits) {
                        barSelection.enter().append('text').attr({
                            'x': (function (d) {
                                if (reveresed)
                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().width - BulletChart.StartMarginHorizontal + BulletChart.SubtitleMargin;
                                return d.x - BulletChart.SubtitleMargin;
                            }),
                            'y': (function (d) { return d.y + BulletChart.BulletSize; }),
                            'fill': model.bulletChartSettings.axis.unitsColor,
                            'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(model.bulletChartSettings.axis.measureUnits);
                    }
                    if (this.interactivityService) {
                        var behaviorOptions = {
                            rects: bullets,
                            valueRects: valueSelection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService,
                            bulletChartSettings: this.model.bulletChartSettings,
                            hasHighlights: false,
                        };
                        var targetCollection = this.model.barRects.concat(this.model.valueRects);
                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                    }
                    barSelection.exit();
                    visuals.TooltipManager.addTooltip(valueSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                    visuals.TooltipManager.addTooltip(rectSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                };
                BulletChart.prototype.setUpBulletsVertically = function (bulletBody, model, reveresed) {
                    var _this = this;
                    var bars = model.bars;
                    var rects = model.barRects;
                    var valueRects = model.valueRects;
                    var targetValues = model.targetValues;
                    var barSelection = this.labelGraphicsContext.selectAll('text').data(bars, function (d) { return d.key; });
                    var rectSelection = this.bulletGraphicsContext.selectAll('rect.range').data(rects, function (d) { return d.key; });
                    // Draw bullets
                    var bullets = rectSelection.enter().append('rect').attr({
                        'x': (function (d) { return bars[d.barIndex].x; }),
                        'y': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),
                        'height': (function (d) { return d.start - d.end; }),
                        'width': BulletChart.BulletSize,
                    }).classed('range', true).style({
                        'fill': (function (d) { return d.fill; })
                    });
                    rectSelection.exit();
                    // Draw value rects
                    var valueSelection = this.bulletGraphicsContext.selectAll('rect').data(valueRects, function (d) { return d.key; });
                    valueSelection.enter().append('rect').attr({
                        'x': (function (d) { return bars[d.barIndex].x + BulletChart.BulletSize / 3; }),
                        'y': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], d, reveresed); }),
                        'height': (function (d) { return d.start - d.end; }),
                        'width': BulletChart.BulletSize * 1 / 4,
                    }).classed('value', true).style({
                        'fill': (function (d) { return d.fill; }),
                    });
                    valueSelection.exit();
                    // Draw markers
                    var markerSelection = this.bulletGraphicsContext.selectAll('values').data(targetValues, function (d) { return d.key; });
                    markerSelection.enter().append('line').attr({
                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),
                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),
                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),
                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value; }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                    });
                    markerSelection.enter().append('line').attr({
                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),
                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                        'transform': 'rotate(45deg)',
                        'transform-origin': '50% 50% 0',
                    });
                    markerSelection.enter().append('line').attr({
                        'y1': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'y2': (function (d) { return _this.calculateLabelHeight(bars[d.barIndex], null, reveresed) + d.value2; }),
                        'x1': (function (d) { return bars[d.barIndex].x + BulletChart.MarkerMarginVertical; }),
                        'x2': (function (d) { return bars[d.barIndex].x + (BulletChart.MarkerMarginVertical * 3); }),
                    }).style({
                        'stroke': (function (d) { return d.fill; }),
                        'stroke-width': 2,
                        'transform': 'rotate(315deg)',
                        'transform-origin': '50% 50% 0',
                    });
                    markerSelection.exit();
                    // // Draw axes
                    if (model.bulletChartSettings.axis.axis) {
                        // Using var instead of let since you can't pass let parameters to functions inside loops.
                        // needs to be changed to let when typescript 1.8 comes out.
                        for (var idx = 0; idx < bars.length; idx++) {
                            var bar = bars[idx];
                            this.bulletGraphicsContext.append("g").attr({
                                'transform': function () {
                                    var xLocation = bar.x;
                                    var yLocation = _this.calculateLabelHeight(bar, null, reveresed);
                                    // let yLocation = bar.y + BulletChart.BulletSize / 2;
                                    return 'translate(' + xLocation + ',' + yLocation + ')';
                                },
                            }).classed("axis", true).call(bar.axis.scale(bar.scale)).style({
                                'fill': model.bulletChartSettings.axis.axisColor,
                                'font-size': PixelConverter.fromPoint(BulletChart.AxisFontSizeInPt),
                            }).selectAll('line').style({
                                'stroke': model.bulletChartSettings.axis.axisColor,
                            });
                        }
                    }
                    // Draw Labels
                    if (model.bulletChartSettings.labelSettings.show) {
                        barSelection.enter().append('text').classed("title", true).attr({
                            'x': (function (d) { return d.x; }),
                            'y': (function (d) {
                                if (reveresed)
                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.BulletSize;
                                return d.y + powerbi.TextMeasurementService.estimateSvgTextHeight(BulletChart.getTextProperties(d.categoryLabel, model.bulletChartSettings.labelSettings.fontSize)) / 2;
                            }),
                            'fill': model.bulletChartSettings.labelSettings.labelColor,
                            'font-size': PixelConverter.fromPoint(model.bulletChartSettings.labelSettings.fontSize),
                        }).text(function (d) { return d.categoryLabel; });
                    }
                    // Draw measure label
                    if (model.bulletChartSettings.axis.measureUnits) {
                        barSelection.enter().append('text').attr({
                            'x': (function (d) { return d.x + BulletChart.BulletSize; }),
                            'y': (function (d) {
                                if (reveresed)
                                    return _this.bulletGraphicsContext.node().getBoundingClientRect().height + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;
                                return d.y + BulletChart.StartMarginVertical + BulletChart.SubtitleMargin;
                            }),
                            'fill': model.bulletChartSettings.axis.unitsColor,
                            'font-size': PixelConverter.fromPoint(BulletChart.DefaultSubtitleFontSizeInPt)
                        }).text(model.bulletChartSettings.axis.measureUnits);
                    }
                    if (this.interactivityService) {
                        var behaviorOptions = {
                            rects: bullets,
                            valueRects: valueSelection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService,
                            bulletChartSettings: this.model.bulletChartSettings,
                            hasHighlights: false,
                        };
                        var targetCollection = this.model.barRects.concat(this.model.valueRects);
                        this.interactivityService.bind(targetCollection, this.behavior, behaviorOptions);
                    }
                    barSelection.exit();
                    visuals.TooltipManager.addTooltip(valueSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                    visuals.TooltipManager.addTooltip(rectSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                };
                /*About to remove your visual, do clean up here */
                BulletChart.prototype.destroy = function () { };
                BulletChart.prototype.enumerateObjectInstances = function (options) {
                    var data = this.model;
                    if (!data) {
                        return;
                    }
                    var objectName = options.objectName;
                    switch (objectName) {
                        case 'labels':
                            return this.enumerateLabels(data);
                        case 'values':
                            return this.enumerateValues(data);
                        case 'orientation':
                            return this.enumerateOrientation(data);
                        case 'axis':
                            return this.enumerateAxis(data);
                        case 'colors':
                            return this.enumerateColors(data);
                    }
                };
                BulletChart.prototype.enumerateLabels = function (data) {
                    return [{
                            selector: null,
                            objectName: 'labels',
                            properties: {
                                show: this.model.bulletChartSettings.labelSettings.show,
                                labelColor: this.model.bulletChartSettings.labelSettings.labelColor,
                                fontSize: this.model.bulletChartSettings.labelSettings.fontSize,
                            }
                        }];
                };
                BulletChart.prototype.enumerateValues = function (data) {
                    return [{
                            selector: null,
                            objectName: 'values',
                            properties: {
                                targetValue: this.model.bulletChartSettings.values.targetValue,
                                targetValue2: this.model.bulletChartSettings.values.targetValue2,
                                minimumPercent: this.model.bulletChartSettings.values.minimumPercent,
                                needsImprovementPercent: this.model.bulletChartSettings.values.needsImprovementPercent,
                                satisfactoryPercent: this.model.bulletChartSettings.values.satisfactoryPercent,
                                goodPercent: this.model.bulletChartSettings.values.goodPercent,
                                veryGoodPercent: this.model.bulletChartSettings.values.veryGoodPercent,
                                maximumPercent: this.model.bulletChartSettings.values.maximumPercent,
                            }
                        }];
                };
                BulletChart.prototype.enumerateOrientation = function (data) {
                    return [{
                            selector: null,
                            objectName: 'orientation',
                            properties: {
                                orientation: this.model.bulletChartSettings.orientation.orientation
                            }
                        }];
                };
                BulletChart.prototype.enumerateAxis = function (data) {
                    return [{
                            selector: null,
                            objectName: 'axis',
                            properties: {
                                axis: this.model.bulletChartSettings.axis.axis,
                                axisColor: this.model.bulletChartSettings.axis.axisColor,
                                measureUnits: this.model.bulletChartSettings.axis.measureUnits,
                                unitsColor: this.model.bulletChartSettings.axis.unitsColor,
                            }
                        }];
                };
                BulletChart.prototype.enumerateColors = function (data) {
                    return [{
                            selector: null,
                            objectName: 'colors',
                            properties: {
                                badColor: this.model.bulletChartSettings.colors.badColor,
                                needsImprovementColor: this.model.bulletChartSettings.colors.needsImprovementColor,
                                satisfactoryColor: this.model.bulletChartSettings.colors.satisfactoryColor,
                                goodColor: this.model.bulletChartSettings.colors.goodColor,
                                veryGoodColor: this.model.bulletChartSettings.colors.veryGoodColor,
                                bulletColor: this.model.bulletChartSettings.colors.bulletColor,
                            }
                        }];
                };
                BulletChart.ScrollBarSize = 13;
                BulletChart.SpaceRequiredForBar = 60;
                BulletChart.SpaceRequiredForBarVertically = 100;
                BulletChart.StartMarginHorizontal = 30;
                BulletChart.StartMarginVertical = 50;
                BulletChart.BulletSize = 25;
                BulletChart.DefaultSubtitleFontSizeInPt = 9;
                BulletChart.BarMargin = 10;
                BulletChart.MaxLabelWidth = 80;
                BulletChart.MaxLabelHeight = 60;
                BulletChart.SubtitleMargin = 10;
                BulletChart.AxisFontSizeInPt = 8;
                BulletChart.BiggestLabelWidth = 0;
                BulletChart.BiggestLabelHeight = 0;
                BulletChart.MarkerMarginHorizontal = BulletChart.BulletSize / 3;
                BulletChart.MarkerMarginVertical = BulletChart.BulletSize / 4;
                BulletChart.FontFamily = "Segoe UI";
                BulletChart.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Category',
                        }, {
                            name: 'Value',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Value',
                        }, {
                            name: 'TargetValue',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Target Value',
                        }, {
                            name: 'Minimum',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Minimum',
                        }, {
                            name: 'NeedsImprovement',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Needs Improvement',
                        }, {
                            name: 'Satisfactory',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Satisfactory',
                        }, {
                            name: 'Good',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Good',
                        }, {
                            name: 'VeryGood',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Very Good',
                        }, {
                            name: 'Maximum',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Maximum',
                        }, {
                            name: 'TargetValue2',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Target Value 2'
                        }
                    ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        values: {
                            displayName: 'Data values',
                            properties: {
                                targetValue: {
                                    displayName: 'Target Value',
                                    type: { numeric: true }
                                },
                                targetValue2: {
                                    displayName: 'Target Value 2',
                                    type: { numeric: true },
                                },
                                minimumPercent: {
                                    displayName: 'Minimum %',
                                    type: { numeric: true }
                                },
                                needsImprovementPercent: {
                                    displayName: 'Needs Improvement %',
                                    type: { numeric: true },
                                },
                                satisfactoryPercent: {
                                    displayName: 'Satisfactory %',
                                    type: { numeric: true }
                                },
                                goodPercent: {
                                    displayName: 'Good %',
                                    type: { numeric: true }
                                },
                                veryGoodPercent: {
                                    displayName: 'Very Good %',
                                    type: { numeric: true },
                                },
                                maximumPercent: {
                                    displayName: 'Maximum %',
                                    type: { numeric: true }
                                },
                            }
                        },
                        labels: {
                            displayName: 'Category labels',
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true },
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } },
                                },
                            },
                        },
                        orientation: {
                            displayName: 'Orientation',
                            properties: {
                                orientation: {
                                    displayName: 'Orientation',
                                    type: { enumeration: Orientation.type }
                                }
                            }
                        },
                        colors: {
                            displayName: 'Colors',
                            properties: {
                                badColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Bad Color'
                                },
                                needsImprovementColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Needs Improvement Color',
                                },
                                satisfactoryColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Satisfactory Color'
                                },
                                goodColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Good Color'
                                },
                                veryGoodColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Very Good Color',
                                },
                                bulletColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Bullet Color'
                                }
                            },
                        },
                        axis: {
                            displayName: 'Axis',
                            properties: {
                                axis: {
                                    displayName: 'Axis',
                                    type: { bool: true }
                                },
                                axisColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Axis Color'
                                },
                                measureUnits: {
                                    type: { text: true },
                                    displayName: 'Measure Units '
                                },
                                unitsColor: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Units Color'
                                },
                            }
                        }
                    },
                    dataViewMappings: [{
                            conditions: [
                                {
                                    'Category': { max: 1 }, 'Value': { max: 1 }, 'TargetValue': { max: 1 }, 'Minimum': { max: 1 }, 'NeedsImprovement': { max: 1 },
                                    'Satisfactory': { max: 1 }, 'Good': { max: 1 }, 'VeryGood': { max: 1 }, 'Maximum': { max: 1 }, 'TargetValue2': { max: 1 },
                                },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [
                                        { bind: { to: 'Value' } },
                                        { bind: { to: 'TargetValue' } },
                                        { bind: { to: 'TargetValue2' } },
                                        { bind: { to: 'Minimum' } },
                                        { bind: { to: 'NeedsImprovement' } },
                                        { bind: { to: 'Satisfactory' } },
                                        { bind: { to: 'Good' } },
                                        { bind: { to: 'VeryGood' } },
                                        { bind: { to: 'Maximum' } },
                                    ]
                                },
                            },
                        }],
                    supportsHighlight: true,
                    sorting: {
                        default: {},
                    },
                    drilldown: {
                        roles: ['Category']
                    }
                };
                return BulletChart;
            }());
            samples.BulletChart = BulletChart;
            //TODO: This module should be removed once TextMeasruementService exports the "estimateSvgTextBaselineDelta" function.
            var TextMeasurementHelper;
            (function (TextMeasurementHelper) {
                var spanElement;
                var svgTextElement;
                var canvasCtx;
                function estimateSvgTextBaselineDelta(textProperties) {
                    var rect = estimateSvgTextRect(textProperties);
                    return rect.y + rect.height;
                }
                TextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                function ensureDOM() {
                    if (spanElement)
                        return;
                    spanElement = $('<span/>');
                    $('body').append(spanElement);
                    //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.
                    svgTextElement = d3.select($('body').get(0))
                        .append('svg')
                        .style({
                        'height': '0px',
                        'width': '0px',
                        'position': 'absolute'
                    })
                        .append('text');
                    canvasCtx = $('<canvas/>').get(0).getContext("2d");
                }
                function measureSvgTextRect(textProperties) {
                    debug.assertValue(textProperties, 'textProperties');
                    ensureDOM();
                    svgTextElement.style(null);
                    svgTextElement
                        .text(textProperties.text)
                        .attr({
                        'visibility': 'hidden',
                        'font-family': textProperties.fontFamily,
                        'font-size': textProperties.fontSize,
                        'font-weight': textProperties.fontWeight,
                        'font-style': textProperties.fontStyle,
                        'white-space': textProperties.whiteSpace || 'nowrap'
                    });
                    // We're expecting the browser to give a synchronous measurement here
                    // We're using SVGTextElement because it works across all browsers 
                    return svgTextElement.node().getBBox();
                }
                function estimateSvgTextRect(textProperties) {
                    debug.assertValue(textProperties, 'textProperties');
                    var estimatedTextProperties = {
                        fontFamily: textProperties.fontFamily,
                        fontSize: textProperties.fontSize,
                        text: "M",
                    };
                    var rect = measureSvgTextRect(estimatedTextProperties);
                    return rect;
                }
            })(TextMeasurementHelper = samples.TextMeasurementHelper || (samples.TextMeasurementHelper = {}));
            var BulletWebBehavior = (function () {
                function BulletWebBehavior() {
                }
                BulletWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    this.options = options;
                    var clearCatcher = options.clearCatcher;
                    options.valueRects.on('click', function (d, i) {
                        d3.event.stopPropagation();
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    });
                    options.rects.on('click', function (d, i) {
                        d3.event.stopPropagation();
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    });
                    clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                BulletWebBehavior.prototype.renderSelection = function (hasSelection) {
                    var options = this.options;
                    options.valueRects.style("opacity", function (d) {
                        return hasSelection ? (d.selected ? '1' : '0.4') : '1';
                    });
                    options.rects.style("opacity", function (d) {
                        return hasSelection ? (d.selected ? '1' : '0.4') : '1';
                    });
                };
                return BulletWebBehavior;
            }());
            samples.BulletWebBehavior = BulletWebBehavior;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/ https://github.com/jasondavies/d3-cloud
// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
            (function (WordCloudScaleType) {
                WordCloudScaleType[WordCloudScaleType["logn"] = 0] = "logn";
                WordCloudScaleType[WordCloudScaleType["sqrt"] = 1] = "sqrt";
                WordCloudScaleType[WordCloudScaleType["value"] = 2] = "value";
            })(samples.WordCloudScaleType || (samples.WordCloudScaleType = {}));
            var WordCloudScaleType = samples.WordCloudScaleType;
            ;
            var VisualLayout = (function () {
                function VisualLayout(defaultViewport, defaultMargin) {
                    this.defaultViewport = defaultViewport || { width: 0, height: 0 };
                    this.defaultMargin = defaultMargin || { top: 0, bottom: 0, right: 0, left: 0 };
                }
                Object.defineProperty(VisualLayout.prototype, "margin", {
                    get: function () {
                        return this.marginValue || (this.margin = this.defaultMargin);
                    },
                    set: function (value) {
                        this.marginValue = VisualLayout.restrictToMinMax(value);
                        this.update();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VisualLayout.prototype, "viewport", {
                    get: function () {
                        return this.viewportValue || (this.viewportValue = this.defaultViewport);
                    },
                    set: function (value) {
                        this.viewportValue = VisualLayout.restrictToMinMax(value);
                        this.update();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VisualLayout.prototype, "viewportIn", {
                    get: function () {
                        return this.viewportInValue || this.viewport;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(VisualLayout.prototype, "viewportInIsZero", {
                    get: function () {
                        return this.viewportIn.width === 0 || this.viewportIn.height === 0;
                    },
                    enumerable: true,
                    configurable: true
                });
                VisualLayout.prototype.update = function () {
                    this.viewportInValue = VisualLayout.restrictToMinMax({
                        width: this.viewport.width - (this.margin.left + this.margin.right),
                        height: this.viewport.height - (this.margin.top + this.margin.bottom)
                    });
                };
                VisualLayout.restrictToMinMax = function (value) {
                    var result = $.extend({}, value);
                    d3.keys(value).forEach(function (x) { return result[x] = Math.max(0, value[x]); });
                    return result;
                };
                return VisualLayout;
            }());
            var WordCloud = (function () {
                function WordCloud(options) {
                    this.durationAnimations = 500;
                    this.fakeViewport = {
                        width: 1500,
                        height: 1000
                    };
                    this.canvasViewport = {
                        width: 128,
                        height: 2048
                    };
                    if (options) {
                        this.svg = options.svg || this.svg;
                        this.layout = new VisualLayout(null, options.margin || WordCloud.DefaultMargin);
                        if (options.animator)
                            this.animator = options.animator;
                    }
                }
                WordCloud.prototype.init = function (options) {
                    var _this = this;
                    if (this.svg)
                        this.root = this.svg;
                    else
                        this.root = d3.select(options.element.get(0)).append("svg");
                    WordCloud.colors = options.style.colorPalette.dataColors;
                    this.hostService = options.host;
                    this.selectionManager = new visuals.utility.SelectionManager({ hostServices: this.hostService });
                    if (!this.layout)
                        this.layout = new VisualLayout(null, WordCloud.DefaultMargin);
                    this.root.classed(WordCloud.ClassName, true);
                    this.root.on("click", function () {
                        _this.selectionManager.clear();
                        _this.setSelection(_this.wordsSelection);
                    });
                    this.fontFamily = this.root.style("font-family");
                    this.main = this.root.append("g");
                    this.wordsContainerSelection = this.main
                        .append("g")
                        .classed(WordCloud.Words["class"], true);
                    this.canvas = document.createElement("canvas");
                };
                WordCloud.prototype.converter = function (dataView) {
                    var _this = this;
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[0].values ||
                        !dataView.categorical.categories[0].values.length ||
                        !(dataView.categorical.categories[0].values.length > 0))
                        return null;
                    var categories = dataView.categorical.categories[0].values, settings = WordCloud.parseSettings(dataView, categories[0]), frequencies, texts;
                    if (!settings)
                        return null;
                    if (!_.isEmpty(dataView.categorical.values) &&
                        !_.isEmpty(dataView.categorical.values[0]) &&
                        !_.isEmpty(dataView.categorical.values[0].values))
                        frequencies = dataView.categorical.values[0].values;
                    texts = categories.map(function (item, index) {
                        var color, categoryObject = dataView.categorical.categories[0];
                        if (categoryObject.objects && categoryObject.objects[index])
                            color = _this.getColor(WordCloud.Properties.dataPoint.fill, explore.util.getRandomColor(), categoryObject.objects[index]);
                        else {
                            if (_this.wordCloudTexts && _this.wordCloudTexts[index])
                                color = _this.wordCloudTexts[index].color;
                            else
                                color = explore.util.getRandomColor();
                        }
                        return {
                            text: item,
                            count: (frequencies && frequencies[index] && !isNaN(frequencies[index])) ? frequencies[index] : 1,
                            index: index,
                            selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[index]),
                            color: color,
                        };
                    });
                    return {
                        settings: settings,
                        texts: texts
                    };
                };
                WordCloud.prototype.getColor = function (properties, defaultColor, objects) {
                    var colorHelper;
                    colorHelper = new visuals.ColorHelper(WordCloud.colors, properties, defaultColor);
                    return explore.util.hexToRgb(colorHelper.getColorForMeasure(objects, ""));
                };
                WordCloud.parseSettings = function (dataView, value) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.columns[0])
                        return null;
                    var objects = dataView.metadata.objects, valueFormatter, minFontSize, maxFontSize, minAngle, maxAngle, maxNumberOfOrientations, isRotateText = false, isBrokenText = true, isRemoveStopWords = true, stopWords, stopWordsArray, isDefaultStopWords = false, maxNumberOfWords;
                    maxNumberOfWords = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords);
                    minFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.minFontSize, WordCloud.DefaultSettings.minFontSize);
                    maxFontSize = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.general.maxFontSize, WordCloud.DefaultSettings.maxFontSize);
                    minAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.minAngle, WordCloud.DefaultSettings.minAngle);
                    maxAngle = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxAngle, WordCloud.DefaultSettings.maxAngle);
                    isRotateText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.rotateText.show, WordCloud.DefaultSettings.isRotateText);
                    maxNumberOfOrientations = WordCloud.getNumberFromObjects(objects, WordCloud.Properties.rotateText.maxNumberOfOrientations, WordCloud.DefaultSettings.maxNumberOfOrientations);
                    valueFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, WordCloud.Properties.general.formatString),
                        value: value
                    });
                    isBrokenText = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.general.isBrokenText, WordCloud.DefaultSettings.isBrokenText);
                    isRemoveStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.show, WordCloud.DefaultSettings.isRemoveStopWords);
                    stopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.words, WordCloud.DefaultSettings.stopWords);
                    if (typeof stopWords === "string")
                        stopWordsArray = stopWords.split(WordCloud.StopWordsDelemiter);
                    else
                        stopWordsArray = WordCloud.DefaultSettings.stopWordsArray;
                    isDefaultStopWords = powerbi.DataViewObjects.getValue(objects, WordCloud.Properties.stopWords.isDefaultStopWords, WordCloud.DefaultSettings.isDefaultStopWords);
                    return {
                        minFontSize: minFontSize,
                        maxFontSize: maxFontSize,
                        minAngle: minAngle,
                        maxAngle: maxAngle,
                        maxNumberOfOrientations: maxNumberOfOrientations,
                        valueFormatter: valueFormatter,
                        isRotateText: isRotateText,
                        isBrokenText: isBrokenText,
                        isRemoveStopWords: isRemoveStopWords,
                        stopWords: stopWords,
                        stopWordsArray: stopWordsArray,
                        isDefaultStopWords: isDefaultStopWords,
                        maxNumberOfWords: maxNumberOfWords
                    };
                };
                WordCloud.getNumberFromObjects = function (objects, properties, defaultValue) {
                    return objects ? powerbi.DataViewObjects.getValue(objects, properties, defaultValue) : defaultValue;
                };
                WordCloud.prototype.parseNumber = function (value, defaultValue, minValue, maxValue) {
                    if (defaultValue === void 0) { defaultValue = 0; }
                    if (minValue === void 0) { minValue = -Number.MAX_VALUE; }
                    if (maxValue === void 0) { maxValue = Number.MAX_VALUE; }
                    var parsedValue = Number(value);
                    if (isNaN(parsedValue) || (typeof value === "string" && value.length === 0))
                        return defaultValue;
                    if (parsedValue < minValue)
                        return minValue;
                    if (parsedValue > maxValue)
                        return maxValue;
                    return parsedValue;
                };
                WordCloud.prototype.computePositions = function (words, onPositionsComputed) {
                    var _this = this;
                    var context = this.getCanvasContext(), surface = [], borders = null, maxNumberOfWords;
                    if (!words || !(words.length > 0))
                        return null;
                    maxNumberOfWords = Math.abs(this.parseNumber(this.settings.maxNumberOfWords, WordCloud.DefaultSettings.maxNumberOfWords, words.length * -1, words.length));
                    if (words.length > maxNumberOfWords)
                        words = words.slice(0, maxNumberOfWords);
                    for (var i = void 0; i < (this.specialViewport.width >> 5) * this.specialViewport.height; i++) {
                        surface[i] = 0;
                    }
                    setTimeout(function () { return _this.computeCycle(words, context, surface, borders, onPositionsComputed, [], 0); }, 0);
                };
                WordCloud.prototype.computeCycle = function (words, context, surface, borders, onPositionsComputed, wordsForDraw, index) {
                    if (wordsForDraw === void 0) { wordsForDraw = []; }
                    if (index === void 0) { index = 0; }
                    var word = words[index], ratio = 1;
                    if (words.length <= 10)
                        ratio = 5;
                    else if (words.length <= 25)
                        ratio = 3;
                    else if (words.length <= 75)
                        ratio = 1.5;
                    else if (words.length <= 100)
                        ratio = 1.25;
                    word.x = (this.specialViewport.width / ratio * (Math.random() + 0.5)) >> 1;
                    word.y = (this.specialViewport.height / ratio * (Math.random() + 0.5)) >> 1;
                    this.generateSprites(context, word, words, index);
                    if (word.sprite && this.findPosition(surface, word, borders)) {
                        wordsForDraw.push(word);
                        borders = this.updateBorders(word, borders);
                        word.x -= this.specialViewport.width >> 1;
                        word.y -= this.specialViewport.height >> 1;
                    }
                    if (++index < words.length && this.root)
                        this.computeCycle(words, context, surface, borders, onPositionsComputed, wordsForDraw, index);
                    else {
                        onPositionsComputed({
                            data: wordsForDraw,
                            leftBorder: borders && borders[0],
                            rightBorder: borders && borders[1]
                        });
                    }
                };
                WordCloud.prototype.updateBorders = function (word, borders) {
                    if (borders && borders.length === 2) {
                        var leftBorder = borders[0], rightBorder = borders[1];
                        if (word.x + word.x0 < leftBorder.x)
                            leftBorder.x = word.x + word.x0;
                        if (word.y + word.y0 < leftBorder.y)
                            leftBorder.y = word.y + word.y0;
                        if (word.x + word.x1 > rightBorder.x)
                            rightBorder.x = word.x + word.x1;
                        if (word.y + word.y1 > rightBorder.y)
                            rightBorder.y = word.y + word.y1;
                    }
                    else {
                        borders = [
                            {
                                x: word.x + word.x0,
                                y: word.y + word.y0
                            }, {
                                x: word.x + word.x1,
                                y: word.y + word.y1
                            }
                        ];
                    }
                    return borders;
                };
                WordCloud.prototype.generateSprites = function (context, currentWord, words, index) {
                    if (currentWord.sprite)
                        return;
                    context.clearRect(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height);
                    var x = 0, y = 0, maxHeight = 0, quantityOfWords = words.length, pixels, sprite = [];
                    for (var i = index; i < quantityOfWords; i++) {
                        var currentWordData = words[i], widthOfWord = 0, heightOfWord = 0;
                        context.save();
                        context.font = "normal normal " + (currentWordData.size + 1) + WordCloud.Size + " " + this.fontFamily;
                        widthOfWord = context.measureText(currentWordData.text + "m").width;
                        heightOfWord = currentWordData.size << 1;
                        if (currentWordData.rotate) {
                            var sr = Math.sin(currentWordData.rotate * WordCloud.Radians), cr = Math.cos(currentWordData.rotate * WordCloud.Radians), widthCr = widthOfWord * cr, widthSr = widthOfWord * sr, heightCr = heightOfWord * cr, heightSr = heightOfWord * sr;
                            widthOfWord = (Math.max(Math.abs(widthCr + heightSr), Math.abs(widthCr - heightSr)) + 31) >> 5 << 5;
                            heightOfWord = Math.floor(Math.max(Math.abs(widthSr + heightCr), Math.abs(widthSr - heightCr)));
                        }
                        else
                            widthOfWord = (widthOfWord + 31) >> 5 << 5;
                        if (heightOfWord > maxHeight)
                            maxHeight = heightOfWord;
                        if (x + widthOfWord >= (this.canvasViewport.width << 5)) {
                            x = 0;
                            y += maxHeight;
                            maxHeight = 0;
                        }
                        context.translate((x + (widthOfWord >> 1)), (y + (heightOfWord >> 1)));
                        if (currentWordData.rotate)
                            context.rotate(currentWordData.rotate * WordCloud.Radians);
                        context.fillText(currentWordData.text, 0, 0);
                        if (currentWordData.padding) {
                            context.lineWidth = 2 * currentWordData.padding;
                            context.strokeText(currentWordData.text, 0, 0);
                        }
                        context.restore();
                        currentWordData.width = widthOfWord;
                        currentWordData.height = heightOfWord;
                        currentWordData.xOff = x;
                        currentWordData.yOff = y;
                        currentWordData.x1 = widthOfWord >> 1;
                        currentWordData.y1 = heightOfWord >> 1;
                        currentWordData.x0 = -currentWordData.x1;
                        currentWordData.y0 = -currentWordData.y1;
                        x += widthOfWord;
                    }
                    pixels = context.getImageData(0, 0, this.canvasViewport.width << 5, this.canvasViewport.height).data;
                    sprite = [];
                    for (var i = quantityOfWords - 1; i >= 0; i--) {
                        var currentWordData = words[i], width = currentWordData.width, width32 = width >> 5, height = currentWordData.y1 - currentWordData.y0, x_1 = 0, y_1 = 0, seen = 0, seenRow = 0;
                        if (currentWordData.xOff + width >= (this.canvasViewport.width << 5) ||
                            currentWordData.yOff + height >= this.canvasViewport.height) {
                            currentWordData.sprite = null;
                            continue;
                        }
                        for (var j = 0; j < height * width32; j++) {
                            sprite[j] = 0;
                        }
                        if (currentWordData.xOff !== null)
                            x_1 = currentWordData.xOff;
                        else
                            return;
                        y_1 = currentWordData.yOff;
                        seen = 0;
                        seenRow = -1;
                        for (var j = 0; j < height; j++) {
                            for (var k = 0; k < width; k++) {
                                var l = width32 * j + (k >> 5), index_1 = ((y_1 + j) * (this.canvasViewport.width << 5) + (x_1 + k)) << 2, m = pixels[index_1]
                                    ? 1 << (31 - (k % 32))
                                    : 0;
                                sprite[l] |= m;
                                seen |= m;
                            }
                            if (seen)
                                seenRow = j;
                            else {
                                currentWordData.y0++;
                                height--;
                                j--;
                                y_1++;
                            }
                        }
                        currentWordData.y1 = currentWordData.y0 + seenRow;
                        currentWordData.sprite = sprite.slice(0, (currentWordData.y1 - currentWordData.y0) * width32);
                    }
                };
                WordCloud.prototype.findPosition = function (surface, word, borders) {
                    var startPoint = { x: word.x, y: word.y }, delta = Math.sqrt(this.specialViewport.width * this.specialViewport.width + this.specialViewport.height * this.specialViewport.height), point, dt = Math.random() < 0.5 ? 1 : -1, shift = -dt, dx, dy;
                    while (true) {
                        shift += dt;
                        point = this.archimedeanSpiral(shift);
                        dx = Math.floor(point.x);
                        dy = Math.floor(point.y);
                        if (Math.min(Math.abs(dx), Math.abs(dy)) >= delta)
                            break;
                        word.x = startPoint.x + dx;
                        word.y = startPoint.y + dy;
                        if (word.x + word.x0 < 0 ||
                            word.y + word.y0 < 0 ||
                            word.x + word.x1 > this.specialViewport.width ||
                            word.y + word.y1 > this.specialViewport.height)
                            continue;
                        if (!borders || !this.checkIntersect(word, surface)) {
                            if (!borders || this.checkIntersectOfRectangles(word, borders[0], borders[1])) {
                                var sprite = word.sprite, width = word.width >> 5, shiftWidth = this.specialViewport.width >> 5, lx = word.x - (width << 4), sx = lx & 127, msx = 32 - sx, height = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5);
                                for (var i = 0; i < height; i++) {
                                    var lastSprite = 0;
                                    for (var j = 0; j <= width; j++) {
                                        var leftMask = lastSprite << msx, rightMask = void 0;
                                        if (j < width)
                                            lastSprite = sprite[i * width + j];
                                        rightMask = j < width
                                            ? lastSprite >>> sx
                                            : 0;
                                        surface[x + j] |= leftMask | rightMask;
                                    }
                                    x += shiftWidth;
                                }
                                word.sprite = null;
                                return true;
                            }
                        }
                    }
                    return false;
                };
                WordCloud.prototype.archimedeanSpiral = function (value) {
                    var ratio = this.specialViewport.width / this.specialViewport.height;
                    value = value * 0.1;
                    return {
                        x: ratio * value * Math.cos(value),
                        y: value * Math.sin(value)
                    };
                };
                WordCloud.prototype.checkIntersect = function (word, surface) {
                    var shiftWidth = this.specialViewport.width >> 5, sprite = word.sprite, widthOfWord = word.width >> 5, lx = word.x - (widthOfWord << 4), sx = lx & 127, msx = 32 - sx, heightOfWord = word.y1 - word.y0, x = (word.y + word.y0) * shiftWidth + (lx >> 5);
                    for (var i = 0; i < heightOfWord; i++) {
                        var lastSprite = 0;
                        for (var j = 0; j <= widthOfWord; j++) {
                            var mask = 0, leftMask = void 0, intersectMask = 0;
                            leftMask = lastSprite << msx;
                            if (j < widthOfWord)
                                lastSprite = sprite[i * widthOfWord + j];
                            mask = j < widthOfWord
                                ? lastSprite >>> sx
                                : 0;
                            intersectMask = (leftMask | mask) & surface[x + j];
                            if (intersectMask)
                                return true;
                        }
                        x += shiftWidth;
                    }
                    return false;
                };
                WordCloud.prototype.checkIntersectOfRectangles = function (word, leftBorder, rightBorder) {
                    return (word.x + word.x1) > leftBorder.x &&
                        (word.x + word.x0) < rightBorder.x &&
                        (word.y + word.y1) > leftBorder.y &&
                        (word.y + word.y0) < rightBorder.y;
                };
                WordCloud.prototype.getCanvasContext = function () {
                    if (!this.canvasViewport)
                        return null;
                    this.canvas.width = 1;
                    this.canvas.height = 1;
                    var context = this.canvas.getContext("2d");
                    this.canvas.width = this.canvasViewport.width << 5;
                    this.canvas.height = this.canvasViewport.height;
                    context = this.canvas.getContext("2d");
                    context.fillStyle = context.strokeStyle = "red";
                    context.textAlign = "center";
                    return context;
                };
                WordCloud.prototype.getReducedText = function (texts) {
                    var brokenStrings = [];
                    brokenStrings = this.getBrokenWords(texts);
                    return brokenStrings.reduce(function (previousValue, currentValue) {
                        if (!previousValue.some(function (value) {
                            if (value.index !== currentValue.index && value.text === currentValue.text) {
                                value.count += currentValue.count;
                                return true;
                            }
                            return false;
                        })) {
                            previousValue.push(currentValue);
                        }
                        return previousValue;
                    }, []);
                };
                WordCloud.prototype.getBrokenWords = function (words) {
                    var _this = this;
                    var brokenStrings = [], whiteSpaceRegExp = /\s/, punctuatuinRegExp;
                    if (!this.settings.isBrokenText)
                        return words;
                    punctuatuinRegExp = new RegExp("[" + WordCloud.Punctuation.join("\\") + "]", "gim");
                    words.forEach(function (item) {
                        if (typeof item.text === "string") {
                            var words_1;
                            words_1 = item.text.replace(punctuatuinRegExp, " ").split(whiteSpaceRegExp);
                            if (_this.settings.isRemoveStopWords) {
                                var stopWords_1 = _this.settings.stopWordsArray;
                                if (_this.settings.isDefaultStopWords)
                                    stopWords_1 = stopWords_1.concat(WordCloud.StopWords);
                                words_1 = words_1.filter(function (value) {
                                    return value.length > 0 && !stopWords_1.some(function (removeWord) {
                                        return value.toLocaleLowerCase() === removeWord.toLocaleLowerCase();
                                    });
                                });
                            }
                            words_1.forEach(function (element) {
                                if (element.length > 0 && !whiteSpaceRegExp.test(element)) {
                                    brokenStrings.push({
                                        text: element,
                                        count: item.count,
                                        index: item.index,
                                        selectionId: item.selectionId,
                                        color: item.color
                                    });
                                }
                            });
                        }
                        else
                            brokenStrings.push(item);
                    });
                    return brokenStrings;
                };
                WordCloud.prototype.getWords = function (values) {
                    var _this = this;
                    var sortedValues, minValue = 0, maxValue = 0, valueFormatter = this.settings.valueFormatter;
                    if (!values || !(values.length >= 1))
                        return [];
                    sortedValues = values.sort(function (a, b) {
                        return b.count - a.count;
                    });
                    minValue = sortedValues[sortedValues.length - 1].count;
                    maxValue = sortedValues[0].count;
                    var returnValues = values.map(function (value) {
                        return {
                            text: valueFormatter.format(value.text),
                            size: _this.getFontSize(value.count, minValue, maxValue),
                            x: 0,
                            y: 0,
                            rotate: _this.getAngle(),
                            padding: 1,
                            width: 0,
                            height: 0,
                            xOff: 0,
                            yOff: 0,
                            x0: 0,
                            y0: 0,
                            x1: 0,
                            y1: 0,
                            color: value.color,
                            selectionId: value.selectionId,
                            wordIndex: value.index
                        };
                    });
                    this.dataBeforeRender = returnValues;
                    return returnValues;
                };
                WordCloud.prototype.getFontSize = function (value, minValue, maxValue, scaleType) {
                    if (scaleType === void 0) { scaleType = WordCloudScaleType.value; }
                    var weight, fontSize, maxFontSize, minFontSize;
                    minFontSize = Math.abs(this.parseNumber(this.settings.minFontSize, WordCloud.DefaultSettings.minFontSize));
                    maxFontSize = Math.abs(this.parseNumber(this.settings.maxFontSize, WordCloud.DefaultSettings.maxFontSize));
                    if (minFontSize > maxFontSize) {
                        var buffer = minFontSize;
                        minFontSize = maxFontSize;
                        maxFontSize = buffer;
                    }
                    switch (scaleType) {
                        case WordCloudScaleType.logn: {
                            weight = Math.log(value);
                        }
                        case WordCloudScaleType.sqrt: {
                            weight = Math.sqrt(value);
                        }
                        case WordCloudScaleType.value: {
                            weight = value;
                        }
                    }
                    fontSize = weight > minValue
                        ? (maxFontSize * (weight - minValue)) / (maxValue - minValue)
                        : 0;
                    fontSize = (fontSize * 100) / maxFontSize;
                    fontSize = (fontSize * (maxFontSize - minFontSize)) / 100 + minFontSize;
                    return fontSize;
                };
                WordCloud.prototype.getAngle = function () {
                    if (!this.settings ||
                        !this.settings.isRotateText)
                        return 0;
                    var minAngle, maxAngle, maxNumberOfOrientations, angle;
                    maxNumberOfOrientations = Math.abs(this.parseNumber(this.settings.maxNumberOfOrientations, 0));
                    minAngle = this.parseNumber(this.settings.minAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle);
                    maxAngle = this.parseNumber(this.settings.maxAngle, 0, WordCloud.MinAngle, WordCloud.MaxAngle);
                    if (minAngle > maxAngle) {
                        var buffer = minAngle;
                        minAngle = maxAngle;
                        maxAngle = buffer;
                    }
                    angle = Math.abs(((maxAngle - minAngle) / maxNumberOfOrientations) * Math.floor(Math.random() * maxNumberOfOrientations));
                    return maxNumberOfOrientations !== 0 ? minAngle + angle : 0;
                };
                WordCloud.prototype.update = function (visualUpdateOptions) {
                    var _this = this;
                    if (!visualUpdateOptions ||
                        !visualUpdateOptions.viewport ||
                        !visualUpdateOptions.dataViews ||
                        !visualUpdateOptions.dataViews[0] ||
                        !visualUpdateOptions.viewport ||
                        !(visualUpdateOptions.viewport.height >= 0) ||
                        !(visualUpdateOptions.viewport.width >= 0))
                        return;
                    this.visualUpdateOptions = visualUpdateOptions;
                    this.layout.viewport = this.visualUpdateOptions.viewport;
                    var dataView = visualUpdateOptions.dataViews[0];
                    if (this.layout.viewportInIsZero)
                        return;
                    this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);
                    this.UpdateSize();
                    this.data = this.converter(dataView);
                    if (!this.data)
                        return;
                    this.settings = this.data.settings;
                    this.wordCloudTexts = this.data.texts;
                    this.computePositions(this.getWords(this.getReducedText(this.data.texts)), function (wordCloudDataView) { return _this.render(wordCloudDataView); });
                    if (visualUpdateOptions !== this.visualUpdateOptions)
                        this.update(this.visualUpdateOptions);
                };
                WordCloud.prototype.UpdateSize = function () {
                    var fakeWidth, fakeHeight, ratio;
                    ratio = Math.sqrt((this.fakeViewport.width * this.fakeViewport.height)
                        / (this.layout.viewportIn.width * this.layout.viewportIn.height));
                    if (isNaN(ratio))
                        fakeHeight = fakeWidth = 1;
                    else {
                        fakeHeight = this.layout.viewportIn.height * ratio;
                        fakeWidth = this.layout.viewportIn.width * ratio;
                    }
                    this.specialViewport = {
                        height: fakeHeight,
                        width: fakeWidth
                    };
                    this.root.attr({
                        "height": this.layout.viewport.height,
                        "width": this.layout.viewport.width
                    });
                };
                WordCloud.prototype.render = function (wordCloudDataView) {
                    var _this = this;
                    if (!wordCloudDataView ||
                        !wordCloudDataView.data)
                        return;
                    this.wordCloudDataView = wordCloudDataView;
                    var animatedWordSelection, wordElements = this.main
                        .select(WordCloud.Words.selector)
                        .selectAll(WordCloud.Word.selector);
                    this.wordsSelection = wordElements.data(wordCloudDataView.data);
                    this.animation(this.wordsSelection, this.durationAnimations)
                        .attr("transform", function (item) { return (visuals.SVGUtil.translate(item.x, item.y) + "rotate(" + item.rotate + ")"); })
                        .style({
                        "font-size": (function (item) { return ("" + item.size + WordCloud.Size); }),
                        "fill": (function (item) { return item.color; }),
                    });
                    animatedWordSelection = this.wordsSelection
                        .enter()
                        .append("svg:text")
                        .attr("transform", function (item) { return (visuals.SVGUtil.translate(item.x, item.y) + "rotate(" + item.rotate + ")"); })
                        .style("font-size", "1px");
                    this.wordsSelection.on("click", function (item) {
                        _this.selectionManager
                            .select(item.selectionId, d3.event.ctrlKey)
                            .then(function () { return _this.setSelection(_this.wordsSelection); });
                        d3.event.stopPropagation();
                    });
                    this.animation(animatedWordSelection, this.durationAnimations)
                        .style({
                        "font-size": (function (item) { return ("" + item.size + WordCloud.Size); }),
                        "fill": (function (item) { return item.color; }),
                    });
                    this.wordsSelection
                        .text(function (item) { return item.text; })
                        .classed(WordCloud.Word["class"], true);
                    this.wordsSelection.exit().remove();
                    this.setSelection(this.wordsSelection);
                    setTimeout(function () {
                        if (_this.root)
                            _this.scaleMainView(wordCloudDataView, wordElements[0].length && _this.durationAnimations);
                    }, this.durationAnimations + WordCloud.RenderDelay);
                };
                WordCloud.prototype.setSelection = function (selection) {
                    var selectionIds = this.selectionManager.getSelectionIds();
                    if (selectionIds.some(function (x) { return !selection.data().some(function (d) { return d.selectionId.getKey() === x.getKey(); }); })) {
                        this.selectionManager.clear();
                        selectionIds = [];
                    }
                    if (!selectionIds.length) {
                        this.setOpacity(selection, WordCloud.MaxOpacity, true);
                        return;
                    }
                    var selectedColumns = selection.filter(function (x) {
                        return selectionIds.some(function (y) { return y.getKey() === x.selectionId.getKey(); });
                    });
                    this.setOpacity(selection, WordCloud.MinOpacity);
                    this.setOpacity(selectedColumns, WordCloud.MaxOpacity);
                };
                WordCloud.prototype.setOpacity = function (element, opacityValue, disableAnimation) {
                    if (disableAnimation === void 0) { disableAnimation = false; }
                    var elementAnimation = disableAnimation ? element : this.animation(element);
                    elementAnimation.style("fill-opacity", opacityValue);
                };
                WordCloud.prototype.scaleMainView = function (wordCloudDataView, durationAnimation) {
                    if (durationAnimation === void 0) { durationAnimation = 0; }
                    if (!wordCloudDataView ||
                        !wordCloudDataView.leftBorder ||
                        !wordCloudDataView.rightBorder)
                        return;
                    var scale = 1, mainSVGRect = this.main.node()["getBBox"](), leftBorder = wordCloudDataView.leftBorder, rightBorder = wordCloudDataView.rightBorder, width2, height2, scaleByX, scaleByY;
                    scaleByX = this.layout.viewportIn.width / Math.abs(leftBorder.x - rightBorder.x);
                    scaleByY = this.layout.viewportIn.height / Math.abs(leftBorder.y - rightBorder.y);
                    scale = Math.min(scaleByX, scaleByY);
                    width2 = this.layout.margin.left + (mainSVGRect.x * scale * -1)
                        + (this.layout.viewportIn.width - (mainSVGRect.width * scale)) / 2;
                    height2 = this.layout.margin.top + (mainSVGRect.y * scale * -1)
                        + (this.layout.viewportIn.height - (mainSVGRect.height * scale)) / 2;
                    this.animation(this.main, durationAnimation)
                        .attr("transform", visuals.SVGUtil.translate(width2, height2) + "scale(" + scale + ")");
                };
                WordCloud.prototype.enumerateObjectInstances = function (options) {
                    var _this = this;
                    var instances = [];
                    if (!this.settings)
                        return instances;
                    switch (options.objectName) {
                        case "general": {
                            var general = {
                                objectName: "general",
                                displayName: "general",
                                selector: null,
                                properties: {
                                    maxNumberOfWords: this.settings.maxNumberOfWords,
                                    minFontSize: this.settings.minFontSize,
                                    maxFontSize: this.settings.maxFontSize,
                                    isBrokenText: this.settings.isBrokenText
                                }
                            };
                            instances.push(general);
                            break;
                        }
                        case "dataPoint": {
                            if (!this.wordCloudDataView ||
                                !this.wordCloudDataView.data)
                                return;
                            var dataPoints = this.dataBeforeRender;
                            var wordCategoriesIndex_1 = [];
                            dataPoints.forEach(function (item) {
                                if (wordCategoriesIndex_1.indexOf(item.wordIndex) === -1) {
                                    wordCategoriesIndex_1.push(item.wordIndex);
                                    instances.push({
                                        objectName: "dataPoint",
                                        displayName: _this.data.texts[item.wordIndex].text,
                                        selector: visuals.ColorHelper.normalizeSelector(item.selectionId.getSelector(), false),
                                        properties: {
                                            fill: { solid: { color: item.color } }
                                        }
                                    });
                                }
                            });
                            break;
                        }
                        case "rotateText": {
                            var rotateText = {
                                objectName: "rotateText",
                                displayName: "Rotate Text",
                                selector: null,
                                properties: {
                                    show: this.settings.isRotateText,
                                    minAngle: this.settings.minAngle,
                                    maxAngle: this.settings.maxAngle,
                                    maxNumberOfOrientations: this.settings.maxNumberOfOrientations
                                }
                            };
                            instances.push(rotateText);
                            break;
                        }
                        case "stopWords": {
                            var stopWords = {
                                objectName: "stopWords",
                                displayName: "Stop Words",
                                selector: null,
                                properties: {
                                    show: this.settings.isRemoveStopWords,
                                    isDefaultStopWords: this.settings.isDefaultStopWords,
                                    words: this.settings.stopWords ||
                                        this.settings.stopWordsArray.join(WordCloud.StopWordsDelemiter)
                                }
                            };
                            instances.push(stopWords);
                            break;
                        }
                    }
                    return instances;
                };
                WordCloud.prototype.animation = function (element, duration, callback) {
                    if (duration === void 0) { duration = 0; }
                    return element
                        .transition()
                        .duration(duration)
                        .each("end", callback);
                };
                WordCloud.prototype.destroy = function () {
                    this.root = null;
                    this.canvas = null;
                };
                WordCloud.ClassName = "wordCloud";
                WordCloud.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        },
                        maxNumberOfWords: {
                            objectName: "general",
                            propertyName: "maxNumberOfWords"
                        },
                        minFontSize: {
                            objectName: "general",
                            propertyName: "minFontSize"
                        },
                        maxFontSize: {
                            objectName: "general",
                            propertyName: "maxFontSize"
                        },
                        isBrokenText: {
                            objectName: "general",
                            propertyName: "isBrokenText"
                        },
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    stopWords: {
                        show: {
                            objectName: "stopWords",
                            propertyName: "show"
                        },
                        isDefaultStopWords: {
                            objectName: "stopWords",
                            propertyName: "isDefaultStopWords"
                        },
                        words: {
                            objectName: "stopWords",
                            propertyName: "words"
                        },
                    },
                    rotateText: {
                        show: {
                            objectName: "rotateText",
                            propertyName: "show"
                        },
                        minAngle: {
                            objectName: "rotateText",
                            propertyName: "minAngle"
                        },
                        maxAngle: {
                            objectName: "rotateText",
                            propertyName: "maxAngle"
                        },
                        maxNumberOfOrientations: {
                            objectName: "rotateText",
                            propertyName: "maxNumberOfOrientations"
                        }
                    }
                };
                WordCloud.Words = {
                    "class": "words",
                    selector: ".words"
                };
                WordCloud.Word = {
                    "class": "word",
                    selector: ".word"
                };
                WordCloud.Size = "px";
                WordCloud.StopWordsDelemiter = " ";
                WordCloud.Radians = Math.PI / 180;
                WordCloud.MinAngle = -180;
                WordCloud.MaxAngle = 180;
                WordCloud.MaxNumberOfWords = 2500;
                WordCloud.MinOpacity = 0.2;
                WordCloud.MaxOpacity = 1;
                WordCloud.capabilities = {
                    dataRoles: [{
                            name: "Category",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Category"
                        }, {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Values"
                        }],
                    dataViewMappings: [{
                            conditions: [{
                                    "Category": {
                                        min: 1,
                                        max: 1
                                    },
                                    "Values": {
                                        min: 0,
                                        max: 1
                                    }
                                }],
                            categorical: {
                                categories: {
                                    for: { in: "Category" },
                                    dataReductionAlgorithm: { top: { count: WordCloud.MaxNumberOfWords } }
                                },
                                values: {
                                    for: { in: "Values" }
                                }
                            }
                        }],
                    sorting: {
                        implicit: {
                            clauses: [{
                                    role: "Values",
                                    direction: 2 /*SortDirection.Descending*/ //Constant SortDirection.Descending currently is not supported on the msit
                                }]
                        }
                    },
                    objects: {
                        general: {
                            displayName: "General",
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: true
                                        }
                                    }
                                },
                                maxNumberOfWords: {
                                    displayName: "Max number of words",
                                    type: { numeric: true }
                                },
                                minFontSize: {
                                    displayName: "Min Font",
                                    type: { numeric: true }
                                },
                                maxFontSize: {
                                    displayName: "Max Font",
                                    type: { numeric: true }
                                },
                                isBrokenText: {
                                    displayName: "Word-breaking",
                                    type: { bool: true }
                                },
                                isRemoveStopWords: {
                                    displayName: "Stop Words",
                                    type: { bool: true }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: "Data colors",
                            properties: {
                                fill: {
                                    displayName: "Fill",
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        stopWords: {
                            displayName: "Stop Words",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: { bool: true }
                                },
                                isDefaultStopWords: {
                                    displayName: "Default Stop Words",
                                    type: { bool: true }
                                },
                                words: {
                                    displayName: "Words",
                                    type: { text: true }
                                }
                            }
                        },
                        rotateText: {
                            displayName: "Rotate Text",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: { bool: true }
                                },
                                minAngle: {
                                    displayName: "Min Angle",
                                    type: { numeric: true }
                                },
                                maxAngle: {
                                    displayName: "Max Angle",
                                    type: { numeric: true }
                                },
                                maxNumberOfOrientations: {
                                    displayName: "Max number of orientations",
                                    type: { numeric: true }
                                }
                            }
                        }
                    }
                };
                WordCloud.Punctuation = [
                    "!", ".", ":", "'", ";", ",", "!",
                    "@", "#", "$", "%", "^", "&", "*",
                    "(", ")", "[", "]", "\"", "\\", "/",
                    "-", "_", "+", "="
                ];
                WordCloud.StopWords = [
                    "a", "able", "about", "across", "after", "all", "almost", "also", "am", "among", "an",
                    "and", "any", "are", "as", "at", "be", "because", "been", "but", "by", "can", "cannot",
                    "could", "did", "do", "does", "either", "else", "ever", "every", "for", "from", "get",
                    "got", "had", "has", "have", "he", "her", "hers", "him", "his", "how", "however", "i",
                    "if", "in", "into", "is", "it", "its", "just", "least", "let", "like", "likely", "may",
                    "me", "might", "most", "must", "my", "neither", "no", "nor", "not", "of", "off", "often",
                    "on", "only", "or", "other", "our", "own", "rather", "said", "say", "says", "she", "should",
                    "since", "so", "some", "than", "that", "the", "their", "them", "then", "there", "these",
                    "they", "this", "tis", "to", "too", "twas", "us", "wants", "was", "we", "were", "what",
                    "when", "where", "which", "while", "who", "whom", "why", "will", "with", "would", "yet",
                    "you", "your"
                ];
                WordCloud.DefaultSettings = {
                    minFontSize: 20,
                    maxFontSize: 100,
                    minAngle: -60,
                    maxAngle: 90,
                    maxNumberOfOrientations: 2,
                    isRotateText: false,
                    isBrokenText: true,
                    isRemoveStopWords: false,
                    stopWordsArray: [],
                    stopWords: undefined,
                    isDefaultStopWords: false,
                    maxNumberOfWords: 200
                };
                WordCloud.RenderDelay = 50;
                WordCloud.DefaultMargin = {
                    top: 10,
                    right: 10,
                    bottom: 10,
                    left: 10
                };
                return WordCloud;
            }());
            samples.WordCloud = WordCloud;
            var explore;
            (function (explore) {
                var util;
                (function (util) {
                    function hexToRgb(hex) {
                        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
                        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                            return r + r + g + g + b + b;
                        });
                        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        return result ? "rgb(" + parseInt(result[1], 16) + "," + parseInt(result[2], 16) + "," + parseInt(result[3], 16) + ")" : null;
                    }
                    util.hexToRgb = hexToRgb;
                    function getRandomColor() {
                        var red = Math.floor(Math.random() * 255), green = Math.floor(Math.random() * 255), blue = Math.floor(Math.random() * 255);
                        return "rgb(" + red + "," + green + "," + blue + ")";
                    }
                    util.getRandomColor = getRandomColor;
                })(util = explore.util || (explore.util = {}));
            })(explore || (explore = {}));
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var PixelConverter = jsCommon.PixelConverter;
            var TableViewFactory;
            (function (TableViewFactory) {
                function createTableView(options) {
                    return new TableView(options);
                }
                TableViewFactory.createTableView = createTableView;
            })(TableViewFactory = samples.TableViewFactory || (samples.TableViewFactory = {}));
            /**
             * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.
             * It can create lists containing either HTML or SVG elements.
             */
            var TableView = (function () {
                function TableView(options) {
                    // make a copy of options so that it is not modified later by caller
                    this.options = $.extend(true, {}, options);
                    this.options.baseContainer
                        .style('overflow-y', 'auto')
                        .attr('drag-resize-disabled', true);
                    this.scrollContainer = options.baseContainer
                        .append('div')
                        .attr('class', 'scrollRegion');
                    this.visibleGroupContainer = this.scrollContainer
                        .append('div')
                        .attr('class', 'visibleGroup');
                    TableView.SetDefaultOptions(options);
                }
                TableView.SetDefaultOptions = function (options) {
                    options.rowHeight = options.rowHeight || TableView.defaultRowHeight;
                };
                TableView.prototype.rowHeight = function (rowHeight) {
                    this.options.rowHeight = Math.ceil(rowHeight);
                    return this;
                };
                TableView.prototype.columnWidth = function (columnWidth) {
                    this.options.columnWidth = Math.ceil(columnWidth);
                    return this;
                };
                TableView.prototype.orientation = function (orientation) {
                    this.options.orientation = orientation;
                    return this;
                };
                TableView.prototype.rows = function (rows) {
                    this.options.rows = Math.ceil(rows);
                    return this;
                };
                TableView.prototype.columns = function (columns) {
                    this.options.columns = Math.ceil(columns);
                    return this;
                };
                TableView.prototype.data = function (data, getDatumIndex, dataReset) {
                    if (dataReset === void 0) { dataReset = false; }
                    this._data = data;
                    this.getDatumIndex = getDatumIndex;
                    this.setTotalRows();
                    if (dataReset) {
                        $(this.options.baseContainer.node()).scrollTop(0);
                    }
                    return this;
                };
                TableView.prototype.viewport = function (viewport) {
                    this.options.viewport = viewport;
                    return this;
                };
                TableView.prototype.empty = function () {
                    this._data = [];
                    this.render();
                };
                TableView.prototype.setTotalRows = function () {
                    var count = this._data.length;
                    var rows = Math.min(this.options.rows, count);
                    var columns = Math.min(this.options.columns, count);
                    if ((columns > 0) && (rows > 0)) {
                        this._totalColumns = columns;
                        this._totalRows = rows;
                    }
                    else if (rows > 0) {
                        this._totalRows = rows;
                        this._totalColumns = Math.ceil(count / rows);
                    }
                    else if (columns > 0) {
                        this._totalColumns = columns;
                        this._totalRows = Math.ceil(count / columns);
                    }
                    else {
                        this._totalColumns = TableView.defaultColumns;
                        this._totalRows = Math.ceil(count / TableView.defaultColumns);
                    }
                };
                TableView.prototype.render = function () {
                    var options = this.options;
                    var visibleGroupContainer = this.visibleGroupContainer;
                    var rowHeight = options.rowHeight || TableView.defaultRowHeight;
                    var groupedData = [];
                    var totalRows = options.rows;
                    var totalColumns = options.columns;
                    var totalItems = this._data.length;
                    var totalRows = options.rows > totalItems ? totalItems : options.rows;
                    var totalColumns = options.columns > totalItems ? totalItems : options.columns;
                    if (totalColumns === 0 && totalRows === 0) {
                        if (options.orientation === Orientation.HORIZONTAL) {
                            totalColumns = totalItems;
                            totalRows = 1;
                        }
                        else {
                            totalColumns = 1;
                            totalRows = totalItems;
                        }
                    }
                    else if (totalColumns === 0 && totalRows > 0)
                        totalColumns = Math.ceil(totalItems / totalRows);
                    else if (totalColumns > 0 && totalRows === 0)
                        totalRows = Math.ceil(totalItems / totalColumns);
                    if (this.options.orientation === Orientation.VERTICAL) {
                        var n = totalRows;
                        totalRows = totalColumns;
                        totalColumns = n;
                    }
                    else if (this.options.orientation === Orientation.HORIZONTAL) {
                        if (totalRows === 0)
                            totalRows = this._totalRows;
                        if (totalColumns === 0)
                            totalColumns = this._totalColumns;
                    }
                    var m = 0;
                    var k = 0;
                    for (var i = 0; i < totalRows; i++) {
                        if (this.options.orientation === Orientation.VERTICAL && options.rows === 0 && totalItems % options.columns > 0 && options.columns <= totalItems) {
                            if (totalItems % options.columns > i) {
                                m = i * Math.ceil(totalItems / options.columns);
                                k = m + Math.ceil(totalItems / options.columns);
                                groupedData.push(this._data.slice(m, k));
                            }
                            else {
                                groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.columns)));
                                k = k + Math.floor(totalItems / options.columns);
                            }
                        }
                        else if (this.options.orientation === Orientation.HORIZONTAL && options.columns === 0 && totalItems % options.rows > 0 && options.rows <= totalItems) {
                            if (totalItems % options.rows > i) {
                                m = i * Math.ceil(totalItems / options.rows);
                                k = m + Math.ceil(totalItems / options.rows);
                                groupedData.push(this._data.slice(m, k));
                            }
                            else {
                                groupedData.push(this._data.slice(k, k + Math.floor(totalItems / options.rows)));
                                k = k + Math.floor(totalItems / options.rows);
                            }
                        }
                        else {
                            var k = i * totalColumns;
                            groupedData.push(this._data.slice(k, k + totalColumns));
                        }
                    }
                    visibleGroupContainer.selectAll(".row").remove();
                    var cellSelection = visibleGroupContainer.selectAll(".row")
                        .data(groupedData)
                        .enter()
                        .append("div")
                        .classed('row', true)
                        .selectAll(".cell")
                        .data(function (d) { return d; });
                    cellSelection
                        .enter()
                        .append('div')
                        .classed('cell', true)
                        .call(function (d) { return options.enter(d); });
                    cellSelection.order();
                    var cellUpdateSelection = visibleGroupContainer.selectAll('.cell:not(.transitioning)');
                    cellUpdateSelection.call(function (d) { return options.update(d); });
                    cellUpdateSelection.style({ 'height': (rowHeight > 0) ? rowHeight + 'px' : 'auto' });
                    if (this.options.orientation === Orientation.VERTICAL) {
                        var realColumnNumber = 0;
                        for (var i = 0; i < groupedData.length; i++) {
                            if (groupedData[i].length !== 0)
                                realColumnNumber = i + 1;
                        }
                        cellUpdateSelection.style({ 'width': '100%' });
                        var rowUpdateSelection = visibleGroupContainer.selectAll('div.row');
                        rowUpdateSelection.style({ 'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / realColumnNumber) + '%' });
                    }
                    else
                        cellUpdateSelection.style({
                            'width': (options.columnWidth > 0) ? options.columnWidth + 'px' : (100 / totalColumns) + '%'
                        });
                    cellSelection
                        .exit()
                        .call(function (d) { return options.exit(d); })
                        .remove();
                };
                TableView.defaultRowHeight = 0;
                TableView.defaultColumns = 1;
                return TableView;
            }());
            // TODO: Generate these from above, defining twice just introduces potential for error
            samples.chicletSlicerProps = {
                general: {
                    orientation: { objectName: 'general', propertyName: 'orientation' },
                    columns: { objectName: 'general', propertyName: 'columns' },
                    rows: { objectName: 'general', propertyName: 'rows' },
                    showDisabled: { objectName: 'general', propertyName: 'showDisabled' },
                    multiselect: { objectName: 'general', propertyName: 'multiselect' },
                    selection: { objectName: 'general', propertyName: 'selection' },
                },
                header: {
                    show: { objectName: 'header', propertyName: 'show' },
                    title: { objectName: 'header', propertyName: 'title' },
                    fontColor: { objectName: 'header', propertyName: 'fontColor' },
                    background: { objectName: 'header', propertyName: 'background' },
                    outline: { objectName: 'header', propertyName: 'outline' },
                    textSize: { objectName: 'header', propertyName: 'textSize' },
                    outlineColor: { objectName: 'header', propertyName: 'outlineColor' },
                    outlineWeight: { objectName: 'header', propertyName: 'outlineWeight' }
                },
                rows: {
                    fontColor: { objectName: 'rows', propertyName: 'fontColor' },
                    textSize: { objectName: 'rows', propertyName: 'textSize' },
                    height: { objectName: 'rows', propertyName: 'height' },
                    width: { objectName: 'rows', propertyName: 'width' },
                    background: { objectName: 'rows', propertyName: 'background' },
                    transparency: { objectName: 'rows', propertyName: 'transparency' },
                    selectedColor: { objectName: 'rows', propertyName: 'selectedColor' },
                    unselectedColor: { objectName: 'rows', propertyName: 'unselectedColor' },
                    disabledColor: { objectName: 'rows', propertyName: 'disabledColor' },
                    outline: { objectName: 'rows', propertyName: 'outline' },
                    outlineColor: { objectName: 'rows', propertyName: 'outlineColor' },
                    outlineWeight: { objectName: 'rows', propertyName: 'outlineWeight' },
                    borderStyle: { objectName: 'rows', propertyName: 'borderStyle' },
                },
                images: {
                    imageSplit: { objectName: 'images', propertyName: 'imageSplit' },
                    stretchImage: { objectName: 'images', propertyName: 'stretchImage' },
                    bottomImage: { objectName: 'images', propertyName: 'bottomImage' },
                },
                selectedPropertyIdentifier: { objectName: 'general', propertyName: 'selected' },
                filterPropertyIdentifier: { objectName: 'general', propertyName: 'filter' },
                formatString: { objectName: 'general', propertyName: 'formatString' },
                hasSavedSelection: true,
            };
            var ChicletBorderStyle;
            (function (ChicletBorderStyle) {
                ChicletBorderStyle.ROUNDED = 'Rounded';
                ChicletBorderStyle.CUT = 'Cut';
                ChicletBorderStyle.SQUARE = 'Square';
                ChicletBorderStyle.type = powerbi.createEnumType([
                    { value: ChicletBorderStyle.ROUNDED, displayName: ChicletBorderStyle.ROUNDED },
                    { value: ChicletBorderStyle.CUT, displayName: ChicletBorderStyle.CUT },
                    { value: ChicletBorderStyle.SQUARE, displayName: ChicletBorderStyle.SQUARE },
                ]);
            })(ChicletBorderStyle || (ChicletBorderStyle = {}));
            var ChicletSlicerShowDisabled;
            (function (ChicletSlicerShowDisabled) {
                ChicletSlicerShowDisabled.INPLACE = 'Inplace';
                ChicletSlicerShowDisabled.BOTTOM = 'Bottom';
                ChicletSlicerShowDisabled.HIDE = 'Hide';
                ChicletSlicerShowDisabled.type = powerbi.createEnumType([
                    { value: ChicletSlicerShowDisabled.INPLACE, displayName: ChicletSlicerShowDisabled.INPLACE },
                    { value: ChicletSlicerShowDisabled.BOTTOM, displayName: ChicletSlicerShowDisabled.BOTTOM },
                    { value: ChicletSlicerShowDisabled.HIDE, displayName: ChicletSlicerShowDisabled.HIDE },
                ]);
            })(ChicletSlicerShowDisabled || (ChicletSlicerShowDisabled = {}));
            var Orientation;
            (function (Orientation) {
                Orientation.HORIZONTAL = 'Horizontal';
                Orientation.VERTICAL = 'Vertical';
                Orientation.type = powerbi.createEnumType([
                    { value: Orientation.HORIZONTAL, displayName: Orientation.HORIZONTAL },
                    { value: Orientation.VERTICAL, displayName: Orientation.VERTICAL }
                ]);
            })(Orientation || (Orientation = {}));
            var ChicletSlicer = (function () {
                function ChicletSlicer(options) {
                    if (options) {
                        if (options.behavior) {
                            this.behavior = options.behavior;
                        }
                    }
                    if (!this.behavior) {
                        this.behavior = new ChicletSlicerWebBehavior();
                    }
                }
                ChicletSlicer.DefaultStyleProperties = function () {
                    return {
                        general: {
                            orientation: Orientation.VERTICAL,
                            columns: 3,
                            rows: 0,
                            multiselect: true,
                            showDisabled: ChicletSlicerShowDisabled.INPLACE,
                            selection: null,
                        },
                        margin: {
                            top: 50,
                            bottom: 50,
                            right: 50,
                            left: 50
                        },
                        header: {
                            borderBottomWidth: 1,
                            show: true,
                            outline: 'BottomOnly',
                            fontColor: '#a6a6a6',
                            background: null,
                            textSize: 10,
                            outlineColor: '#a6a6a6',
                            outlineWeight: 1,
                            title: '',
                        },
                        headerText: {
                            marginLeft: 8,
                            marginTop: 0
                        },
                        slicerText: {
                            textSize: 10,
                            height: 0,
                            width: 0,
                            fontColor: '#666666',
                            hoverColor: '#212121',
                            selectedColor: '#BDD7EE',
                            unselectedColor: '#ffffff',
                            disabledColor: 'grey',
                            marginLeft: 8,
                            outline: 'Frame',
                            background: null,
                            transparency: 0,
                            outlineColor: '#000000',
                            outlineWeight: 1,
                            borderStyle: 'Cut',
                        },
                        slicerItemContainer: {
                            // The margin is assigned in the less file. This is needed for the height calculations.
                            marginTop: 5,
                            marginLeft: 0,
                        },
                        images: {
                            imageSplit: 50,
                            stretchImage: false,
                            bottomImage: false
                        }
                    };
                };
                ChicletSlicer.converter = function (dataView, localizedSelectAllText, interactivityService) {
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[0].values ||
                        !(dataView.categorical.categories[0].values.length > 0)) {
                        return;
                    }
                    var converter = new ChicletSlicerChartConversion.ChicletSlicerConverter(dataView, interactivityService);
                    converter.convert();
                    var slicerData;
                    var defaultSettings = this.DefaultStyleProperties();
                    var objects = dataView.metadata.objects;
                    if (objects) {
                        defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.orientation, defaultSettings.general.orientation);
                        defaultSettings.general.columns = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.columns, defaultSettings.general.columns);
                        defaultSettings.general.rows = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.rows, defaultSettings.general.rows);
                        defaultSettings.general.multiselect = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.multiselect, defaultSettings.general.multiselect);
                        defaultSettings.general.showDisabled = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.general.showDisabled, defaultSettings.general.showDisabled);
                        defaultSettings.general.selection = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.chicletSlicerProps.general.selection, defaultSettings.general.selection);
                        defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.show, defaultSettings.header.show);
                        defaultSettings.header.title = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.title, defaultSettings.header.title);
                        defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.fontColor, defaultSettings.header.fontColor);
                        defaultSettings.header.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.background, defaultSettings.header.background);
                        defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.textSize, defaultSettings.header.textSize);
                        defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outline, defaultSettings.header.outline);
                        defaultSettings.header.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.header.outlineColor, defaultSettings.header.outlineColor);
                        defaultSettings.header.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.header.outlineWeight, defaultSettings.header.outlineWeight);
                        defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.textSize, defaultSettings.slicerText.textSize);
                        defaultSettings.slicerText.height = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.height, defaultSettings.slicerText.height);
                        defaultSettings.slicerText.width = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.width, defaultSettings.slicerText.width);
                        defaultSettings.slicerText.selectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.selectedColor, defaultSettings.slicerText.selectedColor);
                        defaultSettings.slicerText.unselectedColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.unselectedColor, defaultSettings.slicerText.unselectedColor);
                        defaultSettings.slicerText.disabledColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.disabledColor, defaultSettings.slicerText.disabledColor);
                        defaultSettings.slicerText.background = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.background, defaultSettings.slicerText.background);
                        defaultSettings.slicerText.transparency = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.transparency, defaultSettings.slicerText.transparency);
                        defaultSettings.slicerText.fontColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.fontColor, defaultSettings.slicerText.fontColor);
                        defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outline, defaultSettings.slicerText.outline);
                        defaultSettings.slicerText.outlineColor = powerbi.DataViewObjects.getFillColor(objects, samples.chicletSlicerProps.rows.outlineColor, defaultSettings.slicerText.outlineColor);
                        defaultSettings.slicerText.outlineWeight = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.outlineWeight, defaultSettings.slicerText.outlineWeight);
                        defaultSettings.slicerText.borderStyle = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.rows.borderStyle, defaultSettings.slicerText.borderStyle);
                        defaultSettings.images.imageSplit = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.imageSplit, defaultSettings.images.imageSplit);
                        defaultSettings.images.stretchImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.stretchImage, defaultSettings.images.stretchImage);
                        defaultSettings.images.bottomImage = powerbi.DataViewObjects.getValue(objects, samples.chicletSlicerProps.images.bottomImage, defaultSettings.images.bottomImage);
                    }
                    var categories = dataView.categorical.categories[0];
                    slicerData = {
                        categorySourceName: categories.source.displayName,
                        formatString: visuals.valueFormatter.getFormatString(categories.source, samples.chicletSlicerProps.formatString),
                        slicerSettings: defaultSettings,
                        slicerDataPoints: converter.dataPoints,
                    };
                    // Override hasSelection if a objects contained more scopeIds than selections we found in the data
                    slicerData.hasSelectionOverride = converter.hasSelectionOverride;
                    return slicerData;
                };
                ChicletSlicer.prototype.init = function (options) {
                    this.element = options.element;
                    this.currentViewport = options.viewport;
                    if (this.behavior) {
                        this.interactivityService = visuals.createInteractivityService(options.host);
                    }
                    this.hostServices = options.host;
                    this.settings = ChicletSlicer.DefaultStyleProperties();
                    this.initContainer();
                };
                ChicletSlicer.prototype.update = function (options) {
                    if (!options ||
                        !options.dataViews ||
                        !options.dataViews[0] ||
                        !options.viewport) {
                        return;
                    }
                    var existingDataView = this.dataView;
                    this.dataView = options.dataViews[0];
                    var resetScrollbarPosition = true;
                    if (existingDataView) {
                        resetScrollbarPosition = !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
                    }
                    if (options.viewport.height === this.currentViewport.height
                        && options.viewport.width === this.currentViewport.width) {
                        this.waitingForData = false;
                    }
                    else {
                        this.currentViewport = options.viewport;
                    }
                    this.updateInternal(resetScrollbarPosition);
                };
                ChicletSlicer.prototype.onResizing = function (finalViewport) {
                    this.currentViewport = finalViewport;
                    this.updateInternal(false /* resetScrollbarPosition */);
                };
                ChicletSlicer.prototype.enumerateObjectInstances = function (options) {
                    var data = this.slicerData;
                    if (!data) {
                        return;
                    }
                    var objectName = options.objectName;
                    switch (objectName) {
                        case 'rows':
                            return this.enumerateRows(data);
                        case 'header':
                            return this.enumerateHeader(data);
                        case 'general':
                            return this.enumerateGeneral(data);
                        case 'images':
                            return this.enumerateImages(data);
                    }
                };
                ChicletSlicer.prototype.enumerateHeader = function (data) {
                    var slicerSettings = this.settings;
                    return [{
                            selector: null,
                            objectName: 'header',
                            properties: {
                                show: slicerSettings.header.show,
                                title: slicerSettings.header.title,
                                fontColor: slicerSettings.header.fontColor,
                                background: slicerSettings.header.background,
                                textSize: slicerSettings.header.textSize,
                                outline: slicerSettings.header.outline,
                                outlineColor: slicerSettings.header.outlineColor,
                                outlineWeight: slicerSettings.header.outlineWeight
                            }
                        }];
                };
                ChicletSlicer.prototype.enumerateRows = function (data) {
                    var slicerSettings = this.settings;
                    return [{
                            selector: null,
                            objectName: 'rows',
                            properties: {
                                textSize: slicerSettings.slicerText.textSize,
                                height: slicerSettings.slicerText.height,
                                width: slicerSettings.slicerText.width,
                                background: slicerSettings.slicerText.background,
                                transparency: slicerSettings.slicerText.transparency,
                                selectedColor: slicerSettings.slicerText.selectedColor,
                                unselectedColor: slicerSettings.slicerText.unselectedColor,
                                disabledColor: slicerSettings.slicerText.disabledColor,
                                outline: slicerSettings.slicerText.outline,
                                outlineColor: slicerSettings.slicerText.outlineColor,
                                outlineWeight: slicerSettings.slicerText.outlineWeight,
                                fontColor: slicerSettings.slicerText.fontColor,
                                borderStyle: slicerSettings.slicerText.borderStyle,
                            }
                        }];
                };
                ChicletSlicer.prototype.enumerateGeneral = function (data) {
                    var slicerSettings = this.settings;
                    return [{
                            selector: null,
                            objectName: 'general',
                            properties: {
                                orientation: slicerSettings.general.orientation,
                                columns: slicerSettings.general.columns,
                                rows: slicerSettings.general.rows,
                                showDisabled: slicerSettings.general.showDisabled,
                                multiselect: slicerSettings.general.multiselect,
                            }
                        }];
                };
                ChicletSlicer.prototype.enumerateImages = function (data) {
                    var slicerSettings = this.settings;
                    return [{
                            selector: null,
                            objectName: 'images',
                            properties: {
                                imageSplit: slicerSettings.images.imageSplit,
                                stretchImage: slicerSettings.images.stretchImage,
                                bottomImage: slicerSettings.images.bottomImage,
                            }
                        }];
                };
                ChicletSlicer.prototype.updateInternal = function (resetScrollbarPosition) {
                    var _this = this;
                    this.updateSlicerBodyDimensions();
                    var localizedSelectAllText = 'Select All';
                    var data = ChicletSlicer.converter(this.dataView, localizedSelectAllText, this.interactivityService);
                    if (!data) {
                        this.tableView.empty();
                        return;
                    }
                    if (this.interactivityService) {
                        this.interactivityService.applySelectionStateToData(data.slicerDataPoints);
                    }
                    data.slicerSettings.header.outlineWeight = data.slicerSettings.header.outlineWeight < 0 ? 0 : data.slicerSettings.header.outlineWeight;
                    data.slicerSettings.slicerText.outlineWeight = data.slicerSettings.slicerText.outlineWeight < 0 ? 0 : data.slicerSettings.slicerText.outlineWeight;
                    data.slicerSettings.general.getSavedSelection = function () {
                        try {
                            return JSON.parse(_this.slicerData.slicerSettings.general.selection) || [];
                        }
                        catch (ex) {
                            return [];
                        }
                    };
                    data.slicerSettings.general.setSavedSelection = function (selectionIds) {
                        _this.isSelectionSaved = true;
                        _this.hostServices.persistProperties({
                            merge: [{
                                    objectName: "general",
                                    selector: null,
                                    properties: { selection: selectionIds && JSON.stringify(selectionIds) || "" }
                                }] });
                    };
                    if (this.slicerData) {
                        if (this.isSelectionSaved) {
                            this.isSelectionLoaded = true;
                        }
                        else {
                            this.isSelectionLoaded = this.slicerData.slicerSettings.general.selection === data.slicerSettings.general.selection;
                        }
                    }
                    else {
                        this.isSelectionLoaded = false;
                    }
                    this.slicerData = data;
                    this.settings = this.slicerData.slicerSettings;
                    if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.BOTTOM) {
                        data.slicerDataPoints.sort(function (a, b) {
                            if (a.selectable === b.selectable) {
                                return 0;
                            }
                            else if (a.selectable && !b.selectable) {
                                return -1;
                            }
                            else {
                                return 1;
                            }
                        });
                    }
                    else if (this.settings.general.showDisabled === ChicletSlicerShowDisabled.HIDE) {
                        data.slicerDataPoints = data.slicerDataPoints.filter(function (x) { return x.selectable; });
                    }
                    var height = this.settings.slicerText.height;
                    if (height === 0) {
                        var extraSpaceForCell = ChicletSlicer.cellTotalInnerPaddings + ChicletSlicer.cellTotalInnerBorders;
                        var textProperties = ChicletSlicer.getChicletTextProperties(this.settings.slicerText.textSize);
                        height = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) + powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties) + extraSpaceForCell;
                        var hasImage = _.any(data.slicerDataPoints, function (x) { return x.imageURL !== '' && typeof x.imageURL !== "undefined"; });
                        if (hasImage)
                            height += 100;
                    }
                    this.tableView
                        .rowHeight(height)
                        .columnWidth(this.settings.slicerText.width)
                        .orientation(this.settings.general.orientation)
                        .rows(this.settings.general.rows)
                        .columns(this.settings.general.columns)
                        .data(data.slicerDataPoints, function (d) { return $.inArray(d, data.slicerDataPoints); }, resetScrollbarPosition)
                        .viewport(this.getSlicerBodyViewport(this.currentViewport))
                        .render();
                    // if(!selectedItems.length  &&  String(savedSelection).length && this.slicerData && this.slicerData.hasSelectionOverride){
                    //     var arrSelection = String(savedSelection).split('&');
                    //     var arrSelected = jQuery.map(data.slicerDataPoints, function (d, index) { 
                    //         if (arrSelection.indexOf(d.category) > -1) return d; 
                    //     });
                    //     data.slicerDataPoints.forEach(function (d, index) { 
                    //         if (arrSelection.indexOf(d.category) > -1){
                    //             d.selected = true;
                    //             // console.error('>>>>@@@', d, index);
                    //         }
                    //     });
                    //     if(!arrSelection.length){
                    //         this.slicerData.hasSelectionOverride = false
                    //     }
                    //     // console.error('>>> 2', 'RESTORE',   savedSelection,     arrSelected,     data.slicerDataPoints )
                    // }
                };
                ChicletSlicer.prototype.initContainer = function () {
                    var _this = this;
                    var settings = this.settings;
                    var slicerBodyViewport = this.getSlicerBodyViewport(this.currentViewport);
                    var slicerContainer = d3.select(this.element.get(0))
                        .append('div')
                        .classed(ChicletSlicer.Container.class, true);
                    this.slicerHeader = slicerContainer
                        .append('div')
                        .classed(ChicletSlicer.Header.class, true);
                    this.slicerHeader
                        .append('span')
                        .classed(ChicletSlicer.Clear.class, true)
                        .attr('title', 'Clear');
                    this.slicerHeader
                        .append('div')
                        .classed(ChicletSlicer.HeaderText.class, true)
                        .style({
                        'margin-left': PixelConverter.toString(settings.headerText.marginLeft),
                        'margin-top': PixelConverter.toString(settings.headerText.marginTop),
                        'border-style': this.getBorderStyle(settings.header.outline),
                        'border-color': settings.header.outlineColor,
                        'border-width': this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                        'font-size': PixelConverter.fromPoint(settings.header.textSize),
                    });
                    this.slicerBody = slicerContainer
                        .append('div').classed(ChicletSlicer.Body.class, true)
                        .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)
                        .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL)
                        .style({
                        'height': PixelConverter.toString(slicerBodyViewport.height),
                        'width': '100%',
                    });
                    var rowEnter = function (rowSelection) {
                        var settings = _this.settings;
                        var listItemElement = rowSelection.append('li')
                            .classed(ChicletSlicer.ItemContainer.class, true)
                            .style({
                            'margin-left': PixelConverter.toString(settings.slicerItemContainer.marginLeft),
                        });
                        listItemElement.append('div')
                            .classed('slicer-img-wrapper', true);
                        listItemElement.append('div')
                            .classed('slicer-text-wrapper', true)
                            .append('span')
                            .classed(ChicletSlicer.LabelText.class, true)
                            .style({
                            'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),
                        });
                    };
                    var rowUpdate = function (rowSelection) {
                        var settings = _this.settings;
                        var data = _this.slicerData;
                        if (data && settings) {
                            _this.slicerHeader.classed('hidden', !settings.header.show);
                            _this.slicerHeader.select(ChicletSlicer.HeaderText.selector)
                                .text(settings.header.title.trim() !== "" ? settings.header.title.trim() : _this.slicerData.categorySourceName)
                                .style({
                                'border-style': _this.getBorderStyle(settings.header.outline),
                                'border-color': settings.header.outlineColor,
                                'border-width': _this.getBorderWidth(settings.header.outline, settings.header.outlineWeight),
                                'color': settings.header.fontColor,
                                'background-color': settings.header.background,
                                'font-size': PixelConverter.fromPoint(settings.header.textSize),
                            });
                            _this.slicerBody
                                .classed('slicerBody-horizontal', settings.general.orientation === Orientation.HORIZONTAL)
                                .classed('slicerBody-vertical', settings.general.orientation === Orientation.VERTICAL);
                            var slicerText = rowSelection.selectAll(ChicletSlicer.LabelText.selector);
                            var textProperties = ChicletSlicer.getChicletTextProperties(settings.slicerText.textSize);
                            var formatString = data.formatString;
                            slicerText.text(function (d) {
                                var text = visuals.valueFormatter.format(d.category, formatString);
                                textProperties.text = text;
                                if (_this.settings.slicerText.width === 0)
                                    return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, (_this.currentViewport.width / _this.settings.general.columns) - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);
                                else
                                    return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, _this.settings.slicerText.width - ChicletSlicer.chicletTotalInnerRightLeftPaddings - ChicletSlicer.cellTotalInnerBorders - settings.slicerText.outlineWeight);
                            });
                            var slicerImg = rowSelection.selectAll('.slicer-img-wrapper');
                            slicerImg
                                .style('height', settings.images.imageSplit + '%')
                                .classed('hidden', function (d) {
                                if (!(d.imageURL)) {
                                    return true;
                                }
                                if (settings.images.imageSplit < 10) {
                                    return true;
                                }
                            })
                                .style('display', function (d) { return (d.imageURL) ? 'flex' : 'none'; })
                                .classed('stretchImage', settings.images.stretchImage)
                                .classed('bottomImage', settings.images.bottomImage)
                                .style('background-image', function (d) {
                                return d.imageURL ? "url(" + d.imageURL + ")" : '';
                            });
                            rowSelection.selectAll('.slicer-text-wrapper')
                                .style('height', function (d) {
                                return d.imageURL ? (100 - settings.images.imageSplit) + '%' : '100%';
                            })
                                .classed('hidden', function (d) {
                                if (settings.images.imageSplit > 90) {
                                    return true;
                                }
                            });
                            rowSelection.selectAll('.slicerItemContainer').style({
                                'color': settings.slicerText.fontColor,
                                'border-style': _this.getBorderStyle(settings.slicerText.outline),
                                'border-color': settings.slicerText.outlineColor,
                                'border-width': _this.getBorderWidth(settings.slicerText.outline, settings.slicerText.outlineWeight),
                                'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),
                                'border-radius': _this.getBorderRadius(settings.slicerText.borderStyle),
                            });
                            if (settings.slicerText.background)
                                _this.slicerBody.style('background-color', explore.util.hexToRGBString(settings.slicerText.background, (100 - settings.slicerText.transparency) / 100));
                            else
                                _this.slicerBody.style('background-color', null);
                            if (_this.interactivityService && _this.slicerBody) {
                                var slicerBody = _this.slicerBody.attr('width', _this.currentViewport.width);
                                var slicerItemContainers = slicerBody.selectAll(ChicletSlicer.ItemContainer.selector);
                                var slicerItemLabels = slicerBody.selectAll(ChicletSlicer.LabelText.selector);
                                var slicerItemInputs = slicerBody.selectAll(ChicletSlicer.Input.selector);
                                var slicerClear = _this.slicerHeader.select(ChicletSlicer.Clear.selector);
                                var behaviorOptions = {
                                    dataPoints: data.slicerDataPoints,
                                    slicerItemContainers: slicerItemContainers,
                                    slicerItemLabels: slicerItemLabels,
                                    slicerItemInputs: slicerItemInputs,
                                    slicerClear: slicerClear,
                                    interactivityService: _this.interactivityService,
                                    slicerSettings: data.slicerSettings,
                                    isSelectionLoaded: _this.isSelectionLoaded
                                };
                                _this.interactivityService.bind(data.slicerDataPoints, _this.behavior, behaviorOptions, {
                                    overrideSelectionFromData: true,
                                    hasSelectionOverride: data.hasSelectionOverride,
                                });
                                _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), _this.interactivityService.hasSelection());
                            }
                            else {
                                _this.behavior.styleSlicerInputs(rowSelection.select(ChicletSlicer.ItemContainer.selector), false);
                            }
                        }
                    };
                    var rowExit = function (rowSelection) {
                        rowSelection.remove();
                    };
                    var tableViewOptions = {
                        rowHeight: this.getRowHeight(),
                        columnWidth: this.settings.slicerText.width,
                        orientation: this.settings.general.orientation,
                        rows: this.settings.general.rows,
                        columns: this.settings.general.columns,
                        enter: rowEnter,
                        exit: rowExit,
                        update: rowUpdate,
                        loadMoreData: function () { return _this.onLoadMoreData(); },
                        scrollEnabled: true,
                        viewport: this.getSlicerBodyViewport(this.currentViewport),
                        baseContainer: this.slicerBody,
                    };
                    this.tableView = TableViewFactory.createTableView(tableViewOptions);
                };
                ChicletSlicer.prototype.onLoadMoreData = function () {
                    if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
                        this.hostServices.loadMoreData();
                        this.waitingForData = true;
                    }
                };
                ChicletSlicer.prototype.getSlicerBodyViewport = function (currentViewport) {
                    var settings = this.settings;
                    var headerHeight = (settings.header.show) ? this.getHeaderHeight() : 0;
                    var slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);
                    return {
                        height: slicerBodyHeight,
                        width: currentViewport.width
                    };
                };
                ChicletSlicer.prototype.updateSlicerBodyDimensions = function () {
                    var slicerViewport = this.getSlicerBodyViewport(this.currentViewport);
                    this.slicerBody
                        .style({
                        'height': PixelConverter.toString(slicerViewport.height),
                        'width': '100%',
                    });
                };
                ChicletSlicer.getChicletTextProperties = function (textSize) {
                    return {
                        fontFamily: ChicletSlicer.DefaultFontFamily,
                        fontSize: PixelConverter.fromPoint(textSize || ChicletSlicer.DefaultFontSizeInPt),
                    };
                };
                ChicletSlicer.prototype.getHeaderHeight = function () {
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(this.settings.header.textSize));
                };
                ChicletSlicer.prototype.getRowHeight = function () {
                    var textSettings = this.settings.slicerText;
                    return textSettings.height !== 0
                        ? textSettings.height
                        : powerbi.TextMeasurementService.estimateSvgTextHeight(ChicletSlicer.getChicletTextProperties(textSettings.textSize));
                };
                ChicletSlicer.prototype.getBorderStyle = function (outlineElement) {
                    return outlineElement === '0px' ? 'none' : 'solid';
                };
                ChicletSlicer.prototype.getBorderWidth = function (outlineElement, outlineWeight) {
                    switch (outlineElement) {
                        case 'None':
                            return '0px';
                        case 'BottomOnly':
                            return '0px 0px ' + outlineWeight + 'px 0px';
                        case 'TopOnly':
                            return outlineWeight + 'px 0px 0px 0px';
                        case 'TopBottom':
                            return outlineWeight + 'px 0px ' + outlineWeight + 'px 0px';
                        case 'LeftRight':
                            return '0px ' + outlineWeight + 'px 0px ' + outlineWeight + 'px';
                        case 'Frame':
                            return outlineWeight + 'px';
                        default:
                            return outlineElement.replace("1", outlineWeight.toString());
                    }
                };
                ChicletSlicer.prototype.getBorderRadius = function (borderType) {
                    switch (borderType) {
                        case ChicletBorderStyle.ROUNDED:
                            return "10px";
                        case ChicletBorderStyle.SQUARE:
                            return "0px";
                        default:
                            return "5px";
                    }
                };
                ChicletSlicer.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Field'),
                        },
                        {
                            name: 'Values',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                        },
                        {
                            name: 'Image',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Image',
                        },
                    ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                selection: {
                                    displayName: "Selection",
                                    type: { text: true }
                                },
                                orientation: {
                                    displayName: 'Orientation',
                                    type: { enumeration: Orientation.type }
                                },
                                columns: {
                                    displayName: 'Columns',
                                    type: { numeric: true }
                                },
                                rows: {
                                    displayName: 'Rows',
                                    type: { numeric: true }
                                },
                                showDisabled: {
                                    displayName: 'Show Disabled',
                                    type: { enumeration: ChicletSlicerShowDisabled.type }
                                },
                                multiselect: {
                                    displayName: 'Multiple selection',
                                    type: { bool: true }
                                },
                                selected: {
                                    type: { bool: true }
                                },
                                filter: {
                                    type: { filter: {} },
                                    rule: {
                                        output: {
                                            property: 'selected',
                                            selector: ['Category'],
                                        }
                                    }
                                },
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        header: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Header'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                title: {
                                    displayName: 'Title',
                                    type: { text: true }
                                },
                                fontColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_FontColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                background: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                outline: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                                    type: { formatting: { outline: true } }
                                },
                                textSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { numeric: true }
                                },
                                outlineColor: {
                                    displayName: 'Outline Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                outlineWeight: {
                                    displayName: 'Outline Weight',
                                    type: { numeric: true }
                                }
                            }
                        },
                        rows: {
                            displayName: 'Chiclets',
                            properties: {
                                fontColor: {
                                    displayName: 'Text color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                textSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { numeric: true }
                                },
                                height: {
                                    displayName: 'Height',
                                    type: { numeric: true }
                                },
                                width: {
                                    displayName: 'Width',
                                    type: { numeric: true }
                                },
                                selectedColor: {
                                    displayName: 'Selected Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                unselectedColor: {
                                    displayName: 'Unselected Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                disabledColor: {
                                    displayName: 'Disabled Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                background: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                transparency: {
                                    displayName: "Transparency",
                                    description: "Set transparency for background color",
                                    type: { numeric: true }
                                },
                                outline: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                                    type: { formatting: { outline: true } }
                                },
                                outlineColor: {
                                    displayName: 'Outline Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                outlineWeight: {
                                    displayName: 'Outline Weight',
                                    type: { numeric: true }
                                },
                                borderStyle: {
                                    displayName: 'Outline Style',
                                    type: { enumeration: ChicletBorderStyle.type }
                                },
                            }
                        },
                        images: {
                            displayName: 'Images',
                            properties: {
                                imageSplit: {
                                    displayName: 'Image Split',
                                    type: { numeric: true }
                                },
                                stretchImage: {
                                    displayName: 'Stretch image',
                                    type: { bool: true }
                                },
                                bottomImage: {
                                    displayName: 'Bottom image',
                                    type: { bool: true }
                                },
                            }
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Image': { min: 0, max: 1 }, 'Values': { min: 0, max: 1 } }],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Image',
                                        select: [{ bind: { to: 'Values' } },
                                        ],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                },
                                includeEmptyGroups: true
                            }
                        }],
                    supportsHighlight: true,
                    sorting: {
                        default: {},
                    },
                    suppressDefaultTitle: true,
                };
                ChicletSlicer.DefaultFontFamily = 'Segoe UI, Tahoma, Verdana, Geneva, sans-serif';
                ChicletSlicer.DefaultFontSizeInPt = 11;
                ChicletSlicer.cellTotalInnerPaddings = 8;
                ChicletSlicer.cellTotalInnerBorders = 2;
                ChicletSlicer.chicletTotalInnerRightLeftPaddings = 14;
                ChicletSlicer.ItemContainer = createClassAndSelector('slicerItemContainer');
                ChicletSlicer.HeaderText = createClassAndSelector('headerText');
                ChicletSlicer.Container = createClassAndSelector('chicletSlicer');
                ChicletSlicer.LabelText = createClassAndSelector('slicerText');
                ChicletSlicer.Header = createClassAndSelector('slicerHeader');
                ChicletSlicer.Input = createClassAndSelector('slicerCheckbox');
                ChicletSlicer.Clear = createClassAndSelector('clear');
                ChicletSlicer.Body = createClassAndSelector('slicerBody');
                return ChicletSlicer;
            }());
            samples.ChicletSlicer = ChicletSlicer;
            var ChicletSlicerChartConversion;
            (function (ChicletSlicerChartConversion) {
                var ChicletSlicerConverter = (function () {
                    function ChicletSlicerConverter(dataView, interactivityService) {
                        var dataViewCategorical = dataView.categorical;
                        this.dataViewCategorical = dataViewCategorical;
                        this.dataViewMetadata = dataView.metadata;
                        if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                            this.category = dataViewCategorical.categories[0];
                            this.categoryIdentities = this.category.identity;
                            this.categoryValues = this.category.values;
                            this.categoryColumnRef = this.category.identityFields;
                            this.categoryFormatString = visuals.valueFormatter.getFormatString(this.category.source, samples.chicletSlicerProps.formatString);
                        }
                        this.dataPoints = [];
                        this.interactivityService = interactivityService;
                        this.hasSelectionOverride = false;
                    }
                    ChicletSlicerConverter.prototype.convert = function () {
                        this.dataPoints = [];
                        this.numberOfCategoriesSelectedInData = 0;
                        // If category exists, we render labels using category values. If not, we render labels
                        // using measure labels.
                        if (this.categoryValues) {
                            var objects = this.dataViewMetadata ? this.dataViewMetadata.objects : undefined;
                            var isInvertedSelectionMode = undefined;
                            var numberOfScopeIds;
                            if (objects && objects.general && objects.general.filter) {
                                if (!this.categoryColumnRef)
                                    return;
                                var filter = objects.general.filter;
                                var scopeIds = powerbi.data.SQExprConverter.asScopeIdsContainer(filter, this.categoryColumnRef);
                                if (scopeIds) {
                                    isInvertedSelectionMode = scopeIds.isNot;
                                    numberOfScopeIds = scopeIds.scopeIds ? scopeIds.scopeIds.length : 0;
                                }
                                else {
                                    isInvertedSelectionMode = false;
                                }
                            }
                            if (this.interactivityService) {
                                if (isInvertedSelectionMode === undefined) {
                                    // The selection state is read from the Interactivity service in case of SelectAll or Clear when query doesn't update the visual
                                    isInvertedSelectionMode = this.interactivityService.isSelectionModeInverted();
                                }
                                else {
                                    this.interactivityService.setSelectionModeInverted(isInvertedSelectionMode);
                                }
                            }
                            var hasSelection = undefined;
                            for (var idx = 0; idx < this.categoryValues.length; idx++) {
                                var selected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, idx);
                                if (selected != null) {
                                    hasSelection = selected;
                                    break;
                                }
                            }
                            var dataViewCategorical = this.dataViewCategorical;
                            var formatStringProp = samples.chicletSlicerProps.formatString;
                            var value = -Infinity;
                            var imageURL = '';
                            for (var categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {
                                var categoryIdentity = this.category.identity ? this.category.identity[categoryIndex] : null;
                                var categoryIsSelected = visuals.isCategoryColumnSelected(samples.chicletSlicerProps.selectedPropertyIdentifier, this.category, categoryIndex);
                                var selectable = true;
                                if (hasSelection != null) {
                                    if (isInvertedSelectionMode) {
                                        if (this.category.objects == null)
                                            categoryIsSelected = undefined;
                                        if (categoryIsSelected != null) {
                                            categoryIsSelected = hasSelection;
                                        }
                                        else if (categoryIsSelected == null)
                                            categoryIsSelected = !hasSelection;
                                    }
                                    else {
                                        if (categoryIsSelected == null) {
                                            categoryIsSelected = !hasSelection;
                                        }
                                    }
                                }
                                if (categoryIsSelected) {
                                    this.numberOfCategoriesSelectedInData++;
                                }
                                var categoryValue = this.categoryValues[categoryIndex];
                                var categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
                                if (this.dataViewCategorical.values) {
                                    // Series are either measures in the multi-measure case, or the single series otherwise
                                    for (var seriesIndex = 0; seriesIndex < this.dataViewCategorical.values.length; seriesIndex++) {
                                        var seriesData = dataViewCategorical.values[seriesIndex];
                                        if (seriesData.values[categoryIndex] != null) {
                                            value = seriesData.values[categoryIndex];
                                            if (seriesData.highlights) {
                                                selectable = !(seriesData.highlights[categoryIndex] === null);
                                            }
                                            if (seriesData.source.groupName && seriesData.source.groupName !== '') {
                                                imageURL = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                                                if (!/^(ftp|http|https):\/\/[^ "]+$/.test(imageURL)) {
                                                    imageURL = undefined;
                                                }
                                            }
                                        }
                                    }
                                }
                                this.dataPoints.push({
                                    identity: visuals.SelectionId.createWithId(categoryIdentity),
                                    category: categoryLabel,
                                    imageURL: imageURL,
                                    value: value,
                                    selected: categoryIsSelected,
                                    selectable: selectable
                                });
                            }
                            if (numberOfScopeIds != null && numberOfScopeIds > this.numberOfCategoriesSelectedInData) {
                                this.hasSelectionOverride = true;
                            }
                        }
                    };
                    return ChicletSlicerConverter;
                }());
                ChicletSlicerChartConversion.ChicletSlicerConverter = ChicletSlicerConverter;
            })(ChicletSlicerChartConversion || (ChicletSlicerChartConversion = {}));
            //TODO: This module should be removed once TextMeasruementService exports the "estimateSvgTextBaselineDelta" function.
            var ChicletSlicerTextMeasurementHelper;
            (function (ChicletSlicerTextMeasurementHelper) {
                var spanElement;
                var svgTextElement;
                var canvasCtx;
                function estimateSvgTextBaselineDelta(textProperties) {
                    var rect = estimateSvgTextRect(textProperties);
                    return rect.y + rect.height;
                }
                ChicletSlicerTextMeasurementHelper.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
                function ensureDOM() {
                    if (spanElement)
                        return;
                    spanElement = $('<span/>');
                    $('body').append(spanElement);
                    //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.
                    svgTextElement = d3.select($('body').get(0))
                        .append('svg')
                        .style({
                        'height': '0px',
                        'width': '0px',
                        'position': 'absolute'
                    })
                        .append('text');
                    canvasCtx = $('<canvas/>').get(0).getContext("2d");
                }
                function measureSvgTextRect(textProperties) {
                    debug.assertValue(textProperties, 'textProperties');
                    ensureDOM();
                    svgTextElement.style(null);
                    svgTextElement
                        .text(textProperties.text)
                        .attr({
                        'visibility': 'hidden',
                        'font-family': textProperties.fontFamily,
                        'font-size': textProperties.fontSize,
                        'font-weight': textProperties.fontWeight,
                        'font-style': textProperties.fontStyle,
                        'white-space': textProperties.whiteSpace || 'nowrap'
                    });
                    // We're expecting the browser to give a synchronous measurement here
                    // We're using SVGTextElement because it works across all browsers 
                    return svgTextElement.node().getBBox();
                }
                function estimateSvgTextRect(textProperties) {
                    debug.assertValue(textProperties, 'textProperties');
                    var estimatedTextProperties = {
                        fontFamily: textProperties.fontFamily,
                        fontSize: textProperties.fontSize,
                        text: "M",
                    };
                    var rect = measureSvgTextRect(estimatedTextProperties);
                    return rect;
                }
            })(ChicletSlicerTextMeasurementHelper = samples.ChicletSlicerTextMeasurementHelper || (samples.ChicletSlicerTextMeasurementHelper = {}));
            var ChicletSlicerWebBehavior = (function () {
                function ChicletSlicerWebBehavior() {
                }
                ChicletSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    var _this = this;
                    var filterPropertyId = samples.chicletSlicerProps.filterPropertyIdentifier;
                    var slicers = this.slicers = options.slicerItemContainers;
                    this.slicerItemLabels = options.slicerItemLabels;
                    this.slicerItemInputs = options.slicerItemInputs;
                    var slicerClear = options.slicerClear;
                    this.dataPoints = options.dataPoints;
                    this.interactivityService = options.interactivityService;
                    this.slicerSettings = options.slicerSettings;
                    this.options = options;
                    if (!this.options.isSelectionLoaded) {
                        this.loadSelection(selectionHandler);
                    }
                    slicers.on("mouseover", function (d) {
                        if (d.selectable) {
                            d.mouseOver = true;
                            d.mouseOut = false;
                            _this.renderMouseover();
                        }
                    });
                    slicers.on("mouseout", function (d) {
                        if (d.selectable) {
                            d.mouseOver = false;
                            d.mouseOut = true;
                            _this.renderMouseover();
                        }
                    });
                    slicers.on("click", function (d, index) {
                        if (!d.selectable) {
                            return;
                        }
                        var settings = _this.slicerSettings;
                        d3.event.preventDefault();
                        if (d3.event.altKey && settings.general.multiselect) {
                            var selectedIndexes = jQuery.map(_this.dataPoints, function (d, index) { if (d.selected)
                                return index; });
                            var selIndex = selectedIndexes.length > 0 ? (selectedIndexes[selectedIndexes.length - 1]) : 0;
                            if (selIndex > index) {
                                var temp = index;
                                index = selIndex;
                                selIndex = temp;
                            }
                            selectionHandler.handleClearSelection();
                            for (var i = selIndex; i <= index; i++) {
                                selectionHandler.handleSelection(_this.dataPoints[i], true /* isMultiSelect */);
                            }
                        }
                        else if (d3.event.ctrlKey && settings.general.multiselect) {
                            selectionHandler.handleSelection(d, true /* isMultiSelect */);
                        }
                        else {
                            selectionHandler.handleSelection(d, false /* isMultiSelect */);
                        }
                        selectionHandler.persistSelectionFilter(filterPropertyId);
                        _this.saveSelection(selectionHandler);
                    });
                    slicerClear.on("click", function (d) {
                        selectionHandler.handleClearSelection();
                        selectionHandler.persistSelectionFilter(filterPropertyId);
                        _this.saveSelection(selectionHandler);
                    });
                };
                ChicletSlicerWebBehavior.prototype.loadSelection = function (selectionHandler) {
                    selectionHandler.handleClearSelection();
                    var savedSelectionIds = this.slicerSettings.general.getSavedSelection();
                    if (savedSelectionIds.length) {
                        var selectedDataPoints = this.dataPoints.filter(function (d) { return savedSelectionIds.some(function (x) { return d.identity.getKey() === x; }); });
                        selectedDataPoints.forEach(function (x) { return selectionHandler.handleSelection(x, true); });
                        selectionHandler.persistSelectionFilter(samples.chicletSlicerProps.filterPropertyIdentifier);
                    }
                };
                ChicletSlicerWebBehavior.prototype.saveSelection = function (selectionHandler) {
                    var selectionIdKeys = selectionHandler.selectedIds.map(function (x) { return x.getKey(); });
                    this.slicerSettings.general.setSavedSelection(selectionIdKeys);
                };
                ChicletSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
                    if (!hasSelection && !this.interactivityService.isSelectionModeInverted()) {
                        this.slicers.style('background', this.slicerSettings.slicerText.unselectedColor);
                    }
                    else {
                        this.styleSlicerInputs(this.slicers, hasSelection);
                    }
                };
                ChicletSlicerWebBehavior.prototype.renderMouseover = function () {
                    var _this = this;
                    this.slicerItemLabels.style({
                        'color': function (d) {
                            if (d.mouseOver)
                                return _this.slicerSettings.slicerText.hoverColor;
                            if (d.mouseOut) {
                                if (d.selected)
                                    return _this.slicerSettings.slicerText.fontColor;
                                else
                                    return _this.slicerSettings.slicerText.fontColor;
                            }
                        }
                    });
                };
                ChicletSlicerWebBehavior.prototype.styleSlicerInputs = function (slicers, hasSelection) {
                    var settings = this.slicerSettings;
                    var selectedItems = [];
                    slicers.each(function (d) {
                        // get selected items
                        if (d.selectable && d.selected) {
                            selectedItems.push(d);
                        }
                        d3.select(this).style({
                            'background': d.selectable ? (d.selected ? settings.slicerText.selectedColor : settings.slicerText.unselectedColor)
                                : settings.slicerText.disabledColor
                        });
                        d3.select(this).classed('slicerItem-disabled', !d.selectable);
                    });
                };
                return ChicletSlicerWebBehavior;
            }());
            samples.ChicletSlicerWebBehavior = ChicletSlicerWebBehavior;
            var explore;
            (function (explore) {
                var util;
                (function (util) {
                    function hexToRGBString(hex, transparency) {
                        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
                        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
                            return r + r + g + g + b + b;
                        });
                        // Hex format which return the format r-g-b
                        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                        var rgb = result ? {
                            r: parseInt(result[1], 16),
                            g: parseInt(result[2], 16),
                            b: parseInt(result[3], 16)
                        } : null;
                        // Wrong input
                        if (rgb === null) {
                            return '';
                        }
                        if (!transparency && transparency !== 0) {
                            return "rgb(" + rgb.r + "," + rgb.g + "," + rgb.b + ")";
                        }
                        else {
                            return "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + transparency + ")";
                        }
                    }
                    util.hexToRGBString = hexToRGBString;
                })(util = explore.util || (explore.util = {}));
            })(explore || (explore = {}));
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ChordChart = (function () {
                function ChordChart() {
                }
                /* Convert a DataView into a view model */
                ChordChart.converter = function (dataView, colors, prevAxisVisible) {
                    var catDv = dataView.categorical;
                    var defaultDataPointColor = ChordChart.getDefaultDataPointColor(dataView).solid.color;
                    var labelColor = ChordChart.getLabelsColor(dataView);
                    var labelFontSize = ChordChart.getLabelsFontSize(dataView);
                    if (catDv && catDv.categories && catDv.categories.length > 0 && catDv.values && catDv.categories[0].values && catDv.categories[0].values[0]) {
                        var cat = catDv.categories[0];
                        var catValues = cat.values;
                        var values = catDv.values;
                        var dataMatrix = [];
                        var legendData = {
                            dataPoints: [],
                            title: values[0] && values[0].source ? values[0].source.displayName : "",
                        };
                        var toolTipData = [];
                        var sliceTooltipData = [];
                        var max = 1000;
                        var seriesName = []; /* series name array */
                        var seriesIndex = []; /* series index array */
                        var catIndex = []; /* index array for category names */
                        var isDiffFromTo = false; /* boolean variable indicates that From and To are different */
                        var labelData = []; /* label data: !important */
                        var colorHelper = new visuals.ColorHelper(colors, ChordChart.chordChartProps.dataPoint.fill, defaultDataPointColor);
                        for (var i = 0, iLen = catValues.length; i < iLen; i++) {
                            catIndex[catValues[i]] = i;
                        }
                        for (var i = 0, iLen = values.length; i < iLen; i++) {
                            var seriesNameStr = visuals.converterHelper.getSeriesName(values[i].source);
                            seriesName.push(seriesNameStr);
                            seriesIndex[seriesNameStr] = i;
                        }
                        var totalFields = this.union_arrays(catValues, seriesName);
                        if (ChordChart.getValidArrayLength(totalFields) ===
                            ChordChart.getValidArrayLength(catValues) + ChordChart.getValidArrayLength(seriesName)) {
                            isDiffFromTo = true;
                        }
                        var formatStringProp = ChordChart.chordChartProps.general.formatString;
                        var categorySourceFormatString = visuals.valueFormatter.getFormatString(cat.source, formatStringProp);
                        for (var i = 0, iLen = totalFields.length; i < iLen; i++) {
                            var id = null;
                            var color = '';
                            var isCategory = false;
                            if (catIndex[totalFields[i]] !== undefined) {
                                var index = catIndex[totalFields[i]];
                                id = visuals.SelectionIdBuilder
                                    .builder()
                                    .withCategory(cat, catIndex[totalFields[i]])
                                    .createSelectionId();
                                isCategory = true;
                                var thisCategoryObjects = cat.objects ? cat.objects[index] : undefined;
                                color = colorHelper.getColorForSeriesValue(thisCategoryObjects, /* cat.identityFields */ undefined, catValues[index]);
                            }
                            else if (seriesIndex[totalFields[i]] !== undefined) {
                                var index = seriesIndex[totalFields[i]];
                                var seriesData = values[index];
                                var seriesObjects = seriesData && seriesData.objects && seriesData.objects[0];
                                var seriesNameStr = visuals.converterHelper.getSeriesName(seriesData.source);
                                id = visuals.SelectionId.createWithId(seriesData.identity);
                                isCategory = false;
                                color = colorHelper.getColorForSeriesValue(seriesObjects, /* values.identityFields */ undefined, seriesNameStr);
                            }
                            labelData.push({
                                label: totalFields[i],
                                labelColor: labelColor,
                                barColor: color,
                                isCategory: isCategory,
                                identity: id,
                                selected: false
                            });
                            dataMatrix.push([]);
                            toolTipData.push([]);
                            var formattedCategoryValue = visuals.valueFormatter.format(catValues[i], categorySourceFormatString);
                            for (var j = 0, jLen = totalFields.length; j < jLen; j++) {
                                var elementValue = 0;
                                var tooltipInfo = [];
                                if (catIndex[totalFields[i]] !== undefined &&
                                    seriesIndex[totalFields[j]] !== undefined) {
                                    var row = catIndex[totalFields[i]];
                                    var col = seriesIndex[totalFields[j]];
                                    if (values[col].values[row] !== null) {
                                        elementValue = values[col].values[row];
                                        if (elementValue > max)
                                            max = elementValue;
                                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, catDv, formattedCategoryValue, elementValue, null, null, col, row);
                                    }
                                }
                                else if (isDiffFromTo && catIndex[totalFields[j]] !== undefined &&
                                    seriesIndex[totalFields[i]] !== undefined) {
                                    var row = catIndex[totalFields[j]];
                                    var col = seriesIndex[totalFields[i]];
                                    if (values[col].values[row] !== null) {
                                        elementValue = values[col].values[row];
                                    }
                                }
                                dataMatrix[i].push(elementValue);
                                toolTipData[i].push({
                                    tooltipInfo: tooltipInfo
                                });
                            }
                            var totalSum = d3.sum(dataMatrix[i]);
                            sliceTooltipData.push({
                                tooltipInfo: [{
                                        displayName: totalFields[i],
                                        value: (ChordChart.isInt(totalSum)) ? totalSum.toFixed(0) : totalSum.toFixed(2)
                                    }]
                            });
                        }
                        var chordLayout = d3.layout.chord()
                            .padding(0.1)
                            .matrix(dataMatrix);
                        var unitLength = Math.round(max / 5).toString().length - 1;
                        return {
                            dataMatrix: dataMatrix,
                            labelDataPoints: ChordChart.convertToChordArcDescriptor(chordLayout.groups(), labelData),
                            legendData: legendData,
                            tooltipData: toolTipData,
                            sliceTooltipData: sliceTooltipData,
                            tickUnit: Math.pow(10, unitLength),
                            differentFromTo: isDiffFromTo,
                            defaultDataPointColor: defaultDataPointColor,
                            prevAxisVisible: prevAxisVisible,
                            showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),
                            showLabels: ChordChart.getLabelsShow(dataView),
                            showAxis: ChordChart.getAxisShow(dataView),
                            labelFontSize: labelFontSize,
                        };
                    }
                    else {
                        return {
                            dataMatrix: [],
                            labelDataPoints: [],
                            legendData: null,
                            tooltipData: [],
                            sliceTooltipData: [],
                            tickUnit: 1000,
                            differentFromTo: false,
                            defaultDataPointColor: defaultDataPointColor,
                            prevAxisVisible: prevAxisVisible,
                            showAllDataPoints: ChordChart.getShowAllDataPoints(dataView),
                            showLabels: ChordChart.getLabelsShow(dataView),
                            showAxis: ChordChart.getAxisShow(dataView),
                            labelFontSize: labelFontSize,
                        };
                    }
                };
                /* Check every element of the array and returns the count of elements which are valid(not undefined) */
                ChordChart.getValidArrayLength = function (array) {
                    var len = 0;
                    for (var i = 0, iLen = array.length; i < iLen; i++) {
                        if (array[i] !== undefined) {
                            len++;
                        }
                    }
                    return len;
                };
                /* Convert ChordLayout to ChordArcDescriptor */
                ChordChart.convertToChordArcDescriptor = function (groups, datum) {
                    var labelDataPoints = [];
                    for (var i = 0, iLen = groups.length; i < iLen; i++) {
                        var labelDataPoint = groups[i];
                        labelDataPoint.data = datum[i];
                        labelDataPoints.push(labelDataPoint);
                    }
                    return labelDataPoints;
                };
                /* Calculate radius */
                ChordChart.prototype.calculateRadius = function (viewport) {
                    if (this.data && this.data.showLabels) {
                        // if we have category or data labels, use a sigmoid to blend the desired denominator from 2 to 3.
                        // if we are taller than we are wide, we need to use a larger denominator to leave horizontal room for the labels.
                        var hw = viewport.height / viewport.width;
                        var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));
                        return Math.min(viewport.height, viewport.width) / denom;
                    }
                    // no labels
                    return Math.min(viewport.height, viewport.width) / 2;
                };
                /* Draw category labels */
                ChordChart.drawDefaultCategoryLabels = function (graphicsContext, chordData, radius, viewport) {
                    /** Multiplier to place the end point of the reference line at 0.05 * radius away from the outer edge of the chord/pie. */
                    var arc = d3.svg.arc()
                        .innerRadius(0)
                        .outerRadius(radius * ChordChart.InnerArcRadiusRatio);
                    var outerArc = d3.svg.arc()
                        .innerRadius(radius * ChordChart.OuterArcRadiusRatio)
                        .outerRadius(radius * ChordChart.OuterArcRadiusRatio);
                    if (chordData.showLabels) {
                        var labelLayout = ChordChart.getChordChartLabelLayout(radius, outerArc, viewport, chordData.labelFontSize);
                        ChordChart.drawDefaultLabelsForChordChart(chordData.labelDataPoints, graphicsContext, labelLayout, viewport, radius, arc, outerArc);
                    }
                    else
                        visuals.dataLabelUtils.cleanDataLabels(graphicsContext, true);
                };
                /* One time setup*/
                ChordChart.prototype.init = function (options) {
                    var element = this.element = options.element;
                    this.selectionManager = new visuals.utility.SelectionManager({ hostServices: options.host });
                    this.svg = d3.select(element.get(0))
                        .append('svg')
                        .style('position', 'absolute')
                        .classed(ChordChart.VisualClassName, true);
                    this.mainGraphicsContext = this.svg
                        .append('g');
                    this.mainGraphicsContext
                        .append('g')
                        .classed('slices', true);
                    this.mainGraphicsContext
                        .append('g')
                        .classed('ticks', true);
                    this.mainGraphicsContext
                        .append('g')
                        .classed('chords', true);
                    this.colors = options.style.colorPalette.dataColors;
                };
                /* Called for data, size, formatting changes*/
                ChordChart.prototype.update = function (options) {
                    var _this = this;
                    // assert dataView           
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    // get animation duration
                    var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                    var dataView = this.dataView = options.dataViews[0];
                    var prevAxisShow = (this.data) ? this.data.showAxis : !ChordChart.getAxisShow(dataView);
                    var data = this.data = ChordChart.converter(dataView, this.colors, prevAxisShow);
                    var viewport = options.viewport;
                    var chordLayout = this.chordLayout = d3.layout.chord()
                        .padding(0.1)
                        .matrix(data.dataMatrix);
                    var width = viewport.width;
                    var height = viewport.height;
                    var radius = this.calculateRadius(viewport);
                    var sm = this.selectionManager;
                    var innerRadius = radius;
                    var outerRadius = radius * ChordChart.InnerArcRadiusRatio;
                    var arc = d3.svg.arc().innerRadius(innerRadius).outerRadius(outerRadius);
                    this.svg
                        .attr({
                        'width': width,
                        'height': height
                    });
                    var mainGraphicsContext = this.mainGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(width / 2, height / 2));
                    var sliceShapes = this.svg.select('.slices')
                        .selectAll('path' + ChordChart.sliceClass.selector)
                        .data(chordLayout.groups);
                    sliceShapes.enter()
                        .insert("path")
                        .classed(ChordChart.sliceClass.class, true);
                    sliceShapes.style('fill', function (d, i) { return data.labelDataPoints[i].data.barColor; })
                        .style("stroke", function (d, i) { return data.labelDataPoints[i].data.barColor; })
                        .on('click', function (d, i) {
                        var _this = this;
                        sm.select(data.labelDataPoints[i].data.identity).then(function (ids) {
                            if (ids.length > 0) {
                                mainGraphicsContext.selectAll(".chords path.chord")
                                    .style("opacity", 1);
                                mainGraphicsContext.selectAll(".slices path.slice")
                                    .style('opacity', 0.3);
                                mainGraphicsContext.selectAll(".chords path.chord")
                                    .filter(function (d) { return d.source.index !== i && d.target.index !== i; })
                                    .style("opacity", 0.3);
                                d3.select(_this).style('opacity', 1);
                            }
                            else {
                                sliceShapes.style('opacity', 1);
                                mainGraphicsContext.selectAll(".chords path.chord")
                                    .filter(function (d) { return d.source.index !== i && d.target.index !== i; })
                                    .style("opacity", 1);
                            }
                        });
                        d3.event.stopPropagation();
                    })
                        .transition()
                        .duration(duration)
                        .attr("d", arc);
                    sliceShapes.exit()
                        .remove();
                    visuals.TooltipManager.addTooltip(sliceShapes, function (tooltipEvent) {
                        return data.sliceTooltipData[tooltipEvent.data.index].tooltipInfo;
                    });
                    var chordShapes = this.svg.select('.chords')
                        .selectAll('path' + ChordChart.chordClass.selector)
                        .data(chordLayout.chords);
                    chordShapes
                        .enter().insert("path")
                        .classed(ChordChart.chordClass.class, true);
                    chordShapes.style("fill", function (d, i) { return data.labelDataPoints[d.target.index].data.barColor; })
                        .style("opacity", 1)
                        .transition()
                        .duration(duration)
                        .attr("d", d3.svg.chord().radius(innerRadius));
                    chordShapes.exit()
                        .remove();
                    this.svg
                        .on('click', function () { return _this.selectionManager.clear().then(function () {
                        sliceShapes.style('opacity', 1);
                        chordShapes.style('opacity', 1);
                    }); });
                    ChordChart.drawTicks(this.mainGraphicsContext, data, chordLayout, outerRadius, duration, viewport);
                    ChordChart.drawDefaultCategoryLabels(this.mainGraphicsContext, data, radius, viewport);
                    visuals.TooltipManager.addTooltip(chordShapes, function (tooltipEvent) {
                        var tooltipInfo = [];
                        if (data.differentFromTo) {
                            tooltipInfo = data.tooltipData[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex]
                                .tooltipInfo;
                        }
                        else {
                            tooltipInfo.push({
                                displayName: data.labelDataPoints[tooltipEvent.data.source.index].data.label
                                    + '->' + data.labelDataPoints[tooltipEvent.data.source.subindex].data.label,
                                value: data.dataMatrix[tooltipEvent.data.source.index][tooltipEvent.data.source.subindex].toString()
                            });
                            tooltipInfo.push({
                                displayName: data.labelDataPoints[tooltipEvent.data.target.index].data.label
                                    + '->' + data.labelDataPoints[tooltipEvent.data.target.subindex].data.label,
                                value: data.dataMatrix[tooltipEvent.data.target.index][tooltipEvent.data.target.subindex].toString()
                            });
                        }
                        return tooltipInfo;
                    });
                };
                /*About to remove your visual, do clean up here */
                ChordChart.prototype.destroy = function () {
                };
                /* Clean ticks */
                ChordChart.cleanTicks = function (context) {
                    var empty = [];
                    var tickLines = context.selectAll(ChordChart.tickLineClass.selector).data(empty);
                    tickLines.exit().remove();
                    var tickTexts = context.selectAll(ChordChart.tickTextClass.selector).data(empty);
                    tickTexts.exit().remove();
                    context.selectAll(ChordChart.tickPairClass.selector).remove();
                    context.selectAll(ChordChart.sliceTicksClass.selector).remove();
                };
                /* Draw axis(ticks) around the arc */
                ChordChart.drawTicks = function (graphicsContext, chordData, chordLayout, outerRadius, duration, viewport) {
                    if (chordData.showAxis) {
                        var tickShapes = graphicsContext.select('.ticks')
                            .selectAll('g' + ChordChart.sliceTicksClass.selector)
                            .data(chordLayout.groups);
                        var animDuration = (chordData.prevAxisVisible === chordData.showAxis) ? duration : 0;
                        tickShapes.enter().insert('g')
                            .classed(ChordChart.sliceTicksClass.class, true);
                        var tickPairs = tickShapes.selectAll('g' + ChordChart.tickPairClass.selector)
                            .data(function (d) {
                            var k = (d.endAngle - d.startAngle) / d.value;
                            var range = d3.range(0, d.value, d.value - 1 < 0.15 ? 0.15 : d.value - 1);
                            var retval = range.map(function (v, i) {
                                var divider = 1000;
                                var unitStr = 'k';
                                if (chordData.tickUnit >= 1000 * 1000) {
                                    divider = 1000 * 1000;
                                    unitStr = 'm';
                                }
                                else if (chordData.tickUnit >= 1000) {
                                    divider = 1000;
                                    unitStr = 'k';
                                }
                                else {
                                    divider = 1;
                                    unitStr = '';
                                }
                                var retv = {
                                    angle: v * k + d.startAngle,
                                    label: Math.floor(v / divider) + unitStr
                                };
                                return retv;
                            });
                            return retval;
                        });
                        tickPairs.enter().insert('g')
                            .classed(ChordChart.tickPairClass.class, true);
                        tickPairs.transition()
                            .duration(animDuration)
                            .attr('transform', function (d) {
                            return 'rotate(' + (d.angle * 180 / Math.PI - 90) + ')'
                                + 'translate(' + outerRadius + ',0)';
                        });
                        tickPairs.selectAll('line' + ChordChart.tickLineClass.selector)
                            .data(function (d) { return [d]; })
                            .enter().insert('line')
                            .classed(ChordChart.tickLineClass.class, true)
                            .style("stroke", "#000")
                            .attr("x1", 1)
                            .attr("y1", 0)
                            .attr("x2", 5)
                            .attr("y2", 0);
                        tickPairs.selectAll('text' + ChordChart.tickTextClass.selector)
                            .data(function (d) { return [d]; })
                            .enter().insert('text')
                            .classed(ChordChart.tickTextClass.class, true)
                            .style("text-anchor", function (d) { return d.angle > Math.PI ? "end" : null; })
                            .text(function (d) { return d.label; })
                            .attr("transform", function (d) { return d.angle > Math.PI ? "rotate(180)translate(-16)" : null; })
                            .attr("x", 8)
                            .attr("dy", ".35em");
                        tickPairs.exit()
                            .remove();
                        tickShapes.exit()
                            .remove();
                    }
                    else {
                        ChordChart.cleanTicks(graphicsContext);
                    }
                };
                /* Get format parameter axis whether it determines show ticks or not. Default value is true */
                ChordChart.getAxisShow = function (dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var axis = objects['axis'];
                            if (axis && axis.hasOwnProperty('show')) {
                                return axis['show'];
                            }
                        }
                    }
                    return true;
                };
                /* Get format parameter labels whether it determines show labels or not. Default value is true */
                ChordChart.getLabelsShow = function (dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var labels = objects['labels'];
                            if (labels && labels.hasOwnProperty('show')) {
                                return labels['show'];
                            }
                        }
                    }
                    return true;
                };
                /* Get format parameter labels whether it determines show labels or not. Default value is true */
                ChordChart.getLabelsColor = function (dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var labels = objects['labels'];
                            if (labels && labels.hasOwnProperty('color'))
                                return labels['color'].solid.color;
                        }
                    }
                    return ChordChart.DefaultLabelColor;
                };
                ChordChart.getLabelsFontSize = function (dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var labels = objects['labels'];
                            if (labels && labels.hasOwnProperty('fontSize'))
                                return labels['fontSize'];
                        }
                    }
                    return ChordChart.DefaultLabelsFontSize;
                };
                /* Select labels */
                ChordChart.selectLabels = function (filteredData, context, isDonut, forAnimation) {
                    if (isDonut === void 0) { isDonut = false; }
                    if (forAnimation === void 0) { forAnimation = false; }
                    // Check for a case where resizing leaves no labels - then we need to remove the labels 'g'
                    if (filteredData.length === 0) {
                        visuals.dataLabelUtils.cleanDataLabels(context, true);
                        return null;
                    }
                    if (context.select(ChordChart.labelGraphicsContextClass.selector).empty())
                        context.append('g').classed(ChordChart.labelGraphicsContextClass.class, true);
                    // line chart ViewModel has a special 'key' property for point identification since the 'identity' field is set to the series identity
                    var hasKey = filteredData[0].key !== null;
                    var hasDataPointIdentity = filteredData[0].identity !== null;
                    var getIdentifier = hasKey ?
                        function (d) { return d.key; }
                        : hasDataPointIdentity ?
                            function (d) { return d.identity.getKey(); }
                            : undefined;
                    var labels = isDonut ?
                        context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, function (d) { return d.data.identity.getKey(); })
                        : getIdentifier !== null ?
                            context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData, getIdentifier)
                            : context.select(ChordChart.labelGraphicsContextClass.selector).selectAll(ChordChart.labelsClass.selector).data(filteredData);
                    var newLabels = labels.enter()
                        .append('text')
                        .classed(ChordChart.labelsClass.class, true);
                    if (forAnimation)
                        newLabels.style('opacity', 0);
                    return labels;
                };
                /* Draw labels */
                ChordChart.drawDefaultLabelsForChordChart = function (data, context, layout, viewport, radius, arc, outerArc) {
                    // Hide and reposition labels that overlap
                    var dataLabelManager = new powerbi.DataLabelManager();
                    var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout, /* addTransform */ true);
                    var labels = ChordChart.selectLabels(filteredData, context, true);
                    if (!labels) {
                        return;
                    }
                    labels
                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; }, dy: '.35em' })
                        .text(function (d) { return d.labeltext; })
                        .style(layout.style);
                    labels
                        .exit()
                        .remove();
                    if (context.select(ChordChart.linesGraphicsContextClass.selector).empty()) {
                        context
                            .append('g')
                            .classed(ChordChart.linesGraphicsContextClass.class, true);
                    }
                    var lines = context.select(ChordChart.linesGraphicsContextClass.selector).selectAll('polyline')
                        .data(filteredData, function (d) { return d.data.identity.getKey(); });
                    var innerLinePointMultiplier = 2.05;
                    var midAngle = function (d) {
                        return d.startAngle + (d.endAngle - d.startAngle) / 2;
                    };
                    lines.enter()
                        .append('polyline')
                        .classed(ChordChart.lineClass.class, true);
                    lines
                        .attr('points', function (d) {
                        var textPoint = outerArc.centroid(d);
                        textPoint[0] = radius * 0.95 * (midAngle(d) < Math.PI ? 1 : -1);
                        var midPoint = outerArc.centroid(d);
                        var chartPoint = arc.centroid(d);
                        chartPoint[0] *= innerLinePointMultiplier;
                        chartPoint[1] *= innerLinePointMultiplier;
                        return [chartPoint, midPoint, textPoint];
                    }).
                        style({
                        'opacity': function (d) { return ChordChart.PolylineOpacity; },
                        'stroke': function (d) { return d.data.labelColor; },
                    });
                    lines
                        .exit()
                        .remove();
                };
                /* Get label layout */
                ChordChart.getChordChartLabelLayout = function (radius, outerArc, viewport, labelFontSize) {
                    var midAngle = function (d) {
                        return d.startAngle + (d.endAngle - d.startAngle) / 2;
                    };
                    var spaceAvaliableForLabels = viewport.width / 2 - radius;
                    var minAvailableSpace = Math.min(spaceAvaliableForLabels, visuals.dataLabelUtils.maxLabelWidth);
                    var PixelConverter = jsCommon.PixelConverter;
                    return {
                        labelText: function (d) {
                            // show only category label
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: d.data.label,
                                maxWidth: minAvailableSpace,
                                fontSize: labelFontSize,
                            });
                        },
                        labelLayout: {
                            x: function (d) {
                                return radius * (midAngle(d) < Math.PI ? 1 : -1);
                            },
                            y: function (d) {
                                var pos = outerArc.centroid(d);
                                return pos[1];
                            },
                        },
                        filter: function (d) { return (d !== null && d.data !== null && d.data.label !== null); },
                        style: {
                            'fill': function (d) { return d.data.labelColor; },
                            'text-anchor': function (d) { return midAngle(d) < Math.PI ? 'start' : 'end'; },
                            'font-size': function (d) { return PixelConverter.fromPointToPixel(labelFontSize); },
                        },
                    };
                };
                /* Get Default Datapoint color */
                ChordChart.getDefaultDataPointColor = function (dataView, defaultValue) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var dataPoint = objects['dataPoint'];
                            if (dataPoint && dataPoint.hasOwnProperty('defaultColor')) {
                                var defaultColor = dataPoint['defaultColor'];
                                if (defaultColor) {
                                    return defaultColor;
                                }
                            }
                        }
                    }
                    return { solid: { color: defaultValue } };
                };
                /* Get format paramter value (showAllDataPoints)  */
                ChordChart.getShowAllDataPoints = function (dataView) {
                    if (!dataView || !dataView.metadata || !dataView.metadata.objects)
                        return false;
                    var objects = dataView.metadata.objects;
                    var dataPoint = objects['dataPoint'];
                    if (dataPoint && dataPoint.hasOwnProperty('showAllDataPoints')) {
                        return dataPoint['showAllDataPoints'];
                    }
                    return false;
                };
                /* Enumerate format values */
                ChordChart.prototype.enumerateObjectInstances = function (options) {
                    var instances = [];
                    var axis;
                    switch (options.objectName) {
                        case 'axis':
                            axis = {
                                objectName: 'axis',
                                displayName: 'Axis',
                                selector: null,
                                properties: {
                                    show: ChordChart.getAxisShow(this.dataView)
                                }
                            };
                            instances.push(axis);
                            break;
                        case 'labels':
                            axis = {
                                objectName: 'labels',
                                displayName: 'Labels',
                                selector: null,
                                properties: {
                                    show: ChordChart.getLabelsShow(this.dataView),
                                    color: ChordChart.getLabelsColor(this.dataView),
                                    fontSize: ChordChart.getLabelsFontSize(this.dataView),
                                }
                            };
                            instances.push(axis);
                            break;
                        case 'dataPoint':
                            var defaultColor = {
                                objectName: 'dataPoint',
                                selector: null,
                                properties: {
                                    defaultColor: {
                                        solid: { color: (this.data && this.data.defaultDataPointColor) ? this.data.defaultDataPointColor : this.colors.getColorByIndex(0).value }
                                    }
                                }
                            };
                            instances.push(defaultColor);
                            var showAllDataPoints = {
                                objectName: 'dataPoint',
                                selector: null,
                                properties: {
                                    showAllDataPoints: this.data ? !!this.data.showAllDataPoints : false,
                                }
                            };
                            instances.push(showAllDataPoints);
                            if (this.data && this.data.labelDataPoints) {
                                for (var i = 0, iLen = this.data.labelDataPoints.length; i < iLen; i++) {
                                    var labelDataPoint = this.data.labelDataPoints[i].data;
                                    if (labelDataPoint.isCategory) {
                                        var colorInstance = {
                                            objectName: 'dataPoint',
                                            displayName: labelDataPoint.label,
                                            selector: visuals.ColorHelper.normalizeSelector(labelDataPoint.identity.getSelector()),
                                            properties: {
                                                fill: { solid: { color: labelDataPoint.barColor } }
                                            }
                                        };
                                        instances.push(colorInstance);
                                    }
                                }
                            }
                            break;
                    }
                    return instances;
                };
                /* Utility function for checking if it is integer or float */
                ChordChart.isInt = function (n) {
                    return n % 1 === 0;
                };
                /* Utility function for union two arrays without duplicates */
                ChordChart.union_arrays = function (x, y) {
                    var obj = {};
                    for (var i = 0; i < x.length; i++) {
                        obj[x[i]] = x[i];
                    }
                    for (var i = 0; i < y.length; i++) {
                        obj[y[i]] = y[i];
                    }
                    var res = [];
                    for (var k in obj) {
                        if (obj.hasOwnProperty(k)) {
                            res.push(obj[k]);
                        }
                    }
                    return res;
                };
                ChordChart.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'From',
                        }, {
                            name: 'Series',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'To',
                        }, {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                        }
                    ],
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Series': { max: 0 } },
                                { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
                                { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Series',
                                        select: [{ bind: { to: 'Y' } }],
                                        dataReductionAlgorithm: { top: {} }
                                    },
                                },
                                rowCount: { preferred: { min: 2 }, supported: { min: 1 } }
                            },
                        }],
                    objects: {
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                            },
                        },
                        axis: {
                            displayName: 'Axis',
                            properties: {
                                show: {
                                    type: { bool: true }
                                },
                            },
                        },
                        labels: {
                            displayName: 'Labels',
                            properties: {
                                show: {
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } },
                                },
                            },
                        }
                    }
                };
                ChordChart.chordChartProps = {
                    general: {
                        formatString: { objectName: 'general', propertyName: 'formatString' },
                    },
                    dataPoint: {
                        defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                        fill: { objectName: 'dataPoint', propertyName: 'fill' },
                        showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
                    },
                    axis: {
                        show: { objectName: 'axis', propertyName: 'show' },
                    },
                    labels: {
                        show: { objectName: 'labels', propertyName: 'show' },
                        color: { objectName: 'labels', propertyName: 'color' },
                        fontSize: { objectName: 'labels', propertyName: 'fontSize' },
                    },
                };
                ChordChart.PolylineOpacity = 0.5;
                ChordChart.OuterArcRadiusRatio = 0.9;
                ChordChart.InnerArcRadiusRatio = 0.8;
                ChordChart.DefaultLabelColor = "#777777";
                ChordChart.DefaultLabelsFontSize = 12;
                ChordChart.VisualClassName = 'chordChart';
                ChordChart.sliceClass = {
                    class: 'slice',
                    selector: '.slice',
                };
                ChordChart.chordClass = {
                    class: 'chord',
                    selector: '.chord',
                };
                ChordChart.sliceTicksClass = {
                    class: 'slice-ticks',
                    selector: '.slice-ticks'
                };
                ChordChart.tickPairClass = {
                    class: 'tick-pair',
                    selector: '.tick-pair'
                };
                ChordChart.tickLineClass = {
                    class: 'tick-line',
                    selector: '.tick-line'
                };
                ChordChart.tickTextClass = {
                    class: 'tick-text',
                    selector: '.tick-text'
                };
                ChordChart.labelGraphicsContextClass = {
                    class: 'labels',
                    selector: '.labels',
                };
                ChordChart.labelsClass = {
                    class: 'data-labels',
                    selector: '.data-labels',
                };
                ChordChart.linesGraphicsContextClass = {
                    class: 'lines',
                    selector: '.lines',
                };
                ChordChart.lineClass = {
                    class: 'line-label',
                    selector: '.line-label',
                };
                return ChordChart;
            }());
            samples.ChordChart = ChordChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var DataRoleHelper = powerbi.data.DataRoleHelper;
            var EnhancedScatterChart = (function () {
                function EnhancedScatterChart() {
                    this.AxisGraphicsContextClassName = 'axisGraphicsContext';
                    this.ScrollBarWidth = 10;
                    this.textProperties = {
                        fontFamily: 'wf_segoe-ui_normal',
                        fontSize: jsCommon.PixelConverter.toString(EnhancedScatterChart.AxisFontSize),
                    };
                }
                Object.defineProperty(EnhancedScatterChart.prototype, "margin", {
                    get: function () {
                        return this._margin || { left: 0, right: 0, top: 0, bottom: 0 };
                    },
                    set: function (value) {
                        this._margin = $.extend({}, value);
                        this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EnhancedScatterChart.prototype, "viewport", {
                    get: function () {
                        return this._viewport || { width: 0, height: 0 };
                    },
                    set: function (value) {
                        this._viewport = $.extend({}, value);
                        this._viewportIn = EnhancedScatterChart.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EnhancedScatterChart.prototype, "viewportIn", {
                    get: function () {
                        return this._viewportIn || this.viewport;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(EnhancedScatterChart.prototype, "legendViewport", {
                    get: function () {
                        return this.legend.getMargins();
                    },
                    enumerable: true,
                    configurable: true
                });
                EnhancedScatterChart.substractMargin = function (viewport, margin) {
                    return {
                        width: Math.max(viewport.width - (margin.left + margin.right), 0),
                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                    };
                };
                EnhancedScatterChart.getCustomSymbolType = function (shape) {
                    var customSymbolTypes = d3.map({
                        "circle": function (size) {
                            var r = Math.sqrt(size / Math.PI);
                            return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + (-r) + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
                        },
                        "cross": function (size) {
                            var r = Math.sqrt(size / 5) / 2;
                            return "M" + -3 * r + "," + -r
                                + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
                        },
                        "diamond": function (size) {
                            var ry = Math.sqrt(size / (2 * Math.tan(Math.PI / 6))), rx = ry * Math.tan(Math.PI / 6);
                            return "M0," + -ry
                                + "L" + rx + ",0"
                                + " 0," + ry
                                + " " + -rx + ",0"
                                + "Z";
                        },
                        "square": function (size) {
                            var r = Math.sqrt(size) / 2;
                            return "M" + -r + "," + -r
                                + "L" + r + "," + -r
                                + " " + r + "," + r
                                + " " + -r + "," + r
                                + "Z";
                        },
                        "triangle-up": function (size) {
                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                            return "M0," + -ry
                                + "L" + rx + "," + ry
                                + " " + -rx + "," + ry
                                + "Z";
                        },
                        "triangle-down": function (size) {
                            var rx = Math.sqrt(size / Math.sqrt(3)), ry = rx * Math.sqrt(3) / 2;
                            return "M0," + ry
                                + "L" + rx + "," + -ry
                                + " " + -rx + "," + -ry
                                + "Z";
                        },
                        'star': function (size) {
                            var outerRadius = Math.sqrt(size / 2);
                            var innerRadius = Math.sqrt(size / 10);
                            var results = "";
                            var angle = Math.PI / 5;
                            for (var i = 0; i < 10; i++) {
                                // Use outer or inner radius depending on what iteration we are in.
                                var r = (i & 1) === 0 ? outerRadius : innerRadius;
                                var currX = Math.cos(i * angle) * r;
                                var currY = Math.sin(i * angle) * r;
                                // Our first time we simply append the coordinates, subsequet times
                                // we append a ", " to distinguish each coordinate pair.
                                if (i === 0) {
                                    results = "M" + currX + "," + currY + "L";
                                }
                                else {
                                    results += " " + currX + "," + currY;
                                }
                            }
                            return results + "Z";
                        },
                        'hexagon': function (size) {
                            var r = Math.sqrt(size / (6 * Math.sqrt(3)));
                            var r2 = Math.sqrt(size / (2 * Math.sqrt(3)));
                            return "M0," + (2 * r) + "L" + (-r2) + "," + r + " " + (-r2) + "," + (-r) + " 0," + (-2 * r) + " " + r2 + "," + (-r) + " " + r2 + "," + r + "Z";
                        },
                        'x': function (size) {
                            var r = Math.sqrt(size / 10);
                            return "M0," + r + "L" + (-r) + "," + 2 * r + " " + (-2 * r) + "," + r + " " + (-r) + ",0 " + (-2 * r) + "," + (-r) + " " + (-r) + "," + (-2 * r) + " 0," + (-r) + " " + r + "," + (-2 * r) + " " + (2 * r) + "," + (-r) + " " + r + ",0 " + (2 * r) + "," + r + " " + r + "," + (2 * r) + "Z";
                        },
                        'uparrow': function (size) {
                            var r = Math.sqrt(size / 12);
                            return "M" + r + "," + (3 * r) + "L" + (-r) + "," + (3 * r) + " " + (-r) + "," + (-r) + " " + (-2 * r) + "," + (-r) + " 0," + (-3 * r) + " " + (2 * r) + "," + (-r) + " " + r + "," + (-r) + "Z";
                        },
                        'downarrow': function (size) {
                            var r = Math.sqrt(size / 12);
                            return "M0," + (3 * r) + "L" + (-2 * r) + "," + r + " " + (-r) + "," + r + " " + (-r) + "," + (-3 * r) + " " + r + "," + (-3 * r) + " " + r + "," + r + " " + (2 * r) + "," + r + "Z";
                        }
                    });
                    var defaultValue = customSymbolTypes.entries()[0].value;
                    if (!shape) {
                        return defaultValue;
                    }
                    else if (isNaN(shape)) {
                        return customSymbolTypes[shape && shape.toString().toLowerCase()] || defaultValue;
                    }
                    else {
                        var result = customSymbolTypes.entries()[Math.floor(shape)];
                        return result ? result.value : defaultValue;
                    }
                };
                EnhancedScatterChart.prototype.init = function (options) {
                    this.options = options;
                    this.animator = new visuals.BaseAnimator();
                    this.behavior = new visuals.CartesianChartBehavior([new visuals.ScatterChartWebBehavior()]);
                    var element = this.element = options.element;
                    this.viewport = _.clone(options.viewport);
                    this.style = options.style;
                    this.hostServices = options.host;
                    this.colors = this.style.colorPalette.dataColors;
                    this.interactivity = options.interactivity;
                    this.margin = {
                        top: 1,
                        right: 1,
                        bottom: 1,
                        left: 1
                    };
                    this.yAxisOrientation = visuals.yAxisPosition.left;
                    this.adjustMargins();
                    var showLinesOnX = this.scrollY = true;
                    var showLinesOnY = this.scrollX = true;
                    var svg = this.svg = d3.select(element.get(0))
                        .append('svg')
                        .style('position', 'absolute')
                        .classed(EnhancedScatterChart.ClassName, true);
                    var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')
                        .classed(this.AxisGraphicsContextClassName, true);
                    this.svgScrollable = svg.append('svg')
                        .classed('svgScrollable', true)
                        .style('overflow', 'hidden');
                    var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')
                        .classed(this.AxisGraphicsContextClassName, true);
                    this.clearCatcher = visuals.appendClearCatcher(this.axisGraphicsContextScrollable);
                    var axisGroup = showLinesOnX ? axisGraphicsContextScrollable : axisGraphicsContext;
                    this.backgroundGraphicsContext = axisGraphicsContext.append('svg:image');
                    this.xAxisGraphicsContext = showLinesOnX ? axisGraphicsContext.append('g').attr('class', 'x axis') : axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
                    this.y1AxisGraphicsContext = axisGroup.append('g').attr('class', 'y axis');
                    this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);
                    this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                    this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);
                    this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                    this.interactivityService = visuals.createInteractivityService(this.hostServices);
                    this.legend = visuals.createLegend(element, this.interactivity && this.interactivity.isInteractiveLegend, this.interactivityService, true);
                    this.mainGraphicsG = this.axisGraphicsContextScrollable.append('g')
                        .classed(EnhancedScatterChart.MainGraphicsContextClassName, true);
                    this.mainGraphicsContext = this.mainGraphicsG.append('svg');
                    this.svgDefaultImage = "http://svg-edit.googlecode.com/svn-history/r1771/trunk/clipart/sun.svg";
                    this.keyArray = [];
                };
                EnhancedScatterChart.prototype.adjustMargins = function () {
                    // Adjust margins if ticks are not going to be shown on either axis
                    var xAxis = this.element.find('.x.axis');
                    if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(this.viewportIn.width) === 0
                        && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(this.viewportIn.height) === 0) {
                        this.margin = {
                            top: 0,
                            right: 0,
                            bottom: 0,
                            left: 0
                        };
                        xAxis.hide();
                    }
                    else {
                        xAxis.show();
                    }
                };
                EnhancedScatterChart.prototype.getValueAxisProperties = function (dataViewMetadata, axisTitleOnByDefault) {
                    var toReturn = {};
                    if (!dataViewMetadata)
                        return toReturn;
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var valueAxisObject = objects['valueAxis'];
                        if (valueAxisObject) {
                            toReturn = {
                                show: valueAxisObject['show'],
                                position: valueAxisObject['position'],
                                axisScale: valueAxisObject['axisScale'],
                                start: valueAxisObject['start'],
                                end: valueAxisObject['end'],
                                showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],
                                axisStyle: valueAxisObject['axisStyle'],
                                axisColor: valueAxisObject['axisColor'],
                                secShow: valueAxisObject['secShow'],
                                secPosition: valueAxisObject['secPosition'],
                                secAxisScale: valueAxisObject['secAxisScale'],
                                secStart: valueAxisObject['secStart'],
                                secEnd: valueAxisObject['secEnd'],
                                secShowAxisTitle: valueAxisObject['secShowAxisTitle'],
                                secAxisStyle: valueAxisObject['secAxisStyle'],
                                labelDisplayUnits: valueAxisObject['labelDisplayUnits'],
                            };
                        }
                    }
                    return toReturn;
                };
                EnhancedScatterChart.prototype.getCategoryAxisProperties = function (dataViewMetadata, axisTitleOnByDefault) {
                    var toReturn = {};
                    if (!dataViewMetadata)
                        return toReturn;
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        var categoryAxisObject = objects['categoryAxis'];
                        if (categoryAxisObject) {
                            toReturn = {
                                show: categoryAxisObject['show'],
                                axisType: categoryAxisObject['axisType'],
                                axisScale: categoryAxisObject['axisScale'],
                                axisColor: categoryAxisObject['axisColor'],
                                start: categoryAxisObject['start'],
                                end: categoryAxisObject['end'],
                                showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],
                                axisStyle: categoryAxisObject['axisStyle'],
                                labelDisplayUnits: categoryAxisObject['labelDisplayUnits']
                            };
                        }
                    }
                    return toReturn;
                };
                EnhancedScatterChart.converter = function (dataView, currentViewport, colorPalette, interactivityService, categoryAxisProperties, valueAxisProperties) {
                    var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName;
                    var dataViewCategorical = dataView.categorical;
                    var dataViewMetadata = dataView.metadata;
                    if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                        categoryValues = dataViewCategorical.categories[0].values;
                        categoryFormatter = visuals.valueFormatter.create({ format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString), value: categoryValues[0], value2: categoryValues[categoryValues.length - 1] });
                        categoryIdentities = dataViewCategorical.categories[0].identity;
                        categoryObjects = dataViewCategorical.categories[0].objects;
                        categoryQueryName = dataViewCategorical.categories[0].source.queryName;
                    }
                    else {
                        categoryValues = [null];
                        // creating default formatter for null value (to get the right string of empty value from the locale)
                        categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null);
                    }
                    var categories = dataViewCategorical.categories;
                    var dataValues = dataViewCategorical.values;
                    var hasDynamicSeries = !!dataValues.source;
                    var grouped = dataValues.grouped();
                    var useShape = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image') >= 0)) ? false : true;
                    var useCustomColor = (!!(DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill') >= 0)) ? true : false;
                    var dvSource = dataValues.source;
                    var scatterMetadata = EnhancedScatterChart.getMetadata(grouped, dvSource);
                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                    var fillPoint = false;
                    var backdrop = { show: false, url: "" };
                    var crosshair = false;
                    var outline = false;
                    var defaultDataPointColor = "";
                    var showAllDataPoints = true;
                    if (dataViewMetadata && dataViewMetadata.objects) {
                        var objects = dataViewMetadata.objects;
                        defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                        showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                        /*if(objects['dataPoint']){
                            let shapeObj = objects['dataPoint'];
                            if(shapeObj['useShape']){
                                shape = <boolean>shapeObj['useShape'];
                            }
                        }*/
                        var labelsObj = objects['categoryLabels'];
                        if (labelsObj) {
                            dataLabelsSettings.show = (labelsObj['show'] !== undefined) ? labelsObj['show'] : dataLabelsSettings.show;
                            dataLabelsSettings.fontSize = (labelsObj['fontSize'] !== undefined) ? labelsObj['fontSize'] : dataLabelsSettings.fontSize;
                            if (labelsObj['color'] !== undefined) {
                                dataLabelsSettings.labelColor = labelsObj['color'].solid.color;
                            }
                        }
                        fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, fillPoint);
                        var backdropObject = objects['backdrop'];
                        if (backdropObject !== undefined) {
                            backdrop.show = backdropObject['show'];
                            if (backdrop.show) {
                                backdrop.url = backdropObject['url'];
                            }
                        }
                        var crosshairObject = objects['crosshair'];
                        if (crosshairObject !== undefined) {
                            crosshair = crosshairObject['show'];
                        }
                        var outlineObject = objects['outline'];
                        if (outlineObject !== undefined) {
                            outline = outlineObject['show'];
                        }
                    }
                    var dataPoints = EnhancedScatterChart.createDataPoints(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, dataLabelsSettings, defaultDataPointColor, categoryQueryName);
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(dataPoints);
                    }
                    var legendItems = hasDynamicSeries
                        ? EnhancedScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), defaultDataPointColor)
                        : [];
                    var legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                    if (!legendTitle) {
                        legendTitle = categories && categories[0].source.displayName ? categories[0].source.displayName : "";
                    }
                    var legendData = { title: legendTitle, dataPoints: legendItems };
                    var sizeRange = EnhancedScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                    if (categoryAxisProperties && categoryAxisProperties["showAxisTitle"] !== null && categoryAxisProperties["showAxisTitle"] === false) {
                        scatterMetadata.axesLabels.x = null;
                    }
                    if (valueAxisProperties && valueAxisProperties["showAxisTitle"] !== null && valueAxisProperties["showAxisTitle"] === false) {
                        scatterMetadata.axesLabels.y = null;
                    }
                    if (dataPoints && dataPoints[0]) {
                        var point = dataPoints[0];
                        if (point.backdrop != null) {
                            backdrop.show = true;
                            backdrop.url = point.backdrop;
                        }
                        if (point.xStart != null) {
                            categoryAxisProperties['start'] = point.xStart;
                        }
                        if (point.xEnd != null) {
                            categoryAxisProperties['end'] = point.xEnd;
                        }
                        if (point.yStart != null) {
                            valueAxisProperties['start'] = point.yStart;
                        }
                        if (point.yEnd != null) {
                            valueAxisProperties['end'] = point.yEnd;
                        }
                    }
                    return {
                        xCol: scatterMetadata.cols.x,
                        yCol: scatterMetadata.cols.y,
                        dataPoints: dataPoints,
                        legendData: legendData,
                        axesLabels: scatterMetadata.axesLabels,
                        selectedIds: [],
                        size: scatterMetadata.cols.size,
                        sizeRange: sizeRange,
                        dataLabelsSettings: dataLabelsSettings,
                        defaultDataPointColor: defaultDataPointColor,
                        hasDynamicSeries: hasDynamicSeries,
                        showAllDataPoints: showAllDataPoints,
                        fillPoint: fillPoint,
                        useShape: useShape,
                        useCustomColor: useCustomColor,
                        backdrop: backdrop,
                        crosshair: crosshair,
                        outline: outline
                    };
                };
                EnhancedScatterChart.createSeriesLegend = function (dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                    var grouped = dataValues.grouped();
                    var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                    var legendItems = [];
                    for (var i = 0, len = grouped.length; i < len; i++) {
                        var grouping = grouped[i];
                        var color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                        legendItems.push({
                            color: color,
                            icon: visuals.LegendIcon.Circle,
                            label: visuals.valueFormatter.format(grouping.name, formatString),
                            identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                            selected: false,
                        });
                    }
                    return legendItems;
                };
                EnhancedScatterChart.getSizeRangeForGroups = function (dataViewValueGroups, sizeColumnIndex) {
                    var result = {};
                    if (dataViewValueGroups) {
                        dataViewValueGroups.forEach(function (group) {
                            var sizeColumn = visuals.ScatterChart.getMeasureValue(sizeColumnIndex, group.values);
                            var currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                            if (result.min == null || result.min > currentRange.min) {
                                result.min = currentRange.min;
                            }
                            if (result.max == null || result.max < currentRange.max) {
                                result.max = currentRange.max;
                            }
                        });
                    }
                    return result;
                };
                EnhancedScatterChart.getMetadata = function (grouped, source) {
                    var xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X');
                    var yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y');
                    var sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Size');
                    var gradientIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');
                    var colorFillIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'ColorFill');
                    var shapeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Shape');
                    var imageIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Image');
                    var rotationIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Rotation');
                    var backdropIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Backdrop');
                    var xStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X Start');
                    var xEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X End');
                    var yStartIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y Start');
                    var yEndIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y End');
                    var xCol;
                    var yCol;
                    var sizeCol;
                    var colorFillCol;
                    var shapeCol;
                    var imageCol;
                    var rotationCol;
                    var backdropCol;
                    var xStartCol;
                    var xEndCol;
                    var yStartCol;
                    var yEndCol;
                    var xAxisLabel = "";
                    var yAxisLabel = "";
                    if (grouped && grouped.length) {
                        var firstGroup = grouped[0], measureCount = firstGroup.values.length;
                        if (!(xIndex >= 0))
                            xIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(yIndex >= 0))
                            yIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(sizeIndex >= 0))
                            sizeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(colorFillIndex >= 0))
                            colorFillIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(shapeIndex >= 0))
                            shapeIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(imageIndex >= 0)) {
                            imageIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        }
                        if (!(rotationIndex >= 0))
                            rotationIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(backdropIndex >= 0))
                            backdropIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, xStartIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(xStartIndex >= 0))
                            xStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xEndIndex, yStartIndex, yEndIndex]);
                        if (!(xEndIndex >= 0))
                            xEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, yStartIndex, yEndIndex]);
                        if (!(yStartIndex >= 0))
                            yStartIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yEndIndex]);
                        if (!(yEndIndex >= 0))
                            yEndIndex = EnhancedScatterChart.getDefaultMeasureIndex(measureCount, [xIndex, yIndex, sizeIndex, gradientIndex, colorFillIndex, shapeIndex, imageIndex, rotationIndex, backdropIndex, xStartIndex, xEndIndex, yStartIndex]);
                        if (xIndex >= 0) {
                            xCol = firstGroup.values[xIndex].source;
                            xAxisLabel = firstGroup.values[xIndex].source.displayName;
                        }
                        if (yIndex >= 0) {
                            yCol = firstGroup.values[yIndex].source;
                            yAxisLabel = firstGroup.values[yIndex].source.displayName;
                        }
                        if (sizeIndex >= 0) {
                            sizeCol = firstGroup.values[sizeIndex].source;
                        }
                        if (colorFillIndex >= 0) {
                            colorFillCol = firstGroup.values[colorFillIndex].source;
                        }
                        if (shapeIndex >= 0) {
                            shapeCol = firstGroup.values[shapeIndex].source;
                        }
                        if (imageIndex >= 0) {
                            imageCol = firstGroup.values[imageIndex].source;
                        }
                        if (rotationIndex >= 0) {
                            rotationCol = firstGroup.values[rotationIndex].source;
                        }
                        if (backdropIndex >= 0) {
                            backdropCol = firstGroup.values[backdropIndex].source;
                        }
                        if (xStartIndex >= 0) {
                            xStartCol = firstGroup.values[xStartIndex].source;
                        }
                        if (xEndIndex >= 0) {
                            xEndCol = firstGroup.values[xEndIndex].source;
                        }
                        if (yStartIndex >= 0) {
                            yStartCol = firstGroup.values[yStartIndex].source;
                        }
                        if (yEndIndex >= 0) {
                            yEndCol = firstGroup.values[yEndIndex].source;
                        }
                    }
                    return {
                        idx: {
                            x: xIndex,
                            y: yIndex,
                            size: sizeIndex,
                            colorFill: colorFillIndex,
                            shape: shapeIndex,
                            image: imageIndex,
                            rotation: rotationIndex,
                            backdrop: backdropIndex,
                            xStart: xStartIndex,
                            xEnd: xEndIndex,
                            yStart: yStartIndex,
                            yEnd: yEndIndex,
                        },
                        cols: {
                            x: xCol,
                            y: yCol,
                            size: sizeCol,
                            colorFill: colorFillCol,
                            shape: shapeCol,
                            image: imageCol,
                            rotation: rotationCol,
                            backdrop: backdropCol,
                            xStart: xStartCol,
                            xEnd: xEndCol,
                            yStart: yStartCol,
                            yEnd: yEndCol,
                        },
                        axesLabels: {
                            x: xAxisLabel,
                            y: yAxisLabel
                        }
                    };
                };
                EnhancedScatterChart.getDefaultMeasureIndex = function (count, usedIndexes) {
                    for (var i = 0; i < count; i++) {
                        var found = true;
                        for (var j = 0; j < usedIndexes.length; j++) {
                            if (i === usedIndexes[j]) {
                                found = false;
                                break;
                            }
                        }
                        if (found === true) {
                            return i;
                        }
                    }
                    return -1;
                };
                EnhancedScatterChart.createLazyFormattedCategory = function (formatter, value) {
                    return new jsCommon.Lazy(function () { return formatter.format(value); });
                };
                EnhancedScatterChart.createDataPoints = function (dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, hasDynamicSeries, labelSettings, defaultDataPointColor, categoryQueryName) {
                    var dataPoints = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped();
                    var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                    for (var categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {
                        var categoryValue = categoryValues[categoryIdx];
                        for (var seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {
                            var grouping = grouped[seriesIdx];
                            var seriesValues = grouping.values;
                            var measureX = visuals.ScatterChart.getMeasureValue(indicies.x, seriesValues);
                            var measureY = visuals.ScatterChart.getMeasureValue(indicies.y, seriesValues);
                            var measureSize = visuals.ScatterChart.getMeasureValue(indicies.size, seriesValues);
                            var measureColorFill = visuals.ScatterChart.getMeasureValue(indicies.colorFill, seriesValues);
                            var measureShape = visuals.ScatterChart.getMeasureValue(indicies.shape, seriesValues);
                            var measureImage = visuals.ScatterChart.getMeasureValue(indicies.image, seriesValues);
                            var measureRotation = visuals.ScatterChart.getMeasureValue(indicies.rotation, seriesValues);
                            var measureBackdrop = visuals.ScatterChart.getMeasureValue(indicies.backdrop, seriesValues);
                            var measureXStart = visuals.ScatterChart.getMeasureValue(indicies.xStart, seriesValues);
                            var measureXEnd = visuals.ScatterChart.getMeasureValue(indicies.xEnd, seriesValues);
                            var measureYStart = visuals.ScatterChart.getMeasureValue(indicies.yStart, seriesValues);
                            var measureYEnd = visuals.ScatterChart.getMeasureValue(indicies.yEnd, seriesValues);
                            var xVal = measureX && measureX.values && !isNaN(measureX.values[categoryIdx]) ? measureX.values[categoryIdx] : null;
                            var yVal = measureY && measureY.values && !isNaN(measureY.values[categoryIdx]) ? measureY.values[categoryIdx] : 0;
                            var size = measureSize && measureSize.values ? measureSize.values[categoryIdx] : null;
                            var colorFill = measureColorFill && measureColorFill.values ? measureColorFill.values[categoryIdx] : null;
                            var shapeSymbolType = EnhancedScatterChart.getCustomSymbolType(measureShape && measureShape.values && measureShape.values[categoryIdx]);
                            var image = measureImage && measureImage.values ? measureImage.values[categoryIdx] : null;
                            var rotation = measureRotation && measureRotation.values ? measureRotation.values[categoryIdx] : 0;
                            var backdrop = measureBackdrop && measureBackdrop.values ? measureBackdrop.values[categoryIdx] : null;
                            var xStart = measureXStart && measureXStart.values ? measureXStart.values[categoryIdx] : null;
                            var xEnd = measureXEnd && measureXEnd.values ? measureXEnd.values[categoryIdx] : null;
                            var yStart = measureYStart && measureYStart.values ? measureYStart.values[categoryIdx] : null;
                            var yEnd = measureYEnd && measureYEnd.values ? measureYEnd.values[categoryIdx] : null;
                            var hasNullValue = (xVal == null) || (yVal == null);
                            if (hasNullValue)
                                continue;
                            var color = void 0;
                            if (hasDynamicSeries) {
                                color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                            }
                            else {
                                // If we have no Size measure then use a blank query name
                                var measureSource = (measureSize != null)
                                    ? measureSize.source.queryName
                                    : '';
                                color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                            }
                            var category = categories && categories.length > 0 ? categories[0] : null;
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(category, categoryIdx)
                                .withSeries(dataValues, grouping)
                                .createSelectionId();
                            var seriesData = [];
                            if (dataValueSource) {
                                // Dynamic series
                                seriesData.push({ value: grouping.name, metadata: { source: dataValueSource, values: [] } });
                            }
                            if (measureX) {
                                seriesData.push({ value: xVal, metadata: measureX });
                            }
                            if (measureY) {
                                seriesData.push({ value: yVal, metadata: measureY });
                            }
                            if (measureSize && measureSize.values && measureSize.values.length > 0) {
                                seriesData.push({ value: measureSize.values[categoryIdx], metadata: measureSize });
                            }
                            if (measureColorFill && measureColorFill.values && measureColorFill.values.length > 0) {
                                seriesData.push({ value: measureColorFill.values[categoryIdx], metadata: measureColorFill });
                            }
                            if (measureShape && measureShape.values && measureShape.values.length > 0) {
                                seriesData.push({ value: measureShape.values[categoryIdx], metadata: measureShape });
                            }
                            if (measureImage && measureImage.values && measureImage.values.length > 0) {
                                seriesData.push({ value: measureImage.values[categoryIdx], metadata: measureImage });
                            }
                            if (measureRotation && measureRotation.values && measureRotation.values.length > 0) {
                                seriesData.push({ value: measureRotation.values[categoryIdx], metadata: measureRotation });
                            }
                            if (measureBackdrop && measureBackdrop.values && measureBackdrop.values.length > 0) {
                                seriesData.push({ value: measureBackdrop.values[categoryIdx], metadata: measureBackdrop });
                            }
                            if (measureXStart && measureXStart.values && measureXStart.values.length > 0) {
                                seriesData.push({ value: measureXStart.values[categoryIdx], metadata: measureXStart });
                            }
                            if (measureXEnd && measureXEnd.values && measureXEnd.values.length > 0) {
                                seriesData.push({ value: measureXEnd.values[categoryIdx], metadata: measureXEnd });
                            }
                            if (measureYStart && measureYStart.values && measureYStart.values.length > 0) {
                                seriesData.push({ value: measureYStart.values[categoryIdx], metadata: measureYStart });
                            }
                            if (measureYEnd && measureYEnd.values && measureYEnd.values.length > 0) {
                                seriesData.push({ value: measureYEnd.values[categoryIdx], metadata: measureYEnd });
                            }
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData);
                            var dataPoint = {
                                x: xVal,
                                y: yVal,
                                size: size,
                                radius: { sizeMeasure: measureSize, index: categoryIdx },
                                fill: color,
                                formattedCategory: this.createLazyFormattedCategory(categoryFormatter, categoryValue),
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                labelFill: labelSettings.labelColor,
                                labelFontSize: labelSettings.fontSize,
                                colorFill: colorFill,
                                shapeSymbolType: shapeSymbolType,
                                svgurl: image,
                                rotation: rotation,
                                backdrop: backdrop,
                                xStart: xStart,
                                xEnd: xEnd,
                                yStart: yStart,
                                yEnd: yEnd
                            };
                            dataPoints.push(dataPoint);
                        }
                    }
                    return dataPoints;
                };
                EnhancedScatterChart.prototype.setData = function (dataViews) {
                    this.data = {
                        xCol: undefined,
                        yCol: undefined,
                        dataPoints: [],
                        legendData: { dataPoints: [] },
                        axesLabels: { x: '', y: '' },
                        selectedIds: [],
                        sizeRange: [],
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                        defaultDataPointColor: null,
                        hasDynamicSeries: false,
                        useShape: true,
                        useCustomColor: false,
                    };
                    if (dataViews.length > 0) {
                        var dataView = dataViews[0];
                        if (dataView) {
                            this.categoryAxisProperties = this.getCategoryAxisProperties(dataView.metadata, true);
                            this.valueAxisProperties = this.getValueAxisProperties(dataView.metadata, true);
                            this.dataView = dataView;
                            if (dataView.categorical && dataView.categorical.values) {
                                this.data = EnhancedScatterChart.converter(dataView, this.viewport, this.colors, this.interactivityService, this.categoryAxisProperties, this.valueAxisProperties);
                            }
                        }
                    }
                };
                EnhancedScatterChart.prototype.update = function (options) {
                    debug.assertValue(options, 'options');
                    var dataViews = this.dataViews = options.dataViews;
                    this.viewport = _.clone(options.viewport);
                    if (!dataViews)
                        return;
                    if (dataViews && dataViews.length > 0) {
                        var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                        if (warnings && warnings.length > 0)
                            this.hostServices.setWarnings(warnings);
                        this.populateObjectProperties(dataViews);
                    }
                    this.setData(dataViews);
                    // Note: interactive legend shouldn't be rendered explicitly here
                    // The interactive legend is being rendered in the render method of ICartesianVisual
                    if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend)) {
                        this.renderLegend();
                    }
                    this.render(options.suppressAnimations);
                };
                EnhancedScatterChart.prototype.populateObjectProperties = function (dataViews) {
                    if (dataViews && dataViews.length > 0) {
                        var dataViewMetadata = dataViews[0].metadata;
                        if (dataViewMetadata) {
                            this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});
                        }
                        else {
                            this.legendObjectProperties = {};
                        }
                        this.categoryAxisProperties = this.getCategoryAxisProperties(dataViewMetadata);
                        this.valueAxisProperties = this.getValueAxisProperties(dataViewMetadata);
                        var axisPosition = this.valueAxisProperties['position'];
                        this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
                    }
                };
                EnhancedScatterChart.prototype.renderLegend = function () {
                    var legendData = { title: "", dataPoints: [] };
                    var legend = this.legend;
                    this.layerLegendData = this.data.legendData;
                    if (this.layerLegendData) {
                        legendData.title = this.layerLegendData.title || "";
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
                        legendData.fontSize = this.legendLabelFontSize ? this.legendLabelFontSize : EnhancedScatterChart.LegendLabelFontSizeDefault;
                        if (this.layerLegendData.grouped) {
                            legendData.grouped = true;
                        }
                    }
                    var legendProperties = this.legendObjectProperties;
                    if (legendProperties) {
                        visuals.LegendData.update(legendData, legendProperties);
                        var position = legendProperties[visuals.legendProps.position];
                        if (position)
                            legend.changeOrientation(visuals.LegendPosition[position]);
                    }
                    else {
                        legend.changeOrientation(visuals.LegendPosition.Top);
                    }
                    if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {
                        legendData.dataPoints = [];
                    }
                    var viewport = this.viewport;
                    legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });
                    visuals.Legend.positionChartArea(this.svg, legend);
                };
                EnhancedScatterChart.prototype.hideLegends = function () {
                    if (this.cartesianSmallViewPortProperties) {
                        if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.viewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {
                            return true;
                        }
                    }
                    return false;
                };
                EnhancedScatterChart.prototype.shouldRenderAxis = function (axisProperties, propertyName) {
                    if (propertyName === void 0) { propertyName = "show"; }
                    if (!axisProperties) {
                        return false;
                    }
                    else if (axisProperties.isCategoryAxis && (!this.categoryAxisProperties || this.categoryAxisProperties[propertyName] == null || this.categoryAxisProperties[propertyName])) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    else if (!axisProperties.isCategoryAxis && (!this.valueAxisProperties || this.valueAxisProperties[propertyName] == null || this.valueAxisProperties[propertyName])) {
                        return axisProperties.values && axisProperties.values.length > 0;
                    }
                    return false;
                };
                EnhancedScatterChart.prototype.getMaxMarginFactor = function () {
                    return this.options.style.maxMarginFactor || 0.25;
                };
                EnhancedScatterChart.prototype.adjustViewportbyBackdrop = function () {
                    var img = new Image();
                    var that = this;
                    img.src = this.data.backdrop.url;
                    img.onload = function () {
                        if (that.oldBackdrop !== this.src) {
                            that.render(true);
                            that.oldBackdrop = this.src;
                        }
                    };
                    if (img.width > 0 && img.height > 0) {
                        if (img.width * this.viewportIn.height < this.viewportIn.width * img.height) {
                            var deltaWidth = this.viewportIn.width - this.viewportIn.height * img.width / img.height;
                            this.viewport = { width: this.viewport.width - deltaWidth, height: this.viewport.height };
                        }
                        else {
                            var deltaHeight = this.viewportIn.height - this.viewportIn.width * img.height / img.width;
                            this.viewport = { width: this.viewport.width, height: this.viewport.height - deltaHeight };
                        }
                    }
                };
                EnhancedScatterChart.prototype.render = function (suppressAnimations) {
                    this.viewport.height -= this.legendViewport.height;
                    this.viewport.width -= this.legendViewport.width;
                    if (this.viewportIn.width === 0 || this.viewportIn.height === 0) {
                        return;
                    }
                    var maxMarginFactor = this.getMaxMarginFactor();
                    this.leftRightMarginLimit = this.viewport.width * maxMarginFactor;
                    var bottomMarginLimit = this.bottomMarginLimit = Math.max(25, Math.ceil(this.viewport.height * maxMarginFactor));
                    // reset defaults
                    this.margin.top = 8;
                    this.margin.bottom = bottomMarginLimit;
                    this.margin.right = 0;
                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);
                    this.yAxisIsCategorical = this.yAxisProperties.isCategoryAxis;
                    this.hasCategoryAxis = this.yAxisIsCategorical ? this.yAxisProperties && this.yAxisProperties.values.length > 0 : this.xAxisProperties && this.xAxisProperties.values.length > 0;
                    var renderXAxis = this.shouldRenderAxis(this.xAxisProperties);
                    var renderY1Axis = this.shouldRenderAxis(this.yAxisProperties);
                    var mainAxisScale;
                    this.isXScrollBarVisible = false;
                    this.isYScrollBarVisible = false;
                    var tickLabelMargins;
                    var axisLabels;
                    var chartHasAxisLabels;
                    var yAxisOrientation = this.yAxisOrientation;
                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);
                    var doneWithMargins = false, maxIterations = 2, numIterations = 0;
                    while (!doneWithMargins && numIterations < maxIterations) {
                        numIterations++;
                        tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({ width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, false);
                        // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side
                        var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                        maxMainYaxisSide += 10;
                        maxSecondYaxisSide += 10;
                        xMax += 12;
                        if (showY1OnRight && renderY1Axis) {
                            maxSecondYaxisSide += 20;
                        }
                        if (!showY1OnRight && renderY1Axis) {
                            maxMainYaxisSide += 20;
                        }
                        if (this.hideAxisLabels()) {
                            this.xAxisProperties.axisLabel = null;
                            this.yAxisProperties.axisLabel = null;
                        }
                        this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);
                        axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };
                        chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                        if (axisLabels.x != null)
                            xMax += 18;
                        if (axisLabels.y != null)
                            maxMainYaxisSide += 20;
                        if (axisLabels.y2 != null)
                            maxSecondYaxisSide += 20;
                        this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;
                        this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;
                        this.margin.bottom = xMax;
                        // re-calculate the axes with the new margins
                        var previousTickCountY1 = this.yAxisProperties.values.length;
                        this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);
                        // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again
                        // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.
                        if (this.yAxisProperties.values.length === previousTickCountY1)
                            doneWithMargins = true;
                    }
                    // we have to do the above process again since changes are made to viewport.
                    if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {
                        this.adjustViewportbyBackdrop();
                        doneWithMargins = false;
                        maxIterations = 2;
                        numIterations = 0;
                        while (!doneWithMargins && numIterations < maxIterations) {
                            numIterations++;
                            tickLabelMargins = visuals.AxisHelper.getTickLabelMargins({ width: this.viewportIn.width, height: this.viewport.height }, this.leftRightMarginLimit, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.measureSvgTextHeight, { x: this.xAxisProperties, y1: this.yAxisProperties }, this.bottomMarginLimit, this.textProperties, this.isXScrollBarVisible || this.isYScrollBarVisible, showY1OnRight, renderXAxis, renderY1Axis, false);
                            // We look at the y axes as main and second sides, if the y axis orientation is right so the main side represents the right side
                            var maxMainYaxisSide = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxSecondYaxisSide = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, xMax = tickLabelMargins.xMax;
                            maxMainYaxisSide += 10;
                            if (showY1OnRight && renderY1Axis)
                                maxSecondYaxisSide += 15;
                            xMax += 12;
                            if (this.hideAxisLabels()) {
                                this.xAxisProperties.axisLabel = null;
                                this.yAxisProperties.axisLabel = null;
                            }
                            this.addUnitTypeToAxisLabel(this.xAxisProperties, this.yAxisProperties);
                            axisLabels = { x: this.xAxisProperties.axisLabel, y: this.yAxisProperties.axisLabel, y2: null };
                            chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                            if (axisLabels.x != null)
                                xMax += 18;
                            if (axisLabels.y != null)
                                maxMainYaxisSide += 20;
                            if (axisLabels.y2 != null)
                                maxSecondYaxisSide += 20;
                            this.margin.left = showY1OnRight ? maxSecondYaxisSide : maxMainYaxisSide;
                            this.margin.right = showY1OnRight ? maxMainYaxisSide : maxSecondYaxisSide;
                            this.margin.bottom = xMax;
                            // re-calculate the axes with the new margins
                            var previousTickCountY1 = this.yAxisProperties.values.length;
                            this.calculateAxes(this.categoryAxisProperties, this.valueAxisProperties, this.textProperties, true);
                            // the minor padding adjustments could have affected the chosen tick values, which would then need to calculate margins again
                            // e.g. [0,2,4,6,8] vs. [0,5,10] the 10 is wider and needs more margin.
                            if (this.yAxisProperties.values.length === previousTickCountY1)
                                doneWithMargins = true;
                        }
                    }
                    this.renderChart(mainAxisScale, this.xAxisProperties, this.yAxisProperties, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations);
                    this.updateAxis();
                    if (!this.data)
                        return;
                    var data = this.data;
                    var dataPoints = this.data.dataPoints;
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                    this.mainGraphicsContext.attr('width', this.viewportIn.width)
                        .attr('height', this.viewportIn.height);
                    var sortedData = dataPoints.sort(function (a, b) {
                        return b.radius.sizeMeasure ? (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index]) : 0;
                    });
                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    var scatterMarkers = this.drawScatterMarkers(sortedData, hasSelection, data.sizeRange, duration);
                    var dataLabelsSettings = this.data.dataLabelsSettings;
                    if (dataLabelsSettings.show) {
                        var layout = this.getEnhanchedScatterChartLabelLayout(dataLabelsSettings, this.viewportIn, data.sizeRange);
                        var clonedDataPoints = this.cloneDataPoints(dataPoints);
                        //fix bug 3863: drawDefaultLabelsForDataPointChart add to datapoints[xxx].size = object , which causes when
                        //category labels is on and Fill Points option off to fill the points when mouse click occures because of default size
                        //is set to datapoints.
                        visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(clonedDataPoints, this.mainGraphicsG, layout, this.viewportIn);
                        var offset = dataLabelsSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;
                        this.mainGraphicsG.select('.labels').attr('transform', visuals.SVGUtil.translate(offset, 0));
                    }
                    else {
                        visuals.dataLabelUtils.cleanDataLabels(this.mainGraphicsG);
                    }
                    var behaviorOptions = undefined;
                    if (this.interactivityService) {
                        behaviorOptions = {
                            dataPointsSelection: scatterMarkers,
                            data: this.data,
                            plotContext: this.mainGraphicsContext,
                        };
                    }
                    visuals.TooltipManager.addTooltip(scatterMarkers, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                    if (this.behavior) {
                        var layerBehaviorOptions = [];
                        layerBehaviorOptions.push(behaviorOptions);
                        if (this.interactivityService) {
                            var cbehaviorOptions = {
                                layerOptions: layerBehaviorOptions,
                                clearCatcher: this.clearCatcher,
                            };
                            this.interactivityService.bind(dataPoints, this.behavior, cbehaviorOptions);
                        }
                    }
                };
                EnhancedScatterChart.prototype.cloneDataPoints = function (dataPoints) {
                    var clonedDataPoints = new Array();
                    for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                        var dataPoint = dataPoints_1[_i];
                        var clonedDataPoint = _.clone(dataPoint);
                        clonedDataPoints.push(clonedDataPoint);
                    }
                    return clonedDataPoints;
                };
                EnhancedScatterChart.prototype.darkenZeroLine = function (g) {
                    var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();
                    if (zeroTick) {
                        d3.select(zeroTick).select('line').classed('zero-line', true);
                    }
                };
                EnhancedScatterChart.prototype.getCategoryAxisFill = function () {
                    if (this.dataView && this.dataView.metadata.objects) {
                        var label = this.dataView.metadata.objects['categoryAxis'];
                        if (label) {
                            return label['axisColor'];
                        }
                    }
                    return { solid: { color: '#333' } };
                };
                EnhancedScatterChart.prototype.getEnhanchedScatterChartLabelLayout = function (labelSettings, viewport, sizeRange) {
                    var xScale = this.xAxisProperties.scale;
                    var yScale = this.yAxisProperties.scale;
                    var fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize);
                    var offset = labelSettings.fontSize * EnhancedScatterChart.DataLabelsOffset;
                    return {
                        labelText: function (d) {
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: d.formattedCategory.getValue(),
                                fontSize: labelSettings.fontSize,
                                maxWidth: viewport.width,
                            });
                        },
                        labelLayout: {
                            x: function (d) { return xScale(d.x) - offset; },
                            y: function (d) {
                                var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + visuals.dataLabelUtils.labelMargin;
                                return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;
                            },
                        },
                        filter: function (d) {
                            return (d != null && d.formattedCategory.getValue() != null);
                        },
                        style: {
                            'fill': function (d) { return d.labelFill; },
                            'font-size': fontSizeInPx,
                        },
                    };
                };
                EnhancedScatterChart.prototype.getValueAxisFill = function () {
                    if (this.dataView && this.dataView.metadata.objects) {
                        var label = this.dataView.metadata.objects['valueAxis'];
                        if (label)
                            return label['axisColor'];
                    }
                    return { solid: { color: '#333' } };
                };
                EnhancedScatterChart.prototype.renderCrossHair = function () {
                    var _this = this;
                    var xScale = this.xAxisProperties.scale;
                    var yScale = this.yAxisProperties.scale;
                    var mainGraphicsContext = this.mainGraphicsContext;
                    mainGraphicsContext.selectAll(".crosshairCanvas").remove();
                    if (this.data.crosshair) {
                        var canvas = mainGraphicsContext.append("g").attr("class", "crosshairCanvas").attr("id", "crosshairCanvas");
                        var crossHair = canvas.append("g").attr("class", "crosshair");
                        var hLine_1 = crossHair.append("line").attr("id", "h_crosshair") // horizontal cross hair
                            .attr("x1", 0)
                            .attr("y1", 0)
                            .attr("x2", 0)
                            .attr("y2", 0)
                            .style("stroke", "gray")
                            .style("stroke-width", "1px")
                            .style("stroke-dasharray", "5,5")
                            .style("display", "none");
                        var vLine_1 = crossHair.append("line").attr("id", "v_crosshair") // vertical cross hair
                            .attr("x1", 0)
                            .attr("y1", 0)
                            .attr("x2", 0)
                            .attr("y2", 0)
                            .style("stroke", "gray")
                            .style("stroke-width", "1px")
                            .style("stroke-dasharray", "5,5")
                            .style("display", "none");
                        var text_1 = crossHair.append("text").attr("id", "crosshair_text") // text label for cross hair
                            .style("font-size", "10px")
                            .style("stroke", "gray")
                            .style("stroke-width", "0.5px");
                        var addCrossHair_1 = function (xCoord, yCoord) {
                            // Update horizontal cross hair
                            hLine_1.attr("x1", 0)
                                .attr("y1", yCoord)
                                .attr("x2", _this.viewportIn.width)
                                .attr("y2", yCoord)
                                .style("display", "block");
                            // Update vertical cross hair
                            vLine_1.attr("x1", xCoord)
                                .attr("y1", 0)
                                .attr("x2", xCoord)
                                .attr("y2", _this.viewportIn.height)
                                .style("display", "block");
                            // Update text label
                            text_1.attr("transform", "translate(" + (xCoord + 5) + "," + (yCoord - 5) + ")")
                                .text("(" + Math.round(xScale.invert(xCoord) * 100) / 100 + " , " + Math.round(yScale.invert(yCoord) * 100) / 100 + ")");
                        };
                        this.axisGraphicsContextScrollable.on("mousemove", function () {
                            var coordinates = d3.mouse(this);
                            var svgNode = this.viewportElement;
                            var scaledRect = svgNode.getBoundingClientRect();
                            var domRect = svgNode.getBBox();
                            var ratioX = scaledRect.width / domRect.width;
                            var ratioY = scaledRect.height / domRect.height;
                            if (domRect.width > 0 && !powerbi.Double.equalWithPrecision(ratioX, 1.0, 0.00001)) {
                                coordinates[0] = coordinates[0] / ratioX;
                            }
                            if (domRect.height > 0 && !powerbi.Double.equalWithPrecision(ratioY, 1.0, 0.00001)) {
                                coordinates[1] = coordinates[1] / ratioY;
                            }
                            addCrossHair_1(coordinates[0], coordinates[1]);
                        })
                            .on("mouseover", function () {
                            d3.selectAll(".crosshair").style("display", "block");
                        })
                            .on("mouseout", function () {
                            d3.selectAll(".crosshair").style("display", "none");
                        });
                    }
                };
                EnhancedScatterChart.prototype.renderBackground = function () {
                    if (this.data.backdrop && this.data.backdrop.show && (this.data.backdrop.url !== undefined)) {
                        this.backgroundGraphicsContext
                            .attr("xlink:href", this.data.backdrop.url)
                            .attr('x', 0)
                            .attr('y', 0)
                            .attr('width', this.viewportIn.width)
                            .attr('height', this.viewportIn.height);
                    }
                    else {
                        this.backgroundGraphicsContext
                            .attr('width', 0)
                            .attr('height', 0);
                    }
                };
                EnhancedScatterChart.prototype.renderChart = function (mainAxisScale, xAxis, yAxis, tickLabelMargins, chartHasAxisLabels, axisLabels, suppressAnimations, scrollScale, extent) {
                    var bottomMarginLimit = this.bottomMarginLimit;
                    var leftRightMarginLimit = this.leftRightMarginLimit;
                    var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                    this.renderBackground();
                    //hide show x-axis here
                    if (this.shouldRenderAxis(xAxis)) {
                        xAxis.axis.orient("bottom");
                        if (!xAxis.willLabelsFit)
                            xAxis.axis.tickPadding(5);
                        var xAxisGraphicsElement = this.xAxisGraphicsContext;
                        if (duration) {
                            xAxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(xAxis.axis)
                                .call(this.darkenZeroLine);
                        }
                        else {
                            xAxisGraphicsElement
                                .call(xAxis.axis)
                                .call(this.darkenZeroLine);
                        }
                        var xZeroTick = xAxisGraphicsElement.selectAll('g.tick').filter(function (data) { return data === 0; });
                        if (xZeroTick) {
                            var xZeroColor = this.getValueAxisFill();
                            if (xZeroColor)
                                xZeroTick.selectAll('line').style({ 'stroke': xZeroColor.solid.color });
                        }
                        var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');
                        if (xAxis.willLabelsWordBreak) {
                            xAxisTextNodes
                                .call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, xAxis, bottomMarginLimit);
                        }
                        else {
                            xAxisTextNodes
                                .call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.getTailoredTextOrDefault, visuals.CartesianChart.AxisTextProperties, !xAxis.willLabelsFit, bottomMarginLimit === tickLabelMargins.xMax, xAxis, this.margin, this.isXScrollBarVisible || this.isYScrollBarVisible);
                        }
                    }
                    else {
                        this.xAxisGraphicsContext.selectAll('*').remove();
                    }
                    if (this.shouldRenderAxis(yAxis)) {
                        var yAxisOrientation = this.yAxisOrientation;
                        yAxis.axis
                            .tickSize(-this.viewportIn.width)
                            .tickPadding(10)
                            .orient(yAxisOrientation.toLowerCase());
                        var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                        if (duration) {
                            y1AxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(yAxis.axis)
                                .call(this.darkenZeroLine);
                        }
                        else {
                            y1AxisGraphicsElement
                                .call(yAxis.axis)
                                .call(this.darkenZeroLine);
                        }
                        var yZeroTick = y1AxisGraphicsElement.selectAll('g.tick').filter(function (data) { return data === 0; });
                        if (yZeroTick) {
                            var yZeroColor = this.getCategoryAxisFill();
                            if (yZeroColor) {
                                yZeroTick.selectAll('line').style({ 'stroke': yZeroColor.solid.color });
                            }
                        }
                        if (tickLabelMargins.yLeft >= leftRightMarginLimit) {
                            y1AxisGraphicsElement.selectAll('text')
                                .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                            leftRightMarginLimit - 10, powerbi.TextMeasurementService.svgEllipsis);
                        }
                    }
                    else {
                        this.y1AxisGraphicsContext.selectAll('*').remove();
                    }
                    // Axis labels
                    //TODO: Add label for second Y axis for combo chart
                    if (chartHasAxisLabels) {
                        var hideXAxisTitle = !this.shouldRenderAxis(xAxis, "showAxisTitle");
                        var hideYAxisTitle = !this.shouldRenderAxis(yAxis, "showAxisTitle");
                        var hideY2AxisTitle = this.valueAxisProperties && this.valueAxisProperties["secShowAxisTitle"] != null && this.valueAxisProperties["secShowAxisTitle"] === false;
                        this.renderAxesLabels(axisLabels, this.legendViewport.height, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle);
                    }
                    else {
                        this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                        this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                    }
                    this.renderCrossHair();
                };
                EnhancedScatterChart.prototype.renderAxesLabels = function (axisLabels, legendMargin, hideXAxisTitle, hideYAxisTitle, hideY2AxisTitle) {
                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                    var margin = this.margin;
                    var width = this.viewportIn.width;
                    var height = this.viewport.height;
                    var fontSize = EnhancedScatterChart.AxisFontSize;
                    var yAxisOrientation = this.yAxisOrientation;
                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    if (!hideXAxisTitle) {
                        var xAxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(axisLabels.x)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "xAxisLabel",
                                    "transform": visuals.SVGUtil.translate(width / 2, height - fontSize - 2)
                                });
                            });
                        });
                        xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!hideYAxisTitle) {
                        var yAxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(axisLabels.y)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    "transform": "rotate(-90)",
                                    "y": showY1OnRight ? width + margin.right - fontSize : -margin.left,
                                    "x": -((height - margin.top - legendMargin) / 2),
                                    "dy": "1em"
                                });
                            });
                        });
                        yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!hideY2AxisTitle && axisLabels.y2) {
                        var y2AxisLabel = this.axisGraphicsContext.append("text")
                            .style("text-anchor", "middle")
                            .text(axisLabels.y2)
                            .call(function (text) {
                            text.each(function () {
                                var text = d3.select(this);
                                text.attr({
                                    "class": "yAxisLabel",
                                    "transform": "rotate(-90)",
                                    "y": showY1OnRight ? -margin.left : width + margin.right - fontSize,
                                    "x": -((height - margin.top - legendMargin) / 2),
                                    "dy": "1em"
                                });
                            });
                        });
                        y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis);
                    }
                };
                EnhancedScatterChart.prototype.updateAxis = function () {
                    this.adjustMargins();
                    var yAxisOrientation = this.yAxisOrientation;
                    var showY1OnRight = yAxisOrientation === visuals.yAxisPosition.right;
                    this.xAxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(0, this.viewportIn.height));
                    this.y1AxisGraphicsContext
                        .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? this.viewportIn.width : 0, 0));
                    this.svg.attr({
                        'width': this.viewport.width,
                        'height': this.viewport.height
                    });
                    this.svgScrollable.attr({
                        'width': this.viewport.width,
                        'height': this.viewport.height
                    });
                    this.svgScrollable.attr({
                        'x': 0
                    });
                    var left = this.margin.left;
                    var top = this.margin.top;
                    this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(left, top));
                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(left, top));
                    this.clearCatcher.attr('transform', visuals.SVGUtil.translate(-left, -top));
                    if (this.isXScrollBarVisible) {
                        this.svgScrollable.attr({
                            'x': left
                        });
                        this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, top));
                        this.svgScrollable.attr('width', this.viewportIn.width);
                        this.svg.attr('width', this.viewport.width)
                            .attr('height', this.viewport.height + this.ScrollBarWidth);
                    }
                    else if (this.isYScrollBarVisible) {
                        this.svgScrollable.attr('height', this.viewportIn.height + top);
                        this.svg.attr('width', this.viewport.width + this.ScrollBarWidth)
                            .attr('height', this.viewport.height);
                    }
                };
                EnhancedScatterChart.prototype.getUnitType = function (xAxis) {
                    if (xAxis.formatter &&
                        xAxis.formatter.displayUnit &&
                        xAxis.formatter.displayUnit.value > 1)
                        return xAxis.formatter.displayUnit.title;
                    return null;
                };
                EnhancedScatterChart.prototype.addUnitTypeToAxisLabel = function (xAxis, yAxis) {
                    var unitType = this.getUnitType(xAxis);
                    if (xAxis.isCategoryAxis) {
                        this.categoryAxisHasUnitType = unitType !== null;
                    }
                    else {
                        this.valueAxisHasUnitType = unitType !== null;
                    }
                    if (xAxis.axisLabel && unitType) {
                        if (xAxis.isCategoryAxis) {
                            xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, xAxis.axisLabel, unitType);
                        }
                        else {
                            xAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, xAxis.axisLabel, unitType);
                        }
                    }
                    unitType = this.getUnitType(yAxis);
                    if (!yAxis.isCategoryAxis) {
                        this.valueAxisHasUnitType = unitType !== null;
                    }
                    else {
                        this.categoryAxisHasUnitType = unitType !== null;
                    }
                    if (yAxis.axisLabel && unitType) {
                        if (!yAxis.isCategoryAxis) {
                            yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, yAxis.axisLabel, unitType);
                        }
                        else {
                            yAxis.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, yAxis.axisLabel, unitType);
                        }
                    }
                };
                EnhancedScatterChart.prototype.hideAxisLabels = function () {
                    if (this.cartesianSmallViewPortProperties) {
                        if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort
                            && ((this.viewport.height + this.legendViewport.height) < this.cartesianSmallViewPortProperties.MinHeightAxesVisible)
                            && !this.options.interactivity.isInteractiveLegend) {
                            return true;
                        }
                    }
                    return false;
                };
                EnhancedScatterChart.prototype.drawScatterMarkers = function (scatterData, hasSelection, sizeRange, duration) {
                    var _this = this;
                    var xScale = this.xAxisProperties.scale;
                    var yScale = this.yAxisProperties.scale;
                    var shouldEnableFill = (!sizeRange || !sizeRange.min) && this.data.fillPoint;
                    var markers;
                    var useCustomColor = this.data.useCustomColor;
                    if (this.data.useShape) {
                        this.mainGraphicsContext.selectAll(EnhancedScatterChart.ImageClasses.selector).remove();
                        markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.DotClasses.selector).data(scatterData, function (d) { return d.identity.getKey(); });
                        markers.enter()
                            .append('path')
                            .classed(EnhancedScatterChart.DotClasses.class, true).attr('id', 'markershape');
                        markers
                            .style({
                            'stroke-opacity': function (d) { return visuals.ScatterChart.getBubbleOpacity(d, hasSelection); },
                            'stroke-width': '1px',
                            'stroke': function (d) {
                                var color = useCustomColor ? d.colorFill : d.fill;
                                if (_this.data.outline) {
                                    return d3.rgb(color).darker();
                                }
                                else {
                                    return d3.rgb(color);
                                }
                            },
                            'fill': function (d) { return d3.rgb(useCustomColor ? d.colorFill : d.fill); },
                            'fill-opacity': function (d) { return (d.size != null || shouldEnableFill) ? visuals.ScatterChart.getBubbleOpacity(d, hasSelection) : 0; },
                        })
                            .attr("d", function (d) {
                            var r = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                            var area = 4 * r * r;
                            return d.shapeSymbolType(area);
                        })
                            .transition()
                            .duration(function (d) {
                            if (_this.keyArray.indexOf(d.identity.getKey()) >= 0) {
                                return duration;
                            }
                            else {
                                return 0;
                            }
                        })
                            .attr("transform", function (d) { return "translate(" + xScale(d.x) + "," + yScale(d.y) + ") rotate(" + d.rotation + ")"; });
                    }
                    else {
                        this.mainGraphicsContext.selectAll(EnhancedScatterChart.DotClasses.selector).remove();
                        markers = this.mainGraphicsContext.classed('ScatterMarkers', true).selectAll(EnhancedScatterChart.ImageClasses.selector).data(scatterData, function (d) { return d.identity.getKey(); });
                        markers.enter().append("svg:image")
                            .classed(EnhancedScatterChart.ImageClasses.class, true).attr('id', 'markerimage');
                        markers
                            .attr("xlink:href", function (d) {
                            if (d.svgurl !== undefined && d.svgurl != null && d.svgurl !== "") {
                                return d.svgurl;
                            }
                            else {
                                return _this.svgDefaultImage;
                            }
                        })
                            .attr("width", function (d) {
                            return visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport) * 2;
                        })
                            .attr("height", function (d) {
                            return visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport) * 2;
                        })
                            .transition()
                            .duration(function (d) {
                            if (_this.keyArray.indexOf(d.identity.getKey()) >= 0) {
                                return duration;
                            }
                            else {
                                return 0;
                            }
                        })
                            .attr("transform", function (d) {
                            var radius = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, _this.viewport);
                            return "translate(" + (xScale(d.x) - radius) + "," + (yScale(d.y) - radius) + ") rotate(" + d.rotation + "," + radius + "," + radius + ")";
                        });
                    }
                    markers.exit().remove();
                    this.keyArray = [];
                    for (var i = 0; i < scatterData.length; i++) {
                        this.keyArray.push(scatterData[i].identity.getKey());
                    }
                    return markers;
                };
                EnhancedScatterChart.prototype.calculateAxes = function (categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible) {
                    var visualOptions = {
                        viewport: this.viewport,
                        margin: this.margin,
                        forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],
                        forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,
                        showCategoryAxisLabel: false,
                        showValueAxisLabel: false,
                        categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? categoryAxisProperties['axisScale'] : null,
                        valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? valueAxisProperties['axisScale'] : null,
                        valueAxisDisplayUnits: valueAxisProperties && valueAxisProperties['labelDisplayUnits'] != null ? valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,
                        categoryAxisDisplayUnits: categoryAxisProperties && categoryAxisProperties['labelDisplayUnits'] != null ? categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault,
                        trimOrdinalDataOnOverflow: false
                    };
                    if (valueAxisProperties) {
                        visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);
                    }
                    visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']);
                    visualOptions.showValueAxisLabel = true;
                    var width = this.viewport.width - (this.margin.left + this.margin.right);
                    var axes = this.calculateAxesProperties(visualOptions);
                    axes[0].willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes[0], width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                    // If labels do not fit and we are not scrolling, try word breaking
                    axes[0].willLabelsWordBreak = (!axes[0].willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes[0], this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);
                    return axes;
                };
                EnhancedScatterChart.prototype.calculateAxesProperties = function (options) {
                    var data = this.data;
                    var dataPoints = data.dataPoints;
                    this.margin = options.margin;
                    this.viewport = options.viewport;
                    var minY = 0, maxY = 10, minX = 0, maxX = 10;
                    if (dataPoints.length > 0) {
                        minY = d3.min(dataPoints, function (d) { return d.y; });
                        maxY = d3.max(dataPoints, function (d) { return d.y; });
                        minX = d3.min(dataPoints, function (d) { return d.x; });
                        maxX = d3.max(dataPoints, function (d) { return d.x; });
                    }
                    var xDomain = [minX, maxX];
                    var combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain);
                    this.xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: this.viewportIn.width,
                        dataDomain: combinedXDomain,
                        metaDataColumn: data.xCol,
                        formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: true,
                        isVertical: false,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: true,
                        isCategoryAxis: true,
                        scaleType: options.categoryAxisScaleType,
                        axisDisplayUnits: options.categoryAxisDisplayUnits
                    });
                    this.xAxisProperties.axis.tickSize(-this.viewportIn.height, 0);
                    this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                    var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [minY, maxY]);
                    this.yAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: this.viewportIn.height,
                        dataDomain: combinedDomain,
                        metaDataColumn: data.yCol,
                        formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
                        outerPadding: 0,
                        isScalar: true,
                        isVertical: true,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: true,
                        isCategoryAxis: false,
                        scaleType: options.valueAxisScaleType,
                        axisDisplayUnits: options.valueAxisDisplayUnits
                    });
                    this.yAxisProperties.axisLabel = this.data.axesLabels.y;
                    return [this.xAxisProperties, this.yAxisProperties];
                };
                EnhancedScatterChart.prototype.enumerateDataPoints = function (enumeration) {
                    var data = this.data;
                    if (!data)
                        return;
                    var seriesCount = data.dataPoints.length;
                    if (!data.hasDynamicSeries) {
                        // Add default color and show all slices
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            selector: null,
                            properties: {
                                defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                            }
                        }).pushInstance({
                            objectName: 'dataPoint',
                            selector: null,
                            properties: {
                                showAllDataPoints: !!data.showAllDataPoints
                            }
                        });
                        for (var i = 0; i < seriesCount; i++) {
                            var seriesDataPoints = data.dataPoints[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: seriesDataPoints.formattedCategory.getValue(),
                                selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
                                properties: {
                                    fill: { solid: { color: seriesDataPoints.fill } }
                                },
                            });
                        }
                    }
                    else {
                        var legendDataPointLength = data.legendData.dataPoints.length;
                        for (var i = 0; i < legendDataPointLength; i++) {
                            var series = data.legendData.dataPoints[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: series.label,
                                selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                                properties: {
                                    fill: { solid: { color: series.color } }
                                },
                            });
                        }
                    }
                };
                EnhancedScatterChart.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                        case 'dataPoint':
                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                            if (!visuals.GradientUtils.hasGradientRole(categoricalDataView))
                                this.enumerateDataPoints(enumeration);
                            break;
                        case 'categoryAxis':
                            this.getCategoryAxisValues(enumeration);
                            break;
                        case 'valueAxis':
                            this.getValueAxisValues(enumeration);
                            break;
                        case 'categoryLabels':
                            if (this.data)
                                visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, true);
                            else
                                visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, true);
                            break;
                        case 'fillPoint':
                            var sizeRange = this.data.sizeRange;
                            // Check if the card should be shown or not
                            if (sizeRange && sizeRange.min)
                                break;
                            enumeration.pushInstance({
                                objectName: 'fillPoint',
                                selector: null,
                                properties: {
                                    show: this.data.fillPoint,
                                },
                            });
                            break;
                        case 'backdrop':
                            enumeration.pushInstance({
                                objectName: 'backdrop',
                                displayName: 'Backdrop',
                                selector: null,
                                properties: {
                                    show: this.data.backdrop ? this.data.backdrop.show : false,
                                    url: this.data.backdrop ? this.data.backdrop.url : null
                                },
                            });
                            break;
                        case 'crosshair':
                            enumeration.pushInstance({
                                objectName: 'crosshair',
                                selector: null,
                                properties: {
                                    show: this.data.crosshair
                                },
                            });
                            break;
                        case 'outline':
                            enumeration.pushInstance({
                                objectName: 'outline',
                                selector: null,
                                properties: {
                                    show: this.data.outline
                                },
                            });
                            break;
                        case 'legend':
                            this.getLegendValue(enumeration);
                            break;
                    }
                    return enumeration.complete();
                };
                EnhancedScatterChart.prototype.hasLegend = function () {
                    return this.data && this.data.hasDynamicSeries;
                };
                EnhancedScatterChart.prototype.getLegendValue = function (enumeration) {
                    if (!this.hasLegend())
                        return;
                    var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());
                    var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);
                    var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : '');
                    var legendLabelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                    this.legendLabelFontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, EnhancedScatterChart.LegendLabelFontSizeDefault);
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: legendLabelColor,
                            fontSize: this.legendLabelFontSize,
                        },
                        objectName: 'legend'
                    });
                };
                EnhancedScatterChart.prototype.getCategoryAxisValues = function (enumeration) {
                    var supportedType = visuals.axisType.both;
                    var isScalar = true;
                    var logPossible = false;
                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options
                    if (!isScalar) {
                        if (this.categoryAxisProperties) {
                            this.categoryAxisProperties['start'] = null;
                            this.categoryAxisProperties['end'] = null;
                        }
                    }
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: 'categoryAxis',
                        validValues: {
                            axisScale: scaleOptions
                        }
                    };
                    instance.properties['show'] = this.categoryAxisProperties && this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;
                    if (this.yAxisIsCategorical)
                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                    if (supportedType === visuals.axisType.both) {
                        instance.properties['axisType'] = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical;
                    }
                    if (isScalar) {
                        instance.properties['axisScale'] = (this.categoryAxisProperties && this.categoryAxisProperties['axisScale'] != null && logPossible) ? this.categoryAxisProperties['axisScale'] : visuals.axisScale.linear;
                        instance.properties['start'] = this.categoryAxisProperties ? this.categoryAxisProperties['start'] : null;
                        instance.properties['end'] = this.categoryAxisProperties ? this.categoryAxisProperties['end'] : null;
                        instance.properties['labelDisplayUnits'] = this.categoryAxisProperties && this.categoryAxisProperties['labelDisplayUnits'] != null ? this.categoryAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;
                    }
                    instance.properties['showAxisTitle'] = this.categoryAxisProperties && this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : true;
                    enumeration
                        .pushInstance(instance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.categoryAxisProperties && this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.categoryAxisProperties ? this.categoryAxisProperties['labelColor'] : null
                        },
                        objectName: 'categoryAxis',
                        validValues: {
                            axisStyle: this.categoryAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                        }
                    });
                };
                //todo: wrap all these object getters and other related stuff into an interface
                EnhancedScatterChart.prototype.getValueAxisValues = function (enumeration) {
                    var scaleOptions = [visuals.axisScale.log, visuals.axisScale.linear]; //until options can be update in propPane, show all options
                    var logPossible = false;
                    var instance = {
                        selector: null,
                        properties: {},
                        objectName: 'valueAxis',
                        validValues: {
                            axisScale: scaleOptions,
                            secAxisScale: scaleOptions
                        }
                    };
                    instance.properties['show'] = this.valueAxisProperties && this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;
                    if (!this.yAxisIsCategorical) {
                        instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                    }
                    instance.properties['axisScale'] = (this.valueAxisProperties && this.valueAxisProperties['axisScale'] != null && logPossible) ? this.valueAxisProperties['axisScale'] : visuals.axisScale.linear;
                    instance.properties['start'] = this.valueAxisProperties ? this.valueAxisProperties['start'] : null;
                    instance.properties['end'] = this.valueAxisProperties ? this.valueAxisProperties['end'] : null;
                    instance.properties['showAxisTitle'] = this.valueAxisProperties && this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : true;
                    instance.properties['labelDisplayUnits'] = this.valueAxisProperties && this.valueAxisProperties['labelDisplayUnits'] != null ? this.valueAxisProperties['labelDisplayUnits'] : EnhancedScatterChart.LabelDisplayUnitsDefault;
                    enumeration
                        .pushInstance(instance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            axisStyle: this.valueAxisProperties && this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.valueAxisProperties ? this.valueAxisProperties['labelColor'] : null
                        },
                        objectName: 'valueAxis',
                        validValues: {
                            axisStyle: this.valueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                        },
                    });
                };
                EnhancedScatterChart.prototype.onClearSelection = function () {
                    if (this.interactivityService)
                        this.interactivityService.clearSelection();
                };
                EnhancedScatterChart.DefaultBubbleOpacity = 0.85;
                EnhancedScatterChart.DimmedBubbleOpacity = 0.4;
                EnhancedScatterChart.DataLabelsOffset = 5;
                EnhancedScatterChart.ClassName = 'enhancedScatterChart';
                EnhancedScatterChart.MainGraphicsContextClassName = 'mainGraphicsContext';
                EnhancedScatterChart.LegendLabelFontSizeDefault = 9;
                EnhancedScatterChart.LabelDisplayUnitsDefault = 0;
                EnhancedScatterChart.AxisFontSize = 11;
                EnhancedScatterChart.DotClasses = {
                    class: 'dot',
                    selector: '.dot'
                };
                EnhancedScatterChart.ImageClasses = {
                    class: 'img',
                    selector: '.img'
                };
                EnhancedScatterChart.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                        }, {
                            name: 'Series',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                        }, {
                            name: 'X',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_X'),
                        }, {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
                        }, {
                            name: 'Size',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Size'),
                        }, {
                            name: 'Gradient',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                        }, {
                            name: 'ColorFill',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Customized Color',
                        }, {
                            name: 'Shape',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Shape',
                        }, {
                            name: 'Image',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Image',
                        }, {
                            name: 'Rotation',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Rotation',
                        }, {
                            name: 'Backdrop',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Backdrop',
                        }, {
                            name: 'X Start',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'X Start',
                        }, {
                            name: 'X End',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'X End',
                        }, {
                            name: 'Y Start',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Y Start',
                        }, {
                            name: 'Y End',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Y End',
                        }
                    ],
                    dataViewMappings: [{
                            conditions: [{
                                    'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },
                                    'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },
                                    'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },
                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }
                                }, {
                                    'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },
                                    'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 1 }, 'Shape': { max: 1 },
                                    'Image': { max: 0 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },
                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }
                                }, {
                                    'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 },
                                    'Size': { max: 1 }, 'Gradient': { max: 0 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },
                                    'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },
                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }
                                }, {
                                    'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 },
                                    'Size': { max: 1 }, 'Gradient': { max: 1 }, 'ColorFill': { max: 0 }, 'Shape': { max: 0 },
                                    'Image': { max: 1 }, 'Rotation': { max: 1 }, 'Backdrop': { max: 1 }, 'X Start': { max: 1 },
                                    'X End': { max: 1 }, 'Y Start': { max: 1 }, 'Y End': { max: 1 }
                                }],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { sample: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Series',
                                        select: [
                                            { bind: { to: 'X' } },
                                            { bind: { to: 'Y' } },
                                            { bind: { to: 'Size' } },
                                            { bind: { to: 'Gradient' } },
                                            { bind: { to: 'ColorFill' } },
                                            { bind: { to: 'Shape' } },
                                            { bind: { to: 'Image' } },
                                            { bind: { to: 'Rotation' } },
                                            { bind: { to: 'Backdrop' } },
                                            { bind: { to: 'X Start' } },
                                            { bind: { to: 'X End' } },
                                            { bind: { to: 'Y Start' } },
                                            { bind: { to: 'Y End' } },
                                        ],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                },
                                rowCount: { preferred: { min: 2 } }
                            },
                        }],
                    objects: {
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                    type: { bool: true }
                                },
                                useShape: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_UseImage'),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                    type: { fillRule: {} },
                                    rule: {
                                        inputRole: 'Gradient',
                                        output: {
                                            property: 'fill',
                                            selector: ['Category'],
                                        },
                                    }
                                }
                            }
                        },
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        categoryAxis: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                    type: { formatting: { axisScale: true } }
                                },
                                start: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                    type: { numeric: true }
                                },
                                end: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                    type: { numeric: true }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                    type: { bool: true }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                    type: { formatting: { axisStyle: true } }
                                },
                                axisColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                labelDisplayUnits: {
                                    displayName: 'Display Units',
                                    type: { formatting: { labelDisplayUnits: true } },
                                },
                            }
                        },
                        valueAxis: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                                    type: { formatting: { yAxisPosition: true } }
                                },
                                axisScale: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                                    type: { formatting: { axisScale: true } }
                                },
                                start: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                                    type: { numeric: true }
                                },
                                end: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                                    type: { numeric: true }
                                },
                                showAxisTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                    type: { bool: true }
                                },
                                axisStyle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                                    type: { formatting: { axisStyle: true } }
                                },
                                axisColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                labelDisplayUnits: {
                                    displayName: 'Display Units',
                                    type: { formatting: { labelDisplayUnits: true } },
                                }
                            }
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                                    type: { enumeration: visuals.legendPosition.type },
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: 'Legend Name',
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                                    type: { text: true }
                                },
                                labelColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        categoryLabels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                },
                            },
                        },
                        fillPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_FillPoint'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { bool: true }
                                },
                            },
                        },
                        backdrop: {
                            displayName: 'Backdrop',
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                url: {
                                    displayName: 'Image URL',
                                    type: { text: true }
                                },
                            },
                        },
                        crosshair: {
                            displayName: 'Crosshair',
                            properties: {
                                show: {
                                    displayName: 'Crosshair',
                                    type: { bool: true }
                                },
                            },
                        },
                        outline: {
                            displayName: 'Outline',
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                                    type: { bool: true }
                                }
                            }
                        }
                    }
                };
                return EnhancedScatterChart;
            }());
            samples.EnhancedScatterChart = EnhancedScatterChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var THREE;
var WebGLHeatmap;
var GlobeMapCanvasLayers;
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var DataRoleHelper = powerbi.data.DataRoleHelper;
            var GlobeMap = (function () {
                function GlobeMap() {
                    this.renderData = [];
                    this.locationsToLoad = 0;
                    this.locationsLoaded = 0;
                    this.renderLoopEnabled = true;
                    this.needsRender = false;
                }
                GlobeMap.converter = function (dataView) {
                    return {};
                };
                GlobeMap.prototype.init = function (options) {
                    this.container = options.element;
                    this.viewport = options.viewport;
                    this.readyToRender = false;
                    if (!this.globeMapLocationCache)
                        this.globeMapLocationCache = {};
                    if (!THREE) {
                        loadGlobeMapLibs();
                    }
                    if (THREE) {
                        this.setup();
                    }
                };
                GlobeMap.prototype.setup = function () {
                    this.initSettings();
                    this.initTextures();
                    this.initMercartorSphere();
                    this.initZoomControl();
                    this.initScene();
                    this.initHeatmap();
                    this.readyToRender = true;
                    this.composeRenderData();
                    this.initRayCaster();
                };
                GlobeMap.prototype.initSettings = function () {
                    var settings = this.settings = {};
                    settings.autoRotate = false;
                    settings.earthRadius = 30;
                    settings.cameraRadius = 100;
                    settings.earthSegments = 100;
                    settings.heatmapSize = 1000;
                    settings.heatPointSize = 7;
                    settings.heatIntensity = 10;
                    settings.heatmapScaleOnZoom = 0.95;
                    settings.barWidth = 0.3;
                    settings.barHeight = 5;
                    settings.rotateSpeed = 0.5;
                    settings.zoomSpeed = 0.8;
                    settings.cameraAnimDuration = 1000; //ms
                    settings.clickInterval = 200; //ms
                };
                GlobeMap.prototype.initScene = function () {
                    var viewport = this.viewport;
                    var settings = this.settings;
                    var clock = new THREE.Clock();
                    var renderer = this.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                    this.container.append(renderer.domElement);
                    this.domElement = renderer.domElement;
                    var camera = this.camera = new THREE.PerspectiveCamera(35, viewport.width / viewport.height, 0.1, 10000);
                    var orbitControls = this.orbitControls = new THREE.OrbitControls(camera, this.domElement);
                    var scene = this.scene = new THREE.Scene();
                    renderer.setSize(viewport.width, viewport.height);
                    renderer.setClearColor(0xbac4d2, 1);
                    camera.position.z = settings.cameraRadius;
                    orbitControls.maxDistance = settings.cameraRadius;
                    orbitControls.minDistance = settings.earthRadius + 1;
                    orbitControls.rotateSpeed = settings.rotateSpeed;
                    orbitControls.zoomSpeed = settings.zoomSpeed;
                    orbitControls.autoRotate = settings.autoRotate;
                    var ambientLight = new THREE.AmbientLight(0x000000);
                    var light1 = new THREE.DirectionalLight(0xffffff, 0.4);
                    var light2 = new THREE.DirectionalLight(0xffffff, 0.4);
                    var earth = this.earth = this.createEarth();
                    scene.add(ambientLight);
                    scene.add(light1);
                    scene.add(light2);
                    scene.add(earth);
                    light1.position.set(20, 20, 20);
                    light2.position.set(0, 0, -20);
                    var _zis = this;
                    requestAnimationFrame(function render() {
                        try {
                            if (_zis.renderLoopEnabled)
                                requestAnimationFrame(render);
                            if (!_zis.shouldRender())
                                return;
                            orbitControls.update(clock.getDelta());
                            _zis.setEarthTexture();
                            _zis.intersectBars();
                            _zis.heatmap.display(); // Needed for IE/Edge to behave nicely
                            renderer.render(scene, camera);
                            _zis.needsRender = false;
                        }
                        catch (e) {
                            console.error(e);
                        }
                    });
                };
                GlobeMap.prototype.shouldRender = function () {
                    return this.readyToRender && this.needsRender;
                };
                GlobeMap.prototype.createEarth = function () {
                    var geometry = new GlobeMap.MercartorSphere(this.settings.earthRadius, this.settings.earthSegments, this.settings.earthSegments);
                    var material = new THREE.MeshPhongMaterial({
                        map: this.mapTextures[0],
                        side: THREE.DoubleSide,
                        shininess: 1,
                        emissive: 0xaaaaaa,
                    });
                    return new THREE.Mesh(geometry, material);
                };
                GlobeMap.prototype.zoomClicked = function (zoomDirection) {
                    if (this.orbitControls.enabled === false || this.orbitControls.enableZoom === false)
                        return;
                    if (zoomDirection === -1)
                        this.orbitControls.constraint.dollyOut(Math.pow(0.95, this.settings.zoomSpeed));
                    else if (zoomDirection === 1)
                        this.orbitControls.constraint.dollyIn(Math.pow(0.95, this.settings.zoomSpeed));
                    this.orbitControls.update();
                    this.animateCamera(this.camera.position);
                };
                GlobeMap.prototype.rotateCam = function (deltaX, deltaY) {
                    if (this.orbitControls.enabled === false || this.orbitControls.enableRotate === false)
                        return;
                    this.orbitControls.constraint.rotateLeft(2 * Math.PI * deltaX / this.domElement.offsetHeight * this.settings.rotateSpeed);
                    this.orbitControls.constraint.rotateUp(2 * Math.PI * deltaY / this.domElement.offsetHeight * this.settings.rotateSpeed);
                    this.orbitControls.update();
                    this.animateCamera(this.camera.position);
                };
                GlobeMap.prototype.initZoomControl = function () {
                    var _this = this;
                    var radius = 17;
                    var zoomControlWidth = radius * 8.5;
                    var zoomControlHeight = radius * 8.5;
                    var startX = radius * 3;
                    var startY = radius + 3;
                    var gap = radius * 2;
                    var zoomCss = {
                        'position': 'absolute',
                        'left': 'calc(100% - ' + zoomControlWidth + 'px)',
                        'top': 'calc(100% - ' + zoomControlHeight + 'px)',
                        'zIndex': '1000',
                    };
                    var zoomContainer = d3.select(this.container[0])
                        .append('div')
                        .style(zoomCss);
                    this.zoomControl = zoomContainer.append("svg")
                        .attr({
                        "width": zoomControlWidth,
                        "height": zoomControlHeight
                    });
                    var bottom = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(0, -5); });
                    bottom.append("circle").attr({
                        cx: startX + gap,
                        cy: startY + (2 * gap),
                        r: radius,
                        fill: "white",
                        opacity: 0.5,
                        stroke: 'gray',
                    });
                    bottom.append("path").attr({
                        d: "M" + (startX + (2 * radius)) + " " + (startY + (radius * 4.7)) + " l12 -20 a40,70 0 0,1 -24,0z",
                        fill: "gray",
                    });
                    var left = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(5, 0); });
                    left.append("circle").attr({
                        cx: startX,
                        cy: startY + gap,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: 0.5,
                    });
                    left.append("path").attr({
                        d: "M" + (startX - radius / 1.5) + " " + (startY + (radius * 2)) + " l20 -12 a70,40 0 0,0 0,24z",
                        fill: "gray",
                    });
                    var top = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(0, 5); });
                    top.append("circle").attr({
                        cx: startX + gap,
                        cy: startY,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: 0.5,
                    });
                    top.append("path").attr({
                        d: "M" + (startX + (2 * radius)) + " " + (startY - (radius / 1.5)) + " l12 20 a40,70 0 0,0 -24,0z",
                        fill: "gray",
                    });
                    var right = this.zoomControl.append("g").on("click", function () { return _this.rotateCam(-5, 0); });
                    right.append("circle").attr({
                        cx: startX + (2 * gap),
                        cy: startY + gap,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: 0.5,
                    });
                    right.append("path").attr({
                        d: "M" + (startX + (4.7 * radius)) + " " + (startY + (radius * 2)) + " l-20 -12 a70,40 0 0,1 0,24z",
                        fill: "gray",
                    });
                    var zoomIn = this.zoomControl.append("g").on("click", function () { return _this.zoomClicked(-1); });
                    zoomIn.append("circle").attr({
                        cx: startX + 4 * radius,
                        cy: startY + 6 * radius,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: 0.5,
                    });
                    zoomIn.append("rect").attr({
                        x: startX + 3.5 * radius,
                        y: startY + 5.9 * radius,
                        width: radius,
                        height: radius / 3,
                        fill: "gray",
                    });
                    zoomIn.append("rect").attr({
                        x: startX + (4 * radius) - radius / 6,
                        y: startY + 5.55 * radius,
                        width: radius / 3,
                        height: radius,
                        fill: "gray",
                    });
                    var zoomOut = this.zoomControl.append("g").on("click", function () { return _this.zoomClicked(1); });
                    zoomOut.append("circle").attr({
                        cx: startX,
                        cy: startY + 6 * radius,
                        r: radius,
                        fill: "white",
                        stroke: "gray",
                        opacity: "0.50",
                    });
                    zoomOut.append("rect").attr({
                        x: startX - (radius / 2),
                        y: startY + 5.9 * radius,
                        width: radius,
                        height: radius / 3,
                        fill: "gray",
                    });
                };
                GlobeMap.prototype.initTextures = function () {
                    var _this = this;
                    if (!GlobeMapCanvasLayers) {
                        // Initialize once, since this is a CPU + Network heavy operation.
                        GlobeMapCanvasLayers = [];
                        for (var level = 2; level <= 5; ++level) {
                            var canvas = this.getBingMapCanvas(level);
                            GlobeMapCanvasLayers.push(canvas);
                        }
                    }
                    // Can't execute in for loop because variable assignement gets overwritten
                    var createTexture = function (canvas) {
                        var texture = new THREE.Texture(canvas.get(0));
                        texture.needsUpdate = true;
                        canvas.on("ready", function (e, resolution) {
                            //console.log("level ready", resolution, texture)
                            texture.needsUpdate = true;
                            _this.needsRender = true;
                        });
                        return texture;
                    };
                    this.mapTextures = [];
                    for (var i = 0; i < GlobeMapCanvasLayers.length; ++i) {
                        this.mapTextures.push(createTexture(GlobeMapCanvasLayers[i]));
                    }
                };
                GlobeMap.prototype.initHeatmap = function () {
                    var settings = this.settings;
                    //console.log("initHeatmap");
                    try {
                        var heatmap = this.heatmap = new WebGLHeatmap({ width: settings.heatmapSize, height: settings.heatmapSize, intensityToAlpha: true });
                    }
                    catch (e) {
                        // IE & Edge will throw an error about texImage2D, we need to ignore it
                        console.error(e);
                    }
                    // canvas contents will be used for a texture
                    var texture = this.heatTexture = new THREE.Texture(heatmap.canvas);
                    texture.needsUpdate = true;
                    var material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                    var geometry = new THREE.SphereGeometry(settings.earthRadius + 0.01, settings.earthSegments, settings.earthSegments);
                    var mesh = new THREE.Mesh(geometry, material);
                    window["heatmap"] = heatmap;
                    window["heatmapTexture"] = texture;
                    this.scene.add(mesh);
                };
                GlobeMap.prototype.setEarthTexture = function () {
                    //get distance as arbitrary value from 0-1
                    if (!this.camera)
                        return;
                    var maxDistance = this.settings.cameraRadius - this.settings.earthRadius;
                    var distance = (this.camera.position.length() - this.settings.earthRadius) / maxDistance;
                    var texture;
                    if (distance <= 1 / 5) {
                        texture = this.mapTextures[3];
                    }
                    else if (distance <= 2 / 5) {
                        texture = this.mapTextures[2];
                    }
                    else if (distance <= 3 / 5) {
                        texture = this.mapTextures[1];
                    }
                    else {
                        texture = this.mapTextures[0];
                    }
                    if (this.earth.material.map !== texture) {
                        this.earth.material.map = texture;
                    }
                    if (this.selectedBar) {
                        this.orbitControls.rotateSpeed = this.settings.rotateSpeed;
                    }
                    else {
                        this.orbitControls.rotateSpeed = this.settings.rotateSpeed * distance;
                    }
                    //console.log(distance, this.orbitControls.rotateSpeed);
                };
                GlobeMap.prototype.update = function (options) {
                    this.needsRender = true;
                    this.cleanHeatAndBar();
                    if (options.viewport.height !== this.viewport.height || options.viewport.width !== this.viewport.width) {
                        var viewport = this.viewport = options.viewport;
                        if (this.camera && this.renderer) {
                            this.camera.aspect = viewport.width / viewport.height;
                            this.camera.updateProjectionMatrix();
                            this.renderer.setSize(viewport.width, viewport.height);
                        }
                        return;
                    }
                    // PowerBI fires two update calls, one for size, one for data
                    if (options.dataViews[0] && options.dataViews[0].categorical) {
                        this.composeRenderData(options.dataViews[0].categorical);
                    }
                };
                GlobeMap.prototype.cleanHeatAndBar = function () {
                    this.heatmap.clear();
                    this.heatTexture.needsUpdate = true;
                    if (this.barsGroup) {
                        this.scene.remove(this.barsGroup);
                    }
                };
                GlobeMap.prototype.renderMagic = function () {
                    if (!this.readyToRender) {
                        //console.log("not ready to render");
                        this.defferedRender();
                        return;
                    }
                    var renderData = this.renderData;
                    var heatmap = this.heatmap;
                    var settings = this.settings;
                    heatmap.clear();
                    if (this.barsGroup) {
                        this.scene.remove(this.barsGroup);
                    }
                    this.barsGroup = new THREE.Object3D();
                    this.scene.add(this.barsGroup);
                    //colors for stacked vector by series values
                    var barMaterials = [
                        new THREE.MeshPhongMaterial({ color: 0xff00ff, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),
                        new THREE.MeshPhongMaterial({ color: 0xffff1a, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),
                        new THREE.MeshPhongMaterial({ color: 0xff0000, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),
                        new THREE.MeshPhongMaterial({ color: 0x00ffff, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),
                        new THREE.MeshPhongMaterial({ color: 0x994d00, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),
                        new THREE.MeshPhongMaterial({ color: 0xb3cccc, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),
                        new THREE.MeshPhongMaterial({ color: 0xace600, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),
                        new THREE.MeshPhongMaterial({ color: 0x52527a, side: THREE.DoubleSide, shading: THREE.FlatShading, transparent: true }),
                    ];
                    this.averageBarVector = new THREE.Vector3();
                    for (var i = 0, len = renderData.length; i < len; ++i) {
                        var renderDatum = renderData[i];
                        if (!renderDatum.lat || !renderDatum.lng)
                            continue;
                        if (renderDatum.heat > 0.001) {
                            if (renderDatum.heat < 0.1)
                                renderDatum.heat = 0.1;
                            var x = (180 + renderDatum.lng) / 360 * settings.heatmapSize;
                            var y = (1 - ((90 + renderDatum.lat) / 180)) * settings.heatmapSize;
                            heatmap.addPoint(x, y, settings.heatPointSize, renderDatum.heat * settings.heatIntensity);
                        }
                        if (renderDatum.height >= 0) {
                            if (renderDatum.height < 0.01)
                                renderDatum.height = 0.01;
                            var latRadians = renderDatum.lat / 180 * Math.PI; //radians
                            var lngRadians = renderDatum.lng / 180 * Math.PI;
                            var x = Math.cos(lngRadians) * Math.cos(latRadians);
                            var z = -Math.sin(lngRadians) * Math.cos(latRadians);
                            var y = Math.sin(latRadians);
                            var v = new THREE.Vector3(x, y, z);
                            this.averageBarVector.add(v);
                            var barHeight = settings.barHeight * renderDatum.height;
                            //this array holds the relative series values to the actual measure for example [0.2,0.3,0.5]
                            //this is how we draw the vectors relativly to the complete value one on top of another. 
                            var measuresBySeries = [];
                            //this array holds the original values of the series for the tool tips
                            var dataPointToolTip = [];
                            if (renderDatum.heightBySeries) {
                                for (var c = 0; c < renderDatum.heightBySeries.length; c++) {
                                    if (renderDatum.heightBySeries[c])
                                        measuresBySeries.push(renderDatum.heightBySeries[c]);
                                    dataPointToolTip.push(renderDatum.seriesToolTipData[c]);
                                }
                            }
                            else {
                                //no category series so we'll just draw one value
                                measuresBySeries.push(1);
                            }
                            var previousMeasureValue = 0;
                            for (var j = 0; j < measuresBySeries.length; j++) {
                                previousMeasureValue += measuresBySeries[j];
                                var geometry = new THREE.CubeGeometry(settings.barWidth, settings.barWidth, barHeight * measuresBySeries[j]);
                                var bar = new THREE.Mesh(geometry, barMaterials[j % (barMaterials.length - 1)]);
                                bar.position = v.clone().multiplyScalar(settings.earthRadius + ((barHeight / 2) * previousMeasureValue));
                                bar.lookAt(v);
                                bar.toolTipData = dataPointToolTip.length === 0 ? renderDatum.toolTipData : this.getToolTipDataForSeries(renderDatum.toolTipData, dataPointToolTip[j]);
                                this.barsGroup.add(bar);
                                previousMeasureValue += measuresBySeries[j];
                            }
                        }
                    }
                    if (this.barsGroup.children.length > 0 && this.camera) {
                        this.averageBarVector.multiplyScalar(1 / this.barsGroup.children.length);
                        if (this.locationsLoaded === this.locationsToLoad) {
                            this.animateCamera(this.averageBarVector);
                        }
                    }
                    heatmap.update();
                    heatmap.blur();
                    this.heatTexture.needsUpdate = true;
                    this.needsRender = true;
                    //console.log("renderMagic done! locations:", this.barsGroup.children.length, "toload/loaded", this.locationsToLoad, this.locationsLoaded)
                };
                GlobeMap.prototype.getToolTipDataForSeries = function (toolTipData, dataPointToolTip) {
                    var result = jQuery.extend(true, {
                        series: { displayName: dataPointToolTip.displayName, value: dataPointToolTip.value }
                    }, toolTipData);
                    result.height.value = dataPointToolTip.dataPointValue;
                    return result;
                };
                GlobeMap.prototype.composeRenderData = function (categoricalView) {
                    // memoize last value
                    if (categoricalView) {
                        this.categoricalView = categoricalView;
                    }
                    else {
                        categoricalView = this.categoricalView;
                    }
                    this.renderData = [];
                    var locations = [];
                    var globeMapLocationCache = this.globeMapLocationCache;
                    //console.log("categoricalView", categoricalView)
                    if (!categoricalView)
                        return;
                    var categories = categoricalView.categories;
                    var grouped = categoricalView.values.grouped();
                    var heightIndex = 0;
                    var intensityIndex = 0;
                    try {
                        heightIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Height");
                        intensityIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Heat");
                        var longitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "X");
                        var latitudeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
                    }
                    catch (e) { }
                    var locationType, heights, heightsBySeries, toolTipDataBySeries, heats, latitudes, longitudes, locationDispName, heightDispName, heatDispName, heightFormat, heatFormat;
                    if (heightIndex !== undefined && categoricalView.values[heightIndex] && categoricalView.values !== undefined) {
                        var locationCategory = categories[0];
                        locations = locationCategory.values;
                        locationDispName = locationCategory.source.displayName;
                        if (locationCategory.source.type.category) {
                            locationType = locationCategory.source.type.category.toLowerCase();
                        }
                        else {
                            locationType = "";
                        }
                    }
                    else {
                        locations = [];
                    }
                    // For debugging since devTools - salesByCountry isn't really sales by country
                    //var places = ["kenya", "india", "united states", "london", "australia", "canada"]
                    //heightIndex = 0;
                    if (heightIndex !== undefined && categoricalView.values[heightIndex]) {
                        // heights = categoricalView.values[heightIndex].values;
                        heightDispName = categoricalView.values[heightIndex].source.displayName;
                        heightFormat = categoricalView.values[heightIndex].source.format;
                        if (grouped.length > 1) {
                            heights = new Array(locations.length);
                            heightsBySeries = new Array(locations.length);
                            toolTipDataBySeries = new Array(locations.length);
                            //creating a matrix for drawing values by series later.
                            for (var i = 0; i < grouped.length; i++) {
                                var values = grouped[i].values[heightIndex].values;
                                for (var j = 0; j < values.length; j++) {
                                    if (!heights[j])
                                        heights[j] = 0;
                                    heights[j] += values[j] ? values[j] : 0;
                                    if (!heightsBySeries[j])
                                        heightsBySeries[j] = [];
                                    heightsBySeries[j][i] = values[j];
                                    if (!toolTipDataBySeries[j])
                                        toolTipDataBySeries[j] = [];
                                    toolTipDataBySeries[j][i] = { displayName: categoricalView.values.source.displayName, value: grouped[i].name, dataPointValue: values[j] };
                                }
                            }
                            for (var i = 0; i < grouped.length; i++) {
                                var values = grouped[i].values[heightIndex].values;
                                for (var j = 0; j < values.length; j++) {
                                    //calculating relative size of series
                                    heightsBySeries[j][i] = values[j] / heights[j];
                                }
                            }
                        }
                        else {
                            heights = categoricalView.values[heightIndex].values;
                            heightsBySeries = new Array(grouped.length);
                        }
                    }
                    else {
                        heightsBySeries = new Array(locations.length);
                        heights = new Array(locations.length);
                    }
                    if (intensityIndex !== undefined && categoricalView.values[intensityIndex]) {
                        if (grouped.length > 1) {
                            heats = new Array(locations.length);
                            for (var i = 0; i < grouped.length; i++) {
                                var values = grouped[i].values[intensityIndex].values;
                                for (var j = 0; j < values.length; j++) {
                                    if (!heats[j])
                                        heats[j] = 0;
                                    heats[j] += values[j] ? values[j] : 0;
                                }
                            }
                        }
                        else {
                            heats = categoricalView.values[intensityIndex].values;
                        }
                        heatDispName = categoricalView.values[intensityIndex].source.displayName;
                        heatFormat = categoricalView.values[intensityIndex].source.format;
                    }
                    else {
                        heats = new Array(locations.length);
                    }
                    if (longitudeIndex !== undefined && categoricalView.values[longitudeIndex]
                        && latitudeIndex !== undefined && categoricalView.values[latitudeIndex]) {
                        longitudes = categoricalView.values[longitudeIndex].values;
                        latitudes = categoricalView.values[latitudeIndex].values;
                    }
                    else {
                        longitudes = null;
                        latitudes = null;
                    }
                    var maxHeight = Math.max.apply(null, heights) || 1;
                    var maxHeat = Math.max.apply(null, heats) || 1;
                    var heatFormatter = visuals.valueFormatter.create({ format: heatFormat, value: heats[0], value2: heats[1] });
                    var heightFormatter = visuals.valueFormatter.create({ format: heightFormat, value: heights[0], value2: heights[1] });
                    for (var i = 0, len = locations.length; i < len; ++i) {
                        var place = locations[i];
                        var lat, lng, latlng, height, heat;
                        //place = places[i];
                        if (place && typeof (place) === "string") {
                            place = place.toLowerCase();
                            var placeKey = place + "/" + locationType;
                            if (!longitudes && globeMapLocationCache[placeKey]) {
                                latlng = globeMapLocationCache[placeKey];
                                lat = latlng.latitude;
                                lng = latlng.longitude;
                            }
                            else if (longitudes) {
                                lat = latitudes[i];
                                lng = longitudes[i];
                            }
                            height = heights[i] / maxHeight;
                            heat = heats[i] / maxHeat;
                            var renderDatum = {
                                lat: lat,
                                lng: lng,
                                height: height ? height || 0.01 : undefined,
                                heightBySeries: heightsBySeries[i],
                                seriesToolTipData: toolTipDataBySeries ? toolTipDataBySeries[i] : undefined,
                                heat: heat || 0,
                                toolTipData: {
                                    location: { displayName: locationDispName, value: locations[i] },
                                    height: { displayName: heightDispName, value: heightFormatter.format(heights[i]) },
                                    heat: { displayName: heatDispName, value: heatFormatter.format(heats[i]) }
                                }
                            };
                            this.renderData.push(renderDatum);
                            if (!longitudes && !latlng) {
                                this.geocodeRenderDatum(renderDatum, place, locationType);
                            }
                        }
                    }
                    try {
                        this.renderMagic();
                    }
                    catch (e) {
                        console.error(e);
                    }
                };
                GlobeMap.prototype.geocodeRenderDatum = function (renderDatum, place, locationType) {
                    var _this = this;
                    var placeKey = place + "/" + locationType;
                    this.globeMapLocationCache[placeKey] = {}; //store empty object so we don't send AJAX request again
                    this.locationsToLoad++;
                    try {
                        var geocoder = powerbi.visuals["BI"].Services.GeocodingManager.geocode;
                    }
                    catch (e) {
                        geocoder = visuals.services.geocode;
                    }
                    if (geocoder) {
                        geocoder(place, locationType).always(function (latlng) {
                            // we use always because we want to cache unknown values. 
                            // No point asking bing again and again when it tells us it doesn't know about a location
                            _this.globeMapLocationCache[placeKey] = latlng;
                            _this.locationsLoaded++;
                            //console.log(place, latlng);
                            if (latlng.latitude && latlng.longitude) {
                                renderDatum.lat = latlng.latitude;
                                renderDatum.lng = latlng.longitude;
                                _this.defferedRender();
                            }
                        });
                    }
                };
                GlobeMap.prototype.defferedRender = function () {
                    var _this = this;
                    if (!this.deferredRenderTimerId) {
                        this.deferredRenderTimerId = setTimeout(function () {
                            _this.deferredRenderTimerId = null;
                            _this.composeRenderData();
                        }, 500);
                    }
                };
                GlobeMap.prototype.initRayCaster = function () {
                    var _this = this;
                    this.rayCaster = new THREE.Raycaster();
                    var settings = this.settings;
                    var mousePosNormalized = this.mousePosNormalized = new THREE.Vector2();
                    var mousePos = this.mousePos = new THREE.Vector2();
                    var element = this.container.get(0);
                    var mouseDownTime;
                    $(this.domElement).on("mousemove", function (event) {
                        // get coordinates in -1 to +1 space
                        var rect = element.getBoundingClientRect();
                        mousePos.x = event.clientX;
                        mousePos.y = event.clientY;
                        mousePosNormalized.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                        mousePosNormalized.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                        _this.needsRender = true;
                    }).on("mousedown", function (event) {
                        mouseDownTime = Date.now();
                    }).on("mouseup", function (event) {
                        // Debounce slow clicks
                        if ((Date.now() - mouseDownTime) > settings.clickInterval)
                            return;
                        if (_this.hoveredBar && event.shiftKey) {
                            _this.selectedBar = _this.hoveredBar;
                            _this.animateCamera(_this.selectedBar.position, function () {
                                if (!_this.selectedBar)
                                    return;
                                _this.orbitControls.center.copy(_this.selectedBar.position.clone().normalize().multiplyScalar(settings.earthRadius));
                                _this.orbitControls.minDistance = 1;
                            });
                        }
                        else {
                            if (_this.selectedBar) {
                                _this.animateCamera(_this.selectedBar.position, function () {
                                    _this.orbitControls.center.set(0, 0, 0);
                                    _this.orbitControls.minDistance = settings.earthRadius + 1;
                                });
                                _this.selectedBar = null;
                            }
                        }
                    }).on("mousewheel DOMMouseScroll", function (e) {
                        _this.needsRender = true;
                        if (_this.orbitControls.enabled && _this.orbitControls.enableZoom) {
                            _this.heatTexture.needsUpdate = true;
                            e = e.originalEvent;
                            var delta = e.wheelDelta > 0 || e.detail < 0 ? 1 : -1;
                            var scale = delta > 0 ? _this.settings.heatmapScaleOnZoom : (1 / _this.settings.heatmapScaleOnZoom);
                            _this.heatmap.multiply(scale);
                            _this.heatmap.update();
                        }
                    });
                };
                GlobeMap.prototype.intersectBars = function () {
                    if (!this.rayCaster || !this.barsGroup)
                        return;
                    var rayCaster = this.rayCaster;
                    rayCaster.setFromCamera(this.mousePosNormalized, this.camera);
                    var intersects = rayCaster.intersectObjects(this.barsGroup.children);
                    if (intersects && intersects.length > 0) {
                        //console.log(intersects[0], this.mousePos.x, this.mousePos.y);
                        var object = intersects[0].object;
                        if (!object || !object.toolTipData)
                            return;
                        var toolTipData = object.toolTipData;
                        var toolTipItems = [];
                        if (toolTipData.location.displayName)
                            toolTipItems.push(toolTipData.location);
                        if (toolTipData.series)
                            toolTipItems.push(toolTipData.series);
                        if (toolTipData.height.displayName)
                            toolTipItems.push(toolTipData.height);
                        if (toolTipData.heat.displayName)
                            toolTipItems.push(toolTipData.heat);
                        this.hoveredBar = object;
                        visuals.TooltipManager.ToolTipInstance.show(toolTipItems, { x: this.mousePos.x, y: this.mousePos.y, width: 0, height: 0 });
                    }
                    else {
                        this.hoveredBar = null;
                        visuals.TooltipManager.ToolTipInstance.hide();
                    }
                };
                GlobeMap.prototype.animateCamera = function (to, done) {
                    var _this = this;
                    if (!this.camera)
                        return;
                    var startTime = Date.now();
                    var duration = this.settings.cameraAnimDuration;
                    var endTime = startTime + duration;
                    var startPos = this.camera.position.clone().normalize();
                    var endPos = to.clone().normalize();
                    var length = this.camera.position.length();
                    var easeInOut = function (t) {
                        t *= 2;
                        if (t < 1)
                            return (t * t * t) / 2;
                        t -= 2;
                        return (t * t * t + 2) / 2;
                    };
                    var onUpdate = function () {
                        var now = Date.now();
                        var t = (now - startTime) / duration;
                        if (t > 1)
                            t = 1;
                        t = easeInOut(t);
                        var pos = new THREE.Vector3()
                            .add(startPos.clone().multiplyScalar(1 - t))
                            .add(endPos.clone().multiplyScalar(t))
                            .normalize()
                            .multiplyScalar(length);
                        _this.camera.position = pos;
                        if (now < endTime) {
                            requestAnimationFrame(onUpdate);
                        }
                        else if (done) {
                            done();
                        }
                        _this.needsRender = true;
                    };
                    requestAnimationFrame(onUpdate);
                };
                GlobeMap.prototype.destroy = function () {
                    clearTimeout(this.deferredRenderTimerId);
                    this.renderLoopEnabled = false;
                    this.scene = null;
                    this.heatmap = null;
                    this.heatTexture = null;
                    this.camera = null;
                    if (this.renderer) {
                        if (this.renderer.context) {
                            var extension = this.renderer.context.getExtension('WEBGL_lose_context');
                            if (extension)
                                extension.loseContext();
                            this.renderer.context = null;
                        }
                        this.renderer.domElement = null;
                    }
                    this.renderer = null;
                    this.renderData = null;
                    this.barsGroup = null;
                    if (this.orbitControls)
                        this.orbitControls.dispose();
                    this.orbitControls = null;
                    if (this.domElement)
                        $(this.domElement)
                            .off("mousemove mouseup mousedown mousewheel DOMMouseScroll");
                    this.domElement = null;
                    if (this.container)
                        this.container.empty();
                };
                GlobeMap.prototype.initMercartorSphere = function () {
                    if (GlobeMap.MercartorSphere)
                        return;
                    var MercartorSphere = function (radius, widthSegments, heightSegments) {
                        THREE.Geometry.call(this);
                        this.radius = radius;
                        this.widthSegments = widthSegments;
                        this.heightSegments = heightSegments;
                        this.t = 0;
                        var x, y, vertices = [], uvs = [];
                        function interplolate(a, b, t) {
                            return (1 - t) * a + t * b;
                        }
                        // interpolates between sphere and plane
                        function interpolateVertex(u, v, t) {
                            var maxLng = Math.PI * 2;
                            var maxLat = Math.PI;
                            var radius = this.radius;
                            var sphereX = -radius * Math.cos(u * maxLng) * Math.sin(v * maxLat);
                            var sphereY = -radius * Math.cos(v * maxLat);
                            var sphereZ = radius * Math.sin(u * maxLng) * Math.sin(v * maxLat);
                            var planeX = u * radius * 2 - radius;
                            var planeY = v * radius * 2 - radius;
                            var planeZ = 0;
                            var x = interplolate(sphereX, planeX, t);
                            var y = interplolate(sphereY, planeY, t);
                            var z = interplolate(sphereZ, planeZ, t);
                            return new THREE.Vector3(x, y, z);
                        }
                        // http://mathworld.wolfram.com/MercatorProjection.html
                        // Mercator projection goes form +85.05 to -85.05 degrees
                        function interpolateUV(u, v, t) {
                            var lat = (v - 0.5) * 90 * 2 / 180 * Math.PI; //turn from 0-1 into lat in radians
                            var sin = Math.sin(lat);
                            var normalizedV = 0.5 + 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;
                            return new THREE.Vector2(u, normalizedV); //interplolate(normalizedV1, v, t))
                        }
                        for (y = 0; y <= heightSegments; y++) {
                            var verticesRow = [];
                            var uvsRow = [];
                            for (x = 0; x <= widthSegments; x++) {
                                var u = x / widthSegments;
                                var v = y / heightSegments;
                                this.vertices.push(interpolateVertex.call(this, u, v, this.t));
                                uvsRow.push(interpolateUV.call(this, u, v, this.t));
                                verticesRow.push(this.vertices.length - 1);
                            }
                            vertices.push(verticesRow);
                            uvs.push(uvsRow);
                        }
                        //console.log(vertices, uvs);
                        for (y = 0; y < this.heightSegments; y++) {
                            for (x = 0; x < this.widthSegments; x++) {
                                var v1 = vertices[y][x + 1];
                                var v2 = vertices[y][x];
                                var v3 = vertices[y + 1][x];
                                var v4 = vertices[y + 1][x + 1];
                                var n1 = this.vertices[v1].clone().normalize();
                                var n2 = this.vertices[v2].clone().normalize();
                                var n3 = this.vertices[v3].clone().normalize();
                                var n4 = this.vertices[v4].clone().normalize();
                                var uv1 = uvs[y][x + 1].clone();
                                var uv2 = uvs[y][x].clone();
                                var uv3 = uvs[y + 1][x].clone();
                                var uv4 = uvs[y + 1][x + 1].clone();
                                var normals = [n1, n2, n3, n4];
                                this.faces.push(new THREE.Face4(v1, v2, v3, v4, normals));
                                this.faceVertexUvs[0].push([uv1, uv2, uv3, uv4]);
                            }
                        }
                        this.computeCentroids();
                        this.computeFaceNormals();
                        this.boundingSphere = new THREE.Sphere(new THREE.Vector3(), radius);
                    };
                    MercartorSphere.prototype = Object.create(THREE.Geometry.prototype);
                    GlobeMap.MercartorSphere = MercartorSphere;
                };
                GlobeMap.prototype.getBingMapCanvas = function (resolution) {
                    var tileSize = 256;
                    var numSegments = Math.pow(2, resolution);
                    var numTiles = numSegments * numSegments;
                    var tilesLoaded = 0;
                    var canvasSize = tileSize * numSegments;
                    var canvas = $('<canvas/>').attr({ width: canvasSize, height: canvasSize });
                    var canvasElem = canvas.get(0);
                    var canvasContext = canvasElem.getContext("2d");
                    function generateQuads(res, quad) {
                        if (res <= resolution) {
                            if (res === resolution) {
                                loadTile(quad);
                            }
                            generateQuads(res + 1, quad + "0");
                            generateQuads(res + 1, quad + "1");
                            generateQuads(res + 1, quad + "2");
                            generateQuads(res + 1, quad + "3");
                        }
                    }
                    function loadTile(quad) {
                        var template = "https://t{server}.tiles.virtualearth.net/tiles/r{quad}.jpeg?g=0&mkt={language}";
                        var numServers = 7;
                        var server = Math.round(Math.random() * numServers);
                        var language = (navigator["languages"] && navigator["languages"].length) ? navigator["languages"][0] : navigator.language;
                        var url = template.replace("{server}", server)
                            .replace("{quad}", quad)
                            .replace("{language}", language);
                        var coords = getCoords(quad);
                        //console.log(quad, coords.x, coords.y)
                        var tile = new Image();
                        tile.onload = function () {
                            tilesLoaded++;
                            canvasContext.drawImage(tile, coords.x * tileSize, coords.y * tileSize, tileSize, tileSize);
                            if (tilesLoaded === numTiles) {
                                canvas.trigger("ready", resolution);
                            }
                        };
                        // So the canvas doesn't get tainted
                        tile.crossOrigin = '';
                        tile.src = url;
                    }
                    function getCoords(quad) {
                        var x = 0;
                        var y = 0;
                        var last = quad.length - 1;
                        for (var i = last; i >= 0; i--) {
                            var chr = quad.charAt(i);
                            var pow = Math.pow(2, last - i);
                            if (chr === "1") {
                                x += pow;
                            }
                            else if (chr === "2") {
                                y += pow;
                            }
                            else if (chr === "3") {
                                x += pow;
                                y += pow;
                            }
                        }
                        return { x: x, y: y };
                    }
                    generateQuads(0, "");
                    return canvas;
                };
                GlobeMap.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
                            preferredTypes: [
                                { geography: { address: true } },
                                { geography: { city: true } },
                                { geography: { continent: true } },
                                { geography: { country: true } },
                                { geography: { county: true } },
                                { geography: { place: true } },
                                { geography: { postalCode: true } },
                                { geography: { region: true } },
                                { geography: { stateOrProvince: true } },
                            ],
                        },
                        {
                            name: 'Series',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Legend",
                        },
                        {
                            name: 'X',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Longitude',
                            description: 'Use to override the longitude of locations',
                            preferredTypes: [{ geography: { longitude: true } }],
                        },
                        {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Latitude',
                            description: 'Use to override the latitude of locations',
                            preferredTypes: [{ geography: { latitude: true } }],
                        },
                        {
                            name: 'Height',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Bar Height',
                        },
                        {
                            name: 'Heat',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Heat Intensity',
                        }
                    ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    type: { formatting: { legendPosition: true } }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleText'),
                                    type: { text: true }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            properties: {
                                defaultColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                showAllDataPoints: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fillRule: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                    type: { fillRule: {} },
                                    rule: {
                                        inputRole: 'Gradient',
                                        output: {
                                            property: 'fill',
                                            selector: ['Category'],
                                        },
                                    },
                                }
                            }
                        },
                        categoryLabels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                            },
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Series': { max: 1 }, 'Height': { max: 1 }, 'Heat': { max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Series',
                                        select: [
                                            { bind: { to: 'Height' } },
                                            { bind: { to: 'Heat' } },
                                            { bind: { to: 'X' } },
                                            { bind: { to: 'Y' } },
                                        ],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                },
                                rowCount: { preferred: { min: 2 } }
                            },
                        }],
                    sorting: {
                        custom: {},
                    }
                };
                return GlobeMap;
            }());
            samples.GlobeMap = GlobeMap;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
function loadGlobeMapLibs() {
    // include GlobeMapLibs.js
}
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var PixelConverter = jsCommon.PixelConverter;
            /**
             * RadarChartBehavior
             */
            var RadarChartWebBehavior = (function () {
                function RadarChartWebBehavior() {
                }
                RadarChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    var selection = this.selection = options.selection;
                    var clearCatcher = options.clearCatcher;
                    selection.on('click', function (d) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        d3.event.stopPropagation();
                    });
                    clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                RadarChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                    this.selection.style("opacity", function (d) { return (hasSelection && !d.selected) ? RadarChart.DimmedAreaFillOpacity : RadarChart.AreaFillOpacity; });
                };
                return RadarChartWebBehavior;
            }());
            samples.RadarChartWebBehavior = RadarChartWebBehavior;
            var RadarChart = (function () {
                function RadarChart(options) {
                    if (options) {
                        if (options.svg)
                            this.svg = options.svg;
                        if (options.animator)
                            this.animator = options.animator;
                        if (options.margin)
                            this.margin = options.margin;
                    }
                }
                RadarChart.converter = function (dataView, colors) {
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !(dataView.categorical.categories.length > 0) ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.values ||
                        !(dataView.categorical.values.length > 0)) {
                        return {
                            legendData: {
                                dataPoints: []
                            },
                            settings: {
                                showLegend: true
                            },
                            series: [],
                            dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                        };
                    }
                    var catDv = dataView.categorical;
                    var values = catDv.values;
                    var series = [];
                    var colorHelper = new visuals.ColorHelper(colors, RadarChart.Properties.dataPoint.fill);
                    var legendData = {
                        fontSize: 8.25,
                        dataPoints: [],
                        title: ""
                    };
                    //Parse legend settings          
                    var legendSettings = RadarChart.parseSettings(dataView);
                    var dataLabelsSettings = RadarChart.parseLabelSettings(dataView);
                    for (var i = 0, iLen = values.length; i < iLen; i++) {
                        var color = colors.getColorByIndex(i).value, serieIdentity = void 0, queryName = void 0, displayName = void 0, dataPoints = [];
                        if (values[i].source) {
                            var source = values[i].source;
                            if (source.queryName) {
                                queryName = source.queryName;
                                serieIdentity = visuals.SelectionId.createWithMeasure(queryName);
                            }
                            if (source.displayName)
                                displayName = source.displayName;
                            if (source.objects) {
                                var objects = source.objects;
                                color = colorHelper.getColorForMeasure(objects, queryName);
                            }
                        }
                        legendData.dataPoints.push({
                            label: displayName,
                            color: color,
                            icon: visuals.LegendIcon.Box,
                            selected: false,
                            identity: serieIdentity
                        });
                        for (var k = 0, kLen = values[i].values.length; k < kLen; k++) {
                            var dataPointIdentity = visuals.SelectionIdBuilder
                                .builder()
                                .withMeasure(queryName)
                                .withCategory(catDv.categories[0], k)
                                .withSeries(dataView.categorical.values, dataView.categorical.values[i])
                                .createSelectionId();
                            var tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(RadarChart.formatStringProp, catDv, catDv.categories[0].values[k], values[i].values[k], null, null, i);
                            var labelFormatString = visuals.valueFormatter.getFormatString(catDv.values[i].source, RadarChart.formatStringProp);
                            var fontSizeInPx = jsCommon.PixelConverter.fromPoint(dataLabelsSettings.fontSize);
                            dataPoints.push({
                                x: k,
                                y: values[i].values[k],
                                color: color,
                                identity: dataPointIdentity,
                                selected: false,
                                tooltipInfo: tooltipInfo,
                                value: values[i].values[k],
                                labelFormatString: labelFormatString,
                                labelFontSize: fontSizeInPx,
                            });
                        }
                        if (dataPoints.length > 0)
                            series.push({
                                fill: color,
                                name: displayName,
                                data: dataPoints,
                                identity: serieIdentity,
                            });
                    }
                    return {
                        legendData: legendData,
                        settings: legendSettings,
                        series: series,
                        dataLabelsSettings: dataLabelsSettings,
                    };
                };
                RadarChart.prototype.init = function (options) {
                    var element = options.element;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    if (!this.svg) {
                        this.svg = d3.select(element.get(0)).append('svg');
                        this.svg.style('position', 'absolute');
                    }
                    if (!this.margin)
                        this.margin = RadarChart.DefaultMargin;
                    this.svg.classed(RadarChart.VisualClassName, true);
                    this.interactivityService = visuals.createInteractivityService(options.host);
                    this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
                    this.legend = visuals.createLegend(element, this.isInteractiveChart, this.interactivityService, true, visuals.LegendPosition.Top);
                    this.colors = options.style.colorPalette.dataColors;
                    this.mainGroupElement = this.svg.append('g');
                    this.segments = this.mainGroupElement
                        .append('g')
                        .classed(RadarChart.Segments.class, true);
                    this.axis = this.mainGroupElement
                        .append('g')
                        .classed(RadarChart.Axis.class, true);
                    this.chart = this.mainGroupElement
                        .append('g')
                        .classed(RadarChart.Chart.class, true);
                };
                RadarChart.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    var dataView = options.dataViews[0];
                    this.radarChartData = RadarChart.converter(dataView, this.colors);
                    var categories = [], series = this.radarChartData.series, dataViewMetadataColumn, duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, options.suppressAnimations);
                    if (dataView.categorical &&
                        dataView.categorical.categories &&
                        dataView.categorical.categories[0] &&
                        dataView.categorical.categories[0].values)
                        categories = dataView.categorical.categories[0].values;
                    if (dataView.metadata && dataView.metadata.columns && dataView.metadata.columns.length > 0)
                        dataViewMetadataColumn = dataView.metadata.columns[0];
                    this.viewport = {
                        height: options.viewport.height > 0 ? options.viewport.height : 0,
                        width: options.viewport.width > 0 ? options.viewport.width : 0
                    };
                    this.parseLegendProperties(dataView);
                    this.renderLegend(this.radarChartData);
                    this.updateViewport();
                    this.svg
                        .attr({
                        'height': this.viewport.height,
                        'width': this.viewport.width
                    });
                    var mainGroup = this.mainGroupElement;
                    mainGroup.attr('transform', visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                    var width = this.viewport.width - this.margin.left - this.margin.right;
                    var height = this.viewport.height - this.margin.top - this.margin.bottom;
                    this.angle = RadarChart.Radians / categories.length;
                    this.radius = RadarChart.SegmentFactor * RadarChart.Scale * Math.min(width, height) / 2;
                    this.drawCircularSegments(categories);
                    this.drawAxes(categories);
                    this.drawAxesLabels(categories, dataViewMetadataColumn);
                    this.drawChart(series, duration);
                    this.drawDataLabels(series);
                };
                RadarChart.prototype.getRadarChartLabelLayout = function (labelSettings, allDataPoints) {
                    var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
                    var angle = this.angle;
                    var radius = this.radius;
                    var dataPoints = this.getDataPoints(this.radarChartData.series);
                    var stack = d3.layout.stack();
                    var layers = stack(dataPoints);
                    var viewport = this.viewport;
                    var halfHeight = this.viewport.height / 2;
                    var halfWidth = this.viewport.width / 2;
                    var y = d3.scale.linear()
                        .domain([0, d3.max(layers, function (layer) {
                            return d3.max(layer, function (d) {
                                return d.y0 + d.y;
                            });
                        })]).range([0, radius]);
                    return {
                        labelText: function (d) {
                            var formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings);
                            if (labelSettings.displayUnits === 0) {
                                var maxDataPoint = _.max(allDataPoints, function (d) { return d.value; });
                                var maxValue = maxDataPoint.value > 0 ? maxDataPoint.value : 0;
                                formmater = formattersCache.getOrCreate(d.labelFormatString, labelSettings, maxValue);
                            }
                            return visuals.dataLabelUtils.getLabelFormattedText({ label: formmater.format(d.value), maxWidth: viewport.width, fontSize: labelSettings.fontSize });
                        },
                        labelLayout: {
                            x: function (d) { return -1 * y(d.y) * Math.sin(d.x * angle) + halfWidth; },
                            y: function (d) { return -1 * y(d.y) * Math.cos(d.x * angle) + halfHeight - 10; },
                        },
                        filter: function (d) {
                            return (d != null && d.value != null);
                        },
                        style: {
                            'fill': labelSettings.labelColor,
                            'font-size': function (d) { return PixelConverter.fromPoint(labelSettings.fontSize); },
                        },
                    };
                };
                RadarChart.prototype.drawCircularSegments = function (values) {
                    var data = [];
                    var angle = this.angle, factor = RadarChart.SegmentFactor, levels = RadarChart.SegmentLevels, radius = this.radius;
                    for (var level = 0; level < levels - 1; level++) {
                        var levelFactor = radius * ((level + 1) / levels);
                        var transform = -1 * levelFactor;
                        for (var i = 0; i < values.length; i++)
                            data.push({
                                x1: levelFactor * (1 - factor * Math.sin(i * angle)),
                                y1: levelFactor * (1 - factor * Math.cos(i * angle)),
                                x2: levelFactor * (1 - factor * Math.sin((i + 1) * angle)),
                                y2: levelFactor * (1 - factor * Math.cos((i + 1) * angle)),
                                translate: visuals.SVGUtil.translate(transform, transform)
                            });
                    }
                    var selection = this.mainGroupElement
                        .select(RadarChart.Segments.selector)
                        .selectAll(RadarChart.SegmentNode.selector)
                        .data(data);
                    selection
                        .enter()
                        .append('svg:line')
                        .classed(RadarChart.SegmentNode.class, true);
                    selection
                        .attr({
                        'x1': function (item) { return item.x1; },
                        'y1': function (item) { return item.y1; },
                        'x2': function (item) { return item.x2; },
                        'y2': function (item) { return item.y2; },
                        'transform': function (item) { return item.translate; }
                    });
                    selection.exit().remove();
                };
                RadarChart.prototype.drawDataLabels = function (series) {
                    var allDataPoints = this.getAllDataPointsList(series);
                    if (this.radarChartData.dataLabelsSettings.show) {
                        var layout = this.getRadarChartLabelLayout(this.radarChartData.dataLabelsSettings, allDataPoints);
                        var viewport = this.viewport;
                        var labels = visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(allDataPoints, this.mainGroupElement, layout, viewport);
                        if (labels)
                            labels.attr('transform', visuals.SVGUtil.translate(-(viewport.width / 2), -(viewport.height / 2)));
                    }
                    else
                        visuals.dataLabelUtils.cleanDataLabels(this.mainGroupElement);
                };
                RadarChart.prototype.drawAxes = function (values) {
                    var angle = this.angle, radius = -1 * this.radius;
                    var selection = this.mainGroupElement
                        .select(RadarChart.Axis.selector)
                        .selectAll(RadarChart.AxisNode.selector);
                    var axis = selection.data(values);
                    axis
                        .enter()
                        .append('svg:line');
                    axis
                        .attr({
                        'x1': 0,
                        'y1': 0,
                        'x2': function (name, i) { return radius * Math.sin(i * angle); },
                        'y2': function (name, i) { return radius * Math.cos(i * angle); }
                    })
                        .classed(RadarChart.AxisNode.class, true);
                    axis.exit().remove();
                };
                RadarChart.prototype.drawAxesLabels = function (values, dataViewMetadataColumn) {
                    var angle = this.angle, radius = -1 * this.radius, length = values.length;
                    var formatter = visuals.valueFormatter.create({
                        format: visuals.valueFormatter.getFormatString(dataViewMetadataColumn, RadarChart.formatStringProp, true),
                        value: values[0],
                        value2: values[length - 1],
                    });
                    var selection = this.mainGroupElement
                        .select(RadarChart.Axis.selector)
                        .selectAll(RadarChart.AxisLabel.selector);
                    var labels = selection.data(values);
                    labels
                        .enter()
                        .append('svg:text');
                    labels
                        .attr({
                        'text-anchor': 'middle',
                        'dy': '1.5em',
                        'transform': visuals.SVGUtil.translate(0, -10),
                        'x': function (name, i) { return (radius - 20) * Math.sin(i * angle); },
                        'y': function (name, i) { return (radius - 10) * Math.cos(i * angle); }
                    })
                        .text(function (item) { return formatter.format(item); })
                        .classed(RadarChart.AxisLabel.class, true);
                    labels.exit().remove();
                };
                RadarChart.prototype.drawChart = function (series, duration) {
                    var angle = this.angle, radius = this.radius, dotRadius = 5, dataPoints = this.getDataPoints(series);
                    var stack = d3.layout.stack();
                    var layers = stack(dataPoints);
                    var y = d3.scale.linear()
                        .domain([0, d3.max(layers, function (layer) {
                            return d3.max(layer, function (d) {
                                return d.y0 + d.y;
                            });
                        })]).range([0, radius]);
                    var calculatePoints = function (points) {
                        return points.map(function (value) {
                            var x1 = -1 * y(value.y) * Math.sin(value.x * angle);
                            var y1 = -1 * y(value.y) * Math.cos(value.x * angle);
                            return x1 + "," + y1;
                        }).join(' ');
                    };
                    var selection = this.chart.selectAll(RadarChart.ChartNode.selector).data(layers);
                    selection
                        .enter()
                        .append('g')
                        .classed(RadarChart.ChartNode.class, true);
                    var polygon = selection.selectAll(RadarChart.ChartPolygon.selector).data(function (d) {
                        if (d && d.length > 0) {
                            return [d];
                        }
                        return [];
                    });
                    polygon
                        .enter()
                        .append('polygon')
                        .classed(RadarChart.ChartPolygon.class, true);
                    polygon
                        .style('fill', function (d) { return d[0].color; })
                        .style('opacity', RadarChart.DimmedAreaFillOpacity)
                        .on('mouseover', function (d) {
                        d3.select(this).transition()
                            .duration(duration)
                            .style('opacity', RadarChart.AreaFillOpacity);
                    })
                        .on('mouseout', function (d) {
                        d3.select(this).transition()
                            .duration(duration)
                            .style('opacity', RadarChart.DimmedAreaFillOpacity);
                    })
                        .attr('points', calculatePoints);
                    polygon.exit().remove();
                    var dots = selection.selectAll(RadarChart.ChartDot.selector)
                        .data(function (d) { return d.filter(function (d) { return d.y != null; }); });
                    dots.enter()
                        .append('svg:circle')
                        .classed(RadarChart.ChartDot.class, true);
                    dots.attr('r', dotRadius)
                        .attr({
                        'cx': function (value) { return -1 * y(value.y) * Math.sin(value.x * angle); },
                        'cy': function (value) { return -1 * y(value.y) * Math.cos(value.x * angle); }
                    })
                        .style('fill', function (d) { return d.color; });
                    dots.exit().remove();
                    visuals.TooltipManager.addTooltip(dots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                    selection.exit().remove();
                    var behaviorOptions = undefined;
                    if (this.interactivityService) {
                        // Register interactivity
                        var dataPointsToBind = this.getAllDataPointsList(series);
                        behaviorOptions = { selection: dots, clearCatcher: this.svg };
                        this.interactivityService.bind(dataPointsToBind, new RadarChartWebBehavior(), behaviorOptions);
                    }
                };
                RadarChart.prototype.renderLegend = function (radarChartData) {
                    if (!radarChartData.legendData)
                        return;
                    var legendData = radarChartData.legendData;
                    if (this.legendObjectProperties) {
                        visuals.LegendData.update(legendData, this.legendObjectProperties);
                        var position = this.legendObjectProperties[visuals.legendProps.position];
                        if (position)
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                    }
                    else
                        this.legend.changeOrientation(visuals.LegendPosition.Top);
                    var viewport = this.viewport;
                    this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });
                    visuals.Legend.positionChartArea(this.svg, this.legend);
                };
                RadarChart.prototype.getDataPoints = function (series) {
                    var dataPoints = [];
                    for (var _i = 0, series_3 = series; _i < series_3.length; _i++) {
                        var serie = series_3[_i];
                        dataPoints.push(serie.data);
                    }
                    return dataPoints;
                };
                RadarChart.prototype.getAllDataPointsList = function (series) {
                    var dataPoints = [];
                    for (var _i = 0, series_4 = series; _i < series_4.length; _i++) {
                        var serie = series_4[_i];
                        dataPoints = dataPoints.concat(serie.data);
                    }
                    return dataPoints;
                };
                RadarChart.prototype.parseLegendProperties = function (dataView) {
                    if (!dataView || !dataView.metadata) {
                        this.legendObjectProperties = {};
                        return;
                    }
                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, "legend", {});
                };
                RadarChart.parseSettings = function (dataView) {
                    var objects;
                    if (!dataView || !dataView.metadata || !dataView.metadata.columns || !dataView.metadata.objects)
                        objects = null;
                    else
                        objects = dataView.metadata.objects;
                    return {
                        showLegend: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.legend.show, true)
                    };
                };
                RadarChart.parseLabelSettings = function (dataView) {
                    var objects;
                    if (!dataView || !dataView.metadata || !dataView.metadata.objects)
                        objects = null;
                    else
                        objects = dataView.metadata.objects;
                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                    var labelsObj = {
                        show: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.show, dataLabelsSettings.show),
                        labelColor: powerbi.DataViewObjects.getFillColor(objects, RadarChart.Properties.labels.color, dataLabelsSettings.labelColor),
                        displayUnits: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.displayUnits, dataLabelsSettings.displayUnits),
                        precision: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.precision, dataLabelsSettings.precision),
                        fontSize: powerbi.DataViewObjects.getValue(objects, RadarChart.Properties.labels.fontSize, dataLabelsSettings.fontSize),
                        position: dataLabelsSettings.position
                    };
                    return labelsObj;
                };
                // This function returns the values to be displayed in the property pane for each object.
                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do
                // validation and return other values/defaults
                RadarChart.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    var settings;
                    if (!this.radarChartData || !this.radarChartData.settings)
                        return [];
                    settings = this.radarChartData.settings;
                    switch (options.objectName) {
                        case "legend":
                            enumeration.pushInstance(this.enumerateLegend(settings));
                            break;
                        case "dataPoint":
                            this.enumerateDataPoint(enumeration);
                            break;
                        case 'labels':
                            this.enumerateDataLabels(enumeration);
                            break;
                    }
                    return enumeration.complete();
                };
                RadarChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings) {
                    return {
                        enumeration: enumeration,
                        dataLabelsSettings: labelSettings,
                        show: true,
                        displayUnits: true,
                        precision: true,
                        fontSize: true,
                    };
                };
                RadarChart.prototype.enumerateDataLabels = function (enumeration) {
                    var labelSettings = this.radarChartData.dataLabelsSettings;
                    //Draw default settings
                    visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings));
                };
                RadarChart.prototype.enumerateLegend = function (settings) {
                    var showTitle = true, titleText = "", legend, labelColor, fontSize = 8;
                    showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, showTitle);
                    titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, titleText);
                    labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, labelColor);
                    fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, fontSize);
                    legend = {
                        objectName: "legend",
                        displayName: "legend",
                        selector: null,
                        properties: {
                            show: settings.showLegend,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: fontSize,
                        }
                    };
                    return legend;
                };
                RadarChart.prototype.enumerateDataPoint = function (enumeration) {
                    if (!this.radarChartData || !this.radarChartData.series)
                        return;
                    var series = this.radarChartData.series;
                    for (var _i = 0, series_5 = series; _i < series_5.length; _i++) {
                        var serie = series_5[_i];
                        enumeration.pushInstance({
                            objectName: "dataPoint",
                            displayName: serie.name,
                            selector: visuals.ColorHelper.normalizeSelector(serie.identity.getSelector(), false),
                            properties: {
                                fill: { solid: { color: serie.fill } }
                            }
                        });
                    }
                };
                RadarChart.prototype.updateViewport = function () {
                    var legendMargins = this.legend.getMargins(), legendPosition;
                    legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];
                    switch (legendPosition) {
                        case visuals.LegendPosition.Top:
                        case visuals.LegendPosition.TopCenter:
                        case visuals.LegendPosition.Bottom:
                        case visuals.LegendPosition.BottomCenter:
                            this.viewport.height -= legendMargins.height;
                            break;
                        case visuals.LegendPosition.Left:
                        case visuals.LegendPosition.LeftCenter:
                        case visuals.LegendPosition.Right:
                        case visuals.LegendPosition.RightCenter:
                            this.viewport.width -= legendMargins.width;
                            break;
                    }
                };
                RadarChart.capabilities = {
                    dataRoles: [
                        {
                            displayName: 'Category',
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                        },
                        {
                            displayName: 'Y Axis',
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                        },
                    ],
                    dataViewMappings: [{
                            conditions: [{ 'Category': { min: 1, max: 1 } }],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [{ bind: { to: 'Y' } }]
                                }
                            }
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        legend: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                            description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                                    type: { enumeration: visuals.legendPosition.type }
                                },
                                showTitle: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                                    type: { text: true },
                                    suppressFormatPainterCopy: true
                                },
                                labelColor: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                            properties: {
                                show: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                labelDisplayUnits: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                                    type: { formatting: { labelDisplayUnits: true } },
                                    suppressFormatPainterCopy: true,
                                },
                                labelPrecision: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                    description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                                    placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                                    type: { numeric: true },
                                    suppressFormatPainterCopy: true,
                                },
                                fontSize: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                                    type: { formatting: { fontSize: true } }
                                },
                            }
                        }
                    }
                };
                /** Note: Public for testability */
                RadarChart.formatStringProp = {
                    objectName: 'general',
                    propertyName: 'formatString',
                };
                RadarChart.Properties = {
                    legend: {
                        show: { objectName: 'legend', propertyName: 'show' }
                    },
                    dataPoint: {
                        fill: { objectName: 'dataPoint', propertyName: 'fill' }
                    },
                    labels: {
                        show: { objectName: 'labels', propertyName: 'show' },
                        color: { objectName: 'labels', propertyName: 'color' },
                        displayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                        precision: { objectName: 'labels', propertyName: 'labelPrecision' },
                        fontSize: { objectName: 'labels', propertyName: 'fontSize' },
                    }
                };
                RadarChart.VisualClassName = 'radarChart';
                RadarChart.Segments = CreateClassAndSelector('segments');
                RadarChart.SegmentNode = CreateClassAndSelector('segmentNode');
                RadarChart.Axis = CreateClassAndSelector('axis');
                RadarChart.AxisNode = CreateClassAndSelector('axisNode');
                RadarChart.AxisLabel = CreateClassAndSelector('axisLabel');
                RadarChart.Chart = CreateClassAndSelector('chart');
                RadarChart.ChartNode = CreateClassAndSelector('chartNode');
                RadarChart.ChartPolygon = CreateClassAndSelector('chartPolygon');
                RadarChart.ChartDot = CreateClassAndSelector('chartDot');
                RadarChart.DefaultMargin = {
                    top: 50,
                    bottom: 50,
                    right: 100,
                    left: 100
                };
                RadarChart.SegmentLevels = 6;
                RadarChart.SegmentFactor = 1;
                RadarChart.Radians = 2 * Math.PI;
                RadarChart.Scale = 1;
                RadarChart.AreaFillOpacity = 1;
                RadarChart.DimmedAreaFillOpacity = 0.4;
                return RadarChart;
            }());
            samples.RadarChart = RadarChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
            var HistogramChartWarning = (function () {
                function HistogramChartWarning(message) {
                    this.message = message;
                }
                Object.defineProperty(HistogramChartWarning.prototype, "code", {
                    get: function () {
                        return "BulletChartWarning";
                    },
                    enumerable: true,
                    configurable: true
                });
                HistogramChartWarning.prototype.getMessages = function (resourceProvider) {
                    return {
                        message: this.message,
                        title: resourceProvider.get(""),
                        detail: resourceProvider.get("")
                    };
                };
                HistogramChartWarning.ErrorInvalidDataValues = "Some data values are invalid or too big";
                return HistogramChartWarning;
            }());
            samples.HistogramChartWarning = HistogramChartWarning;
            var Histogram = (function () {
                function Histogram(histogramConstructorOptions) {
                    this.ColumnPadding = 1;
                    this.MinColumnHeight = 1;
                    this.MinOpacity = 0.3;
                    this.MaxOpacity = 1;
                    this.NumberOfLabelsOnAxisY = 5;
                    this.MinNumberOfBins = 0;
                    this.MaxNumberOfBins = 100;
                    this.MinPrecision = 0;
                    this.MaxPrecision = 17; // max number of decimals in float
                    this.TooltipDisplayName = "Range";
                    this.SeparatorNumbers = ", ";
                    this.LegendSize = 50;
                    this.AxisSize = 30;
                    this.ExcludeBrackets = {
                        left: "(",
                        right: ")"
                    };
                    this.IncludeBrackets = {
                        left: "[",
                        right: "]"
                    };
                    this.margin = {
                        top: 10,
                        right: 10,
                        bottom: 10,
                        left: 10
                    };
                    this.durationAnimations = 200;
                    if (histogramConstructorOptions) {
                        if (histogramConstructorOptions.svg) {
                            this.svg = histogramConstructorOptions.svg;
                        }
                        if (histogramConstructorOptions.animator) {
                            this.animator = histogramConstructorOptions.animator;
                        }
                        this.margin = histogramConstructorOptions.margin || this.margin;
                    }
                }
                Object.defineProperty(Histogram.prototype, "columnsSelection", {
                    get: function () {
                        return this.main.select(Histogram.Columns.selector)
                            .selectAll(Histogram.Column.selector);
                    },
                    enumerable: true,
                    configurable: true
                });
                Histogram.prototype.init = function (visualsOptions) {
                    this.hostService = visualsOptions.host;
                    if (this.svg) {
                        this.root = this.svg;
                    }
                    else {
                        this.root = d3.select(visualsOptions.element.get(0))
                            .append("svg");
                    }
                    var style = visualsOptions.style;
                    this.colors = style && style.colorPalette
                        ? style.colorPalette.dataColors
                        : new visuals.DataColorPalette();
                    this.root.classed(Histogram.ClassName, true);
                    this.main = this.root.append("g");
                    this.axes = this.main
                        .append("g")
                        .classed(Histogram.Axes["class"], true);
                    this.axisX = this.axes
                        .append("g")
                        .classed(Histogram.Axis["class"], true);
                    this.axisY = this.axes
                        .append("g")
                        .classed(Histogram.Axis["class"], true);
                    this.legend = this.main
                        .append("g")
                        .classed(Histogram.Legends["class"], true);
                    this.columns = this.main
                        .append("g")
                        .classed(Histogram.Columns["class"], true);
                    this.selectionManager = new SelectionManager({ hostServices: visualsOptions.host });
                };
                Histogram.prototype.converter = function (dataView) {
                    var _this = this;
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[0].values ||
                        !(dataView.categorical.categories[0].values.length > 0)) {
                        return null;
                    }
                    var settings, histogramLayout, values, numericalValues = [], data, xScale, yScale, valueFormatter, frequencies = [], identities = [], shiftByValues = 0, sumFrequency = 0;
                    if (dataView.categorical.values &&
                        dataView.categorical.values[0] &&
                        dataView.categorical.values[0].values) {
                        frequencies = dataView.categorical.values[0].values;
                    }
                    if (dataView.categorical.categories[0].identity
                        && dataView.categorical.categories[0].identity.length > 0) {
                        identities = dataView.categorical.categories[0].identity;
                    }
                    settings = this.parseSettings(dataView);
                    if (!settings) {
                        return null;
                    }
                    values = this.getValuesByFrequencies(dataView.categorical.categories[0].values, frequencies, identities);
                    values.forEach(function (value) {
                        numericalValues.push(value.value);
                        sumFrequency += value.frequency;
                    });
                    histogramLayout = d3.layout.histogram();
                    if (settings.bins && settings.bins > this.MinNumberOfBins) {
                        histogramLayout = histogramLayout.bins(settings.bins);
                    }
                    data = histogramLayout.frequency(settings.frequency)(numericalValues);
                    data.forEach(function (bin, index) {
                        var filteredValues, frequency;
                        filteredValues = values.filter(function (value) {
                            return _this.isValueContainedInRange(value, bin, index);
                        });
                        frequency = filteredValues.reduce(function (previousValue, currentValue) {
                            return previousValue + currentValue.frequency;
                        }, 0);
                        bin.y = settings.frequency
                            ? frequency
                            : frequency / sumFrequency;
                        shiftByValues += bin.length;
                    });
                    xScale = d3.scale.linear()
                        .domain([
                        d3.min(data, function (item) { return d3.min(item); }),
                        d3.max(data, function (item) { return d3.max(item); })
                    ])
                        .range([0, this.viewport.width - this.LegendSize - this.AxisSize]);
                    yScale = d3.scale.linear()
                        .domain([
                        0,
                        d3.max(data, function (item) { return item.y; })
                    ])
                        .range([this.viewport.height - this.LegendSize, 0]);
                    valueFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(dataView.categorical.categories[0].source, Histogram.Properties["general"]["formatString"]),
                        value: values[0].value,
                        value2: values[values.length - 1].value,
                        precision: settings.precision
                    });
                    return {
                        xScale: xScale,
                        yScale: yScale,
                        settings: settings,
                        data: this.getData(values, numericalValues, data, settings, valueFormatter),
                        formatter: valueFormatter
                    };
                };
                Histogram.prototype.getValuesByFrequencies = function (sourceValues, frequencies, identities) {
                    var values = [];
                    sourceValues.forEach(function (item, index) {
                        var frequency = 1, value = Number(item);
                        value = isNaN(value) ? 0 : value;
                        if (frequencies
                            && frequencies[index]
                            && !isNaN(frequencies[index])
                            && frequencies[index] > 1) {
                            frequency = frequencies[index];
                        }
                        values.push({
                            value: value,
                            frequency: frequency,
                            selectionId: visuals.SelectionId.createWithId(identities[index])
                        });
                    });
                    return values;
                };
                Histogram.prototype.getData = function (values, numericalValues, data, settings, valueFormatter) {
                    var _this = this;
                    var minValue = d3.min(numericalValues), maxValue = d3.max(numericalValues);
                    return data.map(function (bin, index) {
                        bin.range = _this.getRange(minValue, maxValue, bin.dx, index);
                        bin.tooltipInfo = _this.getTooltipData(bin.y, bin.range, settings, index === 0, valueFormatter);
                        bin.selectionIds = _this.getSelectionIds(values, bin, index);
                        return bin;
                    });
                };
                Histogram.prototype.getRange = function (minValue, maxValue, step, index) {
                    var leftBorder = minValue + index * step, rightBorder = leftBorder + step;
                    return [leftBorder, rightBorder];
                };
                Histogram.prototype.getTooltipData = function (value, range, settings, includeLeftBorder, valueFormatter) {
                    return [{
                            displayName: this.getLegendText(settings),
                            value: valueFormatter.format(value)
                        }, {
                            displayName: this.TooltipDisplayName,
                            value: this.rangeToString(range, includeLeftBorder, valueFormatter)
                        }];
                };
                Histogram.prototype.getSelectionIds = function (values, bin, index) {
                    var _this = this;
                    var selectionIds = [];
                    values.forEach(function (value) {
                        if (_this.isValueContainedInRange(value, bin, index)) {
                            selectionIds.push(value.selectionId);
                        }
                    });
                    return selectionIds;
                };
                Histogram.prototype.isValueContainedInRange = function (value, bin, index) {
                    return ((index === 0 && value.value >= bin.x) || (value.value > bin.x)) && value.value <= bin.x + bin.dx;
                };
                Histogram.prototype.parseSettings = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.columns[0]) {
                        return null;
                    }
                    var histogramSettings = {}, objects, colorHelper;
                    colorHelper = new visuals.ColorHelper(this.colors, Histogram.Properties["dataPoint"]["fill"], Histogram.DefaultHistogramSettings.fillColor);
                    histogramSettings.displayName = Histogram.DefaultHistogramSettings.displayName;
                    histogramSettings.fillColor = Histogram.DefaultHistogramSettings.fillColor;
                    histogramSettings.bins = Histogram.DefaultHistogramSettings.bins;
                    histogramSettings.frequency = Histogram.DefaultHistogramSettings.frequency;
                    histogramSettings.displayName =
                        dataView.metadata.columns[0].displayName || Histogram.DefaultHistogramSettings.displayName;
                    objects = this.getObjectsFromDataView(dataView);
                    if (objects) {
                        histogramSettings.fillColor = colorHelper.getColorForMeasure(objects, "");
                        histogramSettings.bins = this.getBins(objects);
                        histogramSettings.frequency = this.getFrequency(objects);
                        histogramSettings.precision = this.getPrecision(objects);
                    }
                    return histogramSettings;
                };
                Histogram.prototype.getBins = function (objects) {
                    var binsNumber;
                    binsNumber = Number(powerbi.DataViewObjects.getValue(objects, Histogram.Properties["general"]["bins"], Histogram.DefaultHistogramSettings.bins));
                    if (!binsNumber || isNaN(binsNumber) || binsNumber <= this.MinNumberOfBins) {
                        return Histogram.DefaultHistogramSettings.bins;
                    }
                    if (binsNumber > this.MaxNumberOfBins) {
                        return this.MaxNumberOfBins;
                    }
                    return binsNumber;
                };
                Histogram.prototype.getFrequency = function (objects) {
                    return powerbi.DataViewObjects.getValue(objects, Histogram.Properties["general"]["frequency"], Histogram.DefaultHistogramSettings.frequency);
                };
                Histogram.prototype.getPrecision = function (objects) {
                    var precision = powerbi.DataViewObjects.getValue(objects, Histogram.Properties["labels"]["labelPrecision"], Histogram.DefaultHistogramSettings.precision);
                    if (precision <= this.MinPrecision) {
                        return this.MinPrecision;
                    }
                    if (precision >= this.MaxPrecision) {
                        return this.MaxPrecision;
                    }
                    return precision;
                };
                Histogram.prototype.validateData = function (data) {
                    if (data && data.data.some(function (x) { return x.range.some(function (x) { return isNaN(x) || x === Infinity || x === -Infinity; }); })) {
                        this.hostService.setWarnings([new HistogramChartWarning(HistogramChartWarning.ErrorInvalidDataValues)]);
                        return false;
                    }
                    return true;
                };
                Histogram.prototype.update = function (visualUpdateOptions) {
                    if (!visualUpdateOptions ||
                        !visualUpdateOptions.dataViews ||
                        !visualUpdateOptions.dataViews[0]) {
                        return;
                    }
                    var dataView = visualUpdateOptions.dataViews[0];
                    this.durationAnimations = getAnimationDuration(this.animator, visualUpdateOptions.suppressAnimations);
                    this.setSize(visualUpdateOptions.viewport);
                    this.histogramDataView = this.converter(dataView);
                    if (!this.validateData(this.histogramDataView)) {
                        this.histogramDataView.data = [];
                    }
                    this.render();
                };
                Histogram.prototype.setSize = function (viewport) {
                    var height, width;
                    height = viewport.height -
                        this.margin.top -
                        this.margin.bottom;
                    width = viewport.width -
                        this.margin.left -
                        this.margin.right;
                    this.viewport = {
                        height: height,
                        width: width
                    };
                    this.updateElements(viewport.height, viewport.width);
                };
                Histogram.prototype.updateElements = function (height, width) {
                    var shiftToRight = this.margin.left + this.LegendSize;
                    this.root.attr({
                        "height": height,
                        "width": width
                    });
                    this.main.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.legend.attr("transform", visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.columns.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0));
                    this.axes.attr("transform", visuals.SVGUtil.translate(shiftToRight, 0));
                    this.axisX.attr("transform", visuals.SVGUtil.translate(0, this.viewport.height - this.LegendSize));
                };
                Histogram.prototype.render = function () {
                    if (!this.histogramDataView || !this.histogramDataView.settings) {
                        return;
                    }
                    this.renderAxes();
                    var columnsSelection = this.renderColumns();
                    this.renderLegend();
                    this.bindSelectionHandler(columnsSelection);
                };
                Histogram.prototype.renderColumns = function () {
                    var _this = this;
                    var data = this.histogramDataView.data, yScale = this.histogramDataView.yScale, countOfValues = data.length, widthOfColumn, updateColumnsSelection;
                    widthOfColumn = countOfValues && ((this.viewport.width - this.AxisSize - this.LegendSize) / countOfValues - this.ColumnPadding);
                    if (widthOfColumn < 0) {
                        widthOfColumn = 0;
                    }
                    updateColumnsSelection = this.columnsSelection.data(data);
                    updateColumnsSelection
                        .enter()
                        .append("svg:rect");
                    updateColumnsSelection
                        .attr("x", this.ColumnPadding / 2)
                        .attr("width", widthOfColumn)
                        .attr("height", function (item) { return _this.getColumnHeight(item, yScale); })
                        .style("fill", this.histogramDataView.settings.fillColor)
                        .attr("class", Histogram.Column["class"])
                        .attr("transform", function (item, index) { return visuals.SVGUtil.translate(widthOfColumn * index + _this.ColumnPadding * index, yScale(item.y) - _this.ColumnPadding / 2.5); });
                    if (countOfValues) {
                        //if data is empty, it throws for some reason
                        updateColumnsSelection.classed(Histogram.Column["class"]);
                    }
                    updateColumnsSelection.exit().remove();
                    this.renderTooltip(updateColumnsSelection);
                    return updateColumnsSelection;
                };
                Histogram.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                };
                Histogram.prototype.getColumnHeight = function (column, y) {
                    var height = this.viewport.height - this.LegendSize - y(column.y);
                    return height > 0 ? height : this.MinColumnHeight;
                };
                Histogram.prototype.renderAxes = function () {
                    var xScale = this.histogramDataView.xScale, yScale = this.histogramDataView.yScale, valueFormatter = this.histogramDataView.formatter, xAxis, yAxis;
                    xAxis = d3.svg.axis()
                        .scale(xScale)
                        .orient("bottom")
                        .tickValues(this.rangesToArray(this.histogramDataView.data))
                        .tickFormat(function (item) { return valueFormatter.format(item); });
                    yAxis = d3.svg.axis()
                        .scale(yScale)
                        .orient("left")
                        .ticks(this.NumberOfLabelsOnAxisY);
                    this.axisX.call(xAxis);
                    this.axisY.call(yAxis);
                };
                Histogram.prototype.rangesToArray = function (data) {
                    return data.reduce(function (previousValue, currentValue, index) {
                        var range;
                        range = index === 0
                            ? currentValue.range
                            : currentValue.range.slice(1);
                        return previousValue.concat(range);
                    }, []);
                };
                Histogram.prototype.rangeToString = function (range, includeLeftBorder, valueFormatter) {
                    var leftBracket, rightBracket = this.IncludeBrackets.right, leftBorder = valueFormatter.format(range[0]), rightBorder = valueFormatter.format(range[1]);
                    leftBracket = includeLeftBorder
                        ? this.IncludeBrackets.left
                        : this.ExcludeBrackets.left;
                    return "" + leftBracket + leftBorder + this.SeparatorNumbers + rightBorder + rightBracket;
                };
                Histogram.prototype.renderLegend = function () {
                    var legendElements, legendSelection, datalegends = this.getDataLegends(this.histogramDataView.settings);
                    legendElements = this.main
                        .select(Histogram.Legends.selector)
                        .selectAll(Histogram.Legend.selector);
                    legendSelection = legendElements.data(datalegends);
                    legendSelection
                        .enter()
                        .append("svg:text");
                    legendSelection
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("dx", function (item) { return item.dx; })
                        .attr("dy", function (item) { return item.dy; })
                        .attr("transform", function (item) { return item.transform; })
                        .attr("class", Histogram.Legend["class"])
                        .text(function (item) { return item.text; })
                        .classed(Histogram.Legend["class"], true);
                    legendSelection
                        .exit()
                        .remove();
                };
                Histogram.prototype.getDataLegends = function (settings) {
                    var bottomLegendText = this.getLegendText(settings);
                    return [{
                            transform: visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height),
                            text: settings.displayName,
                            dx: "1em",
                            dy: "-1em"
                        }, {
                            transform: visuals.SVGUtil.translateAndRotate(0, this.viewport.height / 2, 0, 0, 270),
                            text: bottomLegendText,
                            dx: "3em"
                        }];
                };
                Histogram.prototype.getLegendText = function (settings) {
                    return settings.frequency
                        ? Histogram.FrequencyText
                        : Histogram.DensityText;
                };
                Histogram.prototype.bindSelectionHandler = function (columnsSelection) {
                    var _this = this;
                    this.setSelection(columnsSelection);
                    columnsSelection.on("click", function (data) {
                        _this.selectionManager.clear();
                        data.selectionIds.forEach(function (selectionId) {
                            _this.selectionManager.select(selectionId, true).then(function (selectionIds) {
                                if (selectionIds.length > 0) {
                                    _this.setSelection(columnsSelection, data);
                                }
                                else {
                                    _this.setSelection(columnsSelection);
                                }
                            });
                        });
                        d3.event.stopPropagation();
                    });
                    this.root.on("click", function () {
                        _this.selectionManager.clear();
                        _this.setSelection(columnsSelection);
                    });
                };
                Histogram.prototype.setSelection = function (columnsSelection, data) {
                    columnsSelection.transition()
                        .duration(this.durationAnimations)
                        .style("fill-opacity", this.MaxOpacity);
                    if (!data) {
                        return;
                    }
                    columnsSelection
                        .filter(function (columnSelection) {
                        return columnSelection !== data;
                    })
                        .transition()
                        .duration(this.durationAnimations)
                        .style("fill-opacity", this.MinOpacity);
                };
                Histogram.prototype.enumerateObjectInstances = function (options) {
                    var instances = [], settings;
                    if (!this.histogramDataView ||
                        !this.histogramDataView.settings) {
                        return instances;
                    }
                    settings = this.histogramDataView.settings;
                    switch (options.objectName) {
                        case "general": {
                            var general = {
                                objectName: "general",
                                displayName: "general",
                                selector: null,
                                properties: {
                                    bins: settings.bins,
                                    frequency: settings.frequency
                                }
                            };
                            instances.push(general);
                            break;
                        }
                        case "dataPoint": {
                            var dataPoint = {
                                objectName: "dataPoint",
                                displayName: "dataPoint",
                                selector: null,
                                properties: {
                                    fill: settings.fillColor
                                }
                            };
                            instances.push(dataPoint);
                            break;
                        }
                        case "labels": {
                            var labels = {
                                objectName: "labels",
                                displayName: "labels",
                                selector: null,
                                properties: {
                                    labelPrecision: settings.precision
                                }
                            };
                            instances.push(labels);
                            break;
                        }
                    }
                    return instances;
                };
                Histogram.prototype.getObjectsFromDataView = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.objects) {
                        return null;
                    }
                    return dataView.metadata.objects;
                };
                Histogram.prototype.destroy = function () {
                    this.root = null;
                };
                Histogram.ClassName = "histogram";
                Histogram.FrequencyText = "Frequency";
                Histogram.DensityText = "Density";
                Histogram.Properties = {
                    general: {
                        bins: {
                            objectName: "general",
                            propertyName: "bins"
                        },
                        frequency: {
                            objectName: "general",
                            propertyName: "frequency"
                        },
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    dataPoint: {
                        fill: {
                            objectName: "dataPoint",
                            propertyName: "fill"
                        }
                    },
                    labels: {
                        labelPrecision: {
                            objectName: "labels",
                            propertyName: "labelPrecision"
                        }
                    }
                };
                Histogram.DefaultHistogramSettings = {
                    frequency: true,
                    displayName: "Histogram",
                    bins: null,
                    fillColor: "cadetblue",
                    precision: 2
                };
                Histogram.Axes = {
                    "class": "axes",
                    selector: ".axes"
                };
                Histogram.Axis = {
                    "class": "axis",
                    selector: ".axis"
                };
                Histogram.Columns = {
                    "class": "columns",
                    selector: ".columns"
                };
                Histogram.Column = {
                    "class": "column",
                    selector: ".column"
                };
                Histogram.Legends = {
                    "class": "legends",
                    selector: ".legends"
                };
                Histogram.Legend = {
                    "class": "legend",
                    selector: ".legend"
                };
                Histogram.capabilities = {
                    dataRoles: [{
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: powerbi.data.createDisplayNameGetter("Role_DisplayName_Values")
                        }, {
                            name: "Frequency",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Frequency"
                        }],
                    dataViewMappings: [{
                            conditions: [{ "Values": { min: 1, max: 1 }, "Frequency": { min: 0, max: 1 } }],
                            categorical: {
                                categories: {
                                    bind: { to: "Values" },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: { for: { in: "Frequency" } }
                            }
                        }],
                    sorting: {
                        implicit: {
                            clauses: [{ role: "Values", direction: 1 /*SortDirection.Ascending*/ }] //Constant SortDirection.Ascending currently is not supported on the msit
                        }
                    },
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: { type: { formatting: { formatString: true } } },
                                bins: {
                                    displayName: "Bins",
                                    type: { numeric: true }
                                },
                                frequency: {
                                    displayName: "Frequency",
                                    type: { bool: true }
                                }
                            },
                        },
                        dataPoint: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_DataPoint"),
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        labels: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                            properties: {
                                labelPrecision: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                                    type: { numeric: true }
                                }
                            }
                        }
                    }
                };
                return Histogram;
            }());
            samples.Histogram = Histogram;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var getAnimationDuration = visuals.AnimatorCommon.GetAnimationDuration;
            var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var AxisScale = powerbi.visuals.axisScale;
            var PixelConverter = jsCommon.PixelConverter;
            var MaxXAxisHeight = 40;
            var LabelMargin = 15;
            var DefaultRadius = 5;
            var DefaultStrokeWidth = 1;
            var DefaultDataPointColor = "#00B8AA";
            var MinPrecision = 0;
            var MaxPrecision = 17;
            samples.DotPlotProperties = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                labels: {
                    show: {
                        objectName: "labels",
                        propertyName: "show"
                    },
                    fontSize: {
                        objectName: "labels",
                        propertyName: "fontSize"
                    },
                    labelPrecision: {
                        objectName: "labels",
                        propertyName: "labelPrecision"
                    },
                    labelDisplayUnits: {
                        objectName: "labels",
                        propertyName: "labelDisplayUnits"
                    },
                    labelColor: {
                        objectName: "labels",
                        propertyName: "labelColor"
                    }
                },
                dataPoint: {
                    fill: {
                        objectName: "dataPoint",
                        propertyName: "fill"
                    }
                },
                categories: {
                    show: {
                        objectName: "categories",
                        propertyName: "show"
                    },
                    fontColor: {
                        objectName: "categories",
                        propertyName: "fontColor"
                    },
                    fontSize: {
                        objectName: "categories",
                        propertyName: "fontSize"
                    }
                }
            };
            var DotPlot = (function () {
                function DotPlot(options) {
                    this.DefaultMargin = {
                        top: 10,
                        bottom: 10,
                        right: 20,
                        left: 20
                    };
                    this.durationAnimations = 200;
                    this.scaleType = AxisScale.linear;
                    this.textProperties = {
                        fontFamily: 'wf_segoe-ui_normal',
                        fontSize: jsCommon.PixelConverter.toString(9),
                    };
                    this.dotPlotSelectors = {
                        svgPlotSelector: CreateClassAndSelector('dotplot'),
                        plotSelector: CreateClassAndSelector('dotplotSelector'),
                        plotGroupSelector: CreateClassAndSelector('dotplotGroup'),
                        axisSelector: CreateClassAndSelector('axisGraphicsContext'),
                        xAxisSelector: CreateClassAndSelector('x axis'),
                        circleSeletor: CreateClassAndSelector('circleSelector'),
                    };
                    this.DefaultDotPlotSettings = {
                        labelSettings: {
                            show: true,
                            precision: 2,
                            fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,
                            displayUnits: 0,
                            labelColor: visuals.dataLabelUtils.defaultLabelColor,
                        },
                        categorySettings: {
                            show: true,
                            fontColor: visuals.LegendData.DefaultLegendLabelFillColor
                        },
                        defaultDataPointColor: DefaultDataPointColor
                    };
                    if (options) {
                        if (options.svg) {
                            this.svg = options.svg;
                        }
                        if (options.animator) {
                            this.animator = options.animator;
                        }
                        this.radius = options.radius || DefaultRadius;
                        this.strokeWidth = options.strokeWidth || DefaultStrokeWidth;
                    }
                }
                DotPlot.getTooltipData = function (value) {
                    return [{
                            displayName: "Value",
                            value: value.toString()
                        }];
                };
                DotPlot.converter = function (dataView, scale, defaultMargin, defaultSetting, colors, viewport, radius) {
                    var values = dataView.categorical.values, dataPointsGroup = [], displayName = dataView.categorical.categories[0].source.displayName, objects = this.getObjectsFromDataView(dataView), settings, defaultColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value);
                    var categories = dataView.categorical.categories[0].values.map(function (x, i) { return {
                        value: x,
                        selectionId: visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i])
                    }; });
                    settings = {
                        categorySettings: this.getCategorySettings(objects, defaultSetting),
                        defaultDataPointColor: defaultColor,
                        labelSettings: this.parseSettings(objects, defaultSetting)
                    };
                    var categoryColumn = dataView.categorical.categories[0];
                    var diameter = 2 * radius + 1;
                    var dotsTotalHeight = viewport.height - radius - MaxXAxisHeight;
                    var maxDots = Math.floor((dotsTotalHeight - defaultMargin.top) / diameter) - 1;
                    var fontSizeInPx = PixelConverter.fromPoint(settings.labelSettings.fontSize);
                    var yScale = d3.scale.linear()
                        .domain([0, maxDots])
                        .range([dotsTotalHeight - defaultMargin.bottom, defaultMargin.top + defaultMargin.bottom]);
                    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                        var value = values_1[_i];
                        var min = _.min(value.values);
                        var max = _.max(value.values);
                        var color = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, colors.getColorByIndex(0).value);
                        var length_1 = value.values.length;
                        var minDots = min / (max / maxDots);
                        var dotsScale = d3.scale.log().domain([min, max]).range([minDots === 0 ? 1 : minDots, maxDots]).clamp(true);
                        for (var k = 0; k < length_1; k++) {
                            var y = dotsScale(value.values[k]);
                            var dataPoints = [];
                            for (var level = 0; level < y; level++) {
                                dataPoints.push({
                                    x: scale(categories[k].value) + scale.rangeBand() / 2,
                                    y: yScale(level),
                                    tooltipInfo: DotPlot.getTooltipData(value.values[k])
                                });
                            }
                            var categorySelectionId = visuals.SelectionIdBuilder.builder().withCategory(categoryColumn, k).createSelectionId();
                            var tooltipInfo = DotPlot.getTooltipData(value.values[k]);
                            dataPointsGroup.push({
                                selected: false,
                                value: value.values[k],
                                label: value.values[k],
                                color: color,
                                identity: categorySelectionId,
                                tooltipInfo: tooltipInfo,
                                dataPoints: dataPoints,
                                labelFontSize: fontSizeInPx,
                            });
                        }
                    }
                    return {
                        dataPoints: dataPointsGroup,
                        values: dataView.categorical.categories[0].values,
                        displayName: displayName,
                        categories: categories,
                        settings: settings
                    };
                };
                DotPlot.prototype.init = function (options) {
                    var element = options.element;
                    this.behavior = new DotplotBehavior();
                    this.interactivityService = visuals.createInteractivityService(options.host);
                    this.radius = DefaultRadius;
                    this.strokeWidth = DefaultStrokeWidth;
                    this.colors = options.style.colorPalette.dataColors;
                    this.svg = d3.select(element.get(0)).append('svg').classed(this.dotPlotSelectors.svgPlotSelector.class, true).style('position', 'absolute');
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                    var axisGraphicsContext = this.svg.append('g').classed(this.dotPlotSelectors.axisSelector.class, true);
                    this.dotPlot = this.svg.append('g').classed(this.dotPlotSelectors.plotSelector.class, true);
                    this.xAxis = axisGraphicsContext.append("g").classed(this.dotPlotSelectors.xAxisSelector.class, true);
                };
                DotPlot.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    this.durationAnimations = getAnimationDuration(this.animator, options.suppressAnimations);
                    var dataView = this.dataView = options.dataViews[0];
                    var viewport = options.viewport;
                    if (!dataView ||
                        !dataView.categorical ||
                        !dataView.categorical.values ||
                        dataView.categorical.values.length < 1 ||
                        !dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0]) {
                        this.clearData();
                        return;
                    }
                    var viewportIn = {
                        height: (viewport.height - this.DefaultMargin.top),
                        width: (viewport.width - this.DefaultMargin.left)
                    };
                    this.svg.style({
                        height: PixelConverter.toString(viewport.height),
                        width: PixelConverter.toString(viewport.width)
                    });
                    var xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, false);
                    var data = DotPlot.converter(dataView, xAxisProperties.scale, this.DefaultMargin, this.DefaultDotPlotSettings, this.colors, viewport, this.radius);
                    this.dotPlotDataView = data;
                    var dataPoints = data.dataPoints;
                    if (this.interactivityService)
                        this.interactivityService.applySelectionStateToData(dataPoints);
                    this.renderAxis(viewportIn.height - MaxXAxisHeight, xAxisProperties, data, this.durationAnimations);
                    this.drawDotPlot(dataPoints, data.settings);
                    var dataLabelsSettings = data.settings.labelSettings;
                    if (dataLabelsSettings.show) {
                        var layout = this.getEnhanchedDotplotLayout(dataLabelsSettings, viewportIn);
                        visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, this.svg, layout, viewportIn, !options.suppressAnimations, this.durationAnimations);
                    }
                    else {
                        visuals.dataLabelUtils.cleanDataLabels(this.svg);
                    }
                };
                DotPlot.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                        case 'dataPoint':
                            this.enumerateDataPoints(enumeration, this.dataView);
                            break;
                        case 'labels':
                            this.enumerateDataLabels(enumeration, this.dataView);
                            break;
                        case 'categories':
                            this.enumerateCategories(enumeration, this.dataView);
                            break;
                    }
                    return enumeration.complete();
                };
                DotPlot.getObjectsFromDataView = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.objects) {
                        return null;
                    }
                    return dataView.metadata.objects;
                };
                DotPlot.parseSettings = function (objects, defaultDotPlotSettings) {
                    var precision = this.getPrecision(objects, defaultDotPlotSettings);
                    return {
                        show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, defaultDotPlotSettings.labelSettings.show),
                        precision: precision,
                        fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, defaultDotPlotSettings.labelSettings.fontSize),
                        displayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, defaultDotPlotSettings.labelSettings.displayUnits),
                        labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, defaultDotPlotSettings.labelSettings.labelColor),
                    };
                };
                DotPlot.getCategorySettings = function (objects, defaultDotPlotSettings) {
                    return {
                        show: powerbi.DataViewObject.getValue(objects, samples.DotPlotProperties.categories.show, defaultDotPlotSettings.categorySettings.show),
                        fontColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.categories.fontColor, defaultDotPlotSettings.categorySettings.fontColor)
                    };
                };
                DotPlot.getPrecision = function (objects, defaultDotPlotSettings) {
                    var precision = powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, defaultDotPlotSettings.labelSettings.precision);
                    if (precision <= MinPrecision)
                        return MinPrecision;
                    if (precision >= MaxPrecision)
                        return MaxPrecision;
                    return precision;
                };
                DotPlot.prototype.drawDotPlot = function (data, setting) {
                    var selection = this.dotPlot.selectAll(this.dotPlotSelectors.plotGroupSelector.selector).data(data);
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                    selection
                        .enter()
                        .append('g')
                        .attr({
                        stroke: "black",
                        "stroke-width": this.strokeWidth
                    }).
                        style("fill-opacity", function (item) { return visuals.ColumnUtil.getFillOpacity(item.selected, item.highlight, hasSelection, false); }).
                        classed(this.dotPlotSelectors.plotGroupSelector.class, true);
                    var circleSelection = selection.selectAll(this.dotPlotSelectors.circleSeletor.selector).data(function (d) { return d.dataPoints; });
                    circleSelection.enter().append('circle')
                        .classed(this.dotPlotSelectors.circleSeletor.class, true);
                    circleSelection.attr({
                        cx: function (point) { return point.x; },
                        cy: function (point) { return point.y; },
                        r: this.radius,
                        fill: setting.defaultDataPointColor
                    });
                    this.renderTooltip(selection);
                    circleSelection.exit().remove();
                    selection.exit().remove();
                    var interactivityService = this.interactivityService;
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(data);
                        var behaviorOptions = {
                            columns: selection,
                            clearCatcher: this.clearCatcher,
                            interactivityService: this.interactivityService,
                        };
                        interactivityService.bind(data, this.behavior, behaviorOptions);
                    }
                };
                DotPlot.prototype.getEnhanchedDotplotLayout = function (labelSettings, viewport) {
                    var fontSizeInPx = jsCommon.PixelConverter.fromPoint(labelSettings.fontSize);
                    var formatter = visuals.valueFormatter.create({
                        format: visuals.valueFormatter.getFormatString(this.dataView.categorical.categories[0].source, samples.DotPlotProperties.general.formatString),
                        precision: labelSettings.precision,
                        value: labelSettings.displayUnits
                    });
                    return {
                        labelText: function (d) {
                            return visuals.dataLabelUtils.getLabelFormattedText({
                                label: formatter.format(d.label),
                                fontSize: labelSettings.fontSize,
                                maxWidth: viewport.width,
                            });
                        },
                        labelLayout: {
                            x: function (d) { return d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].x : 0; },
                            y: function (d) { return d && d.dataPoints && d.dataPoints[d.dataPoints.length - 1] ? d.dataPoints[d.dataPoints.length - 1].y - LabelMargin : 0; }
                        },
                        filter: function (d) {
                            return (d != null && d.label != null);
                        },
                        style: {
                            'fill': labelSettings.categoryLabelColor,
                            'font-size': fontSizeInPx,
                        },
                    };
                };
                DotPlot.prototype.enumerateDataLabels = function (enumeration, dataView) {
                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;
                    enumeration.pushInstance({
                        objectName: "labels",
                        displayName: "Labels",
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.show, this.DefaultDotPlotSettings.labelSettings.show),
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.fontSize, this.DefaultDotPlotSettings.labelSettings.fontSize),
                            labelPrecision: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelPrecision, this.DefaultDotPlotSettings.labelSettings.precision),
                            labelDisplayUnits: powerbi.DataViewObjects.getValue(objects, samples.DotPlotProperties.labels.labelDisplayUnits, this.DefaultDotPlotSettings.labelSettings.displayUnits),
                            labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.labels.labelColor, this.DefaultDotPlotSettings.labelSettings.labelColor)
                        }
                    });
                };
                DotPlot.prototype.enumerateDataPoints = function (enumeration, dataView) {
                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;
                    var dataPointColor = powerbi.DataViewObjects.getFillColor(objects, samples.DotPlotProperties.dataPoint.fill, this.DefaultDotPlotSettings.defaultDataPointColor);
                    enumeration.pushInstance({
                        objectName: "dataPoint",
                        displayName: "Data Points",
                        selector: null,
                        properties: {
                            fill: { solid: { color: dataPointColor } }
                        }
                    });
                };
                DotPlot.prototype.enumerateCategories = function (enumeration, dataView) {
                    var objects = dataView && dataView.metadata ? dataView.metadata.objects : undefined;
                    var categoriesSettings = DotPlot.getCategorySettings(objects, this.DefaultDotPlotSettings);
                    enumeration.pushInstance({
                        objectName: "categories",
                        displayName: "Categories",
                        selector: null,
                        properties: {
                            show: categoriesSettings.show,
                            fontSize: categoriesSettings.fontSize,
                            fontColor: categoriesSettings.fontColor
                        }
                    });
                };
                DotPlot.prototype.clearData = function () {
                    this.dotPlot.selectAll("*").remove();
                    this.xAxis.selectAll("*").remove();
                    visuals.dataLabelUtils.cleanDataLabels(this.svg);
                };
                DotPlot.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                };
                DotPlot.prototype.calculateAxes = function (viewportIn, textProperties, scrollbarVisible) {
                    var category = this.dataView.categorical.categories && this.dataView.categorical.categories.length > 0
                        ? this.dataView.categorical.categories[0]
                        : {
                            source: undefined,
                            values: [visuals.valueFormatter.format(null)],
                            identity: undefined,
                        };
                    var visualOptions = {
                        viewport: viewportIn,
                        margin: this.DefaultMargin,
                        forcedXDomain: this.dataView.categorical.categories[0].values,
                        forceMerge: false,
                        showCategoryAxisLabel: false,
                        showValueAxisLabel: false,
                        categoryAxisScaleType: this.scaleType,
                        valueAxisScaleType: null,
                        valueAxisDisplayUnits: 0,
                        categoryAxisDisplayUnits: 0,
                        trimOrdinalDataOnOverflow: false,
                    };
                    var width = viewportIn.width;
                    var axes = this.calculateAxesProperties(viewportIn, visualOptions, category.source);
                    axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                    // If labels do not fit and we are not scrolling, try word breaking
                    axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.DefaultMargin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);
                    return axes;
                };
                DotPlot.prototype.calculateAxesProperties = function (viewportIn, options, metaDataColumn) {
                    var xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: viewportIn.width,
                        dataDomain: options.forcedXDomain,
                        metaDataColumn: metaDataColumn,
                        formatString: visuals.valueFormatter.getFormatString(metaDataColumn, samples.DotPlotProperties.general.formatString),
                        outerPadding: 0,
                        isScalar: false,
                        isVertical: false,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: true,
                        isCategoryAxis: true,
                        getValueFn: function (index, type) { return index; },
                        scaleType: options.categoryAxisScaleType,
                        axisDisplayUnits: options.categoryAxisDisplayUnits
                    });
                    xAxisProperties.axisLabel = "New Label";
                    return xAxisProperties;
                };
                DotPlot.prototype.renderAxis = function (height, xAxisProperties, data, duration) {
                    this.xAxis.attr({
                        transform: visuals.SVGUtil.translate(0, height)
                    });
                    var xAxis = xAxisProperties.axis;
                    xAxis.orient('bottom');
                    this.xAxis
                        .transition()
                        .duration(duration)
                        .call(xAxis);
                };
                DotPlot.capabilities = {
                    dataRoles: [{
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Category'
                        },
                        {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Values'
                        }],
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Values': { max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    group: {
                                        by: "Series",
                                        select: [{ for: { in: "Values" } }],
                                        dataReductionAlgorithm: { top: {} }
                                    }
                                }
                            },
                        }],
                    objects: {
                        general: {
                            displayName: 'General',
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                        dataPoint: {
                            displayName: 'Data colors',
                            properties: {
                                fill: {
                                    displayName: 'Fill',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        labels: {
                            displayName: "Data labels",
                            description: 'Display data label options',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                showSeries: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: 'Color',
                                    description: 'Select color for data labels',
                                    type: { fill: { solid: { color: true } } }
                                },
                                labelDisplayUnits: {
                                    displayName: 'Display units',
                                    description: 'Select the units (millions, billions, etc.)',
                                    type: { formatting: { labelDisplayUnits: true } },
                                    suppressFormatPainterCopy: true
                                },
                                labelPrecision: {
                                    displayName: 'Decimal places',
                                    description: 'Select the number of decimal places to display',
                                    placeHolderText: 'Auto',
                                    type: { numeric: true },
                                    suppressFormatPainterCopy: true
                                },
                                showAll: {
                                    displayName: 'Customize series',
                                    type: { bool: true }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                },
                            }
                        }
                    }
                };
                return DotPlot;
            }());
            samples.DotPlot = DotPlot;
            var DotplotBehavior = (function () {
                function DotplotBehavior() {
                }
                DotplotBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    this.columns = options.columns;
                    this.clearCatcher = options.clearCatcher;
                    this.interactivityService = options.interactivityService;
                    this.columns.on('click', function (d, i) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    });
                    options.clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                DotplotBehavior.prototype.renderSelection = function (hasSelection) {
                    var hasHighlights = this.interactivityService.hasSelection();
                    this.columns.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });
                };
                return DotplotBehavior;
            }());
            samples.DotplotBehavior = DotplotBehavior;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  This file is based on or incorporates material from the projects listed below (Third Party IP).
 *  The original copyright notice and the license under which Microsoft received such Third Party IP,
 *  are set forth below. Such licenses and notices are provided for informational purposes only.
 *  Microsoft licenses the Third Party IP to you under the licensing terms for the Microsoft product.
 *  Microsoft reserves all other rights not expressly granted under this agreement, whether by
 *  implication, estoppel or otherwise.
 *
 *  d3 Force Layout
 *  Copyright (c) 2010-2015, Michael Bostock
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * The name Michael Bostock may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var PixelConverter = jsCommon.PixelConverter;
            var linkColorType;
            (function (linkColorType) {
                linkColorType.byWeight = 'ByWeight';
                linkColorType.byLinkType = 'ByLinkType';
                linkColorType.interactive = 'Interactive';
                linkColorType.type = powerbi.createEnumType([
                    { value: linkColorType.byWeight, displayName: 'ByWeight' },
                    { value: linkColorType.byLinkType, displayName: 'ByLinkType' },
                    { value: linkColorType.interactive, displayName: 'Interactive' },
                ]);
            })(linkColorType || (linkColorType = {}));
            samples.forceProps = {
                general: {
                    formatString: {
                        objectName: "general",
                        propertyName: "formatString"
                    }
                },
                labels: {
                    show: {
                        objectName: "labels",
                        propertyName: "show"
                    },
                    color: {
                        objectName: "labels",
                        propertyName: "color"
                    },
                    fontSize: {
                        objectName: "labels",
                        propertyName: "fontSize"
                    }
                },
                links: {
                    showArrow: { objectName: 'links', propertyName: 'showArrow' },
                    showLabel: { objectName: 'links', propertyName: 'showLabel' },
                    colorLink: { objectName: 'links', propertyName: 'colorLink' },
                    thickenLink: { objectName: 'links', propertyName: 'thickenLink' },
                },
                nodes: {
                    displayImage: { objectName: 'nodes', propertyName: 'displayImage' },
                    defaultImage: { objectName: 'nodes', propertyName: 'defaultImage' },
                    imageUrl: { objectName: 'nodes', propertyName: 'imageUrl' },
                    imageExt: { objectName: 'nodes', propertyName: 'imageExt' },
                    nameMaxLength: { objectName: 'nodes', propertyName: 'nameMaxLength' },
                    highlightReachableLinks: { objectName: 'nodes', propertyName: 'highlightReachableLinks' },
                },
                size: {
                    charge: { objectName: 'size', propertyName: 'charge' },
                }
            };
            var ForceGraph = (function () {
                function ForceGraph() {
                }
                Object.defineProperty(ForceGraph.prototype, "margin", {
                    get: function () {
                        return this.marginValue || { left: 0, right: 0, top: 0, bottom: 0 };
                    },
                    set: function (value) {
                        this.marginValue = $.extend({}, value);
                        this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ForceGraph.prototype, "viewport", {
                    get: function () {
                        return this.viewportValue || { width: 0, height: 0 };
                    },
                    set: function (value) {
                        this.viewportValue = $.extend({}, value);
                        this.viewportInValue = ForceGraph.substractMargin(this.viewport, this.margin);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(ForceGraph.prototype, "viewportIn", {
                    get: function () {
                        return this.viewportInValue || this.viewport;
                    },
                    enumerable: true,
                    configurable: true
                });
                ForceGraph.substractMargin = function (viewport, margin) {
                    return {
                        width: Math.max(viewport.width - (margin.left + margin.right), 0),
                        height: Math.max(viewport.height - (margin.top + margin.bottom), 0)
                    };
                };
                ForceGraph.prototype.scale1to10 = function (d) {
                    var scale = d3.scale.linear().domain([this.data.minFiles, this.data.maxFiles]).rangeRound([1, 10]).clamp(true);
                    return scale(d);
                };
                ForceGraph.prototype.getLinkColor = function (d) {
                    switch (this.options.colorLink) {
                        case linkColorType.byWeight:
                            return this.colors.getColorByIndex(this.scale1to10(d.filecount)).value;
                        case linkColorType.byLinkType:
                            return d.type && this.data.linkTypes[d.type] ? this.data.linkTypes[d.type].color : this.options.defaultLinkColor;
                    }
                    ;
                    return this.options.defaultLinkColor;
                };
                ForceGraph.prototype.getDefaultOptions = function () {
                    return {
                        showDataLabels: true,
                        labelColor: visuals.dataLabelUtils.defaultLabelColor,
                        fontSize: visuals.dataLabelUtils.DefaultFontSizeInPt,
                        showArrow: false,
                        showLabel: false,
                        colorLink: linkColorType.interactive,
                        thickenLink: true,
                        displayImage: false,
                        defaultImage: "Home",
                        imageUrl: "",
                        imageExt: ".png",
                        nameMaxLength: 10,
                        highlightReachableLinks: false,
                        charge: -15,
                        defaultLinkColor: "#bbb",
                        defaultLinkHighlightColor: "#f00",
                        defaultLinkThickness: "1.5px",
                    };
                };
                ForceGraph.prototype.updateOptions = function (objects) {
                    this.options.showDataLabels = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.show, this.options.showDataLabels);
                    this.options.labelColor = powerbi.DataViewObjects.getFillColor(objects, samples.forceProps.labels.color, this.options.labelColor);
                    this.options.fontSize = powerbi.DataViewObjects.getValue(objects, samples.forceProps.labels.fontSize, this.options.fontSize);
                    this.options.showArrow = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showArrow, this.options.showArrow);
                    this.options.showLabel = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.showLabel, this.options.showLabel);
                    this.options.colorLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.colorLink, this.options.colorLink);
                    this.options.thickenLink = powerbi.DataViewObjects.getValue(objects, samples.forceProps.links.thickenLink, this.options.thickenLink);
                    this.options.displayImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.displayImage, this.options.displayImage);
                    this.options.defaultImage = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.defaultImage, this.options.defaultImage);
                    this.options.imageUrl = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageUrl, this.options.imageUrl);
                    this.options.imageExt = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.imageExt, this.options.imageExt);
                    this.options.nameMaxLength = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.nameMaxLength, this.options.nameMaxLength);
                    this.options.highlightReachableLinks = powerbi.DataViewObjects.getValue(objects, samples.forceProps.nodes.highlightReachableLinks, this.options.highlightReachableLinks);
                    this.options.charge = powerbi.DataViewObjects.getValue(objects, samples.forceProps.size.charge, this.options.charge);
                    if (this.options.charge >= 0 || this.options.charge < -100)
                        this.options.charge = this.getDefaultOptions().charge;
                };
                ForceGraph.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                        case 'labels':
                            this.enumerateLabels(enumeration);
                            break;
                        case 'links':
                            this.enumerateLinks(enumeration);
                            break;
                        case 'nodes':
                            this.enumerateNodes(enumeration);
                            break;
                        case 'size':
                            this.enumerateSize(enumeration);
                            break;
                        default:
                            break;
                    }
                    return enumeration.complete();
                };
                ForceGraph.prototype.enumerateLabels = function (enumeration) {
                    var labels, options;
                    if (!this.options || !this.options)
                        return;
                    options = this.options;
                    labels = {
                        objectName: 'labels',
                        displayName: 'Labels',
                        selector: null,
                        properties: {
                            show: options.showDataLabels,
                            fontSize: options.fontSize,
                            color: options.labelColor
                        }
                    };
                    enumeration.pushInstance(labels);
                };
                ForceGraph.prototype.enumerateLinks = function (enumeration) {
                    var links, options;
                    if (!this.options)
                        return;
                    options = this.options;
                    links = {
                        objectName: 'links',
                        displayName: 'Links',
                        selector: null,
                        properties: {
                            showArrow: options.showArrow,
                            colorLink: options.colorLink,
                            showLabel: options.showLabel,
                            thickenLink: options.thickenLink,
                        }
                    };
                    enumeration.pushInstance(links);
                };
                ForceGraph.prototype.enumerateNodes = function (enumeration) {
                    var nodes, options;
                    if (!this.options)
                        return;
                    options = this.options;
                    nodes = {
                        objectName: 'nodes',
                        displayName: 'Nodes',
                        selector: null,
                        properties: {
                            displayImage: options.displayImage,
                            defaultImage: options.defaultImage,
                            imageUrl: options.imageUrl,
                            imageExt: options.imageExt,
                            nameMaxLength: options.nameMaxLength,
                            highlightReachableLinks: options.highlightReachableLinks,
                        }
                    };
                    enumeration.pushInstance(nodes);
                };
                ForceGraph.prototype.enumerateSize = function (enumeration) {
                    var size, options;
                    if (!this.options)
                        return;
                    options = this.options;
                    size = {
                        objectName: 'size',
                        displayName: 'Size',
                        selector: null,
                        properties: {
                            charge: options.charge,
                        }
                    };
                    enumeration.pushInstance(size);
                };
                ForceGraph.converter = function (dataView, colors) {
                    var categorical = dataView.categorical;
                    var nodes = {};
                    var minFiles = Number.MAX_VALUE;
                    var maxFiles = 0;
                    var linkedByName = {};
                    var links = [];
                    var linkDataPoints = {};
                    var linkTypeCount = 0;
                    var sourceCol = -1, targetCol = -1, weightCol = -1, linkTypeCol = -1, sourceTypeCol = -1, targetTypeCol = -1;
                    var rows;
                    var tooltipInfo = [];
                    var formatStringProp = samples.forceProps.general.formatString;
                    if (dataView && dataView.categorical && dataView.categorical.categories && dataView.metadata && dataView.metadata.columns) {
                        var metadataColumns = dataView.metadata.columns;
                        for (var i = 0; i < metadataColumns.length; i++) {
                            var col = metadataColumns[i];
                            if (col.roles) {
                                if (col.roles['Source'])
                                    sourceCol = i;
                                else if (col.roles['Target'])
                                    targetCol = i;
                                else if (col.roles['Weight'])
                                    weightCol = i;
                                else if (col.roles['LinkType'])
                                    linkTypeCol = i;
                                else if (col.roles['SourceType'])
                                    sourceTypeCol = i;
                                else if (col.roles['TargetType'])
                                    targetTypeCol = i;
                            }
                        }
                    }
                    if (dataView && dataView.table) {
                        rows = dataView.table.rows;
                    }
                    if (sourceCol < 0 || targetCol < 0)
                        return {
                            nodes: {},
                            links: [],
                            minFiles: 0,
                            maxFiles: 0,
                            linkedByName: {},
                            linkTypes: {},
                        };
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(categorical.categories[0].source, formatStringProp);
                    var categoryTargetFormatString = visuals.valueFormatter.getFormatString(categorical.categories[1].source, formatStringProp);
                    var weightFormatString = visuals.valueFormatter.getFormatString(categorical.values ? categorical.values[0].source : null, formatStringProp, true);
                    rows.forEach(function (item) {
                        linkedByName[item[sourceCol] + "," + item[targetCol]] = 1;
                        var source = nodes[item[sourceCol]] ||
                            (nodes[item[sourceCol]] = { name: item[sourceCol], image: sourceTypeCol > 0 ? item[sourceTypeCol] : '', adj: {} });
                        var target = nodes[item[targetCol]] ||
                            (nodes[item[targetCol]] = { name: item[targetCol], image: targetTypeCol > 0 ? item[targetTypeCol] : '', adj: {} });
                        source.adj[target.name] = 1;
                        target.adj[source.name] = 1;
                        tooltipInfo = [{
                                displayName: dataView.metadata.columns[0].displayName,
                                value: visuals.valueFormatter.format(source.name, categorySourceFormatString)
                            }, {
                                displayName: dataView.metadata.columns[1].displayName,
                                value: visuals.valueFormatter.format(target.name, categoryTargetFormatString)
                            }];
                        if (weightCol > 0)
                            tooltipInfo.push({
                                displayName: dataView.metadata.columns[2].displayName,
                                value: visuals.valueFormatter.format(item[weightCol], weightFormatString)
                            });
                        var link = {
                            source: source,
                            target: target,
                            filecount: weightCol > 0 ? item[weightCol] : 0,
                            type: linkTypeCol > 0 ? item[linkTypeCol] : '',
                            tooltipInfo: tooltipInfo,
                        };
                        if (linkTypeCol > 0) {
                            if (!linkDataPoints[item[linkTypeCol]]) {
                                linkDataPoints[item[linkTypeCol]] = {
                                    label: item[linkTypeCol],
                                    color: colors.getColorByIndex(linkTypeCount++).value,
                                };
                            }
                            ;
                        }
                        ;
                        if (link.filecount < minFiles) {
                            minFiles = link.filecount;
                        }
                        ;
                        if (link.filecount > maxFiles) {
                            maxFiles = link.filecount;
                        }
                        ;
                        links.push(link);
                    });
                    return {
                        nodes: nodes,
                        links: links,
                        minFiles: minFiles,
                        maxFiles: maxFiles,
                        linkedByName: linkedByName,
                        linkTypes: linkDataPoints,
                    };
                };
                ForceGraph.prototype.init = function (options) {
                    this.root = d3.select(options.element.get(0));
                    this.forceLayout = d3.layout.force();
                    this.colors = options.style.colorPalette.dataColors;
                    this.options = this.getDefaultOptions();
                };
                ForceGraph.prototype.update = function (options) {
                    var _this = this;
                    if (!options.dataViews || (options.dataViews.length < 1))
                        return;
                    this.data = ForceGraph.converter(this.dataView = options.dataViews[0], this.colors);
                    if (!this.data)
                        return;
                    if (options.dataViews[0].metadata && options.dataViews[0].metadata.objects)
                        this.updateOptions(options.dataViews[0].metadata.objects);
                    this.viewport = options.viewport;
                    var k = Math.sqrt(Object.keys(this.data.nodes).length / (this.viewport.width * this.viewport.height));
                    this.root.selectAll("svg").remove();
                    var svg = this.root
                        .append("svg")
                        .attr("width", this.viewport.width)
                        .attr("height", this.viewport.height)
                        .classed(ForceGraph.VisualClassName, true);
                    this.forceLayout
                        .gravity(100 * k)
                        .links(this.data.links)
                        .size([this.viewport.width, this.viewport.height])
                        .linkDistance(100)
                        .charge(this.options.charge / k)
                        .on("tick", this.tick());
                    this.updateNodes();
                    this.forceLayout.start();
                    // uncomment if we don't need the marker-end workaround
                    //if (this.options.showArrow) {
                    // build the arrow.
                    //function marker(d, i) {
                    //    let val = "mid_" + i;
                    //    svg.append("defs").selectAll("marker")
                    //        .data([val])      // Different link/path types can be defined here
                    //        .enter().append("marker")    // This section adds in the arrows
                    //        .attr("id", String)
                    //        .attr("viewBox", "0 -5 10 10")
                    //        .attr("refX", 10)
                    //        .attr("refY", 0)
                    //        .attr("markerWidth", 6)
                    //        .attr("markerHeight", 6)
                    //        .attr("orient", "auto")
                    //        .attr("markerUnits", "userSpaceOnUse")
                    //        .append("path")
                    //        .attr("d", "M0,-5L10,0L0,5")
                    //    //below works if no marker-end workaround needed
                    //        .style("fill", d => this.getLinkColor(d))
                    //    ;
                    //    return "url(#" + val + ")";
                    //}
                    //}
                    this.paths = svg.selectAll(".link")
                        .data(this.forceLayout.links())
                        .enter().append("path")
                        .attr("class", "link")
                        .attr("id", function (d, i) { return "linkid_" + i; })
                        .attr("stroke-width", function (d) { return _this.options.thickenLink ? _this.scale1to10(d.filecount) : _this.options.defaultLinkThickness; })
                        .style("stroke", function (d) { return _this.getLinkColor(d); })
                        .style("fill", function (d) { if (_this.options.showArrow)
                        return _this.getLinkColor(d); })
                        .on("mouseover", this.fadePath(.3, this.options.defaultLinkHighlightColor))
                        .on("mouseout", this.fadePath(1, this.options.defaultLinkColor));
                    visuals.TooltipManager.addTooltip(this.paths, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                    if (this.options.showLabel) {
                        svg.selectAll(".linklabelholder")
                            .data(this.forceLayout.links())
                            .enter().append("g")
                            .attr("class", "linklabelholder")
                            .append("text")
                            .attr("class", "linklabel")
                            .attr("y", "-12")
                            .attr("text-anchor", "middle")
                            .style("fill", "#000")
                            .append("textPath")
                            .attr("xlink:href", function (d, i) { return "#linkid_" + i; })
                            .attr("startOffset", "25%") //use "50%" if we don't need the marker-end workaround
                            .text(function (d) { return _this.options.colorLink === linkColorType.byLinkType ? d.type : d.filecount; });
                    }
                    // define the nodes
                    this.nodes = svg.selectAll(".node")
                        .data(this.forceLayout.nodes())
                        .enter().append("g")
                        .attr("class", "node")
                        .call(this.forceLayout.drag)
                        .on("mouseover", this.fadeNode(.3, this.options.defaultLinkHighlightColor))
                        .on("mouseout", this.fadeNode(1, this.options.defaultLinkColor))
                        .on("mousedown", function () { return d3.event.stopPropagation(); })
                        .attr("drag-resize-disabled", true);
                    // add the nodes
                    if (this.options.displayImage) {
                        this.nodes.append("image")
                            .attr("xlink:href", function (d) {
                            return d.image && d.image !== '' ?
                                _this.options.imageUrl + d.image + _this.options.imageExt :
                                (_this.options.defaultImage && _this.options.defaultImage !== '' ?
                                    _this.options.imageUrl + _this.options.defaultImage + _this.options.imageExt :
                                    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABsAAAAbCAMAAAHNDTTxAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAACuUExURQAAAMbGxvLy8sfHx/Hx8fLy8vHx8cnJycrKyvHx8fHx8cvLy/Ly8szMzM3NzfHx8dDQ0PHx8fLy8vHx8e/v79LS0tPT0/Ly8tTU1NXV1dbW1vHx8fHx8fDw8NjY2PT09PLy8vLy8vHx8fLy8vHx8fHx8enp6fDw8PLy8uPj4+Tk5OXl5fHx8b+/v/Pz8+bm5vHx8ejo6PLy8vHx8fLy8sTExPLy8vLy8sXFxfHx8YCtMbUAAAA6dFJOUwD/k/+b7/f///+r/////0z/w1RcEP//ZP///4fj/v8Yj3yXn/unDEhQ////YP9Y/8//aIMU/9+L/+fzC4s1AAAACXBIWXMAABcRAAAXEQHKJvM/AAABQElEQVQoU5WS61LCMBCFFymlwSPKVdACIgWkuNyL+P4v5ibZ0jKjP/xm0uw5ySa7mRItAhnMoIC5TwQZdCZiZjcoC8WU6EVsmZgzoqGdxafgvJAvjUXCb2M+0cXNsd/GDarZqSf7av3M2P1E3xhfLkPUvLD5joEYwVVJQXM6+9McWUwLf4nDTCQZAy96UoDjNI/jhl3xPLbQamu8xD7iaIsPKw7GJ7KZEnWLY3Gi8EFj5nqibXnwD5VEGjJXk5sbpLppfvvo1RazQVrhSopPK4TODrtnjS3dY4ic8KurruWQYF+UG60BacexTMyT2jlNg41dOmKvTpkUd/Jevy7ZxQ61ULRUpoododx8GeDPvIrktbFVdUsK6f8Na5VlVpjZJtowTXVy7kfXF5wCaV1tqXAFuIdWJu+JviaQzNzfQvQDGKRXXEmy83cAAAAASUVORK5CYII=');
                        })
                            .attr("x", "-12px")
                            .attr("y", "-12px")
                            .attr("width", "24px")
                            .attr("height", "24px");
                    }
                    else {
                        this.nodes.append("circle")
                            .attr("r", function (d) { return d.weight < 5 ? 5 : d.weight; });
                    }
                    // add the text
                    if (this.options.showDataLabels) {
                        this.nodes.append("text")
                            .attr({
                            x: 12,
                            dy: ".35em"
                        })
                            .style({
                            fill: this.options.labelColor,
                            'font-size': PixelConverter.fromPoint(this.options.fontSize)
                        })
                            .text(function (d) { return d.name ? (d.name.length > _this.options.nameMaxLength ? d.name.substr(0, _this.options.nameMaxLength) : d.name) : ''; });
                    }
                };
                ForceGraph.prototype.updateNodes = function () {
                    var oldNodes = this.forceLayout.nodes();
                    this.forceLayout.nodes(d3.values(this.data.nodes));
                    this.forceLayout.nodes().forEach(function (node, i) {
                        if (!oldNodes[i]) {
                            return;
                        }
                        node.x = oldNodes[i].x;
                        node.y = oldNodes[i].y;
                        node.px = oldNodes[i].px;
                        node.py = oldNodes[i].py;
                        node.weight = oldNodes[i].weight;
                    });
                };
                ForceGraph.prototype.tick = function () {
                    var _this = this;
                    var viewport = this.viewportIn;
                    // limitX and limitY is necessary when you minimize the graph and then resize it to normal.
                    //"width/height * 20" seems enough to move nodes freely by force layout.
                    var maxWidth = viewport.width * 20;
                    var maxHeight = viewport.height * 20;
                    var limitX = function (x) { return Math.max((viewport.width - maxWidth) / 2, Math.min((viewport.width + maxWidth) / 2, x)); };
                    var limitY = function (y) { return Math.max((viewport.height - maxHeight) / 2, Math.min((viewport.height + maxHeight) / 2, y)); };
                    //use this if we don't need the marker-end workaround
                    //path.attr("d", function (d) {
                    //    let dx = d.target.x - d.source.x,
                    //        dy = d.target.y - d.source.y,
                    //        dr = Math.sqrt(dx * dx + dy * dy);
                    //    // x and y distances from center to outside edge of target node
                    //    let offsetX = (dx * d.target.radius) / dr;
                    //    let offsetY = (dy * d.target.radius) / dr;
                    //    return "M" +
                    //        d.source.x + "," +
                    //        d.source.y + "A" +
                    //        dr + "," + dr + " 0 0,1 " +
                    //        (d.target.x - offsetX) + "," +
                    //        (d.target.y - offsetY);
                    //});
                    var getPath = this.options.showArrow ?
                        //this is for marker-end workaround, build the marker with the path
                        //this is for marker-end workaround, build the marker with the path
                        function (d) {
                            d.source.x = limitX(d.source.x);
                            d.source.y = limitY(d.source.y);
                            d.target.x = limitX(d.target.x);
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy), theta = Math.atan2(dy, dx) + Math.PI / 7.85, d90 = Math.PI / 2, dtxs = d.target.x - 6 * Math.cos(theta), dtys = d.target.y - 6 * Math.sin(theta);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "A" +
                                dr + "," + dr + " 0 0 1," +
                                d.target.x + "," +
                                d.target.y +
                                "A" + dr + "," + dr + " 0 0 0," + d.source.x + "," + d.source.y + "M" + dtxs + "," + dtys + "l" + (3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (-3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "L" + (dtxs - 3.5 * Math.cos(d90 - theta) - 10 * Math.cos(theta)) + "," + (dtys + 3.5 * Math.sin(d90 - theta) - 10 * Math.sin(theta)) + "z";
                        } :
                        function (d) {
                            d.source.x = limitX(d.source.x);
                            d.source.y = limitY(d.source.y);
                            d.target.x = limitX(d.target.x);
                            d.target.y = limitY(d.target.y);
                            var dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy);
                            return "M" +
                                d.source.x + "," +
                                d.source.y + "A" +
                                dr + "," + dr + " 0 0,1 " +
                                d.target.x + "," +
                                d.target.y;
                        };
                    return function () {
                        _this.paths.each(function () { this.parentNode.insertBefore(this, this); });
                        _this.paths.attr("d", getPath);
                        _this.nodes.attr("transform", function (d) { return "translate(" + limitX(d.x) + "," + limitY(d.y) + ")"; });
                    };
                };
                ForceGraph.prototype.fadePath = function (opacity, highlight) {
                    var _this = this;
                    if (this.options.colorLink !== linkColorType.interactive)
                        return;
                    return function (d) {
                        _this.paths.style("stroke-opacity", function (o) { return o.source === d.source && o.target === d.target ? 1 : opacity; });
                        _this.paths.style("stroke", function (o) { return o.source === d.source && o.target === d.target ? highlight : _this.options.defaultLinkColor; });
                    };
                };
                ForceGraph.prototype.isReachable = function (a, b) {
                    if (a.name === b.name)
                        return true;
                    if (this.data.linkedByName[a.name + "," + b.name])
                        return true;
                    var visited = {};
                    for (var name_1 in this.data.nodes) {
                        visited[name_1] = false;
                    }
                    ;
                    visited[a.name] = true;
                    var stack = [];
                    stack.push(a.name);
                    while (stack.length > 0) {
                        var cur = stack.pop();
                        var node = this.data.nodes[cur];
                        for (var nb in node.adj) {
                            if (nb === b.name)
                                return true;
                            if (!visited[nb]) {
                                visited[nb] = true;
                                stack.push(nb);
                            }
                        }
                    }
                    ;
                    return false;
                };
                ForceGraph.prototype.fadeNode = function (opacity, highlight) {
                    var _this = this;
                    if (this.options.colorLink !== linkColorType.interactive)
                        return;
                    var isConnected = function (a, b) { return _this.data.linkedByName[a.name + "," + b.name] || _this.data.linkedByName[b.name + "," + a.name] || a.name === b.name; };
                    return function (d) {
                        var that = _this;
                        _this.nodes.style("stroke-opacity", function (o) {
                            var thisOpacity = (that.options.highlightReachableLinks ? that.isReachable(d, o) : isConnected(d, o)) ? 1 : opacity;
                            this.setAttribute('fill-opacity', thisOpacity);
                            return thisOpacity;
                        });
                        _this.paths.style("stroke-opacity", function (o) {
                            return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) :
                                (o.source === d || o.target === d)) ? 1 : opacity;
                        });
                        _this.paths.style("stroke", function (o) {
                            return (_this.options.highlightReachableLinks ? _this.isReachable(d, o.source) :
                                (o.source === d || o.target === d)) ? highlight : _this.options.defaultLinkColor;
                        });
                    };
                };
                ForceGraph.prototype.destroy = function () {
                    this.root = null;
                };
                ForceGraph.VisualClassName = 'forceGraph';
                ForceGraph.capabilities = {
                    dataRoles: [
                        {
                            name: 'Source',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Source',
                        },
                        {
                            name: 'Target',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Target',
                        },
                        {
                            name: 'Weight',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Weight',
                        },
                        {
                            name: 'LinkType',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'LinkType',
                            description: 'Links can be colored by link types',
                        },
                        {
                            name: 'SourceType',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'SourceType',
                            description: 'Source type represents the image name for source entities',
                        },
                        {
                            name: 'TargetType',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'TargetType',
                            description: 'Target type represents the image name for target entities',
                        },
                    ],
                    objects: {
                        general: {
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                }
                            }
                        },
                        labels: {
                            displayName: 'Data labels',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                color: {
                                    displayName: 'Fill',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        links: {
                            displayName: 'Links',
                            properties: {
                                showArrow: {
                                    type: { bool: true },
                                    displayName: 'Arrow'
                                },
                                showLabel: {
                                    type: { bool: true },
                                    displayName: 'Label',
                                    description: 'Displays weight on links',
                                },
                                colorLink: {
                                    type: { enumeration: linkColorType.type },
                                    displayName: 'Color',
                                },
                                thickenLink: {
                                    type: { bool: true },
                                    displayName: 'Thickness',
                                    description: 'Thickenss of links represents weight',
                                },
                            }
                        },
                        nodes: {
                            displayName: 'Nodes',
                            properties: {
                                displayImage: {
                                    type: { bool: true },
                                    displayName: 'Image',
                                    description: 'Images are loaded from image url + source or target type + image extension',
                                },
                                defaultImage: {
                                    type: { text: true },
                                    displayName: 'Default image'
                                },
                                imageUrl: {
                                    type: { text: true },
                                    displayName: 'Image url'
                                },
                                imageExt: {
                                    type: { text: true },
                                    displayName: 'Image extension'
                                },
                                nameMaxLength: {
                                    type: { numeric: true },
                                    displayName: 'Max name length',
                                    description: 'Max length of the name of entities displayed',
                                },
                                highlightReachableLinks: {
                                    type: { bool: true },
                                    displayName: 'Highlight all reachable links',
                                    description: "In interactive mode, whether a node's all reachable links will be highlighted",
                                },
                            }
                        },
                        size: {
                            displayName: 'Size',
                            properties: {
                                charge: {
                                    type: { numeric: true },
                                    displayName: 'Charge',
                                    description: 'The larger the negative charge the more apart the entities, must be negative but greater than -100',
                                },
                            }
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Source': { max: 1 }, 'Target': { max: 1 }, 'Weight': { max: 1 }, 'LinkType': { max: 1 }, 'SourceType': { max: 1 }, 'TargetType': { max: 1 } },
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Source' },
                                    dataReductionAlgorithm: { top: {} }
                                },
                                values: {
                                    select: [
                                        { bind: { to: 'Target' } },
                                        { bind: { to: 'Weight' } },
                                        { bind: { to: 'LinkType' } },
                                        { bind: { to: 'SourceType' } },
                                        { bind: { to: 'TargetType' } },
                                    ],
                                },
                                rowCount: { preferred: { min: 1 } }
                            },
                        }],
                    suppressDefaultTitle: true,
                };
                return ForceGraph;
            }());
            samples.ForceGraph = ForceGraph;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var PixelConverter = jsCommon.PixelConverter;
            var PercentFormat = "0.00 %;-0.00 %;0.00 %";
            var MillisecondsInADay = 86400000;
            var MillisecondsInWeek = 604800000;
            var MillisecondsInAMonth = 2629746000;
            var MillisecondsInAYear = 31556952000;
            samples.DefaultDateType = "Week";
            var ChartLineHeight = 40;
            var PaddingTasks = 5;
            var dateTypeSelector;
            (function (dateTypeSelector) {
                dateTypeSelector.day = 'Day';
                dateTypeSelector.week = 'Week';
                dateTypeSelector.month = 'Month';
                dateTypeSelector.year = 'Year';
                dateTypeSelector.type = powerbi.createEnumType([
                    { value: dateTypeSelector.day, displayName: 'Day' },
                    { value: dateTypeSelector.week, displayName: 'Week' },
                    { value: dateTypeSelector.month, displayName: 'Month' },
                    { value: dateTypeSelector.year, displayName: 'Year' }
                ]);
            })(dateTypeSelector = samples.dateTypeSelector || (samples.dateTypeSelector = {}));
            ;
            samples.GanttChartProps = {
                legend: {
                    show: { objectName: 'legend', propertyName: 'show' },
                    position: { objectName: 'legend', propertyName: 'position' },
                    showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                    titleText: { objectName: 'legend', propertyName: 'titleText' },
                    labelColor: { objectName: 'legend', propertyName: 'labelColor' },
                    fontSize: { objectName: 'legend', propertyName: 'fontSize' },
                },
                taskCompletion: {
                    fill: { objectName: 'taskCompletion', propertyName: 'fill' },
                },
                dataPoint: {
                    fill: { objectName: 'dataPoint', propertyName: 'fill' },
                },
                taskLabels: {
                    show: { objectName: 'taskLabels', propertyName: 'show' },
                    fill: { objectName: 'taskLabels', propertyName: 'fill' },
                    fontSize: { objectName: 'taskLabels', propertyName: 'fontSize' },
                    width: { objectName: 'taskLabels', propertyName: 'width' },
                },
                taskResource: {
                    show: { objectName: 'taskResource', propertyName: 'show' },
                    fill: { objectName: 'taskResource', propertyName: 'fill' },
                    fontSize: { objectName: 'taskResource', propertyName: 'fontSize' },
                },
                ganttDateType: {
                    type: { objectName: 'ganttDateType', propertyName: 'type' },
                }
            };
            var Selectors;
            (function (Selectors) {
                var CreateClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                Selectors.ClassName = CreateClassAndSelector("gantt");
                Selectors.Chart = CreateClassAndSelector("chart");
                Selectors.ChartLine = CreateClassAndSelector("chart-line");
                Selectors.Body = CreateClassAndSelector("gantt-body");
                Selectors.AxisGroup = CreateClassAndSelector("axis");
                Selectors.Domain = CreateClassAndSelector("domain");
                Selectors.AxisTick = CreateClassAndSelector("tick");
                Selectors.Tasks = CreateClassAndSelector("tasks");
                Selectors.SingleTask = CreateClassAndSelector("task");
                Selectors.TaskRect = CreateClassAndSelector("task-rect");
                Selectors.TaskProgress = CreateClassAndSelector("task-progress");
                Selectors.TaskResource = CreateClassAndSelector("task-resource");
                Selectors.SingleMilestone = CreateClassAndSelector("milestone");
                Selectors.TaskLabels = CreateClassAndSelector("task-labels");
                Selectors.TaskLines = CreateClassAndSelector("task-lines");
                Selectors.SingleTaskLine = CreateClassAndSelector("task-line");
                Selectors.Label = CreateClassAndSelector("label");
                Selectors.LegendItems = CreateClassAndSelector("legendItem");
                Selectors.LegendTitle = CreateClassAndSelector("legendTitle");
            })(Selectors || (Selectors = {}));
            var Gantt = (function () {
                function Gantt() {
                    this.textProperties = {
                        fontFamily: 'wf_segoe-ui_normal',
                        fontSize: jsCommon.PixelConverter.toString(9),
                    };
                    this.margin = {
                        top: 50,
                        right: 40,
                        bottom: 40,
                        left: 10
                    };
                }
                Gantt.getMaxTaskOpacity = function () {
                    return Gantt.DefaultValues.MaxTaskOpacity;
                };
                Gantt.getMinTaskOpacity = function () {
                    return Gantt.DefaultValues.MinTaskOpacity;
                };
                Gantt.prototype.init = function (options) {
                    var element = options.element;
                    this.style = options.style;
                    this.body = d3.select(element.get(0));
                    this.hostServices = options.host;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
                    this.interactivityService = visuals.createInteractivityService(this.hostServices);
                    this.createViewport(element);
                    this.updateChartSize(options.viewport);
                    this.behavior = new GanttChartBehavior();
                    this.colors = options.style.colorPalette.dataColors;
                    this.data = {
                        legendData: null,
                        series: null,
                        showLegend: null
                    };
                };
                /**
                 * Create the vieport area of the gantt chart
                 */
                Gantt.prototype.createViewport = function (element) {
                    //create div container to the whole viewport area
                    this.ganttDiv = this.body.append("div")
                        .classed(Selectors.Body.class, true);
                    //create container to the svg area
                    this.ganttSvg = this.ganttDiv
                        .append("svg")
                        .classed(Selectors.ClassName.class, true);
                    //create clear catcher
                    this.clearCatcher = visuals.appendClearCatcher(this.ganttSvg);
                    //create axis container
                    this.axisGroup = this.ganttSvg
                        .append("g")
                        .classed(Selectors.AxisGroup.class, true);
                    //create task lines container
                    this.lineGroup = this.ganttSvg
                        .append("g")
                        .classed(Selectors.TaskLines.class, true);
                    //create chart container
                    this.chartGroup = this.ganttSvg
                        .append("g")
                        .classed(Selectors.Chart.class, true);
                    //create tasks container
                    this.taskGroup = this.chartGroup
                        .append("g")
                        .classed(Selectors.Tasks.class, true);
                    //create legend container
                    this.legend = visuals.createLegend(element.children(Selectors.Body.selector), this.isInteractiveChart, this.interactivityService, true, visuals.LegendPosition.Top);
                };
                /**
                 * Clear the viewport area
                 */
                Gantt.prototype.clearViewport = function () {
                    this.body.selectAll(Selectors.LegendItems.selector).remove();
                    this.body.selectAll(Selectors.LegendTitle.selector).remove();
                    this.axisGroup.selectAll(Selectors.AxisTick.selector).remove();
                    this.axisGroup.selectAll(Selectors.Domain.selector).remove();
                    this.lineGroup.selectAll("*").remove();
                    this.chartGroup.selectAll(Selectors.ChartLine.selector).remove();
                    this.chartGroup.selectAll(Selectors.SingleTask.selector).remove();
                };
                /**
                 * Update div container size to the whole viewport area
                 * @param viewport The vieport to change it size
                 */
                Gantt.prototype.updateChartSize = function (viewport) {
                    this.ganttDiv.style({
                        height: PixelConverter.toString(viewport.height),
                        width: PixelConverter.toString(viewport.width)
                    });
                };
                /**
               * Create the gantt tasks series based on all task types
               * @param taskTypes All unique types from the tasks array.
               */
                Gantt.prototype.createSeries = function (objects, tasks) {
                    var colorHelper = new visuals.ColorHelper(this.colors, samples.GanttChartProps.dataPoint.fill);
                    var taskGroup = _.groupBy(tasks, function (t) { return t.taskType; });
                    var taskTypes = Gantt.getAllTasksTypes(this.dataView);
                    var series = _.map(taskTypes.types, function (type) {
                        return {
                            tasks: taskGroup[type],
                            fill: colorHelper.getColorForMeasure(objects, type),
                            name: type,
                            identity: visuals.SelectionId.createWithMeasure(type),
                            selected: false
                        };
                    });
                    return series;
                };
                /**
                * Convert the dataView to view model
                * @param dataView The data Model
                */
                Gantt.converter = function (dataView, colorPalette) {
                    var taskLabelsShow = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.show, true);
                    var taskLabelsColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor);
                    var taskLabelsFontSize = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);
                    var taskLabelsWidth = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskLabels.width, taskLabelsShow ? Gantt.DefaultValues.TaskLabelWidth : 0);
                    var taskProgressColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor);
                    var taskResourceColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, samples.GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor);
                    var taskResourceFontSize = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize);
                    var taskResourceShow = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.taskResource.show, true);
                    var dateType = powerbi.DataViewObjects.getValue(dataView.metadata.objects, samples.GanttChartProps.ganttDateType.type, samples.DefaultDateType);
                    var taskTypes = Gantt.getAllTasksTypes(dataView);
                    var colorHelper = new visuals.ColorHelper(colorPalette, samples.GanttChartProps.dataPoint.fill);
                    var legendData = {
                        fontSize: Gantt.DefaultValues.LegendFontSize,
                        dataPoints: [],
                        title: taskTypes.typeName
                    };
                    legendData.dataPoints = _.map(taskTypes.types, function (type) {
                        return {
                            label: type,
                            color: colorHelper.getColorForMeasure(dataView.metadata.objects, type),
                            icon: visuals.LegendIcon.Circle,
                            selected: false,
                            identity: visuals.SelectionId.createWithMeasure(type)
                        };
                    });
                    var settings = {
                        taskLabelsShow: taskLabelsShow,
                        taskLabelsColor: taskLabelsColor,
                        taskLabelsFontSize: taskLabelsFontSize,
                        taskLabelsWidth: taskLabelsWidth,
                        taskProgressColor: taskProgressColor,
                        taskResourceShow: taskResourceShow,
                        taskResourceColor: taskResourceColor,
                        taskResourceFontSize: taskResourceFontSize,
                        legendData: legendData,
                        taskTypes: taskTypes,
                        dateType: dateType
                    };
                    return settings;
                };
                /**
                 * Returns the chart formatters
                 * @param dataView The data Model
                 */
                Gantt.prototype.parseSettings = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns)
                        return null;
                    var dateFormat = "d";
                    var numberFormat = "#";
                    for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                        var dvColumn = _a[_i];
                        if (!!dataView.categorical.categories) {
                            for (var _b = 0, _c = dataView.categorical.categories; _b < _c.length; _b++) {
                                var dvCategory = _c[_b];
                                if (this.hasRole(dvCategory.source, "StartDate"))
                                    dateFormat = dvColumn.format;
                            }
                        }
                    }
                    return {
                        startDateFormatter: visuals.valueFormatter.create({ format: dateFormat }),
                        durationFormatter: visuals.valueFormatter.create({ format: numberFormat }),
                        completionFormatter: visuals.valueFormatter.create({ format: PercentFormat, value: 1, allowFormatBeautification: true })
                    };
                };
                Gantt.prototype.isValidDate = function (date) {
                    if (Object.prototype.toString.call(date) !== "[object Date]")
                        return false;
                    return !isNaN(date.getTime());
                };
                Gantt.prototype.convertToDecimal = function (number) {
                    if (!(number >= 0 && number <= 1))
                        return (number / 100);
                    return number;
                };
                /**
                * Create task objects dataView
                * @param dataView The data Model.
                * @param formatters task attributes represented format.
                * @param series An array that holds the color data of different task groups.
                */
                Gantt.prototype.createTasks = function (dataView, formatters) {
                    var _this = this;
                    var columnSource = dataView.table.columns;
                    var data = dataView.table.rows;
                    var categories = dataView.categorical.categories[0];
                    var colorHelper = new visuals.ColorHelper(this.colors, samples.GanttChartProps.dataPoint.fill);
                    return data.map(function (child, index) {
                        var dateString = _this.getTaskProperty(columnSource, child, "StartDate");
                        //let startDate = new Date(dateString);
                        dateString = _this.isValidDate(dateString) ? dateString : new Date(Date.now());
                        var duration = _this.getTaskProperty(columnSource, child, "Duration");
                        var completionValue = _this.getTaskProperty(columnSource, child, "Completion");
                        var completion = _this.convertToDecimal(completionValue);
                        completion = completion <= 1 ? completion : 1;
                        var taskType = _this.getTaskProperty(columnSource, child, "Legend");
                        var tasksTypeColor = colorHelper.getColorForMeasure(dataView.metadata.objects, taskType);
                        var task = {
                            id: index,
                            name: _this.getTaskProperty(columnSource, child, "Task"),
                            start: dateString ? dateString : new Date(Date.now()),
                            duration: duration > 0 ? duration : 1,
                            end: null,
                            completion: completion > 0 ? completion : 0,
                            resource: _this.getTaskProperty(columnSource, child, "Resource"),
                            taskType: taskType,
                            color: tasksTypeColor ? tasksTypeColor : Gantt.DefaultValues.TaskColor,
                            tooltipInfo: null,
                            description: "",
                            identity: visuals.SelectionId.createWithIdAndMeasure(categories.identity[index], taskType),
                            selected: false
                        };
                        task.end = d3.time.day.offset(task.start, task.duration);
                        task.tooltipInfo = _this.getTooltipInfo(task, formatters);
                        return task;
                    });
                };
                /**
                * Gets all unique types from the tasks array
                * @param dataView The data model.
                */
                Gantt.getAllTasksTypes = function (dataView) {
                    var types = [];
                    var groupName = "";
                    var taskTypes;
                    var data = dataView.table.rows;
                    var index = _.findIndex(dataView.table.columns, function (col) { return col.roles.hasOwnProperty("Legend"); });
                    if (index !== -1) {
                        groupName = dataView.table.columns[index].displayName;
                        types = _.unique(data, function (d) { return d[index]; }).map(function (d) { return d[index]; });
                    }
                    taskTypes = {
                        typeName: groupName,
                        types: types
                    };
                    return taskTypes;
                };
                /**
                * Get the tooltip info (data display names & formated values)
                * @param task All task attributes.
                * @param formatters Formatting options for gantt attributes.
                */
                Gantt.prototype.getTooltipInfo = function (task, formatters, timeInterval) {
                    if (timeInterval === void 0) { timeInterval = "Days"; }
                    var tooltipDataArray = [];
                    if (task.taskType)
                        tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[0].name, value: task.taskType });
                    tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[1].name, value: task.name });
                    if (!isNaN(task.start.getDate()))
                        tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[2].name, value: formatters.startDateFormatter.format(task.start.toLocaleDateString()) });
                    tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[3].name, value: formatters.durationFormatter.format(task.duration) + " " + timeInterval });
                    tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[4].name, value: formatters.completionFormatter.format(task.completion) });
                    if (task.resource)
                        tooltipDataArray.push({ displayName: Gantt.capabilities.dataRoles[5].name, value: task.resource });
                    return tooltipDataArray;
                };
                /**
                 * Get task property from the data view
                 * @param columnSource
                 * @param child
                 * @param propertyName The property to get
                 */
                Gantt.prototype.getTaskProperty = function (columnSource, child, propertyName) {
                    if (!child ||
                        !columnSource ||
                        !(columnSource.length > 0) ||
                        !columnSource[0].roles)
                        return null;
                    var index = columnSource.indexOf(columnSource.filter(function (x) { return x.roles[propertyName]; })[0]);
                    return index !== -1 ? child[index] : null;
                };
                /**
                 * Check if dataView has a given role
                 * @param column The dataView headers
                 * @param name The role to find
                 */
                Gantt.prototype.hasRole = function (column, name) {
                    var roles = column.roles;
                    return roles && roles[name];
                };
                /**
                 * Check if task has data for task
                 * @param dataView
                 */
                Gantt.prototype.isChartHasTask = function (dataView) {
                    if (dataView.table &&
                        dataView.table.columns) {
                        for (var _i = 0, _a = dataView.table.columns; _i < _a.length; _i++) {
                            var column = _a[_i];
                            if (this.hasRole(column, "Task")) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                /**
                 * Get legend data, calculate position and draw it
                 * @param ganttChartData Data for series and legend
                 */
                Gantt.prototype.renderLegend = function (legendData) {
                    if (!legendData)
                        return;
                    if (this.legendObjectProperties) {
                        visuals.LegendData.update(legendData, this.legendObjectProperties);
                        var position;
                        position = this.legendObjectProperties[visuals.legendProps.position];
                        if (position)
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                    }
                    var viewport = this.viewport;
                    this.legend.drawLegend(legendData, { height: viewport.height, width: viewport.width });
                    visuals.Legend.positionChartArea(this.ganttSvg, this.legend);
                };
                Gantt.prototype.parseLegendProperties = function (dataView) {
                    if (!dataView || !dataView.metadata) {
                        this.legendObjectProperties = {};
                        return;
                    }
                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'legend', {});
                };
                /**
                * Called on data change or resizing
                * @param options The visual option that contains the dataview and the viewport
                */
                Gantt.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    var dataView = options.dataViews[0];
                    if (!this.isChartHasTask(dataView) || options.dataViews[0].table.rows.length === 0) {
                        this.clearViewport();
                        return;
                    }
                    this.dataView = dataView;
                    var viewport = options.viewport;
                    this.viewport = viewport;
                    this.updateChartSize(viewport);
                    var viewModel = Gantt.converter(dataView, this.colors), formatters = this.parseSettings(dataView), tasks = this.createTasks(dataView, formatters);
                    this.parseLegendProperties(dataView);
                    this.renderLegend(viewModel.legendData);
                    this.data.series = this.createSeries(dataView.metadata.objects, tasks);
                    this.viewModel = viewModel;
                    if (this.interactivityService) {
                        this.interactivityService.applySelectionStateToData(tasks);
                        this.interactivityService.applySelectionStateToData(this.data.series);
                    }
                    if (tasks.length > 0) {
                        var tasksSortedByStartDate = _.sortBy(tasks, function (t) { return t.start; });
                        var tasksSortedByEndDate = _.sortBy(tasks, function (t) { return t.end; });
                        var dateTypeMilliseconds = this.getDateType();
                        var startDate = tasksSortedByStartDate[0].start, endDate = tasksSortedByEndDate[tasks.length - 1].end, ticks = Math.ceil(Math.round(endDate.valueOf() - startDate.valueOf()) / dateTypeMilliseconds);
                        ticks = ticks === 0 || ticks === 1 ? 2 : ticks;
                        var axisLength = ticks * 50;
                        this.ganttSvg
                            .attr({
                            height: PixelConverter.toString(tasks.length * ChartLineHeight + this.margin.top),
                            width: PixelConverter.toString(this.margin.left + this.viewModel.taskLabelsWidth + axisLength + Gantt.DefaultValues.ResourceWidth)
                        });
                        var viewportIn = {
                            height: viewport.height,
                            width: axisLength
                        };
                        var xAxisProperties = this.calculateAxes(viewportIn, this.textProperties, startDate, endDate, axisLength, ticks, false);
                        this.timeScale = xAxisProperties.scale;
                        this.renderAxis(xAxisProperties, 200);
                        this.renderTasks(tasks);
                        this.createMilestoneLine(tasks);
                        this.updateTaskLabels(tasks, viewModel.taskLabelsWidth);
                        this.updateElementsPositions(viewport, this.margin);
                        if (this.interactivityService) {
                            var behaviorOptions = {
                                clearCatcher: this.clearCatcher,
                                taskSelection: this.taskGroup.selectAll(Selectors.SingleTask.selector),
                                legendSelection: this.body.selectAll(Selectors.LegendItems.selector),
                                interactivityService: this.interactivityService
                            };
                            this.interactivityService.bind(tasks, this.behavior, behaviorOptions);
                        }
                    }
                };
                Gantt.prototype.getDateType = function () {
                    var milliSeconds = MillisecondsInWeek;
                    switch (this.viewModel.dateType) {
                        case "Day":
                            milliSeconds = MillisecondsInADay;
                            break;
                        case "Week":
                            milliSeconds = MillisecondsInWeek;
                            break;
                        case "Month":
                            milliSeconds = MillisecondsInAMonth;
                            break;
                        case "Year":
                            milliSeconds = MillisecondsInAYear;
                            break;
                    }
                    return milliSeconds;
                };
                Gantt.prototype.calculateAxes = function (viewportIn, textProperties, startDate, endDate, axisLength, ticksCount, scrollbarVisible) {
                    var dataTypeDatetime = powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Date);
                    var category = { displayName: "StartDate", queryName: "StartDate", type: dataTypeDatetime, index: 0 };
                    var visualOptions = {
                        viewport: viewportIn,
                        margin: this.margin,
                        forcedXDomain: [startDate, endDate],
                        forceMerge: false,
                        showCategoryAxisLabel: false,
                        showValueAxisLabel: false,
                        categoryAxisScaleType: powerbi.visuals.axisScale.linear,
                        valueAxisScaleType: null,
                        valueAxisDisplayUnits: 0,
                        categoryAxisDisplayUnits: 0,
                        trimOrdinalDataOnOverflow: false,
                        forcedTickCount: ticksCount
                    };
                    var width = viewportIn.width;
                    var axes = this.calculateAxesProperties(viewportIn, visualOptions, axisLength, category);
                    axes.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(axes, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                    // If labels do not fit and we are not scrolling, try word breaking
                    axes.willLabelsWordBreak = (!axes.willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(axes, this.margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);
                    return axes;
                };
                Gantt.prototype.calculateAxesProperties = function (viewportIn, options, axisLength, metaDataColumn) {
                    var xAxisProperties = visuals.AxisHelper.createAxis({
                        pixelSpan: viewportIn.width,
                        dataDomain: options.forcedXDomain,
                        metaDataColumn: metaDataColumn,
                        formatString: Gantt.DefaultValues.ganttFormatString,
                        outerPadding: 0,
                        isScalar: true,
                        isVertical: false,
                        forcedTickCount: options.forcedTickCount,
                        useTickIntervalForDisplayUnits: true,
                        isCategoryAxis: true,
                        getValueFn: function (index, type) {
                            return visuals.valueFormatter.format(new Date(index), Gantt.DefaultValues.ganttFormatString);
                        },
                        scaleType: options.categoryAxisScaleType,
                        axisDisplayUnits: options.categoryAxisDisplayUnits,
                    });
                    xAxisProperties.axisLabel = metaDataColumn.displayName;
                    return xAxisProperties;
                };
                Gantt.prototype.renderAxis = function (xAxisProperties, duration) {
                    var xAxis = xAxisProperties.axis;
                    xAxis.orient('bottom');
                    this.axisGroup.transition().duration(duration).call(xAxis);
                };
                /**
                * Update task labels and add its tooltips
                * @param tasks All tasks array
                * @param width The task label width
                */
                Gantt.prototype.updateTaskLabels = function (tasks, width) {
                    var _this = this;
                    var axisLabel;
                    var taskLineCoordinateX = 15;
                    var taskLabelsShow = this.viewModel ? this.viewModel.taskLabelsShow : true;
                    var taskLabelsColor = this.viewModel ? this.viewModel.taskLabelsColor : Gantt.DefaultValues.TaskLabelColor;
                    var taskLabelsFontSize = this.viewModel ? this.viewModel.taskLabelsFontSize : Gantt.DefaultValues.LabelFontSize;
                    if (taskLabelsShow) {
                        axisLabel = this.lineGroup.selectAll(Selectors.Label.selector).data(tasks);
                        axisLabel.enter().append("text").classed(Selectors.Label.class, true);
                        axisLabel.attr({
                            x: taskLineCoordinateX,
                            y: function (task, i) { return _this.getTaskLabelCoordinateY(task.id); },
                            fill: taskLabelsColor,
                            "stroke-width": 1
                        })
                            .style("font-size", PixelConverter.fromPoint(taskLabelsFontSize))
                            .text(function (task) { return task.name; });
                        axisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width - 20, powerbi.TextMeasurementService.svgEllipsis);
                        axisLabel.append("title").text(function (task) { return task.name; });
                        axisLabel.exit().remove();
                    }
                    else {
                        this.lineGroup.selectAll(Selectors.Label.selector).remove();
                    }
                };
                Gantt.prototype.renderTasks = function (tasks) {
                    var _this = this;
                    var taskSelection = this.taskGroup.selectAll(Selectors.SingleTask.selector).data(tasks);
                    var taskProgressColor = this.viewModel ? this.viewModel.taskProgressColor : Gantt.DefaultValues.ProgressColor;
                    var taskResourceShow = this.viewModel ? this.viewModel.taskResourceShow : true;
                    var padding = 4;
                    var taskResourceColor = this.viewModel ? this.viewModel.taskResourceColor : Gantt.DefaultValues.TaskResourceColor;
                    var taskResourceFontSize = this.viewModel ? this.viewModel.taskResourceFontSize : Gantt.DefaultValues.ResourceFontSize;
                    //render task group container 
                    taskSelection.enter().append("g").classed(Selectors.SingleTask.class, true);
                    //render task main rect
                    var taskRect = taskSelection.selectAll(Selectors.TaskRect.selector).data(function (d) { return [d]; });
                    taskRect.enter().append("rect").classed(Selectors.TaskRect.class, true);
                    taskRect.classed(Selectors.TaskRect.class, true).attr({
                        x: function (task) { return _this.timeScale(task.start); },
                        y: function (task) { return _this.getBarYCoordinate(task.id); },
                        width: function (task) { return _this.taskDurationToWidth(task); },
                        height: function () { return _this.getBarHeight(); }
                    }).style("fill", function (task) { return task.color; });
                    taskRect.exit().remove();
                    //render task progress rect 
                    var taskProgress = taskSelection.selectAll(Selectors.TaskProgress.selector).data(function (d) { return [d]; });
                    taskProgress.enter().append("rect").classed(Selectors.TaskProgress.class, true);
                    taskProgress.attr({
                        x: function (task) { return _this.timeScale(task.start); },
                        y: function (task) { return _this.getBarYCoordinate(task.id) + _this.getBarHeight() / 2 - Gantt.DefaultValues.ProgressBarHeight / 2; },
                        width: function (task) { return _this.setTaskProgress(task); },
                        height: Gantt.DefaultValues.ProgressBarHeight
                    }).style("fill", taskProgressColor);
                    taskProgress.exit().remove();
                    if (taskResourceShow) {
                        //render task resource labels
                        var taskResource = taskSelection.selectAll(Selectors.TaskResource.selector).data(function (d) { return [d]; });
                        taskResource.enter().append("text").classed(Selectors.TaskResource.class, true);
                        taskResource.attr({
                            x: function (task) { return _this.timeScale(task.end) + padding; },
                            y: function (task) { return (_this.getBarYCoordinate(task.id) + (_this.getBarHeight() / 2) + padding); }
                        })
                            .text(function (task) { return task.resource; })
                            .style({
                            fill: taskResourceColor,
                            "font-size": PixelConverter.fromPoint(taskResourceFontSize)
                        }).call(visuals.AxisHelper.LabelLayoutStrategy.clip, Gantt.DefaultValues.ResourceWidth - 10, powerbi.TextMeasurementService.svgEllipsis);
                        taskResource.exit().remove();
                    }
                    else {
                        taskSelection.selectAll(Selectors.TaskResource.selector).remove();
                    }
                    visuals.TooltipManager.addTooltip(taskSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    taskSelection.exit().remove();
                };
                Gantt.prototype.onClearSelection = function () {
                    this.selectionManager.clear();
                };
                /**
                 * Returns the matching Y coordinate for a given task index
                 * @param taskIndex Task Number
                 */
                Gantt.prototype.getTaskLabelCoordinateY = function (taskIndex) {
                    var fontSize = +this.getTaskLabelFontSize();
                    return (ChartLineHeight * taskIndex) + (this.getBarHeight() + 5 - (40 - fontSize) / 4);
                };
                /**
                 * Set the task progress bar in the gantt
                 * @param task All task attributes
                 */
                Gantt.prototype.setTaskProgress = function (task) {
                    var fraction = task.completion / 1.0, y = this.timeScale, progress = (y(task.end) - y(task.start)) * fraction;
                    return progress;
                };
                /**
                 * Set the task progress bar in the gantt
                 * @param lineNumber Line number that represents the task number
                 */
                Gantt.prototype.getBarYCoordinate = function (lineNumber) {
                    return (ChartLineHeight * lineNumber) + (PaddingTasks);
                };
                Gantt.prototype.getBarHeight = function () {
                    return ChartLineHeight / 1.5;
                };
                /**
                * convert task duration to width in the time scale
                * @param task The task to convert
                */
                Gantt.prototype.taskDurationToWidth = function (task) {
                    return this.timeScale(task.end) - this.timeScale(task.start);
                };
                Gantt.prototype.getTooltipForMilstoneLine = function (timestamp, milestoneTitle) {
                    var stringDate = new Date(timestamp).toDateString();
                    var tooltip = [{ displayName: milestoneTitle, value: stringDate }];
                    return tooltip;
                };
                /**
                * Create vertical dotted line that represent milestone in the time axis (by default it shows not time)
                * @param tasks All tasks array
                * @param timestamp the milestone to be shown in the time axis (default Date.now())
                */
                Gantt.prototype.createMilestoneLine = function (tasks, milestoneTitle, timestamp) {
                    if (milestoneTitle === void 0) { milestoneTitle = "Today"; }
                    if (timestamp === void 0) { timestamp = Date.now(); }
                    var line = [{
                            x1: this.timeScale(timestamp),
                            y1: 0,
                            x2: this.timeScale(timestamp),
                            y2: this.getMilestoneLineLength(tasks.length),
                            tooltipInfo: this.getTooltipForMilstoneLine(timestamp, milestoneTitle)
                        }];
                    var chartLineSelection = this.chartGroup.selectAll(Selectors.ChartLine.selector).data(line);
                    chartLineSelection.enter().append("line").classed(Selectors.ChartLine.class, true);
                    chartLineSelection.attr({
                        x1: function (line) { return line.x1; },
                        y1: function (line) { return line.y1; },
                        x2: function (line) { return line.x2; },
                        y2: function (line) { return line.y2; },
                        tooltipInfo: function (line) { return line.tooltipInfo; }
                    });
                    visuals.TooltipManager.addTooltip(chartLineSelection, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    chartLineSelection.exit().remove();
                };
                Gantt.prototype.updateElementsPositions = function (viewport, margin) {
                    var viewModel = this.viewModel;
                    this.axisGroup.attr("transform", visuals.SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, 15));
                    this.chartGroup.attr("transform", visuals.SVGUtil.translate(viewModel.taskLabelsWidth + margin.left, margin.top));
                    this.lineGroup.attr("transform", visuals.SVGUtil.translate(0, margin.top));
                };
                /**
                 * Returns the width of the now line based on num of tasks
                 * @param numOfTasks Number of tasks
                 */
                Gantt.prototype.getMilestoneLineLength = function (numOfTasks) {
                    return numOfTasks * ChartLineHeight;
                };
                Gantt.prototype.getTaskLabelFontSize = function () {
                    return powerbi.DataViewObjects.getValue(this.dataView.metadata.objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize);
                };
                /**
                 * handle "Legend" card
                 * @param enumeration The instance to be pushed into "Legend" card
                 * @param objects Dataview objects
                 */
                Gantt.prototype.enumerateLegendOptions = function (enumeration, objects) {
                    enumeration.pushInstance({
                        displayName: samples.GanttChartProps.legend.show.objectName,
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.show, true),
                            position: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.position, true),
                            showTitle: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.showTitle, true),
                            titleText: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.titleText, ""),
                            labelColor: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.legend.labelColor, Gantt.DefaultValues.LegendLabelColor),
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.legend.fontSize, Gantt.DefaultValues.LegendFontSize)
                        },
                        objectName: samples.GanttChartProps.legend.show.objectName
                    });
                };
                /**
                * handle "Data Colors" card
                * @param enumeration The instance to be pushed into "Data Colors" card
                * @param objects Dataview objects
                */
                Gantt.prototype.enumerateDataPoints = function (enumeration, objects) {
                    var taskSeries = this.data.series;
                    taskSeries.forEach(function (item) {
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: item.name,
                            selector: visuals.ColorHelper.normalizeSelector(item.identity.getSelector(), false),
                            properties: {
                                fill: { solid: { color: item.fill } }
                            }
                        });
                    });
                };
                /**
                * handle "Task Completion" card
                * @param enumeration The instance to be pushed into "Task Completion" card
                * @param objects Dataview objects
                */
                Gantt.prototype.enumerateTaskCompletion = function (enumeration, objects) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskCompletion.fill, Gantt.DefaultValues.ProgressColor)
                        },
                        objectName: samples.GanttChartProps.taskCompletion.fill.objectName
                    });
                };
                /**
                * handle "Labels" card
                * @param enumeration The instance to be pushed into "Data Labels" card
                * @param objects Dataview objects
                */
                Gantt.prototype.enumerateTaskLabels = function (enumeration, objects) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.show, true),
                            fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskLabels.fill, Gantt.DefaultValues.TaskLabelColor),
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.fontSize, Gantt.DefaultValues.LabelFontSize),
                            width: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskLabels.width, Gantt.DefaultValues.TaskLabelWidth),
                        },
                        objectName: samples.GanttChartProps.taskLabels.show.objectName
                    });
                };
                /**
                * handle "Data Labels" card
                * @param enumeration The instance to be pushed into "Task Resource" card
                * @param objects Dataview objects
                */
                Gantt.prototype.enumerateDataLabels = function (enumeration, objects) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskResource.show, true),
                            fill: powerbi.DataViewObjects.getFillColor(objects, samples.GanttChartProps.taskResource.fill, Gantt.DefaultValues.TaskResourceColor),
                            fontSize: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.taskResource.fontSize, Gantt.DefaultValues.ResourceFontSize)
                        },
                        objectName: samples.GanttChartProps.taskResource.show.objectName
                    });
                };
                Gantt.prototype.enumerateDateType = function (enumeration, objects) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            type: powerbi.DataViewObjects.getValue(objects, samples.GanttChartProps.ganttDateType.type, samples.DefaultDateType),
                        },
                        objectName: samples.GanttChartProps.ganttDateType.type.objectName
                    });
                };
                /**
                * handle the property pane options
                * @param objects Dataview enumerate objects
                */
                Gantt.prototype.enumerateObjectInstances = function (options) {
                    var dataView = this.dataView;
                    if (!dataView)
                        return;
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                        case 'legend':
                            this.enumerateLegendOptions(enumeration, dataView.metadata.objects);
                            break;
                        case 'dataPoint':
                            this.enumerateDataPoints(enumeration, dataView.metadata.objects);
                            break;
                        case 'taskLabels':
                            this.enumerateTaskLabels(enumeration, dataView.metadata.objects);
                            break;
                        case 'taskCompletion':
                            this.enumerateTaskCompletion(enumeration, dataView.metadata.objects);
                            break;
                        case 'taskResource':
                            this.enumerateDataLabels(enumeration, dataView.metadata.objects);
                            break;
                        case 'ganttDateType':
                            this.enumerateDateType(enumeration, dataView.metadata.objects);
                            break;
                    }
                    return enumeration.complete();
                };
                Gantt.DefaultValues = {
                    AxisTickSize: 6,
                    LabelFontSize: 9,
                    LegendFontSize: 8,
                    LegendLabelColor: "#000000",
                    MaxTaskOpacity: 1,
                    MinTaskOpacity: 0.4,
                    ProgressBarHeight: 4,
                    ProgressColor: "#000000",
                    ResourceFontSize: 9,
                    ResourceWidth: 100,
                    TaskColor: "#00B099",
                    TaskLabelColor: "#000000",
                    TaskLabelWidth: 110,
                    TaskLineWidth: 15,
                    TaskResourceColor: "#000000",
                    ganttFormatString: "MMM dd"
                };
                Gantt.capabilities = {
                    dataRoles: [
                        {
                            name: "Legend",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Legend",
                        }, {
                            name: "Task",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Task"
                        }, {
                            name: "StartDate",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Start Date",
                        }, {
                            name: "Duration",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "Duration",
                            requiredTypes: [{ numeric: true }, { integer: true }]
                        }, {
                            name: "Completion",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: "% Completion",
                            requiredTypes: [{ numeric: true }, { integer: true }]
                        }, {
                            name: "Resource",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: "Resource"
                        }
                    ],
                    dataViewMappings: [{
                            conditions: [
                                {
                                    "Legend": { min: 0, max: 1 },
                                    "Task": { min: 1, max: 1 },
                                    "StartDate": { min: 0, max: 0 },
                                    "Duration": { min: 0, max: 0 },
                                    "Completion": { min: 0, max: 0 },
                                    "Resource": { min: 0, max: 0 }
                                }, {
                                    "Legend": { min: 0, max: 1 },
                                    "Task": { min: 1, max: 1 },
                                    "StartDate": { min: 0, max: 1 },
                                    "Duration": { min: 0, max: 0 },
                                    "Completion": { min: 0, max: 0 },
                                    "Resource": { min: 0, max: 0 }
                                }, {
                                    "Legend": { min: 0, max: 1 },
                                    "Task": { min: 0, max: 1 },
                                    "StartDate": { min: 0, max: 1 },
                                    "Duration": { min: 0, max: 1 },
                                    "Completion": { min: 0, max: 1 },
                                    "Resource": { min: 0, max: 1 },
                                }
                            ],
                            table: {
                                rows: {
                                    select: [
                                        { for: { in: "Legend" } },
                                        { for: { in: "Task" } },
                                        { for: { in: "StartDate" } },
                                        { for: { in: "Duration" } },
                                        { for: { in: "Completion" } },
                                        { for: { in: "Resource" } },
                                    ]
                                },
                            },
                        }],
                    sorting: {
                        default: {},
                    },
                    objects: {
                        legend: {
                            displayName: "Legend",
                            description: "Display legend options",
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: "Position",
                                    description: "Select the location for the legend",
                                    type: { enumeration: visuals.legendPosition.type }
                                },
                                showTitle: {
                                    displayName: "Title",
                                    description: "Display a title for legend symbols",
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: "Legend Name",
                                    description: "Title text",
                                    type: { text: true },
                                    suppressFormatPainterCopy: true
                                },
                                labelColor: {
                                    displayName: "Color",
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: "Text Size",
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        //dataPoint: {
                        //    displayName: "Data colors",
                        //    properties: {
                        //        fill: {
                        //            displayName: "Fill",
                        //            type: { fill: { solid: { color: true } } }
                        //        }
                        //    }
                        //},
                        taskLabels: {
                            displayName: 'Category Labels',
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: 'Fill',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Font Size',
                                    type: { formatting: { fontSize: true } }
                                },
                                width: {
                                    displayName: 'Width',
                                    type: { numeric: true }
                                }
                            }
                        },
                        taskCompletion: {
                            displayName: 'Task Completion',
                            properties: {
                                show: {
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: 'Completion Color',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        taskResource: {
                            displayName: 'Data Labels',
                            properties: {
                                show: {
                                    displayName: "Show",
                                    type: { bool: true }
                                },
                                fill: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Font Size',
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        },
                        ganttDateType: {
                            displayName: 'Gantt Date Type',
                            properties: {
                                type: {
                                    displayName: "Type",
                                    type: { enumeration: dateTypeSelector.type }
                                },
                            }
                        },
                    }
                };
                return Gantt;
            }());
            samples.Gantt = Gantt;
            var GanttChartBehavior = (function () {
                function GanttChartBehavior() {
                }
                GanttChartBehavior.prototype.bindEvents = function (options, selectionHandler) {
                    this.options = options;
                    var clearCatcher = options.clearCatcher;
                    options.taskSelection.on('click', function (d) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                        d3.event.stopPropagation();
                    });
                    clearCatcher.on('click', function () {
                        selectionHandler.handleClearSelection();
                    });
                };
                GanttChartBehavior.prototype.renderSelection = function (hasSelection) {
                    var options = this.options;
                    var ganttMaxOpacity = Gantt.getMaxTaskOpacity();
                    var ganttMinOpacity = Gantt.getMinTaskOpacity();
                    options.taskSelection.style("opacity", function (d) {
                        return (hasSelection && !d.selected) ? ganttMinOpacity : ganttMaxOpacity;
                    });
                };
                return GanttChartBehavior;
            }());
            samples.GanttChartBehavior = GanttChartBehavior;
            var GanttChartWarning = (function () {
                function GanttChartWarning() {
                }
                Object.defineProperty(GanttChartWarning.prototype, "code", {
                    get: function () {
                        return "GanttChartWarning";
                    },
                    enumerable: true,
                    configurable: true
                });
                GanttChartWarning.prototype.getMessages = function (resourceProvider) {
                    var message = "This visual requires task value", titleKey = "", detailKey = "", visualMessage;
                    visualMessage = {
                        message: message,
                        title: resourceProvider.get(titleKey),
                        detail: resourceProvider.get(detailKey)
                    };
                    return visualMessage;
                };
                return GanttChartWarning;
            }());
            samples.GanttChartWarning = GanttChartWarning;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            var SelectionManager = visuals.utility.SelectionManager;
            var px = jsCommon.PixelConverter.toString;
            var pt = jsCommon.PixelConverter.fromPoint;
            var fromPointToPixel = jsCommon.PixelConverter.fromPointToPixel;
            samples.Months = powerbi.createEnumType([
                { value: 1, displayName: 'January' },
                { value: 2, displayName: 'February' },
                { value: 3, displayName: 'March' },
                { value: 4, displayName: 'April' },
                { value: 5, displayName: 'May' },
                { value: 6, displayName: 'June' },
                { value: 7, displayName: 'July' },
                { value: 8, displayName: 'August' },
                { value: 9, displayName: 'September' },
                { value: 10, displayName: 'October' },
                { value: 11, displayName: 'November' },
                { value: 12, displayName: 'December' }
            ]);
            samples.WeekDays = powerbi.createEnumType([
                { value: 0, displayName: 'Sunday' },
                { value: 1, displayName: 'Monday' },
                { value: 2, displayName: 'Tuesday' },
                { value: 3, displayName: 'Wednesday' },
                { value: 4, displayName: 'Thursday' },
                { value: 5, displayName: 'Friday' },
                { value: 6, displayName: 'Saturday' }
            ]);
            (function (GranularityType) {
                GranularityType[GranularityType["year"] = 0] = "year";
                GranularityType[GranularityType["quarter"] = 1] = "quarter";
                GranularityType[GranularityType["month"] = 2] = "month";
                GranularityType[GranularityType["week"] = 3] = "week";
                GranularityType[GranularityType["day"] = 4] = "day";
            })(samples.GranularityType || (samples.GranularityType = {}));
            var GranularityType = samples.GranularityType;
            var SelectedCellColorProp = { objectName: 'cells', propertyName: 'fillSelected' };
            var UnselectedCellColorProp = { objectName: 'cells', propertyName: 'fillUnselected' };
            var TimeRangeColorProp = { objectName: 'rangeHeader', propertyName: 'fontColor' };
            var TimeRangeSizeProp = { objectName: 'rangeHeader', propertyName: 'textSize' };
            var TimeRangeShowProp = { objectName: 'rangeHeader', propertyName: 'show' };
            var LabelsColorProp = { objectName: 'labels', propertyName: 'fontColor' };
            var LabelsSizeProp = { objectName: 'labels', propertyName: 'textSize' };
            var LabelsShowProp = { objectName: 'labels', propertyName: 'show' };
            var CalendarMonthProp = { objectName: 'calendar', propertyName: 'month' };
            var CalendarDayProp = { objectName: 'calendar', propertyName: 'day' };
            var WeekDayProp = { objectName: 'weekDay', propertyName: 'day' };
            var GranularityNames = [
                {
                    granularityType: GranularityType.year,
                    name: "year"
                }, {
                    granularityType: GranularityType.quarter,
                    name: "quarter"
                }, {
                    granularityType: GranularityType.month,
                    name: "month"
                }, {
                    granularityType: GranularityType.week,
                    name: "week"
                }, {
                    granularityType: GranularityType.day,
                    name: "day"
                }];
            var TimelineGranularity = (function () {
                function TimelineGranularity() {
                    this.datePeriods = [];
                }
                /**
                * Returns the short month name of the given date (e.g. Jan, Feb, Mar)
                */
                TimelineGranularity.prototype.shortMonthName = function (date) {
                    return date.toString().split(' ')[1];
                };
                TimelineGranularity.prototype.resetDatePeriods = function () {
                    this.datePeriods = [];
                };
                TimelineGranularity.prototype.getDatePeriods = function () {
                    return this.datePeriods;
                };
                TimelineGranularity.prototype.getExtendedLabel = function () {
                    return this.extendedLabel;
                };
                TimelineGranularity.prototype.setExtendedLabel = function (extendedLabel) {
                    this.extendedLabel = extendedLabel;
                };
                TimelineGranularity.prototype.createLabels = function (granularity) {
                    var labels = [];
                    var lastDatePeriod;
                    _.map(this.datePeriods, function (x) {
                        if (_.isEmpty(labels) || !granularity.sameLabel(x, lastDatePeriod)) {
                            lastDatePeriod = x;
                            labels.push(granularity.generateLabel(x));
                        }
                    });
                    return labels;
                };
                /**
                * Adds the new date into the given datePeriods array
                * If the date corresponds to the last date period, given the current granularity,
                * it will be added to that date period. Otherwise, a new date period will be added to the array.
                * i.e. using Month granularity, Feb 2 2015 corresponds to Feb 3 2015.
                * It is assumed that the given date does not correspond to previous date periods, other than the last date period
                */
                TimelineGranularity.prototype.addDate = function (date, identifierArray) {
                    var datePeriods = this.getDatePeriods();
                    var lastDatePeriod = datePeriods[datePeriods.length - 1];
                    if (datePeriods.length === 0 || !_.isEqual(lastDatePeriod.identifierArray, identifierArray)) {
                        if (datePeriods.length > 0)
                            lastDatePeriod.endDate = date;
                        datePeriods.push({
                            identifierArray: identifierArray,
                            startDate: date,
                            endDate: date,
                            week: this.determineWeek(date),
                            year: this.determineYear(date),
                            fraction: 1,
                            index: datePeriods.length
                        });
                    }
                    else
                        lastDatePeriod.endDate = date;
                };
                TimelineGranularity.prototype.setNewEndDate = function (date) {
                    _.last(this.datePeriods).endDate = date;
                };
                /**
                 * Splits a given period into two periods.
                 * The new period is added after the index of the old one, while the old one is simply updated.
                 * @param index The index of the date priod to be split
                 * @param newFraction The fraction value of the new date period
                 * @param newDate The date in which the date period is split
                 */
                TimelineGranularity.prototype.splitPeriod = function (index, newFraction, newDate) {
                    var oldDatePeriod = this.datePeriods[index];
                    oldDatePeriod.fraction -= newFraction;
                    var newDateObject = {
                        identifierArray: oldDatePeriod.identifierArray,
                        startDate: newDate,
                        endDate: oldDatePeriod.endDate,
                        week: this.determineWeek(newDate),
                        year: this.determineYear(newDate),
                        fraction: newFraction,
                        index: oldDatePeriod.index + oldDatePeriod.fraction
                    };
                    oldDatePeriod.endDate = newDate;
                    this.datePeriods.splice(index + 1, 0, newDateObject);
                };
                TimelineGranularity.prototype.previousMonth = function (month) {
                    return (month > 0) ? month - 1 : 11;
                };
                TimelineGranularity.prototype.nextMonth = function (month) {
                    return (month < 11) ? month + 1 : 0;
                };
                TimelineGranularity.prototype.countWeeks = function (startDate, endDate) {
                    var totalDays;
                    if (endDate.getFullYear() === startDate.getFullYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() >= startDate.getDate())
                        totalDays = endDate.getDate() - startDate.getDate();
                    else {
                        totalDays = endDate.getDate() - 1;
                        var lastMonth = this.nextMonth(startDate.getMonth());
                        var month = endDate.getMonth();
                        while (month !== lastMonth) {
                            totalDays += new Date(endDate.getFullYear(), month, 0).getDate();
                            month = this.previousMonth(month);
                        }
                        totalDays += new Date(endDate.getFullYear(), lastMonth, 0).getDate() - startDate.getDate();
                    }
                    return 1 + Math.floor(totalDays / 7);
                };
                TimelineGranularity.prototype.determineWeek = function (date) {
                    var year = date.getFullYear();
                    if (this.inPreviousYear(date))
                        year--;
                    var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(year);
                    var weeks = this.countWeeks(dateOfFirstWeek, date);
                    return [weeks, year];
                };
                TimelineGranularity.prototype.inPreviousYear = function (date) {
                    var dateOfFirstWeek = Timeline.calendar.getDateOfFirstWeek(date.getFullYear());
                    return date < dateOfFirstWeek;
                };
                TimelineGranularity.prototype.determineYear = function (date) {
                    var firstDay = new Date(date.getFullYear(), Timeline.calendar.getFirstMonthOfYear(), Timeline.calendar.getFirstDayOfYear());
                    return date.getFullYear() - ((firstDay <= date) ? 0 : 1);
                };
                return TimelineGranularity;
            }());
            samples.TimelineGranularity = TimelineGranularity;
            var DayGranularity = (function (_super) {
                __extends(DayGranularity, _super);
                function DayGranularity() {
                    _super.apply(this, arguments);
                }
                DayGranularity.prototype.getType = function () {
                    return GranularityType.day;
                };
                DayGranularity.prototype.splitDate = function (date) {
                    return [this.shortMonthName(date), date.getDate(), date.getFullYear()];
                };
                DayGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
                    return firstDatePeriod.startDate.getTime() === secondDatePeriod.startDate.getTime();
                };
                DayGranularity.prototype.generateLabel = function (datePeriod) {
                    return {
                        title: this.shortMonthName(datePeriod.startDate) + ' ' + datePeriod.startDate.getDate() + ' - ' + datePeriod.year,
                        text: datePeriod.startDate.getDate().toString(),
                        id: datePeriod.index
                    };
                };
                return DayGranularity;
            }(TimelineGranularity));
            samples.DayGranularity = DayGranularity;
            var MonthGranularity = (function (_super) {
                __extends(MonthGranularity, _super);
                function MonthGranularity() {
                    _super.apply(this, arguments);
                }
                MonthGranularity.prototype.getType = function () {
                    return GranularityType.month;
                };
                MonthGranularity.prototype.splitDate = function (date) {
                    return [this.shortMonthName(date), date.getFullYear()];
                };
                MonthGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
                    return this.shortMonthName(firstDatePeriod.startDate) === this.shortMonthName(secondDatePeriod.startDate);
                };
                MonthGranularity.prototype.generateLabel = function (datePeriod) {
                    var shortMonthName = this.shortMonthName(datePeriod.startDate);
                    return {
                        title: shortMonthName,
                        text: shortMonthName,
                        id: datePeriod.index
                    };
                };
                return MonthGranularity;
            }(TimelineGranularity));
            samples.MonthGranularity = MonthGranularity;
            var WeekGranularity = (function (_super) {
                __extends(WeekGranularity, _super);
                function WeekGranularity() {
                    _super.apply(this, arguments);
                }
                WeekGranularity.prototype.getType = function () {
                    return GranularityType.week;
                };
                WeekGranularity.prototype.splitDate = function (date) {
                    return this.determineWeek(date);
                };
                WeekGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
                    return _.isEqual(firstDatePeriod.week, secondDatePeriod.week);
                };
                WeekGranularity.prototype.generateLabel = function (datePeriod) {
                    return {
                        title: 'Week ' + datePeriod.week[0] + ' - ' + datePeriod.week[1],
                        text: 'W' + datePeriod.week[0],
                        id: datePeriod.index
                    };
                };
                return WeekGranularity;
            }(TimelineGranularity));
            samples.WeekGranularity = WeekGranularity;
            var QuarterGranularity = (function (_super) {
                __extends(QuarterGranularity, _super);
                function QuarterGranularity() {
                    _super.apply(this, arguments);
                }
                /**
                 * Returns the date's quarter name (e.g. Q1, Q2, Q3, Q4)
                 * @param date A date
                 */
                QuarterGranularity.prototype.quarterText = function (date) {
                    var quarter = 3;
                    var year = date.getFullYear();
                    while (date < Timeline.calendar.getQuarterStartDate(year, quarter))
                        if (quarter > 0)
                            quarter--;
                        else {
                            quarter = 3;
                            year--;
                        }
                    quarter++;
                    return 'Q' + quarter;
                };
                QuarterGranularity.prototype.getType = function () {
                    return GranularityType.quarter;
                };
                QuarterGranularity.prototype.splitDate = function (date) {
                    return [this.quarterText(date), date.getFullYear()];
                };
                QuarterGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
                    return this.quarterText(firstDatePeriod.startDate) === this.quarterText(secondDatePeriod.startDate)
                        && firstDatePeriod.year === secondDatePeriod.year;
                };
                QuarterGranularity.prototype.generateLabel = function (datePeriod) {
                    var quarter = this.quarterText(datePeriod.startDate);
                    return {
                        title: quarter + ' ' + datePeriod.year,
                        text: quarter,
                        id: datePeriod.index
                    };
                };
                return QuarterGranularity;
            }(TimelineGranularity));
            samples.QuarterGranularity = QuarterGranularity;
            var YearGranularity = (function (_super) {
                __extends(YearGranularity, _super);
                function YearGranularity() {
                    _super.apply(this, arguments);
                }
                YearGranularity.prototype.getType = function () {
                    return GranularityType.year;
                };
                YearGranularity.prototype.splitDate = function (date) {
                    return [date.getFullYear()];
                };
                YearGranularity.prototype.sameLabel = function (firstDatePeriod, secondDatePeriod) {
                    return firstDatePeriod.year === secondDatePeriod.year;
                };
                YearGranularity.prototype.generateLabel = function (datePeriod) {
                    return {
                        title: 'Year ' + datePeriod.year,
                        text: datePeriod.year.toString(),
                        id: datePeriod.index
                    };
                };
                return YearGranularity;
            }(TimelineGranularity));
            samples.YearGranularity = YearGranularity;
            var TimelineGranularityData = (function () {
                function TimelineGranularityData(startDate, endDate) {
                    this.granularities = [];
                    this.setDatesRange(startDate, endDate);
                    var lastDate = this.dates[this.dates.length - 1];
                    this.endingDate = TimelineGranularityData.nextDay(lastDate);
                }
                /**
                 * Returns the date of the previos day
                 * @param date The following date
                 */
                TimelineGranularityData.previousDay = function (date) {
                    var prevDay = new Date(date.getTime());
                    prevDay.setDate(prevDay.getDate() - 1);
                    return prevDay;
                };
                /**
                 * Returns the date of the next day
                 * @param date The previous date
                 */
                TimelineGranularityData.nextDay = function (date) {
                    var nextDay = new Date(date.getTime());
                    nextDay.setDate(nextDay.getDate() + 1);
                    return nextDay;
                };
                /**
                * Returns an array of dates with all the days between the start date and the end date
                */
                TimelineGranularityData.prototype.setDatesRange = function (startDate, endDate) {
                    this.dates = [];
                    var date = startDate;
                    while (date <= endDate) {
                        this.dates.push(date);
                        date = TimelineGranularityData.nextDay(date);
                    }
                };
                /**
                 * Adds a new granularity to the array of granularities.
                 * Resets the new granularity, adds all dates to it, and then edits the last date period with the ending date.
                 * @param granularity The new granularity to be added
                 */
                TimelineGranularityData.prototype.addGranularity = function (granularity) {
                    granularity.resetDatePeriods();
                    for (var _i = 0, _a = this.dates; _i < _a.length; _i++) {
                        var date = _a[_i];
                        var identifierArray = granularity.splitDate(date);
                        granularity.addDate(date, identifierArray);
                    }
                    granularity.setNewEndDate(this.endingDate);
                    this.granularities.push(granularity);
                };
                /**
                 * Returns a specific granularity from the array of granularities
                 * @param index The index of the requested granularity
                 */
                TimelineGranularityData.prototype.getGranularity = function (index) {
                    return this.granularities[index];
                };
                TimelineGranularityData.prototype.createGranularities = function () {
                    this.granularities = [];
                    this.addGranularity(new YearGranularity());
                    this.addGranularity(new QuarterGranularity());
                    this.addGranularity(new MonthGranularity());
                    this.addGranularity(new WeekGranularity());
                    this.addGranularity(new DayGranularity());
                };
                TimelineGranularityData.prototype.createLabels = function () {
                    var _this = this;
                    this.granularities.forEach(function (x) {
                        x.setExtendedLabel({
                            dayLabels: x.getType() >= GranularityType.day ? x.createLabels(_this.granularities[GranularityType.day]) : [],
                            weekLabels: x.getType() >= GranularityType.week ? x.createLabels(_this.granularities[GranularityType.week]) : [],
                            monthLabels: x.getType() >= GranularityType.month ? x.createLabels(_this.granularities[GranularityType.month]) : [],
                            quarterLabels: x.getType() >= GranularityType.quarter ? x.createLabels(_this.granularities[GranularityType.quarter]) : [],
                            yearLabels: x.getType() >= GranularityType.year ? x.createLabels(_this.granularities[GranularityType.year]) : [],
                        });
                    });
                };
                return TimelineGranularityData;
            }());
            samples.TimelineGranularityData = TimelineGranularityData;
            var Utils = (function () {
                function Utils() {
                }
                /**
                 * Returns the date of the start of the selection
                 * @param timelineData The TimelineData which contains all the date periods
                 */
                Utils.getStartSelectionDate = function (timelineData) {
                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionStartIndex].startDate;
                };
                /**
                 * Returns the date of the end of the selection
                 * @param timelineData The TimelineData which contains all the date periods
                 */
                Utils.getEndSelectionDate = function (timelineData) {
                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex].endDate;
                };
                /**
                 * Returns the date period of the end of the selection
                 * @param timelineData The TimelineData which contains all the date periods
                 */
                Utils.getEndSelectionPeriod = function (timelineData) {
                    return timelineData.currentGranularity.getDatePeriods()[timelineData.selectionEndIndex];
                };
                /**
                 * Returns the color of a cell, depending on whether its date period is between the selected date periods
                 * @param d The TimelineDataPoint of the cell
                 * @param timelineData The TimelineData with the selected date periods
                 * @param timelineFormat The TimelineFormat with the chosen colors
                 */
                Utils.getCellColor = function (d, timelineData, cellFormat) {
                    var inSelectedPeriods = d.datePeriod.startDate >= Utils.getStartSelectionDate(timelineData) && d.datePeriod.endDate <= Utils.getEndSelectionDate(timelineData);
                    return inSelectedPeriods ? cellFormat.colorInProperty : cellFormat.colorOutProperty;
                };
                /**
                 * Returns the granularity type of the given granularity name
                 * @param granularityName The name of the granularity
                 */
                Utils.getGranularityType = function (granularityName) {
                    var index = _.findIndex(GranularityNames, function (x) { return x.name === granularityName; });
                    return GranularityNames[index].granularityType;
                };
                /**
                 * Returns the name of the granularity type
                 * @param granularity The type of granularity
                 */
                Utils.getGranularityName = function (granularity) {
                    var index = _.findIndex(GranularityNames, function (x) { return x.granularityType === granularity; });
                    return GranularityNames[index].name;
                };
                /**
                 * Splits the date periods of the current granularity, in case the stard and end of the selection is in between a date period.
                 * i.e. for a quarter granularity and a selection between Feb 6 and Dec 23, the date periods for Q1 and Q4 will be split accordingly
                 * @param timelineData The TimelineData that contains the date periods
                 * @param startDate The starting date of the selection
                 * @param endDate The ending date of the selection
                 */
                Utils.separateSelection = function (timelineData, startDate, endDate) {
                    var datePeriods = timelineData.currentGranularity.getDatePeriods();
                    var startDateIndex = _.findIndex(datePeriods, function (x) { return startDate < x.endDate; });
                    var endDateIndex = _.findIndex(datePeriods, function (x) { return endDate <= x.endDate; });
                    timelineData.selectionStartIndex = startDateIndex;
                    timelineData.selectionEndIndex = endDateIndex;
                    var startRatio = Utils.getDateRatio(datePeriods[startDateIndex], startDate, true);
                    var endRatio = Utils.getDateRatio(datePeriods[endDateIndex], endDate, false);
                    if (endRatio > 0)
                        timelineData.currentGranularity.splitPeriod(endDateIndex, endRatio, endDate);
                    if (startRatio > 0) {
                        var startFration = datePeriods[startDateIndex].fraction - startRatio;
                        timelineData.currentGranularity.splitPeriod(startDateIndex, startFration, startDate);
                        timelineData.selectionStartIndex++;
                        timelineData.selectionEndIndex++;
                    }
                };
                /**
                 * Returns the ratio of the given date compared to the whole date period.
                 * The ratio is calculated either from the start or the end of the date period.
                 * i.e. the ratio of Feb 7 2016 compared to the month of Feb 2016,
                 * is 0.2142 from the start of the month, or 0.7857 from the end of the month.
                 * @param datePeriod The date period that contain the specified date
                 * @param date The date
                 * @param fromStart Whether to calculater the ratio from the start of the date period.
                 */
                Utils.getDateRatio = function (datePeriod, date, fromStart) {
                    var dateDifference = fromStart ? date.getTime() - datePeriod.startDate.getTime() : datePeriod.endDate.getTime() - date.getTime();
                    var periodDifference = datePeriod.endDate.getTime() - datePeriod.startDate.getTime();
                    return periodDifference === 0 ? 0 : dateDifference / periodDifference;
                };
                /**
                * Returns the time range text, depending on the given granularity (e.g. "Feb 3 2014 - Apr 5 2015", "Q1 2014 - Q2 2015")
                */
                Utils.timeRangeText = function (timelineData) {
                    var startSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getStartSelectionDate(timelineData));
                    var endSelectionDateArray = timelineData.currentGranularity.splitDate(Utils.getEndSelectionPeriod(timelineData).startDate);
                    return startSelectionDateArray.join(' ') + ' - ' + endSelectionDateArray.join(' ');
                };
                Utils.dateRangeText = function (datePeriod) {
                    return datePeriod.startDate.toDateString() + ' - ' + TimelineGranularityData.previousDay(datePeriod.endDate).toDateString();
                };
                /**
                 * Combines the first two partial date periods, into a single date period.
                 * Returns whether a partial date period was found.
                 * i.e. combines "Feb 1 2016 - Feb 5 2016" with "Feb 5 2016 - Feb 29 2016" into "Feb 1 2016 - Feb 29 2016"
                 * @param datePeriods The list of date periods
                 */
                Utils.unseparateSelection = function (datePeriods) {
                    var separationIndex = _.findIndex(datePeriods, function (x) { return x.fraction < 1; });
                    if (separationIndex >= 0) {
                        datePeriods[separationIndex].endDate = datePeriods[separationIndex + 1].endDate;
                        datePeriods[separationIndex].fraction += datePeriods[separationIndex + 1].fraction;
                        datePeriods.splice(separationIndex + 1, 1);
                        return true;
                    }
                    return false;
                };
                return Utils;
            }());
            samples.Utils = Utils;
            var Calendar = (function () {
                function Calendar(calendarFormat) {
                    var _this = this;
                    this.firstDayOfWeek = calendarFormat.weekDayProperty;
                    this.firstMonthOfYear = calendarFormat.firstMonthProperty - 1;
                    this.firstDayOfYear = calendarFormat.firstDayProperty;
                    this.dateOfFirstWeek = {};
                    this.quarterFirstMonths = [0, 3, 6, 9].map(function (x) { return x + _this.firstMonthOfYear; });
                }
                Calendar.prototype.getFirstDayOfWeek = function () {
                    return this.firstDayOfWeek;
                };
                Calendar.prototype.getFirstMonthOfYear = function () {
                    return this.firstMonthOfYear;
                };
                Calendar.prototype.getFirstDayOfYear = function () {
                    return this.firstDayOfYear;
                };
                Calendar.prototype.getQuarterStartDate = function (year, quarterIndex) {
                    return new Date(year, this.quarterFirstMonths[quarterIndex], this.firstDayOfYear);
                };
                Calendar.prototype.isChanged = function (calendarFormat) {
                    return this.firstMonthOfYear !== (calendarFormat.firstMonthProperty - 1)
                        || this.firstDayOfYear !== calendarFormat.firstDayProperty
                        || this.firstDayOfWeek !== calendarFormat.weekDayProperty;
                };
                Calendar.prototype.calculateDateOfFirstWeek = function (year) {
                    var date = new Date(year, this.firstMonthOfYear, this.firstDayOfYear);
                    while (date.getDay() !== this.firstDayOfWeek)
                        date = TimelineGranularityData.nextDay(date);
                    return date;
                };
                Calendar.prototype.getDateOfFirstWeek = function (year) {
                    if (!this.dateOfFirstWeek[year])
                        this.dateOfFirstWeek[year] = this.calculateDateOfFirstWeek(year);
                    return this.dateOfFirstWeek[year];
                };
                return Calendar;
            }());
            samples.Calendar = Calendar;
            var Timeline = (function () {
                function Timeline() {
                    var _this = this;
                    this.requiresNoUpdate = false;
                    this.foreignSelection = false;
                    this.selector = ['Y', 'Q', 'M', 'W', 'D'];
                    this.timelineMargins = {
                        LeftMargin: 15,
                        RightMargin: 15,
                        TopMargin: 15,
                        BottomMargin: 10,
                        CellWidth: 40,
                        CellHeight: 25,
                        StartXpoint: 10,
                        StartYpoint: 20,
                        ElementWidth: 30,
                        MinCellWidth: 30,
                        MaxCellHeight: 60,
                        PeriodSlicerRectWidth: 15,
                        PeriodSlicerRectHeight: 23
                    };
                    this.defaultTimelineProperties = {
                        DefaultLabelsShow: true,
                        TimelineDefaultTextSize: 9,
                        TimelineDefaultCellColor: "#ADD8E6",
                        TimelineDefaultCellColorOut: "#FFFFFF",
                        TimelineDefaultTimeRangeShow: true,
                        DefaultTimeRangeColor: "#777777",
                        DefaultLabelColor: "#777777",
                        DefaultGranularity: GranularityType.month,
                        DefaultFirstMonth: 1,
                        DefaultFirstDay: 1,
                        DefaultFirstWeekDay: 0
                    };
                    this.timelineSelectors = {
                        TimelineVisual: createClassAndSelector('Timeline'),
                        SelectionRangeContainer: createClassAndSelector('selectionRangeContainer'),
                        textLabel: createClassAndSelector('label'),
                        LowerTextCell: createClassAndSelector('lowerTextCell'),
                        UpperTextCell: createClassAndSelector('upperTextCell'),
                        UpperTextArea: createClassAndSelector('upperTextArea'),
                        LowerTextArea: createClassAndSelector('lowerTextArea'),
                        RangeTextArea: createClassAndSelector('rangeTextArea'),
                        CellsArea: createClassAndSelector('cellsArea'),
                        CursorsArea: createClassAndSelector('cursorsArea'),
                        MainArea: createClassAndSelector('mainArea'),
                        SelectionCursor: createClassAndSelector('selectionCursor'),
                        Cell: createClassAndSelector('cell'),
                        CellRect: createClassAndSelector('cellRect'),
                        VertLine: createClassAndSelector('timelineVertLine'),
                        TimelineSlicer: createClassAndSelector('timelineSlicer'),
                        PeriodSlicerGranularities: createClassAndSelector('periodSlicerGranularities'),
                        PeriodSlicerSelection: createClassAndSelector('periodSlicerSelection'),
                        PeriodSlicerSelectionRect: createClassAndSelector('periodSlicerSelectionRect'),
                        PeriodSlicerRect: createClassAndSelector('periodSlicerRect')
                    };
                    this.drag = d3.behavior.drag()
                        .origin(function (d) {
                        d.x = d.selectionIndex * _this.timelineProperties.cellWidth;
                        return d;
                    })
                        .on("dragstart", function () { _this.dragstarted(); })
                        .on("drag", function (d) { _this.dragged(d); })
                        .on("dragend", function () { _this.dragended(); });
                }
                /**
                 * Changes the current granularity depending on the given granularity type
                 * Separates the new granularity's date periods which contain the start/end selection
                 * Unseparates the date periods of the previous granularity.
                 * @param granularity The new granularity type
                 */
                Timeline.prototype.changeGranularity = function (granularity, startDate, endDate) {
                    if (Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods()))
                        Utils.unseparateSelection(this.timelineData.currentGranularity.getDatePeriods());
                    this.timelineData.currentGranularity = this.timelineGranularityData.getGranularity(granularity);
                    Utils.separateSelection(this.timelineData, startDate, endDate);
                };
                Timeline.prototype.init = function (options) {
                    this.hostServices = options.host;
                    this.initialized = false;
                    var element = options.element;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    this.timelineProperties = {
                        element: element,
                        textYPosition: 50,
                        cellsYPosition: this.timelineMargins.TopMargin * 3 + 65,
                        topMargin: this.timelineMargins.TopMargin,
                        bottomMargin: this.timelineMargins.BottomMargin,
                        leftMargin: this.timelineMargins.LeftMargin,
                        startXpoint: this.timelineMargins.StartXpoint,
                        startYpoint: this.timelineMargins.StartYpoint,
                        cellWidth: this.timelineMargins.CellWidth,
                        cellHeight: this.timelineMargins.CellHeight,
                        elementWidth: this.timelineMargins.ElementWidth,
                        rightMargin: this.timelineMargins.RightMargin
                    };
                    this.body = d3.select(element.get(0));
                    this.timelineDiv = this.body.append('div');
                    this.svg = this.timelineDiv.append('svg').attr('width', px(options.viewport.width)).classed(this.timelineSelectors.TimelineVisual.class, true);
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                    this.clearCatcher.data([this])
                        .on("click", function (timeline) { return timeline.clear(); })
                        .on("touchstart", function (timeline) { return timeline.clear(); });
                    this.rangeText = this.svg.append('g').classed(this.timelineSelectors.RangeTextArea.class, true).append('text');
                    this.mainGroupElement = this.svg.append('g').classed(this.timelineSelectors.MainArea.class, true);
                    this.yearLabelsElement = this.mainGroupElement.append('g');
                    this.quarterLabelsElement = this.mainGroupElement.append('g');
                    this.monthLabelsElement = this.mainGroupElement.append('g');
                    this.weekLabelsElement = this.mainGroupElement.append('g');
                    this.dayLabelsElement = this.mainGroupElement.append('g');
                    this.cellsElement = this.mainGroupElement.append('g').classed(this.timelineSelectors.CellsArea.class, true);
                    this.cursorGroupElement = this.svg.append('g').classed(this.timelineSelectors.CursorsArea.class, true);
                };
                Timeline.prototype.clear = function () {
                    this.selectionManager.clear();
                    if (this.timelineData) {
                        this.timelineData.selectionStartIndex = 0;
                        this.timelineData.selectionEndIndex = this.timelineData.currentGranularity.getDatePeriods().length - 1;
                        if (_.any(this.timelineData.timelineDatapoints, function (x) { return x.index % 1 !== 0; }))
                            this.selectPeriod(this.timelineData.currentGranularity.getType());
                        else {
                            Timeline.updateCursors(this.timelineData, this.timelineProperties.cellWidth);
                            this.fillCells(this.timelineFormat.cellFormat);
                            this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);
                            this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);
                        }
                        this.setSelection(this.timelineData);
                    }
                };
                Timeline.prototype.drawGranular = function (timelineProperties) {
                    var _this = this;
                    var dragPeriodRectState = false;
                    var startXpoint = timelineProperties.startXpoint;
                    var startYpoint = timelineProperties.startYpoint;
                    var elementWidth = timelineProperties.elementWidth;
                    this.selectorContainer = this.svg.append('g').classed(this.timelineSelectors.TimelineSlicer.class, true);
                    this.selectorContainer.on('mouseleave', function (d) { return dragPeriodRectState = false; });
                    var fillRect = this.selectorContainer.append('rect');
                    var selectorPeriods = this.selector;
                    fillRect.attr({
                        height: px(1),
                        x: px(startXpoint),
                        y: px(startYpoint + 2),
                        width: px((selectorPeriods.length - 1) * elementWidth)
                    });
                    var fillVertLine = this.selectorContainer.selectAll("vertLines")
                        .data(selectorPeriods).enter().append('rect');
                    fillVertLine
                        .classed(this.timelineSelectors.VertLine.class, true)
                        .attr({
                        x: function (d, index) { return px(startXpoint + index * elementWidth); },
                        y: px(startYpoint),
                        width: px(2),
                        height: px(3)
                    })
                        .style({ 'cursor': 'pointer' });
                    var text = this.selectorContainer.selectAll(this.timelineSelectors.PeriodSlicerGranularities.selector)
                        .data(selectorPeriods)
                        .enter()
                        .append("text")
                        .classed(this.timelineSelectors.PeriodSlicerGranularities.class, true);
                    var textLabels;
                    textLabels = text.text(function (d) { return d; })
                        .attr({
                        x: function (d, index) { return px(startXpoint - 3 + index * elementWidth); },
                        y: px(startYpoint - 3)
                    });
                    this.selectedText = this.selectorContainer.append("text").classed(this.timelineSelectors.PeriodSlicerSelection.class, true);
                    this.selectedText.text(Utils.getGranularityName(this.defaultTimelineProperties.DefaultGranularity))
                        .attr({
                        x: px(startXpoint + 2 * elementWidth),
                        y: px(startYpoint + 17),
                    });
                    var selRects = this.selectorContainer
                        .selectAll(this.timelineSelectors.PeriodSlicerSelectionRect.selector)
                        .data(selectorPeriods)
                        .enter()
                        .append('rect')
                        .classed(this.timelineSelectors.PeriodSlicerSelectionRect.class, true);
                    var clickHandler = function (d, index) {
                        _this.selectPeriod(index);
                        dragPeriodRectState = true;
                    };
                    selRects.attr({
                        x: function (d, index) { return px(startXpoint - elementWidth / 2 + index * elementWidth); },
                        y: px(3),
                        width: px(elementWidth),
                        height: px(23)
                    })
                        .style({ 'cursor': 'pointer' })
                        .on('mousedown', clickHandler)
                        .on('touchstart', clickHandler)
                        .on('mouseup', function () { return dragPeriodRectState = false; })
                        .on('touchend', function () { return dragPeriodRectState = false; })
                        .on("mouseover", function (d, index) {
                        if (dragPeriodRectState) {
                            _this.selectPeriod(index);
                        }
                    });
                    var dragPeriodRect = d3.behavior.drag()
                        .on("dragstart", function (e, b) {
                        dragPeriodRectState = true;
                    })
                        .on("dragend", function (e, b) {
                        dragPeriodRectState = false;
                    });
                    this.periodSlicerRect = this.selectorContainer
                        .append('rect').classed(this.timelineSelectors.PeriodSlicerRect.class, true)
                        .attr({
                        x: px(startXpoint - 6 + this.defaultTimelineProperties.DefaultGranularity * elementWidth),
                        y: px(startYpoint - 16),
                        rx: px(4),
                        width: px(15),
                        height: px(23)
                    })
                        .on('mouseup', function (d) { return dragPeriodRectState = false; });
                    this.periodSlicerRect.call(dragPeriodRect);
                };
                Timeline.prototype.redrawPeriod = function (granularity) {
                    var dx = this.timelineMargins.StartXpoint + granularity * this.timelineMargins.ElementWidth;
                    this.periodSlicerRect.transition().attr("x", px(dx - 7));
                    this.selectedText.text(Utils.getGranularityName(granularity));
                    var startDate = Utils.getStartSelectionDate(this.timelineData);
                    var endDate = Utils.getEndSelectionDate(this.timelineData);
                    this.changeGranularity(granularity, startDate, endDate);
                };
                Timeline.setMeasures = function (labelFormat, granularityType, datePeriodsCount, viewport, timelineProperties, timelineMargins) {
                    timelineProperties.cellsYPosition = timelineProperties.textYPosition;
                    var labelSize = fromPointToPixel(labelFormat.sizeProperty);
                    if (labelFormat.showProperty)
                        timelineProperties.cellsYPosition += labelSize * 1.5 * (granularityType + 1);
                    var svgHeight = Math.max(0, viewport.height - timelineMargins.TopMargin);
                    var maxHeight = viewport.width - timelineMargins.RightMargin - timelineMargins.MinCellWidth * datePeriodsCount;
                    var height = Math.max(timelineMargins.MinCellWidth, Math.min(timelineMargins.MaxCellHeight, maxHeight, svgHeight - timelineProperties.cellsYPosition - 20));
                    var width = Math.max(timelineMargins.MinCellWidth, (viewport.width - height - timelineMargins.RightMargin) / datePeriodsCount);
                    timelineProperties.cellHeight = height;
                    timelineProperties.cellWidth = width;
                };
                Timeline.prototype.visualChangeOnly = function (options) {
                    if (options && options.dataViews && options.dataViews[0] && options.dataViews[0].metadata &&
                        this.options && this.options.dataViews && this.options.dataViews[0] && this.options.dataViews[0].metadata) {
                        var newObjects_1 = options.dataViews[0].metadata.objects;
                        var oldObjects_1 = this.options.dataViews[0].metadata.objects;
                        var properties = ['rangeHeader', 'cells', 'labels'];
                        var metadataChanged = !properties.every(function (x) { return _.isEqual(newObjects_1 ? newObjects_1[x] : undefined, oldObjects_1 ? oldObjects_1[x] : undefined); });
                        return options.suppressAnimations || metadataChanged;
                    }
                    return false;
                };
                Timeline.prototype.unavailableType = function (dataViewCategorical) {
                    return !dataViewCategorical.categories
                        || dataViewCategorical.categories.length !== 1
                        || !dataViewCategorical.categories[0].values
                        || dataViewCategorical.categories[0].values.length === 0
                        || !dataViewCategorical.categories[0].source
                        || !dataViewCategorical.categories[0].source.type;
                };
                Timeline.prototype.unavailableChildIdentityField = function (dataViewTree) {
                    return !dataViewTree.root || !dataViewTree.root.childIdentityFields || dataViewTree.root.childIdentityFields.length === 0;
                };
                Timeline.prototype.createTimelineOptions = function (dataView) {
                    this.dataView = dataView;
                    if (!dataView.categorical
                        || !dataView.metadata
                        || this.unavailableType(dataView.categorical)
                        || !dataView.tree
                        || this.unavailableChildIdentityField(dataView.tree))
                        return false;
                    var columnExp = dataView.tree.root.childIdentityFields[0];
                    this.valueType = columnExp ? columnExp.ref : null;
                    if (!(dataView.categorical.categories[0].source.type.dateTime ||
                        (dataView.categorical.categories[0].source.type.numeric && (this.valueType === 'Year' || this.valueType === 'Date'))))
                        return false;
                    this.values = this.prepareValues(this.dataView.categorical.categories[0].values);
                    return true;
                };
                //Public for testability.
                Timeline.prototype.prepareValues = function (values) {
                    // remove null strings and rebuild string type date 
                    // (BUG #7266283 IN PBI-service)
                    values = values.filter(Boolean);
                    for (var i in values) {
                        var item = values[i];
                        if (typeof (item) === 'String' && (String(new Date(item)) !== 'Invalid Date')) {
                            return values[i] = new Date(item);
                        }
                    }
                    ;
                    return values;
                };
                Timeline.prototype.createTimelineData = function () {
                    var startDate;
                    var endDate;
                    if (this.valueType === 'Year') {
                        var years = this.values;
                        startDate = new Date(_.min(years), 0);
                        endDate = new Date(_.max(years), 11);
                    }
                    else {
                        var dates = this.values;
                        startDate = _.min(dates);
                        endDate = _.max(dates);
                    }
                    if (!this.initialized)
                        this.drawGranular(this.timelineProperties);
                    if (this.initialized) {
                        var actualEndDate = TimelineGranularityData.nextDay(endDate);
                        var daysPeriods = this.timelineGranularityData.getGranularity(GranularityType.day).getDatePeriods();
                        var prevStartDate = daysPeriods[0].startDate;
                        var prevEndDate = daysPeriods[daysPeriods.length - 1].endDate;
                        var changedSelection = startDate.getTime() >= prevStartDate.getTime() && actualEndDate.getTime() <= prevEndDate.getTime();
                        this.newGranularity = this.timelineData.currentGranularity.getType();
                        if (changedSelection) {
                            this.foreignSelection = true;
                            this.changeGranularity(this.newGranularity, startDate, actualEndDate);
                            this.timelineFormat = Timeline.fillTimelineFormat(this.options.dataViews[0].metadata.objects, this.defaultTimelineProperties);
                        }
                        else {
                            if (actualEndDate < prevEndDate)
                                endDate = daysPeriods[daysPeriods.length - 1].startDate;
                            if (startDate > prevStartDate)
                                startDate = prevStartDate;
                            this.initialized = false;
                        }
                    }
                    if (!this.initialized) {
                        this.timelineGranularityData = new TimelineGranularityData(startDate, endDate);
                        this.timelineData = {
                            elementsCount: 0,
                            timelineDatapoints: [],
                            cursorDataPoints: new Array()
                        };
                    }
                };
                Timeline.prototype.update = function (options) {
                    var visualChange = this.visualChangeOnly(options);
                    this.requiresNoUpdate = this.requiresNoUpdate && !visualChange;
                    if (this.requiresNoUpdate) {
                        if (this.foreignSelection)
                            this.foreignSelection = false;
                        else
                            this.requiresNoUpdate = false;
                        return;
                    }
                    this.options = options;
                    if (!options.dataViews || !options.dataViews[0])
                        return;
                    var validOptions = this.createTimelineOptions(options.dataViews[0]);
                    if (!validOptions) {
                        this.clearData();
                        return;
                    }
                    this.newGranularity = this.defaultTimelineProperties.DefaultGranularity;
                    if (!visualChange)
                        this.createTimelineData();
                    this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, options.dataViews[0], this.initialized, this.newGranularity, options.viewport, this.timelineMargins);
                    this.render(this.timelineData, this.timelineFormat, this.timelineProperties, options);
                    this.initialized = true;
                };
                Timeline.prototype.selectPeriod = function (periodNameIndex) {
                    this.redrawPeriod(periodNameIndex);
                    this.timelineFormat = Timeline.converter(this.timelineData, this.timelineProperties, this.defaultTimelineProperties, this.timelineGranularityData, this.options.dataViews[0], this.initialized, this.timelineData.currentGranularity.getType(), this.options.viewport, this.timelineMargins);
                    this.render(this.timelineData, this.timelineFormat, this.timelineProperties, this.options);
                };
                Timeline.isDataNotMatch = function (dataView) {
                    if (dataView.categorical.categories.length <= 0 ||
                        dataView.categorical.categories[0] === undefined ||
                        dataView.categorical.categories[0].identityFields === undefined ||
                        dataView.categorical.categories[0].identityFields.length <= 0)
                        return true;
                    return false;
                };
                Timeline.converter = function (timelineData, timelineProperties, defaultTimelineProperties, timelineGranularityData, dataView, initialized, granularityType, viewport, timelineMargins) {
                    var timelineFormat = Timeline.fillTimelineFormat(dataView.metadata.objects, defaultTimelineProperties);
                    if (!initialized) {
                        timelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 0 });
                        timelineData.cursorDataPoints.push({ x: 0, selectionIndex: 0, cursorIndex: 1 });
                    }
                    if (!initialized || Timeline.calendar.isChanged(timelineFormat.calendarFormat)) {
                        Timeline.calendar = new Calendar(timelineFormat.calendarFormat);
                        timelineGranularityData.createGranularities();
                        timelineGranularityData.createLabels();
                        timelineData.currentGranularity = timelineGranularityData.getGranularity(granularityType);
                        timelineData.selectionStartIndex = 0;
                        timelineData.selectionEndIndex = timelineData.currentGranularity.getDatePeriods().length - 1;
                    }
                    timelineData.categorySourceName = dataView.categorical.categories[0].source.displayName;
                    timelineData.columnIdentity = dataView.categorical.categories[0].identityFields[0];
                    if (dataView.categorical.categories[0].source.type.numeric) {
                        timelineData.columnIdentity.ref = "Date";
                    }
                    if (this.isDataNotMatch(dataView))
                        return;
                    var timelineElements = timelineData.currentGranularity.getDatePeriods();
                    timelineData.elementsCount = timelineElements.length;
                    timelineData.timelineDatapoints = [];
                    for (var _i = 0, timelineElements_1 = timelineElements; _i < timelineElements_1.length; _i++) {
                        var currentTimePeriod = timelineElements_1[_i];
                        var datapoint = {
                            index: currentTimePeriod.index,
                            datePeriod: currentTimePeriod
                        };
                        timelineData.timelineDatapoints.push(datapoint);
                    }
                    var countFullCells = timelineData.currentGranularity.getDatePeriods().filter(function (x) { return x.index % 1 === 0; }).length;
                    Timeline.setMeasures(timelineFormat.labelFormat, timelineData.currentGranularity.getType(), countFullCells, viewport, timelineProperties, timelineMargins);
                    Timeline.updateCursors(timelineData, timelineProperties.cellWidth);
                    return timelineFormat;
                };
                Timeline.prototype.render = function (timelineData, timelineFormat, timelineProperties, options) {
                    var timelineDatapointsCount = this.timelineData.timelineDatapoints.filter(function (x) { return x.index % 1 === 0; }).length;
                    this.svgWidth = 1 + this.timelineProperties.cellHeight + timelineProperties.cellWidth * timelineDatapointsCount;
                    this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);
                    this.timelineDiv.attr({
                        height: px(options.viewport.height),
                        width: px(options.viewport.width),
                        'drag-resize-disabled': true
                    }).style({
                        'overflow-x': 'auto',
                        'overflow-y': 'auto'
                    });
                    this.svg.attr({
                        height: px(Math.max(0, options.viewport.height - this.timelineMargins.TopMargin)),
                        width: px(Math.max(0, this.svgWidth))
                    });
                    var fixedTranslateString = visuals.SVGUtil.translate(timelineProperties.leftMargin, timelineProperties.topMargin);
                    var translateString = visuals.SVGUtil.translate(timelineProperties.cellHeight / 2, timelineProperties.topMargin);
                    this.mainGroupElement.attr('transform', translateString);
                    this.selectorContainer.attr('transform', fixedTranslateString);
                    this.cursorGroupElement.attr('transform', translateString);
                    var extendedLabels = this.timelineData.currentGranularity.getExtendedLabel();
                    var granularityType = this.timelineData.currentGranularity.getType();
                    var yPos = 0, yDiff = 1.50;
                    this.renderLabels(extendedLabels.yearLabels, this.yearLabelsElement, yPos, granularityType === 0);
                    yPos += yDiff;
                    this.renderLabels(extendedLabels.quarterLabels, this.quarterLabelsElement, yPos, granularityType === 1);
                    yPos += yDiff;
                    this.renderLabels(extendedLabels.monthLabels, this.monthLabelsElement, yPos, granularityType === 2);
                    yPos += yDiff;
                    this.renderLabels(extendedLabels.weekLabels, this.weekLabelsElement, yPos, granularityType === 3);
                    yPos += yDiff;
                    this.renderLabels(extendedLabels.dayLabels, this.dayLabelsElement, yPos, granularityType === 4);
                    this.renderCells(timelineData, timelineFormat, timelineProperties, options.suppressAnimations);
                    this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);
                };
                Timeline.prototype.renderLabels = function (labels, labelsElement, index, isLast) {
                    var _this = this;
                    var labelTextSelection = labelsElement.selectAll(this.timelineSelectors.textLabel.selector);
                    if (!this.timelineFormat.labelFormat.showProperty) {
                        labelTextSelection.remove();
                        return;
                    }
                    var labelsGroupSelection = labelTextSelection.data(labels);
                    labelsGroupSelection.enter().append('text').classed(this.timelineSelectors.textLabel.class, true);
                    labelsGroupSelection.text(function (x, id) {
                        if (!isLast && id === 0 && labels.length > 1) {
                            var fontSize = pt(_this.timelineFormat.labelFormat.sizeProperty);
                            var textProperties = {
                                text: labels[0].text,
                                fontFamily: 'arial',
                                fontSize: fontSize
                            };
                            var halfFirstTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2;
                            textProperties = {
                                text: labels[1].text,
                                fontFamily: 'arial',
                                fontSize: fontSize
                            };
                            var halfSecondTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties) / 2;
                            var diff = _this.timelineProperties.cellWidth * (labels[1].id - labels[0].id);
                            if (diff < halfFirstTextWidth + halfSecondTextWidth)
                                return "";
                        }
                        var labelFormattedTextOptions = {
                            label: x.text,
                            maxWidth: _this.timelineProperties.cellWidth * (isLast ? 0.90 : 3),
                            fontSize: _this.timelineFormat.labelFormat.sizeProperty
                        };
                        return visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
                    })
                        .style('font-size', pt(this.timelineFormat.labelFormat.sizeProperty))
                        .attr({
                        x: function (x) { return (x.id + 0.5) * _this.timelineProperties.cellWidth; },
                        y: this.timelineProperties.textYPosition + (1 + index) * fromPointToPixel(this.timelineFormat.labelFormat.sizeProperty),
                        fill: this.timelineFormat.labelFormat.colorProperty
                    }).append('title').text(function (x) { return x.title; });
                    labelsGroupSelection.exit().remove();
                };
                Timeline.prototype.clearData = function () {
                    this.initialized = false;
                    this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).remove();
                    this.mainGroupElement.selectAll(this.timelineSelectors.textLabel.selector).remove();
                    this.rangeText.text("");
                    this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).remove();
                    this.svg.select(this.timelineSelectors.TimelineSlicer.selector).remove();
                };
                Timeline.updateCursors = function (timelineData, cellWidth) {
                    var startDate = timelineData.timelineDatapoints[timelineData.selectionStartIndex].datePeriod;
                    timelineData.cursorDataPoints[0].selectionIndex = startDate.index;
                    var endDate = timelineData.timelineDatapoints[timelineData.selectionEndIndex].datePeriod;
                    timelineData.cursorDataPoints[1].selectionIndex = (endDate.index + endDate.fraction);
                };
                Timeline.fillTimelineFormat = function (objects, timelineProperties) {
                    var timelineFormat = {
                        rangeTextFormat: {
                            showProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, timelineProperties.TimelineDefaultTimeRangeShow),
                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, timelineProperties.DefaultTimeRangeColor),
                            sizeProperty: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, timelineProperties.TimelineDefaultTextSize)
                        },
                        cellFormat: {
                            colorInProperty: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, timelineProperties.TimelineDefaultCellColor),
                            colorOutProperty: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, timelineProperties.TimelineDefaultCellColorOut)
                        },
                        labelFormat: {
                            showProperty: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, timelineProperties.DefaultLabelsShow),
                            colorProperty: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, timelineProperties.DefaultLabelColor),
                            sizeProperty: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, timelineProperties.TimelineDefaultTextSize)
                        },
                        calendarFormat: {
                            firstMonthProperty: powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1),
                            firstDayProperty: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, timelineProperties.DefaultFirstDay))),
                            weekDayProperty: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, timelineProperties.DefaultFirstWeekDay)))
                        }
                    };
                    return timelineFormat;
                };
                Timeline.prototype.fillCells = function (cellFormat) {
                    var _this = this;
                    var dataPoints = this.timelineData.timelineDatapoints;
                    var cellSelection = this.mainGroupElement.selectAll(this.timelineSelectors.CellRect.selector).data(dataPoints);
                    cellSelection.attr('fill', function (d) { return Utils.getCellColor(d, _this.timelineData, cellFormat); });
                };
                Timeline.prototype.renderCells = function (timelineData, timelineFormat, timelineProperties, suppressAnimations) {
                    var _this = this;
                    var allDataPoints = timelineData.timelineDatapoints;
                    var totalX = 0;
                    var cellsSelection = this.cellsElement.selectAll(this.timelineSelectors.CellRect.selector).data(allDataPoints);
                    cellsSelection.enter().append('rect').classed(this.timelineSelectors.CellRect.class, true);
                    cellsSelection
                        .attr({
                        height: px(timelineProperties.cellHeight),
                        width: function (d) { return px(d.datePeriod.fraction * timelineProperties.cellWidth); },
                        x: function (d) {
                            var value = totalX;
                            totalX += d.datePeriod.fraction * timelineProperties.cellWidth;
                            return px(value);
                        },
                        y: px(timelineProperties.cellsYPosition),
                        id: function (d) { return d.index; }
                    });
                    var clickHandler = function (d, index) {
                        d3.event.preventDefault();
                        var cursorDataPoints = _this.timelineData.cursorDataPoints;
                        var keyEvent = d3.event;
                        if (keyEvent.altKey || keyEvent.shiftKey) {
                            if (_this.timelineData.selectionEndIndex < index) {
                                cursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);
                                timelineData.selectionEndIndex = index;
                            }
                            else {
                                cursorDataPoints[0].selectionIndex = d.datePeriod.index;
                                timelineData.selectionStartIndex = index;
                            }
                        }
                        else {
                            timelineData.selectionStartIndex = index;
                            timelineData.selectionEndIndex = index;
                            cursorDataPoints[0].selectionIndex = d.datePeriod.index;
                            cursorDataPoints[1].selectionIndex = (d.datePeriod.index + d.datePeriod.fraction);
                        }
                        _this.fillCells(timelineFormat.cellFormat);
                        _this.renderCursors(timelineData, timelineFormat, timelineProperties.cellHeight, timelineProperties.cellsYPosition);
                        _this.renderTimeRangeText(timelineData, timelineFormat.rangeTextFormat);
                        _this.setSelection(timelineData);
                    };
                    cellsSelection
                        .on('click', clickHandler)
                        .on("touchstart", clickHandler);
                    this.fillCells(timelineFormat.cellFormat);
                    cellsSelection.exit().remove();
                };
                Timeline.prototype.dragstarted = function () {
                    this.timelineData.dragging = true;
                };
                Timeline.prototype.dragged = function (currentCursor) {
                    if (this.timelineData.dragging === true) {
                        var xScale = 1;
                        var container = d3.select(this.timelineSelectors.TimelineVisual.selector);
                        if (container) {
                            var transform = container.style("transform");
                            if (transform !== undefined && transform !== 'none') {
                                var str = transform.split("(")[1];
                                xScale = Number(str.split(", ")[0]);
                            }
                        }
                        var cursorOverElement = this.findCursorOverElement(d3.event.x);
                        if (!cursorOverElement) {
                            return;
                        }
                        var currentlyMouseOverElement = cursorOverElement.datapoint, currentlyMouseOverElementIndex = cursorOverElement.index;
                        if (currentCursor.cursorIndex === 0 && currentlyMouseOverElementIndex <= this.timelineData.selectionEndIndex) {
                            this.timelineData.selectionStartIndex = currentlyMouseOverElementIndex;
                            this.timelineData.cursorDataPoints[0].selectionIndex = currentlyMouseOverElement.datePeriod.index;
                        }
                        if (currentCursor.cursorIndex === 1 && currentlyMouseOverElementIndex >= this.timelineData.selectionStartIndex) {
                            this.timelineData.selectionEndIndex = currentlyMouseOverElementIndex;
                            this.timelineData.cursorDataPoints[1].selectionIndex = (currentlyMouseOverElement.datePeriod.index + currentlyMouseOverElement.datePeriod.fraction);
                        }
                        this.fillCells(this.timelineFormat.cellFormat);
                        this.renderCursors(this.timelineData, this.timelineFormat, this.timelineProperties.cellHeight, this.timelineProperties.cellsYPosition);
                        this.renderTimeRangeText(this.timelineData, this.timelineFormat.rangeTextFormat);
                    }
                };
                /**
                 * Note: Public for testability.
                 */
                Timeline.prototype.findCursorOverElement = function (x) {
                    var timelineDatapoints = this.timelineData.timelineDatapoints || [], length = timelineDatapoints.length, cellWidth = this.timelineProperties.cellWidth;
                    if (timelineDatapoints[0] && timelineDatapoints[1] && x <= timelineDatapoints[1].index * cellWidth) {
                        return {
                            index: 0,
                            datapoint: timelineDatapoints[0]
                        };
                    }
                    else if (timelineDatapoints[length - 1] && x >= timelineDatapoints[length - 1].index * cellWidth) {
                        return {
                            index: length - 1,
                            datapoint: timelineDatapoints[length - 1]
                        };
                    }
                    for (var i = 1; i < length; i++) {
                        var left = timelineDatapoints[i].index * cellWidth, right = timelineDatapoints[i + 1].index * cellWidth;
                        if (x >= left && x <= right) {
                            return {
                                index: i,
                                datapoint: timelineDatapoints[i]
                            };
                        }
                    }
                    return null;
                };
                Timeline.prototype.dragended = function () {
                    this.setSelection(this.timelineData);
                };
                Timeline.prototype.renderCursors = function (timelineData, timelineFormat, cellHeight, cellsYPosition) {
                    var _this = this;
                    var cursorSelection = this.cursorGroupElement.selectAll(this.timelineSelectors.SelectionCursor.selector).data(timelineData.cursorDataPoints);
                    cursorSelection.enter().append('path').classed(this.timelineSelectors.SelectionCursor.class, true);
                    cursorSelection.attr("transform", function (d) { return visuals.SVGUtil.translate(d.selectionIndex * _this.timelineProperties.cellWidth, cellHeight / 2 + cellsYPosition); }).attr({
                        d: d3.svg.arc()
                            .innerRadius(0)
                            .outerRadius(cellHeight / 2)
                            .startAngle(function (d) { return d.cursorIndex * Math.PI + Math.PI; })
                            .endAngle(function (d) { return d.cursorIndex * Math.PI + 2 * Math.PI; })
                    })
                        .call(this.drag);
                    cursorSelection.exit().remove();
                    return cursorSelection;
                };
                Timeline.prototype.renderTimeRangeText = function (timelineData, timeRangeFormat) {
                    var leftMargin = (GranularityNames.length + 2) * this.timelineProperties.elementWidth;
                    var maxWidth = this.svgWidth - leftMargin - this.timelineProperties.leftMargin;
                    if (timeRangeFormat.showProperty && maxWidth > 0) {
                        var timeRangeText = Utils.timeRangeText(timelineData);
                        var labelFormattedTextOptions = {
                            label: timeRangeText,
                            maxWidth: maxWidth,
                            fontSize: timeRangeFormat.sizeProperty
                        };
                        var actualText = visuals.dataLabelUtils.getLabelFormattedText(labelFormattedTextOptions);
                        this.rangeText.classed(this.timelineSelectors.SelectionRangeContainer.class, true);
                        this.rangeText.attr({
                            x: (GranularityNames.length) * (this.timelineProperties.elementWidth + this.timelineProperties.leftMargin),
                            y: 40,
                            fill: timeRangeFormat.colorProperty
                        })
                            .style({
                            'font-size': pt(timeRangeFormat.sizeProperty)
                        }).text(actualText)
                            .append('title').text(timeRangeText);
                        ;
                    }
                    else
                        this.rangeText.text("");
                };
                Timeline.prototype.setSelection = function (timelineData) {
                    this.requiresNoUpdate = true;
                    var lower = powerbi.data.SQExprBuilder.dateTime(Utils.getStartSelectionDate(timelineData));
                    var upper = powerbi.data.SQExprBuilder.dateTime(new Date(Utils.getEndSelectionDate(timelineData).getTime() - 1));
                    var filterExpr = powerbi.data.SQExprBuilder.between(timelineData.columnIdentity, lower, upper);
                    var filter = powerbi.data.SemanticFilter.fromSQExpr(filterExpr);
                    var objects = {
                        merge: [
                            {
                                objectName: "general",
                                selector: undefined,
                                properties: {
                                    "filter": filter,
                                }
                            }
                        ]
                    };
                    this.hostServices.persistProperties(objects);
                    this.hostServices.onSelect({ data: [] });
                };
                // This function retruns the values to be displayed in the property pane for each object.
                // Usually it is a bind pass of what the property pane gave you, but sometimes you may want to do
                // validation and return other values/defaults 
                Timeline.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder();
                    switch (options.objectName) {
                        case 'rangeHeader':
                            this.enumerateRangeHeader(enumeration, this.dataView);
                            break;
                        case 'cells':
                            this.enumerateCells(enumeration, this.dataView);
                            break;
                        case 'labels':
                            this.enumerateLabels(enumeration, this.dataView);
                            break;
                        case 'calendar':
                            this.enumerateCalendar(enumeration, this.dataView);
                            break;
                        case 'weekDay':
                            this.enumerateWeekDay(enumeration, this.dataView);
                            break;
                    }
                    return enumeration.complete();
                };
                Timeline.prototype.enumerateRangeHeader = function (enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
                    enumeration.pushInstance({
                        objectName: 'rangeHeader',
                        displayName: 'Selection Color',
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, TimeRangeShowProp, this.defaultTimelineProperties.TimelineDefaultTimeRangeShow),
                            fontColor: powerbi.DataViewObjects.getFillColor(objects, TimeRangeColorProp, this.defaultTimelineProperties.DefaultTimeRangeColor),
                            textSize: powerbi.DataViewObjects.getValue(objects, TimeRangeSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                        }
                    });
                };
                Timeline.prototype.enumerateCells = function (enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
                    enumeration.pushInstance({
                        objectName: 'cells',
                        selector: null,
                        properties: {
                            fillSelected: powerbi.DataViewObjects.getFillColor(objects, SelectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColor),
                            fillUnselected: powerbi.DataViewObjects.getFillColor(objects, UnselectedCellColorProp, this.defaultTimelineProperties.TimelineDefaultCellColorOut)
                        }
                    });
                };
                Timeline.prototype.enumerateLabels = function (enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
                    enumeration.pushInstance({
                        objectName: 'labels',
                        selector: null,
                        properties: {
                            show: powerbi.DataViewObjects.getValue(objects, LabelsShowProp, this.defaultTimelineProperties.DefaultLabelsShow),
                            fontColor: powerbi.DataViewObjects.getFillColor(objects, LabelsColorProp, this.defaultTimelineProperties.DefaultLabelColor),
                            textSize: powerbi.DataViewObjects.getValue(objects, LabelsSizeProp, this.defaultTimelineProperties.TimelineDefaultTextSize)
                        }
                    });
                };
                Timeline.prototype.enumerateCalendar = function (enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
                    enumeration.pushInstance({
                        objectName: 'calendar',
                        selector: null,
                        properties: {
                            month: Math.max(1, Math.min(12, powerbi.DataViewObjects.getValue(objects, CalendarMonthProp, 1))),
                            day: Math.max(1, Math.min(31, powerbi.DataViewObjects.getValue(objects, CalendarDayProp, 1))),
                        }
                    });
                };
                Timeline.prototype.enumerateWeekDay = function (enumeration, dataview) {
                    var objects = dataview && dataview.metadata ? dataview.metadata.objects : undefined;
                    enumeration.pushInstance({
                        objectName: 'weekDay',
                        selector: null,
                        properties: {
                            day: Math.max(0, Math.min(6, powerbi.DataViewObjects.getValue(objects, WeekDayProp, 0)))
                        }
                    });
                };
                Timeline.capabilities = {
                    dataRoles: [{
                            name: 'Time',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Time'
                        }],
                    dataViewMappings: [{
                            conditions: [
                                { 'Time': { max: 1 } }
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Time' },
                                    dataReductionAlgorithm: { sample: {} }
                                },
                                values: {
                                    select: [{
                                            bind: { to: 'Time' }
                                        }]
                                },
                            }
                        }],
                    objects: {
                        general: {
                            displayName: 'General',
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: true
                                        }
                                    },
                                },
                                selected: {
                                    type: { bool: true }
                                },
                                filter: {
                                    type: { filter: {} },
                                    rule: {
                                        output: {
                                            property: 'selected',
                                            selector: ['Time'],
                                        }
                                    }
                                },
                            },
                        },
                        calendar: {
                            displayName: 'Fiscal Year Start',
                            properties: {
                                month: {
                                    displayName: 'Month',
                                    type: { enumeration: samples.Months }
                                },
                                day: {
                                    displayName: 'Day',
                                    type: { numeric: true }
                                }
                            }
                        },
                        weekDay: {
                            displayName: 'First Day of Week',
                            properties: {
                                day: {
                                    displayName: 'Day',
                                    type: { enumeration: samples.WeekDays }
                                }
                            }
                        },
                        rangeHeader: {
                            displayName: 'Range Header',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                fontColor: {
                                    displayName: 'Font color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                textSize: {
                                    displayName: 'Text Size',
                                    type: { numeric: true }
                                }
                            }
                        },
                        cells: {
                            displayName: 'Cells',
                            properties: {
                                fillSelected: {
                                    displayName: 'Selected cell color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fillUnselected: {
                                    displayName: 'Unselected cell color',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        labels: {
                            displayName: 'Labels',
                            properties: {
                                show: {
                                    displayName: 'Show',
                                    type: { bool: true }
                                },
                                fontColor: {
                                    displayName: 'Font color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                textSize: {
                                    displayName: 'Text Size',
                                    type: { numeric: true }
                                }
                            }
                        }
                    }
                };
                return Timeline;
            }());
            samples.Timeline = Timeline;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ValueFormatter = powerbi.visuals.valueFormatter;
            var SelectionManager = visuals.utility.SelectionManager;
            var StreamGraphAxisGraphicsContextClassName = 'axisGraphicsContext';
            var StreamGraphXAxisClassName = 'x axis';
            var StreamGraphYAxisClassName = 'y axis';
            var StreamGraphDefaultAxisColor = "#777";
            var StreamGraphDefaultFontSizeInPoints = 8;
            var DefaultLegendFontSizeInPt = 8;
            var DefaultLegendLabelFillColor = '#666666';
            var StreamGraphDefaultFontFamily = 'wf_segoe-ui_normal';
            var StreamGraphDefaultFontWeight = 'normal';
            var StreamGraphDefaultSettings = {
                legendSettings: {
                    show: true,
                    showTitle: true,
                    labelColor: DefaultLegendLabelFillColor,
                    titleText: "",
                    fontSize: DefaultLegendFontSizeInPt
                },
                categoryAxisSettings: {
                    show: true,
                    axisColor: StreamGraphDefaultAxisColor,
                    showAxisTitle: false,
                },
                valueAxisSettings: {
                    show: true,
                    axisColor: StreamGraphDefaultAxisColor,
                    showAxisTitle: false,
                },
            };
            var StreamGraph = (function () {
                function StreamGraph() {
                    this.margin = { left: 45, right: 20, bottom: 20, top: 20 };
                }
                StreamGraph.prototype.converter = function (dataView, colors) {
                    if (!dataView || !dataView.categorical || !dataView.categorical.values || !dataView.categorical.categories)
                        return null;
                    var catDv = dataView.categorical, values = catDv.values, dataPoints = [], legendData = {
                        dataPoints: [],
                        title: values[0].source.displayName,
                        fontSize: StreamGraphDefaultFontSizeInPoints,
                    }, value = 0, valueFormatter, categoryFormatter;
                    for (var i = 0; i < values.length; i++) {
                        dataPoints.push([]);
                        if (values[i].source.groupName) {
                            legendData.dataPoints.push({
                                label: values[i].source.groupName,
                                color: colors.getColorByIndex(i).value,
                                icon: visuals.LegendIcon.Box,
                                selected: false,
                                identity: visuals.SelectionId.createWithId(values[i].identity)
                            });
                        }
                        for (var k = 0; k < values[i].values.length; k++) {
                            var id = visuals.SelectionIdBuilder
                                .builder()
                                .withSeries(dataView.categorical.values, dataView.categorical.values[i])
                                .createSelectionId(), y = values[i].values[k];
                            if (y > value) {
                                value = y;
                            }
                            dataPoints[i].push({
                                x: k,
                                y: y,
                                identity: id
                            });
                        }
                    }
                    var streamGraphSettings = this.parseSettings(dataView);
                    valueFormatter = ValueFormatter.create({
                        format: "g",
                        value: value
                    });
                    categoryFormatter = ValueFormatter.create({
                        format: ValueFormatter.getFormatString(catDv.categories[0].source, StreamGraph.Properties.general.formatString),
                        value: catDv.categories[0].values
                    });
                    return {
                        dataPoints: dataPoints,
                        legendData: legendData,
                        valueFormatter: valueFormatter,
                        categoryFormatter: categoryFormatter,
                        streamGraphSettings: streamGraphSettings
                    };
                };
                StreamGraph.prototype.parseSettings = function (dataView) {
                    if (!dataView || !dataView.metadata)
                        return StreamGraphDefaultSettings;
                    var objects = dataView.metadata.objects;
                    var streamGraphSettings = _.clone(StreamGraphDefaultSettings);
                    var categoryAxisSettings = streamGraphSettings.categoryAxisSettings;
                    categoryAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.show, categoryAxisSettings.show);
                    categoryAxisSettings.axisColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.categoryAxis.axisColor, categoryAxisSettings.axisColor);
                    categoryAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.categoryAxis.showAxisTitle, categoryAxisSettings.showAxisTitle);
                    var valueAxisSettings = streamGraphSettings.valueAxisSettings;
                    valueAxisSettings.show = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.show, valueAxisSettings.show);
                    valueAxisSettings.axisColor = powerbi.DataViewObjects.getFillColor(objects, StreamGraph.Properties.valueAxis.axisColor, valueAxisSettings.axisColor);
                    valueAxisSettings.showAxisTitle = powerbi.DataViewObjects.getValue(objects, StreamGraph.Properties.valueAxis.showAxisTitle, valueAxisSettings.showAxisTitle);
                    return streamGraphSettings;
                };
                StreamGraph.prototype.init = function (options) {
                    var element = options.element;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    this.svg = d3.select(element.get(0))
                        .append('svg')
                        .classed(StreamGraph.VisualClassName, true)
                        .style('position', 'absolute');
                    this.axisGraphicsContext = this.svg.append('g')
                        .classed(StreamGraphAxisGraphicsContextClassName, true);
                    this.xAxis = this.axisGraphicsContext.append("g").classed(StreamGraphXAxisClassName, true);
                    this.yAxis = this.axisGraphicsContext.append("g").classed(StreamGraphYAxisClassName, true);
                    this.colors = options.style.colorPalette.dataColors;
                    this.legend = visuals.createLegend(element, false, null, true);
                };
                StreamGraph.prototype.update = function (options) {
                    var _this = this;
                    if (!options.dataViews || !options.dataViews[0] || !options.dataViews[0].categorical) {
                        this.clearData();
                        return;
                    }
                    ;
                    this.viewport = {
                        width: Math.max(0, options.viewport.width),
                        height: Math.max(0, options.viewport.height)
                    };
                    var duration = options.suppressAnimations ? 0 : 250, dataView = this.dataView = options.dataViews[0], data = this.data = this.converter(dataView, this.colors);
                    if (!data || !data.dataPoints || !data.dataPoints.length) {
                        this.clearData();
                        return;
                    }
                    var dataPoints = data.dataPoints;
                    this.renderLegend(data);
                    this.updateViewPort();
                    this.renderXAxisLabels();
                    this.renderYAxisLabels();
                    var height = Math.max(0, this.viewport.height - this.margin.top);
                    this.svg.attr({
                        'width': this.viewport.width,
                        'height': height
                    });
                    var stack = d3.layout.stack();
                    if (this.getWiggle(dataView))
                        stack.offset('wiggle');
                    var layers = stack(dataPoints);
                    var xScale = d3.scale.linear()
                        .domain([0, dataPoints[0].length - 1])
                        .range([this.margin.left, this.viewport.width - this.margin.right]);
                    var yScale = d3.scale.linear()
                        .domain([0, d3.max(layers, function (layer) {
                            return d3.max(layer, function (d) {
                                return d.y0 + d.y;
                            });
                        })])
                        .range([height - this.margin.bottom, this.margin.top]);
                    var area = d3.svg.area()
                        .interpolate('basis')
                        .x(function (d) { return xScale(d.x); })
                        .y0(function (d) { return yScale(d.y0); })
                        .y1(function (d) { return yScale(d.y0 + d.y); });
                    var selectionManager = this.selectionManager;
                    var selection = this.svg.selectAll(StreamGraph.Layer.selector)
                        .data(layers);
                    selection.enter()
                        .append('path')
                        .classed(StreamGraph.Layer.class, true);
                    selection
                        .style("fill", function (d, i) { return _this.colors.getColorByIndex(i).value; })
                        .on('click', function (d) {
                        var _this = this;
                        selectionManager.select(d[0].identity).then(function (ids) {
                            if (ids.length > 0) {
                                selection.style('opacity', 0.5);
                                d3.select(_this).style('opacity', 1);
                            }
                            else
                                selection.style('opacity', 1);
                        });
                    })
                        .transition()
                        .duration(duration)
                        .attr("d", area);
                    selection.exit().remove();
                    this.drawAxis(data, xScale, yScale);
                };
                StreamGraph.prototype.drawAxis = function (data, xScale, yScale) {
                    var _this = this;
                    var shiftY = this.viewport.height - this.margin.bottom - this.margin.top, shiftX = this.viewport.width - this.margin.left - this.margin.right, xAxis = d3.svg.axis();
                    xAxis.scale(xScale)
                        .orient("bottom")
                        .tickFormat((function (item, index) {
                        if (data.categoryFormatter)
                            item = data.categoryFormatter.format(item);
                        if (index != null && xAxis.tickValues() &&
                            (index === 0 || index === xAxis.tickValues().length - 1)) {
                            item = powerbi.TextMeasurementService.getTailoredTextOrDefault(StreamGraph.getTextPropertiesFunction(item), (index ? _this.margin.right : _this.margin.left) * 2);
                        }
                        return item;
                    }).bind(xAxis));
                    var yAxis = d3.svg.axis()
                        .scale(yScale)
                        .orient("left")
                        .tickFormat(function (item) {
                        if (data.valueFormatter) {
                            return data.valueFormatter.format(item);
                        }
                        return item;
                    });
                    this.setMaxTicks(xAxis, shiftX, StreamGraph.MaxNumberOfAxisXValues);
                    this.setMaxTicks(yAxis, shiftY);
                    var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                    if (valueAxisSettings.show) {
                        var axisColor = valueAxisSettings.axisColor;
                        this.yAxis
                            .attr("transform", visuals.SVGUtil.translate(this.margin.left, 0))
                            .call(yAxis);
                        this.yAxis.selectAll("text").style("fill", axisColor);
                    }
                    else
                        this.yAxis.selectAll("*").remove();
                    var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                    if (categoryAxisSettings.show) {
                        var axisColor = categoryAxisSettings.axisColor;
                        this.xAxis
                            .attr("transform", visuals.SVGUtil.translate(0, shiftY))
                            .call(xAxis);
                        this.xAxis.selectAll("text").style("fill", axisColor);
                    }
                    else
                        this.xAxis.selectAll("*").remove();
                };
                StreamGraph.prototype.renderYAxisLabels = function () {
                    this.yAxis.selectAll(StreamGraph.YAxisLabel.selector).remove();
                    var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                    if (valueAxisSettings.show) {
                        this.margin.left = 45;
                        if (valueAxisSettings.showAxisTitle)
                            if (this.dataView.categorical.values.source) {
                                var marginLeft_1 = this.margin.left = 65;
                                var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                                var isXAxisOn = categoryAxisSettings.show === true;
                                var isXTitleOn = categoryAxisSettings.showAxisTitle === true;
                                var height_1 = isXAxisOn ? isXTitleOn ? this.viewport.height - this.margin.bottom : this.viewport.height - this.margin.top : this.viewport.height;
                                var yAxisText = this.dataView.categorical.values.source.displayName;
                                var yAxisClass_1 = StreamGraph.YAxisLabel.class;
                                var yAxisLabel = this.yAxis.append("text")
                                    .style("text-anchor", "middle")
                                    .text(yAxisText)
                                    .call(function (text) {
                                    text.each(function () {
                                        var text = d3.select(this);
                                        text.attr({
                                            class: yAxisClass_1,
                                            transform: "rotate(-90)",
                                            y: -marginLeft_1 + 5,
                                            x: -(height_1 / 2),
                                            dy: "1em"
                                        });
                                    });
                                });
                                yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height_1, powerbi.TextMeasurementService.svgEllipsis);
                            }
                            else
                                valueAxisSettings.showAxisTitle = false;
                    }
                    else
                        this.margin.left = 20;
                };
                StreamGraph.prototype.renderXAxisLabels = function () {
                    this.xAxis.selectAll(StreamGraph.XAxisLabel.selector).remove();
                    var categoryAxisSettings = this.data.streamGraphSettings.categoryAxisSettings;
                    if (categoryAxisSettings.show) {
                        this.margin.bottom = 20;
                        if (categoryAxisSettings.showAxisTitle)
                            if (this.dataView.categorical.categories[0].source) {
                                var marginBottom_1 = this.margin.bottom = 40;
                                var valueAxisSettings = this.data.streamGraphSettings.valueAxisSettings;
                                var isYAxisOn = valueAxisSettings.show === true;
                                var isYTitleOn = valueAxisSettings.showAxisTitle === true;
                                var width_1 = isYAxisOn ? isYTitleOn ? this.viewport.width + this.margin.left : this.viewport.width + this.margin.right : this.viewport.width;
                                var xAxisText = this.dataView.categorical.categories[0].source.displayName;
                                var xAxisClass_1 = StreamGraph.XAxisLabel.class;
                                var xAxisLabel = this.xAxis.append("text")
                                    .style("text-anchor", "middle")
                                    .text(xAxisText)
                                    .call(function (text) {
                                    text.each(function () {
                                        var text = d3.select(this);
                                        text.attr({
                                            class: xAxisClass_1,
                                            transform: visuals.SVGUtil.translate(width_1 / 2, marginBottom_1 - 5)
                                        });
                                    });
                                });
                                xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width_1, powerbi.TextMeasurementService.svgEllipsis);
                            }
                            else
                                categoryAxisSettings.showAxisTitle = false;
                    }
                    else
                        this.margin.bottom = 10;
                };
                StreamGraph.prototype.renderLegend = function (streamGraphData) {
                    var legendData = streamGraphData.legendData;
                    if (!legendData || !this.dataView || !this.dataView.metadata)
                        return;
                    this.legendObjectProperties = powerbi.DataViewObjects.getObject(this.dataView.metadata.objects, "legend", {});
                    if (this.legendObjectProperties) {
                        visuals.LegendData.update(legendData, this.legendObjectProperties);
                        var position = this.legendObjectProperties[visuals.legendProps.position];
                        if (position)
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                    }
                    this.legend.drawLegend(legendData, _.clone(this.viewport));
                    visuals.Legend.positionChartArea(this.svg, this.legend);
                };
                StreamGraph.prototype.updateViewPort = function () {
                    var legendMargins = this.legend.getMargins();
                    var legendPosition = visuals.LegendPosition[this.legendObjectProperties[visuals.legendProps.position]];
                    switch (legendPosition) {
                        case visuals.LegendPosition.Top:
                        case visuals.LegendPosition.TopCenter:
                        case visuals.LegendPosition.Bottom:
                        case visuals.LegendPosition.BottomCenter: {
                            this.viewport.height -= legendMargins.height;
                            break;
                        }
                        case visuals.LegendPosition.Left:
                        case visuals.LegendPosition.LeftCenter:
                        case visuals.LegendPosition.Right:
                        case visuals.LegendPosition.RightCenter: {
                            this.viewport.width -= legendMargins.width;
                            break;
                        }
                    }
                };
                StreamGraph.prototype.setMaxTicks = function (axis, maxSize, maxValue) {
                    var maxTicks = maxValue === undefined
                        ? this.getTicksByAxis(axis).length
                        : Math.min(maxValue, this.getTicksByAxis(axis).length);
                    if (axis.scale().domain.toString() === d3.scale.linear().domain.toString())
                        axis.ticks(this.getFittedTickLength(axis, maxSize, maxTicks));
                    else
                        axis.tickValues(this.getFittedTickValues(axis, maxSize, maxTicks));
                };
                StreamGraph.prototype.getFittedTickLength = function (axis, maxSize, maxTicks) {
                    for (var ticks = this.getTicksByAxis(axis), measureTickFunction = this.getMeasureTickFunction(axis, ticks); maxTicks > 0 && maxSize > 0 && (this.measureTicks(ticks, measureTickFunction) > maxSize || axis.scale().ticks([maxTicks]).length > maxTicks); maxTicks--, ticks = this.getTicksByAxis(axis)) {
                        axis.ticks(maxTicks);
                    }
                    return maxTicks;
                };
                StreamGraph.prototype.getFittedTickValues = function (axis, maxSize, maxTicks) {
                    var ticks = this.getTicksByAxis(axis), maxWidthOf2Ticks, tickPairsWidths = [], measureTickFunction = this.getMeasureTickFunction(axis, ticks);
                    for (var currentMaxTicks = maxTicks, indexes = []; maxTicks > 0 && maxSize > 0; currentMaxTicks--, indexes = []) {
                        switch (currentMaxTicks) {
                            case 0:
                                return [];
                            case 1:
                                indexes = [0];
                                break;
                            case 2:
                                indexes = [0, ticks.length - 1];
                                break;
                            default:
                                var takeEvery = ticks.length / (currentMaxTicks - 1);
                                for (var i = 0; i < currentMaxTicks - 1; i++) {
                                    indexes.push(Math.round(takeEvery * i));
                                }
                                indexes.push(ticks.length - 1);
                                break;
                        }
                        var ticksIndexes = indexes.map(function (x) { return [ticks[x], x]; });
                        maxWidthOf2Ticks = (maxSize / ticks.length) * 2;
                        ticksIndexes.reduce(function (a, b) {
                            tickPairsWidths.push([measureTickFunction(a[0]) + measureTickFunction(b[0]), (b[1] - a[1]) * maxWidthOf2Ticks]);
                            return b;
                        });
                        if (!tickPairsWidths.some(function (x) { return x[0] > x[1]; })) {
                            return ticksIndexes.map(function (x) { return x[0]; });
                        }
                    }
                    return [];
                };
                StreamGraph.prototype.measureTicks = function (ticks, measureTickFunction) {
                    return ticks.map(function (x) { return measureTickFunction(x); }).reduce(function (a, b) { return a + b; });
                };
                StreamGraph.prototype.getTicksByAxis = function (axis) {
                    var scale = axis.scale();
                    var result = axis.tickValues() === null
                        ? scale.ticks
                            ? scale.ticks.apply(scale, axis.ticks())
                            : scale.domain()
                        : axis.tickValues();
                    return result.length === undefined ? [result] : result;
                };
                StreamGraph.prototype.getMeasureTickFunction = function (axis, ticks) {
                    var measureFunction = axis.orient() === "top" || axis.orient() === "bottom"
                        ? powerbi.TextMeasurementService.measureSvgTextWidth
                        : powerbi.TextMeasurementService.measureSvgTextHeight;
                    var cache = {};
                    return function (x) {
                        return cache[x]
                            ? cache[x]
                            : cache[x] = measureFunction(StreamGraph.getTextPropertiesFunction(axis.tickFormat()(x))) + axis.tickPadding();
                    };
                };
                StreamGraph.getTextPropertiesFunction = function (text) {
                    var fontFamily = StreamGraphDefaultFontFamily, fontSize = jsCommon.PixelConverter.fromPoint(StreamGraphDefaultFontSizeInPoints), fontWeight = StreamGraphDefaultFontWeight;
                    return { text: text, fontFamily: fontFamily, fontSize: fontSize, fontWeight: fontWeight };
                };
                StreamGraph.prototype.getWiggle = function (dataView) {
                    if (dataView && dataView.metadata) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var general = powerbi.DataViewObjects.getObject(objects, 'general', undefined);
                            if (general)
                                return general['wiggle'];
                        }
                    }
                    return true;
                };
                StreamGraph.prototype.enumerateValueAxisValues = function (enumeration) {
                    var valueAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.valueAxisSettings : StreamGraphDefaultSettings.valueAxisSettings;
                    enumeration.pushInstance({
                        selector: null,
                        objectName: 'valueAxis',
                        displayName: "Y-Axis",
                        properties: {
                            show: valueAxisSettings.show,
                            showAxisTitle: valueAxisSettings.showAxisTitle,
                            axisColor: valueAxisSettings.axisColor,
                        }
                    });
                };
                StreamGraph.prototype.enumerateCategoryAxisValues = function (enumeration) {
                    var categoryAxisSettings = this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.categoryAxisSettings : StreamGraphDefaultSettings.categoryAxisSettings;
                    enumeration.pushInstance({
                        selector: null,
                        objectName: 'categoryAxis',
                        displayName: "X-Axis",
                        properties: {
                            show: categoryAxisSettings.show,
                            showAxisTitle: categoryAxisSettings.showAxisTitle,
                            axisColor: categoryAxisSettings.axisColor,
                        }
                    });
                };
                StreamGraph.prototype.enumerateLegend = function (enumeration) {
                    var legendSettings = this.legendObjectProperties ? this.legendObjectProperties : {};
                    enumeration.pushInstance({
                        selector: null,
                        objectName: 'legend',
                        displayName: "Legend",
                        properties: {
                            show: this.data && this.data.streamGraphSettings ? this.data.streamGraphSettings.legendSettings.show : true,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.showTitle, true),
                            titleText: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.titleText, ""),
                            labelColor: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.labelColor, DefaultLegendLabelFillColor),
                            fontSize: powerbi.DataViewObject.getValue(legendSettings, visuals.legendProps.fontSize, DefaultLegendFontSizeInPt)
                        }
                    });
                };
                StreamGraph.prototype.clearData = function () {
                    this.svg.selectAll(StreamGraph.Layer.selector).remove();
                    this.legend.drawLegend({ dataPoints: [] }, this.viewport);
                    this.yAxis.selectAll("*").remove();
                    this.xAxis.selectAll("*").remove();
                };
                StreamGraph.prototype.enumerateObjectInstances = function (options) {
                    var enumeration = new visuals.ObjectEnumerationBuilder(), dataView = this.dataView;
                    switch (options.objectName) {
                        case 'legend':
                            if (dataView
                                && dataView.categorical
                                && dataView.categorical.values
                                && dataView.categorical.values.source)
                                this.enumerateLegend(enumeration);
                            break;
                        case 'categoryAxis':
                            this.enumerateCategoryAxisValues(enumeration);
                            break;
                        case 'valueAxis':
                            this.enumerateValueAxisValues(enumeration);
                            break;
                        case 'general':
                            var general = {
                                objectName: 'general',
                                displayName: 'General',
                                selector: null,
                                properties: {
                                    wiggle: this.getWiggle(dataView)
                                }
                            };
                            enumeration.pushInstance(general);
                            break;
                    }
                    return enumeration.complete();
                };
                StreamGraph.VisualClassName = 'streamGraph';
                StreamGraph.Properties = {
                    general: {
                        formatString: {
                            objectName: 'general',
                            propertyName: 'formatString'
                        }
                    },
                    legend: {
                        show: {
                            objectName: "legend",
                            propertyName: "show"
                        }
                    },
                    categoryAxis: {
                        show: {
                            objectName: "categoryAxis",
                            propertyName: "show"
                        },
                        axisColor: {
                            objectName: "categoryAxis",
                            propertyName: "axisColor"
                        },
                        showAxisTitle: {
                            objectName: "categoryAxis",
                            propertyName: "showAxisTitle"
                        }
                    },
                    valueAxis: {
                        show: {
                            objectName: "valueAxis",
                            propertyName: "show"
                        },
                        axisColor: {
                            objectName: "valueAxis",
                            propertyName: "axisColor"
                        },
                        showAxisTitle: {
                            objectName: "valueAxis",
                            propertyName: "showAxisTitle"
                        }
                    }
                };
                StreamGraph.Layer = {
                    'class': 'layer',
                    selector: '.layer'
                };
                StreamGraph.XAxisLabel = {
                    'class': 'xAxisLabel',
                    selector: '.xAxisLabel'
                };
                StreamGraph.YAxisLabel = {
                    'class': 'yAxisLabel',
                    selector: '.yAxisLabel'
                };
                StreamGraph.MaxNumberOfAxisXValues = 5;
                StreamGraph.capabilities = {
                    dataRoles: [
                        {
                            name: 'Category',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Category',
                        }, {
                            name: 'Series',
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Series',
                        }, {
                            name: 'Y',
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                        },
                    ],
                    dataViewMappings: [{
                            conditions: [
                                { 'Category': { max: 1 }, 'Series': { max: 0 } },
                                { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                            ],
                            categorical: {
                                categories: {
                                    for: { in: 'Category' },
                                    dataReductionAlgorithm: { bottom: {} }
                                },
                                values: {
                                    group: {
                                        by: 'Series',
                                        select: [{ for: { in: 'Y' } }],
                                        dataReductionAlgorithm: { bottom: {} }
                                    }
                                },
                            }
                        }],
                    objects: {
                        general: {
                            displayName: 'General',
                            properties: {
                                formatString: { type: { formatting: { formatString: true } } },
                                wiggle: {
                                    type: { bool: true },
                                    displayName: 'Wiggle'
                                }
                            }
                        },
                        categoryAxis: {
                            displayName: 'X-Axis',
                            properties: {
                                show: {
                                    displayName: 'show',
                                    type: { bool: true }
                                },
                                showAxisTitle: {
                                    displayName: 'Title',
                                    type: { bool: true }
                                },
                                axisColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        valueAxis: {
                            displayName: 'Y-Axis',
                            properties: {
                                show: {
                                    displayName: 'show',
                                    type: { bool: true }
                                },
                                showAxisTitle: {
                                    displayName: 'Title',
                                    type: { bool: true }
                                },
                                axisColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                }
                            }
                        },
                        legend: {
                            displayName: 'Legend',
                            properties: {
                                show: {
                                    displayName: 'show',
                                    type: { bool: true }
                                },
                                position: {
                                    displayName: 'Position',
                                    type: { enumeration: visuals.legendPosition.type }
                                },
                                showTitle: {
                                    displayName: 'Title',
                                    type: { bool: true }
                                },
                                titleText: {
                                    displayName: 'Legend Name',
                                    type: { text: true },
                                    suppressFormatPainterCopy: true
                                },
                                labelColor: {
                                    displayName: 'Color',
                                    type: { fill: { solid: { color: true } } }
                                },
                                fontSize: {
                                    displayName: 'Text Size',
                                    type: { formatting: { fontSize: true } }
                                }
                            }
                        }
                    }
                };
                return StreamGraph;
            }());
            samples.StreamGraph = StreamGraph;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            samples.sunburstRoleNames = {
                nodes: 'Nodes',
                values: 'Values',
            };
            var Sunburst = (function () {
                function Sunburst() {
                    this.total = 0;
                }
                Sunburst.prototype.init = function (options) {
                    var _this = this;
                    this.arc = d3.svg.arc()
                        .startAngle(function (d) { return d.x; })
                        .endAngle(function (d) { return d.x + d.dx; })
                        .innerRadius(function (d) { return Math.sqrt(d.y); })
                        .outerRadius(function (d) { return Math.sqrt(d.y + d.dy); });
                    this.colors = options.style.colorPalette.dataColors;
                    this.selectionManager = new SelectionManager({ hostServices: options.host });
                    this.svg = d3.select(options.element.get(0)).append('svg');
                    this.svg.classed('mainDrawArea', true);
                    this.g = this.svg.append('g');
                    this.g.classed("container", true);
                    this.svg.append("text")
                        .classed("sunBurstPercentageFixed", true);
                    this.svg.on('mousedown', function (d) {
                        _this.svg.selectAll("path").style("opacity", 1);
                        _this.svg.select(".sunBurstPercentageFixed").style("opacity", 0);
                        _this.selectionManager.clear();
                    });
                };
                Sunburst.setAllUnhide = function (selection) {
                    selection.attr("setUnHide", "true");
                };
                Sunburst.prototype.update = function (options) {
                    if (options.dataViews.length > 0) {
                        var data = this.converter(options.dataViews[0], this.colors);
                        this.viewport = options.viewport;
                        this.updateInternal(data);
                    }
                };
                Sunburst.prototype.updateInternal = function (dataRootNode) {
                    var _this = this;
                    this.svg.attr({
                        'height': this.viewport.height,
                        'width': this.viewport.width
                    });
                    this.g.attr('transform', visuals.SVGUtil.translate(this.viewport.width / 2, this.viewport.height / 2));
                    var radius = Math.min(this.viewport.width, this.viewport.height) / 2;
                    var partition = d3.layout.partition()
                        .size([2 * Math.PI, radius * radius])
                        .value(function (d) { return d.value; });
                    var path = this.g.datum(dataRootNode).selectAll("path")
                        .data(partition.nodes);
                    path.enter().append("path");
                    path.attr("display", function (d) { return d.depth ? null : "none"; })
                        .attr("d", this.arc)
                        .style("stroke", "#fff")
                        .style("fill", function (d) { return d.color; })
                        .style("fill-rule", "evenodd")
                        .on("mousedown", function (d) {
                        if (d.selector) {
                            _this.selectionManager.select(d.selector);
                        }
                        d3.selectAll("path").call(Sunburst.setAllUnhide).attr('setUnHide', null);
                        _this.highlightPath(d, _this, true);
                        var percentageFixedText = _this.svg.select(".sunBurstPercentageFixed");
                        var percentage = _this.total === 0 ? 0 : (100 * d.total / _this.total).toPrecision(3);
                        percentageFixedText.text(d ? percentage + "%" : "");
                        percentageFixedText.style("fill", d.color);
                        _this.onResize();
                        event.stopPropagation();
                    });
                    this.renderTooltip(path);
                    path.exit().remove();
                    this.onResize();
                };
                // Get all parents of the node
                Sunburst.getTreePath = function (node) {
                    var path = [];
                    var current = node;
                    while (current.parent) {
                        path.unshift(current);
                        current = current.parent;
                    }
                    return path;
                };
                Sunburst.prototype.onResize = function () {
                    var width = this.viewport.width;
                    var height = this.viewport.height;
                    var percentageFixedText = this.svg.select(".sunBurstPercentageFixed");
                    var textWidth = powerbi.TextMeasurementService.measureSvgTextElementWidth(percentageFixedText[0][0]);
                    percentageFixedText.style("opacity", 1);
                    percentageFixedText.attr("y", (height / 2 + 4));
                    percentageFixedText.attr("x", ((width / 2) - (textWidth / 2)));
                };
                Sunburst.prototype.highlightPath = function (d, sunBurst, setUnhide) {
                    var parentsArray = d ? Sunburst.getTreePath(d) : [];
                    // Set opacity for all the segments.
                    sunBurst.svg.selectAll("path").each(function () {
                        if (d3.select(this).attr('setUnHide') !== 'true') {
                            d3.select(this).style("opacity", Sunburst.minOpacity);
                        }
                    });
                    // Highlight only ancestors of the current segment.
                    sunBurst.svg.selectAll("path")
                        .filter(function (node) {
                        return (parentsArray.indexOf(node) >= 0);
                    }).each(function () {
                        d3.select(this).style("opacity", 1);
                        if (setUnhide === true) {
                            d3.select(this).attr('setUnHide', 'true');
                        }
                    });
                };
                Sunburst.prototype.renderTooltip = function (selection) {
                    visuals.TooltipManager.addTooltip(selection, function (tooltipEvent) {
                        return tooltipEvent.data.tooltipInfo;
                    });
                };
                Sunburst.getTooltipData = function (displayName, value) {
                    return [{
                            displayName: displayName,
                            value: value < 0 ? "" : value.toString()
                        }];
                };
                Sunburst.prototype.covertTreeNodeToSunBurstNode = function (originParentNode, sunburstParentNode, colors, pathIdentity, color) {
                    var selector;
                    if (originParentNode.identity) {
                        pathIdentity = pathIdentity.concat([originParentNode.identity]);
                        selector = { data: pathIdentity, };
                    }
                    var selectionId = pathIdentity.length === 0 ? null : new visuals.SelectionId(selector, false);
                    var valueToSet = originParentNode.values ? originParentNode.values[0].value : 0;
                    var newSunNode = {
                        name: originParentNode.name,
                        value: Math.max(valueToSet, 0),
                        selector: selectionId,
                        total: valueToSet
                    };
                    if (originParentNode.value) {
                        newSunNode.color = color ? color : colors.getColor(originParentNode.value).value;
                    }
                    this.total += newSunNode.value;
                    if (originParentNode.children && originParentNode.children.length > 0) {
                        newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, -1);
                        newSunNode.children = [];
                        for (var i = 0; i < originParentNode.children.length; i++) {
                            var newChild = this.covertTreeNodeToSunBurstNode(originParentNode.children[i], newSunNode, colors, pathIdentity, newSunNode.color);
                            newSunNode.children.push(newChild);
                            newSunNode.total += newChild.total;
                        }
                    }
                    else {
                        newSunNode.tooltipInfo = Sunburst.getTooltipData(originParentNode.value, valueToSet);
                    }
                    if (sunburstParentNode) {
                        newSunNode.parent = sunburstParentNode;
                    }
                    return newSunNode;
                };
                Sunburst.prototype.converter = function (dataView, colors) {
                    var colorScale = colors.getNewColorScale();
                    this.total = 0;
                    var root = this.covertTreeNodeToSunBurstNode(dataView.matrix.rows.root, null, colorScale, [], undefined);
                    return root;
                };
                Sunburst.minOpacity = 0.2;
                Sunburst.roleNames = {
                    nodes: 'Nodes',
                    values: 'Values',
                };
                Sunburst.capabilities = {
                    dataRoles: [
                        {
                            name: Sunburst.roleNames.nodes,
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Groups'
                        }, {
                            name: Sunburst.roleNames.values,
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Values'
                        }
                    ],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                formatString: {
                                    type: { formatting: { formatString: true } },
                                },
                            },
                        },
                    },
                    dataViewMappings: [{
                            conditions: [
                                { 'Groups': { min: 0 }, 'Values': { max: 1 } },
                            ],
                            matrix: {
                                rows: {
                                    for: { in: Sunburst.roleNames.nodes },
                                },
                                values: {
                                    for: { in: Sunburst.roleNames.values }
                                },
                            }
                        }],
                };
                return Sunburst;
            }());
            samples.Sunburst = Sunburst;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            ;
            ;
            var LineDotChart = (function () {
                function LineDotChart() {
                    this.margin = {
                        top: 10,
                        right: 30,
                        bottom: 10,
                        left: 10
                    };
                    this.LegendSize = 50;
                    this.AxisSize = 30;
                }
                /* One time setup*/
                LineDotChart.prototype.init = function (options) {
                    var _this = this;
                    this.hostServices = options.host;
                    this.selectionManager = new SelectionManager({ hostServices: this.hostServices });
                    this.root = d3.select(options.element.get(0))
                        .append('svg')
                        .classed(LineDotChart.Identity.class, true);
                    this.root.on('click', function (d) { _this.clearSelection(); });
                    this.main = this.root.append('g');
                    this.axes = this.main.append('g').classed(LineDotChart.Axes.class, true);
                    this.axisX = this.axes.append('g').classed(LineDotChart.Axis.class, true);
                    this.axisY = this.axes.append('g').classed(LineDotChart.Axis.class, true);
                    this.axisY2 = this.axes.append('g').classed(LineDotChart.Axis.class, true);
                    this.legends = this.main.append('g').classed(LineDotChart.Legends.class, true);
                    this.line = this.main.append('g').classed(LineDotChart.Values.class, true);
                    this.colors = options.style && options.style.colorPalette
                        ? options.style.colorPalette.dataColors
                        : new visuals.DataColorPalette();
                };
                /* Called for data, size, formatting changes*/
                LineDotChart.prototype.update = function (options) {
                    if (!options.dataViews || !options.dataViews[0]) {
                        return;
                    }
                    var viewport = options.viewport;
                    var model = this.model = this.converter(options.dataViews[0], viewport);
                    // if (!model) {
                    //     return;
                    // }
                    this.clearSelection();
                    this.resize(viewport);
                    // this.draw(model, !options.suppressAnimations);
                    this.draw(model);
                };
                /*About to remove your visual, do clean up here */
                LineDotChart.prototype.destroy = function () {
                    this.root = null;
                };
                LineDotChart.prototype.setIsStopped = function (isstopped) {
                    var objects = {
                        merge: [
                            {
                                objectName: "misc",
                                selector: undefined,
                                properties: {
                                    "isstopped": isstopped,
                                }
                            }
                        ]
                    };
                    this.hostServices.persistProperties(objects);
                    this.hostServices.onSelect({ data: [] });
                };
                LineDotChart.prototype.enumerateObjectInstances = function (options) {
                    var instances = [];
                    if (!this.model || !this.model.settings) {
                        return instances;
                    }
                    var settings = this.model.settings;
                    switch (options.objectName) {
                        case "lineoptions":
                            var lineoptions = {
                                objectName: "lineoptions",
                                displayName: "lineoptions",
                                selector: null,
                                properties: {
                                    fill: settings.lineFill,
                                    lineThickness: settings.lineThickness
                                }
                            };
                            instances.push(lineoptions);
                            break;
                        case "dotoptions":
                            var dotoptions = {
                                objectName: "dotoptions",
                                displayName: "dotoptions",
                                selector: null,
                                properties: {
                                    color: settings.dotFill,
                                    dotSizeMin: settings.dotSizeMin,
                                    dotSizeMax: settings.dotSizeMax
                                }
                            };
                            instances.push(dotoptions);
                            break;
                        case "counteroptions":
                            var counteroptions = {
                                objectName: "counteroptions",
                                displayName: "counteroptions",
                                selector: null,
                                properties: {
                                    counterTitle: settings.counterTitle
                                }
                            };
                            instances.push(counteroptions);
                            break;
                        // case "labels":
                        //     var labels: VisualObjectInstance = {
                        //         objectName: "labels",
                        //         displayName: "labels",
                        //         selector: null,
                        //         properties: {
                        //             labelPrecision: settings.precision
                        //         }
                        //     };
                        //     instances.push(labels);
                        //     break;
                        case "misc":
                            var misc = {
                                objectName: "misc",
                                displayName: "misc",
                                selector: null,
                                properties: {
                                    isanimated: settings.isanimated,
                                    isstopped: settings.isstopped,
                                    duration: settings.duration
                                }
                            };
                            instances.push(misc);
                            break;
                    }
                    return instances;
                };
                LineDotChart.prototype.selectDot = function (dotelement, selector) {
                    var dot = d3.select(dotelement);
                    if (!dot.classed('point_selected')) {
                        if (selector) {
                            this.selectionManager.select(selector);
                        }
                        this.root.classed("filtered", true);
                        this.line.selectAll('circle.point')
                            .classed('point_selected', false);
                        d3.select(dotelement)
                            .classed('point_selected', true);
                    }
                    else {
                        this.clearSelection();
                    }
                    d3.event.stopPropagation();
                };
                LineDotChart.prototype.clearSelection = function () {
                    this.root.classed("filtered", false);
                    this.root.selectAll("circle.point").classed("point_selected", false);
                    this.selectionManager.clear();
                };
                // Convert a DataView into a view model
                LineDotChart.prototype.converter = function (dataView, viewport) {
                    if (!dataView.categorical ||
                        !dataView.categorical.categories ||
                        !dataView.categorical.categories[0] ||
                        !dataView.categorical.categories[0].values ||
                        !(dataView.categorical.categories[0].values.length > 0) ||
                        !dataView.categorical ||
                        !dataView.categorical.values ||
                        !dataView.categorical.values[0] ||
                        !dataView.categorical.values[0].values ||
                        !(dataView.categorical.values[0].values.length > 0)) {
                        return null;
                    }
                    var values = [];
                    var metadataColumn;
                    var extent;
                    var min;
                    var max;
                    var that = this;
                    var categoryType = visuals.AxisHelper.getCategoryValueType(dataView.categorical.categories[0].source, true);
                    this.isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                    var isScalar = true;
                    var settings = this.parseSettings(dataView);
                    var effectiveWidth = Math.max(0, viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize);
                    var effectiveHeight = Math.max(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize);
                    var format = "";
                    var formatter;
                    // X for categories
                    values = dataView.categorical.categories[0].values;
                    metadataColumn = dataView.categorical.categories[0].source;
                    extent = d3.extent(values);
                    if (this.isDateTime) {
                        min = extent[0].getTime();
                        max = extent[1].getTime();
                        min = new Date(min);
                        max = new Date(max + (max - min) * .05);
                        // var xDomain: number[] = isScalar ? [min, max] : [min.getTime(), max.getTime()]
                        // var format: string = "MMM dd yyyy HH:mm";
                        format = "MMM dd yyyy";
                        formatter = visuals.valueFormatter.create({ format: format });
                    }
                    else {
                        min = extent[0];
                        max = extent[1];
                        max = max + (max - min) * .05;
                        formatter = visuals.valueFormatter.create({ value: 0 });
                    }
                    var xAxis = visuals.AxisHelper.createAxis({
                        pixelSpan: effectiveWidth,
                        dataDomain: [min, max],
                        metaDataColumn: metadataColumn,
                        formatString: null,
                        //formatString: LineDotChart.Properties.general.formatString,
                        outerPadding: 0,
                        isCategoryAxis: true,
                        isScalar: isScalar,
                        isVertical: false,
                        forcedTickCount: undefined,
                        useTickIntervalForDisplayUnits: true,
                        // axisPrecision: settings.precision,
                        getValueFn: function (index, type) {
                            if (that.isDateTime) {
                                return formatter.format(new Date(index));
                            }
                            else {
                                return index;
                            }
                        }
                    });
                    xAxis.formatter = formatter;
                    metadataColumn = dataView.categorical.values[0].source;
                    values = dataView.categorical.values[0].values;
                    extent = d3.extent(values);
                    min = extent[0];
                    max = extent[1];
                    var result = [];
                    var value_sum = 0;
                    var value = 0;
                    var time = 0;
                    var selector;
                    for (var i = 0; i < dataView.categorical.categories[0].values.length; i++) {
                        value = dataView.categorical.values[0].values[i];
                        time = dataView.categorical.categories[0].values[i];
                        value_sum += value;
                        selector = visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[i]);
                        result.push({
                            dot: (value - min) / (max - min),
                            value: value,
                            sum: value_sum,
                            time: time,
                            selector: selector
                        });
                    }
                    // make some space for counter + 25%
                    value_sum = value_sum + (value_sum - min) * 0.10;
                    var yAxis = visuals.AxisHelper.createAxis({
                        pixelSpan: effectiveHeight,
                        dataDomain: [min, value_sum],
                        metaDataColumn: metadataColumn,
                        formatString: null,
                        outerPadding: 0,
                        isCategoryAxis: false,
                        isScalar: true,
                        isVertical: true,
                        useTickIntervalForDisplayUnits: true
                    });
                    var yAxis2 = visuals.AxisHelper.createAxis({
                        pixelSpan: effectiveHeight,
                        dataDomain: [min, value_sum],
                        metaDataColumn: metadataColumn,
                        formatString: null,
                        outerPadding: 0,
                        isCategoryAxis: false,
                        isScalar: true,
                        isVertical: true,
                        useTickIntervalForDisplayUnits: true
                    });
                    yAxis2.axis.orient('right');
                    // Show gridlines on the chart to make the values more readable.
                    // TODO: Make this a configuration setting that can be toggled.
                    // xAxis.axis = xAxis.axis.tickSize(-effectiveHeight);
                    // yAxis.axis = yAxis.axis.tickSize(-effectiveWidth);
                    return {
                        points: result,
                        settings: settings,
                        xAxis: xAxis,
                        yAxis: yAxis,
                        yAxis2: yAxis2,
                        legends: this.generateAxisLabels(viewport, settings)
                    };
                };
                LineDotChart.prototype.parseSettings = function (dataView) {
                    if (!dataView ||
                        !dataView.metadata ||
                        !dataView.metadata.columns ||
                        !dataView.metadata.columns[0]) {
                        return null;
                    }
                    var objects = dataView.metadata.objects;
                    var lineFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.lineoptions.fill, LineDotChart.DefaultSettings.lineFill);
                    var dotFillColorHelper = new visuals.ColorHelper(this.colors, LineDotChart.Properties.dotoptions.color, LineDotChart.DefaultSettings.dotFill);
                    var xAxisTitle = LineDotChart.DefaultSettings.xAxisTitle;
                    var yAxisTitle = LineDotChart.DefaultSettings.yAxisTitle;
                    if (dataView.categorical.categories[0] &&
                        dataView.categorical.categories[0].source &&
                        dataView.categorical.categories[0].source.displayName &&
                        dataView.categorical.values[0] &&
                        dataView.categorical.values[0].source &&
                        dataView.categorical.values[0].source.displayName) {
                        xAxisTitle = dataView.categorical.categories[0].source.displayName;
                        yAxisTitle = dataView.categorical.values[0].source.displayName;
                    }
                    var lineThickness = LineDotChart.DefaultSettings.lineThickness;
                    var dotSizeMin = LineDotChart.DefaultSettings.dotSizeMin;
                    var dotSizeMax = LineDotChart.DefaultSettings.dotSizeMax;
                    var counterTitle = LineDotChart.DefaultSettings.counterTitle;
                    var isanimated = LineDotChart.DefaultSettings.isanimated;
                    var isstopped = LineDotChart.DefaultSettings.isstopped;
                    var duration = LineDotChart.DefaultSettings.duration;
                    if (objects) {
                        lineThickness = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.lineoptions.lineThickness, LineDotChart.DefaultSettings.lineThickness);
                        dotSizeMin = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMin, LineDotChart.DefaultSettings.dotSizeMin);
                        dotSizeMax = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.dotoptions.dotSizeMax, LineDotChart.DefaultSettings.dotSizeMax);
                        counterTitle = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.counteroptions.counterTitle, LineDotChart.DefaultSettings.counterTitle);
                        isanimated = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isanimated, LineDotChart.DefaultSettings.isanimated);
                        isstopped = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.isstopped, LineDotChart.DefaultSettings.isstopped);
                        duration = powerbi.DataViewObjects.getValue(objects, LineDotChart.Properties.misc.duration, LineDotChart.DefaultSettings.duration);
                    }
                    return {
                        // precision: LineDotChart.getPrecision(objects),
                        xAxisTitle: xAxisTitle,
                        yAxisTitle: yAxisTitle,
                        lineFill: lineFillColorHelper.getColorForMeasure(objects, ''),
                        lineThickness: lineThickness,
                        dotFill: dotFillColorHelper.getColorForMeasure(objects, ''),
                        dotSizeMin: dotSizeMin,
                        dotSizeMax: dotSizeMax,
                        counterTitle: counterTitle,
                        isstopped: isstopped,
                        isanimated: isanimated,
                        duration: duration
                    };
                };
                // private static getPrecision(objects: DataViewObjects): number {
                //     if (!objects) {
                //         return LineDotChart.DefaultSettings.precision;
                //     }
                //     var precision: number = DataViewObjects.getValue(
                //         objects,
                //         LineDotChart.Properties.labels.labelPrecision,
                //         LineDotChart.DefaultSettings.precision);
                //     if (precision < LineDotChart.MinPrecision) {
                //         return LineDotChart.MinPrecision;
                //     }
                //     return precision;
                // }
                LineDotChart.prototype.generateAxisLabels = function (viewport, settings) {
                    return [
                        {
                            transform: visuals.SVGUtil.translate((viewport.width - this.margin.left - this.margin.right) / 2, (viewport.height - this.margin.top - this.margin.bottom)),
                            text: settings.xAxisTitle,
                            dx: "1em",
                            dy: "-1em"
                        }, {
                            transform: visuals.SVGUtil.translateAndRotate(0, (viewport.height - this.margin.top - this.margin.bottom) / 2, 0, 0, 270),
                            text: settings.yAxisTitle,
                            dx: "3em"
                        }
                    ];
                };
                LineDotChart.prototype.resize = function (viewport) {
                    this.root.attr({
                        'height': Math.max(0, viewport.height),
                        'width': Math.max(0, viewport.width)
                    });
                    this.main.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.legends.attr('transform', visuals.SVGUtil.translate(this.margin.left, this.margin.top));
                    this.line.attr('transform', visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0));
                    this.axes.attr('transform', visuals.SVGUtil.translate(this.margin.left + this.LegendSize, 0));
                    this.axisX.attr('transform', visuals.SVGUtil.translate(0, viewport.height - this.margin.top - this.margin.bottom - this.LegendSize));
                    this.axisY2.attr('transform', visuals.SVGUtil.translate(viewport.width - this.margin.left - this.margin.right - this.LegendSize - this.AxisSize, 0));
                };
                LineDotChart.prototype.draw = function (model) {
                    var _this = this;
                    var that = this;
                    // Clear canvas
                    this.line.selectAll('*').remove();
                    this.legends.selectAll('*').remove();
                    this.axisX.selectAll('*').remove();
                    this.axisY.selectAll('*').remove();
                    this.axisY2.selectAll('*').remove();
                    if (!model) {
                        return;
                    }
                    this.renderLegends(model);
                    if (model && model.points && model.points.length) {
                        this.axisX.call(model.xAxis.axis);
                        this.axisY.call(model.yAxis.axis);
                        this.axisY2.call(model.yAxis2.axis);
                        if (model.settings.isanimated) {
                            var playBtn = this.line
                                .append("g")
                                .classed("lineDotChart__playBtn", true)
                                .attr("transform", "translate(40, 20)");
                            playBtn
                                .append("circle")
                                .attr("r", 34 / 2);
                            // play / reset buttin
                            if (model.settings.isstopped) {
                                playBtn
                                    .append("path")
                                    .attr("d", "M0 2l10 6-10 6z")
                                    .attr("transform", "translate(-4,-8)");
                                playBtn
                                    .on('click.lineDotChart__playBt', function () {
                                    that.setIsStopped(false);
                                });
                                return;
                            }
                            else {
                                playBtn
                                    .append("path")
                                    .attr("d", "M0 2l10 6-10 6z")
                                    .attr("transform-origin", "center")
                                    .attr("transform", "translate(6, 8) rotate(180)");
                                playBtn
                                    .append("rect")
                                    .attr("width", "2")
                                    .attr("height", "12")
                                    .attr("transform", "translate(-7,-6)");
                                playBtn
                                    .on('click.lineDotChart__playBt', function () {
                                    that.setIsStopped(true);
                                });
                            }
                        }
                        var clip = this.line
                            .append("clipPath")
                            .attr("id", "lineClip")
                            .append("rect")
                            .attr("x", 0)
                            .attr("y", 0)
                            .attr("width", 1)
                            .attr("height", 10000);
                        // Draw the line
                        var line = d3.svg.line()
                            .x(function (d) { return model.xAxis.scale(d.time); })
                            .y(function (d) { return model.yAxis.scale(d.sum); });
                        // .interpolate("basis");
                        var lineSelection = this.line.selectAll('path.plot')
                            .data([model.points]);
                        lineSelection.enter().append('path');
                        lineSelection
                            .classed('plot', true)
                            .attr('stroke', function (d, i) { return model.settings.lineFill; })
                            .attr('stroke-width', model.settings.lineThickness)
                            .attr('d', line);
                        var totalLength = lineSelection.node().getTotalLength();
                        var line_left = lineSelection.node().getPointAtLength(0).x;
                        var line_right = lineSelection.node().getPointAtLength(totalLength).x;
                        lineSelection
                            .attr("clip-path", "url(" + location.href + "#lineClip)");
                        if (!model.settings.isanimated) {
                            clip
                                .interrupt()
                                .attr('x', line_left)
                                .attr('width', line_right - line_left);
                        }
                        else {
                            clip
                                .attr('x', line_left)
                                .interrupt()
                                .transition()
                                .ease("linear")
                                .duration(model.settings.duration * 1000)
                                .attr('width', line_right - line_left);
                        }
                        lineSelection
                            .exit().remove();
                        var point_time = 300;
                        var counter_time = 0; // point_time / 100;
                        // Draw the individual data points that will be shown on hover with a tooltip
                        var lineTipSelection = this.line.selectAll('circle.point')
                            .data(model.points);
                        var that = this;
                        lineTipSelection.enter()
                            .append('circle')
                            .attr('fill', model.settings.dotFill)
                            .attr('opacity', .77)
                            .attr('r', function (d) { return model.settings.dotSizeMin + d.dot * (model.settings.dotSizeMax - model.settings.dotSizeMin); })
                            .classed('point', true)
                            .on('mouseover.point', this.showDataPoint)
                            .on('mouseout.point', this.hideDataPoint)
                            .on("click.point", function (d) {
                            that.selectDot(this, d.selector);
                        });
                        if (!model.settings.isanimated) {
                            lineTipSelection
                                .interrupt()
                                .attr('transform', function (d) {
                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)';
                            });
                        }
                        else {
                            lineTipSelection
                                .interrupt()
                                .attr('transform', function (d) {
                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(0.005)';
                            })
                                .transition()
                                .duration(point_time)
                                .delay(function (d, i) { return _this.pointDelay(model.points, i, model.settings.duration); })
                                .ease("linear")
                                .attr('transform', function (d) {
                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(3.4)';
                            })
                                .transition()
                                .duration(point_time)
                                .delay(function (d, i) { return _this.pointDelay(model.points, i, model.settings.duration) + point_time; })
                                .ease("elastic")
                                .attr('transform', function (d) {
                                return 'translate(' + model.xAxis.scale(d.time) + ' ' + model.yAxis.scale(d.sum) + ') scale(1)';
                            });
                        }
                        lineTipSelection.exit().remove();
                        for (var i = 0; i < lineTipSelection[0].length; i++) {
                            this.addTooltip(model, lineTipSelection[0][i]);
                        }
                        // Feature Counter text 
                        var lineTextSelection = this.line.selectAll('text')
                            .data(model.points);
                        lineTextSelection.enter()
                            .append("text")
                            .classed('text', true)
                            .text(function (d, i) {
                            // if (model.points[i + 1]) {
                            return model.settings.counterTitle + ' ' + (i + 1);
                            // } else {
                            //     // TODO: CRAZY hard code
                            //     return model.settings.counterTitle + ' 265'
                            // }
                        })
                            .attr('x', line_right - 260)
                            .attr('y', 30);
                        if (!model.settings.isanimated) {
                            // opacity 1 only for last
                            lineTextSelection
                                .interrupt()
                                .attr('transform', 'translate(0 0)')
                                .attr('opacity', function (d, i) { return Number(i === model.points.length - 1); });
                        }
                        else {
                            lineTextSelection
                                .attr('opacity', 0)
                                .interrupt()
                                .transition()
                                .duration(counter_time)
                                .delay(function (d, i) { return _this.pointDelay(model.points, i, model.settings.duration); })
                                .attr('transform', 'translate(0 0)')
                                .attr('opacity', 1)
                                .transition()
                                .duration(counter_time)
                                .delay(function (d, i) {
                                if (model.points[i + 1]) {
                                    return _this.pointDelay(model.points, i + 1, model.settings.duration);
                                }
                                else {
                                    return Number.POSITIVE_INFINITY;
                                }
                            })
                                .attr('opacity', 0);
                        }
                        lineTextSelection.exit().remove();
                    }
                };
                LineDotChart.prototype.pointDelay = function (points, num, animation_duration) {
                    if (!points.length || !points[num] || num === 0) {
                        return 0;
                    }
                    if (this.isDateTime) {
                        var time = points[num].time;
                        var min = points[0].time.getTime();
                        var max = points[points.length - 1].time.getTime();
                        var val = time.getTime();
                    }
                    else {
                        var time = points[num].time;
                        var min = points[0].time;
                        var max = points[points.length - 1].time;
                        var val = time;
                    }
                    return animation_duration * 1000 * (val - min) / (max - min);
                };
                LineDotChart.prototype.showDataPoint = function (data, index) {
                    d3.select(this).classed('show', true);
                };
                LineDotChart.prototype.hideDataPoint = function (data, index) {
                    d3.select(this).classed('show', false);
                };
                LineDotChart.prototype.addTooltip = function (model, element) {
                    var selection = d3.select(element);
                    var data = selection.datum();
                    visuals.TooltipManager.addTooltip(selection, function (event) {
                        return [
                            {
                                displayName: model.settings.xAxisTitle,
                                value: model.xAxis.formatter.format(data.time)
                            },
                            {
                                displayName: model.settings.yAxisTitle,
                                value: data.value.toString()
                            }
                        ];
                    });
                };
                LineDotChart.prototype.renderLegends = function (model) {
                    var legendSelection = this.legends
                        .selectAll(LineDotChart.Legend.selector)
                        .data(model.legends);
                    legendSelection
                        .enter()
                        .append("svg:text");
                    legendSelection
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("dx", function (item) { return item.dx; })
                        .attr("dy", function (item) { return item.dy; })
                        .attr("transform", function (item) { return item.transform; })
                        .text(function (item) { return item.text; })
                        .classed(LineDotChart.Legend.class, true);
                    legendSelection
                        .exit()
                        .remove();
                };
                LineDotChart.DefaultSettings = {
                    lineFill: 'rgb(102, 212, 204)',
                    lineThickness: 3,
                    dotFill: '#005c55',
                    dotSizeMin: 4,
                    dotSizeMax: 38,
                    counterTitle: 'Total features',
                    // precision: 2,
                    xAxisTitle: '',
                    yAxisTitle: '',
                    duration: 20,
                    isanimated: true,
                    isstopped: true
                };
                /**
                * Informs the System what it can do
                * Fields, Formatting options, data reduction & QnA hints
                */
                LineDotChart.capabilities = {
                    dataRoles: [
                        {
                            name: "Date",
                            kind: powerbi.VisualDataRoleKind.Grouping,
                            displayName: 'Date'
                        },
                        {
                            name: "Values",
                            kind: powerbi.VisualDataRoleKind.Measure,
                            displayName: 'Values'
                        },
                    ],
                    dataViewMappings: [{
                            conditions: [{
                                    "Date": {
                                        min: 0,
                                        max: 1
                                    },
                                    "Values": {
                                        min: 0,
                                        max: 1
                                    },
                                    "Labels": {
                                        min: 0,
                                        max: 1
                                    }
                                }],
                            categorical: {
                                categories: {
                                    for: { in: "Date" },
                                    dataReductionAlgorithm: { sample: {} }
                                },
                                values: {
                                    for: { in: "Values" }
                                },
                            }
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter("Visual_General"),
                            properties: {
                                formatString: {
                                    type: {
                                        formatting: {
                                            formatString: true
                                        }
                                    },
                                }
                            },
                        },
                        lineoptions: {
                            displayName: 'Line',
                            properties: {
                                fill: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                lineThickness: {
                                    displayName: 'Thickness',
                                    type: { numeric: true }
                                }
                            }
                        },
                        dotoptions: {
                            displayName: 'Dot',
                            properties: {
                                color: {
                                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                    type: { fill: { solid: { color: true } } }
                                },
                                dotSizeMin: {
                                    displayName: 'Min size',
                                    type: { numeric: true }
                                },
                                dotSizeMax: {
                                    displayName: 'Min size',
                                    type: { numeric: true }
                                }
                            }
                        },
                        counteroptions: {
                            displayName: 'Counter',
                            properties: {
                                counterTitle: {
                                    displayName: 'Title',
                                    type: { text: true }
                                }
                            }
                        },
                        misc: {
                            displayName: 'Animation',
                            properties: {
                                isanimated: {
                                    displayName: 'Animated',
                                    type: { bool: true }
                                },
                                isstopped: {
                                    displayName: 'Stop on load',
                                    type: { bool: true }
                                },
                                duration: {
                                    displayName: 'Time',
                                    type: { numeric: true }
                                }
                            }
                        }
                    }
                };
                LineDotChart.Identity = {
                    "class": "lineDotChart",
                    selector: ".lineDotChart"
                };
                LineDotChart.Axes = {
                    "class": "axes",
                    selector: ".axes"
                };
                LineDotChart.Axis = {
                    "class": "axis",
                    selector: ".axis"
                };
                LineDotChart.Legends = {
                    "class": "legends",
                    selector: ".legends"
                };
                LineDotChart.Legend = {
                    "class": "legend",
                    selector: ".legend"
                };
                LineDotChart.Values = {
                    "class": "line",
                    selector: ".line"
                };
                LineDotChart.Properties = {
                    general: {
                        formatString: {
                            objectName: "general",
                            propertyName: "formatString"
                        }
                    },
                    lineoptions: {
                        fill: {
                            objectName: "lineoptions",
                            propertyName: "fill"
                        },
                        lineThickness: {
                            objectName: "lineoptions",
                            propertyName: "lineThickness"
                        }
                    },
                    dotoptions: {
                        color: {
                            objectName: "dotoptions",
                            propertyName: "color"
                        },
                        dotSizeMin: {
                            objectName: "dotoptions",
                            propertyName: "dotSizeMin"
                        },
                        dotSizeMax: {
                            objectName: "dotoptions",
                            propertyName: "dotSizeMax"
                        }
                    },
                    counteroptions: {
                        counterTitle: {
                            objectName: "counteroptions",
                            propertyName: "counterTitle"
                        }
                    },
                    // labels: {
                    //     labelPrecision: <DataViewObjectPropertyIdentifier>{
                    //         objectName: "labels",
                    //         propertyName: "labelPrecision"
                    //     }
                    // },
                    misc: {
                        isanimated: {
                            objectName: "misc",
                            propertyName: "isanimated"
                        },
                        isstopped: {
                            objectName: "misc",
                            propertyName: "isstopped"
                        },
                        duration: {
                            objectName: "misc",
                            propertyName: "duration"
                        }
                    }
                };
                return LineDotChart;
            }());
            samples.LineDotChart = LineDotChart;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var plugins;
        (function (plugins) {
            plugins.sunburstCustom = {
                name: 'sunburstCustom',
                watermarkKey: 'defaultWatermark',
                capabilities: visuals.samples.Sunburst.capabilities,
                create: function () { return new visuals.samples.Sunburst(); }
            };
            plugins.asterPlot = {
                name: 'asterPlot',
                capabilities: visuals.samples.AsterPlot.capabilities,
                create: function () { return new visuals.samples.AsterPlot(); }
            };
            plugins.tornadoChart = {
                name: "tornadoChart",
                capabilities: visuals.samples.TornadoChart.capabilities,
                create: function () { return new visuals.samples.TornadoChart(); }
            };
            plugins.sankeyDiagram = {
                name: "sankeyDiagram",
                capabilities: visuals.samples.SankeyDiagram.capabilities,
                create: function () { return new visuals.samples.SankeyDiagram(); }
            };
            plugins.mekkoChart = {
                name: 'mekkoChart',
                watermarkKey: 'mekko',
                capabilities: visuals.samples.MekkoChart.capabilities,
                create: function () { return new visuals.samples.MekkoChart({ chartType: 0 /* HundredPercentStackedColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
            };
            plugins.bulletChart = {
                name: "bulletChart",
                capabilities: visuals.samples.BulletChart.capabilities,
                create: function () { return new visuals.samples.BulletChart(); }
            };
            plugins.wordCloud = {
                name: "wordCloud",
                capabilities: visuals.samples.WordCloud.capabilities,
                create: function () { return new visuals.samples.WordCloud(); }
            };
            plugins.chicletSlicer = {
                name: 'chicletSlicer',
                capabilities: visuals.samples.ChicletSlicer.capabilities,
                create: function () { return new visuals.samples.ChicletSlicer(); }
            };
            plugins.chordChart = {
                name: "chordChart",
                capabilities: visuals.samples.ChordChart.capabilities,
                create: function () { return new visuals.samples.ChordChart(); }
            };
            plugins.enhancedScatterChart = {
                name: 'enhancedScatterChart',
                capabilities: visuals.samples.EnhancedScatterChart.capabilities,
                create: function () { return new visuals.samples.EnhancedScatterChart(); }
            };
            plugins.radarChart = {
                name: 'radarChart',
                capabilities: visuals.samples.RadarChart.capabilities,
                create: function () { return new visuals.samples.RadarChart(); }
            };
            plugins.dotPlot = {
                name: 'dotPlot',
                capabilities: visuals.samples.DotPlot.capabilities,
                create: function () { return new visuals.samples.DotPlot(); }
            };
            plugins.histogram = {
                name: "histogram",
                capabilities: visuals.samples.Histogram.capabilities,
                create: function () { return new visuals.samples.Histogram(); }
            };
            plugins.timeline = {
                name: 'timeline',
                capabilities: visuals.samples.Timeline.capabilities,
                create: function () { return new visuals.samples.Timeline(); }
            };
            plugins.forceGraph = {
                name: "forceGraph",
                capabilities: visuals.samples.ForceGraph.capabilities,
                create: function () { return new visuals.samples.ForceGraph(); }
            };
            plugins.gantt = {
                name: "gantt",
                capabilities: visuals.samples.Gantt.capabilities,
                create: function () { return new visuals.samples.Gantt(); }
            };
            plugins.streamGraph = {
                name: "streamGraph",
                capabilities: visuals.samples.StreamGraph.capabilities,
                create: function () { return new visuals.samples.StreamGraph(); }
            };
            plugins.lineDotChart = {
                name: "lineDotChart",
                capabilities: visuals.samples.LineDotChart.capabilities,
                create: function () { return new visuals.samples.LineDotChart(); }
            };
        })(plugins = visuals.plugins || (visuals.plugins = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualPluginFactory;
        (function (visualPluginFactory) {
            var CustomVisualPluginService = (function (_super) {
                __extends(CustomVisualPluginService, _super);
                function CustomVisualPluginService() {
                    _super.call(this, {});
                    this.initCustomVisualPlugins();
                }
                CustomVisualPluginService.prototype.getVisuals = function () {
                    var registry = this.customVisualPlugins, names = Object.keys(registry);
                    return names.map(function (name) { return registry[name]; });
                };
                CustomVisualPluginService.prototype.getPlugin = function (type) {
                    if (!type) {
                        return null;
                    }
                    var plugin = this.customVisualPlugins[type];
                    if (!plugin) {
                        return null;
                    }
                    return plugin;
                };
                CustomVisualPluginService.prototype.capabilities = function (type) {
                    var plugin = this.getPlugin(type);
                    if (plugin) {
                        return plugin.capabilities;
                    }
                    return {};
                };
                CustomVisualPluginService.prototype.initCustomVisualPlugins = function () {
                    // Aster Plot
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.asterPlot, function () { return new visuals.samples.AsterPlot(); });
                    // Tornado Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.tornadoChart, function () { return new visuals.samples.TornadoChart({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // Sankey Diagram
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.sankeyDiagram, function () { return new visuals.samples.SankeyDiagram(); });
                    // Mekko Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.mekkoChart, function () { return new visuals.samples.MekkoChart({
                        chartType: 0 /* HundredPercentStackedColumn */,
                        isScrollable: true,
                        animator: new visuals.WebColumnChartAnimator(),
                        behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()])
                    }); });
                    // Bullet Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.bulletChart, function () { return new visuals.samples.BulletChart(); });
                    // Word Cloud
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.wordCloud, function () { return new visuals.samples.WordCloud({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // Chiclet Slicer
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.chicletSlicer, function () { return new visuals.samples.ChicletSlicer({
                        behavior: new visuals.samples.ChicletSlicerWebBehavior()
                    }); });
                    // Enhanced Scatter Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.enhancedScatterChart, function () { return new visuals.samples.EnhancedScatterChart(); });
                    // Radar Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.radarChart, function () { return new visuals.samples.RadarChart({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // DotPlot
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.dotPlot, function () { return new visuals.samples.DotPlot({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // Histogram
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.histogram, function () { return new visuals.samples.Histogram({
                        animator: new visuals.BaseAnimator()
                    }); });
                    // Force Graph
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.forceGraph, function () { return new visuals.samples.ForceGraph(); });
                    // Gantt Chart
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.gantt, function () { return new visuals.samples.Gantt(); });
                    // Stream Graph
                    visualPluginFactory.createPlugin(this.customVisualPlugins, powerbi.visuals.plugins.streamGraph, function () { return new visuals.samples.StreamGraph(); });
                };
                return CustomVisualPluginService;
            }(visualPluginFactory.VisualPluginService));
            visualPluginFactory.CustomVisualPluginService = CustomVisualPluginService;
            function createCustomVisualPluginService() {
                return new CustomVisualPluginService();
            }
            visualPluginFactory.createCustomVisualPluginService = createCustomVisualPluginService;
        })(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));

//# sourceMappingURL=CustomVisuals.js.map
