{"version":3,"sources":["VisualsData.js","../ts/visualsData/semanticQuery/sqExprVisitor.ts","../ts/visualsData/types/enumType.ts","../ts/visualsData/types/fill.ts","../ts/visualsData/types/image.ts","../ts/visualsData/types/structuralType.ts","../ts/visualsData/types/valueType.ts","../ts/visualsData/contracts/dataShapeBinding.ts","../ts/visualsData/contracts/dataShapeBindingDataReduction.ts","../ts/visualsData/contracts/federatedConceptualSchema.ts","../ts/visualsData/contracts/selector.ts","../ts/visualsData/contracts/query.ts","../ts/visualsData/contracts/queryProjection.ts","../ts/visualsData/contracts/visualData.ts","../ts/visualsData/formatting/dateTimeSequence.ts","../ts/visualsData/formatting/displayUnitSystem.ts","../ts/visualsData/formatting/numericSequence.ts","../ts/visualsData/formatting/numericSequenceRange.ts","../ts/visualsData/formatting/valueFormatter.ts","../ts/visualsData/dataView/dataRoleHelper.ts","../ts/visualsData/dataView/dataViewCategoricalReader.ts","../ts/visualsData/dataView/dataViewConcatenateCategoricalColumns.ts","../ts/visualsData/dataView/dataViewMappingVisitor.ts","../ts/visualsData/dataView/dataViewNormalizeValues.ts","../ts/visualsData/dataView/dataViewObject.ts","../ts/visualsData/dataView/dataViewObjectDefinition.ts","../ts/visualsData/dataView/dataViewObjectDescriptor.ts","../ts/visualsData/dataView/dataViewObjectEvaluationUtils.ts","../ts/visualsData/dataView/dataViewObjectEvaluator.ts","../ts/visualsData/dataView/dataViewPivotCategorical.ts","../ts/visualsData/dataView/dataViewPivotMatrix.ts","../ts/visualsData/dataView/dataViewSelfCrossJoin.ts","../ts/visualsData/dataView/dataViewPivotCategoricalToPrimaryGroups.ts","../ts/visualsData/dataView/dataViewTransform.ts","../ts/visualsData/displayNameGetter.ts","../ts/visualsData/iFormattingService.ts","../ts/visualsData/semanticQuery/exprPatterns/fieldExprPattern.ts","../ts/visualsData/dataView/dataViewAnalysis.ts","../ts/visualsData/dataView/dataViewRoleWildcard.ts","../ts/visualsData/dataView/dataViewScopeIdentity.ts","../ts/visualsData/dataView/dataViewScopeWildcard.ts","../ts/visualsData/dataView/rules/colorAllocatorCache.ts","../ts/visualsData/dataView/dataViewRegression.ts","../ts/visualsData/dataView/dataViewSelectTransform.ts","../ts/visualsData/dataView/rules/categoricalEvalContext.ts","../ts/visualsData/dataView/rules/tableEvalContext.ts","../ts/visualsData/dataView/rules/ruleEvaluation.ts","../ts/visualsData/dataView/rules/colorRuleEvaluation.ts","../ts/visualsData/dataView/utils/dataViewMatrixUtils.ts","../ts/visualsData/dataView/utils/dataViewMetadataColumnUtils.ts","../ts/visualsData/contracts/conceptualSchema.ts","../ts/visualsData/dataView/scriptResultUtil.ts","../ts/visualsData/segmentation/dataViewMerger.ts","../ts/visualsData/semanticQuery/sqExprRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/equalsToInRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/filterScopeIdsCollector.ts","../ts/visualsData/semanticQuery/exprPatterns/scopeIdentityExtractor.ts","../ts/visualsData/semanticQuery/primitiveValueEncoding.ts","../ts/visualsData/semanticQuery/sqAggregationOperations.ts","../ts/visualsData/semanticQuery/sqHierarchyExprUtils.ts","../ts/visualsData/semanticQuery/sqExprGroupUtils.ts","../ts/visualsData/semanticQuery/sqExpr.ts","../ts/visualsData/semanticQuery/sqExprUtils.ts","../ts/visualsData/semanticQuery/semanticQueryRewriter.ts","../ts/visualsData/semanticQuery/semanticQuery.ts","../ts/visualsData/dataView/dataViewBuilder.ts","../ts/visualsData/dataView/rules/staticEvalContext.ts","../ts/visualsData/dataView/rules/matrixEvalContext.ts","../ts/visualsData/services/formattingService.ts","../ts/visualsData/services/serialization/sqExprShortSerializer.ts","../ts/visualsData/selection/selectionId.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","powerbi","data","DefaultSQExprVisitorWithArg","visitEntity","expr","arg","visitDefault","visitColumnRef","visitMeasureRef","visitAggr","visitPercentile","visitHierarchy","visitHierarchyLevel","visitPropertyVariationSource","visitSelectRef","visitBetween","visitIn","visitAnd","visitOr","visitCompare","visitContains","visitExists","visitNot","visitStartsWith","visitConstant","visitDateSpan","visitDateAdd","visitNow","visitDefaultValue","visitAnyValue","visitArithmetic","visitFillRule","visitResourcePackageItem","visitScopedEval","DefaultSQExprVisitor","_super","apply","arguments","DefaultSQExprVisitorWithTraversal","source","accept","lower","upper","args","i","len","length","values","valueTuple","j","jlen","left","right","input","rule","gradient2","linearGradient2","gradient3","linearGradient3","visitLinearGradient2","visitLinearGradient3","visitFillRuleStop","min","max","mid","expression","_i","_a","scope","scopeExpr","stop","color","value","createEnumType","members","EnumType","allMembers","validMembers","membersToReturn","allMembers_1","member","_","contains","push","FillSolidColorTypeDescriptor","nullable","descriptor","advancedDescriptor","ImageDefinition","urlType","misc","imageUrl","StructuralTypeDescriptor","isValid","type","fill","fillRule","filter","image","paragraphs","getPrimitiveType","extendedType","PrimitiveTypeMask","isPrimitiveType","PrimitiveTypeWithFlagsMask","getCategoryFromExtendedType","category","ExtendedType","delimIdx","lastIndexOf","baseCategory","slice","toExtendedType","primitiveType","primitiveString","PrimitiveType","t","Null","categoryType","categoryPrimitiveType","matchesExtendedTypeWithAnyPrimitive","a","PrimitiveTypeFlagsExcludedMask","EnumExtensions","jsCommon","ValueType","enumType","underlyingType","hasFlag","Temporal","temporalType","TemporalType","Geography","geographyType","GeographyType","Miscellaneous","miscType","MiscellaneousType","Formatting","formattingType","FormattingType","Enumeration","Scripting","scriptingType","ScriptType","fromDescriptor","text","fromExtendedType","Text","integer","Integer","numeric","Double","bool","Boolean","dateTime","DateTime","duration","Duration","binary","Binary","none","None","scripting","ScriptSource","enumeration","fromEnum","temporal","year","Year_Integer","month","Month_Integer","geography","address","Address","city","City","continent","Continent","country","Country","county","County","region","Region","postalCode","PostalCode_Text","stateOrProvince","StateOrProvince","place","Place","latitude","Latitude_Double","longitude","Longitude_Double","Image","ImageUrl","webUrl","WebUrl","barcode","Barcode_Text","formatting","Color","formatString","FormatString","alignment","Alignment","labelDisplayUnits","LabelDisplayUnits","fontSize","FontSize","labelDensity","LabelDensity","fromPrimitiveTypeAndCategory","id","toString","typeCache","isCompatibleTo","otherTypes","valueType","otherTypes_1","otherType","otherValueType","isCompatibleFrom","other","otherPrimitiveType","equals","isEqual","defineProperty","get","enumerable","configurable","Numeric","Date","Time","Year","Month","PostalCode","Latitude","Longitude","Barcode","DataShapeBindingLimitType","SubtotalType","DataShapeBindingDataReduction","createFrom","reduction","result","top","Top","count","Count","bottom","Bottom","sample","Sample","window","Window","FederatedConceptualSchema","options","schemas","links","schema","name","data_1","Selector","filterFromSelector","selectors","isNot","isEmpty","exprs","ilen","identity","data_2","exprToAdd","undefined","SQExprBuilder","and","DataViewScopeIdentity","filterFromExprs","matchesData","selector","identities","selectorData","dataItem","selectorDataItem","DataViewScopeWildcard","matches","matchesKeys","keysList","selectorDataLength","selectorDataExprs","ScopeIdentityExtractor","getKeys","SQExprUtils","sequenceEqual","x","y","metadata","equalsDataArray","equalsData","selector1","selector2","roles","DataViewRoleWildcard","getKey","toStringify","data_3","key","JSON","stringify","containsWildcard","dataItems","dataItems_1","wildCard","hasRoleWildcard","dataItems_2","isRoleWildcard","getArithmeticOperatorName","arithmeticOperatorKind","Error","EntitySourceType","TimeUnit","QueryAggregateFunction","QueryComparisonKind","SemanticType","FilterKind","QueryProjectionCollection","items","activeProjectionRefs","showAll","_activeProjectionRefs","_showAll","all","set","queryReferences","queryRefs","map","val","queryRef","queryReferences_1","queryReference","addActiveQueryReference","getLastActiveQueryReference","replaceQueryRef","oldQueryRef","newQueryRef","item","clone","cloneDeep","QueryProjectionsByRole","clonedRoles","roleName","getRole","DisplayUnitSystemType","DateTimeSequence","unit","sequence","add","date","extendToCover","addInterval","interval","splice","moveToCover","delta","getDelta","Math","floor","calculate","dataMin","dataMax","expectedCount","getIntervalUnit","DateTimeUnit","calculateYears","calculateMonths","Week","calculateWeeks","Day","calculateDays","Hour","calculateHours","Minute","calculateMinutes","Second","calculateSeconds","Millisecond","calculateMilliseconds","yearsRange","NumericSequenceRange","calculateDataRange","getFullYear","NumericSequence","newMinYear","fromNumericSequence","minYear","maxYear","minMonth","getMonth","maxMonth","calculateUnits","firstDayOfWeek","minDayOfWeek","getDay","dayOffset","minDay","getDate","ceilWithPrecision","floorWithPrecision","getHours","getMinutes","getSeconds","round","DateUtils","addYears","addMonths","addWeeks","addDays","addHours","addMinutes","addSeconds","addMilliseconds","intervalOffset","getTime","maxCount","totalDays","totalHours","totalMinutes","totalSeconds","totalMilliseconds","getMilliseconds","MIN_COUNT","MAX_COUNT","isLeap","getMonthDays","MonthDaysLeap","MonthDays","yearDelta","day","isLeapDay","setFullYear","monthDelta","weeks","days","hours","minutes","seconds","milliseconds","createDisplayUnits","unitLookup","adjustMinBasedOnPreviousUnit","units","maxExponent","names","addUnitIfNonEmpty","pow10","title","format","labelFormat","previousUnit","applicableRangeMax","DisplayUnit","applicableRangeMin","defaultScientificBigNumbersBoundary","scientificSmallNumbersBoundary","PERCENTAGE_FORMAT","SCIENTIFIC_FORMAT","DEFAULT_SCIENTIFIC_FORMAT","SUPPORTED_SCIENTIFIC_FORMATS","project","removeDecimalNoise","reverseProject","isApplicableTo","abs","precision","getPrecision","greaterOrEqualWithPrecision","lessWithPrecision","isScaling","DisplayUnitSystem","displayUnit","update","unitBaseValue","findApplicableDisplayUnit","decimals","trailingZeros","isFormatSupported","getNumberOfDecimalsForFormatting","hasScientitifcFormat","formatHelper","isScalingUnit","shouldRespectScalingUnit","formattingService","formatValue","UNSUPPORTED_FORMATS","test","isPercentageFormat","indexOf","nonScientificFormat","visuals","valueFormatter","DefaultNumericFormat","NumberFormat","addDecimalsToFormat","isStandardNumberFormat","formatNumberWithCustomOverride","formatSingleValue","shouldUseValuePrecision","isScientific","toUpperCase","supportsScientificFormat","shouldFallbackToScientific","getScientificFormat","numericFormat","getNumericFormat","NoDisplayUnitSystem","call","DefaultDisplayUnitSystem","getUnits","reset","previousUnitValue","Infinity","WholeUnitsDisplayUnitSystem","DataLabelsDisplayUnitSystem","AUTO_DISPLAYUNIT_VALUE","NONE_DISPLAYUNIT_VALUE","concat","range","maxAllowedMargin","minPower","useZeroRefPoint","steps","ensureInRange","MIN_EXP","forcedSingleStop","getSize","canExtendMin","hasFixedMin","canExtendMax","hasFixedMax","size","exp","log10","stepExp","expectedCountExp","power","roundMin","floorToPrecision","roundMax","ceilToPrecision","roundRange","calculateFixedRange","shrinkByStep","dexp","e","stepsCount","stepPower","step","roundToPrecision","trimMinMax","stepCount","maxStepCount","minStepCount","offset","minMargin","maxMargin","marginPrecision","_ensureIncludeZero","includeZero","_ensureNotEmpty","DEFAULT_MAX","_ensureDirection","temp","oldCount","newCount","deltaCount","ceil","fixedMin","fixedMax","hasDataRange","ValueUtil","hasValue","MIN_SUPPORTED_DOUBLE","MAX_SUPPORTED_DOUBLE","beautify","BeautifiedFormat","defaultLocalizedStrings","describeUnit","exponent","exponentLookup","getLocalizedString","stringId","getFormatMetadata","getCustomFormatMetadata","setLocaleOptions","locale","createDefaultFormatter","allowFormatBeautification","formatBeaut","formatCore","shouldUseNumericDisplayUnits","displayUnitSystem_1","createDisplayUnitSystem","displayUnitSystemType","singleValueFormattingMode_1","formatSingleValues","value2","decimals_1","forcePrecision_1","MaxScaledDecimalPlaces","detectAxisPrecision","axisValue","isInteger","formattedValue","getStringFormat","StringExtensions","isNullOrUndefinedOrWhiteSpaceString","MaxValueForDisplayUnitRounding","shouldUseDateUnits","tickCount","unit_1","dateFormatString","getValueFormat","columnType","getFormatString","DateTimeMetadataColumn","formatValueColumn","column","formatStringProp","valueFormat","describe","Default","WholeUnits","Verbose","DataLabels","MinIntegerValueForDisplayUnits","isCustomFormat","isStandardFormat","MinPrecisionForDisplayUnits","formatStringProperty","suppressTypeFallback","propertyValue","DataViewObjects","getValue","objects","DefaultDateFormat","DefaultIntegerFormat","formatListCompound","strings","conjunction","lastIndex","restatementComma","formatListAnd","restatementCompoundAnd","formatListOr","restatementCompoundOr","nullsAreBlank","isNaN","NaN","Number","NEGATIVE_INFINITY","negativeInfinity","POSITIVE_INFINITY","infinity","getDisplayUnits","displayUnitSystem","0.00 %;-0.00 %;0.00 %","0.0 %;-0.0 %;0.0 %","NullValue","BooleanTrue","BooleanFalse","NaNValue","InfinityValue","NegativeInfinityValue","RestatementComma","RestatementCompoundAnd","RestatementCompoundOr","DisplayUnitSystem_EAuto_Title","DisplayUnitSystem_E0_Title","DisplayUnitSystem_E3_LabelFormat","DisplayUnitSystem_E3_Title","DisplayUnitSystem_E6_LabelFormat","DisplayUnitSystem_E6_Title","DisplayUnitSystem_E9_LabelFormat","DisplayUnitSystem_E9_Title","DisplayUnitSystem_E12_LabelFormat","DisplayUnitSystem_E12_Title","Percentage","Percentage1","TableTotalLabel","Tooltip_HighlightedValueDisplayName","Funnel_PercentOfFirst","Funnel_PercentOfPrevious","Funnel_PercentOfFirst_Highlight","Funnel_PercentOfPrevious_Highlight","GeotaggingString_Continent","GeotaggingString_Continents","GeotaggingString_Country","GeotaggingString_Countries","GeotaggingString_State","GeotaggingString_States","GeotaggingString_City","GeotaggingString_Cities","GeotaggingString_Town","GeotaggingString_Towns","GeotaggingString_Province","GeotaggingString_Provinces","GeotaggingString_County","GeotaggingString_Counties","GeotaggingString_Village","GeotaggingString_Villages","GeotaggingString_Post","GeotaggingString_Zip","GeotaggingString_Code","GeotaggingString_Place","GeotaggingString_Places","GeotaggingString_Address","GeotaggingString_Addresses","GeotaggingString_Street","GeotaggingString_Streets","GeotaggingString_Longitude","GeotaggingString_Longitude_Short","GeotaggingString_Latitude","GeotaggingString_Latitude_Short","GeotaggingString_PostalCode","GeotaggingString_PostalCodes","GeotaggingString_ZipCode","GeotaggingString_ZipCodes","GeotaggingString_Territory","GeotaggingString_Territories","null","true","false","displayName","DataRoleHelper","getMeasureIndexOfRole","grouped","firstGroup","hasRole","getCategoryIndexOfRole","categories","hasRoleInDataView","dataView","columns","any","c","hasRoleInValueColumn","valueColumn","createIDataViewCategoricalReader","DataViewCategoricalReader","categorical","hasValidCategories","hasAnyValidValues","valueRoleIndexMapping","firstGroupValues","valueIndex","valueCount","valueRoles","role","dataHasDynamicSeries","hasCategories","getCategoryCount","getCategoryValues","getCategoryFromRole","getCategoryValue","categoryIndex","getCategoryColumn","getCategoryMetadataColumn","getCategoryColumnIdentityFields","identityFields","getCategoryDisplayName","targetColumn","hasCompositeCategories","hasCategoryWithRole","getCategoryObjects","hasValues","seriesIndex","getValueInternal","getHighlight","getAllValuesForRole","valuesInRole","roleValueIndex","roleValueCount","getAllHighlightsForRole","groupIndex","valueColumnIndexInRole","valueColumnIndex","groupedValues","highlights","getFirstNonNullValueForCategory","seriesCount","getMeasureQueryName","queryName","getValueColumn","getValueMetadataColumn","getValueDisplayName","hasDynamicSeries","getSeriesCount","valueRoleName","getSeriesObjects","getSeriesValueColumns","getSeriesValueColumnGroup","getSeriesMetadataColumn","getSeriesColumnIdentityFields","getSeriesName","getSeriesDisplayName","DataViewConcatenateCategoricalColumns","inherit","Prototype","inheritSingle","detectAndApply","objectDescriptors","roleMappings","projectionOrdering","selects","projectionActiveItems","dataViewCategorical","concatenationSource","detectCategoricalRoleForHierarchicalGroup","columnsSortedByProjectionOrdering","sortColumnsByProjectionOrdering","activeItemsToIgnoreInConcatenation","chain","activeItemInfo","suppressConcat","applyConcatenation","applyToPlayChartCategorical","categoryRoleName","transformingColumns_1","transformingMetadata","m","transformingDataView","dataViewMappings","roleKinds","DataViewSelectTransform","createRoleKindFromMetadata","projections","projectionsFromSelects","supportedRoleMappings","DataViewAnalysis","chooseDataViewMappings","supportedMappings","isEveryRoleMappingForCategorical","every","roleMapping","targetRoleName_1","getSingleCategoryRoleNameInEveryRoleMapping","isVisualExpectingMaxOneCategoryColumn","categoryColumnsForTargetRole_1","categoryColumn","areValuesCountsEqual","categoricalRoleMappings","uniqueCategoryRoles","categoryRoles","getAllRolesInCategories","uniq","isSameCategoryRoleNameInAllRoleMappings","isUndefined","categoricalRoleName","conditions","condition","categoricalRoleMapping","roleNames","DataViewMapping","visitCategoricalCategories","visitRole","queryRefsToIgnore","formatStringPropId","DataViewObjectDescriptors","findFormatString","concatenatedValues","concatenateValues","columnsSourceSortedByProjectionOrdering","concatenatedColumnMetadata","createConcatenatedColumnMetadata","transformedDataView","addToMetadata","concatenatedCategoryColumn","createConcatenatedCategoryColumn","transformedCategoricalCategories","difference","transformedCategorical","columnsSortedByProjectionOrdering_1","columnsInProjectionOrdering","columnsByIndex_1","columns_1","index","columnIndicesInProjectionOrdering","columnIndex","sourceColumnsSortedByProjectionOrdering","concatenatedDisplayName","sourceColumnsSortedByProjectionOrdering_1","columnSource","newRoles","newColumnMetadata","columnSourceForCurrentDrillLevel","last","isMeasure","newColumn","transformedColumns","transformedMetadata","columnMetadata","newCategoryColumn","firstColumn","visitMapping","mapping","visitor","visitCategorical","table","visitTable","matrix","visitMatrix","tree","visitTree","single","visitSingle","visitCategoricalValues","visitBind","visitFor","visitList","visitReduction","groupedRoleMapping","visitGrouped","group","select","rows","visitMatrixItems","visitTreeNodes","nodes","visitTreeValues","context","bind","to","forValue","select_1","by","reductionAlgorithm","dataReductionAlgorithm","DataViewNormalizeValues","rolesToNormalize","dataRoles","requiredTypes","filterVariantMeasures","dataview","columnFilter","generateMetadataColumnFilter","valueFilter","generateValueFilter","usedMappings","dataViewMappings_1","dataViewMapping","dataViewMappingProp","filterVariantMeasuresCategorical","filterVariantMeasuresTable","filterVariantMeasuresTreeNode","root","filterVariantMeasuresMatrix","filterVariantMeasuresSingle","columnsToNormalize","columns_2","rolesToNormalize_1","columnValueFilters","columns_3","columnValueFilter","generateColumnValueFilter","getColumnRequiredTypes","doesValueMatchTypes","columnRoles","rolesToNormalize_2","_b","typeDescriptor","valuesGrouped","valuesGrouped_1","valueGroup","valuesInGroup","valuesInGroup_1","normalizeVariant","filteredColumns","columns_4","filteredColumns_1","node","children","child","filterVariantMeasuresMatrixRecursive","dataviewMatrix","nodeValue","valueSourceIndex","valueSources","isNumber","rolesToNormalize_3","dataViewMappings_2","firstColumnByRoleName","object","types","types_1","columns_5","propertyId","defaultValue","objectOrMap","objectName","DataViewObject","propertyName","getObject","getUserDefinedObjects","getFillColor","defaultColor","solid","isUserDefined","isArray","getFillColorByPropertyName","DataViewObjectDefinitions","JsonComparer","ensure","defns","defnsForObject","defn","newDefn","properties","deleteProperty","getObjectDefinition","DataViewObjectDefinition","deleteSingleProperty","setValue","getPropertyContainer","propertiesAreEqual","SemanticFilter","isSameFilter","allPropertiesAreEqual","keys","property","encodePropertyValue","valueTypeDescriptor","$","isNumeric","imageValue","imageDefinition","url","scaling","original","cloned","originalDefns","clonedDefns","originalDefns_1","originalDefn","cloneProperties","descriptors","findProperty","propDesc","formattingTypeDesc","findFilterOutput","propType","findDefaultValue","propPredicate","objPropDescs","DataViewObjectEvaluationUtils","evaluateDataViewObjects","evalContext","objectDefns","objectDefinition","evaluatedObject","DataViewObjectEvaluator","run","groupObjectsBySelector","objectDefinitions","objectDefnList","objectDefn","ensureDefinitionListForSelector","metadataOnce","groupedObjects","userDefined","groupedObjects_1","item_1","addImplicitObjects","objectsForAllSelectors","selectTransforms","addDefaultFormatString","addDefaultValue","selectIdx","selectLen","selectTransform","applyFormatString","getColumnFormatForIndex","defaultValueProp","selectTransforms_1","applyDefaultValue","columnIdx","columnLen","formatStringValue","applyMetadataProperty","metadataObjects","targetObjectDefn","targetMetadataObject","findWithMatchingSelector","targetObjectDefns","findExistingObject","objectDescriptor","propertyDefinitions","propertyDescriptors","propertyDefinition","propertyDescriptor","evaluateProperty","structuralType","evaluateValue","RuleEvaluation","evaluateFill","evaluateFillRule","evaluateImage","evaluateParagraphs","fillDefn","fillType","fillRuleDefn","evaluateColorStop","colorStop","colorValueType","numericType","definition","textType","evaluateArrayCopyOnChange","evaluateParagraph","evaluated","definitionTextRuns","textRuns","evaluatedTextRuns","evaluateTextRun","definitionValue","evaluatedValue","definitions","evaluator","evaluatedValues","take","SQExpr","ExpressionEvaluator","evaluate","instance","getExprValue","inputValue","colorAllocator","getColorAllocator","DataViewPivotCategorical","categoryIdentities","categoryValues","pivotedColumns","pivotedValues","rowIdx","rowCount","categoryValue","categoryIdentity","colIdx","colCount","pivotedColumn","groupName","pivotedValue","subtotal","pivotedMetadata","DataViewTransform","createValueColumns","DataViewPivotMatrix","dataViewMatrix","columnHierarchyRewritten","rowHierarchyRewritten","levels","pivotedRowNode","level","columnLeafNodes","measureCount","pivotResultMeasureHeaderLevel","index_1","callback","measureHeaderLeaf","columnLeafNode","levelSourceIndex","isSubtotal","hierarchyTreesRewritten","forEachLeaf","cloneTreeExecuteOnLeaf","cloneTree","sources","updatedRowRoot","updatedNode","newChildren","updatedChild","createNullValues","array","Array","inheritArrayWithValue","nullValues","inherited","DataViewSelfCrossJoin","applyCategorical","dataViewMetadata","categoryLength","valuesArray","createCategoricalDataViewBuilder","withCategories","withGroupedValues","createGroupedValues","build","nullValuesArray","valuesArrayLen","seriesData","seriesDataItem","originalValueColumn","originalHighlightValues","seriesDataItemCategory","groupColumn","identityFrom","fields","valueColumns","v","DataViewPivotCategoricalToPrimaryGroups","ArrayExtensions","pivotBinding","binding","allMappings","finalMapping","defaultDataVolume","canPivotCategorical","Primary","Groupings","Secondary","DataReduction","DataVolume","dataVolume","isPivotableAxis","axis","Projections","Subtotal","SuppressedProjections","unpivotResult","oldDataView","inferUnpivotTransform","newDataView","copy","newDataViewMatrix","unpivotMatrix","hasCompositeGroupInSeries","utils","DataViewMatrixUtils","containsCompositeGroup","categoricalFromUnpivotedMatrix","supportedDataViewMappings","categoricalMapping","matrixDataview","categoryGroups","valueGroups","addGroupingRole","groups","roleProjections","roleProjection","VisualDataRoleKind","Grouping","_c","oldMatrix","oldRows","oldRoot","oldChildren","series","seriesIdLevel","seriesIdFields","childIdentityFields","categoryIdLevel","categoryIdFields","findCategory","addCategory","categoryNode","oldChildren_1","seriesNode","matrixValues","_d","newColumns","s","inheritedNode","newColChildren","srcnode","dstnode","newRows","row","rowValues","mvalues","k","l","newMatrix","measureMetadata","createCategoryColumnsFromUnpivotedMatrix","seriesColumn","valueColumnMetadataSrc","valueColumnMetadataDst","groups_1","unpivotedMatrix","categoryIdentityFields","categorySourceColumns","groupLevelValues","levelValues","transforms","activeItems","colorAllocatorFactory","transformEmptyDataView","visualDataViews","transformQueryToVisualDataView","DataViewRegression","transformSelects","transformedDataViews","splits","transformDataView","splits_1","split","transformed","emptyDataView","transformObjects","selectsToInclude","targetKinds","getTargetKinds","ordering","roleMappings_1","targetDataViewKinds","columnRewrites","applyTransformsToColumns","applyRewritesToCategorical","pivotIfNecessary","matrixTransformationContext","applyRewritesToMatrix","shouldPivotMatrix","applyRewritesToTable","prototypeColumns","rewrites","prototypeColumn","getFormatForColumn","kpi","sort","discourageAggregationAcrossGroups","from","override","rewrittenSource","findOverride","rewritten","overrideArray","valuesOverride","rewrittenValuesSource","seriesGroups_1","isDynamicSeries_1","nextSeriesGroupIndex","currentSeriesGroup","currentValueColumn","newToOldPositions","createTableColumnPositionMapping","columnsClone","sourceColumn","newRow","originalOrder","rewrite","newOrder","createOrderMapping","overrideHierarchy","hierarchy","rewrittenHierarchy","newLevels","newLevel","levelSources","ensureRewritten","h","r","firstRoleMappingWithMatrix","find","matrixMapping","columnLevels","newToOldPositions_1","createMatrixValuesPositionMapping","keys_1","numKeys_1","reorderChildNodes","forEachNodeAtLevel","newValues","iterations","keysIndex","reorderMatrixCompositeGroups","numKeys","childrenClone","supportedDataViewMapping","projection","transformedRowsHierarchy_1","reorderMatrixHierarchyCompositeGroups","transformedColumnsHierarchy_1","matrixHierarchy","hierarchyRole","transformedHierarchy","selectIndicesInProjectionOrder","hasMultipleColumnsInProjection","hierarchyLevel","newToOldLevelSourceIndicesMapping","createMatrixHierarchyLevelSourcesPositionMapping","inheritMatrixNodeHierarchy","transformingHierarchyLevel","reorderMatrixHierarchyLevelColumnSources","reorderMatrixHierarchyLevelValues","levelSourceColumns","columnsForHierarchyRoleOrderedByLevelSourceIndex","DataViewMetadataColumnUtils","joinMetadataColumnsAndProjectionOrder","columnsForHierarchyRoleOrderedByProjection","sortBy","columnInfo","projectionOrderIndex","sourceIndex","originalLevelSources","newLevelSourceIndices","newLevelSourceIndex","oldLevelSourceIndex","transformingHierarchyRootNode","transformingHierarchyLevelIndex","oldToNewLevelSourceIndicesMapping","createReversedMapping","transformingMatrixNode","originalLevelValues","newlyOrderedLevelValues","levelValue","transformingLevelValue","newlyOrderedLastLevelValue","newPosition","reversed","keyAsNumber","parseInt","targetLevel","columnRewrite","dataObjects","evaluateMetadataObjects","metadataObject","colorAllocatorCache","populateColorAllocatorCache","evaluateMetadataRepetition","dataObject","evaluateDataRepetition","rules","evaluateUserDefinedObjects","dataViewObjects","objectDefns_1","createStaticEvalContext","objectDesc","propertyDesc","ruleDesc","createRuleEvaluationInstance","ruleType","ruleOutput","output","selectorToCreate","findSelectorForRuleInput","createRuleEvaluationInstanceFillRule","tryCreateColorAllocatorForFillRule","inputRole","ColorRuleEvaluation","fillRuleProperties","identifier","identifierKind","createColorAllocatorLinearGradient2","createColorAllocatorLinearGradient3","propertyValueFillRule","inputRange","findRuleInputColumnNumberRange","splitScales","midValue","cache","createColorAllocatorCache","staticEvalContext","objectDefnProperties","fillProperty","kind","fillRuleExpr","inputExprQueryName","findFirstQueryNameForExpr","fillRulePropertyDescriptor","register","evaluateDataRepetitionCategoricalCategory","evaluateDataRepetitionCategoricalValueGrouping","rewrittenMatrix","evaluateDataRepetitionMatrix","dataViewTable","rewrittenSelector","rewriteTableRoleSelector","rewrittenTable","evaluateDataRepetitionTable","findSelectorForRoleWildcard","resultingSelector","dataSelector","selectorRoles","allColumnsBelongToSelectorRole","allColumnsBelongToRole","fromExprs","isUniqueDataSelector","dataSelectors","newSelector","columns_6","selectorRole","findSelectedCategoricalColumn","foundMatch","createCategoricalEvalContext","setCurrentRowIndex","dataViewCategoricalValues","selectorMetadata","valueSource","valueSourceOverwrite","setGrouped","createMatrixEvalContext","rewrittenRows","evaluateDataRepetitionMatrixHierarchy","rewrittenCols","dataViewMatrixHierarchy","rewrittenRoot","evaluateDataRepetitionMatrixNode","dataViewNode","childNodes","rewrittenNode","shouldSearchChildren","childNode","rewrittenChildNode","inheritNodeAndChildren","getPrototypeOf","createTableEvalContext","evaluateDataRepetitionTableRows","findIndex","col","inheritedRows","colLen","rowLen","inheritedRow","objectsForColumns","metadataId","categoricalColumn","selectedMetadataId","isSelectRef","expressionName","columnExpr","valueColRoles","aggregates","minLocal","maxLocal","valueIdentityFields","groupedResult","groupValues","currentGroup","determineCategoricalTransformation","some","vg","roleMappingCategorical","hasRolesGrouped","categoriesMapping","hasCategoryRole","hasRolesBind","hasRolesFor","rowLevels","rowRoles","roleMappingMatrix","createDisplayNameGetter","displayNameKey","resourceProvider","getDisplayName","displayNameGetter","fieldExpr","sqExpr","FieldExprPattern","visit","FieldExprToSQExprVisitor","fromColumnAggr","columnAggr","aggregate","fromColumn","columnRef","fromEntity","entityPattern","entity","entityVar","fromEntityAggr","entityAggr","fromHierarchyLevelAggr","hierarchyLevelAggr","fromHierarchyLevel","hierarchyLevelPattern","fromHierarchy","hierarchyPattern","visitColumn","visitColumnAggr","visitColumnHierarchyLevelVariation","columnHierarchyLevelVariationPattern","propertyVariationSource","visitEntityAggr","visitHierarchyLevelAggr","visitMeasure","measure","measureRef","percentile","exclusive","visitPercentOfGrandTotal","percentOfGrandTotal","baseSQExpr","baseExpr","arithmetic","scopedEval","selectRef","SQExprConverter","asFieldPattern","FieldExprPatternBuilder","sourceRef","SourceExprPatternBuilder","ref","entityRef","variable","fieldPattern","argAggr","func","sourcePattern","hierarchyRef","hierarchySourceExprPattern","HierarchyExprPatternBuiler","variation","columnHierarchyLevelVariation","variationName","percentOfGrandTotalPattern","entityExpr","SQEntityExpr","variationRef","exprPattern","fieldExprPattern","toColumnRefSQExpr","columnPattern","getAggregate","FieldExprPatternAggregateVisitor","isAggregation","FieldExprPatternIsAggregationVisitor","hasFieldExprName","getPropertyName","FieldExprPropertyNameVisitor","getHierarchyName","getColumnRef","getFieldExprName","toFieldExprEntityPattern","getSchema","toFieldExprEntityItemPattern","FieldExprToEntityExprPatternBuilder","SQExprInfo","toEntityItemExprPattern","pattern","validateAndReshape","dataViewMappings_3","supports","reshapeCategorical","reshapeTree","reshapeSingle","reshapeTable","ScriptResultUtil","findScriptResult","categoryRoleMapping","supported","updated","maxRowCount","originalLength","updatedCategories","updatedColumn","supportsCategorical","singleRoleMapping","treeRoleMapping","validateRange","countGroups","depth","tableRoleMapping","countMeasures","usePreferredDataViewSchema","scriptResult","supportsScriptResult","supportsTree","supportsSingle","supportsTable","preferred","dataViewSingle","scriptResultRoleMapping","imageBase64","roleCondition","ignoreMin","DataViewMappingMatchErrorCode","conditionRangeTooSmall","conditionRangeTooLarge","validateKind","roleKindByQueryRef","expectedKind","roleCollection","roleProjections_1","Measure","conditionKindExpectedMeasure","conditionKindExpectedGrouping","GroupingOrMeasure","conditionKindExpectedGroupingOrMeasure","mappings","errors","mappingIndex","mappingCount","mappingConditions","requiredProperties","allPropertiesValid","areAllPropertiesValid","conditionsMet","conditionIndex","conditionCount","currentConditionErrors","checkForConditionErrors","currentConditionErrors_1","error","supportedMapping","updatedConditions","emptyToNull","mappingErrors","conditionRoles","isDrillable","roleCount","getPropertyCount","rangeError","code","kindError","requiredProperty","objectDescriptorValue","objectDescriptorProperty","objectDefinitionValue","useActiveIfAvailable","projectionsForRole","hasSameCategoryIdentity","dataView1","dataView2","dv1Categories","dv2Categories","dv1Identity","dv2Identity","dv1Length","getLengthOptional","areMetadataColumnsEquivalent","column1","column2","isMetadataEquivalent","metadata1","metadata2","previousColumnsLength","newColumnsLength","Lazy","fromRoles","DataViewRoleWildcardImpl","firstRoleWildcard","secondRoleWildcard","role1","role2","_this","_roles","_key","ignoreCase","filterFromIdentity","identities_1","orExprs","resultExpr","orExprs_1","orExpr","inExpr","getInExpr","or","not","fromSQExpr","createDataViewScopeIdentity","DataViewScopeIdentityImpl","_expr","SQExprShortSerializer","serialize","wildcard","instanceExprs","firstScopeWildcard","secondScopeWildcard","DataViewScopeWildcardImpl","_exprs","serializeArray","ColorAllocatorProvider","entry","allocator","applicableDataViewMappings","regressionDataViewMapping","usage","regression","regressionDataViews","visualDataViews_1","visualDataView","regressionDataView","linearRegressionTransform","sourceDataView","xColumns","getColumnsForCartesianRoleKind","yColumns","xColumnSource","yColumnSource","combineSeries","regressionUsage","combineSeriesPropertyId","highlightsLineDefSet","dataPointsBySeries","getDataPointsBySeries","lineDefSet","calculateLineDefinitions","xMin","xMax","shouldComputeHightlights","hasHighlightValues","highlightDataPointsBySeries","valuesByTrend","lineDefs","trend","computeLineYValues","highlightsByTrend","createRegressionDataView","dataPointsBySeries_1","dataPointSet","unsortedXValues","xValues","unsortedYValues","yValues","xDataType","getDataType","yDataType","sortedDataPointSet","sortValues","minCategoryValue","maxCategoryValue","lineDef","computeRegressionLine","roleKind","getColumnsWithRoleKind","_loop_1","cartesianKind","state_1","firstNonNull","dataType","zippedValues","zip","valuePair","unzip","xBar","sum","yBar","ssXX","pow","ssXY","slope","intercept","x1","x2","getValuesFromColumn","preferHighlights","xValueArray","seriesYValues","multipleXValueColumns","yRole","seriesRole","xRole","categoricalRoles","seriesRoles","valuesBySeries","withCategory","regressionXQueryName","regressionSeriesQueryName","regressionYQueryName","selects_1","qp","activeItem","colorAllocatorProvider","CategoricalEvalContext","findRuleInputColumn","findRuleInputInColumns","columns_7","columnsByRole","getRoleValue","TableEvalContext","getExprValueFromTable","forEachLeafNode","rootNodes","isNodeArray","rootNodes_1","rootNode","forEachLeafNodeRecursive","nodeOrNodeArray","isArrayOrInheritedArray","matrixNode","nextIndex","treePath","children_1","nextChild","pop","deepestLevelToInherit","useInheritSingle","returnNode","isRootNode","shouldInheritCurrentNode","inheritFunc","shouldInheritChildNodes","matrixOrHierarchy","hasCompositeGroup","isMatrix","hierarchyLevels","hierarchyLevels_1","isMeasureHeadersLevel","isForRole","metadataColumn","targetRole","columnSources","jointResult","projectionOrderSelectIndices","selectIndexToProjectionIndexMap","selectIndex","jointColumnInfo","ConceptualSchema","entityName","entities","withName","findHierarchy","hierarchies","findHierarchyByVariation","variationEntityName","variationColumnName","hierarchyName","variationEntity","variationProperty","variationColumn","variations","targetEntity","navigationProperty","findPropertyWithKpi","kpiProperty","prop","status","goal","ConceptualDataCategory","extractScriptResult","script","provider","extractScriptResultFromVisualConfig","scriptSource","getScriptInput","scriptInput","VariableName","Columns","scriptInputColumnNames","scriptInputColumns","scriptInputColumn","QueryName","Name","ScriptInputColumnNameVisitor","ensureUniqueNames","federatedSchema","getNameForProperty","getVariationLevelName","getNameForHierarchy","federatedScheam","variations_1","defaultHierarchy","segmentation","DataViewMerger","mergeDataViews","segment","mergeTables","mergeCategorical","mergeTreeNodes","mergeIndex","lastMergeIndex","merge","segmentCategoriesLength","segmentCategory","sourceCategory","segmentValuesLength","segmentValue","sourceValue","sourceRoot","segmentRoot","allowDifferentStructure","firstAppendIndex","findFirstAppendIndex","lastSourceChild","mergedChildren","childSegment","isMerge","SQExprRewriter","origArg","rewrittenArg","SQColumnRefExpr","SQMeasureRefExpr","SQAggregationExpr","SQPercentileExpr","SQHierarchyExpr","SQHierarchyLevelExpr","SQPropertyVariationSourceExpr","orig","origLeft","rewrittenLeft","origRight","rewrittenRight","SQAndExpr","origLower","rewrittenLower","origUpper","rewrittenUpper","SQBetweenExpr","rewrittenValues","origArgs","rewrittenArgs","rewriteAll","origValues","origValueTuple","rewrittenValueTuple","SQInExpr","origExprs","rewrittenResult","origExpr","rewrittenExpr","SQOrExpr","SQCompareExpr","comparison","SQContainsExpr","SQExistsExpr","SQNotExpr","SQStartsWithExpr","SQDateSpanExpr","SQDateAddExpr","amount","SQArithmeticExpr","operator","origExpression","rewrittenExpression","origScope","rewrittenScope","SQScopedEvalExpr","origInput","rewrittenInput","origRule","origGradient2","rewrittenGradient2","origGradient3","rewrittenGradient3","rewrittenRule","SQFillRuleExpr","origMin","rewrittenMin","origMax","rewrittenMax","origMid","rewrittenMid","origColor","rewrittenColor","origValue","rewrittenValue","rewrittenStop","EqualsToInRewriter","Rewriter","Equal","visitUnsupported","isSupported","leftIsComparand","isComparand","rightIsComparand","operand","current","InBuilder","complete","cancel","SQConstantExpr","cancelled","asScopeIdsContainer","fieldSQExprs","filterItems","filterItem","FilterScopeIdsCollectorVisitor","getResult","getFirstComparandValue","comparandExpr","FindComparandVisitor","isRoot","keyExprsCount","valueExprs","fieldExprs","fieldSQExprs_1","field","removeEntityVariables","scopeIds","startIndex","endIndex","scopeId","getScopeIdentity","isInArray","compoundSQExpr","equalsExpr","equal","unsupportedSQExpr","values_1","valueTuple_1","fixedExpr","extractor","ScopeIdExtractorImpl","malformed","keyValues","PrimitiveValueEncoding","decimal","double","getTimezoneOffset","dateTimeString","toISOString","endsWith","substr","replace","SingleQuoteRegex","nullEncoding","boolean","createSQAggregationOperations","datetimeMinMaxSupported","SQAggregationOperations","getMetadataForUnderlyingType","removeAggregate","getMetadata","Agg","getSupportedAggregates","targetTypes","fieldKind","isPropertyIdentity","idOnEntityKey","aggregates_1","Sum","Avg","Min","Max","CountNonNull","StandardDeviation","Variance","fieldExprItem","currentSchema","capabilities","supportsMedian","Median","distinctCountAggExists","isSupportedAggregate","supportedAggregates","createExprWithAggregate","aggregateNonNumericFields","preferredAggregate","getDefaultAggregate","SQHierarchyExprUtils","getConceptualHierarchyLevelFromExpr","conceptualSchema","getConceptualHierarchyLevel","schemaName","conceptualHierarchy","getConceptualHierarchy","variationExpr","sourceEntityExpr","expandExpr","suppressHierarchyLevelExpansion","SQExprHierarchyToHierarchyLevelConverter","convert","SQExprVariationConverter","expand","SQExprHierarchyLevelConverter","isHierarchyOrVariation","conceptualProperty","getConceptualProperty","getSourceVariationExpr","hierarchyLevelExpr","getSourceHierarchy","getHierarchySourceAsVariationSource","areHierarchyLevelsOrdered","allLevels","firstExpr","secondExpr","firstLevel","secondLevel","firstIndex","indexOfExpr","secondIndex","getInsertionIndex","orderedSubsetOfLevels","insertIndex","hierarchyExpr","hierarchyLevels_2","SQExprGroupUtils","groupExprs","addChildToGroup","selectQueryIndex","shouldAddExpressionToNewGroup","exprSource","lastGroup","expandedExpr","allHierarchyLevels","defaultAggregateForDataType","defaultAggregateToQueryAggregateFunction","_kind","SQExprEqualityVisitor","validate","aggrUtils","validator","SQExprValidationVisitor","isColumn","isConstant","isEntity","isHierarchy","isHierarchyLevel","isResourcePackageItem","getMetadataForProperty","getMetadataForHierarchyLevel","getMetadataForVariation","getMetadataForPercentOfGrandTotal","getMetadataForEntity","forceAggregation","getHierarchyLevelConceptualProperty","propertyDefaultAggregate","defaultAggregate","getKeyColumns","columnRefExpr","SQExprColumnRefInfoVisitor","getColumnRefSQExpr","keySQExprs","getPropertyKeys","hasGroupOnKeys","keySqExpr","getTargetEntityForVariation","variations_2","getTargetEntity","SQEntityExprInfoVisitor","getEntityExpr","fieldExprHierachyLevel","fieldExprEntity","sourceProperty","getPropertyMetadata","columnAggregate","SQPropRefExpr","argMetadata","SQSelectRefExpr","valueEncoded","SQNowExpr","SQDefaultValueExpr","SQAnyValueExpr","SQResourcePackageItemExpr","packageName","packageType","itemName","between","inExpr_1","tryUseInExprs","leftArgLen","rightArgLen","combinedValues","compare","exists","startsWith","nullConstant","now","anyValue","dateAdd","dateSpan","Decimal","typedConstant","isBoolean","isString","setAggregate","FieldExprChangeAggregateRewriter","FieldExprRemoveAggregateRewriter","setPercentOfGrandTotal","SQExprSetPercentOfGrandTotalRewriter","removePercentOfGrandTotal","SQExprRemovePercentOfGrandTotalRewriter","SQExprRemoveEntityVariablesRewriter","resourcePackageItem","SQExprAggregateInfoVisitor","ignoreCaseInstance","comparand","equalsAll","compareValues","optionalEqual","equalIgnoreCase","leftRule","rightRule","leftLinearGradient2","rightLinearGradient2","leftLinearGradient3","rightLinearGradient3","left2","right2","equalsFillRuleStop","left3","right3","stop1","stop2","SQExprRootRewriter","values_2","validateCompatibleType","compareExpr","validateEntity","isQueryable","aggregateExpr","validateHierarchy","hierarchyLevelFieldExprItem","validateHierarchyLevel","validateOperandsAndTypeForStartOrContains","validateArithmeticTypes","supportsArithmetic","leftMetadata","leftType","rightMetadata","rightType","levelName","hierarchyLevelConceptualProperty","queryable","sourceExpr","targetEntityExpr","schemaHierarchy","hierarchyLevelRef","getEntity","SQExprChangeAggregateRewriter","rewriter","defaultRewrite","SQExprRemoveAggregateRewriter","searchElement","uniqueName","namedItems","exprDefaultName","findUniqueName","defaultName","fallback","SQExprDefaultNameGenerator","IsMeasureVisitor","isAnyValue","IsAnyValueVisitor","isDefaultValue","IsDefaultValueVisitor","discourageAggregation","getSchemaCapabilities","discourageQueryAggregateUsage","getAggregateBehavior","getConceptualColumn","aggregateBehavior","getKpiMetadata","kpiStatusProperty","getKpiStatusProperty","kpiValue","statusMetadata","kpiTrendProperty","getKpiTrendProperty","trendMetadata","getConceptualEntity","conceptualEntity","getDefaultValue","fieldSQExpr","sqField","hierarchyLevelField","getDefaultValues","fieldSQExprs_2","getDataViewScopeIdentityComparisonExpr","fieldsExpr","compareExprs","compareExprs_1","getActiveTablesNames","queryDefn","tables","selectedItems","entityObj","isRelatedToMany","targetExpr","isRelated","isRelatedToOne","sourceMultiplicity","targetMultiplicity","navigationProperties","target","queue","shift","navProperties","navProperties_1","navProperty","isActive","isRelatedOneToOne","sourceNavigations","targetNavigations","hasOneToOneNavigation","navigationProperties_1","concatUnique","leftExprs","rightExprs","concatExprs","rightExprs_1","SemanticQueryRewriter","exprRewriter","rewriteFrom","fromValue","fromContents","originalFrom","originalFromKeys","keyName","originalEntityRef","originalEntityExpr","updatedEntityExpr","SQFrom","rewriteSelect","selectItems","rewriteNamedSQExpressions","rewriteGroupBy","groupByitems","expressions","SQExprRewriterWithSourceRenames","rewriteOrderBy","orderByItems","orderBy","updatedExpr","direction","rewriteWhere","whereItems","where","originalWhere","updatedWhere","SemanticQuery","groupBy","groupByItems","empty","createWithTrimmedFrom","unreferencedKeyFinder","UnreferencedKeyFinder","filterTarget","unreferencedKeys","remove","getSelect","setSelect","createNamedExpressionArray","extendWithName","rewriteExpressionsWithSourceRenames","removeSelect","originalItems","originalExpr","removeOrderBy","sorts","selectNameOf","setSelectAt","originalName","addSelect","exprName","createNamedExpr","currentNames","getGroupBy","setGroupBy","addGroupBy","getOrderBy","setOrderBy","clause","updatedOrderBy","getWhere","setWhere","updatedFilter","updatedTarget","addWhere","incomingWhere","updatedClause","contract","rewrittenContract","getDefaultValueFilter","getDataViewScopeIdentityComparisonFilters","getAnyValueFilter","filters","firstFilter","applyFilter","isDefaultFilter","isAnyFilter","leftFilter","rightFilter","filterWhereItems","filterWhereItem","updatedWhereItem","ensureEntity","desiredVariableName","i_1","candidateName","new","idx","substring","toLowerCase","extend","renames","updatedName","rewriteFilter","updatedTargets","rewriteArray","updatedCondition","updatedExprs","QuerySourceRenameDetector","detector","existingEntity","actualEntity","CategoricalDataViewBuilder","pushIfNotExists","itemToAdd","applySeriesData","staticMeasureColumns","dynamicMeasureColumns","withValues","columns_8","staticSeriesValues","dynamicSeriesMetadata","valueColumns_1","dynamicSeriesValues","fillData","dataViewValues","first","seriesMeasures","measureIndex","measuresLen","hasStaticSeries","staticColumnsStartingIndex","metadataColumns","categoryMetadata","categoryMetadata_1","seriesValues","seriesValue","seriesIdentity","dynamicSeriesGroups_1","appendStaticMeasureColumns","isLegalDataView","isVisualDataView","StaticEvalContext","getTargetExpr","cols","selectTransforms_2","powerbi_1","FormattingEncoder","RegExpExtensions","preserveEscaped","specialChars","oldText","newText","String","fromCharCode","replaceAll","restoreEscaped","preserveLiterals","literals","fromIndex","toIndex","literal","token","restoreLiterals","DateTimeFormat","IndexedTokensRegex","ZeroPlaceholder","DigitPlaceholder","ExponentialFormatChar","NumericPlaceholders","NumericPlaceholderRegex","RegExp","join","FormattingService","culture","gculture","getCulture","canFormat","formatWithIndexedTokens","match","argToken","parts","argIndex","argFormat","nonScientificOverrideFormat","formatWithCustomOverride","_dateTimeScaleFormatInfo","initialize","setCurrentCulture","cultureSelector","_currentCultureSelector","_currentCulture","DateTimeScaleFormatInfo","Globalize","findClosestCulture","cultureName","getCurrentCulture","calendarName","getUrlParam","calendars","calendar","urlParam","common","cultureInfo","navigator","userLanguage","param","location","search","isStandard","formatDateStandard","formatDateCustom","patterns","ensurePatterns","findDateFormat","processCustomDateTimeFormat","localize","_currentCachedFormat","_currentCachedProcessedFormat","fixDateTimeFormat","dictionary","timeSeparator","char","charAt","getNonScientificFormatWithPrecision","baseFormat","newFormat","hasFormatComponents","getComponents","positive","negative","zero","getNumericFormatFromComponent","NumericFormatRegex","formats","addDecimalsToFormatComponent","NumberFormatComponentsDelimeter","placeholder","decimalPlaceholders","repeat","DecimalFormatRegex","beforeDecimal","formatDecimal","afterDecimal","decimalChange","DecimalFormatCharacter","LastNumericPlaceholderRegex","signFormat","hasNegative","signSpecificFormats","formatCount","StandardFormatRegex","formatNumberStandard","formatNumberCustom","numberFormatInfo","numberFormat","formatChar","mantissaDecimalDigits","toFixed","toPrecision","toExponential","actualPrecision","isNegative","paddingZerosCount","paddingZeros","isFinite","formatComponents","formatMeta","hasEscapes","hasQuotes","hasE","scientificMatch","ScientificFormatRegex","formatM","formatE","getCustomFormatPrecision","scale","getCustomFormatScale","indexOfE","mantissa","resultM","fuseNumberWithCustomFormat","resultE","valueFormatted","isValueGlobalized","parseFloat","toNonScientific","_lastCustomFormatMeta","precisionZeros","digitsBeforeDecimalPoint","maxPrecision","indexOfDot","powerZeros","calculatePrecision","calculateScale","hasCommas","hasDots","hasPercent","hasPermile","length_1","dotIndex","suppressModifyValue","formatParts","wholeFormat","fractionFormat","NumericalPlaceHolderRegex","globalizedDecimalSeparator","decimalSeparator","valueParts","wholeValue","fractionValue","TrailingZerosRegex","wholeFormattedValue","fuseNumberWithCustomFormatLeft","fractionFormattedValue","fuseNumberWithCustomFormatRight","fmtOnly","groupSymbolIndex","enableGroups","groupDigitCount","groupSizes","groupSize","groupSeparator","sign","firstChar","isZero","leftBuffer","vi","fi","fCount","vCount","lastChar","plus","minus","dot","comma","monthAbbreviations","cultureHasMonthAbbr","yearMonthPattern","monthDayPattern","fullPattern","longTimePattern","shortTimePattern","separator","hasYearSymbol","YearPattern","yearPos","monthPos","MonthPattern","DayPattern","minutePos","pmPos","shortHourPattern","HourPattern","MinutePattern","SecondPattern","MillisecondPattern","SQExprSerializer","str","agg","f","n","comp","const","o","SelectionId","highlight","keyWithoutHighlight","includes","ignoreHighlight","thisSelector","otherSelector","thisData","otherData","thisValue","otherValue","getKeyWithoutHighlight","hasIdentity","getSelector","getSelectorsByColumn","selectorsByColumn","createNull","createWithId","createWithMeasure","measureId","selectionId","createWithIdAndMeasure","createWithIdAndMeasureAndCategory","dataMap","createWithIds","id1","id2","idArray","createWithIdsAndMeasure","createWithSelectorForColumnAndMeasure","createWithHighlight","newId","data_4","SelectionIdBuilder","builder","ensureDataMap","withSeries","withMeasure","createSelectionId"],"mappings":"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","file":"VisualsData.min.js","sourcesContent":["var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n///<reference path=\"../../Typedefs/jquery/jquery.d.ts\"/>\n///<reference path=\"../../Typedefs/globalize/globalize.d.ts\"/>\n///<reference path=\"../../Typedefs/lodash/lodash.d.ts\"/>\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\n        var DefaultSQExprVisitorWithArg = (function () {\n            function DefaultSQExprVisitorWithArg() {\n            }\n            DefaultSQExprVisitorWithArg.prototype.visitEntity = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitColumnRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitMeasureRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAggr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPercentile = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchy = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchyLevel = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPropertyVariationSource = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitSelectRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitBetween = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitIn = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitOr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitCompare = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitContains = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitExists = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNot = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitStartsWith = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitConstant = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateSpan = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateAdd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNow = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefaultValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnyValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitArithmetic = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitFillRule = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitResourcePackageItem = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitScopedEval = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefault = function (expr, arg) {\n                return;\n            };\n            return DefaultSQExprVisitorWithArg;\n        }());\n        data.DefaultSQExprVisitorWithArg = DefaultSQExprVisitorWithArg;\n        /** Default ISQExprVisitor implementation that others may derive from. */\n        var DefaultSQExprVisitor = (function (_super) {\n            __extends(DefaultSQExprVisitor, _super);\n            function DefaultSQExprVisitor() {\n                _super.apply(this, arguments);\n            }\n            return DefaultSQExprVisitor;\n        }(DefaultSQExprVisitorWithArg));\n        data.DefaultSQExprVisitor = DefaultSQExprVisitor;\n        /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\n        var DefaultSQExprVisitorWithTraversal = (function () {\n            function DefaultSQExprVisitorWithTraversal() {\n            }\n            DefaultSQExprVisitorWithTraversal.prototype.visitEntity = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitColumnRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitMeasureRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAggr = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPercentile = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchy = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchyLevel = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPropertyVariationSource = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitSelectRef = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitBetween = function (expr) {\n                expr.arg.accept(this);\n                expr.lower.accept(this);\n                expr.upper.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitIn = function (expr) {\n                var args = expr.args;\n                for (var i = 0, len = args.length; i < len; i++)\n                    args[i].accept(this);\n                var values = expr.values;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var valueTuple = values[i];\n                    for (var j = 0, jlen = valueTuple.length; j < jlen; j++)\n                        valueTuple[j].accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnd = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitOr = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitCompare = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitContains = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitExists = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNot = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitStartsWith = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitConstant = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateSpan = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateAdd = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNow = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefaultValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnyValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitArithmetic = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRule = function (expr) {\n                expr.input.accept(this);\n                var rule = expr.rule, gradient2 = rule.linearGradient2, gradient3 = rule.linearGradient3;\n                if (gradient2) {\n                    this.visitLinearGradient2(gradient2);\n                }\n                if (gradient3) {\n                    this.visitLinearGradient3(gradient3);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient2 = function (gradient2) {\n                debug.assertValue(gradient2, 'gradient2');\n                this.visitFillRuleStop(gradient2.min);\n                this.visitFillRuleStop(gradient2.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient3 = function (gradient3) {\n                debug.assertValue(gradient3, 'gradient3');\n                this.visitFillRuleStop(gradient3.min);\n                this.visitFillRuleStop(gradient3.mid);\n                this.visitFillRuleStop(gradient3.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitResourcePackageItem = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitScopedEval = function (expr) {\n                expr.expression.accept(this);\n                for (var _i = 0, _a = expr.scope; _i < _a.length; _i++) {\n                    var scopeExpr = _a[_i];\n                    scopeExpr.accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefault = function (expr) {\n                return;\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                stop.color.accept(this);\n                var value = stop.value;\n                if (value)\n                    value.accept(this);\n            };\n            return DefaultSQExprVisitorWithTraversal;\n        }());\n        data.DefaultSQExprVisitorWithTraversal = DefaultSQExprVisitorWithTraversal;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    function createEnumType(members) {\n        return new EnumType(members);\n    }\n    powerbi.createEnumType = createEnumType;\n    var EnumType = (function () {\n        function EnumType(allMembers) {\n            debug.assertValue(allMembers, 'allMembers');\n            this.allMembers = allMembers;\n        }\n        EnumType.prototype.members = function (validMembers) {\n            var allMembers = this.allMembers;\n            if (!validMembers)\n                return allMembers;\n            var membersToReturn = [];\n            for (var _i = 0, allMembers_1 = allMembers; _i < allMembers_1.length; _i++) {\n                var member = allMembers_1[_i];\n                if (_.contains(validMembers, member.value))\n                    membersToReturn.push(member);\n            }\n            return membersToReturn;\n        };\n        return EnumType;\n    }());\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var FillSolidColorTypeDescriptor;\n    (function (FillSolidColorTypeDescriptor) {\n        /** Gets a value indicating whether the descriptor is nullable or not. */\n        function nullable(descriptor) {\n            debug.assertValue(descriptor, 'descriptor');\n            if (descriptor === true)\n                return false;\n            var advancedDescriptor = descriptor;\n            return !!advancedDescriptor.nullable;\n        }\n        FillSolidColorTypeDescriptor.nullable = nullable;\n    })(FillSolidColorTypeDescriptor = powerbi.FillSolidColorTypeDescriptor || (powerbi.FillSolidColorTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var ImageDefinition;\n    (function (ImageDefinition) {\n        ImageDefinition.urlType = { misc: { imageUrl: true } };\n    })(ImageDefinition = powerbi.ImageDefinition || (powerbi.ImageDefinition = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StructuralTypeDescriptor;\n    (function (StructuralTypeDescriptor) {\n        function isValid(type) {\n            debug.assertValue(type, 'type');\n            if (type.fill ||\n                type.fillRule ||\n                type.filter ||\n                type.expression ||\n                type.image ||\n                type.paragraphs) {\n                return true;\n            }\n            return false;\n        }\n        StructuralTypeDescriptor.isValid = isValid;\n    })(StructuralTypeDescriptor = powerbi.StructuralTypeDescriptor || (powerbi.StructuralTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var EnumExtensions = jsCommon.EnumExtensions;\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\n    var ValueType = (function () {\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\n        function ValueType(type, category, enumType) {\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\n            debug.assert(!!category || category === null, 'category');\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\n            this.underlyingType = type;\n            this.category = category;\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\n                this.temporalType = new TemporalType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\n                this.geographyType = new GeographyType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\n                this.miscType = new MiscellaneousType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\n                this.formattingType = new FormattingType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\n                this.enumType = enumType;\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\n                this.scriptingType = new ScriptType(type);\n            }\n        }\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\n        ValueType.fromDescriptor = function (descriptor) {\n            descriptor = descriptor || {};\n            // Simplified primitive types\n            if (descriptor.text)\n                return ValueType.fromExtendedType(ExtendedType.Text);\n            if (descriptor.integer)\n                return ValueType.fromExtendedType(ExtendedType.Integer);\n            if (descriptor.numeric)\n                return ValueType.fromExtendedType(ExtendedType.Double);\n            if (descriptor.bool)\n                return ValueType.fromExtendedType(ExtendedType.Boolean);\n            if (descriptor.dateTime)\n                return ValueType.fromExtendedType(ExtendedType.DateTime);\n            if (descriptor.duration)\n                return ValueType.fromExtendedType(ExtendedType.Duration);\n            if (descriptor.binary)\n                return ValueType.fromExtendedType(ExtendedType.Binary);\n            if (descriptor.none)\n                return ValueType.fromExtendedType(ExtendedType.None);\n            // Extended types\n            if (descriptor.scripting) {\n                if (descriptor.scripting.source)\n                    return ValueType.fromExtendedType(ExtendedType.ScriptSource);\n            }\n            if (descriptor.enumeration)\n                return ValueType.fromEnum(descriptor.enumeration);\n            if (descriptor.temporal) {\n                if (descriptor.temporal.year)\n                    return ValueType.fromExtendedType(ExtendedType.Year_Integer);\n                if (descriptor.temporal.month)\n                    return ValueType.fromExtendedType(ExtendedType.Month_Integer);\n            }\n            if (descriptor.geography) {\n                if (descriptor.geography.address)\n                    return ValueType.fromExtendedType(ExtendedType.Address);\n                if (descriptor.geography.city)\n                    return ValueType.fromExtendedType(ExtendedType.City);\n                if (descriptor.geography.continent)\n                    return ValueType.fromExtendedType(ExtendedType.Continent);\n                if (descriptor.geography.country)\n                    return ValueType.fromExtendedType(ExtendedType.Country);\n                if (descriptor.geography.county)\n                    return ValueType.fromExtendedType(ExtendedType.County);\n                if (descriptor.geography.region)\n                    return ValueType.fromExtendedType(ExtendedType.Region);\n                if (descriptor.geography.postalCode)\n                    return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\n                if (descriptor.geography.stateOrProvince)\n                    return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\n                if (descriptor.geography.place)\n                    return ValueType.fromExtendedType(ExtendedType.Place);\n                if (descriptor.geography.latitude)\n                    return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\n                if (descriptor.geography.longitude)\n                    return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\n            }\n            if (descriptor.misc) {\n                if (descriptor.misc.image)\n                    return ValueType.fromExtendedType(ExtendedType.Image);\n                if (descriptor.misc.imageUrl)\n                    return ValueType.fromExtendedType(ExtendedType.ImageUrl);\n                if (descriptor.misc.webUrl)\n                    return ValueType.fromExtendedType(ExtendedType.WebUrl);\n                if (descriptor.misc.barcode)\n                    return ValueType.fromExtendedType(ExtendedType.Barcode_Text);\n            }\n            if (descriptor.formatting) {\n                if (descriptor.formatting.color)\n                    return ValueType.fromExtendedType(ExtendedType.Color);\n                if (descriptor.formatting.formatString)\n                    return ValueType.fromExtendedType(ExtendedType.FormatString);\n                if (descriptor.formatting.alignment)\n                    return ValueType.fromExtendedType(ExtendedType.Alignment);\n                if (descriptor.formatting.labelDisplayUnits)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\n                if (descriptor.formatting.fontSize)\n                    return ValueType.fromExtendedType(ExtendedType.FontSize);\n                if (descriptor.formatting.labelDensity)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDensity);\n            }\n            if (descriptor.extendedType) {\n                return ValueType.fromExtendedType(descriptor.extendedType);\n            }\n            return ValueType.fromExtendedType(ExtendedType.Null);\n        };\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\n        ValueType.fromExtendedType = function (extendedType) {\n            extendedType = extendedType || ExtendedType.Null;\n            var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);\n            debug.assert(primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null, 'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\n        };\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\n        ValueType.fromPrimitiveTypeAndCategory = function (primitiveType, category) {\n            primitiveType = primitiveType || PrimitiveType.Null;\n            category = category || null;\n            var id = primitiveType.toString();\n            if (category)\n                id += '|' + category;\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\n        };\n        /** Creates a ValueType to describe the given IEnumType. */\n        ValueType.fromEnum = function (enumType) {\n            debug.assertValue(enumType, 'enumType');\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\n        };\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\n        ValueType.isCompatibleTo = function (type, otherTypes) {\n            debug.assertValue(type, 'type');\n            debug.assertValue(otherTypes, 'otherTypes');\n            var valueType = ValueType.fromDescriptor(type);\n            for (var _i = 0, otherTypes_1 = otherTypes; _i < otherTypes_1.length; _i++) {\n                var otherType = otherTypes_1[_i];\n                var otherValueType = ValueType.fromDescriptor(otherType);\n                if (otherValueType.isCompatibleFrom(valueType))\n                    return true;\n            }\n            return false;\n        };\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\n        ValueType.prototype.isCompatibleFrom = function (other) {\n            debug.assertValue(other, 'other');\n            var otherPrimitiveType = other.primitiveType;\n            if (this === other ||\n                this.primitiveType === otherPrimitiveType ||\n                otherPrimitiveType === PrimitiveType.Null)\n                return true;\n            return false;\n        };\n        /**\n         * Determines if the instance ValueType is equal to the 'other' ValueType\n         * @param {ValueType} other the other ValueType to check equality against\n         * @returns True if the instance ValueType is equal to the 'other' ValueType\n         */\n        ValueType.prototype.equals = function (other) {\n            return _.isEqual(this, other);\n        };\n        Object.defineProperty(ValueType.prototype, \"primitiveType\", {\n            /** Gets the exact primitive type of this ValueType. */\n            get: function () {\n                return getPrimitiveType(this.underlyingType);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"extendedType\", {\n            /** Gets the exact extended type of this ValueType. */\n            get: function () {\n                return this.underlyingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"categoryString\", {\n            /** Gets the data category string (if any) for this ValueType. */\n            get: function () {\n                return this.category;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"text\", {\n            // Simplified primitive types\n            /** Indicates whether the type represents text values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Text;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"numeric\", {\n            /** Indicates whether the type represents any numeric value. */\n            get: function () {\n                return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"integer\", {\n            /** Indicates whether the type represents integer numeric values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Integer;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"bool\", {\n            /** Indicates whether the type represents Boolean values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Boolean;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"dateTime\", {\n            /** Indicates whether the type represents any date/time values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.DateTime ||\n                    this.primitiveType === PrimitiveType.Date ||\n                    this.primitiveType === PrimitiveType.Time;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"duration\", {\n            /** Indicates whether the type represents duration values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Duration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"binary\", {\n            /** Indicates whether the type represents binary values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Binary;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"none\", {\n            /** Indicates whether the type represents none values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.None;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"temporal\", {\n            // Extended types\n            /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\n            get: function () {\n                return this.temporalType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"geography\", {\n            /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\n            get: function () {\n                return this.geographyType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"misc\", {\n            /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\n            get: function () {\n                return this.miscType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"formatting\", {\n            /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\n            get: function () {\n                return this.formattingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"enum\", {\n            /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\n            get: function () {\n                return this.enumType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"scripting\", {\n            get: function () {\n                return this.scriptingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ValueType.typeCache = {};\n        return ValueType;\n    }());\n    powerbi.ValueType = ValueType;\n    var ScriptType = (function () {\n        function ScriptType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(ScriptType.prototype, \"source\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return ScriptType;\n    }());\n    powerbi.ScriptType = ScriptType;\n    var TemporalType = (function () {\n        function TemporalType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(TemporalType.prototype, \"year\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TemporalType.prototype, \"month\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return TemporalType;\n    }());\n    powerbi.TemporalType = TemporalType;\n    var GeographyType = (function () {\n        function GeographyType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(GeographyType.prototype, \"address\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"city\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"continent\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"country\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"county\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"region\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"postalCode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"stateOrProvince\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"place\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"latitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"longitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return GeographyType;\n    }());\n    powerbi.GeographyType = GeographyType;\n    var MiscellaneousType = (function () {\n        function MiscellaneousType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(MiscellaneousType.prototype, \"image\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"imageUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"webUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"barcode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Barcode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return MiscellaneousType;\n    }());\n    powerbi.MiscellaneousType = MiscellaneousType;\n    var FormattingType = (function () {\n        function FormattingType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(FormattingType.prototype, \"color\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"formatString\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"alignment\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDisplayUnits\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"fontSize\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDensity\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return FormattingType;\n    }());\n    powerbi.FormattingType = FormattingType;\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\n    (function (PrimitiveType) {\n        PrimitiveType[PrimitiveType[\"Null\"] = 0] = \"Null\";\n        PrimitiveType[PrimitiveType[\"Text\"] = 1] = \"Text\";\n        PrimitiveType[PrimitiveType[\"Decimal\"] = 2] = \"Decimal\";\n        PrimitiveType[PrimitiveType[\"Double\"] = 3] = \"Double\";\n        PrimitiveType[PrimitiveType[\"Integer\"] = 4] = \"Integer\";\n        PrimitiveType[PrimitiveType[\"Boolean\"] = 5] = \"Boolean\";\n        PrimitiveType[PrimitiveType[\"Date\"] = 6] = \"Date\";\n        PrimitiveType[PrimitiveType[\"DateTime\"] = 7] = \"DateTime\";\n        PrimitiveType[PrimitiveType[\"DateTimeZone\"] = 8] = \"DateTimeZone\";\n        PrimitiveType[PrimitiveType[\"Time\"] = 9] = \"Time\";\n        PrimitiveType[PrimitiveType[\"Duration\"] = 10] = \"Duration\";\n        PrimitiveType[PrimitiveType[\"Binary\"] = 11] = \"Binary\";\n        PrimitiveType[PrimitiveType[\"None\"] = 12] = \"None\";\n    })(powerbi.PrimitiveType || (powerbi.PrimitiveType = {}));\n    var PrimitiveType = powerbi.PrimitiveType;\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\n    (function (ExtendedType) {\n        // Flags (1 << 8-15 range [0xFF00])\n        // Important: Enum members must be declared before they are used in TypeScript.\n        ExtendedType[ExtendedType[\"Numeric\"] = 256] = \"Numeric\";\n        ExtendedType[ExtendedType[\"Temporal\"] = 512] = \"Temporal\";\n        ExtendedType[ExtendedType[\"Geography\"] = 1024] = \"Geography\";\n        ExtendedType[ExtendedType[\"Miscellaneous\"] = 2048] = \"Miscellaneous\";\n        ExtendedType[ExtendedType[\"Formatting\"] = 4096] = \"Formatting\";\n        ExtendedType[ExtendedType[\"Scripting\"] = 8192] = \"Scripting\";\n        // Primitive types (0-255 range [0xFF] | flags)\n        // The member names and base values must match those in PrimitiveType.\n        ExtendedType[ExtendedType[\"Null\"] = 0] = \"Null\";\n        ExtendedType[ExtendedType[\"Text\"] = 1] = \"Text\";\n        ExtendedType[ExtendedType[\"Decimal\"] = 258] = \"Decimal\";\n        ExtendedType[ExtendedType[\"Double\"] = 259] = \"Double\";\n        ExtendedType[ExtendedType[\"Integer\"] = 260] = \"Integer\";\n        ExtendedType[ExtendedType[\"Boolean\"] = 5] = \"Boolean\";\n        ExtendedType[ExtendedType[\"Date\"] = 518] = \"Date\";\n        ExtendedType[ExtendedType[\"DateTime\"] = 519] = \"DateTime\";\n        ExtendedType[ExtendedType[\"DateTimeZone\"] = 520] = \"DateTimeZone\";\n        ExtendedType[ExtendedType[\"Time\"] = 521] = \"Time\";\n        ExtendedType[ExtendedType[\"Duration\"] = 10] = \"Duration\";\n        ExtendedType[ExtendedType[\"Binary\"] = 11] = \"Binary\";\n        ExtendedType[ExtendedType[\"None\"] = 12] = \"None\";\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\n        // Temporal\n        ExtendedType[ExtendedType[\"Year\"] = 66048] = \"Year\";\n        ExtendedType[ExtendedType[\"Year_Text\"] = 66049] = \"Year_Text\";\n        ExtendedType[ExtendedType[\"Year_Integer\"] = 66308] = \"Year_Integer\";\n        ExtendedType[ExtendedType[\"Year_Date\"] = 66054] = \"Year_Date\";\n        ExtendedType[ExtendedType[\"Year_DateTime\"] = 66055] = \"Year_DateTime\";\n        ExtendedType[ExtendedType[\"Month\"] = 131584] = \"Month\";\n        ExtendedType[ExtendedType[\"Month_Text\"] = 131585] = \"Month_Text\";\n        ExtendedType[ExtendedType[\"Month_Integer\"] = 131844] = \"Month_Integer\";\n        ExtendedType[ExtendedType[\"Month_Date\"] = 131590] = \"Month_Date\";\n        ExtendedType[ExtendedType[\"Month_DateTime\"] = 131591] = \"Month_DateTime\";\n        // Geography\n        ExtendedType[ExtendedType[\"Address\"] = 6554625] = \"Address\";\n        ExtendedType[ExtendedType[\"City\"] = 6620161] = \"City\";\n        ExtendedType[ExtendedType[\"Continent\"] = 6685697] = \"Continent\";\n        ExtendedType[ExtendedType[\"Country\"] = 6751233] = \"Country\";\n        ExtendedType[ExtendedType[\"County\"] = 6816769] = \"County\";\n        ExtendedType[ExtendedType[\"Region\"] = 6882305] = \"Region\";\n        ExtendedType[ExtendedType[\"PostalCode\"] = 6947840] = \"PostalCode\";\n        ExtendedType[ExtendedType[\"PostalCode_Text\"] = 6947841] = \"PostalCode_Text\";\n        ExtendedType[ExtendedType[\"PostalCode_Integer\"] = 6948100] = \"PostalCode_Integer\";\n        ExtendedType[ExtendedType[\"StateOrProvince\"] = 7013377] = \"StateOrProvince\";\n        ExtendedType[ExtendedType[\"Place\"] = 7078913] = \"Place\";\n        ExtendedType[ExtendedType[\"Latitude\"] = 7144448] = \"Latitude\";\n        ExtendedType[ExtendedType[\"Latitude_Decimal\"] = 7144706] = \"Latitude_Decimal\";\n        ExtendedType[ExtendedType[\"Latitude_Double\"] = 7144707] = \"Latitude_Double\";\n        ExtendedType[ExtendedType[\"Longitude\"] = 7209984] = \"Longitude\";\n        ExtendedType[ExtendedType[\"Longitude_Decimal\"] = 7210242] = \"Longitude_Decimal\";\n        ExtendedType[ExtendedType[\"Longitude_Double\"] = 7210243] = \"Longitude_Double\";\n        // Miscellaneous\n        ExtendedType[ExtendedType[\"Image\"] = 13109259] = \"Image\";\n        ExtendedType[ExtendedType[\"ImageUrl\"] = 13174785] = \"ImageUrl\";\n        ExtendedType[ExtendedType[\"WebUrl\"] = 13240321] = \"WebUrl\";\n        ExtendedType[ExtendedType[\"Barcode\"] = 13305856] = \"Barcode\";\n        ExtendedType[ExtendedType[\"Barcode_Text\"] = 13305857] = \"Barcode_Text\";\n        ExtendedType[ExtendedType[\"Barcode_Integer\"] = 13306116] = \"Barcode_Integer\";\n        // Formatting\n        ExtendedType[ExtendedType[\"Color\"] = 19664897] = \"Color\";\n        ExtendedType[ExtendedType[\"FormatString\"] = 19730433] = \"FormatString\";\n        ExtendedType[ExtendedType[\"Alignment\"] = 20058113] = \"Alignment\";\n        ExtendedType[ExtendedType[\"LabelDisplayUnits\"] = 20123649] = \"LabelDisplayUnits\";\n        ExtendedType[ExtendedType[\"FontSize\"] = 20189443] = \"FontSize\";\n        ExtendedType[ExtendedType[\"LabelDensity\"] = 20254979] = \"LabelDensity\";\n        // Enumeration\n        ExtendedType[ExtendedType[\"Enumeration\"] = 26214401] = \"Enumeration\";\n        // Scripting\n        ExtendedType[ExtendedType[\"ScriptSource\"] = 32776193] = \"ScriptSource\";\n    })(powerbi.ExtendedType || (powerbi.ExtendedType = {}));\n    var ExtendedType = powerbi.ExtendedType;\n    var PrimitiveTypeMask = 0xFF;\n    var PrimitiveTypeWithFlagsMask = 0xFFFF;\n    var PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\n    function getPrimitiveType(extendedType) {\n        return extendedType & PrimitiveTypeMask;\n    }\n    function isPrimitiveType(extendedType) {\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\n    }\n    function getCategoryFromExtendedType(extendedType) {\n        if (isPrimitiveType(extendedType))\n            return null;\n        var category = ExtendedType[extendedType];\n        if (category) {\n            // Check for ExtendedType declaration without a primitive type.\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\n            var delimIdx = category.lastIndexOf('_');\n            if (delimIdx > 0) {\n                var baseCategory = category.slice(0, delimIdx);\n                if (ExtendedType[baseCategory]) {\n                    debug.assert((ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask), 'Unexpected value for ExtendedType base member of ' + extendedType);\n                    category = baseCategory;\n                }\n            }\n        }\n        return category || null;\n    }\n    function toExtendedType(primitiveType, category) {\n        var primitiveString = PrimitiveType[primitiveType];\n        var t = ExtendedType[primitiveString];\n        if (t == null) {\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\n            t = ExtendedType.Null;\n        }\n        if (primitiveType && category) {\n            var categoryType = ExtendedType[category];\n            if (categoryType) {\n                var categoryPrimitiveType = getPrimitiveType(categoryType);\n                if (categoryPrimitiveType === PrimitiveType.Null) {\n                    // Category supports multiple primitive types, check if requested primitive type is supported\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\n                    categoryType = t | categoryType;\n                    if (ExtendedType[categoryType]) {\n                        debug.assert(ExtendedType[categoryType] === (category + '_' + primitiveString), 'Unexpected name for ExtendedType member ' + categoryType);\n                        t = categoryType;\n                    }\n                }\n                else if (categoryPrimitiveType === primitiveType) {\n                    // Primitive type matches the single supported type for the category\n                    t = categoryType;\n                }\n            }\n        }\n        return t;\n    }\n    function matchesExtendedTypeWithAnyPrimitive(a, b) {\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (DataShapeBindingLimitType) {\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Top\"] = 0] = \"Top\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"First\"] = 1] = \"First\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Last\"] = 2] = \"Last\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Sample\"] = 3] = \"Sample\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Bottom\"] = 4] = \"Bottom\";\n        })(data.DataShapeBindingLimitType || (data.DataShapeBindingLimitType = {}));\n        var DataShapeBindingLimitType = data.DataShapeBindingLimitType;\n        (function (SubtotalType) {\n            SubtotalType[SubtotalType[\"None\"] = 0] = \"None\";\n            SubtotalType[SubtotalType[\"Before\"] = 1] = \"Before\";\n            SubtotalType[SubtotalType[\"After\"] = 2] = \"After\";\n        })(data.SubtotalType || (data.SubtotalType = {}));\n        var SubtotalType = data.SubtotalType;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataShapeBindingDataReduction;\n        (function (DataShapeBindingDataReduction) {\n            function createFrom(reduction) {\n                if (!reduction)\n                    return;\n                var result;\n                if (reduction.top) {\n                    result = {\n                        Top: {}\n                    };\n                    if (reduction.top.count)\n                        result.Top.Count = reduction.top.count;\n                }\n                if (reduction.bottom) {\n                    result = {\n                        Bottom: {}\n                    };\n                    if (reduction.bottom.count)\n                        result.Bottom.Count = reduction.bottom.count;\n                }\n                if (reduction.sample) {\n                    result = {\n                        Sample: {}\n                    };\n                    if (reduction.sample.count)\n                        result.Sample.Count = reduction.sample.count;\n                }\n                if (reduction.window) {\n                    result = {\n                        Window: {}\n                    };\n                    if (reduction.window.count)\n                        result.Window.Count = reduction.window.count;\n                }\n                return result;\n            }\n            DataShapeBindingDataReduction.createFrom = createFrom;\n        })(DataShapeBindingDataReduction = data.DataShapeBindingDataReduction || (data.DataShapeBindingDataReduction = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Represents a federated conceptual schema. */\n        var FederatedConceptualSchema = (function () {\n            function FederatedConceptualSchema(options) {\n                debug.assertValue(options, 'options');\n                this.schemas = options.schemas;\n                if (options.links)\n                    this.links = options.links;\n            }\n            FederatedConceptualSchema.prototype.schema = function (name) {\n                return this.schemas[name];\n            };\n            return FederatedConceptualSchema;\n        }());\n        data.FederatedConceptualSchema = FederatedConceptualSchema;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data_1) {\n        var Selector;\n        (function (Selector) {\n            function filterFromSelector(selectors, isNot) {\n                if (_.isEmpty(selectors))\n                    return;\n                var exprs = [];\n                for (var i = 0, ilen = selectors.length; i < ilen; i++) {\n                    var identity = selectors[i];\n                    var data_2 = identity.data;\n                    var exprToAdd = undefined;\n                    if (data_2 && data_2.length) {\n                        for (var j = 0, jlen = data_2.length; j < jlen; j++) {\n                            exprToAdd = data_1.SQExprBuilder.and(exprToAdd, identity.data[j].expr);\n                        }\n                    }\n                    if (exprToAdd)\n                        exprs.push(exprToAdd);\n                }\n                if (!_.isEmpty(exprs))\n                    return powerbi.DataViewScopeIdentity.filterFromExprs(exprs, isNot);\n            }\n            Selector.filterFromSelector = filterFromSelector;\n            function matchesData(selector, identities) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(identities, 'identities');\n                var selectorData = selector.data;\n                if (selectorData.length !== identities.length)\n                    return false;\n                for (var i = 0, len = selectorData.length; i < len; i++) {\n                    var dataItem = selector.data[i];\n                    var selectorDataItem = dataItem;\n                    if (selectorDataItem.expr) {\n                        if (!powerbi.DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\n                            return false;\n                    }\n                    else {\n                        if (!data_1.DataViewScopeWildcard.matches(dataItem, identities[i]))\n                            return false;\n                    }\n                }\n                return true;\n            }\n            Selector.matchesData = matchesData;\n            function matchesKeys(selector, keysList) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(keysList, 'keysList');\n                var selectorData = selector.data, selectorDataLength = selectorData.length;\n                if (selectorDataLength !== keysList.length)\n                    return false;\n                for (var i = 0; i < selectorDataLength; i++) {\n                    var selectorDataItem = selector.data[i], selectorDataExprs = void 0;\n                    if (selectorDataItem.expr) {\n                        selectorDataExprs = data_1.ScopeIdentityExtractor.getKeys(selectorDataItem.expr);\n                    }\n                    else if (selectorDataItem.exprs) {\n                        selectorDataExprs = selectorDataItem.exprs;\n                    }\n                    else {\n                        // In case DataViewRoleWildcard\n                        return false;\n                    }\n                    if (!selectorDataExprs)\n                        continue;\n                    if (!data_1.SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\n                        return false;\n                }\n                return true;\n            }\n            Selector.matchesKeys = matchesKeys;\n            /** Determines whether two selectors are equal. */\n            function equals(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (x.id !== y.id)\n                    return false;\n                if (x.metadata !== y.metadata)\n                    return false;\n                if (!equalsDataArray(x.data, y.data))\n                    return false;\n                return true;\n            }\n            Selector.equals = equals;\n            function equalsDataArray(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                if (x.length !== y.length)\n                    return false;\n                for (var i = 0, len = x.length; i < len; i++) {\n                    if (!equalsData(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            function equalsData(x, y) {\n                var selector1 = x;\n                var selector2 = y;\n                if (selector1.expr && selector2.expr)\n                    return powerbi.DataViewScopeIdentity.equals(selector1, selector2);\n                if (selector1.exprs && selector2.exprs)\n                    return data_1.DataViewScopeWildcard.equals(selector1, selector2);\n                if (selector1.roles && selector2.roles)\n                    return data_1.DataViewRoleWildcard.equals(selector1, selector2);\n                return false;\n            }\n            function getKey(selector) {\n                var toStringify = {};\n                if (selector.data) {\n                    var data_3 = [];\n                    for (var i = 0, ilen = selector.data.length; i < ilen; i++) {\n                        data_3.push(selector.data[i].key);\n                    }\n                    toStringify.data = data_3;\n                }\n                if (selector.metadata)\n                    toStringify.metadata = selector.metadata;\n                if (selector.id)\n                    toStringify.id = selector.id;\n                return JSON.stringify(toStringify);\n            }\n            Selector.getKey = getKey;\n            function containsWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (!dataItems)\n                    return false;\n                for (var _i = 0, dataItems_1 = dataItems; _i < dataItems_1.length; _i++) {\n                    var dataItem = dataItems_1[_i];\n                    var wildCard = dataItem;\n                    if (wildCard.exprs || wildCard.roles)\n                        return true;\n                }\n                return false;\n            }\n            Selector.containsWildcard = containsWildcard;\n            function hasRoleWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (_.isEmpty(dataItems))\n                    return false;\n                for (var _i = 0, dataItems_2 = dataItems; _i < dataItems_2.length; _i++) {\n                    var dataItem = dataItems_2[_i];\n                    if (isRoleWildcard(dataItem))\n                        return true;\n                }\n                return false;\n            }\n            Selector.hasRoleWildcard = hasRoleWildcard;\n            function isRoleWildcard(dataItem) {\n                return !_.isEmpty(dataItem.roles);\n            }\n            Selector.isRoleWildcard = isRoleWildcard;\n        })(Selector = data_1.Selector || (data_1.Selector = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (EntitySourceType) {\n            EntitySourceType[EntitySourceType[\"Table\"] = 0] = \"Table\";\n            EntitySourceType[EntitySourceType[\"Pod\"] = 1] = \"Pod\";\n        })(data.EntitySourceType || (data.EntitySourceType = {}));\n        var EntitySourceType = data.EntitySourceType;\n        function getArithmeticOperatorName(arithmeticOperatorKind) {\n            switch (arithmeticOperatorKind) {\n                case 0 /* Add */:\n                    return \"Add\";\n                case 1 /* Subtract */:\n                    return \"Subtract\";\n                case 2 /* Multiply */:\n                    return \"Multiply\";\n                case 3 /* Divide */:\n                    return \"Divide\";\n            }\n            throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\n        }\n        data.getArithmeticOperatorName = getArithmeticOperatorName;\n        (function (TimeUnit) {\n            TimeUnit[TimeUnit[\"Day\"] = 0] = \"Day\";\n            TimeUnit[TimeUnit[\"Week\"] = 1] = \"Week\";\n            TimeUnit[TimeUnit[\"Month\"] = 2] = \"Month\";\n            TimeUnit[TimeUnit[\"Year\"] = 3] = \"Year\";\n            TimeUnit[TimeUnit[\"Decade\"] = 4] = \"Decade\";\n            TimeUnit[TimeUnit[\"Second\"] = 5] = \"Second\";\n            TimeUnit[TimeUnit[\"Minute\"] = 6] = \"Minute\";\n            TimeUnit[TimeUnit[\"Hour\"] = 7] = \"Hour\";\n        })(data.TimeUnit || (data.TimeUnit = {}));\n        var TimeUnit = data.TimeUnit;\n        (function (QueryAggregateFunction) {\n            QueryAggregateFunction[QueryAggregateFunction[\"Sum\"] = 0] = \"Sum\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Avg\"] = 1] = \"Avg\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Count\"] = 2] = \"Count\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Min\"] = 3] = \"Min\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Max\"] = 4] = \"Max\";\n            QueryAggregateFunction[QueryAggregateFunction[\"CountNonNull\"] = 5] = \"CountNonNull\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Median\"] = 6] = \"Median\";\n            QueryAggregateFunction[QueryAggregateFunction[\"StandardDeviation\"] = 7] = \"StandardDeviation\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Variance\"] = 8] = \"Variance\";\n        })(data.QueryAggregateFunction || (data.QueryAggregateFunction = {}));\n        var QueryAggregateFunction = data.QueryAggregateFunction;\n        (function (QueryComparisonKind) {\n            QueryComparisonKind[QueryComparisonKind[\"Equal\"] = 0] = \"Equal\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThan\"] = 1] = \"GreaterThan\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThanOrEqual\"] = 2] = \"GreaterThanOrEqual\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThan\"] = 3] = \"LessThan\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThanOrEqual\"] = 4] = \"LessThanOrEqual\";\n        })(data.QueryComparisonKind || (data.QueryComparisonKind = {}));\n        var QueryComparisonKind = data.QueryComparisonKind;\n        /** Defines semantic data types. */\n        (function (SemanticType) {\n            SemanticType[SemanticType[\"None\"] = 0] = \"None\";\n            SemanticType[SemanticType[\"Number\"] = 1] = \"Number\";\n            SemanticType[SemanticType[\"Integer\"] = 3] = \"Integer\";\n            SemanticType[SemanticType[\"DateTime\"] = 4] = \"DateTime\";\n            SemanticType[SemanticType[\"Time\"] = 8] = \"Time\";\n            SemanticType[SemanticType[\"Date\"] = 20] = \"Date\";\n            SemanticType[SemanticType[\"Month\"] = 35] = \"Month\";\n            SemanticType[SemanticType[\"Year\"] = 67] = \"Year\";\n            SemanticType[SemanticType[\"YearAndMonth\"] = 128] = \"YearAndMonth\";\n            SemanticType[SemanticType[\"MonthAndDay\"] = 256] = \"MonthAndDay\";\n            SemanticType[SemanticType[\"Decade\"] = 515] = \"Decade\";\n            SemanticType[SemanticType[\"YearAndWeek\"] = 1024] = \"YearAndWeek\";\n            SemanticType[SemanticType[\"String\"] = 2048] = \"String\";\n            SemanticType[SemanticType[\"Boolean\"] = 4096] = \"Boolean\";\n            SemanticType[SemanticType[\"Table\"] = 8192] = \"Table\";\n            SemanticType[SemanticType[\"Range\"] = 16384] = \"Range\";\n        })(data.SemanticType || (data.SemanticType = {}));\n        var SemanticType = data.SemanticType;\n        (function (FilterKind) {\n            FilterKind[FilterKind[\"Default\"] = 0] = \"Default\";\n            FilterKind[FilterKind[\"Period\"] = 1] = \"Period\";\n        })(data.FilterKind || (data.FilterKind = {}));\n        var FilterKind = data.FilterKind;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var QueryProjectionCollection = (function () {\n            function QueryProjectionCollection(items, activeProjectionRefs, showAll) {\n                debug.assertValue(items, 'items');\n                this.items = items;\n                this._activeProjectionRefs = activeProjectionRefs;\n                this._showAll = showAll;\n            }\n            /** Returns all projections in a mutable array. */\n            QueryProjectionCollection.prototype.all = function () {\n                return this.items;\n            };\n            Object.defineProperty(QueryProjectionCollection.prototype, \"activeProjectionRefs\", {\n                get: function () {\n                    return this._activeProjectionRefs;\n                },\n                set: function (queryReferences) {\n                    if (!_.isEmpty(queryReferences)) {\n                        var queryRefs = this.items.map(function (val) { return val.queryRef; });\n                        for (var _i = 0, queryReferences_1 = queryReferences; _i < queryReferences_1.length; _i++) {\n                            var queryReference = queryReferences_1[_i];\n                            if (!_.contains(queryRefs, queryReference))\n                                return;\n                        }\n                        this._activeProjectionRefs = queryReferences;\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(QueryProjectionCollection.prototype, \"showAll\", {\n                get: function () {\n                    return this._showAll;\n                },\n                set: function (value) {\n                    this._showAll = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            QueryProjectionCollection.prototype.addActiveQueryReference = function (queryRef) {\n                if (!this._activeProjectionRefs)\n                    this._activeProjectionRefs = [queryRef];\n                else\n                    this._activeProjectionRefs.push(queryRef);\n            };\n            QueryProjectionCollection.prototype.getLastActiveQueryReference = function () {\n                if (!_.isEmpty(this._activeProjectionRefs)) {\n                    return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\n                }\n            };\n            /** Replaces the given oldQueryRef with newQueryRef in this QueryProjectionCollection. */\n            QueryProjectionCollection.prototype.replaceQueryRef = function (oldQueryRef, newQueryRef) {\n                debug.assertValue(oldQueryRef, 'oldQueryRef');\n                debug.assertValue(newQueryRef, 'newQueryRef');\n                debug.assert(oldQueryRef !== newQueryRef, 'oldQueryRef !== newQueryRef');\n                debug.assert(_.isEmpty(this._activeProjectionRefs), 'replaceQueryRef(...) is not supported on the QueryProjectionCollection of a drillable role');\n                // Note: the same queryRef can get projected multiple times\n                for (var _i = 0, _a = this.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    if (item.queryRef === oldQueryRef) {\n                        item.queryRef = newQueryRef;\n                    }\n                }\n            };\n            QueryProjectionCollection.prototype.clone = function () {\n                return new QueryProjectionCollection(_.cloneDeep(this.items), _.clone(this._activeProjectionRefs), this._showAll);\n            };\n            return QueryProjectionCollection;\n        }());\n        data.QueryProjectionCollection = QueryProjectionCollection;\n        var QueryProjectionsByRole;\n        (function (QueryProjectionsByRole) {\n            /** Clones the QueryProjectionsByRole. */\n            function clone(roles) {\n                if (!roles)\n                    return roles;\n                var clonedRoles = {};\n                for (var roleName in roles)\n                    clonedRoles[roleName] = roles[roleName].clone();\n                return clonedRoles;\n            }\n            QueryProjectionsByRole.clone = clone;\n            /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\n            function getRole(roles, name) {\n                debug.assertAnyValue(roles, 'roles');\n                debug.assertValue(name, 'name');\n                if (!roles)\n                    return;\n                return roles[name];\n            }\n            QueryProjectionsByRole.getRole = getRole;\n        })(QueryProjectionsByRole = data.QueryProjectionsByRole || (data.QueryProjectionsByRole = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** The system used to determine display units used during formatting */\n    (function (DisplayUnitSystemType) {\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Default\"] = 0] = \"Default\";\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Verbose\"] = 1] = \"Verbose\";\n        /**\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\n         * Suitable for dashboard tile cards\n         */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"WholeUnits\"] = 2] = \"WholeUnits\";\n        /**A display unit system that also contains Auto and None units for data labels*/\n        DisplayUnitSystemType[DisplayUnitSystemType[\"DataLabels\"] = 3] = \"DataLabels\";\n    })(powerbi.DisplayUnitSystemType || (powerbi.DisplayUnitSystemType = {}));\n    var DisplayUnitSystemType = powerbi.DisplayUnitSystemType;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Repreasents the sequence of the dates/times */\n    var DateTimeSequence = (function () {\n        // Constructors\n        /** Creates new instance of the DateTimeSequence */\n        function DateTimeSequence(unit) {\n            this.unit = unit;\n            this.sequence = [];\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\n        }\n        // Methods\n        /**\n         * Add a new Date to a sequence.\n         * @param date - date to add\n         */\n        DateTimeSequence.prototype.add = function (date) {\n            if (date < this.min) {\n                this.min = date;\n            }\n            if (date > this.max) {\n                this.max = date;\n            }\n            this.sequence.push(date);\n        };\n        // Methods\n        /**\n         * Extends the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.extendToCover = function (min, max) {\n            var x = this.min;\n            while (min < x) {\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\n                this.sequence.splice(0, 0, x);\n            }\n            this.min = x;\n            x = this.max;\n            while (x < max) {\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\n                this.sequence.push(x);\n            }\n            this.max = x;\n        };\n        /**\n         * Move the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.moveToCover = function (min, max) {\n            var delta = DateTimeSequence.getDelta(min, max, this.unit);\n            var count = Math.floor(delta / this.interval);\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\n            this.sequence = [];\n            this.sequence.push(this.min);\n            this.max = this.min;\n            while (this.max < max) {\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\n                this.sequence.push(this.max);\n            }\n        };\n        // Static\n        /**\n         * Calculate a new DateTimeSequence\n         * @param dataMin - Date representing min of the data range\n         * @param dataMax - Date representing max of the data range\n         * @param expectedCount - expected number of intervals in the sequence\n         * @param unit - of the intervals in the sequence\n         */\n        DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {\n            if (!unit) {\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\n            }\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Month:\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Week:\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Day:\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Second:\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\n                default:\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\n            }\n        };\n        DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\n            // Calculate range and sequence\n            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\n            // Calculate year sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\n            var newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval;\n            var date = new Date(newMinYear, 0, 1);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Year);\n            return result;\n        };\n        DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var minYear = dataMin.getFullYear();\n            var maxYear = dataMax.getFullYear();\n            var minMonth = dataMin.getMonth();\n            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\n            var date = new Date(minYear, 0, 1);\n            // Calculate month sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Month);\n            return result;\n        };\n        DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            var firstDayOfWeek = 0;\n            var minDayOfWeek = dataMin.getDay();\n            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\n            var minDay = dataMin.getDate() - dayOffset;\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Week));\n            // Calculate week sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Week);\n            return result;\n        };\n        DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, powerbi.DateTimeUnit.Day));\n            // Calculate day sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Day);\n            return result;\n        };\n        DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Hour));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Hour));\n            // Calculate hour sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Hour);\n            return result;\n        };\n        DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Minute));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Minute));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Minute);\n            return result;\n        };\n        DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Second));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Second));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Second);\n            return result;\n        };\n        DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\n            var min = DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Millisecond);\n            var max = DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Millisecond);\n            // Calculate milliseconds numeric sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Millisecond);\n            return result;\n        };\n        DateTimeSequence.addInterval = function (value, interval, unit) {\n            interval = Math.round(interval);\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateUtils.addYears(value, interval);\n                case powerbi.DateTimeUnit.Month:\n                    return DateUtils.addMonths(value, interval);\n                case powerbi.DateTimeUnit.Week:\n                    return DateUtils.addWeeks(value, interval);\n                case powerbi.DateTimeUnit.Day:\n                    return DateUtils.addDays(value, interval);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateUtils.addHours(value, interval);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateUtils.addMinutes(value, interval);\n                case powerbi.DateTimeUnit.Second:\n                    return DateUtils.addSeconds(value, interval);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateUtils.addMilliseconds(value, interval);\n            }\n        };\n        DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {\n            var result = new DateTimeSequence(unit);\n            for (var i = 0; i < sequence.sequence.length; i++) {\n                var x = sequence.sequence[i];\n                var d = DateTimeSequence.addInterval(date, x, unit);\n                result.add(d);\n            }\n            result.interval = sequence.interval;\n            result.intervalOffset = sequence.intervalOffset;\n            return result;\n        };\n        DateTimeSequence.getDelta = function (min, max, unit) {\n            var delta = 0;\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    delta = max.getFullYear() - min.getFullYear();\n                    break;\n                case powerbi.DateTimeUnit.Month:\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\n                    break;\n                case powerbi.DateTimeUnit.Week:\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Day:\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Hour:\n                    delta = (max.getTime() - min.getTime()) / 3600000;\n                    break;\n                case powerbi.DateTimeUnit.Minute:\n                    delta = (max.getTime() - min.getTime()) / 60000;\n                    break;\n                case powerbi.DateTimeUnit.Second:\n                    delta = (max.getTime() - min.getTime()) / 1000;\n                    break;\n                case powerbi.DateTimeUnit.Millisecond:\n                    delta = max.getTime() - min.getTime();\n                    break;\n            }\n            return delta;\n        };\n        DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {\n            maxCount = Math.max(maxCount, 2);\n            var totalDays = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Day);\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\n                return powerbi.DateTimeUnit.Year;\n            if (totalDays > 60 && totalDays > 7 * maxCount)\n                return powerbi.DateTimeUnit.Month;\n            if (totalDays > 14 && totalDays > 2 * maxCount)\n                return powerbi.DateTimeUnit.Week;\n            var totalHours = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Hour);\n            if (totalDays > 2 && totalHours > 12 * maxCount)\n                return powerbi.DateTimeUnit.Day;\n            if (totalHours >= 24 && totalHours >= maxCount)\n                return powerbi.DateTimeUnit.Hour;\n            var totalMinutes = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Minute);\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\n                return powerbi.DateTimeUnit.Minute;\n            var totalSeconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Second);\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\n                return powerbi.DateTimeUnit.Second;\n            var totalMilliseconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Millisecond);\n            if (totalMilliseconds > 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\n            var date = min;\n            if (date.getMilliseconds() !== 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            if (date.getSeconds() !== 0)\n                return powerbi.DateTimeUnit.Second;\n            if (date.getMinutes() !== 0)\n                return powerbi.DateTimeUnit.Minute;\n            if (date.getHours() !== 0)\n                return powerbi.DateTimeUnit.Hour;\n            if (date.getDate() !== 1)\n                return powerbi.DateTimeUnit.Day;\n            if (date.getMonth() !== 0)\n                return powerbi.DateTimeUnit.Month;\n            return powerbi.DateTimeUnit.Year;\n        };\n        // Constants\n        DateTimeSequence.MIN_COUNT = 1;\n        DateTimeSequence.MAX_COUNT = 1000;\n        return DateTimeSequence;\n    }());\n    powerbi.DateTimeSequence = DateTimeSequence;\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\n    var DateUtils;\n    (function (DateUtils) {\n        var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        /**\n         * Returns bool indicating weither the provided year is a leap year.\n         * @param year - year value\n         */\n        function isLeap(year) {\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\n        }\n        /**\n         * Returns number of days in the provided year/month.\n         * @param year - year value\n         * @param month - month value\n         */\n        function getMonthDays(year, month) {\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\n        }\n        /**\n         * Adds a specified number of years to the provided date.\n         * @param date - date value\n         * @param yearDelta - number of years to add\n         */\n        function addYears(date, yearDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var isLeapDay = month === 2 && day === 29;\n            var result = new Date(date.getTime());\n            year = year + yearDelta;\n            if (isLeapDay && !isLeap(year)) {\n                day = 28;\n            }\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addYears = addYears;\n        /**\n         * Adds a specified number of months to the provided date.\n         * @param date - date value\n         * @param monthDelta - number of months to add\n         */\n        function addMonths(date, monthDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            year += (monthDelta - (monthDelta % 12)) / 12;\n            month += monthDelta % 12;\n            // VSTS 1325771: Certain column charts don't display any data\n            // Wrap arround the month if is after december (value 11)\n            if (month > 11) {\n                month = month % 12;\n                year++;\n            }\n            day = Math.min(day, getMonthDays(year, month));\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addMonths = addMonths;\n        /**\n         * Adds a specified number of weeks to the provided date.\n         * @param date - date value\n         * @param weeks - number of weeks to add\n         */\n        function addWeeks(date, weeks) {\n            return addDays(date, weeks * 7);\n        }\n        DateUtils.addWeeks = addWeeks;\n        /**\n         * Adds a specified number of days to the provided date.\n         * @param date - date value\n         * @param days - number of days to add\n         */\n        function addDays(date, days) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            result.setFullYear(year, month, day + days);\n            return result;\n        }\n        DateUtils.addDays = addDays;\n        /**\n         * Adds a specified number of hours to the provided date.\n         * @param date - date value\n         * @param hours - number of hours to add\n         */\n        function addHours(date, hours) {\n            return new Date(date.getTime() + hours * 3600000);\n        }\n        DateUtils.addHours = addHours;\n        /**\n         * Adds a specified number of minutes to the provided date.\n         * @param date - date value\n         * @param minutes - number of minutes to add\n         */\n        function addMinutes(date, minutes) {\n            return new Date(date.getTime() + minutes * 60000);\n        }\n        DateUtils.addMinutes = addMinutes;\n        /**\n         * Adds a specified number of seconds to the provided date.\n         * @param date - date value\n         * @param seconds - number of seconds to add\n         */\n        function addSeconds(date, seconds) {\n            return new Date(date.getTime() + seconds * 1000);\n        }\n        DateUtils.addSeconds = addSeconds;\n        /**\n         * Adds a specified number of milliseconds to the provided date.\n         * @param date - date value\n         * @param milliseconds - number of milliseconds to add\n         */\n        function addMilliseconds(date, milliseconds) {\n            return new Date(date.getTime() + milliseconds);\n        }\n        DateUtils.addMilliseconds = addMilliseconds;\n    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    // Constants\n    var maxExponent = 24;\n    var defaultScientificBigNumbersBoundary = 1E15;\n    var scientificSmallNumbersBoundary = 1E-4;\n    var PERCENTAGE_FORMAT = '%';\n    var SCIENTIFIC_FORMAT = 'E+0';\n    var DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\n    // Regular expressions\n    /**\n     * This regex looks for strings that match one of the following conditions:\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\n     * The entire string (start to end) must match, and the match is not case-sensitive.\n     */\n    var SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\n    var DisplayUnit = (function () {\n        function DisplayUnit() {\n        }\n        // Methods\n        DisplayUnit.prototype.project = function (value) {\n            if (this.value) {\n                return powerbi.Double.removeDecimalNoise(value / this.value);\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.reverseProject = function (value) {\n            if (this.value) {\n                return value * this.value;\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.isApplicableTo = function (value) {\n            value = Math.abs(value);\n            var precision = powerbi.Double.getPrecision(value, 3);\n            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);\n        };\n        DisplayUnit.prototype.isScaling = function () {\n            return this.value > 1;\n        };\n        return DisplayUnit;\n    }());\n    powerbi.DisplayUnit = DisplayUnit;\n    var DisplayUnitSystem = (function () {\n        // Constructor\n        function DisplayUnitSystem(units) {\n            this.units = units ? units : [];\n        }\n        Object.defineProperty(DisplayUnitSystem.prototype, \"title\", {\n            // Properties\n            get: function () {\n                return this.displayUnit ? this.displayUnit.title : undefined;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        DisplayUnitSystem.prototype.update = function (value) {\n            if (value === undefined)\n                return;\n            this.unitBaseValue = value;\n            this.displayUnit = this.findApplicableDisplayUnit(value);\n        };\n        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {\n            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {\n                var unit = _a[_i];\n                if (unit.isApplicableTo(value))\n                    return unit;\n            }\n            return undefined;\n        };\n        DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros) {\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\n            if (this.isFormatSupported(format)) {\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\n                if (this.hasScientitifcFormat(format)) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\n                }\n                if (decimals != null) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n            }\n            return powerbi.formattingService.formatValue(value, format);\n        };\n        DisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DisplayUnitSystem.prototype.isPercentageFormat = function (format) {\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\n        };\n        DisplayUnitSystem.prototype.shouldRespectScalingUnit = function (format) {\n            return !this.isPercentageFormat(format);\n        };\n        DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function (format, decimals) {\n            return decimals;\n        };\n        DisplayUnitSystem.prototype.isScalingUnit = function () {\n            return this.displayUnit && this.displayUnit.isScaling();\n        };\n        DisplayUnitSystem.prototype.formatHelper = function (value, nonScientificFormat, format, decimals, trailingZeros) {\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\n            if ((format === 'g' || format === 'G') && decimals != null)\n                format = powerbi.visuals.valueFormatter.DefaultNumericFormat;\n            format = powerbi.NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\n            if (format && !powerbi.formattingService.isStandardNumberFormat(format))\n                return powerbi.formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\n            if (!format)\n                format = 'G';\n            if (!nonScientificFormat)\n                nonScientificFormat = '{0}';\n            var text = powerbi.formattingService.formatValue(value, format);\n            return powerbi.formattingService.format(nonScientificFormat, [text]);\n        };\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\n        DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals, trailingZeros) {\n            // Change unit base to a value appropriate for this value\n            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);\n            return this.format(value, format, decimals, trailingZeros);\n        };\n        DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {\n            if (this.units.length === 0)\n                return true;\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\n            var applicableRangeMin = 0;\n            for (var i = 0; i < this.units.length; i++) {\n                if (this.units[i].isScaling()) {\n                    applicableRangeMin = this.units[i].applicableRangeMin;\n                    break;\n                }\n            }\n            return Math.abs(value) < applicableRangeMin;\n        };\n        DisplayUnitSystem.prototype.isScientific = function (value) {\n            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\n        };\n        DisplayUnitSystem.prototype.hasScientitifcFormat = function (format) {\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\n        };\n        DisplayUnitSystem.prototype.supportsScientificFormat = function (format) {\n            if (format)\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\n            return true;\n        };\n        DisplayUnitSystem.prototype.shouldFallbackToScientific = function (value, format) {\n            return !this.hasScientitifcFormat(format)\n                && this.supportsScientificFormat(format)\n                && this.isScientific(value);\n        };\n        DisplayUnitSystem.prototype.getScientificFormat = function (data, format, decimals, trailingZeros) {\n            // Use scientific format outside of the range\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\n                var numericFormat = powerbi.NumberFormat.getNumericFormat(data, format);\n                if (decimals)\n                    numericFormat = powerbi.NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\n                if (numericFormat)\n                    return numericFormat + SCIENTIFIC_FORMAT;\n                else\n                    return DEFAULT_SCIENTIFIC_FORMAT;\n            }\n            return format;\n        };\n        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\n        return DisplayUnitSystem;\n    }());\n    powerbi.DisplayUnitSystem = DisplayUnitSystem;\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\n    var NoDisplayUnitSystem = (function (_super) {\n        __extends(NoDisplayUnitSystem, _super);\n        // Constructor\n        function NoDisplayUnitSystem() {\n            _super.call(this, []);\n        }\n        return NoDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\n        we are showing values (chart axes) and as such it is the default unit system. */\n    var DefaultDisplayUnitSystem = (function (_super) {\n        __extends(DefaultDisplayUnitSystem, _super);\n        // Constructor\n        function DefaultDisplayUnitSystem(unitLookup) {\n            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));\n        }\n        // Methods\n        DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        DefaultDisplayUnitSystem.reset = function () {\n            DefaultDisplayUnitSystem.units = null;\n        };\n        DefaultDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DefaultDisplayUnitSystem.units) {\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, function (value, previousUnitValue, min) {\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\n                    if (value - previousUnitValue >= 1000) {\n                        return value / 10;\n                    }\n                    return min;\n                });\n                // Ensure last unit has max of infinity\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DefaultDisplayUnitSystem.units;\n        };\n        return DefaultDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\n        where we have restricted space but do not want to show partial units. */\n    var WholeUnitsDisplayUnitSystem = (function (_super) {\n        __extends(WholeUnitsDisplayUnitSystem, _super);\n        // Constructor\n        function WholeUnitsDisplayUnitSystem(unitLookup) {\n            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        WholeUnitsDisplayUnitSystem.reset = function () {\n            WholeUnitsDisplayUnitSystem.units = null;\n        };\n        WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!WholeUnitsDisplayUnitSystem.units) {\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\n                // Ensure last unit has max of infinity\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return WholeUnitsDisplayUnitSystem.units;\n        };\n        WholeUnitsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        return WholeUnitsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;\n    var DataLabelsDisplayUnitSystem = (function (_super) {\n        __extends(DataLabelsDisplayUnitSystem, _super);\n        function DataLabelsDisplayUnitSystem(unitLookup) {\n            _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DataLabelsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DataLabelsDisplayUnitSystem.units) {\n                var units = [];\n                var adjustMinBasedOnPreviousUnit = function (value, previousUnitValue, min) {\n                    // Never returns true, we are always ignoring\n                    // We do not early switch (e.g. 100K instead of 0.1M)\n                    // Intended? If so, remove this function, otherwise, remove if statement\n                    if (value === -1)\n                        if (value - previousUnitValue >= 1000) {\n                            return value / 10;\n                        }\n                    return min;\n                };\n                // Add Auto & None\n                var names = unitLookup(-1);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                names = unitLookup(0);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                // Add normal units\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\n                // Ensure last unit has max of infinity\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DataLabelsDisplayUnitSystem.units;\n        };\n        DataLabelsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        // Constants\n        DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0;\n        DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1;\n        DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\n        return DataLabelsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;\n    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {\n        var units = [];\n        for (var i = 3; i < maxExponent; i++) {\n            var names = unitLookup(i);\n            if (names)\n                addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\n        }\n        return units;\n    }\n    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {\n        if (title || labelFormat) {\n            var min = value;\n            if (units.length > 0) {\n                var previousUnit = units[units.length - 1];\n                if (adjustMinBasedOnPreviousUnit)\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\n                previousUnit.applicableRangeMax = min;\n            }\n            var unit = new DisplayUnit();\n            unit.value = value;\n            unit.applicableRangeMin = min;\n            unit.applicableRangeMax = min * 1000;\n            unit.title = title;\n            unit.labelFormat = labelFormat;\n            units.push(unit);\n        }\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequence = (function () {\n        function NumericSequence() {\n        }\n        NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {\n            debug.assertValue(range, \"range\");\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\n            debug.assert(minPower === undefined || (minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP), \"minPower\");\n            debug.assert(maxAllowedMargin === undefined || (maxAllowedMargin >= 0), \"maxAllowedMargin\");\n            var result = new NumericSequence();\n            if (expectedCount === undefined)\n                expectedCount = 10;\n            else\n                expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (minPower === undefined)\n                minPower = powerbi.Double.MIN_EXP;\n            if (useZeroRefPoint === undefined)\n                useZeroRefPoint = false;\n            if (maxAllowedMargin === undefined)\n                maxAllowedMargin = 1;\n            if (steps === undefined)\n                steps = [1, 2, 5];\n            // Handle single stop case\n            if (range.forcedSingleStop) {\n                result.interval = range.getSize();\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\n                result.min = range.min;\n                result.max = range.max;\n                result.sequence = [range.forcedSingleStop];\n                return result;\n            }\n            var interval = 0;\n            var min = 0;\n            var max = 9;\n            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\n            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\n            var size = range.getSize();\n            var exp = powerbi.Double.log10(size);\n            // Account for Exp of steps\n            var stepExp = powerbi.Double.log10(steps[0]);\n            exp = exp - stepExp;\n            // Account for MaxCount\n            var expectedCountExp = powerbi.Double.log10(expectedCount);\n            exp = exp - expectedCountExp;\n            // Account for MinPower\n            exp = Math.max(exp, minPower - stepExp + 1);\n            var count = undefined;\n            // Create array of \"good looking\" numbers\n            if (interval !== 0) {\n                // If explicit interval is defined - use it instead of the steps array.\n                var power = powerbi.Double.pow10(exp);\n                var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\n                roundRange.shrinkByStep(range, interval);\n                min = roundRange.min;\n                max = roundRange.max;\n                count = Math.floor(roundRange.getSize() / interval);\n            }\n            else {\n                // No interval defined -> find optimal interval\n                var dexp = void 0;\n                for (dexp = 0; dexp < 3; dexp++) {\n                    var e = exp + dexp;\n                    var power = powerbi.Double.pow10(e);\n                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\n                    var stepsCount = steps.length;\n                    var stepPower = powerbi.Double.pow10(e - 1);\n                    for (var i = 0; i < stepsCount; i++) {\n                        var step = steps[i] * stepPower;\n                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\n                        roundRange.shrinkByStep(range, step);\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\n                            roundRange.min -= step;\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\n                            roundRange.max += step;\n                        // Count the intervals\n                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step);\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\n                            interval = step;\n                            min = roundRange.min;\n                            max = roundRange.max;\n                            break;\n                        }\n                    }\n                    // Increase the scale power until the interval is found\n                    if (interval !== 0)\n                        break;\n                }\n            }\n            // Avoid extreme count cases (>1000 ticks)\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\n                interval = (max - min) / count;\n            }\n            result.min = min;\n            result.max = max;\n            result.interval = interval;\n            result.intervalOffset = min - range.min;\n            result.maxAllowedMargin = maxAllowedMargin;\n            result.canExtendMin = canExtendMin;\n            result.canExtendMax = canExtendMax;\n            // Fill in the Sequence\n            var precision = powerbi.Double.getPrecision(interval, 0);\n            result.precision = precision;\n            var sequence = [];\n            var x = powerbi.Double.roundToPrecision(min, precision);\n            sequence.push(x);\n            for (var i = 0; i < count; i++) {\n                x = powerbi.Double.roundToPrecision(x + interval, precision);\n                sequence.push(x);\n            }\n            result.sequence = sequence;\n            result.trimMinMax(range.min, range.max);\n            return result;\n        };\n        /**\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid.\n         * @min - The minimum of the range.\n         * @max - The maximum of the range.\n         * @maxCount - The max count of intervals.\n         * @steps - array of intervals.\n         */\n        NumericSequence.calculateUnits = function (min, max, maxCount, steps) {\n            // Initialization actions\n            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (min === max) {\n                max = min + 1;\n            }\n            var stepCount = 0;\n            var step = 0;\n            // Calculate step\n            for (var i = 0; i < steps.length; i++) {\n                step = steps[i];\n                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);\n                var minStepCount = powerbi.Double.floorWithPrecision(min / step);\n                stepCount = maxStepCount - minStepCount;\n                if (stepCount <= maxCount) {\n                    break;\n                }\n            }\n            // Calculate the offset\n            var offset = -min;\n            offset = offset % step;\n            // Create sequence\n            var result = new NumericSequence();\n            result.sequence = [];\n            for (var x = min + offset;; x += step) {\n                result.sequence.push(x);\n                if (x >= max)\n                    break;\n            }\n            result.interval = step;\n            result.intervalOffset = offset;\n            result.min = result.sequence[0];\n            result.max = result.sequence[result.sequence.length - 1];\n            return result;\n        };\n        NumericSequence.prototype.trimMinMax = function (min, max) {\n            var minMargin = (min - this.min) / this.interval;\n            var maxMargin = (this.max - max) / this.interval;\n            var marginPrecision = 0.001;\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\n                this.min = min;\n            }\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\n                this.max = max;\n            }\n        };\n        NumericSequence.MIN_COUNT = 1;\n        NumericSequence.MAX_COUNT = 1000;\n        return NumericSequence;\n    }());\n    powerbi.NumericSequence = NumericSequence;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequenceRange = (function () {\n        function NumericSequenceRange() {\n        }\n        NumericSequenceRange.prototype._ensureIncludeZero = function () {\n            if (this.includeZero) {\n                // fixed min and max has higher priority than includeZero\n                if (this.min > 0 && !this.hasFixedMin) {\n                    this.min = 0;\n                }\n                if (this.max < 0 && !this.hasFixedMax) {\n                    this.max = 0;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureNotEmpty = function () {\n            if (this.min === this.max) {\n                if (!this.min) {\n                    this.min = 0;\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\n                    this.hasFixedMin = true;\n                    this.hasFixedMax = true;\n                }\n                else {\n                    // We are dealing with a single data value (includeZero is not set)\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\n                    // Interval is calculated based on the number:\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\n                    var value = this.min;\n                    var exp = powerbi.Double.log10(Math.abs(value));\n                    var step = void 0;\n                    if (exp >= 0 && exp < 4) {\n                        step = 0.5;\n                        this.forcedSingleStop = value;\n                    }\n                    else {\n                        step = powerbi.Double.pow10(exp) / 2;\n                        this.forcedSingleStop = null;\n                    }\n                    this.min = value - step;\n                    this.max = value + step;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureDirection = function () {\n            if (this.min > this.max) {\n                var temp = this.min;\n                this.min = this.max;\n                this.max = temp;\n            }\n        };\n        NumericSequenceRange.prototype.getSize = function () {\n            return this.max - this.min;\n        };\n        NumericSequenceRange.prototype.shrinkByStep = function (range, step) {\n            debug.assertValue(range, \"range\");\n            debug.assert(step > 0, \"step\");\n            var oldCount = this.min / step;\n            var newCount = range.min / step;\n            var deltaCount = Math.floor(newCount - oldCount);\n            this.min += deltaCount * step;\n            oldCount = this.max / step;\n            newCount = range.max / step;\n            deltaCount = Math.ceil(newCount - oldCount);\n            this.max += deltaCount * step;\n        };\n        NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\n            var result = new NumericSequenceRange();\n            result.includeZero = includeZero ? true : false;\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\n            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            // Calculate the range using the min, max, dataRange\n            if (result.hasFixedMin && result.hasFixedMax) {\n                result.min = fixedMin;\n                result.max = fixedMax;\n            }\n            else if (result.hasFixedMin) {\n                result.min = fixedMin;\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\n            }\n            else if (result.hasFixedMax) {\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\n                result.max = fixedMax;\n            }\n            else if (result.hasDataRange) {\n                result.min = dataMin;\n                result.max = dataMax;\n            }\n            else {\n                result.min = 0;\n                result.max = 0;\n            }\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            if (result.min === 0) {\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\n            }\n            else if (result.max === 0) {\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\n            }\n            return result;\n        };\n        NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\n            }\n            else {\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\n            }\n        };\n        NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {\n            debug.assertValue(fixedMin, \"fixedMin\");\n            debug.assertValue(fixedMax, \"fixedMax\");\n            var result = new NumericSequenceRange();\n            result.hasDataRange = false;\n            result.includeZero = includeZero;\n            result.min = fixedMin;\n            result.max = fixedMax;\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            result.hasFixedMin = true;\n            result.hasFixedMax = true;\n            return result;\n        };\n        NumericSequenceRange.DEFAULT_MAX = 10;\n        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;\n        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;\n        return NumericSequenceRange;\n    }());\n    powerbi.NumericSequenceRange = NumericSequenceRange;\n    /** Note: Exported for testability */\n    var ValueUtil;\n    (function (ValueUtil) {\n        function hasValue(value) {\n            return value !== undefined && value !== null;\n        }\n        ValueUtil.hasValue = hasValue;\n    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var valueFormatter;\n        (function (valueFormatter) {\n            var StringExtensions = jsCommon.StringExtensions;\n            var BeautifiedFormat = {\n                '0.00 %;-0.00 %;0.00 %': 'Percentage',\n                '0.0 %;-0.0 %;0.0 %': 'Percentage1',\n            };\n            valueFormatter.DefaultIntegerFormat = 'g';\n            valueFormatter.DefaultNumericFormat = '#,0.00';\n            valueFormatter.DefaultDateFormat = 'd';\n            var defaultLocalizedStrings = {\n                'NullValue': '(Blank)',\n                'BooleanTrue': 'True',\n                'BooleanFalse': 'False',\n                'NaNValue': 'NaN',\n                'InfinityValue': '+Infinity',\n                'NegativeInfinityValue': '-Infinity',\n                'RestatementComma': '{0}, {1}',\n                'RestatementCompoundAnd': '{0} and {1}',\n                'RestatementCompoundOr': '{0} or {1}',\n                'DisplayUnitSystem_EAuto_Title': 'Auto',\n                'DisplayUnitSystem_E0_Title': 'None',\n                'DisplayUnitSystem_E3_LabelFormat': '{0}K',\n                'DisplayUnitSystem_E3_Title': 'Thousands',\n                'DisplayUnitSystem_E6_LabelFormat': '{0}M',\n                'DisplayUnitSystem_E6_Title': 'Millions',\n                'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\n                'DisplayUnitSystem_E9_Title': 'Billions',\n                'DisplayUnitSystem_E12_LabelFormat': '{0}T',\n                'DisplayUnitSystem_E12_Title': 'Trillions',\n                'Percentage': '#,0.##%',\n                'Percentage1': '#,0.#%',\n                'TableTotalLabel': 'Total',\n                'Tooltip_HighlightedValueDisplayName': 'Highlighted',\n                'Funnel_PercentOfFirst': 'Percent of first',\n                'Funnel_PercentOfPrevious': 'Percent of previous',\n                'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlighted)',\n                'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlighted)',\n                // Geotagging strings\n                'GeotaggingString_Continent': 'continent',\n                'GeotaggingString_Continents': 'continents',\n                'GeotaggingString_Country': 'country',\n                'GeotaggingString_Countries': 'countries',\n                'GeotaggingString_State': 'state',\n                'GeotaggingString_States': 'states',\n                'GeotaggingString_City': 'city',\n                'GeotaggingString_Cities': 'cities',\n                'GeotaggingString_Town': 'town',\n                'GeotaggingString_Towns': 'towns',\n                'GeotaggingString_Province': 'province',\n                'GeotaggingString_Provinces': 'provinces',\n                'GeotaggingString_County': 'county',\n                'GeotaggingString_Counties': 'counties',\n                'GeotaggingString_Village': 'village',\n                'GeotaggingString_Villages': 'villages',\n                'GeotaggingString_Post': 'post',\n                'GeotaggingString_Zip': 'zip',\n                'GeotaggingString_Code': 'code',\n                'GeotaggingString_Place': 'place',\n                'GeotaggingString_Places': 'places',\n                'GeotaggingString_Address': 'address',\n                'GeotaggingString_Addresses': 'addresses',\n                'GeotaggingString_Street': 'street',\n                'GeotaggingString_Streets': 'streets',\n                'GeotaggingString_Longitude': 'longitude',\n                'GeotaggingString_Longitude_Short': 'lon',\n                'GeotaggingString_Latitude': 'latitude',\n                'GeotaggingString_Latitude_Short': 'lat',\n                'GeotaggingString_PostalCode': 'postal code',\n                'GeotaggingString_PostalCodes': 'postal codes',\n                'GeotaggingString_ZipCode': 'zip code',\n                'GeotaggingString_ZipCodes': 'zip codes',\n                'GeotaggingString_Territory': 'territory',\n                'GeotaggingString_Territories': 'territories',\n            };\n            function beautify(format) {\n                var key = BeautifiedFormat[format];\n                if (key)\n                    return defaultLocalizedStrings[key] || format;\n                return format;\n            }\n            function describeUnit(exponent) {\n                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\n                var title = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\n                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\n                if (title || format)\n                    return { title: title, format: format };\n            }\n            function getLocalizedString(stringId) {\n                return defaultLocalizedStrings[stringId];\n            }\n            valueFormatter.getLocalizedString = getLocalizedString;\n            // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\n            var locale = {\n                null: defaultLocalizedStrings['NullValue'],\n                true: defaultLocalizedStrings['BooleanTrue'],\n                false: defaultLocalizedStrings['BooleanFalse'],\n                NaN: defaultLocalizedStrings['NaNValue'],\n                infinity: defaultLocalizedStrings['InfinityValue'],\n                negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\n                beautify: function (format) { return beautify(format); },\n                describe: function (exponent) { return describeUnit(exponent); },\n                restatementComma: defaultLocalizedStrings['RestatementComma'],\n                restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\n                restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\n            };\n            var MaxScaledDecimalPlaces = 2;\n            var MaxValueForDisplayUnitRounding = 1000;\n            var MinIntegerValueForDisplayUnits = 10000;\n            var MinPrecisionForDisplayUnits = 2;\n            var DateTimeMetadataColumn = {\n                displayName: '',\n                type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.DateTime),\n            };\n            function getFormatMetadata(format) {\n                return powerbi.NumberFormat.getCustomFormatMetadata(format);\n            }\n            valueFormatter.getFormatMetadata = getFormatMetadata;\n            function setLocaleOptions(options) {\n                debug.assertValue(options, 'options');\n                locale = options;\n                powerbi.DefaultDisplayUnitSystem.reset();\n                powerbi.WholeUnitsDisplayUnitSystem.reset();\n            }\n            valueFormatter.setLocaleOptions = setLocaleOptions;\n            function createDefaultFormatter(formatString, allowFormatBeautification) {\n                if (allowFormatBeautification === void 0) { allowFormatBeautification = false; }\n                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;\n                return {\n                    format: function (value) {\n                        if (value == null)\n                            return locale.null;\n                        return formatCore(value, formatBeaut);\n                    }\n                };\n            }\n            valueFormatter.createDefaultFormatter = createDefaultFormatter;\n            /** Creates an IValueFormatter to be used for a range of values. */\n            function create(options) {\n                debug.assertValue(options, 'options');\n                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\n                if (shouldUseNumericDisplayUnits(options)) {\n                    var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType);\n                    var singleValueFormattingMode_1 = !!options.formatSingleValues;\n                    displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\n                    var forcePrecision_1 = options.precision != null;\n                    var decimals_1;\n                    if (forcePrecision_1)\n                        decimals_1 = -options.precision;\n                    else if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1)\n                        decimals_1 = -MaxScaledDecimalPlaces;\n                    // Detect axis precision\n                    if (options.detectAxisPrecision) {\n                        // Trailing zeroes\n                        forcePrecision_1 = true;\n                        var axisValue = options.value;\n                        if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 0)\n                            axisValue = axisValue / displayUnitSystem_1.displayUnit.value;\n                        if (powerbi.Double.isInteger(axisValue))\n                            decimals_1 = 0;\n                        else\n                            decimals_1 = powerbi.Double.log10(axisValue);\n                    }\n                    return {\n                        format: function (value) {\n                            var formattedValue = getStringFormat(value, true /*nullsAreBlank*/);\n                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                                return formattedValue;\n                            // Round to Double.DEFAULT_PRECISION\n                            if (value && !displayUnitSystem_1.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision_1)\n                                value = powerbi.Double.roundToPrecision(value);\n                            return singleValueFormattingMode_1 ?\n                                displayUnitSystem_1.formatSingleValue(value, format, decimals_1, forcePrecision_1) :\n                                displayUnitSystem_1.format(value, format, decimals_1, forcePrecision_1);\n                        },\n                        displayUnit: displayUnitSystem_1.displayUnit,\n                        options: options\n                    };\n                }\n                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\n                    var unit_1 = powerbi.DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\n                    return {\n                        format: function (value) {\n                            if (value == null)\n                                return locale.null;\n                            var formatString = powerbi.formattingService.dateFormatString(unit_1);\n                            return formatCore(value, formatString);\n                        },\n                        options: options\n                    };\n                }\n                return createDefaultFormatter(format);\n            }\n            valueFormatter.create = create;\n            function format(value, format, allowFormatBeautification) {\n                if (value == null)\n                    return locale.null;\n                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);\n            }\n            valueFormatter.format = format;\n            function getValueFormat(value, columnType) {\n                // If column type not defined or is not datetime\n                // ...and the value is of time datetime,\n                // then use the default date format string\n                if ((!columnType || !columnType.dateTime) && value instanceof Date)\n                    return getFormatString(DateTimeMetadataColumn, null, false);\n            }\n            function formatValueColumn(value, column, formatStringProp) {\n                var valueFormat = getValueFormat(value, column.type);\n                if (valueFormat)\n                    return formatCore(value, valueFormat);\n                else\n                    return formatCore(value, getFormatString(column, formatStringProp));\n            }\n            valueFormatter.formatValueColumn = formatValueColumn;\n            function createDisplayUnitSystem(displayUnitSystemType) {\n                if (displayUnitSystemType == null)\n                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                switch (displayUnitSystemType) {\n                    case powerbi.DisplayUnitSystemType.Default:\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.WholeUnits:\n                        return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.Verbose:\n                        return new powerbi.NoDisplayUnitSystem();\n                    case powerbi.DisplayUnitSystemType.DataLabels:\n                        return new powerbi.DataLabelsDisplayUnitSystem(locale.describe);\n                    default:\n                        debug.assertFail('Unknown display unit system type');\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                }\n            }\n            function shouldUseNumericDisplayUnits(options) {\n                var value = options.value;\n                var value2 = options.value2;\n                var format = options.format;\n                // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\n                if (options.formatSingleValues && format) {\n                    if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\n                        var isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\n                        if (isCustomFormat) {\n                            var precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\n                            if (precision < MinPrecisionForDisplayUnits)\n                                return false;\n                        }\n                        else if (powerbi.Double.isInteger(value))\n                            return false;\n                    }\n                }\n                if ((typeof value === 'number') || (typeof value2 === 'number')) {\n                    return true;\n                }\n            }\n            function shouldUseDateUnits(value, value2, tickCount) {\n                // must check both value and value2 because we'll need to get an interval for date units\n                return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\n            }\n            /*\n             * Get the column format. Order of precendence is:\n             *  1. Column format\n             *  2. Default PowerView policy for column type\n             */\n            function getFormatString(column, formatStringProperty, suppressTypeFallback) {\n                if (column) {\n                    if (formatStringProperty) {\n                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);\n                        if (propertyValue)\n                            return propertyValue;\n                    }\n                    if (!suppressTypeFallback) {\n                        var columnType = column.type;\n                        if (columnType) {\n                            if (columnType.dateTime)\n                                return valueFormatter.DefaultDateFormat;\n                            if (columnType.integer)\n                                return valueFormatter.DefaultIntegerFormat;\n                            if (columnType.numeric)\n                                return valueFormatter.DefaultNumericFormat;\n                        }\n                    }\n                }\n            }\n            valueFormatter.getFormatString = getFormatString;\n            function formatListCompound(strings, conjunction) {\n                var result;\n                if (!strings) {\n                    return null;\n                }\n                var length = strings.length;\n                if (length > 0) {\n                    result = strings[0];\n                    var lastIndex = length - 1;\n                    for (var i = 1, len = lastIndex; i < len; i++) {\n                        var value = strings[i];\n                        result = StringExtensions.format(locale.restatementComma, result, value);\n                    }\n                    if (length > 1) {\n                        var value = strings[lastIndex];\n                        result = StringExtensions.format(conjunction, result, value);\n                    }\n                }\n                else {\n                    result = null;\n                }\n                return result;\n            }\n            /** The returned string will look like 'A, B, ..., and C'  */\n            function formatListAnd(strings) {\n                return formatListCompound(strings, locale.restatementCompoundAnd);\n            }\n            valueFormatter.formatListAnd = formatListAnd;\n            /** The returned string will look like 'A, B, ..., or C' */\n            function formatListOr(strings) {\n                return formatListCompound(strings, locale.restatementCompoundOr);\n            }\n            valueFormatter.formatListOr = formatListOr;\n            function formatCore(value, format) {\n                var formattedValue = getStringFormat(value, false /*nullsAreBlank*/);\n                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                    return formattedValue;\n                return powerbi.formattingService.formatValue(value, format);\n            }\n            function getStringFormat(value, nullsAreBlank) {\n                if (value == null && nullsAreBlank)\n                    return locale.null;\n                if (value === true)\n                    return locale.true;\n                if (value === false)\n                    return locale.false;\n                if (typeof value === 'number' && isNaN(value))\n                    return locale.NaN;\n                if (value === Number.NEGATIVE_INFINITY)\n                    return locale.negativeInfinity;\n                if (value === Number.POSITIVE_INFINITY)\n                    return locale.infinity;\n                return '';\n            }\n            function getDisplayUnits(displayUnitSystemType) {\n                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\n                return displayUnitSystem.units;\n            }\n            valueFormatter.getDisplayUnits = getDisplayUnits;\n        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper;\n        (function (DataRoleHelper) {\n            function getMeasureIndexOfRole(grouped, roleName) {\n                if (!_.isEmpty(grouped)) {\n                    var firstGroup = grouped[0];\n                    if (firstGroup.values && firstGroup.values.length > 0) {\n                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {\n                            var value = firstGroup.values[i];\n                            if (value && value.source) {\n                                if (hasRole(value.source, roleName))\n                                    return i;\n                            }\n                        }\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;\n            function getCategoryIndexOfRole(categories, roleName) {\n                if (!_.isEmpty(categories)) {\n                    for (var i = 0, ilen = categories.length; i < ilen; i++) {\n                        if (hasRole(categories[i].source, roleName))\n                            return i;\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;\n            function hasRole(column, name) {\n                var roles = column.roles;\n                return roles && roles[name];\n            }\n            DataRoleHelper.hasRole = hasRole;\n            function hasRoleInDataView(dataView, name) {\n                return dataView != null\n                    && dataView.metadata != null\n                    && dataView.metadata.columns\n                    && _.any(dataView.metadata.columns, function (c) { return c.roles && c.roles[name] !== undefined; });\n            }\n            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;\n            function hasRoleInValueColumn(valueColumn, name) {\n                return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\n            }\n            DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;\n        })(DataRoleHelper = data.DataRoleHelper || (data.DataRoleHelper = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper = powerbi.data.DataRoleHelper;\n        function createIDataViewCategoricalReader(dataView) {\n            return new DataViewCategoricalReader(dataView);\n        }\n        data.createIDataViewCategoricalReader = createIDataViewCategoricalReader;\n        var DataViewCategoricalReader = (function () {\n            function DataViewCategoricalReader(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                this.dataView = dataView;\n                // Validate categories\n                var categorical;\n                if (dataView)\n                    categorical = dataView.categorical;\n                var categories;\n                if (categorical)\n                    categories = this.categories = categorical.categories;\n                this.hasValidCategories = !_.isEmpty(categories);\n                // Validate values\n                var values;\n                if (categorical)\n                    values = categorical.values;\n                // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\n                // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\n                this.hasAnyValidValues = false;\n                if (values != null) {\n                    var grouped = dataView.categorical.values.grouped();\n                    if (grouped.length > 0) {\n                        this.hasAnyValidValues = true;\n                        this.grouped = grouped;\n                        // Iterate through the first group's values to populate the valueRoleIndexMapping\n                        var valueRoleIndexMapping = {};\n                        var firstGroupValues = grouped[0].values;\n                        for (var valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\n                            var valueRoles = firstGroupValues[valueIndex].source.roles;\n                            for (var role in valueRoles) {\n                                if (valueRoles[role]) {\n                                    if (!valueRoleIndexMapping[role])\n                                        valueRoleIndexMapping[role] = [];\n                                    valueRoleIndexMapping[role].push(valueIndex);\n                                }\n                            }\n                        }\n                        this.valueRoleIndexMapping = valueRoleIndexMapping;\n                    }\n                }\n                if (this.hasAnyValidValues)\n                    this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\n            }\n            // Category methods\n            DataViewCategoricalReader.prototype.hasCategories = function () {\n                return this.hasValidCategories;\n            };\n            DataViewCategoricalReader.prototype.getCategoryCount = function () {\n                if (this.hasValidCategories)\n                    return this.categories[0].values.length;\n                else\n                    return 0;\n            };\n            DataViewCategoricalReader.prototype.getCategoryValues = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryValue = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values[categoryIndex] : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumn = function (roleName) {\n                if (this.hasValidCategories)\n                    return this.getCategoryFromRole(roleName);\n            };\n            DataViewCategoricalReader.prototype.getCategoryMetadataColumn = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.source : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumnIdentityFields = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.identityFields : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryDisplayName = function (roleName) {\n                if (this.hasValidCategories) {\n                    var targetColumn = this.getCategoryColumn(roleName);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.hasCompositeCategories = function () {\n                if (this.hasValidCategories)\n                    return this.categories.length > 1;\n            };\n            DataViewCategoricalReader.prototype.hasCategoryWithRole = function (roleName) {\n                return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\n            };\n            DataViewCategoricalReader.prototype.getCategoryObjects = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var category = this.getCategoryFromRole(roleName);\n                    if (category && category.objects) {\n                        return category.objects[categoryIndex];\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryFromRole = function (roleName) {\n                var categories = this.categories;\n                return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\n            };\n            // Value and measure methods\n            DataViewCategoricalReader.prototype.hasValues = function (roleName) {\n                return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\n            };\n            DataViewCategoricalReader.prototype.getValue = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        // For dynamic series, we only ever obtain the first value column from a role\n                        return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, false /* getHighlight */);\n                    }\n                    else {\n                        // For static series or single series, we obtain value columns from the first series\n                        //    and use the seriesIndex to index into the value columns within the role\n                        return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, false /* getHighlight */);\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getHighlight = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        // For dynamic series, we only ever obtain the first value column from a role\n                        return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, true /* getHighlight */);\n                    }\n                    else {\n                        // For static series or single series, we obtain value columns from the first series\n                        //    and use the seriesIndex to index into the value columns within the role\n                        return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, true /* getHighlight */);\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllValuesForRole = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var valuesInRole = [];\n                    for (var roleValueIndex = void 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, false /* getHighlight */));\n                    }\n                    return valuesInRole;\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllHighlightsForRole = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var valuesInRole = [];\n                    for (var roleValueIndex = void 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, true /* getHighlight */));\n                    }\n                    return valuesInRole;\n                }\n            };\n            /**\n             * Obtains the value from grouped.\n             *\n             * Grouped:             [0] [1] [2] [3] (seriesIndex)\n             *                         /   \\\n             * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\n             *                    /    \\ \\  \\\n             * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\n             *\n             *--------------------------------|\n             *                      |Category |\n             * Series|Value Columns |A B C D E|\n             *--------------------------------|\n             *      0|col0 (tooltip)|         |\n             *       |col1 (value)  |         |\n             *       |col2 (value)  |         |\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      1|col0 (tooltip)|         |\n             *       |col1 (value)  |0 1 2 3 4|\n             *       |col2 (value)  |5 6 7 8 9|\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      2|col0 (tooltip)|...      |\n             *\n             * valueColumnIndexInRole is for indexing into the values for a single role\n             * valueColumnIndex is for indexing into the entire value array including\n             * all roles\n             *\n             * The valueRoleIndexMapping converts roleValueIndex and role (value role\n             * with an index of 1) into groupedValueIndex (2)\n             *\n             * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\n             * the second value column with role \"value\" (which is converted to a\n             * groupedValueIndex of 2) and the fourth value within that value column.\n             */\n            DataViewCategoricalReader.prototype.getValueInternal = function (roleName, categoryIndex, groupIndex, valueColumnIndexInRole, getHighlight) {\n                if (this.hasValues(roleName)) {\n                    var valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\n                    var groupedValues = this.grouped[groupIndex].values[valueColumnIndex];\n                    return getHighlight ? groupedValues.highlights[categoryIndex] : groupedValues.values[categoryIndex];\n                }\n            };\n            DataViewCategoricalReader.prototype.getFirstNonNullValueForCategory = function (roleName, categoryIndex) {\n                if (this.hasValues(roleName)) {\n                    if (!this.dataHasDynamicSeries) {\n                        debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\n                        return this.getValue(roleName, categoryIndex);\n                    }\n                    for (var seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\n                        var value = this.getValue(roleName, categoryIndex, seriesIndex);\n                        if (value != null) {\n                            return value;\n                        }\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getMeasureQueryName = function (roleName) {\n                if (this.hasValues(roleName))\n                    return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\n            };\n            DataViewCategoricalReader.prototype.getValueColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\n                    }\n                    else {\n                        return this.grouped[0].values[this.valueRoleIndexMapping[roleName][seriesIndex]];\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getValueMetadataColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                var valueColumn = this.getValueColumn(roleName, seriesIndex);\n                if (valueColumn) {\n                    return valueColumn.source;\n                }\n            };\n            DataViewCategoricalReader.prototype.getValueDisplayName = function (roleName, seriesIndex) {\n                if (this.hasValues(roleName)) {\n                    var targetColumn = this.getValueColumn(roleName, seriesIndex);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            // Series methods\n            DataViewCategoricalReader.prototype.hasDynamicSeries = function () {\n                return this.dataHasDynamicSeries;\n            };\n            DataViewCategoricalReader.prototype.getSeriesCount = function (valueRoleName) {\n                if (this.hasAnyValidValues) {\n                    if (this.dataHasDynamicSeries) {\n                        return this.grouped.length;\n                    }\n                    else if (valueRoleName) {\n                        return this.valueRoleIndexMapping[valueRoleName].length;\n                    }\n                    else {\n                        return 1;\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getSeriesObjects = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].objects;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumns = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumnGroup = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex];\n            };\n            DataViewCategoricalReader.prototype.getSeriesMetadataColumn = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.source;\n            };\n            DataViewCategoricalReader.prototype.getSeriesColumnIdentityFields = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.identityFields;\n            };\n            DataViewCategoricalReader.prototype.getSeriesName = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].name;\n            };\n            DataViewCategoricalReader.prototype.getSeriesDisplayName = function () {\n                if (this.hasAnyValidValues && this.dataHasDynamicSeries)\n                    return this.dataView.categorical.values.source.displayName;\n            };\n            return DataViewCategoricalReader;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var valueFormatter = powerbi.visuals.valueFormatter;\n        var DataViewConcatenateCategoricalColumns;\n        (function (DataViewConcatenateCategoricalColumns) {\n            function detectAndApply(dataView, objectDescriptors, roleMappings, projectionOrdering, selects, projectionActiveItems) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                var result = dataView;\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical) {\n                    var concatenationSource = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\n                    if (concatenationSource) {\n                        // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\n                        var columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\n                        if (columnsSortedByProjectionOrdering.length >= 2) {\n                            var activeItemsToIgnoreInConcatenation = _.chain(projectionActiveItems[concatenationSource.roleName])\n                                .filter(function (activeItemInfo) { return activeItemInfo.suppressConcat; })\n                                .map(function (activeItemInfo) { return activeItemInfo.queryRef; })\n                                .value();\n                            result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\n                        }\n                    }\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.detectAndApply = detectAndApply;\n            /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\n            function applyToPlayChartCategorical(metadata, objectDescriptors, categoryRoleName, categorical) {\n                debug.assertValue(metadata, 'metadata');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(categorical, 'categorical');\n                var result;\n                if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\n                    // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\n                    // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\n                    // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\n                    // use inherit() rather than inheritSingle() here.\n                    var transformingColumns_1 = inherit(metadata.columns);\n                    var transformingMetadata = inherit(metadata, function (m) { m.columns = transformingColumns_1; });\n                    var transformingDataView = { metadata: transformingMetadata, categorical: categorical };\n                    result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\n                }\n                else {\n                    result = { metadata: metadata, categorical: categorical };\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical = applyToPlayChartCategorical;\n            /**\n             * Returns the role and its assocated category columns (from dataViewCategorical.categories)\n             * that should be concatenated for the case of hierarchical group.\n             *\n             * Note: In the future if we support sibling hierarchical groups in categorical,\n             * change the return type to CategoryColumnsByRole[] and update detection logic.\n             */\n            function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, metadata, dataViewMappings, selects, projectionActiveItems) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\n                var result;\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var supportedRoleMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                // The following code will choose a role name only if all supportedRoleMappings share the same role for Categorical Category.\n                // Handling multiple supportedRoleMappings is necessary for TransformActions with splits, which can happen in scenarios such as:\n                // 1. combo chart with a field for both Line and Column values, and\n                // 2. chart with regression line enabled.\n                // In case 1, you can pretty much get exactly the one from supportedRoleMappings for which this code is currently processing for,\n                // by looking at the index of the current split in DataViewTransformActions.splits.\n                // In case 2, however, supportedRoleMappings.length will be different than DataViewTransformActions.splits.length, hence it is\n                // not straight forward to figure out for which one in supportedRoleMappings is this code currently processing.\n                // SO... This code will just choose the category role name if it is consistent across all supportedRoleMappings.\n                var isEveryRoleMappingForCategorical = !_.isEmpty(supportedRoleMappings) &&\n                    _.every(supportedRoleMappings, function (roleMapping) { return !!roleMapping.categorical; });\n                if (isEveryRoleMappingForCategorical) {\n                    var targetRoleName_1 = getSingleCategoryRoleNameInEveryRoleMapping(supportedRoleMappings);\n                    if (targetRoleName_1 &&\n                        isVisualExpectingMaxOneCategoryColumn(targetRoleName_1, supportedRoleMappings)) {\n                        var categoryColumnsForTargetRole_1 = _.filter(dataViewCategorical.categories, function (categoryColumn) { return categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName_1]; });\n                        // There is no need to concatenate columns unless there is actually more than one column\n                        if (categoryColumnsForTargetRole_1.length >= 2) {\n                            // At least for now, we expect all category columns for the same role to have the same number of value entries.\n                            // If that's not the case, we won't run the concatenate logic for that role at all...\n                            var areValuesCountsEqual = _.every(categoryColumnsForTargetRole_1, function (categoryColumn) { return categoryColumn.values.length === categoryColumnsForTargetRole_1[0].values.length; });\n                            if (areValuesCountsEqual) {\n                                result = {\n                                    roleName: targetRoleName_1,\n                                    categories: categoryColumnsForTargetRole_1,\n                                };\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n            /** If all mappings in the specified roleMappings have the same single role name for their categorical category roles, return that role name, else returns undefined. */\n            function getSingleCategoryRoleNameInEveryRoleMapping(categoricalRoleMappings) {\n                debug.assertNonEmpty(categoricalRoleMappings, 'categoricalRoleMappings');\n                debug.assert(_.every(categoricalRoleMappings, function (roleMapping) { return !!roleMapping.categorical; }), 'All mappings in categoricalRoleMappings must contain a DataViewCategoricalMapping');\n                var result;\n                // With \"list\" in role mapping, it is possible to have multiple role names for category.\n                // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\n                // We can change this if we want to support independent (sibling) group hierarchies in categorical.\n                var uniqueCategoryRoles = _.chain(categoricalRoleMappings)\n                    .map(function (roleMapping) {\n                    var categoryRoles = getAllRolesInCategories(roleMapping.categorical);\n                    return categoryRoles.length === 1 ? categoryRoles[0] : undefined;\n                })\n                    .uniq() // Note: _.uniq() does not treat two arrays with same elements as equal\n                    .value();\n                var isSameCategoryRoleNameInAllRoleMappings = uniqueCategoryRoles.length === 1 && !_.isUndefined(uniqueCategoryRoles[0]);\n                if (isSameCategoryRoleNameInAllRoleMappings) {\n                    result = uniqueCategoryRoles[0];\n                }\n                return result;\n            }\n            function isVisualExpectingMaxOneCategoryColumn(categoricalRoleName, roleMappings) {\n                debug.assertValue(categoricalRoleName, 'categoricalRoleName');\n                debug.assertNonEmpty(roleMappings, 'roleMappings');\n                var isVisualExpectingMaxOneCategoryColumn = _.every(roleMappings, function (roleMapping) {\n                    return !_.isEmpty(roleMapping.conditions) &&\n                        _.every(roleMapping.conditions, function (condition) { return condition[categoricalRoleName] && condition[categoricalRoleName].max === 1; });\n                });\n                return isVisualExpectingMaxOneCategoryColumn;\n            }\n            /**\n             * Returns the array of role names that are mapped to categorical categories.\n             * Returns an empty array if none exists.\n             */\n            function getAllRolesInCategories(categoricalRoleMapping) {\n                debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\n                var roleNames = [];\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalRoleMapping.categories, {\n                    visitRole: function (roleName) {\n                        roleNames.push(roleName);\n                    }\n                });\n                return roleNames;\n            }\n            function applyConcatenation(dataView, objectDescriptors, roleName, columnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(roleName, 'roleName');\n                debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\n                var formatStringPropId = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                var concatenatedValues = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\n                var columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, function (categoryColumn) { return categoryColumn.source; });\n                var concatenatedColumnMetadata = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\n                var transformedDataView = inheritSingle(dataView);\n                addToMetadata(transformedDataView, concatenatedColumnMetadata);\n                var concatenatedCategoryColumn = createConcatenatedCategoryColumn(columnsSortedByProjectionOrdering, concatenatedColumnMetadata, concatenatedValues);\n                var dataViewCategorical = dataView.categorical;\n                var transformedCategoricalCategories = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\n                transformedCategoricalCategories.push(concatenatedCategoryColumn);\n                var transformedCategorical = inheritSingle(dataViewCategorical);\n                transformedCategorical.categories = transformedCategoricalCategories;\n                transformedDataView.categorical = transformedCategorical;\n                return transformedDataView;\n            }\n            function concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId) {\n                debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\n                debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\n                debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\n                var concatenatedValues = [];\n                // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\n                for (var _i = 0, columnsSortedByProjectionOrdering_1 = columnsSortedByProjectionOrdering; _i < columnsSortedByProjectionOrdering_1.length; _i++) {\n                    var categoryColumn = columnsSortedByProjectionOrdering_1[_i];\n                    var formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\n                    for (var i = 0, len = categoryColumn.values.length; i < len; i++) {\n                        if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\n                            var value = categoryColumn.values && categoryColumn.values[i];\n                            var formattedValue = valueFormatter.format(value, formatString);\n                            concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\n                        }\n                    }\n                }\n                return concatenatedValues;\n            }\n            /**\n            * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\n            */\n            function sortColumnsByProjectionOrdering(projectionOrdering, roleName, columns) {\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                debug.assertValue(roleName, 'roleName');\n                debug.assertValue(columns, 'columns');\n                var columnsInProjectionOrdering;\n                if (projectionOrdering) {\n                    // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\n                    var columnsByIndex_1 = {};\n                    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n                        var column = columns_1[_i];\n                        if (column.source.roles[roleName]) {\n                            debug.assert(!columnsByIndex_1[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\n                            columnsByIndex_1[column.source.index] = column;\n                        }\n                    }\n                    var columnIndicesInProjectionOrdering = projectionOrdering[roleName];\n                    columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\n                        .map(function (columnIndex) { return columnsByIndex_1[columnIndex]; })\n                        .filter(function (column) { return !!column; })\n                        .value();\n                }\n                else {\n                    // If projectionOrder is unspecified, just return the columns for the specified role in their current order\n                    columnsInProjectionOrdering = _.filter(columns, function (column) { return column.source.roles[roleName]; });\n                }\n                return columnsInProjectionOrdering;\n            }\n            /**\n             * Creates the column metadata that will back the column with the concatenated values.\n             */\n            function createConcatenatedColumnMetadata(roleName, sourceColumnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(roleName, 'roleName');\n                debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\n                debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(function (c) { return c.isMeasure; }).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\n                var concatenatedDisplayName;\n                for (var _i = 0, sourceColumnsSortedByProjectionOrdering_1 = sourceColumnsSortedByProjectionOrdering; _i < sourceColumnsSortedByProjectionOrdering_1.length; _i++) {\n                    var columnSource = sourceColumnsSortedByProjectionOrdering_1[_i];\n                    if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\n                        concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\n                    }\n                }\n                var newRoles = {};\n                newRoles[roleName] = true;\n                var newColumnMetadata = {\n                    displayName: concatenatedDisplayName,\n                    roles: newRoles,\n                    type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Text)\n                };\n                var columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\n                if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\n                    newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\n                }\n                // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\n                // If queryName is not set at all, the column chart visual will only render column for the first group instance.\n                // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\n                newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\n                return newColumnMetadata;\n            }\n            function addToMetadata(transformedDataView, newColumn) {\n                debug.assertValue(transformedDataView, 'transformedDataView');\n                debug.assertValue(newColumn, 'newColumn');\n                var transformedColumns = inheritSingle(transformedDataView.metadata.columns);\n                transformedColumns.push(newColumn);\n                var transformedMetadata = inheritSingle(transformedDataView.metadata);\n                transformedMetadata.columns = transformedColumns;\n                transformedDataView.metadata = transformedMetadata;\n            }\n            function createConcatenatedCategoryColumn(sourceColumnsSortedByProjectionOrdering, columnMetadata, concatenatedValues) {\n                debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\n                var newCategoryColumn = {\n                    source: columnMetadata,\n                    values: concatenatedValues\n                };\n                // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\n                // So, we'll just take the identities and identityFields from the first column\n                var firstColumn = sourceColumnsSortedByProjectionOrdering[0];\n                if (firstColumn.identity) {\n                    newCategoryColumn.identity = firstColumn.identity;\n                }\n                if (firstColumn.identityFields) {\n                    newCategoryColumn.identityFields = firstColumn.identityFields;\n                }\n                // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\n                if (firstColumn.objects) {\n                    newCategoryColumn.objects = firstColumn.objects;\n                }\n                return newCategoryColumn;\n            }\n        })(DataViewConcatenateCategoricalColumns = data.DataViewConcatenateCategoricalColumns || (data.DataViewConcatenateCategoricalColumns = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewMapping;\n    (function (DataViewMapping) {\n        function visitMapping(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var categorical = mapping.categorical;\n            if (categorical)\n                visitCategorical(categorical, visitor);\n            var table = mapping.table;\n            if (table)\n                visitTable(table, visitor);\n            var matrix = mapping.matrix;\n            if (matrix)\n                visitMatrix(matrix, visitor);\n            var tree = mapping.tree;\n            if (tree)\n                visitTree(tree, visitor);\n            var single = mapping.single;\n            if (single)\n                visitSingle(single, visitor);\n        }\n        DataViewMapping.visitMapping = visitMapping;\n        function visitCategorical(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitCategoricalCategories(mapping.categories, visitor);\n            visitCategoricalValues(mapping.values, visitor);\n        }\n        DataViewMapping.visitCategorical = visitCategorical;\n        function visitCategoricalCategories(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor);\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitCategoricalCategories = visitCategoricalCategories;\n        function visitCategoricalValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor, 0 /* CategoricalValue */);\n                visitFor(mapping, visitor, 0 /* CategoricalValue */);\n                visitList(mapping, visitor, 0 /* CategoricalValue */);\n                var groupedRoleMapping = mapping;\n                visitGrouped(groupedRoleMapping, visitor);\n                var group = groupedRoleMapping.group;\n                if (group) {\n                    for (var _i = 0, _a = group.select; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        visitBind(item, visitor, 1 /* CategoricalValueGroup */);\n                        visitFor(item, visitor, 1 /* CategoricalValueGroup */);\n                    }\n                }\n            }\n        }\n        DataViewMapping.visitCategoricalValues = visitCategoricalValues;\n        function visitTable(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var rows = mapping.rows;\n            visitBind(rows, visitor);\n            visitFor(rows, visitor);\n            visitList(rows, visitor);\n            visitReduction(rows, visitor);\n        }\n        DataViewMapping.visitTable = visitTable;\n        function visitMatrix(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitMatrixItems(mapping.rows, visitor);\n            visitMatrixItems(mapping.columns, visitor);\n            visitMatrixItems(mapping.values, visitor);\n        }\n        /**\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         *\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         * @param visitor The visitor.\n         */\n        function visitMatrixItems(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitMatrixItems = visitMatrixItems;\n        function visitTree(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitTreeNodes(mapping.nodes, visitor);\n            visitTreeValues(mapping.values, visitor);\n        }\n        function visitTreeNodes(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeNodes = visitTreeNodes;\n        function visitTreeValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeValues = visitTreeValues;\n        function visitBind(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var bind = mapping.bind;\n            if (bind) {\n                if (context != null)\n                    visitor.visitRole(bind.to, context);\n                else\n                    visitor.visitRole(bind.to);\n            }\n        }\n        function visitFor(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var forValue = mapping.for;\n            if (forValue) {\n                if (context != null)\n                    visitor.visitRole(forValue.in, context);\n                else\n                    visitor.visitRole(forValue.in);\n            }\n        }\n        function visitList(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var select = mapping.select;\n            if (select) {\n                for (var _i = 0, select_1 = select; _i < select_1.length; _i++) {\n                    var item = select_1[_i];\n                    visitBind(item, visitor, context);\n                    visitFor(item, visitor, context);\n                }\n            }\n        }\n        function visitGrouped(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (!mapping)\n                return;\n            var group = mapping.group;\n            if (group) {\n                visitor.visitRole(group.by);\n                visitReduction(group, visitor);\n            }\n        }\n        DataViewMapping.visitGrouped = visitGrouped;\n        function visitReduction(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (visitor.visitReduction) {\n                var reductionAlgorithm = mapping.dataReductionAlgorithm;\n                if (reductionAlgorithm) {\n                    visitor.visitReduction(reductionAlgorithm);\n                }\n            }\n        }\n        function visitSingle(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitor.visitRole(mapping.role);\n        }\n    })(DataViewMapping = powerbi.DataViewMapping || (powerbi.DataViewMapping = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewNormalizeValues;\n        (function (DataViewNormalizeValues) {\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                var rolesToNormalize = _.filter(options.dataRoles, function (role) { return !_.isEmpty(role.requiredTypes); });\n                filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\n            }\n            DataViewNormalizeValues.apply = apply;\n            function filterVariantMeasures(dataview, dataViewMappings, rolesToNormalize) {\n                debug.assertValue(dataview, 'dataview');\n                // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\n                    return;\n                var columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\n                var valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\n                var usedMappings = {};\n                for (var _i = 0, dataViewMappings_1 = dataViewMappings; _i < dataViewMappings_1.length; _i++) {\n                    var dataViewMapping = dataViewMappings_1[_i];\n                    // Get dataview specified in mappings which are also in dataview\n                    for (var dataViewMappingProp in dataViewMapping) {\n                        if (dataview[dataViewMappingProp] != null)\n                            usedMappings[dataViewMappingProp] = true;\n                    }\n                }\n                if (usedMappings['categorical'])\n                    filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\n                if (usedMappings['table'])\n                    filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\n                if (usedMappings['tree'])\n                    filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\n                if (usedMappings['matrix'])\n                    filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\n                if (usedMappings['single'])\n                    filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\n            }\n            DataViewNormalizeValues.filterVariantMeasures = filterVariantMeasures;\n            function generateMetadataColumnFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return false; };\n                var columnsToNormalize = {};\n                for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {\n                    var column = columns_2[_i];\n                    var roles = column.roles;\n                    if (!roles)\n                        continue;\n                    for (var _a = 0, rolesToNormalize_1 = rolesToNormalize; _a < rolesToNormalize_1.length; _a++) {\n                        var role = rolesToNormalize_1[_a];\n                        if (!roles[role.name])\n                            continue;\n                        columnsToNormalize[column.index] = true;\n                        break;\n                    }\n                }\n                return function (columnIndex) {\n                    if (isNaN(columnIndex))\n                        return false;\n                    return !!columnsToNormalize[columnIndex];\n                };\n            }\n            DataViewNormalizeValues.generateMetadataColumnFilter = generateMetadataColumnFilter;\n            function generateValueFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return true; };\n                var columnValueFilters = [];\n                // Build columnValueFilters based on role requiredTypes\n                for (var _i = 0, columns_3 = columns; _i < columns_3.length; _i++) {\n                    var column = columns_3[_i];\n                    var columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\n                    if (columnValueFilter)\n                        columnValueFilters[column.index] = columnValueFilter;\n                }\n                return function (columnIndex, value) {\n                    if (columnValueFilters[columnIndex])\n                        return columnValueFilters[columnIndex](value);\n                    return true;\n                };\n            }\n            DataViewNormalizeValues.generateValueFilter = generateValueFilter;\n            function generateColumnValueFilter(column, rolesToNormalize) {\n                var requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\n                if (_.isEmpty(requiredTypes))\n                    return;\n                return function (value) {\n                    return doesValueMatchTypes(value, requiredTypes);\n                };\n            }\n            function getColumnRequiredTypes(column, rolesToNormalize) {\n                var requiredTypes = [];\n                var columnRoles = column && column.roles;\n                if (!columnRoles)\n                    return requiredTypes;\n                for (var _i = 0, rolesToNormalize_2 = rolesToNormalize; _i < rolesToNormalize_2.length; _i++) {\n                    var role = rolesToNormalize_2[_i];\n                    if (!columnRoles[role.name])\n                        continue;\n                    for (var _a = 0, _b = role.requiredTypes; _a < _b.length; _a++) {\n                        var typeDescriptor = _b[_a];\n                        var type = powerbi.ValueType.fromDescriptor(typeDescriptor);\n                        requiredTypes.push(type);\n                    }\n                }\n                return requiredTypes;\n            }\n            DataViewNormalizeValues.getColumnRequiredTypes = getColumnRequiredTypes;\n            function filterVariantMeasuresCategorical(dataview, columnFilter, valueFilter) {\n                var values = dataview && dataview.values;\n                if (!values)\n                    return;\n                var valuesGrouped = values.grouped();\n                if (!valuesGrouped)\n                    return;\n                for (var _i = 0, valuesGrouped_1 = valuesGrouped; _i < valuesGrouped_1.length; _i++) {\n                    var valueGroup = valuesGrouped_1[_i];\n                    var valuesInGroup = valueGroup.values;\n                    for (var _a = 0, valuesInGroup_1 = valuesInGroup; _a < valuesInGroup_1.length; _a++) {\n                        var valueColumn = valuesInGroup_1[_a];\n                        var columnIndex = valueColumn.source.index;\n                        if (!columnFilter(columnIndex))\n                            continue;\n                        for (var i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\n                            valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\n                        }\n                    }\n                }\n            }\n            function filterVariantMeasuresTable(dataview, columnFilter, valueFilter) {\n                var columns = dataview && dataview.columns;\n                if (!columns)\n                    return;\n                var filteredColumns = [];\n                for (var _i = 0, columns_4 = columns; _i < columns_4.length; _i++) {\n                    var column = columns_4[_i];\n                    if (columnFilter(column.index))\n                        filteredColumns.push(column.index);\n                }\n                var rows = dataview.rows;\n                for (var i = 0, ilen = rows.length; i < ilen; i++) {\n                    for (var _a = 0, filteredColumns_1 = filteredColumns; _a < filteredColumns_1.length; _a++) {\n                        var index = filteredColumns_1[_a];\n                        rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresTreeNode(node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var columnIndex in node.values) {\n                        // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\n                        if (columnFilter(columnIndex)) {\n                            // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\n                            if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\n                                node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', columnIndex, valueFilter);\n                            else\n                                node.values = normalizeVariant(node.values, columnIndex, columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresMatrix(dataview, columnFilter, valueFilter) {\n                var root = dataview && dataview.rows && dataview.rows.root;\n                if (!root)\n                    return;\n                // Recurse into rows.children\n                // e.g. rows.children -> .children -> .children.values\n                filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\n            }\n            function filterVariantMeasuresMatrixRecursive(dataviewMatrix, node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var id in node.values) {\n                        // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\n                        var nodeValue = node.values[id];\n                        // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\n                        var valueSourceIndex = nodeValue.valueSourceIndex || 0;\n                        // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\n                        var columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\n                        if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\n                            node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter) {\n                if (!dataview.single)\n                    return;\n                var roleNames = [];\n                for (var _i = 0, rolesToNormalize_3 = rolesToNormalize; _i < rolesToNormalize_3.length; _i++) {\n                    var role = rolesToNormalize_3[_i];\n                    if (role.name)\n                        roleNames.push(role.name);\n                }\n                var columns = dataview.metadata.columns;\n                for (var _a = 0, dataViewMappings_2 = dataViewMappings; _a < dataViewMappings_2.length; _a++) {\n                    var dataViewMapping = dataViewMappings_2[_a];\n                    var roleName = dataViewMapping.single.role;\n                    if (roleNames.indexOf(roleName) !== -1) {\n                        var column = firstColumnByRoleName(columns, roleName);\n                        if (column)\n                            dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\n                        return;\n                    }\n                }\n            }\n            function normalizeVariant(object, key, columnIndex, valueFilter) {\n                if (!object)\n                    return;\n                var value = object[key];\n                if (value !== null && !valueFilter(columnIndex, value)) {\n                    object = inheritSingle(object);\n                    object[key] = null;\n                }\n                return object;\n            }\n            DataViewNormalizeValues.normalizeVariant = normalizeVariant;\n            function doesValueMatchTypes(value, types) {\n                for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n                    var type = types_1[_i];\n                    if (type.numeric || type.integer)\n                        return typeof (value) === 'number';\n                }\n                return false;\n            }\n            function firstColumnByRoleName(columns, roleName) {\n                for (var _i = 0, columns_5 = columns; _i < columns_5.length; _i++) {\n                    var column = columns_5[_i];\n                    var columnRoles = column && column.roles;\n                    if (columnRoles && columnRoles[roleName])\n                        return column;\n                }\n            }\n        })(DataViewNormalizeValues = data.DataViewNormalizeValues || (data.DataViewNormalizeValues = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewObjects;\n    (function (DataViewObjects) {\n        /** Gets the value of the given object/property pair. */\n        function getValue(objects, propertyId, defaultValue) {\n            debug.assertAnyValue(objects, 'objects');\n            debug.assertValue(propertyId, 'propertyId');\n            if (!objects)\n                return defaultValue;\n            var objectOrMap = objects[propertyId.objectName];\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\n            var object = objectOrMap;\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\n        }\n        DataViewObjects.getValue = getValue;\n        /** Gets an object from objects. */\n        function getObject(objects, objectName, defaultValue) {\n            if (objects && objects[objectName]) {\n                var object = objects[objectName];\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\n                return object;\n            }\n            else {\n                return defaultValue;\n            }\n        }\n        DataViewObjects.getObject = getObject;\n        /** Gets a map of user-defined objects. */\n        function getUserDefinedObjects(objects, objectName) {\n            if (objects && objects[objectName]) {\n                var map = objects[objectName];\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\n                return map;\n            }\n        }\n        DataViewObjects.getUserDefinedObjects = getUserDefinedObjects;\n        /** Gets the solid color from a fill property. */\n        function getFillColor(objects, propertyId, defaultColor) {\n            var value = getValue(objects, propertyId);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObjects.getFillColor = getFillColor;\n        /** Returns true if the given object represents a collection of user-defined objects */\n        function isUserDefined(objectOrMap) {\n            return _.isArray(objectOrMap);\n        }\n        DataViewObjects.isUserDefined = isUserDefined;\n    })(DataViewObjects = powerbi.DataViewObjects || (powerbi.DataViewObjects = {}));\n    var DataViewObject;\n    (function (DataViewObject) {\n        function getValue(object, propertyName, defaultValue) {\n            debug.assertAnyValue(object, 'object');\n            debug.assertValue(propertyName, 'propertyName');\n            if (!object)\n                return defaultValue;\n            var propertyValue = object[propertyName];\n            if (propertyValue === undefined)\n                return defaultValue;\n            return propertyValue;\n        }\n        DataViewObject.getValue = getValue;\n        /** Gets the solid color from a fill property using only a propertyName */\n        function getFillColorByPropertyName(objects, propertyName, defaultColor) {\n            var value = DataViewObject.getValue(objects, propertyName);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;\n    })(DataViewObject = powerbi.DataViewObject || (powerbi.DataViewObject = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var JsonComparer = jsCommon.JsonComparer;\n        var DataViewObjectDefinitions;\n        (function (DataViewObjectDefinitions) {\n            /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\n            function ensure(defns, objectName, selector) {\n                debug.assertValue(defns, 'defns');\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    defns[objectName] = defnsForObject = [];\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n                var newDefn = {\n                    selector: selector,\n                    properties: {},\n                };\n                defnsForObject.push(newDefn);\n                return newDefn;\n            }\n            DataViewObjectDefinitions.ensure = ensure;\n            function deleteProperty(defns, objectName, selector, propertyName) {\n                debug.assertValue(defns, 'defns');\n                var defn = getObjectDefinition(defns, objectName, selector);\n                if (!defn)\n                    return;\n                DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\n            }\n            DataViewObjectDefinitions.deleteProperty = deleteProperty;\n            function setValue(defns, propertyId, selector, value) {\n                debug.assertValue(defns, 'defns');\n                debug.assertValue(propertyId, 'propertyId');\n                ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\n            }\n            DataViewObjectDefinitions.setValue = setValue;\n            function getValue(defns, propertyId, selector) {\n                var properties = getPropertyContainer(defns, propertyId, selector);\n                if (!properties)\n                    return;\n                return properties[propertyId.propertyName];\n            }\n            DataViewObjectDefinitions.getValue = getValue;\n            function getPropertyContainer(defns, propertyId, selector) {\n                var defn = getObjectDefinition(defns, propertyId.objectName, selector);\n                if (!defn)\n                    return;\n                return defn.properties;\n            }\n            DataViewObjectDefinitions.getPropertyContainer = getPropertyContainer;\n            function getObjectDefinition(defns, objectName, selector) {\n                debug.assertAnyValue(defns, 'defns');\n                debug.assertValue(objectName, 'objectName');\n                debug.assertAnyValue(selector, 'selector');\n                if (!defns)\n                    return;\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    return;\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n            }\n            DataViewObjectDefinitions.getObjectDefinition = getObjectDefinition;\n            function propertiesAreEqual(a, b) {\n                if (a instanceof data.SemanticFilter && b instanceof data.SemanticFilter) {\n                    return data.SemanticFilter.isSameFilter(a, b);\n                }\n                return JsonComparer.equals(a, b);\n            }\n            DataViewObjectDefinitions.propertiesAreEqual = propertiesAreEqual;\n            function allPropertiesAreEqual(a, b) {\n                debug.assertValue(a, 'a');\n                debug.assertValue(b, 'b');\n                if (Object.keys(a).length !== Object.keys(b).length)\n                    return false;\n                for (var property in a) {\n                    if (!propertiesAreEqual(a[property], b[property]))\n                        return false;\n                }\n                return true;\n            }\n            DataViewObjectDefinitions.allPropertiesAreEqual = allPropertiesAreEqual;\n            function encodePropertyValue(value, valueTypeDescriptor) {\n                debug.assertAnyValue(value, 'value');\n                debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\n                if (valueTypeDescriptor.bool) {\n                    if (typeof (value) !== 'boolean')\n                        value = false; // This is fallback, which doesn't really belong here.\n                    return data.SQExprBuilder.boolean(value);\n                }\n                else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\n                    return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.numeric) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                }\n                else if (valueTypeDescriptor.fill) {\n                    if (value) {\n                        return {\n                            solid: { color: data.SQExprBuilder.text(value) }\n                        };\n                    }\n                }\n                else if (valueTypeDescriptor.formatting) {\n                    if (valueTypeDescriptor.formatting.labelDisplayUnits) {\n                        return data.SQExprBuilder.double(+value);\n                    }\n                    else {\n                        return data.SQExprBuilder.text(value);\n                    }\n                }\n                else if (valueTypeDescriptor.enumeration) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                    else\n                        return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.misc) {\n                    if (value) {\n                        value = data.SQExprBuilder.text(value);\n                    }\n                    else {\n                        value = null;\n                    }\n                }\n                else if (valueTypeDescriptor.image) {\n                    if (value) {\n                        var imageValue = value;\n                        var imageDefinition = {\n                            name: data.SQExprBuilder.text(imageValue.name),\n                            url: data.SQExprBuilder.text(imageValue.url),\n                        };\n                        if (imageValue.scaling)\n                            imageDefinition.scaling = data.SQExprBuilder.text(imageValue.scaling);\n                        return imageDefinition;\n                    }\n                }\n                return value;\n            }\n            DataViewObjectDefinitions.encodePropertyValue = encodePropertyValue;\n            function clone(original) {\n                debug.assertValue(original, 'original');\n                var cloned = {};\n                for (var objectName in original) {\n                    var originalDefns = original[objectName];\n                    if (_.isEmpty(originalDefns))\n                        continue;\n                    var clonedDefns = [];\n                    for (var _i = 0, originalDefns_1 = originalDefns; _i < originalDefns_1.length; _i++) {\n                        var originalDefn = originalDefns_1[_i];\n                        clonedDefns.push({\n                            properties: cloneProperties(originalDefn.properties),\n                            selector: originalDefn.selector,\n                        });\n                    }\n                    cloned[objectName] = clonedDefns;\n                }\n                return cloned;\n            }\n            DataViewObjectDefinitions.clone = clone;\n            function cloneProperties(original) {\n                debug.assertValue(original, 'original');\n                // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\n                return _.clone(original);\n            }\n        })(DataViewObjectDefinitions = data.DataViewObjectDefinitions || (data.DataViewObjectDefinitions = {}));\n        var DataViewObjectDefinition;\n        (function (DataViewObjectDefinition) {\n            function deleteSingleProperty(defn, propertyName) {\n                //note: We decided that delete is acceptable here and that we don't need optimization here\n                delete defn.properties[propertyName];\n            }\n            DataViewObjectDefinition.deleteSingleProperty = deleteSingleProperty;\n        })(DataViewObjectDefinition = data.DataViewObjectDefinition || (data.DataViewObjectDefinition = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectDescriptors;\n        (function (DataViewObjectDescriptors) {\n            /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\n            function findFormatString(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var formattingTypeDesc = powerbi.ValueType.fromDescriptor(propDesc.type).formatting;\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\n                });\n            }\n            DataViewObjectDescriptors.findFormatString = findFormatString;\n            /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\n            function findFilterOutput(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.filter;\n                });\n            }\n            DataViewObjectDescriptors.findFilterOutput = findFilterOutput;\n            /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\n            function findDefaultValue(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.expression && propType.expression.defaultValue;\n                });\n            }\n            DataViewObjectDescriptors.findDefaultValue = findDefaultValue;\n            function findProperty(descriptors, propPredicate) {\n                debug.assertAnyValue(descriptors, 'descriptors');\n                debug.assertAnyValue(propPredicate, 'propPredicate');\n                if (!descriptors)\n                    return;\n                for (var objectName in descriptors) {\n                    var objPropDescs = descriptors[objectName].properties;\n                    for (var propertyName in objPropDescs) {\n                        if (propPredicate(objPropDescs[propertyName])) {\n                            return {\n                                objectName: objectName,\n                                propertyName: propertyName,\n                            };\n                        }\n                    }\n                }\n            }\n        })(DataViewObjectDescriptors = data.DataViewObjectDescriptors || (data.DataViewObjectDescriptors = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n*  Power BI Visualizations\n*\n*  Copyright (c) Microsoft Corporation\n*  All rights reserved.\n *  MIT License\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n*\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n*  THE SOFTWARE.\n*/\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectEvaluationUtils;\n        (function (DataViewObjectEvaluationUtils) {\n            function evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var objects;\n                for (var j = 0, jlen = objectDefns.length; j < jlen; j++) {\n                    var objectDefinition = objectDefns[j], objectName = objectDefinition.name;\n                    var evaluatedObject = data.DataViewObjectEvaluator.run(evalContext, objectDescriptors[objectName], objectDefinition.properties);\n                    if (!evaluatedObject)\n                        continue;\n                    if (!objects)\n                        objects = {};\n                    // NOTE: this currently has last-object-wins semantics.\n                    objects[objectName] = evaluatedObject;\n                }\n                return objects;\n            }\n            DataViewObjectEvaluationUtils.evaluateDataViewObjects = evaluateDataViewObjects;\n            function groupObjectsBySelector(objectDefinitions) {\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                var grouped = {\n                    data: [],\n                };\n                if (objectDefinitions) {\n                    for (var objectName in objectDefinitions) {\n                        var objectDefnList = objectDefinitions[objectName];\n                        for (var i = 0, len = objectDefnList.length; i < len; i++) {\n                            var objectDefn = objectDefnList[i];\n                            ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\n                                name: objectName,\n                                properties: objectDefn.properties,\n                            });\n                        }\n                    }\n                }\n                return grouped;\n            }\n            DataViewObjectEvaluationUtils.groupObjectsBySelector = groupObjectsBySelector;\n            function ensureDefinitionListForSelector(grouped, selector) {\n                debug.assertValue(grouped, 'grouped');\n                debug.assertAnyValue(selector, 'selector');\n                if (!selector) {\n                    if (!grouped.metadataOnce)\n                        grouped.metadataOnce = { objects: [] };\n                    return grouped.metadataOnce;\n                }\n                var groupedObjects;\n                if (selector.data) {\n                    groupedObjects = grouped.data;\n                }\n                else if (selector.metadata) {\n                    if (!grouped.metadata)\n                        grouped.metadata = [];\n                    groupedObjects = grouped.metadata;\n                }\n                else if (selector.id) {\n                    if (!grouped.userDefined)\n                        grouped.userDefined = [];\n                    groupedObjects = grouped.userDefined;\n                }\n                debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\n                for (var _i = 0, groupedObjects_1 = groupedObjects; _i < groupedObjects_1.length; _i++) {\n                    var item_1 = groupedObjects_1[_i];\n                    if (data.Selector.equals(selector, item_1.selector))\n                        return item_1;\n                }\n                var item = {\n                    selector: selector,\n                    objects: [],\n                };\n                groupedObjects.push(item);\n                return item;\n            }\n            function addImplicitObjects(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                if (selectTransforms) {\n                    addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                    addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                }\n            }\n            DataViewObjectEvaluationUtils.addImplicitObjects = addImplicitObjects;\n            function addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                if (!formatStringProp)\n                    return;\n                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                    var selectTransform = selectTransforms[selectIdx];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyFormatString(objectsForAllSelectors, formatStringProp, selectTransform.queryName, selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\n                }\n            }\n            /** Registers properties for default value, if the properties are not explicitly provided. */\n            function addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var defaultValueProp = data.DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\n                if (!defaultValueProp)\n                    return;\n                for (var _i = 0, selectTransforms_1 = selectTransforms; _i < selectTransforms_1.length; _i++) {\n                    var selectTransform = selectTransforms_1[_i];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyDefaultValue(objectsForAllSelectors, defaultValueProp, selectTransform.queryName, selectTransform.defaultValue);\n                }\n            }\n            function getColumnFormatForIndex(columns, selectIdx) {\n                for (var columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\n                    var column = columns[columnIdx];\n                    if (!column || column.index !== selectIdx)\n                        continue;\n                    return column.format;\n                }\n            }\n            function applyFormatString(objectsForAllSelectors, formatStringProp, queryName, formatStringValue) {\n                if (!formatStringValue)\n                    return;\n                // There is a format string specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, formatStringProp, { metadata: queryName }, data.SQExprBuilder.text(formatStringValue));\n            }\n            function applyDefaultValue(objectsForAllSelectors, defaultValueProp, queryName, defaultValue) {\n                if (!defaultValue)\n                    return;\n                // There is a default value specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, defaultValueProp, { metadata: queryName }, defaultValue);\n            }\n            function applyMetadataProperty(objectsForAllSelectors, propertyId, selector, value) {\n                var objectDefns;\n                if (selector) {\n                    var metadataObjects = objectsForAllSelectors.metadata;\n                    if (!metadataObjects)\n                        metadataObjects = objectsForAllSelectors.metadata = [];\n                    objectDefns = metadataObjects;\n                }\n                else {\n                    var metadataOnce = objectsForAllSelectors.metadataOnce;\n                    if (!metadataOnce)\n                        metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\n                    objectDefns = [metadataOnce];\n                }\n                var targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\n                var targetObjectDefn;\n                if (targetMetadataObject) {\n                    var targetObjectDefns = targetMetadataObject.objects;\n                    targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\n                    if (targetObjectDefn) {\n                        if (targetObjectDefn.properties[propertyId.propertyName])\n                            return;\n                    }\n                    else {\n                        targetObjectDefn = {\n                            name: propertyId.objectName,\n                            properties: {},\n                        };\n                        targetObjectDefns.push(targetObjectDefn);\n                    }\n                }\n                else {\n                    targetObjectDefn = {\n                        name: propertyId.objectName,\n                        properties: {}\n                    };\n                    objectDefns.push({\n                        selector: selector,\n                        objects: [targetObjectDefn],\n                    });\n                }\n                targetObjectDefn.properties[propertyId.propertyName] = value;\n            }\n            function findWithMatchingSelector(objects, selector) {\n                debug.assertValue(objects, 'objects');\n                debug.assertAnyValue(selector, 'selector');\n                for (var i = 0, len = objects.length; i < len; i++) {\n                    var object = objects[i];\n                    if (data.Selector.equals(object.selector, selector))\n                        return object;\n                }\n            }\n            function findExistingObject(objectDefns, objectName) {\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(objectName, 'objectName');\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefn = objectDefns[i];\n                    if (objectDefn.name === objectName)\n                        return objectDefn;\n                }\n            }\n        })(DataViewObjectEvaluationUtils = data.DataViewObjectEvaluationUtils || (data.DataViewObjectEvaluationUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\n        var DataViewObjectEvaluator;\n        (function (DataViewObjectEvaluator) {\n            var colorValueType = powerbi.ValueType.fromDescriptor({ formatting: { color: true } });\n            var numericType = powerbi.ValueType.fromDescriptor({ numeric: true });\n            var textType = powerbi.ValueType.fromDescriptor({ text: true });\n            function run(evalContext, objectDescriptor, propertyDefinitions) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\n                debug.assertValue(propertyDefinitions, 'propertyDefinitions');\n                if (!objectDescriptor)\n                    return;\n                var object, propertyDescriptors = objectDescriptor.properties;\n                for (var propertyName in propertyDefinitions) {\n                    var propertyDefinition = propertyDefinitions[propertyName], propertyDescriptor = propertyDescriptors[propertyName];\n                    if (!propertyDescriptor)\n                        continue;\n                    var propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\n                    if (propertyValue === undefined)\n                        continue;\n                    if (!object)\n                        object = {};\n                    object[propertyName] = propertyValue;\n                }\n                return object;\n            }\n            DataViewObjectEvaluator.run = run;\n            /** Note: Exported for testability */\n            function evaluateProperty(evalContext, propertyDescriptor, propertyDefinition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(propertyDescriptor, 'propertyDescriptor');\n                debug.assertValue(propertyDefinition, 'propertyDefinition');\n                var structuralType = propertyDescriptor.type;\n                if (structuralType && structuralType.expression)\n                    return propertyDefinition;\n                var value = evaluateValue(evalContext, propertyDefinition, powerbi.ValueType.fromDescriptor(propertyDescriptor.type));\n                if (value !== undefined || (propertyDefinition instanceof data.RuleEvaluation))\n                    return value;\n                return evaluateFill(evalContext, propertyDefinition, structuralType)\n                    || evaluateFillRule(evalContext, propertyDefinition, structuralType)\n                    || evaluateImage(evalContext, propertyDefinition, structuralType)\n                    || evaluateParagraphs(evalContext, propertyDefinition, structuralType)\n                    || propertyDefinition;\n            }\n            DataViewObjectEvaluator.evaluateProperty = evaluateProperty;\n            function evaluateFill(evalContext, fillDefn, type) {\n                var fillType = type.fill;\n                if (!fillType)\n                    return;\n                if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\n                    return {\n                        solid: {\n                            color: evaluateValue(evalContext, fillDefn.solid.color, powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Color)),\n                        }\n                    };\n                }\n            }\n            function evaluateFillRule(evalContext, fillRuleDefn, type) {\n                if (!type.fillRule)\n                    return;\n                if (fillRuleDefn.linearGradient2) {\n                    var linearGradient2 = fillRuleDefn.linearGradient2;\n                    return {\n                        linearGradient2: {\n                            min: evaluateColorStop(evalContext, linearGradient2.min),\n                            max: evaluateColorStop(evalContext, linearGradient2.max),\n                        }\n                    };\n                }\n                if (fillRuleDefn.linearGradient3) {\n                    var linearGradient3 = fillRuleDefn.linearGradient3;\n                    return {\n                        linearGradient3: {\n                            min: evaluateColorStop(evalContext, linearGradient3.min),\n                            mid: evaluateColorStop(evalContext, linearGradient3.mid),\n                            max: evaluateColorStop(evalContext, linearGradient3.max),\n                        }\n                    };\n                }\n            }\n            function evaluateColorStop(evalContext, colorStop) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(colorStop, 'colorStop');\n                var step = {\n                    color: evaluateValue(evalContext, colorStop.color, colorValueType),\n                };\n                var value = evaluateValue(evalContext, colorStop.value, numericType);\n                if (value != null)\n                    step.value = value;\n                return step;\n            }\n            function evaluateImage(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.image || !definition)\n                    return;\n                var value = {\n                    name: evaluateValue(evalContext, definition.name, textType),\n                    url: evaluateValue(evalContext, definition.url, powerbi.ValueType.fromDescriptor(powerbi.ImageDefinition.urlType)),\n                };\n                if (definition.scaling)\n                    value.scaling = evaluateValue(evalContext, definition.scaling, textType);\n                return value;\n            }\n            function evaluateParagraphs(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.paragraphs || !definition)\n                    return;\n                return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\n            }\n            function evaluateParagraph(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionTextRuns = definition.textRuns;\n                var evaluatedTextRuns = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\n                if (definitionTextRuns !== evaluatedTextRuns) {\n                    evaluated = _.clone(definition);\n                    evaluated.textRuns = evaluatedTextRuns;\n                }\n                return evaluated || definition;\n            }\n            function evaluateTextRun(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionValue = definition.value;\n                var evaluatedValue = evaluateValue(evalContext, definitionValue, textType);\n                if (evaluatedValue !== undefined) {\n                    evaluated = _.clone(definition);\n                    evaluated.value = evaluatedValue;\n                }\n                return evaluated || definition;\n            }\n            /**\n             * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\n             * other than the input to it.\n             */\n            function evaluateArrayCopyOnChange(evalContext, definitions, evaluator) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definitions, 'definitions');\n                debug.assertValue(evaluator, 'evaluator');\n                var evaluatedValues;\n                for (var i = 0, len = definitions.length; i < len; i++) {\n                    var definition = definitions[i];\n                    var evaluated = evaluator(evalContext, definition);\n                    // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\n                    // between TEvaluated & TDefinition\n                    if (!evaluatedValues && definition !== evaluated) {\n                        evaluatedValues = _.take(definitions, i);\n                    }\n                    if (evaluatedValues) {\n                        evaluatedValues.push(evaluated);\n                    }\n                }\n                return evaluatedValues || definitions;\n            }\n            function evaluateValue(evalContext, definition, valueType) {\n                if (definition instanceof data.SQExpr)\n                    return ExpressionEvaluator.evaluate(definition, evalContext);\n                if (definition instanceof data.RuleEvaluation)\n                    return definition.evaluate(evalContext);\n            }\n            /** Responsible for evaluating SQExprs into values. */\n            var ExpressionEvaluator = (function (_super) {\n                __extends(ExpressionEvaluator, _super);\n                function ExpressionEvaluator() {\n                    _super.apply(this, arguments);\n                }\n                ExpressionEvaluator.evaluate = function (expr, evalContext) {\n                    if (expr == null)\n                        return;\n                    return expr.accept(ExpressionEvaluator.instance, evalContext);\n                };\n                ExpressionEvaluator.prototype.visitColumnRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitConstant = function (expr, evalContext) {\n                    return expr.value;\n                };\n                ExpressionEvaluator.prototype.visitMeasureRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitAggr = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitFillRule = function (expr, evalContext) {\n                    var inputValue = expr.input.accept(this, evalContext);\n                    if (inputValue !== undefined) {\n                        var colorAllocator = evalContext.getColorAllocator(expr);\n                        if (colorAllocator) {\n                            return colorAllocator.color(inputValue);\n                        }\n                    }\n                };\n                ExpressionEvaluator.prototype.visitSelectRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.instance = new ExpressionEvaluator();\n                return ExpressionEvaluator;\n            }(data.DefaultSQExprVisitorWithArg));\n        })(DataViewObjectEvaluator = data.DataViewObjectEvaluator || (data.DataViewObjectEvaluator = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var DataViewPivotCategorical;\n        (function (DataViewPivotCategorical) {\n            /**\n             * Pivots categories in a categorical DataView into valueGroupings.\n             * This is akin to a mathematical matrix transpose.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                var categorical = dataView.categorical;\n                if (!categorical)\n                    return null;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return null;\n                var values = categorical.values;\n                if (_.isEmpty(values) || values.source)\n                    return null;\n                var category = categories[0], categoryIdentities = category.identity, categoryValues = category.values, pivotedColumns = [], pivotedValues = [];\n                for (var rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\n                    var categoryValue = categoryValues[rowIdx], categoryIdentity = categoryIdentities[rowIdx];\n                    for (var colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\n                        var value = values[colIdx], pivotedColumn = inherit(value.source);\n                        // A value has a series group, which is not implemented for pivoting -- just give up.\n                        if (value.identity)\n                            return null;\n                        pivotedColumn.groupName = categoryValue;\n                        var pivotedValue = {\n                            source: pivotedColumn,\n                            values: [value.values[rowIdx]],\n                            identity: categoryIdentity,\n                            min: value.min,\n                            max: value.max,\n                            subtotal: value.subtotal\n                        };\n                        var highlights = value.highlights;\n                        if (highlights) {\n                            pivotedValue.highlights = [highlights[rowIdx]];\n                        }\n                        pivotedColumns.push(pivotedColumn);\n                        pivotedValues.push(pivotedValue);\n                    }\n                }\n                var pivotedMetadata = inherit(dataView.metadata);\n                pivotedMetadata.columns = pivotedColumns;\n                values = data.DataViewTransform.createValueColumns(pivotedValues, category.identityFields, category.source);\n                return {\n                    metadata: pivotedMetadata,\n                    categorical: {\n                        values: values,\n                    },\n                    matrix: dataView.matrix\n                };\n            }\n            DataViewPivotCategorical.apply = apply;\n        })(DataViewPivotCategorical = data.DataViewPivotCategorical || (data.DataViewPivotCategorical = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewPivotMatrix;\n        (function (DataViewPivotMatrix) {\n            /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\n            function apply(dataViewMatrix, context) {\n                debug.assertValue(dataViewMatrix, 'dataViewMatrix');\n                if (!context.columnHierarchyRewritten)\n                    dataViewMatrix.columns = powerbi.Prototype.inherit(dataViewMatrix.columns);\n                var columns = dataViewMatrix.columns;\n                if (!context.rowHierarchyRewritten)\n                    dataViewMatrix.rows = powerbi.Prototype.inherit(dataViewMatrix.rows);\n                var rows = dataViewMatrix.rows;\n                if (columns.levels.length > 1)\n                    return;\n                var pivotedRowNode = {\n                    level: 0\n                };\n                var columnLeafNodes = columns.root.children;\n                var measureCount = columnLeafNodes.length;\n                // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\n                // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\n                // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \n                // in a matrix with 2+ column fields and 2+ measure fields.\n                // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\n                // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\n                var pivotResultMeasureHeaderLevel = rows.levels.length;\n                if (measureCount > 0) {\n                    var index_1 = 0;\n                    var callback = function (node) {\n                        // Collect values and remove them from row leaves\n                        if (node.values) {\n                            if (!pivotedRowNode.values)\n                                pivotedRowNode.values = {};\n                            for (var i = 0; i < measureCount; i++)\n                                pivotedRowNode.values[index_1++] = node.values[i];\n                            delete node.values;\n                        }\n                        // Create measure headers if there are more than one measures\n                        if (measureCount > 1) {\n                            if (!node.children)\n                                node.children = [];\n                            for (var j = 0; j < measureCount; j++) {\n                                var measureHeaderLeaf = { level: pivotResultMeasureHeaderLevel };\n                                // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\n                                var columnLeafNode = columnLeafNodes[j];\n                                measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\n                                if (node.isSubtotal)\n                                    measureHeaderLeaf.isSubtotal = true;\n                                node.children.push(measureHeaderLeaf);\n                            }\n                        }\n                    };\n                    if (context.hierarchyTreesRewritten) {\n                        forEachLeaf(rows.root, callback);\n                    }\n                    else {\n                        dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\n                    }\n                }\n                else {\n                    if (!context.hierarchyTreesRewritten) {\n                        dataViewMatrix.columns.root = cloneTree(rows.root);\n                    }\n                }\n                if (measureCount > 1) {\n                    // Keep measure headers, but move them to the innermost level\n                    var level = { sources: columns.levels[0].sources };\n                    rows.levels.push(level);\n                    columns.levels.length = 0;\n                }\n                if (context.hierarchyTreesRewritten) {\n                    dataViewMatrix.columns.root = rows.root;\n                    dataViewMatrix.rows.root = {\n                        children: [pivotedRowNode]\n                    };\n                }\n                else {\n                    var updatedRowRoot = powerbi.Prototype.inherit(dataViewMatrix.rows.root);\n                    updatedRowRoot.children = [pivotedRowNode];\n                    dataViewMatrix.rows.root = updatedRowRoot;\n                }\n                dataViewMatrix.columns.levels = rows.levels;\n                dataViewMatrix.rows.levels = [];\n            }\n            DataViewPivotMatrix.apply = apply;\n            function forEachLeaf(root, callback) {\n                var children = root.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachLeaf(children[i], callback);\n                    return;\n                }\n                callback(root);\n            }\n            function cloneTree(node) {\n                return cloneTreeExecuteOnLeaf(node);\n            }\n            DataViewPivotMatrix.cloneTree = cloneTree;\n            function cloneTreeExecuteOnLeaf(node, callback) {\n                var updatedNode = powerbi.Prototype.inherit(node);\n                var children = node.children;\n                if (children && children.length > 0) {\n                    var newChildren = [];\n                    for (var i = 0, ilen = children.length; i < ilen; i++) {\n                        var updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\n                        newChildren.push(updatedChild);\n                    }\n                    updatedNode.children = newChildren;\n                }\n                else {\n                    if (callback)\n                        callback(updatedNode);\n                }\n                return updatedNode;\n            }\n            DataViewPivotMatrix.cloneTreeExecuteOnLeaf = cloneTreeExecuteOnLeaf;\n        })(DataViewPivotMatrix = data.DataViewPivotMatrix || (data.DataViewPivotMatrix = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelfCrossJoin;\n        (function (DataViewSelfCrossJoin) {\n            /**\n             * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\n             * to itself as a value grouping.\n             * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                if (!dataView.categorical)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\n                    return;\n                if (dataViewCategorical.values && dataViewCategorical.values.source)\n                    return;\n                return applyCategorical(dataView.metadata, dataViewCategorical);\n            }\n            DataViewSelfCrossJoin.apply = apply;\n            function applyCategorical(dataViewMetadata, dataViewCategorical) {\n                debug.assertValue(dataViewMetadata, 'dataViewMetadata');\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\n                var category = dataViewCategorical.categories[0], categoryValues = category.values, categoryLength = categoryValues.length;\n                if (categoryLength === 0)\n                    return;\n                var valuesArray = dataViewCategorical.values\n                    ? dataViewCategorical.values.grouped()[0].values\n                    : [];\n                var transformedDataView = data.createCategoricalDataViewBuilder()\n                    .withCategories(dataViewCategorical.categories)\n                    .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\n                    .build();\n                dataViewMetadata = powerbi.Prototype.inherit(dataViewMetadata);\n                dataViewMetadata.columns = transformedDataView.metadata.columns;\n                return {\n                    metadata: dataViewMetadata,\n                    categorical: transformedDataView.categorical,\n                };\n            }\n            function createGroupedValues(category, categoryValues, categoryLength, valuesArray) {\n                debug.assertValue(category, 'category');\n                debug.assertValue(categoryValues, 'categoryValues');\n                debug.assertValue(categoryLength, 'categoryLength');\n                debug.assertValue(valuesArray, 'valuesArray');\n                var nullValuesArray = createNullValues(categoryLength), valuesArrayLen = valuesArray.length, seriesData = [];\n                for (var i = 0; i < categoryLength; i++) {\n                    var seriesDataItem = [];\n                    for (var j = 0; j < valuesArrayLen; j++) {\n                        var originalValueColumn = valuesArray[j], originalHighlightValues = originalValueColumn.highlights;\n                        var seriesDataItemCategory = {\n                            values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\n                        };\n                        if (originalHighlightValues)\n                            seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\n                        seriesDataItem.push(seriesDataItemCategory);\n                    }\n                    seriesData.push(seriesDataItem);\n                }\n                return {\n                    groupColumn: {\n                        source: category.source,\n                        identityFrom: { fields: category.identityFields, identities: category.identity },\n                        values: category.values,\n                    },\n                    valueColumns: _.map(valuesArray, function (v) { return { source: v.source }; }),\n                    data: seriesData,\n                };\n            }\n        })(DataViewSelfCrossJoin = data.DataViewSelfCrossJoin || (data.DataViewSelfCrossJoin = {}));\n        function createNullValues(length) {\n            debug.assertValue(length, 'length');\n            var array = new Array(length);\n            for (var i = 0; i < length; i++)\n                array[i] = null;\n            return array;\n        }\n        function inheritArrayWithValue(nullValues, original, index) {\n            var inherited = powerbi.Prototype.inherit(nullValues);\n            inherited[index] = original[index];\n            return inherited;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewPivotCategoricalToPrimaryGroups;\n        (function (DataViewPivotCategoricalToPrimaryGroups) {\n            /**\n             * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\n             * pivot the secondary before the primary.\n             */\n            function pivotBinding(binding, allMappings, finalMapping, defaultDataVolume) {\n                // unpivot is inferred from result in DataViewTransform.apply but it does not have the\n                // compiled mappings available, let alone the merged mapping, only the original\n                // DataViewMappings. to keep that inference easy, only apply pivot when there's\n                // only one matching mapping\n                if (!allMappings || allMappings.length !== 1)\n                    return;\n                if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\n                    return;\n                if (!binding)\n                    return;\n                if (!canPivotCategorical(binding, finalMapping))\n                    return;\n                // pivot secondary onto front of primary\n                binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\n                binding.Secondary = undefined;\n                // set primary to pivot reduction\n                binding.DataReduction = {\n                    Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\n                    DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\n                };\n            }\n            DataViewPivotCategoricalToPrimaryGroups.pivotBinding = pivotBinding;\n            /** narrowly targets scatter chart scenario for now to keep code simple */\n            function isPivotableAxis(axis) {\n                return axis\n                    && axis.Groupings\n                    && axis.Groupings.length === 1\n                    && !_.isEmpty(axis.Groupings[0].Projections)\n                    && !axis.Groupings[0].Subtotal\n                    && _.isEmpty(axis.Groupings[0].SuppressedProjections);\n            }\n            function canPivotCategorical(binding, mapping) {\n                if (!isPivotableAxis(binding.Primary))\n                    return false;\n                if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\n                    return false;\n                // don't pivot if either axis has a data reduction\n                if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\n                    return false;\n                return true;\n            }\n            function unpivotResult(oldDataView, selects, dataViewMappings, projectionActiveItems) {\n                if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\n                    return oldDataView;\n                // This returns a subsetted version of the DataView rather than using prototypal inheritance because\n                // any dataviews in the old one (including ones invented after this code is written) will correspond\n                // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\n                // querying code made.\n                var newDataView = {\n                    metadata: {\n                        columns: ArrayExtensions.copy(oldDataView.metadata.columns),\n                    },\n                };\n                // preserve view types that aren't affected by pivoting\n                if (oldDataView.single)\n                    newDataView.single = oldDataView.single;\n                if (oldDataView.table)\n                    newDataView.table = oldDataView.table;\n                // other views are derived from matrix\n                if (oldDataView.matrix) {\n                    var newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\n                    // categorical only if there's data\n                    if (!_.isEmpty(newDataViewMatrix.valueSources)) {\n                        // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \n                        // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\n                        // this.canPivotCategorical() would have returned false in the first place for this query.\n                        var hasCompositeGroupInSeries = data.utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\n                        if (!hasCompositeGroupInSeries) {\n                            newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\n                        }\n                    }\n                }\n                return newDataView;\n            }\n            DataViewPivotCategoricalToPrimaryGroups.unpivotResult = unpivotResult;\n            /**\n             * Infer from the query result and the visual mappings whether the query was pivoted.\n             * Narrowly targets scatter chart scenario for now to keep code simple\n             */\n            function inferUnpivotTransform(selects, dataViewMappings, dataView, projectionActiveItems) {\n                if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\n                    return false;\n                // select applicable mappings based on select roles\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var supportedDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\n                if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\n                    return false;\n                var categoricalMapping = supportedDataViewMappings[0].categorical;\n                if (!categoricalMapping)\n                    return false;\n                // pivoted query will have produced a matrix\n                var matrixDataview = dataView.matrix;\n                if (!matrixDataview)\n                    return false;\n                // matrix must have two levels of grouping\n                if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\n                    return false;\n                // get category and value grouping roles\n                var categoryGroups = [];\n                var valueGroups = [];\n                var addGroupingRole = function (roleName, groups) {\n                    var roleProjections = projections[roleName];\n                    if (!roleProjections)\n                        return;\n                    for (var _i = 0, _a = roleProjections.all(); _i < _a.length; _i++) {\n                        var roleProjection = _a[_i];\n                        if (roleKinds[roleProjection.queryRef] === powerbi.VisualDataRoleKind.Grouping)\n                            groups.push(roleProjection.queryRef);\n                    }\n                };\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, categoryGroups); }\n                });\n                powerbi.DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, valueGroups); }\n                });\n                // need both for pivot to have been done\n                if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\n                    return false;\n                // if there was a pivot, there won't be any measures left in the columns\n                for (var _i = 0, _a = matrixDataview.columns.levels; _i < _a.length; _i++) {\n                    var level = _a[_i];\n                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {\n                        var source = _c[_b];\n                        if (!source.isMeasure)\n                            return false;\n                    }\n                }\n                return true;\n            }\n            /**\n             * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\n             * this function changes that so that the categories become the rows and the series the columns.\n             */\n            function unpivotMatrix(oldMatrix) {\n                var oldRows = oldMatrix.rows;\n                var oldRoot = oldRows.root;\n                var oldChildren = oldRoot.children;\n                // series are the outer grouping\n                var series = [];\n                var seriesIdLevel = oldRows.levels[0];\n                var seriesIdFields = oldRoot.childIdentityFields;\n                // categories are the inner grouping. \n                var categoryIndex = {};\n                var categories = [];\n                var categoryIdLevel = oldRows.levels[1];\n                var categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\n                var measureCount = oldMatrix.valueSources.length;\n                // within each series value, the category list may not be complete so cannot simply use the inner loop index\n                // to reference it.\n                var findCategory = function (identity) {\n                    var index = categoryIndex[identity.key];\n                    debug.assert(index !== undefined, \"findcat() !== undefined\");\n                    return index;\n                };\n                // collect series and categories from the row hierarchy\n                if (oldChildren) {\n                    var addCategory = function (categoryNode) {\n                        var key = categoryNode.identity.key;\n                        var index = categoryIndex[key];\n                        if (index === undefined) {\n                            index = categories.length;\n                            categoryIndex[key] = index;\n                            categories.push(categoryNode);\n                        }\n                    };\n                    for (var _i = 0, oldChildren_1 = oldChildren; _i < oldChildren_1.length; _i++) {\n                        var seriesNode = oldChildren_1[_i];\n                        series.push(seriesNode);\n                        for (var _a = 0, _b = seriesNode.children; _a < _b.length; _a++) {\n                            var categoryNode = _b[_a];\n                            addCategory(categoryNode);\n                        }\n                    }\n                }\n                // extract intersection values from pivoted matrix\n                // values will be indexed by categories then series\n                var matrixValues = new Array(categories.length);\n                for (var j = 0; j < series.length; ++j) {\n                    var seriesNode = oldChildren[j];\n                    for (var _c = 0, _d = seriesNode.children; _c < _d.length; _c++) {\n                        var categoryNode = _d[_c];\n                        var i = findCategory(categoryNode.identity); // must lookup actual category index\n                        if (!matrixValues[i])\n                            matrixValues[i] = new Array(series.length);\n                        matrixValues[i][j] = categoryNode.values;\n                    }\n                }\n                // columns of the unpivoted matrix are the series\n                var newColumns = {\n                    root: {\n                        children: _.map(series, function (s) {\n                            var inheritedNode = inheritSingle(s);\n                            inheritedNode.level = 0; // s.level should already be 0, but just in case...\n                            inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\n                            inheritedNode.childIdentityFields = undefined;\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: seriesIdFields,\n                    },\n                    levels: [\n                        seriesIdLevel,\n                    ],\n                };\n                // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\n                if (measureCount > 0) {\n                    var newColChildren = _.map(oldMatrix.columns.root.children, function (srcnode) {\n                        var dstnode = { level: 1 };\n                        if (srcnode.levelSourceIndex)\n                            dstnode.levelSourceIndex = srcnode.levelSourceIndex;\n                        return dstnode;\n                    });\n                    for (var i = 0; i < newColumns.root.children.length; ++i)\n                        newColumns.root.children[i].children = newColChildren;\n                    newColumns.levels.push(oldMatrix.columns.levels[0]);\n                }\n                // rows of the unpivoted matrix are the categories\n                var newRows = {\n                    root: {\n                        children: _.map(categories, function (c) {\n                            var inheritedNode = inheritSingle(c);\n                            inheritedNode.level = 0;\n                            inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\n                            inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: categoryIdFields,\n                    },\n                    levels: [\n                        categoryIdLevel,\n                    ],\n                };\n                // put values into rows\n                if (measureCount > 0) {\n                    for (var i = 0; i < categories.length; ++i) {\n                        var row = newRows.root.children[i];\n                        var rowValues = {};\n                        for (var j = 0; j < series.length; ++j) {\n                            var mvalues = matrixValues[i] && matrixValues[i][j];\n                            for (var k = 0; k < measureCount; ++k) {\n                                var l = j * measureCount + k;\n                                rowValues[l] = !mvalues\n                                    ? (k === 0 ? { value: null } : { value: null, valueSourceIndex: k })\n                                    : mvalues[k];\n                            }\n                        }\n                        row.values = rowValues;\n                    }\n                }\n                var newMatrix = {\n                    rows: newRows,\n                    columns: newColumns,\n                    valueSources: oldMatrix.valueSources,\n                };\n                return newMatrix;\n            }\n            /** build a categorical data view from an unpivoted matrix. */\n            function categoricalFromUnpivotedMatrix(matrix, columnMetadata) {\n                var seriesCount = matrix.columns.root.children.length;\n                var measureMetadata = matrix.valueSources;\n                var measureCount = measureMetadata.length;\n                var categories = createCategoryColumnsFromUnpivotedMatrix(matrix);\n                // create grouped values\n                var groups = [];\n                for (var j = 0; j < seriesCount; ++j) {\n                    var seriesColumn = matrix.columns.root.children[j];\n                    var group = {\n                        values: [],\n                        identity: seriesColumn.identity,\n                        name: seriesColumn.value || null,\n                    };\n                    groups.push(group);\n                    for (var k = 0; k < measureCount; ++k) {\n                        var valueColumnMetadataSrc = measureMetadata[k];\n                        var valueColumnMetadataDst = {};\n                        for (var key in valueColumnMetadataSrc)\n                            valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\n                        valueColumnMetadataDst.groupName = group.name;\n                        columnMetadata.push(valueColumnMetadataDst);\n                        var valueColumn = {\n                            source: valueColumnMetadataDst,\n                            values: [],\n                            identity: group.identity,\n                        };\n                        group.values.push(valueColumn);\n                        // grab measure values in the group from across rows of matrix\n                        var index = k + j * measureCount;\n                        for (var _i = 0, _a = matrix.rows.root.children; _i < _a.length; _i++) {\n                            var categoryNode = _a[_i];\n                            var value = categoryNode.values[index].value;\n                            valueColumn.values.push(value);\n                        }\n                    }\n                }\n                // and now ungrouped\n                var values = [];\n                for (var _b = 0, groups_1 = groups; _b < groups_1.length; _b++) {\n                    var group = groups_1[_b];\n                    for (var k = 0; k < measureCount; ++k) {\n                        values.push(group.values[k]);\n                    }\n                }\n                values.grouped = function () { return groups; };\n                values.identityFields = matrix.columns.root.childIdentityFields;\n                values.source = matrix.columns.levels[0].sources[0];\n                // final assembly\n                var categorical = {\n                    categories: categories,\n                    values: values,\n                };\n                return categorical;\n            }\n            function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix) {\n                debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\n                debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1), 'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\n                // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \n                // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \n                // same amongst the resulting DataViewCategoryColumns.\n                var categoryIdentity = _.map(unpivotedMatrix.rows.root.children, function (x) { return x.identity; });\n                var categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\n                var categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\n                var categories = [];\n                for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\n                    var groupLevelValues = _.map(unpivotedMatrix.rows.root.children, function (categoryNode) {\n                        var levelValues = categoryNode.levelValues;\n                        // Please refer to the interface comments on when this is undefined... But in today's code\n                        // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \n                        if (levelValues !== undefined) {\n                            debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i), 'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\n                            return levelValues[i].value;\n                        }\n                    });\n                    categories.push({\n                        source: categorySourceColumns[i],\n                        values: groupLevelValues,\n                        identity: categoryIdentity,\n                        identityFields: categoryIdentityFields,\n                    });\n                }\n                return categories;\n            }\n        })(DataViewPivotCategoricalToPrimaryGroups = data.DataViewPivotCategoricalToPrimaryGroups || (data.DataViewPivotCategoricalToPrimaryGroups = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var EnumExtensions = jsCommon.EnumExtensions;\n        // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\n        var DataViewTransform;\n        (function (DataViewTransform) {\n            var fillRulePropertyDescriptor = { type: { fillRule: {} } };\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\n                var prototype = options.prototype, objectDescriptors = options.objectDescriptors, dataViewMappings = options.dataViewMappings, transforms = options.transforms, projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems, colorAllocatorFactory = options.colorAllocatorFactory, dataRoles = options.dataRoles;\n                if (!prototype)\n                    return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\n                if (!transforms)\n                    return [prototype];\n                // Transform Query DataView\n                prototype = data.DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\n                var visualDataViews = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\n                // Transform and generate derived visual DataViews\n                visualDataViews = data.DataViewRegression.run({\n                    dataViewMappings: dataViewMappings,\n                    visualDataViews: visualDataViews,\n                    dataRoles: dataRoles,\n                    objectDescriptors: objectDescriptors,\n                    objectDefinitions: transforms.objects,\n                    colorAllocatorFactory: colorAllocatorFactory,\n                    transformSelects: transforms.selects,\n                    metadata: prototype.metadata,\n                    projectionActiveItems: projectionActiveItems,\n                });\n                return visualDataViews;\n            }\n            DataViewTransform.apply = apply;\n            function transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles) {\n                var transformedDataViews = [];\n                var splits = transforms.splits;\n                if (_.isEmpty(splits)) {\n                    transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\n                }\n                else {\n                    for (var _i = 0, splits_1 = splits; _i < splits_1.length; _i++) {\n                        var split = splits_1[_i];\n                        var transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\n                        transformedDataViews.push(transformed);\n                    }\n                }\n                return transformedDataViews;\n            }\n            function transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory) {\n                if (transforms && transforms.objects) {\n                    var emptyDataView = {\n                        metadata: {\n                            columns: [],\n                        }\n                    };\n                    transformObjects(emptyDataView, 0 /* None */, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                    return [emptyDataView];\n                }\n                return [];\n            }\n            function transformDataView(prototype, objectDescriptors, roleMappings, transforms, colorAllocatorFactory, dataRoles, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(transforms, 'transforms');\n                debug.assert(!selectsToInclude ||\n                    _.filter(Object.keys(selectsToInclude), function (selectIndex) { return selectsToInclude[selectIndex] && (!transforms.selects || !transforms.selects[selectIndex]); })\n                        .length === 0, // asserts that the number of select indices in selectsToInclude without a corresponding Select Transform === 0\n                'If selectsToInclude is specified, every Select Index in it must have a corresponding Select Transform.');\n                var targetKinds = getTargetKinds(roleMappings);\n                var transformed = inherit(prototype);\n                transformed.metadata = inherit(prototype.metadata);\n                var projectionOrdering = transforms.roles && transforms.roles.ordering;\n                var projectionActiveItems = transforms.roles && transforms.roles.activeItems;\n                transformed = transformSelects(transformed, targetKinds, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\n                transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\n                transformed = data.DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\n                data.DataViewNormalizeValues.apply({\n                    dataview: transformed,\n                    dataViewMappings: roleMappings,\n                    dataRoles: dataRoles,\n                });\n                return transformed;\n            }\n            function getTargetKinds(roleMappings) {\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                if (!roleMappings)\n                    return 0 /* None */;\n                var result = 0 /* None */;\n                for (var _i = 0, roleMappings_1 = roleMappings; _i < roleMappings_1.length; _i++) {\n                    var roleMapping = roleMappings_1[_i];\n                    if (roleMapping.categorical)\n                        result |= 1 /* Categorical */;\n                    if (roleMapping.matrix)\n                        result |= 2 /* Matrix */;\n                    if (roleMapping.single)\n                        result |= 4 /* Single */;\n                    if (roleMapping.table)\n                        result |= 8 /* Table */;\n                    if (roleMapping.tree)\n                        result |= 16 /* Tree */;\n                }\n                return result;\n            }\n            function transformSelects(dataView, targetDataViewKinds, roleMappings, selectTransforms, projectionOrdering, selectsToInclude) {\n                var columnRewrites = [];\n                if (selectTransforms) {\n                    dataView.metadata.columns = applyTransformsToColumns(dataView.metadata.columns, selectTransforms, columnRewrites);\n                }\n                // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\n                if (dataView.categorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {\n                    dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    // NOTE: This is slightly DSR-specific.\n                    dataView = pivotIfNecessary(dataView, roleMappings);\n                }\n                // Don't perform this potentially expensive transform unless we actually have a matrix.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (dataView.matrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {\n                    var matrixTransformationContext = {\n                        rowHierarchyRewritten: false,\n                        columnHierarchyRewritten: false,\n                        hierarchyTreesRewritten: false\n                    };\n                    dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    if (shouldPivotMatrix(dataView.matrix, roleMappings))\n                        data.DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\n                }\n                // Don't perform this potentially expensive transform unless we actually have a table.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (dataView.table && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {\n                    dataView.table = applyRewritesToTable(dataView.table, columnRewrites, projectionOrdering);\n                }\n                return dataView;\n            }\n            function applyTransformsToColumns(prototypeColumns, selects, rewrites) {\n                debug.assertValue(prototypeColumns, 'columns');\n                if (!selects)\n                    return prototypeColumns;\n                //column may contain undefined entries\n                var columns = inherit(prototypeColumns);\n                for (var i = 0, len = prototypeColumns.length; i < len; i++) {\n                    var prototypeColumn = prototypeColumns[i];\n                    var select = selects[prototypeColumn.index];\n                    if (!select)\n                        continue;\n                    var column = columns[i] = inherit(prototypeColumn);\n                    if (select.roles)\n                        column.roles = select.roles;\n                    if (select.type)\n                        column.type = select.type;\n                    column.format = getFormatForColumn(select, column);\n                    if (select.displayName)\n                        column.displayName = select.displayName;\n                    if (select.queryName)\n                        column.queryName = select.queryName;\n                    if (select.kpi)\n                        column.kpi = select.kpi;\n                    if (select.sort)\n                        column.sort = select.sort;\n                    if (select.discourageAggregationAcrossGroups)\n                        column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\n                    rewrites.push({\n                        from: prototypeColumn,\n                        to: column,\n                    });\n                }\n                return columns;\n            }\n            /**\n             * Get the column format. Order of precendence is:\n             *  1. Select format\n             *  2. Column format\n             */\n            function getFormatForColumn(select, column) {\n                // TODO: we already copied the select.Format to column.format, we probably don't need this check\n                return select.format || column.format;\n            }\n            function applyRewritesToCategorical(prototype, columnRewrites, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                var categorical = inherit(prototype);\n                function override(value) {\n                    var rewrittenSource = findOverride(value.source, columnRewrites);\n                    if (rewrittenSource) {\n                        var rewritten = inherit(value);\n                        rewritten.source = rewrittenSource;\n                        return rewritten;\n                    }\n                }\n                var categories = powerbi.Prototype.overrideArray(prototype.categories, override);\n                if (categories)\n                    categorical.categories = categories;\n                var valuesOverride = powerbi.Prototype.overrideArray(prototype.values, override);\n                var valueColumns = valuesOverride || prototype.values;\n                if (valueColumns) {\n                    if (valueColumns.source) {\n                        if (selectsToInclude && !selectsToInclude[valueColumns.source.index]) {\n                            // if processing a split and this is the split without series...\n                            valueColumns.source = undefined;\n                        }\n                        else {\n                            var rewrittenValuesSource = findOverride(valueColumns.source, columnRewrites);\n                            if (rewrittenValuesSource)\n                                valueColumns.source = rewrittenValuesSource;\n                        }\n                    }\n                    if (selectsToInclude) {\n                        // Apply selectsToInclude to values by removing value columns not included\n                        for (var i = valueColumns.length - 1; i >= 0; i--) {\n                            if (!selectsToInclude[valueColumns[i].source.index]) {\n                                valueColumns.splice(i, 1);\n                            }\n                        }\n                    }\n                    var isDynamicSeries_1 = !!valueColumns.source;\n                    debug.assert(_.every(valueColumns, function (valueColumn) { return isDynamicSeries_1 === !!valueColumn.identity; }), 'After applying selectsToInclude, all remaining DataViewValueColumn objects should have a consistent scope type (static vs. dynamic) with the parent DataViewValueColumns object.');\n                    // Dynamic or not, always update the return values of grouped() to have the rewritten 'source' property\n                    var seriesGroups_1;\n                    if (isDynamicSeries_1) {\n                        // We have a dynamic series, so update the return value of grouped() to have the DataViewValueColumn objects with rewritten 'source'.\n                        // Also, exclude any column that belongs to a static series.\n                        seriesGroups_1 = inherit(valueColumns.grouped());\n                        // The following assert is not a rule that's set in stone.  If it becomes false someday, update the code below to remove static series from seriesGroups.\n                        debug.assert(_.every(seriesGroups_1, function (group) { return !!group.identity; }), 'If the categorical has a dynamic series, query DataView is expected to have a grouped() function that returns only dynamic series groups, even when there is any column that belongs to a static group (in the case of combo chart and splits).  If this assertion becomes false someday, update the code below to remove static series from seriesGroups.');\n                        var nextSeriesGroupIndex = 0;\n                        var currentSeriesGroup = void 0;\n                        for (var i = 0, ilen = valueColumns.length; i < ilen; i++) {\n                            var currentValueColumn = valueColumns[i];\n                            if (!currentSeriesGroup || (currentValueColumn.identity !== currentSeriesGroup.identity)) {\n                                currentSeriesGroup = inherit(seriesGroups_1[nextSeriesGroupIndex]);\n                                seriesGroups_1[nextSeriesGroupIndex] = currentSeriesGroup;\n                                currentSeriesGroup.values = [];\n                                nextSeriesGroupIndex++;\n                                debug.assert(currentValueColumn.identity === currentSeriesGroup.identity, 'expecting the value columns are sequenced by series groups');\n                            }\n                            currentSeriesGroup.values.push(currentValueColumn);\n                        }\n                    }\n                    else {\n                        // We are in a static series, so we should throw away the grouped and recreate it using the static values\n                        //   which have already been filtered\n                        seriesGroups_1 = [{ values: valueColumns }];\n                    }\n                    valueColumns.grouped = function () { return seriesGroups_1; };\n                    categorical.values = valueColumns;\n                }\n                return categorical;\n            }\n            function applyRewritesToTable(prototype, columnRewrites, projectionOrdering) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                var table = inherit(prototype);\n                // Copy the rewritten columns into the table view\n                var override = function (metadata) { return findOverride(metadata, columnRewrites); };\n                var columns = powerbi.Prototype.overrideArray(prototype.columns, override);\n                if (columns)\n                    table.columns = columns;\n                if (!projectionOrdering)\n                    return table;\n                var newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\n                if (!newToOldPositions)\n                    return table;\n                // Reorder the columns\n                var columnsClone = columns.slice(0);\n                var keys = Object.keys(newToOldPositions);\n                for (var i = 0, len = keys.length; i < len; i++) {\n                    var sourceColumn = columnsClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === columns.length)\n                        columns.push(sourceColumn);\n                    else {\n                        debug.assert(i < columns.length, 'The column index is out of range for reordering.');\n                        columns[i] = sourceColumn;\n                    }\n                }\n                // Reorder the rows\n                var rows = powerbi.Prototype.overrideArray(table.rows, function (row) {\n                    var newRow = [];\n                    for (var i = 0, len = keys.length; i < len; ++i)\n                        newRow[i] = row[newToOldPositions[keys[i]]];\n                    return newRow;\n                });\n                if (rows)\n                    table.rows = rows;\n                return table;\n            }\n            /** Creates a mapping of new position to original position. */\n            function createTableColumnPositionMapping(projectionOrdering, columnRewrites) {\n                var roles = Object.keys(projectionOrdering);\n                // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\n                if (roles.length !== 1)\n                    return;\n                var role = roles[0], originalOrder = _.map(columnRewrites, function (rewrite) { return rewrite.from.index; }), newOrder = projectionOrdering[role];\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            function applyRewritesToMatrix(prototype, columnRewrites, roleMappings, projectionOrdering, context) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                debug.assertValue(roleMappings, 'roleMappings');\n                var firstRoleMappingWithMatrix = _.find(roleMappings, function (roleMapping) { return !!roleMapping.matrix; });\n                debug.assertValue(firstRoleMappingWithMatrix, 'roleMappings - at least one role mapping is expected to target DataViewMatrix');\n                var matrixMapping = firstRoleMappingWithMatrix.matrix;\n                var matrix = inherit(prototype);\n                function override(metadata) {\n                    return findOverride(metadata, columnRewrites);\n                }\n                function overrideHierarchy(hierarchy) {\n                    var rewrittenHierarchy = null;\n                    var newLevels = powerbi.Prototype.overrideArray(hierarchy.levels, function (level) {\n                        var newLevel = null;\n                        var levelSources = powerbi.Prototype.overrideArray(level.sources, override);\n                        if (levelSources)\n                            newLevel = ensureRewritten(newLevel, level, function (h) { return h.sources = levelSources; });\n                        return newLevel;\n                    });\n                    if (newLevels)\n                        rewrittenHierarchy = ensureRewritten(rewrittenHierarchy, hierarchy, function (r) { return r.levels = newLevels; });\n                    return rewrittenHierarchy;\n                }\n                var rows = overrideHierarchy(matrix.rows);\n                if (rows) {\n                    matrix.rows = rows;\n                    context.rowHierarchyRewritten = true;\n                }\n                var columns = overrideHierarchy(matrix.columns);\n                if (columns) {\n                    matrix.columns = columns;\n                    context.columnHierarchyRewritten = true;\n                }\n                var valueSources = powerbi.Prototype.overrideArray(matrix.valueSources, override);\n                if (valueSources) {\n                    matrix.valueSources = valueSources;\n                    // Only need to reorder if we have more than one value source, and they are all bound to the same role\n                    var matrixValues = matrixMapping.values;\n                    if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\n                        var columnLevels = columns.levels.length;\n                        if (columnLevels > 0) {\n                            var newToOldPositions_1 = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\n                            if (newToOldPositions_1) {\n                                var keys_1 = Object.keys(newToOldPositions_1);\n                                var numKeys_1 = keys_1.length;\n                                // Reorder the value columns\n                                columns.root = data.DataViewPivotMatrix.cloneTree(columns.root);\n                                if (columnLevels === 1)\n                                    reorderChildNodes(columns.root, newToOldPositions_1);\n                                else\n                                    forEachNodeAtLevel(columns.root, columnLevels - 2, function (node) { return reorderChildNodes(node, newToOldPositions_1); });\n                                // Reorder the value rows\n                                matrix.rows.root = data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, function (node) {\n                                    if (!node.values)\n                                        return;\n                                    var newValues = {};\n                                    var iterations = Object.keys(node.values).length / numKeys_1;\n                                    for (var i = 0, len = iterations; i < len; i++) {\n                                        var offset = i * numKeys_1;\n                                        for (var keysIndex = 0; keysIndex < numKeys_1; keysIndex++)\n                                            newValues[offset + keysIndex] = node.values[offset + newToOldPositions_1[keys_1[keysIndex]]];\n                                    }\n                                    node.values = newValues;\n                                });\n                                context.hierarchyTreesRewritten = true;\n                            }\n                        }\n                    }\n                }\n                reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\n                return matrix;\n            }\n            function reorderChildNodes(node, newToOldPositions) {\n                var keys = Object.keys(newToOldPositions);\n                var numKeys = keys.length;\n                var children = node.children;\n                var childrenClone = children.slice(0);\n                for (var i = 0, len = numKeys; i < len; i++) {\n                    var sourceColumn = childrenClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === children.length)\n                        children.push(sourceColumn);\n                    else {\n                        debug.assert(i < children.length, 'The column index is out of range for reordering.');\n                        children[i] = sourceColumn;\n                    }\n                }\n            }\n            /**\n             * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\n             * and values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified prototype is necessary.\n             */\n            function reorderMatrixCompositeGroups(prototype, supportedDataViewMapping, projection) {\n                var transformedDataView;\n                if (prototype && supportedDataViewMapping && projection) {\n                    // reorder levelValues in any composite groups in rows hierarchy\n                    var transformedRowsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\n                        visitRole: function (role, context) {\n                            transformedRowsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedRowsHierarchy_1 || prototype.rows, role, projection);\n                        }\n                    });\n                    // reorder levelValues in any composite groups in columns hierarchy\n                    var transformedColumnsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\n                        visitRole: function (role, context) {\n                            transformedColumnsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedColumnsHierarchy_1 || prototype.columns, role, projection);\n                        }\n                    });\n                    if (transformedRowsHierarchy_1 || transformedColumnsHierarchy_1) {\n                        transformedDataView = inheritSingle(prototype);\n                        transformedDataView.rows = transformedRowsHierarchy_1 || transformedDataView.rows;\n                        transformedDataView.columns = transformedColumnsHierarchy_1 || transformedDataView.columns;\n                    }\n                }\n                return transformedDataView;\n            }\n            /**\n             * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\n             * values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\n             */\n            function reorderMatrixHierarchyCompositeGroups(matrixHierarchy, hierarchyRole, projection) {\n                debug.assertValue(matrixHierarchy, 'matrixHierarchy');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                var transformedHierarchy;\n                var selectIndicesInProjectionOrder = projection[hierarchyRole];\n                // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\n                var hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\n                if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\n                    for (var i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\n                        var hierarchyLevel = matrixHierarchy.levels[i];\n                        // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\n                        var newToOldLevelSourceIndicesMapping = createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\n                        if (newToOldLevelSourceIndicesMapping) {\n                            if (_.isUndefined(transformedHierarchy)) {\n                                // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\n                                // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\n                                transformedHierarchy = inheritSingle(matrixHierarchy);\n                                transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\n                                // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\n                                // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\n                                // happen in other hierarchy levels in the later iterations of this for-loop.\n                                transformedHierarchy.root = data.utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\n                            }\n                            // reorder the metadata columns in the sources array at that level\n                            var transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\n                            transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\n                            // reorder the level values in the composite group nodes at the current hierarchy level\n                            reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\n                        }\n                    }\n                }\n                return transformedHierarchy;\n            }\n            /**\n             * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\n             * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\n             *\n             * The returned value maps level source indices from the new target order (calculated from projection order)\n             * back to the original order as they appear in the specified hierarchyLevel's sources.\n             * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\n             *\n             * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\n             *\n             * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\n             * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\n             * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\n             */\n            function createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\n                var newToOldLevelSourceIndicesMapping;\n                var levelSourceColumns = hierarchyLevel.sources;\n                if (levelSourceColumns && levelSourceColumns.length >= 2) {\n                    // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\n                    var columnsForHierarchyRoleOrderedByLevelSourceIndex = data.utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(levelSourceColumns, projection, hierarchyRole);\n                    if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\n                        // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\n                        var columnsForHierarchyRoleOrderedByProjection = _.sortBy(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.projectionOrderIndex; });\n                        newToOldLevelSourceIndicesMapping = createOrderMapping(_.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.sourceIndex; }), _.map(columnsForHierarchyRoleOrderedByProjection, function (columnInfo) { return columnInfo.sourceIndex; }));\n                    }\n                }\n                return newToOldLevelSourceIndicesMapping;\n            }\n            /**\n             * Applies re-ordering on the specified transformingHierarchyLevel's sources.\n             * Returns the same object as the specified transformingHierarchyLevel.\n             */\n            function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var originalLevelSources = transformingHierarchyLevel.sources;\n                transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\n                var newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\n                for (var i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\n                    var newLevelSourceIndex = newLevelSourceIndices[i];\n                    var oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\n                    debug.assert(oldLevelSourceIndex < originalLevelSources.length, 'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\n                    transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\n                }\n                return transformingHierarchyLevel;\n            }\n            /**\n             * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\n             * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\n             *\n             * Returns the same object as the specified transformingHierarchyRootNode.\n             */\n            function reorderMatrixHierarchyLevelValues(transformingHierarchyRootNode, transformingHierarchyLevelIndex, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var oldToNewLevelSourceIndicesMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\n                forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, function (transformingMatrixNode) {\n                    var originalLevelValues = transformingMatrixNode.levelValues;\n                    // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\n                    // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\n                    // The following code isn't correct in the special case where a column is projected twice in this composite group,\n                    // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\n                    // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\n                    if (!_.isEmpty(originalLevelValues)) {\n                        // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\n                        // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\n                        // because we don't want to accidentally modify the array AND its value references in Query DataView\n                        var newlyOrderedLevelValues = _.sortBy(originalLevelValues, function (levelValue) { return oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]; });\n                        for (var i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\n                            var transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\n                            transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\n                            newlyOrderedLevelValues[i] = transformingLevelValue;\n                        }\n                        transformingMatrixNode.levelValues = newlyOrderedLevelValues;\n                        // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\n                        // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\n                        var newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\n                        if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\n                            transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\n                        }\n                        if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\n                            transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\n                        }\n                    }\n                });\n                return transformingHierarchyRootNode;\n            }\n            /**\n             * Creates a mapping of new position to original position.\n             *\n             * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\n             * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\n             * - the value in the key-value pair is the index of the particular column in the original order\n             */\n            function createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites) {\n                var role = matrixValues.for.in;\n                var newOrder = projectionOrdering[role];\n                var originalOrder = _.chain(columnRewrites)\n                    .filter(function (rewrite) { return _.contains(valueSources, rewrite.to); })\n                    .map(function (rewrite) { return rewrite.from.index; })\n                    .value();\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            /**\n             * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\n             * originalOrder array.\n             * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\n             * under the context of the caller code), e.g. the Select Index in projection ordering array.\n             * Also, the specified originalOrder must contain every value that exists in newOrder.\n             *\n             * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\n             * key-value pair, each of which represents the new and old indices of a particular column:\n             * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\n             * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\n             *\n             * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\n             *\n             * If the specified originalOrder and newOrder are same, then this function returns undefined.\n             *\n             * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\n             * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\n             */\n            function createOrderMapping(originalOrder, newOrder) {\n                // Optimization: avoid rewriting if the current order is correct\n                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, function (x, y) { return x === y; }))\n                    return;\n                var mapping = {};\n                for (var i = 0, len = newOrder.length; i < len; ++i) {\n                    var newPosition = newOrder[i];\n                    mapping[i] = originalOrder.indexOf(newPosition);\n                }\n                return mapping;\n            }\n            function createReversedMapping(mapping) {\n                debug.assertValue(mapping, 'mapping');\n                var reversed = {};\n                for (var key in mapping) {\n                    // Note: key is a string after we get it out from mapping, thus we need to parse it\n                    // back into a number before putting it as the value in the reversed mapping\n                    var value = mapping[key];\n                    var keyAsNumber = parseInt(key, 10);\n                    reversed[value] = keyAsNumber;\n                }\n                debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length, 'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\n                return reversed;\n            }\n            function forEachNodeAtLevel(node, targetLevel, callback) {\n                debug.assertValue(node, 'node');\n                debug.assert(targetLevel >= 0, 'argetLevel >= 0');\n                debug.assertValue(callback, 'callback');\n                if (node.level === targetLevel) {\n                    callback(node);\n                    return;\n                }\n                var children = node.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachNodeAtLevel(children[i], targetLevel, callback);\n                }\n            }\n            DataViewTransform.forEachNodeAtLevel = forEachNodeAtLevel;\n            function findOverride(source, columnRewrites) {\n                for (var i = 0, len = columnRewrites.length; i < len; i++) {\n                    var columnRewrite = columnRewrites[i];\n                    if (columnRewrite.from === source)\n                        return columnRewrite.to;\n                }\n            }\n            function ensureRewritten(rewritten, prototype, callback) {\n                if (!rewritten)\n                    rewritten = inherit(prototype);\n                if (callback)\n                    callback(rewritten);\n                return rewritten;\n            }\n            function transformObjects(dataView, targetDataViewKinds, objectDescriptors, objectDefinitions, selectTransforms, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!objectDescriptors)\n                    return;\n                var objectsForAllSelectors = data.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\n                data.DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\n                var metadataOnce = objectsForAllSelectors.metadataOnce;\n                var dataObjects = objectsForAllSelectors.data;\n                if (metadataOnce)\n                    evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\n                var metadataObjects = objectsForAllSelectors.metadata;\n                if (metadataObjects) {\n                    for (var i = 0, len = metadataObjects.length; i < len; i++) {\n                        var metadataObject = metadataObjects[i];\n                        var objectDefns = metadataObject.objects;\n                        var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                        evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\n                    }\n                }\n                for (var i = 0, len = dataObjects.length; i < len; i++) {\n                    var dataObject = dataObjects[i];\n                    var objectDefns = dataObject.objects;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                    evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\n                }\n                var userDefined = objectsForAllSelectors.userDefined;\n                if (userDefined) {\n                    // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\n                    evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\n                }\n            }\n            DataViewTransform.transformObjects = transformObjects;\n            function evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var dataViewObjects = dataView.metadata.objects;\n                if (!dataViewObjects) {\n                    dataViewObjects = dataView.metadata.objects = {};\n                }\n                for (var _i = 0, objectDefns_1 = objectDefns; _i < objectDefns_1.length; _i++) {\n                    var objectDefn = objectDefns_1[_i];\n                    var id = objectDefn.selector.id;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\n                    var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                    var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\n                    for (var objectName in objects) {\n                        var object = objects[objectName];\n                        var map = dataViewObjects[objectName];\n                        if (!map)\n                            map = dataViewObjects[objectName] = [];\n                        debug.assert(powerbi.DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\n                        // NOTE: We do not check for duplicate ids.\n                        map.push({ id: id, object: object });\n                    }\n                }\n            }\n            /** Evaluates and sets properties on the DataView metadata. */\n            function evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, objectDefns, dataObjects, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(dataObjects, 'dataObjects');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                if (objects) {\n                    dataView.metadata.objects = objects;\n                    for (var objectName in objects) {\n                        var object = objects[objectName], objectDesc = objectDescriptors[objectName];\n                        for (var propertyName in object) {\n                            var propertyDesc = objectDesc.properties[propertyName], ruleDesc = propertyDesc.rule;\n                            if (!ruleDesc)\n                                continue;\n                            var definition = createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, object[propertyName], propertyDesc.type);\n                            if (!definition)\n                                continue;\n                            dataObjects.push(definition);\n                        }\n                    }\n                }\n            }\n            function createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, propertyValue, ruleType) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(propertyValue, 'propertyValue');\n                debug.assertValue(ruleType, 'ruleType');\n                var ruleOutput = ruleDesc.output;\n                if (!ruleOutput)\n                    return;\n                var selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\n                if (!selectorToCreate)\n                    return;\n                if (ruleType.fillRule) {\n                    return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue);\n                }\n            }\n            function createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(selectorToCreate, 'selectorToCreate');\n                debug.assertValue(propertyValue, 'propertyValue');\n                var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, 1 /* Role */, propertyValue);\n                if (!colorAllocator)\n                    return;\n                var rule = new data.ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\n                var fillRuleProperties = {};\n                fillRuleProperties[ruleDesc.output.property] = {\n                    solid: { color: rule }\n                };\n                return {\n                    selector: selectorToCreate,\n                    rules: [rule],\n                    objects: [{\n                            name: objectName,\n                            properties: fillRuleProperties,\n                        }]\n                };\n            }\n            function tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(propertyValue, 'propertyValue');\n                if (propertyValue.linearGradient2)\n                    return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\n                if (propertyValue.linearGradient3)\n                    return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\n            }\n            function createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient2) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient2, 'linearGradient2');\n                linearGradient2 = propertyValueFillRule.linearGradient2;\n                if (linearGradient2.min.value === undefined ||\n                    linearGradient2.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    if (linearGradient2.min.value === undefined)\n                        linearGradient2.min.value = inputRange.min;\n                    if (linearGradient2.max.value === undefined)\n                        linearGradient2.max.value = inputRange.max;\n                }\n                return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\n            }\n            function createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient3) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient3, 'linearGradient3');\n                var splitScales;\n                linearGradient3 = propertyValueFillRule.linearGradient3;\n                if (linearGradient3.min.value === undefined ||\n                    linearGradient3.mid.value === undefined ||\n                    linearGradient3.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    splitScales =\n                        linearGradient3.min.value === undefined &&\n                            linearGradient3.max.value === undefined &&\n                            linearGradient3.mid.value !== undefined;\n                    if (linearGradient3.min.value === undefined) {\n                        linearGradient3.min.value = inputRange.min;\n                    }\n                    if (linearGradient3.max.value === undefined) {\n                        linearGradient3.max.value = inputRange.max;\n                    }\n                    if (linearGradient3.mid.value === undefined) {\n                        var midValue = (linearGradient3.max.value + linearGradient3.min.value) / 2;\n                        linearGradient3.mid.value = midValue;\n                    }\n                }\n                return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\n            }\n            function populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var cache = data.createColorAllocatorCache();\n                var staticEvalContext = data.createStaticEvalContext();\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefnProperties = objectDefns[i].properties;\n                    for (var propertyName in objectDefnProperties) {\n                        var fillProperty = objectDefnProperties[propertyName];\n                        if (fillProperty &&\n                            fillProperty.solid &&\n                            fillProperty.solid.color &&\n                            fillProperty.solid.color.kind === 23 /* FillRule */) {\n                            var fillRuleExpr = fillProperty.solid.color;\n                            var inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\n                            if (!inputExprQueryName)\n                                continue;\n                            var fillRule = data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, fillRulePropertyDescriptor, fillRuleExpr.rule);\n                            var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, 0 /* QueryName */, fillRule);\n                            if (colorAllocator)\n                                cache.register(fillRuleExpr, colorAllocator);\n                        }\n                    }\n                }\n                return cache;\n            }\n            function evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, selector, rules, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\n                var containsWildcard = data.Selector.containsWildcard(selector);\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {\n                    // 1) Match against categories\n                    evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    // 2) Match against valueGrouping\n                    evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                }\n                var dataViewMatrix = dataView.matrix;\n                if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {\n                    var rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenMatrix) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.matrix = rewrittenMatrix;\n                    }\n                }\n                var dataViewTable = dataView.table;\n                if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {\n                    var rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\n                    var rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenTable) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.table = rewrittenTable;\n                    }\n                }\n            }\n            function rewriteTableRoleSelector(dataViewTable, selector) {\n                if (data.Selector.hasRoleWildcard(selector)) {\n                    selector = findSelectorForRoleWildcard(dataViewTable, selector);\n                }\n                return selector;\n            }\n            function findSelectorForRoleWildcard(dataViewTable, selector) {\n                var resultingSelector = {\n                    data: [],\n                    id: selector.id,\n                    metadata: selector.metadata\n                };\n                for (var _i = 0, _a = selector.data; _i < _a.length; _i++) {\n                    var dataSelector = _a[_i];\n                    if (data.Selector.isRoleWildcard(dataSelector)) {\n                        var selectorRoles = dataSelector.roles;\n                        var allColumnsBelongToSelectorRole = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\n                        var exprs = dataViewTable.identityFields;\n                        if (allColumnsBelongToSelectorRole && exprs) {\n                            resultingSelector.data.push(data.DataViewScopeWildcard.fromExprs(exprs));\n                            continue;\n                        }\n                    }\n                    if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\n                        resultingSelector.data.push(dataSelector);\n                    }\n                }\n                return resultingSelector;\n            }\n            function isUniqueDataSelector(dataSelectors, newSelector) {\n                if (_.isEmpty(dataSelectors))\n                    return true;\n                return !_.any(dataSelectors, function (dataSelector) { return dataSelector.key === newSelector.key; });\n            }\n            function allColumnsBelongToRole(columns, selectorRoles) {\n                for (var _i = 0, columns_6 = columns; _i < columns_6.length; _i++) {\n                    var column = columns_6[_i];\n                    var roles = column.roles;\n                    if (!roles || !_.any(selectorRoles, function (selectorRole) { return roles[selectorRole]; }))\n                        return false;\n                }\n                return true;\n            }\n            function evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\n                    return;\n                var targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\n                if (!targetColumn)\n                    return;\n                var identities = targetColumn.identities, foundMatch, evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                if (!identities)\n                    return;\n                debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\n                for (var i = 0, len = identities.length; i < len; i++) {\n                    var identity = identities[i];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(i);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (!targetColumn.column.objects) {\n                                targetColumn.column.objects = [];\n                                targetColumn.column.objects.length = len;\n                            }\n                            targetColumn.column.objects[i] = objects;\n                        }\n                        if (!containsWildcard)\n                            return true;\n                        foundMatch = true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var dataViewCategoricalValues = dataViewCategorical.values;\n                if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [dataViewCategoricalValues.identityFields]))\n                    return;\n                var valuesGrouped = dataViewCategoricalValues.grouped();\n                if (!valuesGrouped)\n                    return;\n                // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\n                // This should be enhanced in the future.\n                var evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                var foundMatch;\n                for (var i = 0, len = valuesGrouped.length; i < len; i++) {\n                    var valueGroup = valuesGrouped[i];\n                    var selectorMetadata = selector.metadata;\n                    var valuesInGroup = valueGroup.values;\n                    if (containsWildcard || data.Selector.matchesData(selector, [valueGroup.identity])) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (selectorMetadata) {\n                                for (var j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\n                                    var valueColumn = valuesInGroup[j], valueSource = valueColumn.source;\n                                    if (valueSource.queryName === selectorMetadata) {\n                                        var valueSourceOverwrite = powerbi.Prototype.inherit(valueSource);\n                                        valueSourceOverwrite.objects = objects;\n                                        valueColumn.source = valueSourceOverwrite;\n                                        foundMatch = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            else {\n                                valueGroup.objects = objects;\n                                setGrouped(dataViewCategoricalValues, valuesGrouped);\n                                foundMatch = true;\n                            }\n                        }\n                        if (!containsWildcard)\n                            return true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                var evalContext = data.createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\n                var rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                var rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows || rewrittenCols) {\n                    var rewrittenMatrix = inheritSingle(dataViewMatrix);\n                    if (rewrittenRows)\n                        rewrittenMatrix.rows = rewrittenRows;\n                    if (rewrittenCols)\n                        rewrittenMatrix.columns = rewrittenCols;\n                    return rewrittenMatrix;\n                }\n            }\n            function evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrixHierarchy, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (!dataViewMatrixHierarchy)\n                    return;\n                var root = dataViewMatrixHierarchy.root;\n                if (!root)\n                    return;\n                var rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRoot) {\n                    var rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\n                    rewrittenHierarchy.root = rewrittenRoot;\n                    return rewrittenHierarchy;\n                }\n            }\n            function evaluateDataRepetitionMatrixNode(evalContext, dataViewNode, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(dataViewNode, 'dataViewNode');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var childNodes = dataViewNode.children;\n                if (!childNodes)\n                    return;\n                var rewrittenNode;\n                var shouldSearchChildren;\n                var childIdentityFields = dataViewNode.childIdentityFields;\n                if (childIdentityFields) {\n                    // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\n                    shouldSearchChildren = data.Selector.matchesKeys(selector, [childIdentityFields]);\n                }\n                for (var i = 0, len = childNodes.length; i < len; i++) {\n                    var childNode = childNodes[i], identity = childNode.identity, rewrittenChildNode = null;\n                    if (shouldSearchChildren) {\n                        if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                            // TODO: Need to initialize context for rule-based properties.  Rule-based properties\n                            // (such as fillRule/gradients) are not currently implemented.\n                            var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                            if (objects) {\n                                rewrittenChildNode = inheritSingle(childNode);\n                                rewrittenChildNode.objects = objects;\n                            }\n                        }\n                    }\n                    else {\n                        rewrittenChildNode = evaluateDataRepetitionMatrixNode(evalContext, childNode, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                    }\n                    if (rewrittenChildNode) {\n                        if (!rewrittenNode)\n                            rewrittenNode = inheritNodeAndChildren(dataViewNode);\n                        rewrittenNode.children[i] = rewrittenChildNode;\n                        if (!containsWildcard) {\n                            // NOTE: once we find a match for a non-wildcard selector, stop looking.\n                            break;\n                        }\n                    }\n                }\n                return rewrittenNode;\n            }\n            function inheritNodeAndChildren(node) {\n                if (Object.getPrototypeOf(node) !== Object.prototype) {\n                    return node;\n                }\n                var inherited = inheritSingle(node);\n                inherited.children = inherit(node.children);\n                return inherited;\n            }\n            function evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewTable, 'dataViewTable');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var evalContext = data.createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\n                var rewrittenRows = evaluateDataRepetitionTableRows(evalContext, dataViewTable.columns, dataViewTable.rows, dataViewTable.identity, dataViewTable.identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows) {\n                    var rewrittenTable = inheritSingle(dataViewTable);\n                    rewrittenTable.rows = rewrittenRows;\n                    return rewrittenTable;\n                }\n            }\n            function evaluateDataRepetitionTableRows(evalContext, columns, rows, identities, identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(rows, 'rows');\n                debug.assertAnyValue(identities, 'identities');\n                debug.assertAnyValue(identityFields, 'identityFields');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (_.isEmpty(identities) || _.isEmpty(identityFields))\n                    return;\n                if (!selector.metadata ||\n                    !data.Selector.matchesKeys(selector, [identityFields]))\n                    return;\n                var colIdx = _.findIndex(columns, function (col) { return col.queryName === selector.metadata; });\n                if (colIdx < 0)\n                    return;\n                debug.assert(rows.length === identities.length, 'row length mismatch');\n                var colLen = columns.length;\n                var inheritedRows;\n                for (var rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\n                    var identity = identities[rowIdx];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(rowIdx);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            if (!inheritedRows)\n                                inheritedRows = inheritSingle(rows);\n                            var inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\n                            var objectsForColumns = inheritedRow.objects;\n                            if (!objectsForColumns)\n                                inheritedRow.objects = objectsForColumns = new Array(colLen);\n                            objectsForColumns[colIdx] = objects;\n                        }\n                        if (!containsWildcard)\n                            break;\n                    }\n                }\n                return inheritedRows;\n            }\n            function evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, selector, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                // revisit this, likely when we do lazy evaluation of DataView.\n                var columns = dataView.metadata.columns, metadataId = selector.metadata, evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                for (var i = 0, len = columns.length; i < len; i++) {\n                    var column = columns[i];\n                    if (column.queryName === metadataId) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects)\n                            column.objects = objects;\n                    }\n                }\n            }\n            /** Attempts to find a column that can possibly match the selector. */\n            function findSelectedCategoricalColumn(dataViewCategorical, selector) {\n                debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\n                var categoricalColumn = dataViewCategorical.categories[0];\n                if (!categoricalColumn.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [categoricalColumn.identityFields]))\n                    return;\n                var identities = categoricalColumn.identity, targetColumn = categoricalColumn;\n                var selectedMetadataId = selector.metadata;\n                if (selectedMetadataId) {\n                    var valueColumns = dataViewCategorical.values;\n                    if (valueColumns) {\n                        for (var i = 0, len = valueColumns.length; i < len; i++) {\n                            var valueColumn = valueColumns[i];\n                            if (valueColumn.source.queryName === selectedMetadataId) {\n                                targetColumn = valueColumn;\n                                break;\n                            }\n                        }\n                    }\n                }\n                return {\n                    column: targetColumn,\n                    identities: identities,\n                };\n            }\n            function findSelectorForRuleInput(dataView, selectorRoles) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectorRoles, 'selectorRoles');\n                if (selectorRoles.length !== 1)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical)\n                    return;\n                var categories = dataViewCategorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var categoryColumn = categories[0], categoryRoles = categoryColumn.source.roles, categoryIdentityFields = categoryColumn.identityFields;\n                if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\n                    return;\n                return { data: [data.DataViewScopeWildcard.fromExprs(categoryIdentityFields)] };\n            }\n            function findFirstQueryNameForExpr(selectTransforms, expr) {\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(expr, 'expr');\n                if (data.SQExpr.isSelectRef(expr))\n                    return expr.expressionName;\n                if (!selectTransforms)\n                    return;\n                for (var i = 0, len = selectTransforms.length; i < len; i++) {\n                    var select = selectTransforms[i], columnExpr = select.expr;\n                    if (!columnExpr || !data.SQExpr.equals(expr, select.expr))\n                        continue;\n                    return select.queryName;\n                }\n            }\n            /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\n            function findRuleInputColumnNumberRange(dataView, identifier, identifierKind) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                var columns = dataView.metadata.columns;\n                for (var i = 0, len = columns.length; i < len; i++) {\n                    var column = columns[i];\n                    if (identifierKind === 1 /* Role */) {\n                        var valueColRoles = column.roles;\n                        if (!valueColRoles || !valueColRoles[identifier])\n                            continue;\n                    }\n                    else {\n                        debug.assert(identifierKind === 0 /* QueryName */, 'identifierKind === ColumnIdentifierKind.QueryName');\n                        if (column.queryName !== identifier)\n                            continue;\n                    }\n                    var aggregates = column.aggregates;\n                    if (!aggregates)\n                        continue;\n                    var min = aggregates.min;\n                    if (min === undefined)\n                        min = aggregates.minLocal;\n                    if (min === undefined)\n                        continue;\n                    var max = aggregates.max;\n                    if (max === undefined)\n                        max = aggregates.maxLocal;\n                    if (max === undefined)\n                        continue;\n                    return { min: min, max: max };\n                }\n            }\n            // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\n            function createValueColumns(values, valueIdentityFields, source) {\n                if (values === void 0) { values = []; }\n                var result = values;\n                setGrouped(values);\n                if (valueIdentityFields)\n                    result.identityFields = valueIdentityFields;\n                if (source)\n                    result.source = source;\n                return result;\n            }\n            DataViewTransform.createValueColumns = createValueColumns;\n            function setGrouped(values, groupedResult) {\n                values.grouped = groupedResult\n                    ? function () { return groupedResult; }\n                    : function () { return groupValues(values); };\n            }\n            DataViewTransform.setGrouped = setGrouped;\n            /** Group together the values with a common identity. */\n            function groupValues(values) {\n                debug.assertValue(values, 'values');\n                var groups = [], currentGroup;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    if (!currentGroup || currentGroup.identity !== value.identity) {\n                        currentGroup = {\n                            values: []\n                        };\n                        if (value.identity) {\n                            currentGroup.identity = value.identity;\n                            var source = value.source;\n                            // allow null, which will be formatted as (Blank).\n                            if (source.groupName !== undefined)\n                                currentGroup.name = source.groupName;\n                            else if (source.displayName)\n                                currentGroup.name = source.displayName;\n                        }\n                        groups.push(currentGroup);\n                    }\n                    currentGroup.values.push(value);\n                }\n                return groups;\n            }\n            function pivotIfNecessary(dataView, dataViewMappings) {\n                debug.assertValue(dataView, 'dataView');\n                var transformedDataView;\n                switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\n                    case 1 /* Pivot */:\n                        transformedDataView = data.DataViewPivotCategorical.apply(dataView);\n                        break;\n                    case 2 /* SelfCrossJoin */:\n                        transformedDataView = data.DataViewSelfCrossJoin.apply(dataView);\n                        break;\n                }\n                return transformedDataView || dataView;\n            }\n            function determineCategoricalTransformation(categorical, dataViewMappings) {\n                if (!categorical || _.isEmpty(dataViewMappings))\n                    return;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var values = categorical.values;\n                if (_.isEmpty(values))\n                    return;\n                if (values.grouped().some(function (vg) { return !!vg.identity; }))\n                    return;\n                // If we made it here, the DataView has a single category and no valueGrouping.\n                var categoryRoles = categories[0].source.roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingCategorical = dataViewMappings[i].categorical;\n                    if (!roleMappingCategorical)\n                        continue;\n                    if (!hasRolesGrouped(categoryRoles, roleMappingCategorical.values))\n                        continue;\n                    // If we made it here, the DataView's single category has the value grouping role.\n                    var categoriesMapping = roleMappingCategorical.categories;\n                    var hasCategoryRole = hasRolesBind(categoryRoles, categoriesMapping) ||\n                        hasRolesFor(categoryRoles, categoriesMapping);\n                    if (hasCategoryRole)\n                        return 2 /* SelfCrossJoin */;\n                    return 1 /* Pivot */;\n                }\n            }\n            function shouldPivotMatrix(matrix, dataViewMappings) {\n                if (!matrix || _.isEmpty(dataViewMappings))\n                    return;\n                var rowLevels = matrix.rows.levels;\n                if (rowLevels.length < 1)\n                    return;\n                var rows = matrix.rows.root.children;\n                if (!rows || rows.length === 0)\n                    return;\n                var rowRoles = rowLevels[0].sources[0].roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingMatrix = dataViewMappings[i].matrix;\n                    if (!roleMappingMatrix)\n                        continue;\n                    if (!hasRolesFor(rowRoles, roleMappingMatrix.rows) &&\n                        hasRolesFor(rowRoles, roleMappingMatrix.columns)) {\n                        return true;\n                    }\n                }\n            }\n            function hasRolesBind(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.bind)\n                    return roles[roleMapping.bind.to];\n            }\n            function hasRolesFor(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.for)\n                    return roles[roleMapping.for.in];\n            }\n            function hasRolesGrouped(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.group)\n                    return roles[roleMapping.group.by];\n            }\n        })(DataViewTransform = data.DataViewTransform || (data.DataViewTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createDisplayNameGetter(displayNameKey) {\n            return function (resourceProvider) { return resourceProvider.get(displayNameKey); };\n        }\n        data.createDisplayNameGetter = createDisplayNameGetter;\n        function getDisplayName(displayNameGetter, resourceProvider) {\n            if (typeof displayNameGetter === 'function')\n                return displayNameGetter(resourceProvider);\n            if (typeof displayNameGetter === 'string')\n                return displayNameGetter;\n        }\n        data.getDisplayName = getDisplayName;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Enumeration of DateTimeUnits */\n    (function (DateTimeUnit) {\n        DateTimeUnit[DateTimeUnit[\"Year\"] = 0] = \"Year\";\n        DateTimeUnit[DateTimeUnit[\"Month\"] = 1] = \"Month\";\n        DateTimeUnit[DateTimeUnit[\"Week\"] = 2] = \"Week\";\n        DateTimeUnit[DateTimeUnit[\"Day\"] = 3] = \"Day\";\n        DateTimeUnit[DateTimeUnit[\"Hour\"] = 4] = \"Hour\";\n        DateTimeUnit[DateTimeUnit[\"Minute\"] = 5] = \"Minute\";\n        DateTimeUnit[DateTimeUnit[\"Second\"] = 6] = \"Second\";\n        DateTimeUnit[DateTimeUnit[\"Millisecond\"] = 7] = \"Millisecond\";\n    })(powerbi.DateTimeUnit || (powerbi.DateTimeUnit = {}));\n    var DateTimeUnit = powerbi.DateTimeUnit;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function fieldExpr(fieldExpr) {\n                var sqExpr = FieldExprPattern.visit(fieldExpr, FieldExprToSQExprVisitor.instance);\n                debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\n                return sqExpr;\n            }\n            SQExprBuilder.fieldExpr = fieldExpr;\n            function fromColumnAggr(columnAggr) {\n                return SQExprBuilder.aggregate(fromColumn(columnAggr), columnAggr.aggregate);\n            }\n            SQExprBuilder.fromColumnAggr = fromColumnAggr;\n            function fromColumn(column) {\n                return SQExprBuilder.columnRef(fromEntity(column), column.name);\n            }\n            SQExprBuilder.fromColumn = fromColumn;\n            function fromEntity(entityPattern) {\n                return SQExprBuilder.entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\n            }\n            SQExprBuilder.fromEntity = fromEntity;\n            function fromEntityAggr(entityAggr) {\n                return SQExprBuilder.aggregate(fromEntity(entityAggr), entityAggr.aggregate);\n            }\n            SQExprBuilder.fromEntityAggr = fromEntityAggr;\n            function fromHierarchyLevelAggr(hierarchyLevelAggr) {\n                return SQExprBuilder.aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\n            }\n            SQExprBuilder.fromHierarchyLevelAggr = fromHierarchyLevelAggr;\n            function fromHierarchyLevel(hierarchyLevelPattern) {\n                return SQExprBuilder.hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\n            }\n            SQExprBuilder.fromHierarchyLevel = fromHierarchyLevel;\n            function fromHierarchy(hierarchyPattern) {\n                return SQExprBuilder.hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\n            }\n            SQExprBuilder.fromHierarchy = fromHierarchy;\n            var FieldExprToSQExprVisitor = (function () {\n                function FieldExprToSQExprVisitor() {\n                }\n                FieldExprToSQExprVisitor.prototype.visitColumn = function (column) {\n                    return fromColumn(column);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return fromColumnAggr(columnAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariationPattern) {\n                    return SQExprBuilder.propertyVariationSource(this.visitEntity(columnHierarchyLevelVariationPattern.source), columnHierarchyLevelVariationPattern.source.name, columnHierarchyLevelVariationPattern.level.name);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntity = function (entityPattern) {\n                    return fromEntity(entityPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return fromEntityAggr(entityAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchy = function (hierarchyPattern) {\n                    return fromHierarchy(hierarchyPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevel = function (level) {\n                    return fromHierarchyLevel(level);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return fromHierarchyLevelAggr(hierarchyLevelAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitMeasure = function (measure) {\n                    return SQExprBuilder.measureRef(this.visitEntity(measure), measure.name);\n                };\n                FieldExprToSQExprVisitor.prototype.visitPercentile = function (percentile) {\n                    var arg = SQExprBuilder.fieldExpr(percentile.arg);\n                    return SQExprBuilder.percentile(arg, percentile.k, percentile.exclusive);\n                };\n                FieldExprToSQExprVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    var baseSQExpr = SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr);\n                    return SQExprBuilder.arithmetic(baseSQExpr, SQExprBuilder.scopedEval(baseSQExpr, []), 3 /* Divide */);\n                };\n                FieldExprToSQExprVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return SQExprBuilder.selectRef(selectRef.expressionName);\n                };\n                FieldExprToSQExprVisitor.instance = new FieldExprToSQExprVisitor();\n                return FieldExprToSQExprVisitor;\n            }());\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asFieldPattern(sqExpr) {\n                return sqExpr.accept(FieldExprPatternBuilder.instance);\n            }\n            SQExprConverter.asFieldPattern = asFieldPattern;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        var FieldExprPatternBuilder = (function (_super) {\n            __extends(FieldExprPatternBuilder, _super);\n            function FieldExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            FieldExprPatternBuilder.prototype.visitColumnRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var columnRef = sourceRef.entity;\n                    columnRef.name = expr.ref;\n                    return { column: columnRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitMeasureRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var measureRef = sourceRef.entity;\n                    measureRef.name = expr.ref;\n                    return { measure: measureRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            FieldExprPatternBuilder.prototype.visitAggr = function (expr) {\n                var fieldPattern = expr.arg.accept(this);\n                if (fieldPattern && fieldPattern.column) {\n                    var argAggr = fieldPattern.column;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.columnAggr) {\n                    var argAggr = fieldPattern.columnAggr;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.hierarchyLevel) {\n                    var argAggr = fieldPattern.hierarchyLevel;\n                    argAggr.aggregate = expr.func;\n                    return { hierarchyLevelAggr: argAggr };\n                }\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var argAggr = sourcePattern.entity;\n                    argAggr.aggregate = expr.func;\n                    return { entityAggr: argAggr };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitPercentile = function (expr) {\n                return {\n                    percentile: {\n                        arg: expr.arg.accept(this),\n                        k: expr.k,\n                        exclusive: expr.exclusive,\n                    }\n                };\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchy = function (expr) {\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var hierarchyRef = (sourcePattern.entity);\n                    hierarchyRef.name = expr.hierarchy;\n                    return { hierarchy: hierarchyRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchyLevel = function (expr) {\n                var hierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\n                if (!hierarchySourceExprPattern)\n                    return;\n                var hierarchyLevel;\n                if (hierarchySourceExprPattern.hierarchy) {\n                    hierarchyLevel = {\n                        entity: hierarchySourceExprPattern.hierarchy.entity,\n                        schema: hierarchySourceExprPattern.hierarchy.schema,\n                        name: hierarchySourceExprPattern.hierarchy.name,\n                        level: expr.level,\n                    };\n                }\n                if (hierarchySourceExprPattern.variation) {\n                    return {\n                        columnHierarchyLevelVariation: {\n                            source: {\n                                entity: hierarchySourceExprPattern.variation.column.entity,\n                                schema: hierarchySourceExprPattern.variation.column.schema,\n                                name: hierarchySourceExprPattern.variation.column.name,\n                            },\n                            level: hierarchyLevel,\n                            variationName: hierarchySourceExprPattern.variation.variationName,\n                        }\n                    };\n                }\n                return { hierarchyLevel: hierarchyLevel };\n            };\n            FieldExprPatternBuilder.prototype.visitArithmetic = function (expr) {\n                var percentOfGrandTotalPattern = {\n                    percentOfGrandTotal: {\n                        baseExpr: expr.left.accept(this)\n                    }\n                };\n                if (data.SQExpr.equals(expr, SQExprBuilder.fieldExpr(percentOfGrandTotalPattern))) {\n                    return percentOfGrandTotalPattern;\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitSelectRef = function (expr) {\n                return {\n                    selectRef: {\n                        expressionName: expr.expressionName,\n                    }\n                };\n            };\n            FieldExprPatternBuilder.instance = new FieldExprPatternBuilder();\n            return FieldExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var SourceExprPatternBuilder = (function (_super) {\n            __extends(SourceExprPatternBuilder, _super);\n            function SourceExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            SourceExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            SourceExprPatternBuilder.prototype.visitPropertyVariationSource = function (expr) {\n                var entityExpr = expr.arg;\n                if (entityExpr instanceof data.SQEntityExpr) {\n                    var propertyVariationSource = {\n                        schema: entityExpr.schema,\n                        entity: entityExpr.entity,\n                        name: expr.property,\n                    };\n                    if (entityExpr.variable)\n                        propertyVariationSource.entityVar = entityExpr.variable;\n                    return {\n                        variation: {\n                            column: propertyVariationSource,\n                            variationName: expr.name,\n                        }\n                    };\n                }\n            };\n            SourceExprPatternBuilder.instance = new SourceExprPatternBuilder();\n            return SourceExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var HierarchyExprPatternBuiler = (function (_super) {\n            __extends(HierarchyExprPatternBuiler, _super);\n            function HierarchyExprPatternBuiler() {\n                _super.apply(this, arguments);\n            }\n            HierarchyExprPatternBuiler.prototype.visitHierarchy = function (expr) {\n                var exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                var hierarchyRef;\n                var variationRef;\n                if (exprPattern.variation) {\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.variation.column.schema,\n                        entity: exprPattern.variation.column.entity,\n                    };\n                    variationRef = exprPattern.variation;\n                }\n                else\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.entity.schema,\n                        entity: exprPattern.entity.entity,\n                    };\n                return {\n                    hierarchy: hierarchyRef,\n                    variation: variationRef\n                };\n            };\n            HierarchyExprPatternBuiler.instance = new HierarchyExprPatternBuiler();\n            return HierarchyExprPatternBuiler;\n        }(data.DefaultSQExprVisitor));\n        var FieldExprPattern;\n        (function (FieldExprPattern) {\n            function visit(expr, visitor) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(visitor, 'visitor');\n                var fieldExprPattern = expr instanceof data.SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\n                debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\n                if (fieldExprPattern.column)\n                    return visitColumn(fieldExprPattern.column, visitor);\n                if (fieldExprPattern.columnAggr)\n                    return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\n                if (fieldExprPattern.columnHierarchyLevelVariation)\n                    return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\n                if (fieldExprPattern.entity)\n                    return visitEntity(fieldExprPattern.entity, visitor);\n                if (fieldExprPattern.entityAggr)\n                    return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\n                if (fieldExprPattern.hierarchy)\n                    return visitHierarchy(fieldExprPattern.hierarchy, visitor);\n                if (fieldExprPattern.hierarchyLevel)\n                    return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\n                if (fieldExprPattern.hierarchyLevelAggr)\n                    return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\n                if (fieldExprPattern.measure)\n                    return visitMeasure(fieldExprPattern.measure, visitor);\n                if (fieldExprPattern.percentile)\n                    return visitPercentile(fieldExprPattern.percentile, visitor);\n                if (fieldExprPattern.percentOfGrandTotal)\n                    return visitPercentOfGrandTotal(fieldExprPattern.percentOfGrandTotal, visitor);\n                if (fieldExprPattern.selectRef)\n                    return visitSelectRef(fieldExprPattern.selectRef, visitor);\n                debug.assertFail('failed to visit a fieldExprPattern.');\n                return;\n            }\n            FieldExprPattern.visit = visit;\n            function visitColumn(column, visitor) {\n                debug.assertValue(column, 'column');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumn(column);\n            }\n            function visitColumnAggr(columnAggr, visitor) {\n                debug.assertValue(columnAggr, 'columnAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnAggr(columnAggr);\n            }\n            function visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation, visitor) {\n                debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\n            }\n            function visitEntity(entity, visitor) {\n                debug.assertValue(entity, 'entity');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntity(entity);\n            }\n            function visitEntityAggr(entityAggr, visitor) {\n                debug.assertValue(entityAggr, 'entityAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntityAggr(entityAggr);\n            }\n            function visitHierarchy(hierarchy, visitor) {\n                debug.assertValue(hierarchy, 'hierarchy');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchy(hierarchy);\n            }\n            function visitHierarchyLevel(hierarchyLevel, visitor) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevel(hierarchyLevel);\n            }\n            function visitHierarchyLevelAggr(hierarchyLevelAggr, visitor) {\n                debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\n            }\n            function visitMeasure(measure, visitor) {\n                debug.assertValue(measure, 'measure');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitMeasure(measure);\n            }\n            function visitSelectRef(selectRef, visitor) {\n                debug.assertValue(selectRef, 'selectRef');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitSelectRef(selectRef);\n            }\n            function visitPercentile(percentile, visitor) {\n                debug.assertValue(percentile, 'percentile');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitPercentile(percentile);\n            }\n            function visitPercentOfGrandTotal(percentOfGrandTotal, visitor) {\n                debug.assertValue(percentOfGrandTotal, 'percentOfGrandTotal');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitPercentOfGrandTotal(percentOfGrandTotal);\n            }\n            function toColumnRefSQExpr(columnPattern) {\n                return SQExprBuilder.columnRef(SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar), columnPattern.name);\n            }\n            FieldExprPattern.toColumnRefSQExpr = toColumnRefSQExpr;\n            function getAggregate(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\n            }\n            FieldExprPattern.getAggregate = getAggregate;\n            function isAggregation(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                return visit(fieldExpr, FieldExprPatternIsAggregationVisitor.instance);\n            }\n            FieldExprPattern.isAggregation = isAggregation;\n            function hasFieldExprName(fieldExpr) {\n                return (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.measure) !== undefined;\n            }\n            FieldExprPattern.hasFieldExprName = hasFieldExprName;\n            function getPropertyName(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprPropertyNameVisitor.instance);\n            }\n            FieldExprPattern.getPropertyName = getPropertyName;\n            function getHierarchyName(fieldExpr) {\n                var hierarchy = fieldExpr.hierarchy;\n                if (hierarchy)\n                    return hierarchy.name;\n            }\n            FieldExprPattern.getHierarchyName = getHierarchyName;\n            function getColumnRef(fieldExpr) {\n                if (fieldExpr.columnHierarchyLevelVariation)\n                    return fieldExpr.columnHierarchyLevelVariation.source;\n                return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\n            }\n            FieldExprPattern.getColumnRef = getColumnRef;\n            function getFieldExprName(fieldExpr) {\n                var name = getPropertyName(fieldExpr);\n                if (name)\n                    return name;\n                // In case it is an entity\n                return toFieldExprEntityPattern(fieldExpr).entity;\n            }\n            FieldExprPattern.getFieldExprName = getFieldExprName;\n            function getSchema(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                var item = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                debug.assertAnyValue(item, 'expected fieldExpr to be an entity item');\n                return item.schema;\n            }\n            FieldExprPattern.getSchema = getSchema;\n            function toFieldExprEntityPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityPattern = toFieldExprEntityPattern;\n            function toFieldExprEntityItemPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityItemPattern = toFieldExprEntityItemPattern;\n            var FieldExprPatternAggregateVisitor = (function () {\n                function FieldExprPatternAggregateVisitor() {\n                }\n                FieldExprPatternAggregateVisitor.prototype.visitColumn = function (column) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return columnAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntity = function (entity) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return entityAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return hierarchyLevelAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitMeasure = function (measure) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitPercentile = function (percentile) {\n                    // NOTE: Percentile behaves like an aggregate (i.e., can be performed over numeric columns like a SUM), but\n                    // this function can't really convey that because percentile (intentionally) isn't in QueryAggregateFunction enum.\n                    // This should be revisited when we have UI support for the Percentile aggregate.\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return data.SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr));\n                };\n                FieldExprPatternAggregateVisitor.instance = new FieldExprPatternAggregateVisitor();\n                return FieldExprPatternAggregateVisitor;\n            }());\n            var FieldExprPatternIsAggregationVisitor = (function () {\n                function FieldExprPatternIsAggregationVisitor() {\n                }\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumn = function (column) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitEntity = function (entity) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitMeasure = function (measure) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitPercentile = function (percentile) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.instance = new FieldExprPatternIsAggregationVisitor();\n                return FieldExprPatternIsAggregationVisitor;\n            }());\n            var FieldExprToEntityExprPatternBuilder = (function () {\n                function FieldExprToEntityExprPatternBuilder() {\n                }\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumn = function (column) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnAggr = function (columnAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntity = function (entity) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntityAggr = function (entityAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchy = function (hierarchy) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitMeasure = function (measure) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitSelectRef = function (selectRef) {\n                    return;\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitPercentile = function (percentile) {\n                    return FieldExprPattern.visit(percentile.arg, this);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n                };\n                FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern = function (exprPattern) {\n                    debug.assertValue(exprPattern, 'exprPattern');\n                    var pattern = { schema: exprPattern.schema, entity: exprPattern.entity };\n                    if (exprPattern.entityVar) {\n                        pattern.entityVar = exprPattern.entityVar;\n                    }\n                    return pattern;\n                };\n                FieldExprToEntityExprPatternBuilder.instance = new FieldExprToEntityExprPatternBuilder();\n                return FieldExprToEntityExprPatternBuilder;\n            }());\n            var FieldExprPropertyNameVisitor = (function () {\n                function FieldExprPropertyNameVisitor() {\n                }\n                FieldExprPropertyNameVisitor.prototype.visitColumn = function (column) {\n                    return column.name;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return columnAggr.name;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitEntity = function (entity) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitMeasure = function (measure) {\n                    return measure.name;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitPercentile = function (percentile) {\n                    return FieldExprPattern.visit(percentile.arg, this);\n                };\n                FieldExprPropertyNameVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n                };\n                FieldExprPropertyNameVisitor.instance = new FieldExprPropertyNameVisitor();\n                return FieldExprPropertyNameVisitor;\n            }());\n        })(FieldExprPattern = data.FieldExprPattern || (data.FieldExprPattern = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewAnalysis;\n    (function (DataViewAnalysis) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\n        (function (DataViewMappingMatchErrorCode) {\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooLarge\"] = 0] = \"conditionRangeTooLarge\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooSmall\"] = 1] = \"conditionRangeTooSmall\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedMeasure\"] = 2] = \"conditionKindExpectedMeasure\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGrouping\"] = 3] = \"conditionKindExpectedGrouping\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGroupingOrMeasure\"] = 4] = \"conditionKindExpectedGroupingOrMeasure\";\n        })(DataViewAnalysis.DataViewMappingMatchErrorCode || (DataViewAnalysis.DataViewMappingMatchErrorCode = {}));\n        var DataViewMappingMatchErrorCode = DataViewAnalysis.DataViewMappingMatchErrorCode;\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\n        function validateAndReshape(dataView, dataViewMappings) {\n            if (!dataViewMappings || dataViewMappings.length === 0)\n                return { dataView: dataView, isValid: true };\n            if (dataView) {\n                for (var _i = 0, dataViewMappings_3 = dataViewMappings; _i < dataViewMappings_3.length; _i++) {\n                    var dataViewMapping = dataViewMappings_3[_i];\n                    // Keep the original when possible.\n                    if (supports(dataView, dataViewMapping))\n                        return { dataView: dataView, isValid: true };\n                    if (dataViewMapping.categorical && dataView.categorical)\n                        return reshapeCategorical(dataView, dataViewMapping);\n                    if (dataViewMapping.tree && dataView.tree)\n                        return reshapeTree(dataView, dataViewMapping.tree);\n                    if (dataViewMapping.single && dataView.single)\n                        return reshapeSingle(dataView, dataViewMapping.single);\n                    if (dataViewMapping.table && dataView.table)\n                        return reshapeTable(dataView, dataViewMapping.table);\n                }\n            }\n            else if (powerbi.ScriptResultUtil.findScriptResult(dataViewMappings)) {\n                // Currently, PBI Service treats R Script Visuals as static images.\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\n                // to support the PBI Desktop scenario.\n                // This code will be removed once PBI Service fully supports R Script Visuals.\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\n                return { dataView: dataView, isValid: true };\n            }\n            return { isValid: false };\n        }\n        DataViewAnalysis.validateAndReshape = validateAndReshape;\n        function reshapeCategorical(dataView, dataViewMapping) {\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\n            var categoryRoleMapping = dataViewMapping.categorical;\n            var categorical = dataView.categorical;\n            if (!categorical)\n                return { isValid: false };\n            var rowCount;\n            if (categoryRoleMapping.rowCount) {\n                rowCount = categoryRoleMapping.rowCount.supported;\n                if (rowCount && rowCount.max) {\n                    var updated = void 0;\n                    var categories = categorical.categories;\n                    var maxRowCount = rowCount.max;\n                    var originalLength = undefined;\n                    if (categories) {\n                        for (var i = 0, len = categories.length; i < len; i++) {\n                            var category = categories[i];\n                            originalLength = category.values.length;\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                                // Row count too large: Trim it to fit.\n                                var updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\n                                updated = updated || { categories: [] };\n                                updated.categories.push({\n                                    source: category.source,\n                                    values: updatedCategories\n                                });\n                            }\n                        }\n                    }\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\n                        if (!originalLength)\n                            originalLength = categorical.values[0].values.length;\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                            updated = updated || {};\n                            updated.values = powerbi.data.DataViewTransform.createValueColumns();\n                            for (var i = 0, len = categorical.values.length; i < len; i++) {\n                                var column = categorical.values[i], updatedColumn = {\n                                    source: column.source,\n                                    values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\n                                };\n                                if (column.min !== undefined)\n                                    updatedColumn.min = column.min;\n                                if (column.max !== undefined)\n                                    updatedColumn.max = column.max;\n                                if (column.subtotal !== undefined)\n                                    updatedColumn.subtotal = column.subtotal;\n                                updated.values.push(updatedColumn);\n                            }\n                        }\n                    }\n                    if (updated) {\n                        dataView = {\n                            metadata: dataView.metadata,\n                            categorical: updated,\n                        };\n                    }\n                }\n            }\n            if (supportsCategorical(dataView, dataViewMapping))\n                return { dataView: dataView, isValid: true };\n            return null;\n        }\n        function reshapeSingle(dataView, singleRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (dataView.single)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTree(dataView, treeRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            // TODO: Need to implement the reshaping of Tree\n            var metadata = dataView.metadata;\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTable(dataView, tableRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (dataView.table)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function countGroups(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (!columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countGroups = countGroups;\n        function countMeasures(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countMeasures = countMeasures;\n        /** Indicates whether the dataView conforms to the specified schema. */\n        function supports(dataView, roleMapping, usePreferredDataViewSchema) {\n            if (!roleMapping || !dataView)\n                return false;\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\n                return false;\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\n                return false;\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\n                return false;\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\n                return false;\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\n                return false;\n            return true;\n        }\n        DataViewAnalysis.supports = supports;\n        function supportsCategorical(dataView, categoryRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\n            var dataViewCategorical = dataView.categorical;\n            if (!dataViewCategorical)\n                return false;\n            // TODO: Disabling this implementation isn't right.\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\n            //    return false;\n            if (categoryRoleMapping.rowCount) {\n                var rowCount = categoryRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\n                    rowCount = categoryRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\n                        len = dataViewCategorical.values[0].values.length;\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\n                        len = dataViewCategorical.categories[0].values.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsSingle(dataViewSingle, singleRoleMapping) {\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (!dataViewSingle)\n                return false;\n            return true;\n        }\n        function supportsTree(dataView, treeRoleMapping) {\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            var metadata = dataView.metadata;\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\n        }\n        function supportsTable(dataViewTable, tableRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (!dataViewTable)\n                return false;\n            if (tableRoleMapping.rowCount) {\n                var rowCount = tableRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\n                    rowCount = tableRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewTable.rows && dataViewTable.rows.length)\n                        len = dataViewTable.rows.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsScriptResult(dataView, scriptResultRoleMapping) {\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\n            if (!dataView)\n                return false;\n            if (!dataView.imageBase64)\n                return false;\n            return true;\n        }\n        /**\n         * Determines whether the value conforms to the range in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateRange(value, roleCondition, ignoreMin) {\n            debug.assertValue(value, 'value');\n            if (!roleCondition)\n                return;\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\n            if (roleCondition.max !== undefined && roleCondition.max < value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\n        }\n        DataViewAnalysis.validateRange = validateRange;\n        /**\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateKind(roleCondition, roleName, projections, roleKindByQueryRef) {\n            if (!roleCondition || roleCondition.kind === undefined) {\n                return;\n            }\n            var expectedKind = roleCondition.kind;\n            var roleCollection = projections[roleName];\n            if (roleCollection) {\n                var roleProjections = roleCollection.all();\n                for (var _i = 0, roleProjections_1 = roleProjections; _i < roleProjections_1.length; _i++) {\n                    var roleProjection = roleProjections_1[_i];\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\n                        switch (expectedKind) {\n                            case powerbi.VisualDataRoleKind.Measure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\n                            case powerbi.VisualDataRoleKind.Grouping:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\n                            case powerbi.VisualDataRoleKind.GroupingOrMeasure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\n                        }\n                    }\n                }\n            }\n        }\n        /** Determines the appropriate DataViewMappings for the projections. */\n        function chooseDataViewMappings(projections, mappings, roleKindByQueryRef, objectDescriptors, objectDefinitions) {\n            debug.assertValue(projections, 'projections');\n            debug.assertAnyValue(mappings, 'mappings');\n            var supportedMappings = [];\n            var errors = [];\n            if (!_.isEmpty(mappings)) {\n                for (var mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\n                    var mapping = mappings[mappingIndex], mappingConditions = mapping.conditions, requiredProperties = mapping.requiredProperties;\n                    var allPropertiesValid = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\n                    var conditionsMet = [];\n                    if (!_.isEmpty(mappingConditions)) {\n                        for (var conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\n                            var condition = mappingConditions[conditionIndex];\n                            var currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\n                            if (!_.isEmpty(currentConditionErrors)) {\n                                for (var _i = 0, currentConditionErrors_1 = currentConditionErrors; _i < currentConditionErrors_1.length; _i++) {\n                                    var error = currentConditionErrors_1[_i];\n                                    error.mappingIndex = mappingIndex;\n                                    error.conditionIndex = conditionIndex;\n                                    errors.push(error);\n                                }\n                            }\n                            else\n                                conditionsMet.push(condition);\n                        }\n                    }\n                    else {\n                        conditionsMet.push({});\n                    }\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\n                        var supportedMapping = _.cloneDeep(mapping);\n                        var updatedConditions = _.filter(conditionsMet, function (condition) { return Object.keys(condition).length > 0; });\n                        if (!_.isEmpty(updatedConditions))\n                            supportedMapping.conditions = updatedConditions;\n                        supportedMappings.push(supportedMapping);\n                    }\n                }\n            }\n            return {\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\n            };\n        }\n        DataViewAnalysis.chooseDataViewMappings = chooseDataViewMappings;\n        function checkForConditionErrors(projections, condition, roleKindByQueryRef) {\n            debug.assertValue(projections, 'projections');\n            debug.assertValue(condition, 'condition');\n            var conditionRoles = Object.keys(condition);\n            var errors = [];\n            for (var i = 0, len = conditionRoles.length; i < len; i++) {\n                var roleName = conditionRoles[i], isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs), roleCondition = condition[roleName];\n                var roleCount = getPropertyCount(roleName, projections, isDrillable);\n                var rangeError = validateRange(roleCount, roleCondition);\n                if (rangeError != null) {\n                    errors.push({\n                        code: rangeError,\n                        roleName: roleName,\n                    });\n                }\n                var kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\n                if (kindError != null) {\n                    errors.push({\n                        code: kindError,\n                        roleName: roleName,\n                    });\n                }\n            }\n            return errors;\n        }\n        function areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions) {\n            if (_.isEmpty(requiredProperties))\n                return true;\n            if (!objectDescriptors || !objectDefinitions)\n                return false;\n            var staticEvalContext = powerbi.data.createStaticEvalContext();\n            return _.every(requiredProperties, function (requiredProperty) {\n                var objectDescriptorValue = null;\n                var objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\n                if (objectDescriptorProperty)\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\n                var objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\n                if (!objectDescriptorValue || !objectDefinitionValue)\n                    return false;\n                return powerbi.data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\n            });\n        }\n        function getPropertyCount(roleName, projections, useActiveIfAvailable) {\n            debug.assertValue(roleName, 'roleName');\n            debug.assertValue(projections, 'projections');\n            var projectionsForRole = projections[roleName];\n            if (projectionsForRole) {\n                if (useActiveIfAvailable)\n                    return 1;\n                return projectionsForRole.all().length;\n            }\n            return 0;\n        }\n        DataViewAnalysis.getPropertyCount = getPropertyCount;\n        function hasSameCategoryIdentity(dataView1, dataView2) {\n            if (dataView1\n                && dataView2\n                && dataView1.categorical\n                && dataView2.categorical) {\n                var dv1Categories = dataView1.categorical.categories;\n                var dv2Categories = dataView2.categorical.categories;\n                if (dv1Categories\n                    && dv2Categories\n                    && dv1Categories.length === dv2Categories.length) {\n                    for (var i = 0, len = dv1Categories.length; i < len; i++) {\n                        var dv1Identity = dv1Categories[i].identity;\n                        var dv2Identity = dv2Categories[i].identity;\n                        var dv1Length = getLengthOptional(dv1Identity);\n                        if (dv1Length !== getLengthOptional(dv2Identity))\n                            return false;\n                        for (var j = 0; j < dv1Length; j++) {\n                            if (!powerbi.DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\n                                return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        DataViewAnalysis.hasSameCategoryIdentity = hasSameCategoryIdentity;\n        function getLengthOptional(identity) {\n            if (identity)\n                return identity.length;\n            return 0;\n        }\n        function areMetadataColumnsEquivalent(column1, column2) {\n            if (!column1 && !column2)\n                return true;\n            if (!column1 || !column2)\n                return false;\n            if (column1.displayName !== column2.displayName)\n                return false;\n            if (column1.queryName !== column2.queryName)\n                return false;\n            if (column1.isMeasure !== column2.isMeasure)\n                return false;\n            if (column1.type !== column2.type)\n                return false;\n            if (column1.sort !== column2.sort)\n                return false;\n            return true;\n        }\n        DataViewAnalysis.areMetadataColumnsEquivalent = areMetadataColumnsEquivalent;\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\n        function isMetadataEquivalent(metadata1, metadata2) {\n            if (!metadata1 && !metadata2)\n                return true;\n            if (!metadata1 || !metadata2)\n                return false;\n            var previousColumnsLength = metadata1.columns.length;\n            var newColumnsLength = metadata2.columns.length;\n            if (previousColumnsLength !== newColumnsLength)\n                return false;\n            for (var i = 0; i < newColumnsLength; i++) {\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\n                    return false;\n            }\n            return true;\n        }\n        DataViewAnalysis.isMetadataEquivalent = isMetadataEquivalent;\n    })(DataViewAnalysis = powerbi.DataViewAnalysis || (powerbi.DataViewAnalysis = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var Lazy = jsCommon.Lazy;\n        var DataViewRoleWildcard;\n        (function (DataViewRoleWildcard) {\n            function fromRoles(roles) {\n                return new DataViewRoleWildcardImpl(roles);\n            }\n            DataViewRoleWildcard.fromRoles = fromRoles;\n            function equals(firstRoleWildcard, secondRoleWildcard) {\n                return firstRoleWildcard.key &&\n                    secondRoleWildcard.key &&\n                    firstRoleWildcard.key === secondRoleWildcard.key &&\n                    ArrayExtensions.sequenceEqual(firstRoleWildcard.roles, secondRoleWildcard.roles, function (role1, role2) { return role1 === role2; });\n            }\n            DataViewRoleWildcard.equals = equals;\n            var DataViewRoleWildcardImpl = (function () {\n                function DataViewRoleWildcardImpl(roles) {\n                    var _this = this;\n                    debug.assertNonEmpty(roles, 'roles');\n                    this._roles = roles;\n                    this._key = new Lazy(function () { return JSON.stringify(_this.roles); });\n                }\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"roles\", {\n                    get: function () {\n                        return this._roles;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewRoleWildcardImpl;\n            }());\n        })(DataViewRoleWildcard = data.DataViewRoleWildcard || (data.DataViewRoleWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewScopeIdentity;\n    (function (DataViewScopeIdentity) {\n        /** Compares the two DataViewScopeIdentity values for equality. */\n        function equals(x, y, ignoreCase) {\n            // Normalize falsy to null\n            x = x || null;\n            y = y || null;\n            if (x === y)\n                return true;\n            if (!x !== !y)\n                return false;\n            debug.assertValue(x, 'x');\n            debug.assertValue(y, 'y');\n            return data.SQExpr.equals(x.expr, y.expr, ignoreCase);\n        }\n        DataViewScopeIdentity.equals = equals;\n        function filterFromIdentity(identities, isNot) {\n            if (_.isEmpty(identities))\n                return;\n            var exprs = [];\n            for (var _i = 0, identities_1 = identities; _i < identities_1.length; _i++) {\n                var identity = identities_1[_i];\n                exprs.push(identity.expr);\n            }\n            return filterFromExprs(exprs, isNot);\n        }\n        DataViewScopeIdentity.filterFromIdentity = filterFromIdentity;\n        function filterFromExprs(orExprs, isNot) {\n            if (_.isEmpty(orExprs))\n                return;\n            var resultExpr;\n            for (var _i = 0, orExprs_1 = orExprs; _i < orExprs_1.length; _i++) {\n                var orExpr = orExprs_1[_i];\n                var inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\n                if (resultExpr)\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\n                else\n                    resultExpr = inExpr || orExpr;\n            }\n            if (resultExpr) {\n                if (isNot)\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\n            }\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\n        }\n        DataViewScopeIdentity.filterFromExprs = filterFromExprs;\n    })(DataViewScopeIdentity = powerbi.DataViewScopeIdentity || (powerbi.DataViewScopeIdentity = {}));\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        function createDataViewScopeIdentity(expr) {\n            return new DataViewScopeIdentityImpl(expr);\n        }\n        data.createDataViewScopeIdentity = createDataViewScopeIdentity;\n        var DataViewScopeIdentityImpl = (function () {\n            function DataViewScopeIdentityImpl(expr) {\n                debug.assertValue(expr, 'expr');\n                this._expr = expr;\n                this._key = new Lazy(function () { return data.SQExprShortSerializer.serialize(expr); });\n            }\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"expr\", {\n                get: function () {\n                    return this._expr;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"key\", {\n                get: function () {\n                    return this._key.getValue();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return DataViewScopeIdentityImpl;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        var DataViewScopeWildcard;\n        (function (DataViewScopeWildcard) {\n            function matches(wildcard, instance) {\n                var instanceExprs = data.ScopeIdentityExtractor.getKeys(instance.expr);\n                if (!instanceExprs)\n                    return false;\n                return data.SQExprUtils.sequenceEqual(wildcard.exprs, instanceExprs);\n            }\n            DataViewScopeWildcard.matches = matches;\n            function equals(firstScopeWildcard, secondScopeWildcard) {\n                return firstScopeWildcard.key === secondScopeWildcard.key &&\n                    data.SQExprUtils.sequenceEqual(firstScopeWildcard.exprs, secondScopeWildcard.exprs);\n            }\n            DataViewScopeWildcard.equals = equals;\n            function fromExprs(exprs) {\n                return new DataViewScopeWildcardImpl(exprs);\n            }\n            DataViewScopeWildcard.fromExprs = fromExprs;\n            var DataViewScopeWildcardImpl = (function () {\n                function DataViewScopeWildcardImpl(exprs) {\n                    debug.assertValue(exprs, 'exprs');\n                    this._exprs = exprs;\n                    this._key = new Lazy(function () { return data.SQExprShortSerializer.serializeArray(exprs); });\n                }\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"exprs\", {\n                    get: function () {\n                        return this._exprs;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewScopeWildcardImpl;\n            }());\n        })(DataViewScopeWildcard = data.DataViewScopeWildcard || (data.DataViewScopeWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createColorAllocatorCache() {\n            return new ColorAllocatorProvider();\n        }\n        data.createColorAllocatorCache = createColorAllocatorCache;\n        var ColorAllocatorProvider = (function () {\n            function ColorAllocatorProvider() {\n                this.cache = [];\n            }\n            ColorAllocatorProvider.prototype.get = function (key) {\n                debug.assertValue(key, 'key');\n                for (var _i = 0, _a = this.cache; _i < _a.length; _i++) {\n                    var entry = _a[_i];\n                    if (entry.key === key)\n                        return entry.allocator;\n                }\n            };\n            ColorAllocatorProvider.prototype.register = function (key, colorAllocator) {\n                debug.assertValue(key, 'key');\n                debug.assertValue(colorAllocator, 'colorAllocator');\n                debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\n                this.cache.push({\n                    key: key,\n                    allocator: colorAllocator,\n                });\n                return this;\n            };\n            return ColorAllocatorProvider;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewRegression;\n        (function (DataViewRegression) {\n            // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\n            // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\n            var regressionXQueryName = 'RegressionX';\n            var regressionSeriesQueryName = 'RegressionSeries';\n            DataViewRegression.regressionYQueryName = 'RegressionY';\n            function run(options) {\n                debug.assertValue(options, 'options');\n                var dataViewMappings = options.dataViewMappings;\n                var visualDataViews = options.visualDataViews;\n                var dataRoles = options.dataRoles;\n                var objectDescriptors = options.objectDescriptors;\n                var objectDefinitions = options.objectDefinitions;\n                var colorAllocatorFactory = options.colorAllocatorFactory;\n                var transformSelects = options.transformSelects;\n                var projectionActiveItems = options.projectionActiveItems;\n                var metadata = options.metadata;\n                if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\n                    // compute linear regression line if applicable\n                    var roleKindByQueryRef = data.DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\n                    var projections = data.DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\n                    if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\n                        return visualDataViews;\n                    var applicableDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\n                    if (applicableDataViewMappings) {\n                        var regressionDataViewMapping = _.find(applicableDataViewMappings, function (dataViewMapping) {\n                            return dataViewMapping.usage && dataViewMapping.usage.regression;\n                        });\n                        if (regressionDataViewMapping) {\n                            var regressionDataViews = [];\n                            for (var _i = 0, visualDataViews_1 = visualDataViews; _i < visualDataViews_1.length; _i++) {\n                                var visualDataView = visualDataViews_1[_i];\n                                var regressionDataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                                if (regressionDataView)\n                                    regressionDataViews.push(regressionDataView);\n                            }\n                            if (!_.isEmpty(regressionDataViews))\n                                visualDataViews.push.apply(visualDataViews, regressionDataViews);\n                        }\n                    }\n                }\n                return visualDataViews;\n            }\n            DataViewRegression.run = run;\n            /**\n             * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\n             * It works on scalar axis only.\n             * The algorithm is as follows\n             *\n             * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\n             * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\n             * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\n             * If highlights values are present, repeat steps 2 & 3 using highlight values.\n             * 4. Create the new dataView using the points computed above\n             */\n            function linearRegressionTransform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\n                debug.assertValue(dataRoles, 'dataRoles');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!sourceDataView.categorical)\n                    return;\n                // Step 1\n                var xColumns = getColumnsForCartesianRoleKind(0 /* X */, sourceDataView.categorical, dataRoles);\n                var yColumns = getColumnsForCartesianRoleKind(1 /* Y */, sourceDataView.categorical, dataRoles);\n                if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\n                    return;\n                var xColumnSource = xColumns[0].source;\n                var yColumnSource = yColumns[0].source;\n                var combineSeries = true;\n                if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\n                    var regressionUsage = regressionDataViewMapping.usage.regression;\n                    var combineSeriesPropertyId = regressionUsage['combineSeries'];\n                    if (combineSeriesPropertyId) {\n                        combineSeries = powerbi.DataViewObjects.getValue(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\n                    }\n                }\n                // Step 2\n                var dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\n                var lineDefSet = calculateLineDefinitions(dataPointsBySeries);\n                var xMin = lineDefSet.xMin;\n                var xMax = lineDefSet.xMax;\n                var shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\n                var highlightsLineDefSet;\n                if (shouldComputeHightlights) {\n                    var highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\n                    highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\n                    if (highlightsLineDefSet) {\n                        xMin = _.min([xMin, highlightsLineDefSet.xMin]);\n                        xMax = _.max([xMax, highlightsLineDefSet.xMax]);\n                    }\n                    else {\n                        shouldComputeHightlights = false;\n                    }\n                }\n                // Step 3\n                var valuesByTrend = [];\n                for (var _i = 0, _a = lineDefSet.lineDefs; _i < _a.length; _i++) {\n                    var trend = _a[_i];\n                    valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                }\n                var highlightsByTrend;\n                if (shouldComputeHightlights) {\n                    highlightsByTrend = [];\n                    for (var _b = 0, _c = highlightsLineDefSet.lineDefs; _b < _c.length; _b++) {\n                        var trend = _c[_b];\n                        highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                    }\n                }\n                // Step 4\n                var groupValues;\n                if (combineSeries) {\n                    groupValues = ['combinedRegressionSeries'];\n                }\n                else {\n                    // If we are producing a trend line per series we need to maintain the group identities so that we can map between the \n                    // trend line and the original series (to match the color for example).\n                    if (sourceDataView.categorical.values.source) {\n                        // Source data view has dynamic series.\n                        var groups = sourceDataView.categorical.values.grouped();\n                        groupValues = _.map(groups, function (group) { return group.name; });\n                    }\n                    else {\n                        // Source data view has static or no series.\n                        groupValues = _.map(yColumns, function (column) { return column.source.queryName; });\n                    }\n                }\n                // Step 5\n                var regressionDataView = createRegressionDataView(xColumnSource, yColumnSource, groupValues, [xMin, xMax], valuesByTrend, highlightsByTrend, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                return regressionDataView;\n            }\n            DataViewRegression.linearRegressionTransform = linearRegressionTransform;\n            function calculateLineDefinitions(dataPointsBySeries) {\n                var xMin;\n                var xMax;\n                var lineDefs = [];\n                for (var _i = 0, dataPointsBySeries_1 = dataPointsBySeries; _i < dataPointsBySeries_1.length; _i++) {\n                    var dataPointSet = dataPointsBySeries_1[_i];\n                    var unsortedXValues = dataPointSet.xValues;\n                    var unsortedYValues = dataPointSet.yValues;\n                    if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\n                        return;\n                    // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\n                    var xDataType = getDataType(unsortedXValues);\n                    if (!xDataType)\n                        return;\n                    var yDataType = getDataType(unsortedYValues);\n                    if (!yDataType)\n                        return;\n                    var sortedDataPointSet = sortValues(unsortedXValues, unsortedYValues);\n                    var minCategoryValue = sortedDataPointSet.xValues[0];\n                    var maxCategoryValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\n                    var lineDef = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\n                    xMin = _.min([xMin, minCategoryValue]);\n                    xMax = _.max([xMax, maxCategoryValue]);\n                    lineDefs.push(lineDef);\n                }\n                return {\n                    lineDefs: lineDefs,\n                    xMin: xMin,\n                    xMax: xMax,\n                };\n            }\n            function getColumnsForCartesianRoleKind(roleKind, categorical, roles) {\n                debug.assertValue(roleKind, 'roleKind');\n                debug.assertValue(categorical, 'categorical');\n                var columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n                var categories = categorical.categories;\n                if (_.isEmpty(categories))\n                    return;\n                debug.assert(categories.length === 1, 'composite category columns not supported');\n                var categoryColumn = categories[0];\n                columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n            }\n            function getColumnsWithRoleKind(roleKind, columns, roles) {\n                if (_.isEmpty(columns))\n                    return;\n                return _.filter(columns, function (column) {\n                    var _loop_1 = function(roleName) {\n                        if (!column.source.roles[roleName])\n                            return \"continue\";\n                        var role = _.find(roles, function (role) { return role.name === roleName; });\n                        if (role && role.cartesianKind === roleKind)\n                            return { value: true };\n                    };\n                    for (var roleName in column.source.roles) {\n                        var state_1 = _loop_1(roleName);\n                        if (typeof state_1 === \"object\") return state_1.value;\n                        if (state_1 === \"continue\") continue;\n                    }\n                    return false;\n                });\n            }\n            function getDataType(values) {\n                var firstNonNull = _.find(values, function (value) { return value != null; });\n                if (firstNonNull == null)\n                    return;\n                var dataType = typeof firstNonNull;\n                if (_.some(values, function (value) { return value != null && typeof value !== dataType; }))\n                    return;\n                return dataType;\n            }\n            function sortValues(unsortedXValues, unsortedYValues) {\n                debug.assertValue(unsortedXValues, 'unsortedXValues');\n                debug.assertValue(unsortedYValues, 'unsortedYValues');\n                var zippedValues = _.zip(unsortedXValues, unsortedYValues);\n                var _a = _.chain(zippedValues)\n                    .filter(function (valuePair) { return valuePair[0] != null && valuePair[1] != null; })\n                    .sortBy(function (valuePair) { return valuePair[0]; })\n                    .unzip()\n                    .value(), xValues = _a[0], yValues = _a[1];\n                return {\n                    xValues: xValues,\n                    yValues: yValues\n                };\n            }\n            /**\n             * Computes a line definition using linear regression.\n             *   xBar: average of X values, yBar: average of Y values\n             *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\n             *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\n             *   Slope: ssXY / ssXX\n             *   Intercept: yBar - xBar * slope\n             */\n            function computeRegressionLine(xValues, yValues) {\n                debug.assertValue(xValues, 'xValues');\n                debug.assertValue(yValues, 'yValues');\n                var xBar = _.sum(xValues) / xValues.length;\n                var yBar = _.sum(yValues) / yValues.length;\n                var ssXX = _.chain(xValues)\n                    .map(function (x) {\n                    return Math.pow((x - xBar), 2);\n                })\n                    .sum();\n                var ssXY = _.chain(xValues)\n                    .map(function (x, i) {\n                    return (x - xBar) * (yValues[i] - yBar);\n                })\n                    .sum();\n                var slope = ssXY / ssXX;\n                var intercept = yBar - (xBar * slope);\n                return {\n                    slope: slope,\n                    intercept: intercept\n                };\n            }\n            function computeLineYValues(lineDef, x1, x2) {\n                return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\n            }\n            function getValuesFromColumn(column, preferHighlights) {\n                if (preferHighlights) {\n                    // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\n                    var valueColumn = column;\n                    if (valueColumn.highlights) {\n                        return valueColumn.highlights;\n                    }\n                }\n                return column.values;\n            }\n            function getDataPointsBySeries(xColumns, yColumns, combineSeries, preferHighlights) {\n                var dataPointsBySeries = [];\n                var xValueArray = _.map(xColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var seriesYValues = _.map(yColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var multipleXValueColumns = xColumns.length > 1;\n                for (var i = 0; i < seriesYValues.length; i++) {\n                    var xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\n                    var yValues = seriesYValues[i];\n                    if (combineSeries && dataPointsBySeries.length > 0) {\n                        dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\n                        dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\n                    }\n                    else {\n                        dataPointsBySeries.push({\n                            xValues: xValues,\n                            yValues: yValues,\n                        });\n                    }\n                }\n                return dataPointsBySeries;\n            }\n            function createRegressionDataView(xColumnSource, yColumnSource, groupValues, categories, values, highlights, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(xColumnSource, 'xColumnSource');\n                debug.assertValue(yColumnSource, 'yColumnSource');\n                debug.assertValue(categories, 'categories');\n                debug.assertValue(values, 'values');\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertAnyValue(highlights, 'highlights');\n                debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\n                var xRole = regressionDataViewMapping.categorical.categories.for.in;\n                var grouped = regressionDataViewMapping.categorical.values.group;\n                var yRole;\n                var seriesRole;\n                if (grouped && !_.isEmpty(grouped.select)) {\n                    yRole = grouped.select[0].for ?\n                        grouped.select[0].for.in :\n                        grouped.select[0].bind.to;\n                    seriesRole = grouped.by;\n                }\n                if (!yRole || !seriesRole)\n                    return;\n                var categoricalRoles = (_a = {}, _a[xRole] = true, _a);\n                var valueRoles = (_b = {}, _b[yRole] = true, _b);\n                var seriesRoles = (_c = {}, _c[seriesRole] = true, _c);\n                var valuesBySeries = [];\n                for (var index in values) {\n                    var seriesData = {\n                        values: values[index],\n                    };\n                    if (highlights)\n                        seriesData.highlights = highlights[index];\n                    valuesBySeries.push([seriesData]);\n                }\n                var regressionDataView = data.createCategoricalDataViewBuilder()\n                    .withCategory({\n                    source: {\n                        displayName: xColumnSource.displayName,\n                        queryName: regressionXQueryName,\n                        type: xColumnSource.type,\n                        isMeasure: false,\n                        roles: categoricalRoles\n                    },\n                    values: categories,\n                    identityFrom: {\n                        fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\n                    },\n                })\n                    .withGroupedValues({\n                    groupColumn: {\n                        source: {\n                            displayName: yColumnSource.displayName + 'Regression',\n                            queryName: regressionSeriesQueryName,\n                            type: yColumnSource.type,\n                            isMeasure: yColumnSource.isMeasure,\n                            roles: seriesRoles\n                        },\n                        values: groupValues,\n                        identityFrom: {\n                            fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\n                        }\n                    },\n                    valueColumns: [{\n                            source: {\n                                displayName: yColumnSource.displayName,\n                                queryName: DataViewRegression.regressionYQueryName,\n                                type: yColumnSource.type,\n                                isMeasure: yColumnSource.isMeasure,\n                                roles: valueRoles\n                            },\n                        }],\n                    data: valuesBySeries\n                })\n                    .build();\n                data.DataViewTransform.transformObjects(regressionDataView, 1 /* Categorical */, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\n                return regressionDataView;\n                var _a, _b, _c;\n            }\n            function hasHighlightValues(columns) {\n                return _.any(columns, function (column) {\n                    var valueColumn = column;\n                    return valueColumn.highlights != null;\n                });\n            }\n        })(DataViewRegression = data.DataViewRegression || (data.DataViewRegression = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelectTransform;\n        (function (DataViewSelectTransform) {\n            /** Convert selection info to projections */\n            function projectionsFromSelects(selects, projectionActiveItems) {\n                debug.assertAnyValue(selects, \"selects\");\n                debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\n                var projections = {};\n                for (var _i = 0, selects_1 = selects; _i < selects_1.length; _i++) {\n                    var select = selects_1[_i];\n                    var roles = select.roles;\n                    if (!roles)\n                        continue;\n                    for (var roleName in roles) {\n                        if (roles[roleName]) {\n                            var qp = projections[roleName];\n                            if (!qp)\n                                qp = projections[roleName] = new data.QueryProjectionCollection([]);\n                            qp.all().push({ queryRef: select.queryName });\n                            if (projectionActiveItems && projectionActiveItems[roleName])\n                                qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], function (activeItem) { return activeItem.queryRef; });\n                        }\n                    }\n                }\n                return projections;\n            }\n            DataViewSelectTransform.projectionsFromSelects = projectionsFromSelects;\n            /** Use selections and metadata to fashion query role kinds */\n            function createRoleKindFromMetadata(selects, metadata) {\n                var roleKindByQueryRef = {};\n                for (var _i = 0, _a = metadata.columns; _i < _a.length; _i++) {\n                    var column = _a[_i];\n                    if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\n                        continue;\n                    var select = selects[column.index];\n                    if (select) {\n                        var queryRef = select.queryName;\n                        if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\n                            roleKindByQueryRef[queryRef] = column.isMeasure ? powerbi.VisualDataRoleKind.Measure : powerbi.VisualDataRoleKind.Grouping;\n                        }\n                    }\n                }\n                return roleKindByQueryRef;\n            }\n            DataViewSelectTransform.createRoleKindFromMetadata = createRoleKindFromMetadata;\n        })(DataViewSelectTransform = data.DataViewSelectTransform || (data.DataViewSelectTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createCategoricalEvalContext(colorAllocatorProvider, dataViewCategorical) {\n            return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\n        }\n        data.createCategoricalEvalContext = createCategoricalEvalContext;\n        var CategoricalEvalContext = (function () {\n            function CategoricalEvalContext(colorAllocatorProvider, dataView) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.columnsByRole = {};\n            }\n            CategoricalEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            CategoricalEvalContext.prototype.getExprValue = function (expr) {\n                return;\n            };\n            CategoricalEvalContext.prototype.getRoleValue = function (roleName) {\n                var columnsByRole = this.columnsByRole;\n                var column = columnsByRole[roleName];\n                if (!column)\n                    column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\n                if (!column)\n                    return;\n                var index = this.index;\n                if (index != null)\n                    return column.values[this.index];\n            };\n            CategoricalEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.index = index;\n            };\n            return CategoricalEvalContext;\n        }());\n        function findRuleInputColumn(dataViewCategorical, inputRole) {\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n            return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\n                findRuleInputInColumns(dataViewCategorical.categories, inputRole);\n        }\n        function findRuleInputInColumns(columns, inputRole) {\n            debug.assertAnyValue(columns, 'columns');\n            if (!columns)\n                return;\n            for (var _i = 0, columns_7 = columns; _i < columns_7.length; _i++) {\n                var column = columns_7[_i];\n                var roles = column.source.roles;\n                if (!roles || !roles[inputRole])\n                    continue;\n                return column;\n            }\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createTableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms) {\n            return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\n        }\n        data.createTableEvalContext = createTableEvalContext;\n        var TableEvalContext = (function () {\n            function TableEvalContext(colorAllocatorProvider, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            TableEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            TableEvalContext.prototype.getExprValue = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var rowIdx = this.rowIdx;\n                if (rowIdx == null)\n                    return;\n                return data.getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\n            };\n            TableEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            TableEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.rowIdx = index;\n            };\n            return TableEvalContext;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var RuleEvaluation = (function () {\n            function RuleEvaluation() {\n            }\n            // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\n            RuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\n            };\n            return RuleEvaluation;\n        }());\n        data.RuleEvaluation = RuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ColorRuleEvaluation = (function (_super) {\n            __extends(ColorRuleEvaluation, _super);\n            function ColorRuleEvaluation(inputRole, allocator) {\n                debug.assertValue(inputRole, 'inputRole');\n                debug.assertValue(allocator, 'allocator');\n                _super.call(this);\n                this.inputRole = inputRole;\n                this.allocator = allocator;\n            }\n            ColorRuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertValue(evalContext, 'evalContext');\n                var value = evalContext.getRoleValue(this.inputRole);\n                if (value !== undefined)\n                    return this.allocator.color(value);\n            };\n            return ColorRuleEvaluation;\n        }(data.RuleEvaluation));\n        data.ColorRuleEvaluation = ColorRuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var inherit = powerbi.Prototype.inherit;\n            var inheritSingle = powerbi.Prototype.inheritSingle;\n            var ArrayExtensions = jsCommon.ArrayExtensions;\n            var DataViewMatrixUtils;\n            (function (DataViewMatrixUtils) {\n                /**\n                 * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the\n                 * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the\n                 * particular leaf node in the context of this forEachLeafNode(...) invocation.\n                 *\n                 * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\n                 *\n                 * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified\n                 * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\n                 * then treePath will be an array of length 1 containing that very node.\n                 *\n                 * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\n                 * If your callback needs to retain a copy of the treePath, please clone the array before returning.\n                 */\n                function forEachLeafNode(rootNodes, callback) {\n                    debug.assertAnyValue(rootNodes, 'rootNodes');\n                    debug.assertValue(callback, 'callback');\n                    // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\n                    // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \n                    // for the fact that all the properties on DataViewMatrixNode are optional...\n                    if (rootNodes) {\n                        if (isNodeArray(rootNodes)) {\n                            var index = 0;\n                            for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {\n                                var rootNode = rootNodes_1[_i];\n                                if (rootNode) {\n                                    index = forEachLeafNodeRecursive(rootNode, index, [], callback);\n                                }\n                            }\n                        }\n                        else {\n                            forEachLeafNodeRecursive(rootNodes, 0, [], callback);\n                        }\n                    }\n                }\n                DataViewMatrixUtils.forEachLeafNode = forEachLeafNode;\n                function isNodeArray(nodeOrNodeArray) {\n                    return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\n                }\n                /**\n                 * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\n                 * Returns the index for the next node after the last node that this function invokes callback with.\n                 *\n                 * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\n                 */\n                function forEachLeafNodeRecursive(matrixNode, nextIndex, treePath, callback) {\n                    debug.assertValue(matrixNode, 'matrixNode');\n                    debug.assertValue(treePath, 'treePath');\n                    debug.assertValue(callback, 'callback');\n                    // If treePath already contains matrixNode, then either one of the following errors has happened:\n                    // 1. the caller code mistakenly added matrixNode to treePath, or\n                    // 2. the callback modified treePath by adding a node to it, or\n                    // 3. the matrix hierarchy contains a cyclical node reference.');\n                    debug.assert(!_.contains(treePath, matrixNode), 'pre-condition: treePath must not already contain matrixNode');\n                    treePath.push(matrixNode);\n                    if (_.isEmpty(matrixNode.children)) {\n                        callback(matrixNode, nextIndex, treePath);\n                        nextIndex++;\n                    }\n                    else {\n                        var children = matrixNode.children;\n                        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n                            var nextChild = children_1[_i];\n                            if (nextChild) {\n                                nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\n                            }\n                        }\n                    }\n                    debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\n                    treePath.pop();\n                    return nextIndex;\n                }\n                /**\n                 * Returned an object tree where each node and its children property are inherited from the specified node\n                 * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\n                 *\n                 * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array\n                 * property, i.e. its children property is the same array object referenced in the input node's object tree.\n                 *\n                 * @param node The input node with the hierarchy object tree.\n                 * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\n                 * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is\n                 * not already an inherited object. Same goes for the node's children property.  This is useful for creating\n                 * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for\n                 * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains\n                 * inherited objects.\n                 */\n                function inheritMatrixNodeHierarchy(node, deepestLevelToInherit, useInheritSingle) {\n                    debug.assertValue(node, 'node');\n                    debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\n                    debug.assertValue(useInheritSingle, 'useInheritSingle');\n                    var returnNode = node;\n                    // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\n                    // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\n                    // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\n                    //  {\n                    //    \"level\": 0,\n                    //    \"isSubtotal\": true,\n                    //    \"children\": [\n                    //      { \"level\": 2, \"isSubtotal\": true },\n                    //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\n                    //    ]\n                    //  }\n                    var isRootNode = _.isUndefined(node.level);\n                    var shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\n                    if (shouldInheritCurrentNode) {\n                        var inheritFunc = useInheritSingle ? inheritSingle : inherit;\n                        var inheritedNode = inheritFunc(node);\n                        var shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\n                        if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\n                            inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\n                            for (var i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\n                                inheritedNode.children[i] =\n                                    inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\n                            }\n                        }\n                        returnNode = inheritedNode;\n                    }\n                    return returnNode;\n                }\n                DataViewMatrixUtils.inheritMatrixNodeHierarchy = inheritMatrixNodeHierarchy;\n                /**\n                 * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\n                 * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\n                 * Year === 2016, Quarter === 'Qtr 1', Month === 1.\n                 *\n                 * Returns false if the specified matrixOrHierarchy does not contain any composite group,\n                 * or if matrixOrHierarchy is null or undefined.\n                 */\n                function containsCompositeGroup(matrixOrHierarchy) {\n                    debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\n                    var hasCompositeGroup = false;\n                    if (matrixOrHierarchy) {\n                        if (isMatrix(matrixOrHierarchy)) {\n                            hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\n                                containsCompositeGroup(matrixOrHierarchy.columns);\n                        }\n                        else {\n                            var hierarchyLevels = matrixOrHierarchy.levels;\n                            if (!_.isEmpty(hierarchyLevels)) {\n                                for (var _i = 0, hierarchyLevels_1 = hierarchyLevels; _i < hierarchyLevels_1.length; _i++) {\n                                    var level = hierarchyLevels_1[_i];\n                                    // it takes at least 2 columns at the same hierarchy level to form a composite group...\n                                    if (level.sources && (level.sources.length >= 2)) {\n                                        debug.assert(_.all(level.sources, function (sourceColumn) { return sourceColumn.isMeasure === level.sources[0].isMeasure; }), 'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\n                                        // Measure headers are not group\n                                        var isMeasureHeadersLevel = level.sources[0].isMeasure;\n                                        if (!isMeasureHeadersLevel) {\n                                            hasCompositeGroup = true;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return hasCompositeGroup;\n                }\n                DataViewMatrixUtils.containsCompositeGroup = containsCompositeGroup;\n                function isMatrix(matrixOrHierarchy) {\n                    return 'rows' in matrixOrHierarchy &&\n                        'columns' in matrixOrHierarchy &&\n                        'valueSources' in matrixOrHierarchy;\n                }\n            })(DataViewMatrixUtils = utils.DataViewMatrixUtils || (utils.DataViewMatrixUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var DataViewMetadataColumnUtils;\n            (function (DataViewMetadataColumnUtils) {\n                /**\n                 * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\n                 */\n                function isForRole(metadataColumn, targetRole) {\n                    debug.assertValue(metadataColumn, 'metadataColumn');\n                    debug.assertValue(targetRole, 'targetRole');\n                    var roles = metadataColumn.roles;\n                    return roles && roles[targetRole];\n                }\n                DataViewMetadataColumnUtils.isForRole = isForRole;\n                /**\n                 * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\n                 *\n                 * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the\n                 * specified columnSources must be a non-filtered array of column sources from the DataView, such as\n                 * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\n                 *\n                 * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\n                 * @param projection The projection ordering.  It must contain an ordering for the specified role.\n                 * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\n                 */\n                function joinMetadataColumnsAndProjectionOrder(columnSources, projection, role) {\n                    debug.assertAnyValue(columnSources, 'columnSources');\n                    debug.assert(_.all(columnSources, function (column) { return _.isNumber(column.index); }), 'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\n                    debug.assertNonEmpty(projection[role], 'projection[role]');\n                    debug.assert(_.all(columnSources, function (column) { return !isForRole(column, role) || _.contains(projection[role], column.index); }), 'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\n                    var jointResult = [];\n                    if (!_.isEmpty(columnSources)) {\n                        var projectionOrderSelectIndices = projection[role];\n                        var selectIndexToProjectionIndexMap = {};\n                        for (var i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\n                            var selectIndex = projectionOrderSelectIndices[i];\n                            selectIndexToProjectionIndexMap[selectIndex] = i;\n                        }\n                        for (var j = 0, jlen = columnSources.length; j < jlen; j++) {\n                            var column = columnSources[j];\n                            if (isForRole(column, role)) {\n                                var jointColumnInfo = {\n                                    metadataColumn: column,\n                                    sourceIndex: j,\n                                    projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\n                                };\n                                jointResult.push(jointColumnInfo);\n                            }\n                        }\n                    }\n                    return jointResult;\n                }\n                DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder = joinMetadataColumnsAndProjectionOrder;\n            })(DataViewMetadataColumnUtils = utils.DataViewMetadataColumnUtils || (utils.DataViewMetadataColumnUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ConceptualSchema = (function () {\n            function ConceptualSchema() {\n            }\n            ConceptualSchema.prototype.findProperty = function (entityName, propertyName) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                return entity.properties.withName(propertyName);\n            };\n            ConceptualSchema.prototype.findHierarchy = function (entityName, name) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.hierarchies))\n                    return;\n                return entity.hierarchies.withName(name);\n            };\n            ConceptualSchema.prototype.findHierarchyByVariation = function (variationEntityName, variationColumnName, variationName, hierarchyName) {\n                var variationEntity = this.entities.withName(variationEntityName);\n                if (!variationEntity || _.isEmpty(variationEntity.properties))\n                    return;\n                var variationProperty = variationEntity.properties.withName(variationColumnName);\n                if (!variationProperty)\n                    return;\n                var variationColumn = variationProperty.column;\n                if (!variationColumn || _.isEmpty(variationColumn.variations))\n                    return;\n                var variation = variationColumn.variations.withName(variationName);\n                if (variation) {\n                    var targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\n                    if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\n                        return;\n                    return targetEntity.hierarchies.withName(hierarchyName);\n                }\n            };\n            /**\n            * Returns the first property of the entity whose kpi is tied to kpiProperty\n            */\n            ConceptualSchema.prototype.findPropertyWithKpi = function (entityName, kpiProperty) {\n                debug.assertValue(kpiProperty, 'kpiProperty');\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                for (var _i = 0, _a = entity.properties; _i < _a.length; _i++) {\n                    var prop = _a[_i];\n                    if (prop &&\n                        prop.measure &&\n                        prop.measure.kpi &&\n                        (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\n                        return prop;\n                }\n                return;\n            };\n            return ConceptualSchema;\n        }());\n        data.ConceptualSchema = ConceptualSchema;\n        // TODO: Remove this (replaced by ValueType)\n        (function (ConceptualDataCategory) {\n            ConceptualDataCategory[ConceptualDataCategory[\"None\"] = 0] = \"None\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Address\"] = 1] = \"Address\";\n            ConceptualDataCategory[ConceptualDataCategory[\"City\"] = 2] = \"City\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Company\"] = 3] = \"Company\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Continent\"] = 4] = \"Continent\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Country\"] = 5] = \"Country\";\n            ConceptualDataCategory[ConceptualDataCategory[\"County\"] = 6] = \"County\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Date\"] = 7] = \"Date\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Image\"] = 8] = \"Image\";\n            ConceptualDataCategory[ConceptualDataCategory[\"ImageUrl\"] = 9] = \"ImageUrl\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Latitude\"] = 10] = \"Latitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Longitude\"] = 11] = \"Longitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Organization\"] = 12] = \"Organization\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Place\"] = 13] = \"Place\";\n            ConceptualDataCategory[ConceptualDataCategory[\"PostalCode\"] = 14] = \"PostalCode\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Product\"] = 15] = \"Product\";\n            ConceptualDataCategory[ConceptualDataCategory[\"StateOrProvince\"] = 16] = \"StateOrProvince\";\n            ConceptualDataCategory[ConceptualDataCategory[\"WebUrl\"] = 17] = \"WebUrl\";\n        })(data.ConceptualDataCategory || (data.ConceptualDataCategory = {}));\n        var ConceptualDataCategory = data.ConceptualDataCategory;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var FieldExprPattern = powerbi.data.FieldExprPattern;\n    var ScriptResultUtil;\n    (function (ScriptResultUtil) {\n        function findScriptResult(dataViewMappings) {\n            if (dataViewMappings && dataViewMappings.length === 1) {\n                return dataViewMappings[0].scriptResult;\n            }\n            return undefined;\n        }\n        ScriptResultUtil.findScriptResult = findScriptResult;\n        function extractScriptResult(dataViewMappings) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult) {\n                var objects = dataViewMappings[0].metadata.objects;\n                var source = powerbi.DataViewObjects.getValue(objects, scriptResult.script.source);\n                var provider = powerbi.DataViewObjects.getValue(objects, scriptResult.script.provider);\n                return {\n                    source: source,\n                    provider: provider\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResult = extractScriptResult;\n        function extractScriptResultFromVisualConfig(dataViewMappings, objects) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult && objects) {\n                var scriptSource = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\n                var provider = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\n                return {\n                    source: scriptSource ? scriptSource.value : null,\n                    provider: provider ? provider.value : null\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResultFromVisualConfig = extractScriptResultFromVisualConfig;\n        function getScriptInput(projections, selects, schema) {\n            var scriptInput = {\n                VariableName: \"dataset\",\n                Columns: []\n            };\n            // Go over all the projections, and create an input column according to the order\n            // of the projections (including duplicate expressions)\n            if (projections && selects && !_.isEmpty(selects)) {\n                var scriptInputColumnNames = [];\n                var scriptInputColumns = [];\n                for (var role in projections) {\n                    for (var _i = 0, _a = projections[role].all(); _i < _a.length; _i++) {\n                        var projection = _a[_i];\n                        var select = selects.withName(projection.queryRef);\n                        if (select) {\n                            var scriptInputColumn = {\n                                QueryName: select.name,\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\n                            };\n                            scriptInputColumns.push(scriptInputColumn);\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\n                        }\n                    }\n                }\n                // Make sure the names of the columns are unique\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\n                // Update the names of the columns\n                for (var i = 0; i < scriptInputColumnNames.length; i++) {\n                    var scriptInputColumn = scriptInputColumns[i];\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\n                }\n                scriptInput.Columns = scriptInputColumns;\n            }\n            return scriptInput;\n        }\n        ScriptResultUtil.getScriptInput = getScriptInput;\n        var ScriptInputColumnNameVisitor = (function () {\n            function ScriptInputColumnNameVisitor(federatedSchema) {\n                this.federatedSchema = federatedSchema;\n            }\n            ScriptInputColumnNameVisitor.prototype.visitColumn = function (column) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntity = function (entity) {\n                return entity.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                return entityAggr.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchy = function (hierarchy) {\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                /*Hierarchy levels are not supported yet*/\n                return;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitMeasure = function (measure) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitSelectRef = function (selectRef) {\n                return FieldExprPattern.visit(selectRef, this);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitPercentile = function (percentile) {\n                return FieldExprPattern.visit(percentile.arg, this);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n            };\n            ScriptInputColumnNameVisitor.getNameForHierarchy = function (pattern, federatedScheam) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedScheam.schema(pattern.schema), hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\n                if (hierarchy)\n                    return hierarchy.name;\n            };\n            ScriptInputColumnNameVisitor.getNameForProperty = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedSchema.schema(pattern.schema), property = schema.findProperty(pattern.entity, pattern.name);\n                if (property)\n                    return property.name;\n            };\n            ScriptInputColumnNameVisitor.getVariationLevelName = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var source = pattern.source;\n                var prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\n                if (!prop)\n                    return;\n                var variations = prop.column.variations;\n                for (var _i = 0, variations_1 = variations; _i < variations_1.length; _i++) {\n                    var variation = variations_1[_i];\n                    if (variation.name === pattern.variationName)\n                        for (var _a = 0, _b = variation.defaultHierarchy.levels; _a < _b.length; _a++) {\n                            var level = _b[_a];\n                            if (level.name === pattern.level.level)\n                                return level.column.name;\n                        }\n                }\n            };\n            return ScriptInputColumnNameVisitor;\n        }());\n    })(ScriptResultUtil = powerbi.ScriptResultUtil || (powerbi.ScriptResultUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var segmentation;\n        (function (segmentation) {\n            var DataViewMerger;\n            (function (DataViewMerger) {\n                function mergeDataViews(source, segment) {\n                    if (!powerbi.DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\n                        debug.assertFail(\"Cannot merge data views with different metadata columns\");\n                    }\n                    // The last segment is complete. We mark the source as complete.\n                    if (!segment.metadata.segment)\n                        delete source.metadata.segment;\n                    if (source.table && segment.table)\n                        mergeTables(source.table, segment.table);\n                    if (source.categorical && segment.categorical)\n                        mergeCategorical(source.categorical, segment.categorical);\n                    // Tree cannot support subtotals hence we can get into situations\n                    // where a node has no children in one segment and more than 1 child\n                    // in another segment.\n                    if (source.tree && segment.tree)\n                        mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\n                    if (source.matrix && segment.matrix)\n                        mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\n                }\n                DataViewMerger.mergeDataViews = mergeDataViews;\n                /** Note: Public for testability */\n                function mergeTables(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    if (_.isEmpty(segment.rows))\n                        return;\n                    var mergeIndex = segment.lastMergeIndex + 1;\n                    merge(source.rows, segment.rows, mergeIndex);\n                    debug.assert(!source.identity === !segment.identity, 'The existence of identity in the new segment is different than the source');\n                    if (segment.identity)\n                        merge(source.identity, segment.identity, mergeIndex);\n                }\n                DataViewMerger.mergeTables = mergeTables;\n                /**\n                 * Merge categories values and identities\n                 *\n                 * Note: Public for testability\n                 */\n                function mergeCategorical(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    // Merge categories values and identities\n                    if (source.categories && segment.categories) {\n                        var segmentCategoriesLength = segment.categories.length;\n                        debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\n                        for (var categoryIndex = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\n                            var segmentCategory = segment.categories[categoryIndex];\n                            var sourceCategory = source.categories[categoryIndex];\n                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\n                            debug.assert(_.isUndefined(sourceCategory.values) ? _.isUndefined(sourceCategory.identity) : true, 'Source category is missing values but has identities.');\n                            var mergeIndex = segment.lastMergeIndex + 1;\n                            if (segmentCategory.values) {\n                                merge(sourceCategory.values, segmentCategory.values, mergeIndex);\n                            }\n                            if (segmentCategory.identity) {\n                                merge(sourceCategory.identity, segmentCategory.identity, mergeIndex);\n                            }\n                        }\n                    }\n                    // Merge values for each value column\n                    if (source.values && segment.values) {\n                        var segmentValuesLength = segment.values.length;\n                        debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\n                        for (var valueIndex = 0; valueIndex < segmentValuesLength; valueIndex++) {\n                            var segmentValue = segment.values[valueIndex];\n                            var sourceValue = source.values[valueIndex];\n                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\n                            if (!sourceValue.values && segmentValue.values) {\n                                sourceValue.values = [];\n                            }\n                            var mergeIndex = segment.lastMergeIndex + 1;\n                            if (segmentValue.values) {\n                                merge(sourceValue.values, segmentValue.values, mergeIndex);\n                            }\n                            if (segmentValue.highlights) {\n                                merge(sourceValue.highlights, segmentValue.highlights, mergeIndex);\n                            }\n                        }\n                    }\n                }\n                DataViewMerger.mergeCategorical = mergeCategorical;\n                /**\n                 * Merges the segment array starting at the specified index into the source array\n                 * and returns the segment slice that wasn't merged.\n                 * The segment array is spliced up to specified index in the process.\n                 */\n                function merge(source, segment, index) {\n                    if (index >= segment.length)\n                        return segment;\n                    var result = [];\n                    if (index !== undefined)\n                        result = segment.splice(0, index);\n                    Array.prototype.push.apply(source, segment);\n                    return result;\n                }\n                /** Note: Public for testability */\n                function mergeTreeNodes(sourceRoot, segmentRoot, allowDifferentStructure) {\n                    debug.assertValue(sourceRoot, 'sourceRoot');\n                    debug.assertValue(segmentRoot, 'segmentRoot');\n                    if (!segmentRoot.children || segmentRoot.children.length === 0)\n                        return;\n                    if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\n                        sourceRoot.children = segmentRoot.children;\n                        return;\n                    }\n                    debug.assert(sourceRoot.children && sourceRoot.children.length >= 0, \"Source tree has different structure than segment.\");\n                    var firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\n                    var lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\n                    var mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\n                    if (mergedChildren.length > 0)\n                        mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\n                }\n                DataViewMerger.mergeTreeNodes = mergeTreeNodes;\n                function findFirstAppendIndex(children) {\n                    if (children.length === 0)\n                        return 0;\n                    var i = 0;\n                    for (; i < children.length; i++) {\n                        var childSegment = children[i];\n                        if (!childSegment.isMerge)\n                            break;\n                    }\n                    return i;\n                }\n            })(DataViewMerger = segmentation.DataViewMerger || (segmentation.DataViewMerger = {}));\n        })(segmentation = data.segmentation || (data.segmentation = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Rewrites an expression tree, including all descendant nodes. */\n        var SQExprRewriter = (function () {\n            function SQExprRewriter() {\n            }\n            SQExprRewriter.prototype.visitColumnRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQColumnRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitMeasureRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQMeasureRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitAggr = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQAggregationExpr(rewrittenArg, expr.func);\n            };\n            SQExprRewriter.prototype.visitSelectRef = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitPercentile = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPercentileExpr(rewrittenArg, expr.k, expr.exclusive);\n            };\n            SQExprRewriter.prototype.visitHierarchy = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyExpr(rewrittenArg, expr.hierarchy);\n            };\n            SQExprRewriter.prototype.visitHierarchyLevel = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyLevelExpr(rewrittenArg, expr.level);\n            };\n            SQExprRewriter.prototype.visitPropertyVariationSource = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\n            };\n            SQExprRewriter.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitAnd = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQAndExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitBetween = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this), origLower = orig.lower, rewrittenLower = origLower.accept(this), origUpper = orig.upper, rewrittenUpper = origUpper.accept(this);\n                if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\n                    return orig;\n                return new data.SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\n            };\n            SQExprRewriter.prototype.visitIn = function (orig) {\n                var origArgs = orig.args, rewrittenArgs = this.rewriteAll(origArgs), origValues = orig.values, rewrittenValues;\n                for (var i = 0, len = origValues.length; i < len; i++) {\n                    var origValueTuple = origValues[i], rewrittenValueTuple = this.rewriteAll(origValueTuple);\n                    if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\n                        rewrittenValues = ArrayExtensions.take(origValues, i);\n                    if (rewrittenValues)\n                        rewrittenValues.push(rewrittenValueTuple);\n                }\n                if (origArgs === rewrittenArgs && !rewrittenValues)\n                    return orig;\n                return new data.SQInExpr(rewrittenArgs, rewrittenValues || origValues);\n            };\n            SQExprRewriter.prototype.rewriteAll = function (origExprs) {\n                debug.assertValue(origExprs, 'origExprs');\n                var rewrittenResult;\n                for (var i = 0, len = origExprs.length; i < len; i++) {\n                    var origExpr = origExprs[i], rewrittenExpr = origExpr.accept(this);\n                    if (origExpr !== rewrittenExpr && !rewrittenResult)\n                        rewrittenResult = ArrayExtensions.take(origExprs, i);\n                    if (rewrittenResult)\n                        rewrittenResult.push(rewrittenExpr);\n                }\n                return rewrittenResult || origExprs;\n            };\n            SQExprRewriter.prototype.visitOr = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQOrExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitCompare = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitContains = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQContainsExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitExists = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQExistsExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNot = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQNotExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitStartsWith = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQStartsWithExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitConstant = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitDateSpan = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateSpanExpr(orig.unit, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitDateAdd = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNow = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitDefaultValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitAnyValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitArithmetic = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\n            };\n            SQExprRewriter.prototype.visitScopedEval = function (orig) {\n                var origExpression = orig.expression, rewrittenExpression = origExpression.accept(this), origScope = orig.scope, rewrittenScope = this.rewriteAll(origScope);\n                if (origExpression === rewrittenExpression && origScope === rewrittenScope)\n                    return orig;\n                return new data.SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\n            };\n            SQExprRewriter.prototype.visitFillRule = function (orig) {\n                var origInput = orig.input, rewrittenInput = origInput.accept(this);\n                var origRule = orig.rule;\n                var origGradient2 = origRule.linearGradient2, rewrittenGradient2 = origGradient2;\n                if (origGradient2) {\n                    rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\n                }\n                var origGradient3 = origRule.linearGradient3, rewrittenGradient3 = origGradient3;\n                if (origGradient3) {\n                    rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\n                }\n                if (origInput !== rewrittenInput ||\n                    origGradient2 !== rewrittenGradient2 ||\n                    origGradient3 !== rewrittenGradient3) {\n                    var rewrittenRule = {};\n                    if (rewrittenGradient2)\n                        rewrittenRule.linearGradient2 = rewrittenGradient2;\n                    if (rewrittenGradient3)\n                        rewrittenRule.linearGradient3 = rewrittenGradient3;\n                    return new data.SQFillRuleExpr(rewrittenInput, rewrittenRule);\n                }\n                return orig;\n            };\n            SQExprRewriter.prototype.visitLinearGradient2 = function (origGradient2) {\n                debug.assertValue(origGradient2, 'origGradient2');\n                var origMin = origGradient2.min, rewrittenMin = this.visitFillRuleStop(origMin), origMax = origGradient2.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient2;\n            };\n            SQExprRewriter.prototype.visitLinearGradient3 = function (origGradient3) {\n                debug.assertValue(origGradient3, 'origGradient3');\n                var origMin = origGradient3.min, rewrittenMin = this.visitFillRuleStop(origMin), origMid = origGradient3.mid, rewrittenMid = this.visitFillRuleStop(origMid), origMax = origGradient3.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        mid: rewrittenMid,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient3;\n            };\n            SQExprRewriter.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                var origColor = stop.color, rewrittenColor = stop.color.accept(this);\n                var origValue = stop.value, rewrittenValue = origValue;\n                if (origValue)\n                    rewrittenValue = origValue.accept(this);\n                if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\n                    var rewrittenStop = {\n                        color: rewrittenColor\n                    };\n                    if (rewrittenValue)\n                        rewrittenStop.value = rewrittenValue;\n                    return rewrittenStop;\n                }\n                return stop;\n            };\n            SQExprRewriter.prototype.visitResourcePackageItem = function (orig) {\n                return orig;\n            };\n            return SQExprRewriter;\n        }());\n        data.SQExprRewriter = SQExprRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for writing equality comparisons against a field to an SQInExpr. */\n        var EqualsToInRewriter;\n        (function (EqualsToInRewriter) {\n            function run(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(new Rewriter());\n            }\n            EqualsToInRewriter.run = run;\n            var Rewriter = (function (_super) {\n                __extends(Rewriter, _super);\n                function Rewriter() {\n                    _super.call(this);\n                }\n                Rewriter.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return this.visitUnsupported(expr);\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var leftIsComparand = this.isComparand(expr.left);\n                    var rightIsComparand = this.isComparand(expr.right);\n                    if (leftIsComparand === rightIsComparand)\n                        return this.visitUnsupported(expr);\n                    var operand = leftIsComparand\n                        ? expr.left\n                        : expr.right;\n                    var value = leftIsComparand\n                        ? expr.right\n                        : expr.left;\n                    var current = this.current;\n                    if (!current) {\n                        return data.SQExprBuilder.inExpr([operand], [[value]]);\n                    }\n                    current.add(operand, value);\n                    return expr;\n                };\n                Rewriter.prototype.visitOr = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current;\n                    if (!this.current) {\n                        current = this.current = new InBuilder();\n                    }\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                    if (current) {\n                        this.current = null;\n                        return current.complete() || expr;\n                    }\n                    return expr;\n                };\n                Rewriter.prototype.visitAnd = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current = this.current;\n                    if (current) {\n                        // NOTE: Composite keys are not supported by this algorithm.\n                        current.cancel();\n                        return expr;\n                    }\n                    return _super.prototype.visitAnd.call(this, expr);\n                };\n                Rewriter.prototype.visitUnsupported = function (expr) {\n                    var current = this.current;\n                    if (current)\n                        current.cancel();\n                    return expr;\n                };\n                Rewriter.prototype.isSupported = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return expr instanceof data.SQCompareExpr\n                        || expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQConstantExpr\n                        || expr instanceof data.SQHierarchyLevelExpr\n                        || expr instanceof data.SQOrExpr\n                        || expr instanceof data.SQAndExpr;\n                };\n                Rewriter.prototype.isComparand = function (expr) {\n                    return expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQHierarchyLevelExpr;\n                };\n                return Rewriter;\n            }(data.SQExprRewriter));\n            var InBuilder = (function () {\n                function InBuilder() {\n                }\n                InBuilder.prototype.add = function (operand, value) {\n                    debug.assertValue(operand, 'operand');\n                    debug.assertValue(value, 'value');\n                    if (this.cancelled)\n                        return;\n                    if (this.operand && !data.SQExpr.equals(operand, this.operand)) {\n                        this.cancel();\n                        return;\n                    }\n                    this.operand = operand;\n                    var values = this.values;\n                    if (!values)\n                        values = this.values = [];\n                    values.push(value);\n                };\n                InBuilder.prototype.cancel = function () {\n                    this.cancelled = true;\n                };\n                InBuilder.prototype.complete = function () {\n                    if (this.cancelled || !this.operand)\n                        return;\n                    return data.SQExprBuilder.inExpr([this.operand], _.map(this.values, function (v) { return [v]; }));\n                };\n                return InBuilder;\n            }());\n        })(EqualsToInRewriter = data.EqualsToInRewriter || (data.EqualsToInRewriter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asScopeIdsContainer(filter, fieldSQExprs) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\n                var filterItems = filter.conditions();\n                debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\n                var filterItem = filterItems[0];\n                if (filterItem) {\n                    var visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\n                    if (filterItem.accept(visitor))\n                        return visitor.getResult();\n                }\n            }\n            SQExprConverter.asScopeIdsContainer = asScopeIdsContainer;\n            /** Gets a comparand value from the given DataViewScopeIdentity. */\n            function getFirstComparandValue(identity) {\n                debug.assertValue(identity, 'identity');\n                var comparandExpr = identity.expr.accept(new FindComparandVisitor());\n                if (comparandExpr)\n                    return comparandExpr.value;\n            }\n            SQExprConverter.getFirstComparandValue = getFirstComparandValue;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\n        var FilterScopeIdsCollectorVisitor = (function (_super) {\n            __extends(FilterScopeIdsCollectorVisitor, _super);\n            function FilterScopeIdsCollectorVisitor(fieldSQExprs) {\n                _super.call(this);\n                this.isRoot = true;\n                this.isNot = false;\n                this.keyExprsCount = null;\n                this.valueExprs = [];\n                // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\n                // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\n                // need to drop it in order to use JsonComparer.\n                this.fieldExprs = [];\n                for (var _i = 0, fieldSQExprs_1 = fieldSQExprs; _i < fieldSQExprs_1.length; _i++) {\n                    var field = fieldSQExprs_1[_i];\n                    this.fieldExprs.push(data.SQExprBuilder.removeEntityVariables(field));\n                }\n            }\n            FilterScopeIdsCollectorVisitor.prototype.getResult = function () {\n                debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');\n                var valueExprs = this.valueExprs, scopeIds = [];\n                var valueCount = this.keyExprsCount || 1;\n                for (var startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\n                    var values = valueExprs.slice(startIndex, endIndex);\n                    var scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\n                    if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, powerbi.DataViewScopeIdentity.equals))\n                        scopeIds.push(scopeId);\n                    startIndex += valueCount;\n                    endIndex += valueCount;\n                }\n                return {\n                    isNot: this.isNot,\n                    scopeIds: scopeIds,\n                };\n            };\n            FilterScopeIdsCollectorVisitor.getScopeIdentity = function (fieldExprs, valueExprs) {\n                debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\n                debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\n                var compoundSQExpr;\n                for (var i = 0, len = fieldExprs.length; i < len; i++) {\n                    var equalsExpr = data.SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\n                    if (!compoundSQExpr)\n                        compoundSQExpr = equalsExpr;\n                    else\n                        compoundSQExpr = data.SQExprBuilder.and(compoundSQExpr, equalsExpr);\n                }\n                return data.createDataViewScopeIdentity(compoundSQExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitOr = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitNot = function (expr) {\n                if (!this.isRoot)\n                    return this.unsupportedSQExpr();\n                this.isNot = true;\n                return expr.arg.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitConstant = function (expr) {\n                if (this.isRoot && expr.type.primitiveType === powerbi.PrimitiveType.Null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitCompare = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                if (expr.comparison !== data.QueryComparisonKind.Equal)\n                    return this.unsupportedSQExpr();\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitIn = function (expr) {\n                this.keyExprsCount = 0;\n                var result;\n                this.isRoot = false;\n                for (var _i = 0, _a = expr.args; _i < _a.length; _i++) {\n                    var arg = _a[_i];\n                    result = arg.accept(this);\n                    if (!result)\n                        return this.unsupportedSQExpr();\n                    this.keyExprsCount++;\n                }\n                if (this.keyExprsCount !== this.fieldExprs.length)\n                    return this.unsupportedSQExpr();\n                var values = expr.values;\n                for (var _b = 0, values_1 = values; _b < values_1.length; _b++) {\n                    var valueTuple = values_1[_b];\n                    var jlen = valueTuple.length;\n                    debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\n                    for (var _c = 0, valueTuple_1 = valueTuple; _c < valueTuple_1.length; _c++) {\n                        var value = valueTuple_1[_c];\n                        result = value.accept(this);\n                        if (!result)\n                            return this.unsupportedSQExpr();\n                    }\n                }\n                return result;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitColumnRef = function (expr) {\n                if (this.isRoot)\n                    return this.unsupportedSQExpr();\n                var fixedExpr = data.SQExprBuilder.removeEntityVariables(expr);\n                if (this.keyExprsCount !== null)\n                    return data.SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\n                return data.SQExpr.equals(this.fieldExprs[0], fixedExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefaultValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitAnyValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefault = function (expr) {\n                return this.unsupportedSQExpr();\n            };\n            FilterScopeIdsCollectorVisitor.prototype.unsupportedSQExpr = function () {\n                return false;\n            };\n            return FilterScopeIdsCollectorVisitor;\n        }(data.DefaultSQExprVisitor));\n        var FindComparandVisitor = (function (_super) {\n            __extends(FindComparandVisitor, _super);\n            function FindComparandVisitor() {\n                _super.apply(this, arguments);\n            }\n            FindComparandVisitor.prototype.visitAnd = function (expr) {\n                return expr.left.accept(this) || expr.right.accept(this);\n            };\n            FindComparandVisitor.prototype.visitCompare = function (expr) {\n                if (expr.comparison === data.QueryComparisonKind.Equal) {\n                    if (expr.right instanceof data.SQConstantExpr)\n                        return expr.right;\n                    if (expr.left instanceof data.SQConstantExpr)\n                        return expr.left;\n                }\n            };\n            return FindComparandVisitor;\n        }(data.DefaultSQExprVisitor));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\n        var ScopeIdentityExtractor;\n        (function (ScopeIdentityExtractor) {\n            function getKeys(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return null;\n                return ArrayExtensions.emptyToNull(extractor.keys);\n            }\n            ScopeIdentityExtractor.getKeys = getKeys;\n            function getInExpr(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return;\n                var keys = ArrayExtensions.emptyToNull(extractor.keys);\n                var keyValues = ArrayExtensions.emptyToNull(extractor.values);\n                if (keys && keyValues)\n                    return data.SQExprBuilder.inExpr(keys, [keyValues]);\n            }\n            ScopeIdentityExtractor.getInExpr = getInExpr;\n            /**\n             * Recognizes expressions of the form:\n             * 1) Equals(ColRef, Constant)\n             * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\n             * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\n             */\n            var ScopeIdExtractorImpl = (function (_super) {\n                __extends(ScopeIdExtractorImpl, _super);\n                function ScopeIdExtractorImpl() {\n                    _super.apply(this, arguments);\n                    this.keys = [];\n                    this.values = [];\n                }\n                ScopeIdExtractorImpl.prototype.visitAnd = function (expr) {\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal) {\n                        this.visitDefault(expr);\n                        return;\n                    }\n                    debug.assert(expr.left instanceof data.SQExpr && expr.right instanceof data.SQConstantExpr, 'invalid compare expr operands');\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitColumnRef = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitHierarchyLevel = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitConstant = function (expr) {\n                    this.values.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitArithmetic = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitDefault = function (expr) {\n                    this.malformed = true;\n                };\n                return ScopeIdExtractorImpl;\n            }(data.DefaultSQExprVisitor));\n        })(ScopeIdentityExtractor = data.ScopeIdentityExtractor || (data.ScopeIdentityExtractor = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var PrimitiveValueEncoding;\n        (function (PrimitiveValueEncoding) {\n            var SingleQuoteRegex = /'/g;\n            function decimal(value) {\n                debug.assertValue(value, 'value');\n                return value + 'M';\n            }\n            PrimitiveValueEncoding.decimal = decimal;\n            function double(value) {\n                debug.assertValue(value, 'value');\n                return value + 'D';\n            }\n            PrimitiveValueEncoding.double = double;\n            function integer(value) {\n                debug.assertValue(value, 'value');\n                return value + 'L';\n            }\n            PrimitiveValueEncoding.integer = integer;\n            function dateTime(value) {\n                debug.assertValue(value, 'value');\n                // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\n                // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\n                // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\n                var date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\n                var dateTimeString = date.toISOString();\n                // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\n                // we will drop it.\n                // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\n                if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\n                    dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\n                return \"datetime'\" + dateTimeString + \"'\";\n            }\n            PrimitiveValueEncoding.dateTime = dateTime;\n            function text(value) {\n                debug.assertValue(value, 'value');\n                return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\n            }\n            PrimitiveValueEncoding.text = text;\n            function nullEncoding() {\n                return 'null';\n            }\n            PrimitiveValueEncoding.nullEncoding = nullEncoding;\n            function boolean(value) {\n                return value ? 'true' : 'false';\n            }\n            PrimitiveValueEncoding.boolean = boolean;\n        })(PrimitiveValueEncoding = data.PrimitiveValueEncoding || (data.PrimitiveValueEncoding = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Agg = powerbi.data.QueryAggregateFunction;\n        function createSQAggregationOperations(datetimeMinMaxSupported) {\n            return new SQAggregationOperations(datetimeMinMaxSupported);\n        }\n        data.createSQAggregationOperations = createSQAggregationOperations;\n        var SQAggregationOperations = (function () {\n            function SQAggregationOperations(datetimeMinMaxSupported) {\n                this.datetimeMinMaxSupported = datetimeMinMaxSupported;\n            }\n            SQAggregationOperations.prototype.getSupportedAggregates = function (expr, schema, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                debug.assertAnyValue(targetTypes, 'targetTypes');\n                var metadata = getMetadataForUnderlyingType(expr, schema);\n                // don't use expr.validate as validate will be using this function and we end up in a recursive loop\n                if (!metadata)\n                    return [];\n                var valueType = metadata.type, fieldKind = metadata.kind, isPropertyIdentity = metadata.idOnEntityKey;\n                if (!valueType)\n                    return [];\n                // Cannot aggregate on model measures\n                if (fieldKind === 1 /* Measure */)\n                    return [];\n                if (valueType.numeric || valueType.integer) {\n                    var aggregates_1 = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var currentSchema = schema.schema(fieldExprItem.schema);\n                    if (currentSchema.capabilities.supportsMedian)\n                        aggregates_1.push(Agg.Median);\n                    return aggregates_1;\n                }\n                var aggregates = [];\n                // Min/Max of DateTime\n                if (this.datetimeMinMaxSupported &&\n                    valueType.dateTime &&\n                    (_.isEmpty(targetTypes) || powerbi.ValueType.isCompatibleTo(valueType, targetTypes))) {\n                    aggregates.push(Agg.Min);\n                    aggregates.push(Agg.Max);\n                }\n                // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\n                // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\n                var distinctCountAggExists = data.SQExprInfo.getAggregate(expr) === Agg.Count;\n                if (!(isPropertyIdentity && !distinctCountAggExists))\n                    aggregates.push(Agg.Count);\n                aggregates.push(Agg.CountNonNull);\n                return aggregates;\n            };\n            SQAggregationOperations.prototype.isSupportedAggregate = function (expr, schema, aggregate, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\n                return _.contains(supportedAggregates, aggregate);\n            };\n            SQAggregationOperations.prototype.createExprWithAggregate = function (expr, schema, aggregateNonNumericFields, targetTypes, preferredAggregate) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var aggregate;\n                if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\n                    aggregate = preferredAggregate;\n                }\n                else {\n                    aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\n                }\n                if (aggregate !== undefined)\n                    expr = data.SQExprBuilder.aggregate(expr, aggregate);\n                return expr;\n            };\n            return SQAggregationOperations;\n        }());\n        function getMetadataForUnderlyingType(expr, schema) {\n            // Unwrap the aggregate (if the expr has one), and look at the underlying type.\n            var metadata = data.SQExprBuilder.removeAggregate(expr).getMetadata(schema);\n            if (!metadata)\n                metadata = expr.getMetadata(schema);\n            return metadata;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQHierarchyExprUtils;\n        (function (SQHierarchyExprUtils) {\n            function getConceptualHierarchyLevelFromExpr(conceptualSchema, fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                var hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\n                if (hierarchyLevel)\n                    return SQHierarchyExprUtils.getConceptualHierarchyLevel(conceptualSchema, fieldExprItem.schema, fieldExprItem.entity, hierarchyLevel.name, hierarchyLevel.level);\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr = getConceptualHierarchyLevelFromExpr;\n            function getConceptualHierarchyLevel(conceptualSchema, schemaName, entity, hierarchy, hierarchyLevel) {\n                var schema = conceptualSchema.schema(schemaName);\n                var conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\n                if (conceptualHierarchy) {\n                    return conceptualHierarchy.levels.withName(hierarchyLevel);\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevel = getConceptualHierarchyLevel;\n            function getConceptualHierarchy(sqExpr, federatedSchema) {\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchy = sqExpr;\n                    if (sqExpr.arg instanceof data.SQEntityExpr) {\n                        var entityExpr = sqExpr.arg;\n                        return federatedSchema\n                            .schema(entityExpr.schema)\n                            .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\n                    }\n                    else if (sqExpr.arg instanceof data.SQPropertyVariationSourceExpr) {\n                        var variationExpr = sqExpr.arg;\n                        var sourceEntityExpr = variationExpr.arg;\n                        return federatedSchema\n                            .schema(sourceEntityExpr.schema)\n                            .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\n                    }\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchy = getConceptualHierarchy;\n            function expandExpr(schema, expr, suppressHierarchyLevelExpansion) {\n                return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\n                    SQExprVariationConverter.expand(expr, schema) ||\n                    // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\n                    (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\n                    expr;\n            }\n            SQHierarchyExprUtils.expandExpr = expandExpr;\n            function isHierarchyOrVariation(schema, expr) {\n                if (expr instanceof data.SQHierarchyExpr || expr instanceof data.SQHierarchyLevelExpr)\n                    return true;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0)\n                        return true;\n                }\n                return false;\n            }\n            SQHierarchyExprUtils.isHierarchyOrVariation = isHierarchyOrVariation;\n            // Return column reference expression for hierarchy level expression.\n            function getSourceVariationExpr(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                if (fieldExprPattern.columnHierarchyLevelVariation) {\n                    var entity = data.SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\n                    return data.SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceVariationExpr = getSourceVariationExpr;\n            // Return hierarchy expression for hierarchy level expression.\n            function getSourceHierarchy(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                var hierarchyLevel = fieldExprPattern.hierarchyLevel;\n                if (hierarchyLevel) {\n                    var entity = data.SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\n                    return data.SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceHierarchy = getSourceHierarchy;\n            function getHierarchySourceAsVariationSource(hierarchyLevelExpr) {\n                // Make sure the hierarchy level source is a hierarchy\n                if (!(hierarchyLevelExpr.arg instanceof data.SQHierarchyExpr))\n                    return;\n                // Check if the hierarchy source if a variation\n                var hierarchyRef = hierarchyLevelExpr.arg;\n                if (hierarchyRef.arg instanceof data.SQPropertyVariationSourceExpr)\n                    return hierarchyRef.arg;\n            }\n            SQHierarchyExprUtils.getHierarchySourceAsVariationSource = getHierarchySourceAsVariationSource;\n            /**\n            * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\n            */\n            function areHierarchyLevelsOrdered(allLevels, firstExpr, secondExpr) {\n                // Validate that both items hierarchy levels\n                if (!(firstExpr instanceof data.SQHierarchyLevelExpr) || !(secondExpr instanceof data.SQHierarchyLevelExpr))\n                    return false;\n                var firstLevel = firstExpr;\n                var secondLevel = secondExpr;\n                // Validate that both items belong to the same hierarchy\n                if (!data.SQExpr.equals(firstLevel.arg, secondLevel.arg))\n                    return false;\n                // Determine the order\n                var firstIndex = data.SQExprUtils.indexOfExpr(allLevels, firstLevel);\n                var secondIndex = data.SQExprUtils.indexOfExpr(allLevels, secondLevel);\n                return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\n            }\n            SQHierarchyExprUtils.areHierarchyLevelsOrdered = areHierarchyLevelsOrdered;\n            /**\n             * Given an ordered set of levels and an ordered subset of those levels, returns the index where\n             * expr should be inserted into the subset to maintain the correct order.\n             */\n            function getInsertionIndex(allLevels, orderedSubsetOfLevels, expr) {\n                var insertIndex = 0;\n                // Loop through the supplied levels until the insertion would no longer be in the correct order\n                while (insertIndex < orderedSubsetOfLevels.length &&\n                    areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\n                    insertIndex++;\n                }\n                return insertIndex;\n            }\n            SQHierarchyExprUtils.getInsertionIndex = getInsertionIndex;\n        })(SQHierarchyExprUtils = data.SQHierarchyExprUtils || (data.SQHierarchyExprUtils = {}));\n        var SQExprHierarchyToHierarchyLevelConverter;\n        (function (SQExprHierarchyToHierarchyLevelConverter) {\n            function convert(sqExpr, federatedSchema) {\n                debug.assertValue(sqExpr, 'sqExpr');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchyExpr = sqExpr;\n                    var conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\n                    if (conceptualHierarchy)\n                        return _.map(conceptualHierarchy.levels, function (hierarchyLevel) { return data.SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name); });\n                }\n            }\n            SQExprHierarchyToHierarchyLevelConverter.convert = convert;\n        })(SQExprHierarchyToHierarchyLevelConverter = data.SQExprHierarchyToHierarchyLevelConverter || (data.SQExprHierarchyToHierarchyLevelConverter = {}));\n        var SQExprHierarchyLevelConverter;\n        (function (SQExprHierarchyLevelConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs = [];\n                if (expr instanceof data.SQHierarchyLevelExpr) {\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    if (fieldExpr.hierarchyLevel) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        var hierarchy = schema\n                            .schema(fieldExprItem.schema)\n                            .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\n                        if (hierarchy) {\n                            var hierarchyLevels = hierarchy.levels;\n                            for (var _i = 0, hierarchyLevels_2 = hierarchyLevels; _i < hierarchyLevels_2.length; _i++) {\n                                var hierarchyLevel = hierarchyLevels_2[_i];\n                                if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\n                                    exprs.push(expr);\n                                    break;\n                                }\n                                else\n                                    exprs.push(data.SQExprBuilder.hierarchyLevel(data.SQExprBuilder.hierarchy(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), hierarchy.name), hierarchyLevel.name));\n                            }\n                        }\n                    }\n                }\n                if (!_.isEmpty(exprs))\n                    return exprs;\n            }\n            SQExprHierarchyLevelConverter.expand = expand;\n        })(SQExprHierarchyLevelConverter || (SQExprHierarchyLevelConverter = {}));\n        var SQExprVariationConverter;\n        (function (SQExprVariationConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0) {\n                        var variations = column.variations;\n                        // for SU11, we support only one variation\n                        debug.assert(variations.length === 1, \"variations.length\");\n                        var variation = variations[0];\n                        var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        exprs = [];\n                        if (variation.defaultHierarchy) {\n                            var hierarchyExpr = data.SQExprBuilder.hierarchy(data.SQExprBuilder.propertyVariationSource(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), variation.name, conceptualProperty.name), variation.defaultHierarchy.name);\n                            for (var _i = 0, _a = variation.defaultHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                exprs.push(data.SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\n                            }\n                        }\n                    }\n                }\n                return exprs;\n            }\n            SQExprVariationConverter.expand = expand;\n        })(SQExprVariationConverter || (SQExprVariationConverter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        ;\n        var SQExprGroupUtils;\n        (function (SQExprGroupUtils) {\n            /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\n            function groupExprs(schema, exprs) {\n                var groups = [];\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i];\n                    debug.assertValue(expr, \"Expression not found\");\n                    if (!(expr instanceof data.SQHierarchyLevelExpr)) {\n                        groups.push({ expr: expr, children: null, selectQueryIndex: i });\n                    }\n                    else {\n                        addChildToGroup(schema, groups, expr, i);\n                    }\n                }\n                return groups;\n            }\n            SQExprGroupUtils.groupExprs = groupExprs;\n            function addChildToGroup(schema, groups, expr, selectQueryIndex) {\n                // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \n                // a new Group or to the last Group\n                var shouldAddExpressionToNewGroup = true;\n                var exprSource = data.SQHierarchyExprUtils.getSourceVariationExpr(expr) || data.SQHierarchyExprUtils.getSourceHierarchy(expr);\n                var lastGroup = _.last(groups);\n                // The relevant group is always the last added. If it has the same source hierarchy,\n                // and is properly ordered within that hierarchy, we will need to add to this group.\n                if (lastGroup && lastGroup.children && data.SQExpr.equals(lastGroup.expr, exprSource)) {\n                    var expandedExpr = data.SQHierarchyExprUtils.expandExpr(schema, expr.arg);\n                    if (expandedExpr instanceof Array) {\n                        var allHierarchyLevels = expandedExpr;\n                        shouldAddExpressionToNewGroup = !data.SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\n                    }\n                }\n                if (shouldAddExpressionToNewGroup)\n                    // Use the Sourcevariation as the expression for the group.\n                    groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\n                else {\n                    debug.assertValue(lastGroup, 'There should be a group to add the variation to');\n                    debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\n                    lastGroup.children.push(expr);\n                }\n            }\n        })(SQExprGroupUtils = data.SQExprGroupUtils || (data.SQExprGroupUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var StringExtensions = jsCommon.StringExtensions;\n        /** Represents an immutable expression within a SemanticQuery. */\n        var SQExpr = (function () {\n            function SQExpr(kind) {\n                debug.assertValue(kind, 'kind');\n                this._kind = kind;\n            }\n            SQExpr.equals = function (x, y, ignoreCase) {\n                return SQExprEqualityVisitor.run(x, y, ignoreCase);\n            };\n            SQExpr.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.accept(validator);\n                return validator.errors;\n            };\n            SQExpr.prototype.accept = function (visitor, arg) {\n                debug.assertFail('abstract method');\n                return;\n            };\n            Object.defineProperty(SQExpr.prototype, \"kind\", {\n                get: function () {\n                    return this._kind;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            SQExpr.isColumn = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 1 /* ColumnRef */;\n            };\n            SQExpr.isConstant = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 16 /* Constant */;\n            };\n            SQExpr.isEntity = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 0 /* Entity */;\n            };\n            SQExpr.isHierarchy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 5 /* Hierarchy */;\n            };\n            SQExpr.isHierarchyLevel = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 6 /* HierarchyLevel */;\n            };\n            SQExpr.isAggregation = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 3 /* Aggregation */;\n            };\n            SQExpr.isMeasure = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 2 /* MeasureRef */;\n            };\n            SQExpr.isSelectRef = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 28 /* SelectRef */;\n            };\n            SQExpr.isResourcePackageItem = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 24 /* ResourcePackageItem */;\n            };\n            SQExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                if (field.column || field.columnAggr || field.measure)\n                    return this.getMetadataForProperty(field, federatedSchema);\n                if (field.hierarchyLevel || field.hierarchyLevelAggr)\n                    return this.getMetadataForHierarchyLevel(field, federatedSchema);\n                if (field.columnHierarchyLevelVariation)\n                    return this.getMetadataForVariation(field, federatedSchema);\n                if (field.percentOfGrandTotal)\n                    return this.getMetadataForPercentOfGrandTotal();\n                return SQExpr.getMetadataForEntity(field, federatedSchema);\n            };\n            SQExpr.prototype.getDefaultAggregate = function (federatedSchema, forceAggregation) {\n                if (forceAggregation === void 0) { forceAggregation = false; }\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                var aggregate;\n                if (property && property.kind === 0 /* Column */) {\n                    var propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\n                    if ((property.type.integer || property.type.numeric) &&\n                        propertyDefaultAggregate !== 1 /* None */) {\n                        aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\n                        if (aggregate === undefined)\n                            aggregate = defaultAggregateForDataType(property.type);\n                    }\n                    // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \n                    // aggregate on CountNonNull.\n                    if (aggregate === undefined && forceAggregation) {\n                        aggregate = data.QueryAggregateFunction.CountNonNull;\n                    }\n                }\n                return aggregate;\n            };\n            /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\n            SQExpr.prototype.getKeyColumns = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keySQExprs = [];\n                var keys = this.getPropertyKeys(schema);\n                if (keys && keys.length > 0) {\n                    for (var i = 0, len = keys.length; i < len; i++) {\n                        keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\n                    }\n                }\n                else\n                    keySQExprs.push(columnRefExpr);\n                return keySQExprs;\n            };\n            /** Returns a value indicating whether the expression would group on keys other than itself.*/\n            SQExpr.prototype.hasGroupOnKeys = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keys = this.getPropertyKeys(schema);\n                if (!keys || keys.length < 1)\n                    return false;\n                if (keys.length > 1)\n                    return true;\n                var keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\n                return !SQExpr.equals(keySqExpr, this);\n            };\n            SQExpr.prototype.getPropertyKeys = function (schema) {\n                var property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\n                if (!property)\n                    return;\n                return property.column ? property.column.keys : undefined;\n            };\n            SQExpr.prototype.getConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var propertyName = data.FieldExprPattern.getPropertyName(field);\n                if (propertyName)\n                    return federatedSchema\n                        .schema(fieldExprItem.schema)\n                        .findProperty(fieldExprItem.entity, propertyName);\n            };\n            SQExpr.prototype.getTargetEntityForVariation = function (federatedSchema, variationName) {\n                var property = this.getConceptualProperty(federatedSchema);\n                if (property && property.column && !_.isEmpty(property.column.variations)) {\n                    var variations = property.column.variations;\n                    for (var _i = 0, variations_2 = variations; _i < variations_2.length; _i++) {\n                        var variation = variations_2[_i];\n                        if (variation.name === variationName)\n                            return variation.navigationProperty.targetEntity.name;\n                    }\n                }\n            };\n            SQExpr.prototype.getTargetEntity = function (federatedSchema) {\n                return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\n            };\n            SQExpr.prototype.getHierarchyLevelConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\n                if (fieldExprHierachyLevel) {\n                    var fieldExprEntity = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                    var hierarchy = federatedSchema\n                        .schema(fieldExprEntity.schema)\n                        .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\n                    if (hierarchy) {\n                        var hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\n                        if (hierarchyLevel)\n                            return hierarchyLevel.column;\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForVariation = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var sourceProperty = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\n                if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\n                    for (var _i = 0, _a = sourceProperty.column.variations; _i < _a.length; _i++) {\n                        var variation = _a[_i];\n                        if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\n                            for (var _b = 0, _c = variation.defaultHierarchy.levels; _b < _c.length; _b++) {\n                                var level = _c[_b];\n                                if (level.name === columnHierarchyLevelVariation.level.level) {\n                                    var property = level.column;\n                                    return {\n                                        kind: (property.kind === 1 /* Measure */) ? 1 /* Measure */ : 0 /* Column */,\n                                        type: property.type,\n                                        format: property.format,\n                                        idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                                        defaultAggregate: property.column ? property.column.defaultAggregate : null\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForHierarchyLevel = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.prototype.getMetadataForPercentOfGrandTotal = function () {\n                return {\n                    kind: 1 /* Measure */,\n                    format: '#,##0.##%',\n                    type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double)\n                };\n            };\n            SQExpr.prototype.getPropertyMetadata = function (field, property) {\n                var format = property.format;\n                var type = property.type;\n                var columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\n                if (columnAggregate) {\n                    switch (columnAggregate.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer);\n                            format = undefined;\n                            break;\n                        case data.QueryAggregateFunction.Avg:\n                            if (type.integer)\n                                type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double);\n                            break;\n                    }\n                }\n                return {\n                    kind: (property.kind === 1 /* Measure */ || (columnAggregate && columnAggregate.aggregate !== undefined)) ? 1 /* Measure */ : 0 /* Column */,\n                    type: type,\n                    format: format,\n                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                    aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\n                    defaultAggregate: property.column ? property.column.defaultAggregate : null\n                };\n            };\n            SQExpr.prototype.getMetadataForProperty = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.getMetadataForEntity = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var entity = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .entities\n                    .withName(fieldExprItem.entity);\n                if (!entity)\n                    return;\n                // We only support count and countnonnull for entity.\n                if (field.entityAggr) {\n                    switch (field.entityAggr.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            return {\n                                kind: 1 /* Measure */,\n                                type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer),\n                                format: undefined,\n                                idOnEntityKey: false,\n                                aggregate: field.entityAggr.aggregate\n                            };\n                    }\n                }\n            };\n            return SQExpr;\n        }());\n        data.SQExpr = SQExpr;\n        /** Note: Exported for testability */\n        function defaultAggregateForDataType(type) {\n            if (type.integer || type.numeric)\n                return data.QueryAggregateFunction.Sum;\n            return data.QueryAggregateFunction.Count;\n        }\n        data.defaultAggregateForDataType = defaultAggregateForDataType;\n        /** Note: Exported for testability */\n        function defaultAggregateToQueryAggregateFunction(aggregate) {\n            switch (aggregate) {\n                case 6 /* Average */:\n                    return data.QueryAggregateFunction.Avg;\n                case 3 /* Count */:\n                    return data.QueryAggregateFunction.CountNonNull;\n                case 7 /* DistinctCount */:\n                    return data.QueryAggregateFunction.Count;\n                case 5 /* Max */:\n                    return data.QueryAggregateFunction.Max;\n                case 4 /* Min */:\n                    return data.QueryAggregateFunction.Min;\n                case 2 /* Sum */:\n                    return data.QueryAggregateFunction.Sum;\n                default:\n                    return;\n            }\n        }\n        data.defaultAggregateToQueryAggregateFunction = defaultAggregateToQueryAggregateFunction;\n        var SQEntityExpr = (function (_super) {\n            __extends(SQEntityExpr, _super);\n            function SQEntityExpr(schema, entity, variable) {\n                debug.assertValue(entity, 'entity');\n                _super.call(this, 0 /* Entity */);\n                this.schema = schema;\n                this.entity = entity;\n                if (variable)\n                    this.variable = variable;\n            }\n            SQEntityExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitEntity(this, arg);\n            };\n            return SQEntityExpr;\n        }(SQExpr));\n        data.SQEntityExpr = SQEntityExpr;\n        var SQArithmeticExpr = (function (_super) {\n            __extends(SQArithmeticExpr, _super);\n            function SQArithmeticExpr(left, right, operator) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                debug.assertValue(operator, 'operator');\n                _super.call(this, 22 /* Arithmetic */);\n                this.left = left;\n                this.right = right;\n                this.operator = operator;\n            }\n            SQArithmeticExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitArithmetic(this, arg);\n            };\n            return SQArithmeticExpr;\n        }(SQExpr));\n        data.SQArithmeticExpr = SQArithmeticExpr;\n        var SQScopedEvalExpr = (function (_super) {\n            __extends(SQScopedEvalExpr, _super);\n            function SQScopedEvalExpr(expression, scope) {\n                debug.assertValue(expression, 'expression');\n                debug.assertValue(scope, 'scope');\n                _super.call(this, 25 /* ScopedEval */);\n                this.expression = expression;\n                this.scope = scope;\n            }\n            SQScopedEvalExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitScopedEval(this, arg);\n            };\n            SQScopedEvalExpr.prototype.getMetadata = function (federatedSchema) {\n                return this.expression.getMetadata(federatedSchema);\n            };\n            return SQScopedEvalExpr;\n        }(SQExpr));\n        data.SQScopedEvalExpr = SQScopedEvalExpr;\n        var SQPropRefExpr = (function (_super) {\n            __extends(SQPropRefExpr, _super);\n            function SQPropRefExpr(kind, source, ref) {\n                debug.assertValue(kind, 'kind');\n                debug.assertValue(source, 'source');\n                debug.assertValue(ref, 'ref');\n                _super.call(this, kind);\n                this.source = source;\n                this.ref = ref;\n            }\n            return SQPropRefExpr;\n        }(SQExpr));\n        data.SQPropRefExpr = SQPropRefExpr;\n        var SQColumnRefExpr = (function (_super) {\n            __extends(SQColumnRefExpr, _super);\n            function SQColumnRefExpr(source, ref) {\n                _super.call(this, 1 /* ColumnRef */, source, ref);\n            }\n            SQColumnRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitColumnRef(this, arg);\n            };\n            return SQColumnRefExpr;\n        }(SQPropRefExpr));\n        data.SQColumnRefExpr = SQColumnRefExpr;\n        var SQMeasureRefExpr = (function (_super) {\n            __extends(SQMeasureRefExpr, _super);\n            function SQMeasureRefExpr(source, ref) {\n                _super.call(this, 2 /* MeasureRef */, source, ref);\n            }\n            SQMeasureRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitMeasureRef(this, arg);\n            };\n            return SQMeasureRefExpr;\n        }(SQPropRefExpr));\n        data.SQMeasureRefExpr = SQMeasureRefExpr;\n        var SQAggregationExpr = (function (_super) {\n            __extends(SQAggregationExpr, _super);\n            function SQAggregationExpr(arg, func) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(func, 'func');\n                _super.call(this, 3 /* Aggregation */);\n                this.arg = arg;\n                this.func = func;\n            }\n            SQAggregationExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAggr(this, arg);\n            };\n            return SQAggregationExpr;\n        }(SQExpr));\n        data.SQAggregationExpr = SQAggregationExpr;\n        var SQPercentileExpr = (function (_super) {\n            __extends(SQPercentileExpr, _super);\n            function SQPercentileExpr(arg, k, exclusive) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(k, 'k');\n                debug.assert(0 <= k && k <= 1, '0 <= k && k <= 1');\n                debug.assertValue(exclusive, 'exclusive');\n                _super.call(this, 27 /* Percentile */);\n                this.arg = arg;\n                this.k = k;\n                this.exclusive = exclusive;\n            }\n            SQPercentileExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var argMetadata = this.arg.getMetadata(federatedSchema);\n                if (argMetadata) {\n                    return {\n                        kind: 1 /* Measure */,\n                        type: argMetadata.type,\n                    };\n                }\n            };\n            SQPercentileExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPercentile(this, arg);\n            };\n            return SQPercentileExpr;\n        }(SQExpr));\n        data.SQPercentileExpr = SQPercentileExpr;\n        var SQPropertyVariationSourceExpr = (function (_super) {\n            __extends(SQPropertyVariationSourceExpr, _super);\n            function SQPropertyVariationSourceExpr(arg, name, property) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(name, 'name');\n                debug.assertValue(property, 'property');\n                _super.call(this, 4 /* PropertyVariationSource */);\n                this.arg = arg;\n                this.name = name;\n                this.property = property;\n            }\n            SQPropertyVariationSourceExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPropertyVariationSource(this, arg);\n            };\n            return SQPropertyVariationSourceExpr;\n        }(SQExpr));\n        data.SQPropertyVariationSourceExpr = SQPropertyVariationSourceExpr;\n        var SQHierarchyExpr = (function (_super) {\n            __extends(SQHierarchyExpr, _super);\n            function SQHierarchyExpr(arg, hierarchy) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(hierarchy, 'hierarchy');\n                _super.call(this, 5 /* Hierarchy */);\n                this.arg = arg;\n                this.hierarchy = hierarchy;\n            }\n            SQHierarchyExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchy(this, arg);\n            };\n            return SQHierarchyExpr;\n        }(SQExpr));\n        data.SQHierarchyExpr = SQHierarchyExpr;\n        var SQHierarchyLevelExpr = (function (_super) {\n            __extends(SQHierarchyLevelExpr, _super);\n            function SQHierarchyLevelExpr(arg, level) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(level, 'level');\n                _super.call(this, 6 /* HierarchyLevel */);\n                this.arg = arg;\n                this.level = level;\n            }\n            SQHierarchyLevelExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchyLevel(this, arg);\n            };\n            return SQHierarchyLevelExpr;\n        }(SQExpr));\n        data.SQHierarchyLevelExpr = SQHierarchyLevelExpr;\n        var SQSelectRefExpr = (function (_super) {\n            __extends(SQSelectRefExpr, _super);\n            function SQSelectRefExpr(expressionName) {\n                debug.assertValue(expressionName, 'arg');\n                _super.call(this, 28 /* SelectRef */);\n                this.expressionName = expressionName;\n            }\n            SQSelectRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitSelectRef(this, arg);\n            };\n            return SQSelectRefExpr;\n        }(SQExpr));\n        data.SQSelectRefExpr = SQSelectRefExpr;\n        var SQAndExpr = (function (_super) {\n            __extends(SQAndExpr, _super);\n            function SQAndExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 7 /* And */);\n                this.left = left;\n                this.right = right;\n            }\n            SQAndExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnd(this, arg);\n            };\n            return SQAndExpr;\n        }(SQExpr));\n        data.SQAndExpr = SQAndExpr;\n        var SQBetweenExpr = (function (_super) {\n            __extends(SQBetweenExpr, _super);\n            function SQBetweenExpr(arg, lower, upper) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(lower, 'lower');\n                debug.assertValue(upper, 'upper');\n                _super.call(this, 8 /* Between */);\n                this.arg = arg;\n                this.lower = lower;\n                this.upper = upper;\n            }\n            SQBetweenExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitBetween(this, arg);\n            };\n            return SQBetweenExpr;\n        }(SQExpr));\n        data.SQBetweenExpr = SQBetweenExpr;\n        var SQInExpr = (function (_super) {\n            __extends(SQInExpr, _super);\n            function SQInExpr(args, values) {\n                debug.assertValue(args, 'args');\n                debug.assertValue(values, 'values');\n                _super.call(this, 9 /* In */);\n                this.args = args;\n                this.values = values;\n            }\n            SQInExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitIn(this, arg);\n            };\n            return SQInExpr;\n        }(SQExpr));\n        data.SQInExpr = SQInExpr;\n        var SQOrExpr = (function (_super) {\n            __extends(SQOrExpr, _super);\n            function SQOrExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 10 /* Or */);\n                this.left = left;\n                this.right = right;\n            }\n            SQOrExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitOr(this, arg);\n            };\n            return SQOrExpr;\n        }(SQExpr));\n        data.SQOrExpr = SQOrExpr;\n        var SQCompareExpr = (function (_super) {\n            __extends(SQCompareExpr, _super);\n            function SQCompareExpr(comparison, left, right) {\n                debug.assertValue(comparison, 'kind');\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 12 /* Compare */);\n                this.comparison = comparison;\n                this.left = left;\n                this.right = right;\n            }\n            SQCompareExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitCompare(this, arg);\n            };\n            return SQCompareExpr;\n        }(SQExpr));\n        data.SQCompareExpr = SQCompareExpr;\n        var SQContainsExpr = (function (_super) {\n            __extends(SQContainsExpr, _super);\n            function SQContainsExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 11 /* Contains */);\n                this.left = left;\n                this.right = right;\n            }\n            SQContainsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitContains(this, arg);\n            };\n            return SQContainsExpr;\n        }(SQExpr));\n        data.SQContainsExpr = SQContainsExpr;\n        var SQStartsWithExpr = (function (_super) {\n            __extends(SQStartsWithExpr, _super);\n            function SQStartsWithExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 13 /* StartsWith */);\n                this.left = left;\n                this.right = right;\n            }\n            SQStartsWithExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitStartsWith(this, arg);\n            };\n            return SQStartsWithExpr;\n        }(SQExpr));\n        data.SQStartsWithExpr = SQStartsWithExpr;\n        var SQExistsExpr = (function (_super) {\n            __extends(SQExistsExpr, _super);\n            function SQExistsExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 14 /* Exists */);\n                this.arg = arg;\n            }\n            SQExistsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitExists(this, arg);\n            };\n            return SQExistsExpr;\n        }(SQExpr));\n        data.SQExistsExpr = SQExistsExpr;\n        var SQNotExpr = (function (_super) {\n            __extends(SQNotExpr, _super);\n            function SQNotExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 15 /* Not */);\n                this.arg = arg;\n            }\n            SQNotExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNot(this, arg);\n            };\n            return SQNotExpr;\n        }(SQExpr));\n        data.SQNotExpr = SQNotExpr;\n        var SQConstantExpr = (function (_super) {\n            __extends(SQConstantExpr, _super);\n            function SQConstantExpr(type, value, valueEncoded) {\n                debug.assertValue(type, 'type');\n                _super.call(this, 16 /* Constant */);\n                this.type = type;\n                this.value = value;\n                this.valueEncoded = valueEncoded;\n            }\n            SQConstantExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitConstant(this, arg);\n            };\n            SQConstantExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                return {\n                    // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\n                    // A getType or similiar function in the future would be more appropriate. \n                    kind: 1 /* Measure */,\n                    type: this.type,\n                };\n            };\n            return SQConstantExpr;\n        }(SQExpr));\n        data.SQConstantExpr = SQConstantExpr;\n        var SQDateSpanExpr = (function (_super) {\n            __extends(SQDateSpanExpr, _super);\n            function SQDateSpanExpr(unit, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 17 /* DateSpan */);\n                this.unit = unit;\n                this.arg = arg;\n            }\n            SQDateSpanExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateSpan(this, arg);\n            };\n            return SQDateSpanExpr;\n        }(SQExpr));\n        data.SQDateSpanExpr = SQDateSpanExpr;\n        var SQDateAddExpr = (function (_super) {\n            __extends(SQDateAddExpr, _super);\n            function SQDateAddExpr(unit, amount, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(amount, 'amount');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 18 /* DateAdd */);\n                this.unit = unit;\n                this.arg = arg;\n                this.amount = amount;\n            }\n            SQDateAddExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateAdd(this, arg);\n            };\n            return SQDateAddExpr;\n        }(SQExpr));\n        data.SQDateAddExpr = SQDateAddExpr;\n        var SQNowExpr = (function (_super) {\n            __extends(SQNowExpr, _super);\n            function SQNowExpr() {\n                _super.call(this, 19 /* Now */);\n            }\n            SQNowExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNow(this, arg);\n            };\n            return SQNowExpr;\n        }(SQExpr));\n        data.SQNowExpr = SQNowExpr;\n        var SQDefaultValueExpr = (function (_super) {\n            __extends(SQDefaultValueExpr, _super);\n            function SQDefaultValueExpr() {\n                _super.call(this, 21 /* DefaultValue */);\n            }\n            SQDefaultValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDefaultValue(this, arg);\n            };\n            return SQDefaultValueExpr;\n        }(SQExpr));\n        data.SQDefaultValueExpr = SQDefaultValueExpr;\n        var SQAnyValueExpr = (function (_super) {\n            __extends(SQAnyValueExpr, _super);\n            function SQAnyValueExpr() {\n                _super.call(this, 20 /* AnyValue */);\n            }\n            SQAnyValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnyValue(this, arg);\n            };\n            return SQAnyValueExpr;\n        }(SQExpr));\n        data.SQAnyValueExpr = SQAnyValueExpr;\n        var SQFillRuleExpr = (function (_super) {\n            __extends(SQFillRuleExpr, _super);\n            function SQFillRuleExpr(input, fillRule) {\n                debug.assertValue(input, 'input');\n                debug.assertValue(fillRule, 'fillRule');\n                _super.call(this, 23 /* FillRule */);\n                this.input = input;\n                this.rule = fillRule;\n            }\n            SQFillRuleExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitFillRule(this, arg);\n            };\n            return SQFillRuleExpr;\n        }(SQExpr));\n        data.SQFillRuleExpr = SQFillRuleExpr;\n        var SQResourcePackageItemExpr = (function (_super) {\n            __extends(SQResourcePackageItemExpr, _super);\n            function SQResourcePackageItemExpr(packageName, packageType, itemName) {\n                debug.assertValue(packageName, 'packageName');\n                debug.assertValue(itemName, 'itemName');\n                _super.call(this, 24 /* ResourcePackageItem */);\n                this.packageName = packageName;\n                this.packageType = packageType;\n                this.itemName = itemName;\n            }\n            SQResourcePackageItemExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitResourcePackageItem(this, arg);\n            };\n            return SQResourcePackageItemExpr;\n        }(SQExpr));\n        data.SQResourcePackageItemExpr = SQResourcePackageItemExpr;\n        /** Provides utilities for creating & manipulating expressions. */\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function entity(schema, entity, variable) {\n                return new SQEntityExpr(schema, entity, variable);\n            }\n            SQExprBuilder.entity = entity;\n            function columnRef(source, prop) {\n                return new SQColumnRefExpr(source, prop);\n            }\n            SQExprBuilder.columnRef = columnRef;\n            function measureRef(source, prop) {\n                return new SQMeasureRefExpr(source, prop);\n            }\n            SQExprBuilder.measureRef = measureRef;\n            function aggregate(source, aggregate) {\n                return new SQAggregationExpr(source, aggregate);\n            }\n            SQExprBuilder.aggregate = aggregate;\n            function selectRef(expressionName) {\n                return new SQSelectRefExpr(expressionName);\n            }\n            SQExprBuilder.selectRef = selectRef;\n            function percentile(source, k, exclusive) {\n                return new SQPercentileExpr(source, k, exclusive);\n            }\n            SQExprBuilder.percentile = percentile;\n            function arithmetic(left, right, operator) {\n                return new SQArithmeticExpr(left, right, operator);\n            }\n            SQExprBuilder.arithmetic = arithmetic;\n            function scopedEval(expression, scope) {\n                return new SQScopedEvalExpr(expression, scope);\n            }\n            SQExprBuilder.scopedEval = scopedEval;\n            function hierarchy(source, hierarchy) {\n                return new SQHierarchyExpr(source, hierarchy);\n            }\n            SQExprBuilder.hierarchy = hierarchy;\n            function propertyVariationSource(source, name, property) {\n                return new SQPropertyVariationSourceExpr(source, name, property);\n            }\n            SQExprBuilder.propertyVariationSource = propertyVariationSource;\n            function hierarchyLevel(source, level) {\n                return new SQHierarchyLevelExpr(source, level);\n            }\n            SQExprBuilder.hierarchyLevel = hierarchyLevel;\n            function and(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                return new SQAndExpr(left, right);\n            }\n            SQExprBuilder.and = and;\n            function between(arg, lower, upper) {\n                return new SQBetweenExpr(arg, lower, upper);\n            }\n            SQExprBuilder.between = between;\n            function inExpr(args, values) {\n                return new SQInExpr(args, values);\n            }\n            SQExprBuilder.inExpr = inExpr;\n            function or(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                if (left instanceof SQInExpr && right instanceof SQInExpr) {\n                    var inExpr_1 = tryUseInExprs(left, right);\n                    if (inExpr_1)\n                        return inExpr_1;\n                }\n                return new SQOrExpr(left, right);\n            }\n            SQExprBuilder.or = or;\n            function tryUseInExprs(left, right) {\n                if (!left.args || !right.args)\n                    return;\n                var leftArgLen = left.args.length;\n                var rightArgLen = right.args.length;\n                if (leftArgLen !== rightArgLen)\n                    return;\n                for (var i = 0; i < leftArgLen; ++i) {\n                    if (!SQExpr.equals(left.args[i], right.args[i]))\n                        return;\n                }\n                var combinedValues = left.values.concat(right.values);\n                return SQExprBuilder.inExpr(left.args, combinedValues);\n            }\n            function compare(kind, left, right) {\n                return new SQCompareExpr(kind, left, right);\n            }\n            SQExprBuilder.compare = compare;\n            function contains(left, right) {\n                return new SQContainsExpr(left, right);\n            }\n            SQExprBuilder.contains = contains;\n            function exists(arg) {\n                return new SQExistsExpr(arg);\n            }\n            SQExprBuilder.exists = exists;\n            function equal(left, right) {\n                return compare(data.QueryComparisonKind.Equal, left, right);\n            }\n            SQExprBuilder.equal = equal;\n            function not(arg) {\n                return new SQNotExpr(arg);\n            }\n            SQExprBuilder.not = not;\n            function startsWith(left, right) {\n                return new SQStartsWithExpr(left, right);\n            }\n            SQExprBuilder.startsWith = startsWith;\n            function nullConstant() {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Null), null, data.PrimitiveValueEncoding.nullEncoding());\n            }\n            SQExprBuilder.nullConstant = nullConstant;\n            function now() {\n                return new SQNowExpr();\n            }\n            SQExprBuilder.now = now;\n            function defaultValue() {\n                return new SQDefaultValueExpr();\n            }\n            SQExprBuilder.defaultValue = defaultValue;\n            function anyValue() {\n                return new SQAnyValueExpr();\n            }\n            SQExprBuilder.anyValue = anyValue;\n            function boolean(value) {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Boolean), value, data.PrimitiveValueEncoding.boolean(value));\n            }\n            SQExprBuilder.boolean = boolean;\n            function dateAdd(unit, amount, arg) {\n                return new SQDateAddExpr(unit, amount, arg);\n            }\n            SQExprBuilder.dateAdd = dateAdd;\n            function dateTime(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.dateTime(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.DateTime), value, valueEncoded);\n            }\n            SQExprBuilder.dateTime = dateTime;\n            function dateSpan(unit, arg) {\n                return new SQDateSpanExpr(unit, arg);\n            }\n            SQExprBuilder.dateSpan = dateSpan;\n            function decimal(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.decimal(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Decimal), value, valueEncoded);\n            }\n            SQExprBuilder.decimal = decimal;\n            function double(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.double(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double), value, valueEncoded);\n            }\n            SQExprBuilder.double = double;\n            function integer(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.integer(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer), value, valueEncoded);\n            }\n            SQExprBuilder.integer = integer;\n            function text(value, valueEncoded) {\n                debug.assert(!valueEncoded || valueEncoded === data.PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Text), value, valueEncoded || data.PrimitiveValueEncoding.text(value));\n            }\n            SQExprBuilder.text = text;\n            /** Returns an SQExpr that evaluates to the constant value. */\n            function typedConstant(value, type) {\n                if (value == null)\n                    return nullConstant();\n                if (_.isBoolean(value)) {\n                    return boolean(value);\n                }\n                if (_.isString(value)) {\n                    return text(value);\n                }\n                if (_.isNumber(value)) {\n                    if (type.integer && powerbi.Double.isInteger(value))\n                        return integer(value);\n                    return double(value);\n                }\n                if (value instanceof Date) {\n                    return dateTime(value);\n                }\n            }\n            SQExprBuilder.typedConstant = typedConstant;\n            function setAggregate(expr, aggregate) {\n                return FieldExprChangeAggregateRewriter.rewrite(expr, aggregate);\n            }\n            SQExprBuilder.setAggregate = setAggregate;\n            function removeAggregate(expr) {\n                return FieldExprRemoveAggregateRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeAggregate = removeAggregate;\n            function setPercentOfGrandTotal(expr) {\n                return SQExprSetPercentOfGrandTotalRewriter.rewrite(expr);\n            }\n            SQExprBuilder.setPercentOfGrandTotal = setPercentOfGrandTotal;\n            function removePercentOfGrandTotal(expr) {\n                return SQExprRemovePercentOfGrandTotalRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removePercentOfGrandTotal = removePercentOfGrandTotal;\n            function removeEntityVariables(expr) {\n                return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeEntityVariables = removeEntityVariables;\n            function fillRule(expr, rule) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(rule, 'rule');\n                return new SQFillRuleExpr(expr, rule);\n            }\n            SQExprBuilder.fillRule = fillRule;\n            function resourcePackageItem(packageName, packageType, itemName) {\n                return new SQResourcePackageItemExpr(packageName, packageType, itemName);\n            }\n            SQExprBuilder.resourcePackageItem = resourcePackageItem;\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        /** Provides utilities for obtaining information about expressions. */\n        var SQExprInfo;\n        (function (SQExprInfo) {\n            function getAggregate(expr) {\n                return SQExprAggregateInfoVisitor.getAggregate(expr);\n            }\n            SQExprInfo.getAggregate = getAggregate;\n        })(SQExprInfo = data.SQExprInfo || (data.SQExprInfo = {}));\n        var SQExprEqualityVisitor = (function () {\n            function SQExprEqualityVisitor(ignoreCase) {\n                this.ignoreCase = ignoreCase;\n            }\n            SQExprEqualityVisitor.run = function (x, y, ignoreCase) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (ignoreCase)\n                    return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\n                return x.accept(SQExprEqualityVisitor.instance, y);\n            };\n            SQExprEqualityVisitor.prototype.visitColumnRef = function (expr, comparand) {\n                return comparand instanceof SQColumnRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitMeasureRef = function (expr, comparand) {\n                return comparand instanceof SQMeasureRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitAggr = function (expr, comparand) {\n                return comparand instanceof SQAggregationExpr &&\n                    expr.func === comparand.func &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPercentile = function (expr, comparand) {\n                return comparand instanceof SQPercentileExpr &&\n                    expr.exclusive === comparand.exclusive &&\n                    expr.k === comparand.k &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchy = function (expr, comparand) {\n                return comparand instanceof SQHierarchyExpr &&\n                    expr.hierarchy === comparand.hierarchy &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchyLevel = function (expr, comparand) {\n                return comparand instanceof SQHierarchyLevelExpr &&\n                    expr.level === comparand.level &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPropertyVariationSource = function (expr, comparand) {\n                return comparand instanceof SQPropertyVariationSourceExpr &&\n                    expr.name === comparand.name &&\n                    expr.property === comparand.property &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitSelectRef = function (expr, comparand) {\n                return comparand instanceof SQSelectRefExpr &&\n                    expr.expressionName === comparand.expressionName;\n            };\n            SQExprEqualityVisitor.prototype.visitBetween = function (expr, comparand) {\n                return comparand instanceof SQBetweenExpr &&\n                    this.equals(expr.arg, comparand.arg) &&\n                    this.equals(expr.lower, comparand.lower) &&\n                    this.equals(expr.upper, comparand.upper);\n            };\n            SQExprEqualityVisitor.prototype.visitIn = function (expr, comparand) {\n                if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, comparand.args))\n                    return false;\n                var values = expr.values, compareValues = comparand.values;\n                if (values.length !== compareValues.length)\n                    return false;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    if (!this.equalsAll(values[i], compareValues[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.visitEntity = function (expr, comparand) {\n                return comparand instanceof SQEntityExpr &&\n                    expr.schema === comparand.schema &&\n                    expr.entity === comparand.entity &&\n                    this.optionalEqual(expr.variable, comparand.variable);\n            };\n            SQExprEqualityVisitor.prototype.visitAnd = function (expr, comparand) {\n                return comparand instanceof SQAndExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitOr = function (expr, comparand) {\n                return comparand instanceof SQOrExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitCompare = function (expr, comparand) {\n                return comparand instanceof SQCompareExpr &&\n                    expr.comparison === comparand.comparison &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitContains = function (expr, comparand) {\n                return comparand instanceof SQContainsExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitDateSpan = function (expr, comparand) {\n                return comparand instanceof SQDateSpanExpr &&\n                    expr.unit === comparand.unit &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitDateAdd = function (expr, comparand) {\n                return comparand instanceof SQDateAddExpr &&\n                    expr.unit === comparand.unit &&\n                    expr.amount === comparand.amount &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitExists = function (expr, comparand) {\n                return comparand instanceof SQExistsExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNot = function (expr, comparand) {\n                return comparand instanceof SQNotExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNow = function (expr, comparand) {\n                return comparand instanceof SQNowExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitDefaultValue = function (expr, comparand) {\n                return comparand instanceof SQDefaultValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitAnyValue = function (expr, comparand) {\n                return comparand instanceof SQAnyValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitResourcePackageItem = function (expr, comparand) {\n                return comparand instanceof SQResourcePackageItemExpr &&\n                    expr.packageName === comparand.packageName &&\n                    expr.packageType === comparand.packageType &&\n                    expr.itemName === comparand.itemName;\n            };\n            SQExprEqualityVisitor.prototype.visitStartsWith = function (expr, comparand) {\n                return comparand instanceof SQStartsWithExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitConstant = function (expr, comparand) {\n                if (comparand instanceof SQConstantExpr && expr.type === comparand.type)\n                    return expr.type.text && this.ignoreCase ?\n                        StringExtensions.equalIgnoreCase(expr.valueEncoded, comparand.valueEncoded) :\n                        expr.valueEncoded === comparand.valueEncoded;\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitFillRule = function (expr, comparand) {\n                if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\n                    var leftRule = expr.rule, rightRule = comparand.rule;\n                    if (leftRule === rightRule)\n                        return true;\n                    var leftLinearGradient2 = leftRule.linearGradient2, rightLinearGradient2 = rightRule.linearGradient2;\n                    if (leftLinearGradient2 && rightLinearGradient2) {\n                        return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\n                    }\n                    var leftLinearGradient3 = leftRule.linearGradient3, rightLinearGradient3 = rightRule.linearGradient3;\n                    if (leftLinearGradient3 && rightLinearGradient3) {\n                        return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\n                    }\n                }\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient2 = function (left2, right2) {\n                debug.assertValue(left2, 'left2');\n                debug.assertValue(right2, 'right2');\n                return this.equalsFillRuleStop(left2.min, right2.min) &&\n                    this.equalsFillRuleStop(left2.max, right2.max);\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient3 = function (left3, right3) {\n                debug.assertValue(left3, 'left3');\n                debug.assertValue(right3, 'right3');\n                return this.equalsFillRuleStop(left3.min, right3.min) &&\n                    this.equalsFillRuleStop(left3.mid, right3.mid) &&\n                    this.equalsFillRuleStop(left3.max, right3.max);\n            };\n            SQExprEqualityVisitor.prototype.equalsFillRuleStop = function (stop1, stop2) {\n                debug.assertValue(stop1, 'stop1');\n                debug.assertValue(stop2, 'stop2');\n                if (!this.equals(stop1.color, stop2.color))\n                    return false;\n                if (!stop1.value)\n                    return stop1.value === stop2.value;\n                return this.equals(stop1.value, stop2.value);\n            };\n            SQExprEqualityVisitor.prototype.visitArithmetic = function (expr, comparand) {\n                return comparand instanceof SQArithmeticExpr &&\n                    expr.operator === comparand.operator &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitScopedEval = function (expr, comparand) {\n                return comparand instanceof SQScopedEvalExpr &&\n                    this.equals(expr.expression, comparand.expression) &&\n                    this.equalsAll(expr.scope, comparand.scope);\n            };\n            SQExprEqualityVisitor.prototype.optionalEqual = function (x, y) {\n                // Only check equality if both values are specified.\n                if (x && y)\n                    return x === y;\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.equals = function (x, y) {\n                return x.accept(this, y);\n            };\n            SQExprEqualityVisitor.prototype.equalsAll = function (x, y) {\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!this.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.instance = new SQExprEqualityVisitor(/* ignoreCase */ false);\n            SQExprEqualityVisitor.ignoreCaseInstance = new SQExprEqualityVisitor(true);\n            return SQExprEqualityVisitor;\n        }());\n        /** Rewrites a root-level expression. */\n        var SQExprRootRewriter = (function (_super) {\n            __extends(SQExprRootRewriter, _super);\n            function SQExprRootRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRootRewriter.prototype.visitDefault = function (expr) {\n                return expr;\n            };\n            return SQExprRootRewriter;\n        }(data.DefaultSQExprVisitor));\n        var SQExprValidationVisitor = (function (_super) {\n            __extends(SQExprValidationVisitor, _super);\n            function SQExprValidationVisitor(schema, aggrUtils, errors) {\n                debug.assertValue(schema, 'schema');\n                debug.assertValue(aggrUtils, 'aggrUtils');\n                _super.call(this);\n                this.schema = schema;\n                this.aggrUtils = aggrUtils;\n                if (errors)\n                    this.errors = errors;\n            }\n            SQExprValidationVisitor.prototype.visitIn = function (expr) {\n                var inExpr = _super.prototype.visitIn.call(this, expr);\n                var args = inExpr.args;\n                var values = inExpr.values;\n                for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n                    var valueTuple = values_2[_i];\n                    debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\n                    for (var i = 0, len = valueTuple.length; i < len; ++i)\n                        this.validateCompatibleType(args[i], valueTuple[i]);\n                }\n                return inExpr;\n            };\n            SQExprValidationVisitor.prototype.visitCompare = function (expr) {\n                var compareExpr = _super.prototype.visitCompare.call(this, expr);\n                this.validateCompatibleType(compareExpr.left, compareExpr.right);\n                return compareExpr;\n            };\n            SQExprValidationVisitor.prototype.visitColumnRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.column.name);\n                        if (!prop ||\n                            prop.kind !== 0 /* Column */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(3 /* invalidColumnReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitMeasureRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.measure.name);\n                        if (!prop ||\n                            prop.kind !== 1 /* Measure */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(4 /* invalidMeasureReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitAggr = function (expr) {\n                var aggregateExpr = _super.prototype.visitAggr.call(this, expr);\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\n                if (columnRefExpr) {\n                    if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/ null))\n                        this.register(0 /* invalidAggregateFunction */);\n                }\n                return aggregateExpr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchy = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = fieldExpr.hierarchy;\n                    if (fieldExprItem) {\n                        this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\n                    }\n                    else {\n                        this.register(5 /* invalidHierarchyReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var hierarchyLevelFieldExprItem = fieldExpr.hierarchyLevel;\n                    if (hierarchyLevelFieldExprItem) {\n                        this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\n                    }\n                    else if (!fieldExpr.columnHierarchyLevelVariation) {\n                        this.register(6 /* invalidHierarchyLevelReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitPercentile = function (expr) {\n                expr.arg.accept(this);\n                if (_.isEmpty(this.errors)) {\n                    var argMetadata = expr.arg.getMetadata(this.schema);\n                    if (!argMetadata ||\n                        argMetadata.kind !== 0 /* Column */ ||\n                        !(argMetadata.type && (argMetadata.type.integer || argMetadata.type.numeric))) {\n                        this.register(10 /* invalidPercentileArgument */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitEntity = function (expr) {\n                this.validateEntity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitContains = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitStartsWith = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitArithmetic = function (expr) {\n                this.validateArithmeticTypes(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitScopedEval = function (expr) {\n                // No validation necessary\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.validateOperandsAndTypeForStartOrContains = function (left, right) {\n                if (left instanceof SQColumnRefExpr) {\n                    this.visitColumnRef(left);\n                }\n                else if (left instanceof SQHierarchyLevelExpr) {\n                    this.visitHierarchyLevel(left);\n                }\n                else {\n                    this.register(7 /* invalidLeftOperandType */);\n                }\n                if (!(right instanceof SQConstantExpr) || !right.type.text)\n                    this.register(8 /* invalidRightOperandType */);\n                else\n                    this.validateCompatibleType(left, right);\n            };\n            SQExprValidationVisitor.prototype.validateArithmeticTypes = function (left, right) {\n                if (!data.SQExprUtils.supportsArithmetic(left, this.schema))\n                    this.register(7 /* invalidLeftOperandType */);\n                if (!data.SQExprUtils.supportsArithmetic(right, this.schema))\n                    this.register(8 /* invalidRightOperandType */);\n            };\n            SQExprValidationVisitor.prototype.validateCompatibleType = function (left, right) {\n                var leftMetadata = left.getMetadata(this.schema), leftType = leftMetadata && leftMetadata.type, rightMetadata = right.getMetadata(this.schema), rightType = rightMetadata && rightMetadata.type;\n                if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\n                    this.register(9 /* invalidValueType */);\n            };\n            SQExprValidationVisitor.prototype.validateEntity = function (schemaName, entityName) {\n                var schema = this.schema.schema(schemaName);\n                if (schema) {\n                    var entity = schema.entities.withName(entityName);\n                    if (entity)\n                        return entity;\n                    this.register(2 /* invalidEntityReference */);\n                }\n                else {\n                    this.register(1 /* invalidSchemaReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchy = function (schemaName, entityName, hierarchyName) {\n                var entity = this.validateEntity(schemaName, entityName);\n                if (entity) {\n                    var hierarchy = entity.hierarchies.withName(hierarchyName);\n                    if (hierarchy)\n                        return hierarchy;\n                    this.register(5 /* invalidHierarchyReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchyLevel = function (schemaName, entityName, hierarchyName, levelName) {\n                var hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\n                if (hierarchy) {\n                    var hierarchyLevel = hierarchy.levels.withName(levelName);\n                    if (hierarchyLevel)\n                        return hierarchyLevel;\n                    this.register(6 /* invalidHierarchyLevelReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.register = function (error) {\n                if (!this.errors)\n                    this.errors = [];\n                this.errors.push(error);\n            };\n            SQExprValidationVisitor.prototype.isQueryable = function (fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\n                    var hierarchyLevelConceptualProperty = data.SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\n                    return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== 1 /* Error */;\n                }\n                return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, data.FieldExprPattern.getPropertyName(fieldExpr)).queryable !== 1 /* Error */;\n            };\n            return SQExprValidationVisitor;\n        }(data.SQExprRewriter));\n        data.SQExprValidationVisitor = SQExprValidationVisitor;\n        /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\n        var SQExprAggregateInfoVisitor = (function (_super) {\n            __extends(SQExprAggregateInfoVisitor, _super);\n            function SQExprAggregateInfoVisitor() {\n                _super.apply(this, arguments);\n            }\n            SQExprAggregateInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.func;\n            };\n            SQExprAggregateInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprAggregateInfoVisitor.getAggregate = function (expr) {\n                var visitor = new SQExprAggregateInfoVisitor();\n                return expr.accept(visitor);\n            };\n            return SQExprAggregateInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQExprColumnRef expression or undefined.*/\n        var SQExprColumnRefInfoVisitor = (function (_super) {\n            __extends(SQExprColumnRefInfoVisitor, _super);\n            function SQExprColumnRefInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQExprColumnRefInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return expr;\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var ref = expr.level;\n                var hierarchy = (expr.arg);\n                var sourceExpr = hierarchy.accept(this);\n                if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\n                    var propertyVariationSource = hierarchy.arg;\n                    var targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\n                    if (sourceExpr && targetEntity) {\n                        var schemaName = (sourceExpr.source).schema;\n                        var targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\n                        var schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\n                        if (schemaHierarchy) {\n                            for (var _i = 0, _a = schemaHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                if (level.name === ref)\n                                    return new SQColumnRefExpr(targetEntityExpr, level.column.name);\n                            }\n                        }\n                    }\n                }\n                else {\n                    var entityExpr = (hierarchy.arg);\n                    var hierarchyLevelRef = data.SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema, entityExpr.schema, entityExpr.entity, hierarchy.hierarchy, expr.level);\n                    if (hierarchyLevelRef)\n                        return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\n                }\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var propertyName = expr.property;\n                return new SQColumnRefExpr(expr.arg, propertyName);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprColumnRefInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQExprColumnRefInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQEntityExpr expression or undefined.*/\n        var SQEntityExprInfoVisitor = (function (_super) {\n            __extends(SQEntityExprInfoVisitor, _super);\n            function SQEntityExprInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQEntityExprInfoVisitor.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQEntityExprInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return SQEntityExprInfoVisitor.getEntity(expr);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQEntityExprInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitAggr = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitMeasureRef = function (expr) {\n                return expr.source.accept(this);\n            };\n            SQEntityExprInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            SQEntityExprInfoVisitor.getEntity = function (columnRef) {\n                var field = data.SQExprConverter.asFieldPattern(columnRef);\n                var column = field.column;\n                return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\n            };\n            SQEntityExprInfoVisitor.getEntityExpr = function (schema, expr) {\n                var visitor = new SQEntityExprInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQEntityExprInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        var SQExprChangeAggregateRewriter = (function (_super) {\n            __extends(SQExprChangeAggregateRewriter, _super);\n            function SQExprChangeAggregateRewriter(func) {\n                debug.assertValue(func, 'func');\n                _super.call(this);\n                this.func = func;\n            }\n            SQExprChangeAggregateRewriter.prototype.visitAggr = function (expr) {\n                if (expr.func === this.func)\n                    return expr;\n                return new SQAggregationExpr(expr.arg, this.func);\n            };\n            SQExprChangeAggregateRewriter.prototype.visitColumnRef = function (expr) {\n                return new SQAggregationExpr(expr, this.func);\n            };\n            SQExprChangeAggregateRewriter.rewrite = function (expr, func) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(func, 'func');\n                var rewriter = new SQExprChangeAggregateRewriter(func);\n                return expr.accept(rewriter);\n            };\n            return SQExprChangeAggregateRewriter;\n        }(SQExprRootRewriter));\n        var FieldExprChangeAggregateRewriter = (function () {\n            function FieldExprChangeAggregateRewriter(sqExpr, aggregate) {\n                this.sqExpr = sqExpr;\n                this.aggregate = aggregate;\n            }\n            FieldExprChangeAggregateRewriter.rewrite = function (sqExpr, aggregate) {\n                return data.FieldExprPattern.visit(sqExpr, new FieldExprChangeAggregateRewriter(sqExpr, aggregate));\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitPercentOfGrandTotal = function (pattern) {\n                pattern.baseExpr = data.SQExprConverter.asFieldPattern(SQExprChangeAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr), this.aggregate));\n                return SQExprBuilder.fieldExpr({ percentOfGrandTotal: pattern });\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumn = function (column) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumnAggr = function (columnAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitSelectRef = function (selectRef) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitEntity = function (entity) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitEntityAggr = function (entityAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchy = function (hierarchy) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitMeasure = function (measure) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitPercentile = function (percentile) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.defaultRewrite = function () {\n                return SQExprChangeAggregateRewriter.rewrite(this.sqExpr, this.aggregate);\n            };\n            return FieldExprChangeAggregateRewriter;\n        }());\n        var FieldExprRemoveAggregateRewriter = (function () {\n            function FieldExprRemoveAggregateRewriter(sqExpr) {\n                this.sqExpr = sqExpr;\n            }\n            FieldExprRemoveAggregateRewriter.rewrite = function (sqExpr) {\n                return data.FieldExprPattern.visit(sqExpr, new FieldExprRemoveAggregateRewriter(sqExpr));\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitPercentOfGrandTotal = function (pattern) {\n                return FieldExprRemoveAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr));\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitColumn = function (column) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitColumnAggr = function (columnAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitSelectRef = function (selectRef) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitEntity = function (entity) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitEntityAggr = function (entityAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitHierarchy = function (hierarchy) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitMeasure = function (measure) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitPercentile = function (percentile) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.defaultRewrite = function () {\n                return SQExprRemoveAggregateRewriter.rewrite(this.sqExpr);\n            };\n            return FieldExprRemoveAggregateRewriter;\n        }());\n        var SQExprRemoveAggregateRewriter = (function (_super) {\n            __extends(SQExprRemoveAggregateRewriter, _super);\n            function SQExprRemoveAggregateRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveAggregateRewriter.prototype.visitAggr = function (expr) {\n                return expr.arg;\n            };\n            SQExprRemoveAggregateRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveAggregateRewriter.instance);\n            };\n            SQExprRemoveAggregateRewriter.instance = new SQExprRemoveAggregateRewriter();\n            return SQExprRemoveAggregateRewriter;\n        }(SQExprRootRewriter));\n        var SQExprRemoveEntityVariablesRewriter = (function (_super) {\n            __extends(SQExprRemoveEntityVariablesRewriter, _super);\n            function SQExprRemoveEntityVariablesRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveEntityVariablesRewriter.prototype.visitEntity = function (expr) {\n                if (expr.variable)\n                    return SQExprBuilder.entity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprRemoveEntityVariablesRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\n            };\n            SQExprRemoveEntityVariablesRewriter.instance = new SQExprRemoveEntityVariablesRewriter();\n            return SQExprRemoveEntityVariablesRewriter;\n        }(data.SQExprRewriter));\n        var SQExprRemovePercentOfGrandTotalRewriter = (function (_super) {\n            __extends(SQExprRemovePercentOfGrandTotalRewriter, _super);\n            function SQExprRemovePercentOfGrandTotalRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemovePercentOfGrandTotalRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemovePercentOfGrandTotalRewriter.instance);\n            };\n            SQExprRemovePercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr && fieldExpr.percentOfGrandTotal)\n                    expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfGrandTotal.baseExpr);\n                return expr;\n            };\n            SQExprRemovePercentOfGrandTotalRewriter.instance = new SQExprRemovePercentOfGrandTotalRewriter();\n            return SQExprRemovePercentOfGrandTotalRewriter;\n        }(SQExprRootRewriter));\n        var SQExprSetPercentOfGrandTotalRewriter = (function (_super) {\n            __extends(SQExprSetPercentOfGrandTotalRewriter, _super);\n            function SQExprSetPercentOfGrandTotalRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprSetPercentOfGrandTotalRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprSetPercentOfGrandTotalRewriter.instance);\n            };\n            SQExprSetPercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr && !fieldExpr.percentOfGrandTotal)\n                    expr = SQExprBuilder.fieldExpr({ percentOfGrandTotal: { baseExpr: data.SQExprConverter.asFieldPattern(expr) } });\n                return expr;\n            };\n            SQExprSetPercentOfGrandTotalRewriter.instance = new SQExprSetPercentOfGrandTotalRewriter();\n            return SQExprSetPercentOfGrandTotalRewriter;\n        }(SQExprRootRewriter));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var StringExtensions = jsCommon.StringExtensions;\n        var SQExprUtils;\n        (function (SQExprUtils) {\n            function supportsArithmetic(expr, schema) {\n                var metadata = expr.getMetadata(schema), type = metadata && metadata.type;\n                if (!metadata || !type) {\n                    return false;\n                }\n                return type.numeric || type.dateTime || type.duration;\n            }\n            SQExprUtils.supportsArithmetic = supportsArithmetic;\n            function indexOfExpr(items, searchElement) {\n                debug.assertValue(items, 'items');\n                debug.assertValue(searchElement, 'searchElement');\n                for (var i = 0, len = items.length; i < len; i++) {\n                    if (data.SQExpr.equals(items[i], searchElement))\n                        return i;\n                }\n                return -1;\n            }\n            SQExprUtils.indexOfExpr = indexOfExpr;\n            function sequenceEqual(x, y) {\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!data.SQExpr.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            SQExprUtils.sequenceEqual = sequenceEqual;\n            function uniqueName(namedItems, expr, exprDefaultName) {\n                debug.assertValue(namedItems, 'namedItems');\n                // Determine all names\n                var names = {};\n                for (var i = 0, len = namedItems.length; i < len; i++)\n                    names[namedItems[i].name] = true;\n                return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\n            }\n            SQExprUtils.uniqueName = uniqueName;\n            /** Generates a default expression name  */\n            function defaultName(expr, fallback) {\n                if (fallback === void 0) { fallback = 'select'; }\n                if (!expr)\n                    return fallback;\n                return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\n            }\n            SQExprUtils.defaultName = defaultName;\n            /** Gets a value indicating whether the expr is a model measure or an aggregate. */\n            function isMeasure(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsMeasureVisitor.instance);\n            }\n            SQExprUtils.isMeasure = isMeasure;\n            /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\n            function isAnyValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsAnyValueVisitor.instance);\n            }\n            SQExprUtils.isAnyValue = isAnyValue;\n            /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\n            function isDefaultValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsDefaultValueVisitor.instance);\n            }\n            SQExprUtils.isDefaultValue = isDefaultValue;\n            function discourageAggregation(expr, schema) {\n                var capabilities = getSchemaCapabilities(expr, schema);\n                return capabilities && capabilities.discourageQueryAggregateUsage;\n            }\n            SQExprUtils.discourageAggregation = discourageAggregation;\n            function getAggregateBehavior(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var column = getConceptualColumn(expr, schema);\n                if (column)\n                    return column.aggregateBehavior;\n            }\n            SQExprUtils.getAggregateBehavior = getAggregateBehavior;\n            function getSchemaCapabilities(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var field = data.SQExprConverter.asFieldPattern(expr);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var conceptualSchema = schema.schema(fieldExprItem.schema);\n                if (conceptualSchema)\n                    return conceptualSchema.capabilities;\n            }\n            SQExprUtils.getSchemaCapabilities = getSchemaCapabilities;\n            function getKpiMetadata(expr, schema) {\n                var kpiStatusProperty = getKpiStatusProperty(expr, schema);\n                if (kpiStatusProperty)\n                    return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\n                var kpiTrendProperty = getKpiTrendProperty(expr, schema);\n                if (kpiTrendProperty)\n                    return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\n            }\n            SQExprUtils.getKpiMetadata = getKpiMetadata;\n            function getConceptualEntity(entityExpr, schema) {\n                debug.assertValue(entityExpr, 'entityExpr');\n                var conceptualEntity = schema\n                    .schema(entityExpr.schema)\n                    .entities\n                    .withName(entityExpr.entity);\n                return conceptualEntity;\n            }\n            SQExprUtils.getConceptualEntity = getConceptualEntity;\n            function getKpiStatusProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.status === property)\n                    return property;\n            }\n            function getKpiTrendProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.trend === property)\n                    return property;\n            }\n            function getDefaultValue(fieldSQExpr, schema) {\n                var column = getConceptualColumn(fieldSQExpr, schema);\n                if (column)\n                    return column.defaultValue;\n            }\n            SQExprUtils.getDefaultValue = getDefaultValue;\n            function getConceptualColumn(fieldSQExpr, schema) {\n                if (!fieldSQExpr || !schema)\n                    return;\n                var sqField = data.SQExprConverter.asFieldPattern(fieldSQExpr);\n                if (!sqField)\n                    return;\n                var column = sqField.column;\n                if (column) {\n                    if (schema.schema(column.schema) && sqField.column.name) {\n                        var property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\n                        if (property)\n                            return property.column;\n                    }\n                }\n                else {\n                    var hierarchyLevelField = sqField.hierarchyLevel;\n                    if (hierarchyLevelField) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(sqField);\n                        var schemaName = fieldExprItem.schema;\n                        if (schema.schema(schemaName)) {\n                            var hierarchy = schema.schema(schemaName)\n                                .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\n                            if (hierarchy) {\n                                var hierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\n                                if (hierarchyLevel && hierarchyLevel.column)\n                                    return hierarchyLevel.column.column;\n                            }\n                        }\n                    }\n                }\n            }\n            function getDefaultValues(fieldSQExprs, schema) {\n                if (_.isEmpty(fieldSQExprs) || !schema)\n                    return;\n                var result = [];\n                for (var _i = 0, fieldSQExprs_2 = fieldSQExprs; _i < fieldSQExprs_2.length; _i++) {\n                    var sqExpr = fieldSQExprs_2[_i];\n                    var defaultValue = getDefaultValue(sqExpr, schema);\n                    if (defaultValue)\n                        result.push(defaultValue);\n                }\n                return result;\n            }\n            SQExprUtils.getDefaultValues = getDefaultValues;\n            /** Return compare or and expression for key value pairs. */\n            function getDataViewScopeIdentityComparisonExpr(fieldsExpr, values) {\n                debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\n                var compareExprs = [];\n                for (var i = 0; i < fieldsExpr.length; i++) {\n                    compareExprs.push(data.SQExprBuilder.compare(data.QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\n                }\n                if (_.isEmpty(compareExprs))\n                    return;\n                var resultExpr;\n                for (var _i = 0, compareExprs_1 = compareExprs; _i < compareExprs_1.length; _i++) {\n                    var compareExpr = compareExprs_1[_i];\n                    resultExpr = data.SQExprBuilder.and(resultExpr, compareExpr);\n                }\n                return resultExpr;\n            }\n            SQExprUtils.getDataViewScopeIdentityComparisonExpr = getDataViewScopeIdentityComparisonExpr;\n            function getActiveTablesNames(queryDefn) {\n                var tables = [];\n                if (queryDefn) {\n                    var selectedItems = queryDefn.from();\n                    if (selectedItems !== undefined) {\n                        for (var _i = 0, _a = selectedItems.keys(); _i < _a.length; _i++) {\n                            var key = _a[_i];\n                            var entityObj = selectedItems.entity(key);\n                            if (tables.indexOf(entityObj.entity) < 0)\n                                tables.push(entityObj.entity);\n                        }\n                    }\n                }\n                return tables;\n            }\n            SQExprUtils.getActiveTablesNames = getActiveTablesNames;\n            function isRelatedToMany(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 0 /* ZeroOrOne */, 2 /* Many */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 2 /* Many */, 0 /* ZeroOrOne */);\n            }\n            SQExprUtils.isRelatedToMany = isRelatedToMany;\n            function isRelatedToOne(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 2 /* Many */, 0 /* ZeroOrOne */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 0 /* ZeroOrOne */, 2 /* Many */);\n            }\n            SQExprUtils.isRelatedToOne = isRelatedToOne;\n            function isRelated(schema, sourceExpr, targetExpr, sourceMultiplicity, targetMultiplicity) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                if (_.isEmpty(source.navigationProperties))\n                    return false;\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var queue = [];\n                queue.push(source);\n                // walk the relationship path from source.\n                while (!_.isEmpty(queue)) {\n                    var current = queue.shift();\n                    var navProperties = current.navigationProperties;\n                    if (_.isEmpty(navProperties))\n                        continue;\n                    for (var _i = 0, navProperties_1 = navProperties; _i < navProperties_1.length; _i++) {\n                        var navProperty = navProperties_1[_i];\n                        if (!navProperty.isActive)\n                            continue;\n                        if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\n                            if (navProperty.targetEntity === target)\n                                return true;\n                            queue.push(navProperty.targetEntity);\n                        }\n                    }\n                }\n                return false;\n            }\n            function isRelatedOneToOne(schema, sourceExpr, targetExpr) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var sourceNavigations = source.navigationProperties;\n                var targetNavigations = target.navigationProperties;\n                if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\n                    return false;\n                return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\n            }\n            SQExprUtils.isRelatedOneToOne = isRelatedOneToOne;\n            function hasOneToOneNavigation(navigationProperties, targetEntity) {\n                if (_.isEmpty(navigationProperties))\n                    return false;\n                for (var _i = 0, navigationProperties_1 = navigationProperties; _i < navigationProperties_1.length; _i++) {\n                    var navigationProperty = navigationProperties_1[_i];\n                    if (!navigationProperty.isActive)\n                        continue;\n                    if (navigationProperty.targetEntity !== targetEntity)\n                        continue;\n                    if (navigationProperty.sourceMultiplicity === 0 /* ZeroOrOne */ &&\n                        navigationProperty.targetMultiplicity === 0 /* ZeroOrOne */) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\n                and returns a new array. When available, we should use _.unionWith from lodash. */\n            function concatUnique(leftExprs, rightExprs) {\n                debug.assertValue(leftExprs, 'leftExprs');\n                debug.assertValue(rightExprs, 'rightExprs');\n                var concatExprs = ArrayExtensions.copy(leftExprs);\n                for (var _i = 0, rightExprs_1 = rightExprs; _i < rightExprs_1.length; _i++) {\n                    var expr = rightExprs_1[_i];\n                    if (indexOfExpr(concatExprs, expr) === -1) {\n                        concatExprs.push(expr);\n                    }\n                }\n                return concatExprs;\n            }\n            SQExprUtils.concatUnique = concatUnique;\n            var SQExprDefaultNameGenerator = (function (_super) {\n                __extends(SQExprDefaultNameGenerator, _super);\n                function SQExprDefaultNameGenerator() {\n                    _super.apply(this, arguments);\n                }\n                SQExprDefaultNameGenerator.prototype.visitEntity = function (expr) {\n                    return expr.entity;\n                };\n                SQExprDefaultNameGenerator.prototype.visitColumnRef = function (expr) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitMeasureRef = function (expr, fallback) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitAggr = function (expr, fallback) {\n                    return data.QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitPercentile = function (expr, fallback) {\n                    var func = expr.exclusive\n                        ? 'Percentile.Exc('\n                        : 'Percentile.Inc(';\n                    return func + expr.arg.accept(this) + ', ' + expr.k + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitArithmetic = function (expr, fallback) {\n                    return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitConstant = function (expr) {\n                    return 'const';\n                };\n                SQExprDefaultNameGenerator.prototype.visitDefault = function (expr, fallback) {\n                    return fallback || 'expr';\n                };\n                SQExprDefaultNameGenerator.instance = new SQExprDefaultNameGenerator();\n                return SQExprDefaultNameGenerator;\n            }(data.DefaultSQExprVisitorWithArg));\n            var IsMeasureVisitor = (function (_super) {\n                __extends(IsMeasureVisitor, _super);\n                function IsMeasureVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsMeasureVisitor.prototype.visitMeasureRef = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitAggr = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitArithmetic = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsMeasureVisitor.instance = new IsMeasureVisitor();\n                return IsMeasureVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsDefaultValueVisitor = (function (_super) {\n                __extends(IsDefaultValueVisitor, _super);\n                function IsDefaultValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsDefaultValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitDefaultValue = function (expr) {\n                    return true;\n                };\n                IsDefaultValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsDefaultValueVisitor.instance = new IsDefaultValueVisitor();\n                return IsDefaultValueVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsAnyValueVisitor = (function (_super) {\n                __extends(IsAnyValueVisitor, _super);\n                function IsAnyValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsAnyValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnyValue = function (expr) {\n                    return true;\n                };\n                IsAnyValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsAnyValueVisitor.instance = new IsAnyValueVisitor();\n                return IsAnyValueVisitor;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprUtils = data.SQExprUtils || (data.SQExprUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SemanticQueryRewriter = (function () {\n            function SemanticQueryRewriter(exprRewriter) {\n                this.exprRewriter = exprRewriter;\n            }\n            SemanticQueryRewriter.prototype.rewriteFrom = function (fromValue) {\n                var fromContents = {};\n                var originalFrom = fromValue, originalFromKeys = originalFrom.keys();\n                for (var i = 0, len = originalFromKeys.length; i < len; i++) {\n                    var keyName = originalFromKeys[i], originalEntityRef = originalFrom.entity(keyName), originalEntityExpr = data.SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName), updatedEntityExpr = originalEntityExpr.accept(this.exprRewriter);\n                    fromContents[keyName] = {\n                        schema: updatedEntityExpr.schema,\n                        entity: updatedEntityExpr.entity,\n                    };\n                }\n                return new data.SQFrom(fromContents);\n            };\n            SemanticQueryRewriter.prototype.rewriteSelect = function (selectItems, from) {\n                debug.assertValue(selectItems, 'selectItems');\n                debug.assertValue(from, 'from');\n                return this.rewriteNamedSQExpressions(selectItems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteGroupBy = function (groupByitems, from) {\n                debug.assertAnyValue(groupByitems, 'groupByitems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(groupByitems))\n                    return;\n                return this.rewriteNamedSQExpressions(groupByitems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteNamedSQExpressions = function (expressions, from) {\n                var _this = this;\n                debug.assertValue(expressions, 'expressions');\n                return _.map(expressions, function (item) {\n                    return {\n                        name: item.name,\n                        expr: data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(_this.exprRewriter), from)\n                    };\n                });\n            };\n            SemanticQueryRewriter.prototype.rewriteOrderBy = function (orderByItems, from) {\n                debug.assertAnyValue(orderByItems, 'orderByItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(orderByItems))\n                    return;\n                var orderBy = [];\n                for (var i = 0, len = orderByItems.length; i < len; i++) {\n                    var item = orderByItems[i], updatedExpr = data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\n                    orderBy.push({\n                        direction: item.direction,\n                        expr: updatedExpr,\n                    });\n                }\n                return orderBy;\n            };\n            SemanticQueryRewriter.prototype.rewriteWhere = function (whereItems, from) {\n                var _this = this;\n                debug.assertAnyValue(whereItems, 'whereItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(whereItems))\n                    return;\n                var where = [];\n                for (var i = 0, len = whereItems.length; i < len; i++) {\n                    var originalWhere = whereItems[i];\n                    var updatedWhere = {\n                        condition: data.SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\n                    };\n                    if (originalWhere.target)\n                        updatedWhere.target = _.map(originalWhere.target, function (e) { return data.SQExprRewriterWithSourceRenames.rewrite(e.accept(_this.exprRewriter), from); });\n                    where.push(updatedWhere);\n                }\n                return where;\n            };\n            return SemanticQueryRewriter;\n        }());\n        data.SemanticQueryRewriter = SemanticQueryRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /**\n         * Represents a semantic query that is:\n         * 1) Round-trippable with a JSON QueryDefinition.\n         * 2) Immutable\n         * 3) Long-lived and does not have strong references to a conceptual model (only names).\n         */\n        var SemanticQuery = (function () {\n            function SemanticQuery(from, where, orderBy, select, groupBy) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(select, 'select');\n                this.fromValue = from;\n                this.whereItems = where;\n                this.orderByItems = orderBy;\n                this.selectItems = select;\n                this.groupByItems = groupBy;\n            }\n            SemanticQuery.create = function () {\n                if (!SemanticQuery.empty)\n                    SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\n                return SemanticQuery.empty;\n            };\n            SemanticQuery.createWithTrimmedFrom = function (from, where, orderBy, select, groupBy) {\n                var unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\n                // Where\n                if (where) {\n                    for (var i = 0, len = where.length; i < len; i++) {\n                        var filter = where[i];\n                        filter.condition.accept(unreferencedKeyFinder);\n                        var filterTarget = filter.target;\n                        if (filterTarget) {\n                            for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                                if (filterTarget[j])\n                                    filterTarget[j].accept(unreferencedKeyFinder);\n                        }\n                    }\n                }\n                // OrderBy\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++)\n                        orderBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                // Select\n                for (var i = 0, len = select.length; i < len; i++)\n                    select[i].expr.accept(unreferencedKeyFinder);\n                // GroupBy\n                if (groupBy) {\n                    for (var i = 0, len = groupBy.length; i < len; i++)\n                        groupBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                var unreferencedKeys = unreferencedKeyFinder.result();\n                for (var i = 0, len = unreferencedKeys.length; i < len; i++)\n                    from.remove(unreferencedKeys[i]);\n                return new SemanticQuery(from, where, orderBy, select, groupBy);\n            };\n            SemanticQuery.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticQuery.prototype.select = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getSelect();\n                return this.setSelect(values);\n            };\n            SemanticQuery.prototype.getSelect = function () {\n                return SemanticQuery.createNamedExpressionArray(this.selectItems);\n            };\n            SemanticQuery.createNamedExpressionArray = function (items) {\n                return ArrayExtensions.extendWithName(_.map(items, function (s) {\n                    return {\n                        name: s.name,\n                        expr: s.expr,\n                    };\n                }));\n            };\n            SemanticQuery.prototype.setSelect = function (values) {\n                var from = this.fromValue.clone();\n                var selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.rewriteExpressionsWithSourceRenames = function (values, from) {\n                var items = [];\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    items.push({\n                        name: value.name,\n                        expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\n                    });\n                }\n                return items;\n            };\n            /** Removes the given expression from the select. */\n            SemanticQuery.prototype.removeSelect = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var originalItems = this.selectItems, selectItems = [];\n                for (var i = 0, len = originalItems.length; i < len; i++) {\n                    var originalExpr = originalItems[i];\n                    if (data.SQExpr.equals(originalExpr.expr, expr))\n                        continue;\n                    selectItems.push(originalExpr);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            /** Removes the given expression from order by. */\n            SemanticQuery.prototype.removeOrderBy = function (expr) {\n                var sorts = this.orderBy();\n                for (var i = sorts.length - 1; i >= 0; i--) {\n                    if (data.SQExpr.equals(sorts[i].expr, expr))\n                        sorts.splice(i, 1);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.selectNameOf = function (expr) {\n                var index = data.SQExprUtils.indexOfExpr(_.map(this.selectItems, function (s) { return s.expr; }), expr);\n                if (index >= 0)\n                    return this.selectItems[index].name;\n            };\n            SemanticQuery.prototype.setSelectAt = function (index, expr) {\n                debug.assertValue(expr, 'expr');\n                if (index >= this.selectItems.length)\n                    return;\n                var select = this.select(), from = this.fromValue.clone(), originalName = select[index].name;\n                select[index] = {\n                    name: originalName,\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\n            };\n            /** Adds a the expression to the select clause. */\n            SemanticQuery.prototype.addSelect = function (expr, exprName) {\n                debug.assertValue(expr, 'expr');\n                var selectItems = this.select(), from = this.fromValue.clone();\n                selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.createNamedExpr = function (currentNames, from, expr, exprName) {\n                return {\n                    name: data.SQExprUtils.uniqueName(currentNames, expr, exprName),\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n            };\n            SemanticQuery.prototype.groupBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getGroupBy();\n                return this.setGroupBy(values);\n            };\n            SemanticQuery.prototype.getGroupBy = function () {\n                return SemanticQuery.createNamedExpressionArray(this.groupByItems);\n            };\n            SemanticQuery.prototype.setGroupBy = function (values) {\n                var from = this.fromValue.clone();\n                var groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.addGroupBy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var groupByItems = this.groupBy(), from = this.fromValue.clone();\n                groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.orderBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getOrderBy();\n                return this.setOrderBy(values);\n            };\n            SemanticQuery.prototype.getOrderBy = function () {\n                var result = [];\n                var orderBy = this.orderByItems;\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++) {\n                        var clause = orderBy[i];\n                        result.push({\n                            expr: clause.expr,\n                            direction: clause.direction,\n                        });\n                    }\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setOrderBy = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedOrderBy = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var clause = values[i];\n                    updatedOrderBy.push({\n                        expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\n                        direction: clause.direction,\n                    });\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.where = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getWhere();\n                return this.setWhere(values);\n            };\n            SemanticQuery.prototype.getWhere = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                if (whereItems) {\n                    for (var i = 0, len = whereItems.length; i < len; i++)\n                        result.push(whereItems[i]);\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setWhere = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedWhere = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var filter = values[i];\n                    var updatedFilter = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\n                    };\n                    var filterTarget = filter.target;\n                    if (filterTarget) {\n                        updatedFilter.target = [];\n                        for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                            if (filterTarget[j]) {\n                                var updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\n                                updatedFilter.target.push(updatedTarget);\n                            }\n                    }\n                    updatedWhere.push(updatedFilter);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.addWhere = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedWhere = this.where(), incomingWhere = filter.where(), from = this.fromValue.clone();\n                for (var i = 0, len = incomingWhere.length; i < len; i++) {\n                    var clause = incomingWhere[i];\n                    var updatedClause = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\n                    };\n                    if (clause.target)\n                        updatedClause.target = _.map(clause.target, function (t) { return SQExprRewriterWithSourceRenames.rewrite(t, from); });\n                    updatedWhere.push(updatedClause);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                var orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\n                var select = rewriter.rewriteSelect(this.selectItems, from);\n                var groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\n                return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\n            };\n            return SemanticQuery;\n        }());\n        data.SemanticQuery = SemanticQuery;\n        /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\n        var SemanticFilter = (function () {\n            function SemanticFilter(from, where) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                this.fromValue = from;\n                this.whereItems = where;\n            }\n            SemanticFilter.fromSQExpr = function (contract) {\n                debug.assertValue(contract, 'contract');\n                var from = new SQFrom();\n                var rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\n                // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\n                //         Thus not setting a target here.\n                var where = [{\n                        condition: rewrittenContract\n                    }];\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.getDefaultValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.defaultValue());\n            };\n            SemanticFilter.getAnyValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.anyValue());\n            };\n            SemanticFilter.getDataViewScopeIdentityComparisonFilters = function (fieldSQExprs, value) {\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assertValue(value, 'value');\n                if (fieldSQExprs instanceof Array) {\n                    var values = Array.apply(null, Array(fieldSQExprs.length)).map(function () { return value; });\n                    return SemanticFilter.fromSQExpr(data.SQExprUtils.getDataViewScopeIdentityComparisonExpr(fieldSQExprs, values));\n                }\n                return SemanticFilter.fromSQExpr(data.SQExprBuilder.equal(fieldSQExprs, value));\n            };\n            SemanticFilter.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticFilter.prototype.conditions = function () {\n                var expressions = [];\n                var where = this.whereItems;\n                for (var i = 0, len = where.length; i < len; i++) {\n                    var filter = where[i];\n                    expressions.push(filter.condition);\n                }\n                return expressions;\n            };\n            SemanticFilter.prototype.where = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                for (var i = 0, len = whereItems.length; i < len; i++)\n                    result.push(whereItems[i]);\n                return result;\n            };\n            SemanticFilter.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new data.SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.rewrite(validator);\n                return validator.errors;\n            };\n            /** Merges a list of SemanticFilters into one. */\n            SemanticFilter.merge = function (filters) {\n                if (_.isEmpty(filters))\n                    return null;\n                if (filters.length === 1)\n                    return filters[0];\n                var firstFilter = filters[0];\n                var from = firstFilter.from(), where = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\n                for (var i = 1, len = filters.length; i < len; i++)\n                    SemanticFilter.applyFilter(filters[i], from, where);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.isDefaultFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isDefaultValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isAnyFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isAnyValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isSameFilter = function (leftFilter, rightFilter) {\n                if (jsCommon.JsonComparer.equals(leftFilter, rightFilter)) {\n                    return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\n                        || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\n                }\n                return false;\n            };\n            SemanticFilter.applyFilter = function (filter, from, where) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                // Where\n                var filterWhereItems = filter.whereItems;\n                for (var i = 0; i < filterWhereItems.length; i++) {\n                    var filterWhereItem = filterWhereItems[i];\n                    var updatedWhereItem = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\n                    };\n                    if (filterWhereItem.target)\n                        updatedWhereItem.target = _.map(filterWhereItem.target, function (e) { return SQExprRewriterWithSourceRenames.rewrite(e, from); });\n                    where.push(updatedWhereItem);\n                }\n            };\n            return SemanticFilter;\n        }());\n        data.SemanticFilter = SemanticFilter;\n        /** Represents a SemanticQuery/SemanticFilter from clause. */\n        var SQFrom = (function () {\n            function SQFrom(items) {\n                this.items = items || {};\n            }\n            SQFrom.prototype.keys = function () {\n                return Object.keys(this.items);\n            };\n            SQFrom.prototype.entity = function (key) {\n                return this.items[key];\n            };\n            SQFrom.prototype.ensureEntity = function (entity, desiredVariableName) {\n                debug.assertValue(entity, 'entity');\n                // 1) Reuse a reference to the entity among the already referenced\n                var keys = this.keys();\n                for (var i_1 = 0, len = keys.length; i_1 < len; i_1++) {\n                    var key = keys[i_1], item = this.items[key];\n                    if (item && entity.entity === item.entity && entity.schema === item.schema)\n                        return { name: key };\n                }\n                // 2) Add a reference to the entity\n                var candidateName = desiredVariableName || this.candidateName(entity.entity), uniqueName = candidateName, i = 2;\n                while (this.items[uniqueName]) {\n                    uniqueName = candidateName + i++;\n                }\n                this.items[uniqueName] = entity;\n                return { name: uniqueName, new: true };\n            };\n            SQFrom.prototype.remove = function (key) {\n                delete this.items[key];\n            };\n            /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\n            SQFrom.prototype.candidateName = function (ref) {\n                debug.assertValue(ref, 'ref');\n                var idx = ref.lastIndexOf('.');\n                if (idx >= 0 && (idx !== ref.length - 1))\n                    ref = ref.substr(idx + 1);\n                return ref.substring(0, 1).toLowerCase();\n            };\n            SQFrom.prototype.clone = function () {\n                // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\n                var cloned = new SQFrom();\n                // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\n                $.extend(cloned.items, this.items);\n                return cloned;\n            };\n            return SQFrom;\n        }());\n        data.SQFrom = SQFrom;\n        var SQExprRewriterWithSourceRenames = (function (_super) {\n            __extends(SQExprRewriterWithSourceRenames, _super);\n            function SQExprRewriterWithSourceRenames(renames) {\n                debug.assertValue(renames, 'renames');\n                _super.call(this);\n                this.renames = renames;\n            }\n            SQExprRewriterWithSourceRenames.prototype.visitEntity = function (expr) {\n                var updatedName = this.renames[expr.entity];\n                if (updatedName)\n                    return new data.SQEntityExpr(expr.schema, expr.entity, updatedName);\n                return _super.prototype.visitEntity.call(this, expr);\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteFilter = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedTargets = undefined;\n                if (filter.target)\n                    updatedTargets = this.rewriteArray(filter.target);\n                var updatedCondition = filter.condition.accept(this);\n                if (filter.condition === updatedCondition && filter.target === updatedTargets)\n                    return filter;\n                var updatedFilter = {\n                    condition: updatedCondition,\n                };\n                if (updatedTargets)\n                    updatedFilter.target = updatedTargets;\n                return updatedFilter;\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteArray = function (exprs) {\n                debug.assertValue(exprs, 'exprs');\n                var updatedExprs;\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i], rewrittenExpr = expr.accept(this);\n                    if (expr !== rewrittenExpr && !updatedExprs)\n                        updatedExprs = ArrayExtensions.take(exprs, i);\n                    if (updatedExprs)\n                        updatedExprs.push(rewrittenExpr);\n                }\n                return updatedExprs || exprs;\n            };\n            SQExprRewriterWithSourceRenames.rewrite = function (expr, from) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(from, 'from');\n                var renames = QuerySourceRenameDetector.run(expr, from);\n                var rewriter = new SQExprRewriterWithSourceRenames(renames);\n                return expr.accept(rewriter);\n            };\n            return SQExprRewriterWithSourceRenames;\n        }(data.SQExprRewriter));\n        data.SQExprRewriterWithSourceRenames = SQExprRewriterWithSourceRenames;\n        /** Responsible for updating a QueryFrom based on SQExpr references. */\n        var QuerySourceRenameDetector = (function (_super) {\n            __extends(QuerySourceRenameDetector, _super);\n            function QuerySourceRenameDetector(from) {\n                debug.assertValue(from, 'from');\n                _super.call(this);\n                this.from = from;\n                this.renames = {};\n            }\n            QuerySourceRenameDetector.run = function (expr, from) {\n                var detector = new QuerySourceRenameDetector(from);\n                expr.accept(detector);\n                return detector.renames;\n            };\n            QuerySourceRenameDetector.prototype.visitEntity = function (expr) {\n                // TODO: Renames must take the schema into account, not just entity set name.\n                var existingEntity = this.from.entity(expr.variable);\n                if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\n                    return;\n                var actualEntity = this.from.ensureEntity({\n                    schema: expr.schema,\n                    entity: expr.entity,\n                }, expr.variable);\n                this.renames[expr.entity] = actualEntity.name;\n            };\n            return QuerySourceRenameDetector;\n        }(data.DefaultSQExprVisitorWithTraversal));\n        /** Visitor for finding unreferenced sources. */\n        var UnreferencedKeyFinder = (function (_super) {\n            __extends(UnreferencedKeyFinder, _super);\n            function UnreferencedKeyFinder(keys) {\n                debug.assertValue(keys, 'keys');\n                _super.call(this);\n                this.keys = keys;\n            }\n            UnreferencedKeyFinder.prototype.visitEntity = function (expr) {\n                var index = this.keys.indexOf(expr.variable);\n                if (index >= 0)\n                    this.keys.splice(index, 1);\n            };\n            UnreferencedKeyFinder.prototype.result = function () {\n                return this.keys;\n            };\n            return UnreferencedKeyFinder;\n        }(data.DefaultSQExprVisitorWithTraversal));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewTransform = powerbi.data.DataViewTransform;\n        var SQExprBuilder = powerbi.data.SQExprBuilder;\n        function createCategoricalDataViewBuilder() {\n            return new CategoricalDataViewBuilder();\n        }\n        data.createCategoricalDataViewBuilder = createCategoricalDataViewBuilder;\n        var CategoricalDataViewBuilder = (function () {\n            function CategoricalDataViewBuilder() {\n                this.categories = [];\n                this.staticMeasureColumns = [];\n                this.dynamicMeasureColumns = [];\n                this.columnIndex = 0;\n            }\n            CategoricalDataViewBuilder.prototype.withCategory = function (options) {\n                var categoryValues = options.values, identityFrom = options.identityFrom, type = options.source.type;\n                var categoryColumn = {\n                    source: options.source,\n                    identityFields: options.identityFrom.fields,\n                    identity: options.identityFrom.identities || [],\n                    values: categoryValues,\n                };\n                if (!options.identityFrom.identities) {\n                    for (var categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\n                        categoryColumn.identity.push(getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\n                    }\n                }\n                if (!this.categories)\n                    this.categories = [];\n                this.categories.push(categoryColumn);\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withCategories = function (categories) {\n                if (_.isEmpty(this.categories))\n                    this.categories = categories;\n                else\n                    Array.prototype.push.apply(this.categories, categories);\n                return this;\n            };\n            /**\n             * Adds static series columns.\n             *\n             * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in\n             * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\n             */\n            CategoricalDataViewBuilder.prototype.withValues = function (options) {\n                debug.assertValue(options, 'options');\n                var columns = options.columns;\n                debug.assertValue(columns, 'columns');\n                for (var _i = 0, columns_8 = columns; _i < columns_8.length; _i++) {\n                    var column = columns_8[_i];\n                    this.staticMeasureColumns.push(column.source);\n                }\n                this.staticSeriesValues = columns;\n                return this;\n            };\n            /**\n             * Adds dynamic series columns.\n             *\n             * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in\n             * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\n             */\n            CategoricalDataViewBuilder.prototype.withGroupedValues = function (options) {\n                debug.assertValue(options, 'options');\n                var groupColumn = options.groupColumn;\n                debug.assertValue(groupColumn, 'groupColumn');\n                this.dynamicSeriesMetadata = {\n                    column: groupColumn.source,\n                    identityFrom: groupColumn.identityFrom,\n                    values: groupColumn.values,\n                };\n                var valueColumns = options.valueColumns;\n                for (var _i = 0, valueColumns_1 = valueColumns; _i < valueColumns_1.length; _i++) {\n                    var valueColumn = valueColumns_1[_i];\n                    this.dynamicMeasureColumns.push(valueColumn.source);\n                }\n                this.dynamicSeriesValues = options.data;\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.fillData = function (dataViewValues) {\n                var categoryColumn = _.first(this.categories);\n                var categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 1;\n                if (this.hasDynamicSeries) {\n                    for (var seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\n                        var seriesMeasures = this.dynamicSeriesValues[seriesIndex];\n                        debug.assert(seriesMeasures.length === this.dynamicMeasureColumns.length, 'seriesMeasures.length === this.dynamicMeasureColumns.length');\n                        for (var measureIndex = 0, measuresLen = this.dynamicMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                            var groupIndex = seriesIndex * measuresLen + measureIndex;\n                            applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\n                        }\n                    }\n                }\n                if (this.hasStaticSeries) {\n                    // Note: when the target categorical has both dynamic and static series, append static measures at the end of the values array.\n                    var staticColumnsStartingIndex = this.hasDynamicSeries ? (this.dynamicSeriesValues.length * this.dynamicMeasureColumns.length) : 0;\n                    for (var measureIndex = 0, measuresLen = this.staticMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                        applySeriesData(dataViewValues[staticColumnsStartingIndex + measureIndex], this.staticSeriesValues[measureIndex], categoryLength);\n                    }\n                }\n            };\n            /**\n             * Returns the DataView with metadata and DataViewCategorical.\n             * Returns undefined if the combination of parameters is illegal, such as having both dynamic series and static series when building a visual DataView.\n             */\n            CategoricalDataViewBuilder.prototype.build = function () {\n                var metadataColumns = [];\n                var categorical = {};\n                var categoryMetadata = this.categories;\n                var dynamicSeriesMetadata = this.dynamicSeriesMetadata;\n                // --- Build metadata columns and value groups ---\n                for (var _i = 0, categoryMetadata_1 = categoryMetadata; _i < categoryMetadata_1.length; _i++) {\n                    var columnMetadata = categoryMetadata_1[_i];\n                    pushIfNotExists(metadataColumns, columnMetadata.source);\n                }\n                if (this.hasDynamicSeries) {\n                    // Dynamic series, or Dyanmic & Static series.\n                    pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\n                    categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\n                    // For each series value we will make one column per measure\n                    var seriesValues = dynamicSeriesMetadata.values;\n                    for (var seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\n                        var seriesValue = seriesValues[seriesIndex];\n                        var seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\n                        for (var _a = 0, _b = this.dynamicMeasureColumns; _a < _b.length; _a++) {\n                            var measure = _b[_a];\n                            var column = _.clone(measure);\n                            column.groupName = seriesValue;\n                            pushIfNotExists(metadataColumns, column);\n                            categorical.values.push({\n                                source: column,\n                                values: [],\n                                identity: seriesIdentity,\n                            });\n                        }\n                    }\n                    if (this.hasStaticSeries) {\n                        // IMPORTANT: In the Dyanmic & Static series case, the groups array shall not include any static group. This is to match the behavior of dsrReader.\n                        // Get the current return value of grouped() before adding static measure columns, an use that as the return value of this categorical.\n                        // Otherwise, the default behavior of DataViewValueColumns.grouped() from DataViewTransform.createValueColumns() is to create series groups from all measure columns.\n                        var dynamicSeriesGroups_1 = categorical.values.grouped();\n                        categorical.values.grouped = function () { return dynamicSeriesGroups_1; };\n                        this.appendStaticMeasureColumns(metadataColumns, categorical.values);\n                    }\n                }\n                else {\n                    // Static series only / no series\n                    categorical.values = DataViewTransform.createValueColumns();\n                    this.appendStaticMeasureColumns(metadataColumns, categorical.values);\n                }\n                var categories = this.categories;\n                if (!_.isEmpty(categories))\n                    categorical.categories = categories;\n                // --- Fill in data point values ---\n                this.fillData(categorical.values);\n                var dataView = {\n                    metadata: {\n                        columns: metadataColumns,\n                    },\n                    categorical: categorical,\n                };\n                if (this.isLegalDataView(dataView)) {\n                    return dataView;\n                }\n            };\n            CategoricalDataViewBuilder.prototype.appendStaticMeasureColumns = function (metadataColumns, valueColumns) {\n                debug.assertValue(metadataColumns, 'metadataColumns');\n                debug.assertValue(valueColumns, 'valueColumns');\n                if (!_.isEmpty(this.staticMeasureColumns)) {\n                    for (var _i = 0, _a = this.staticMeasureColumns; _i < _a.length; _i++) {\n                        var column = _a[_i];\n                        pushIfNotExists(metadataColumns, column);\n                        valueColumns.push({\n                            source: column,\n                            values: [],\n                        });\n                    }\n                }\n            };\n            CategoricalDataViewBuilder.prototype.isLegalDataView = function (dataView) {\n                if (this.hasDynamicSeries && this.hasStaticSeries && CategoricalDataViewBuilder.isVisualDataView(dataView.metadata.columns)) {\n                    // It is illegal to have both dynamic series and static series in a visual DataViewCategorical,\n                    // because the DataViewValueColumns interface today cannot express that 100% (see its 'source' property and return value of its 'grouped()' function).\n                    return false;\n                }\n                return true;\n            };\n            /**\n             * This function infers that if any metdata column has 'queryName',\n             * then the user of this builder is building a visual DataView (as opposed to query DataView).\n             *\n             * @param metadataColumns The complete collection of metadata columns in the categorical.\n             */\n            CategoricalDataViewBuilder.isVisualDataView = function (metadataColumns) {\n                return !_.isEmpty(metadataColumns) &&\n                    _.any(metadataColumns, function (metadataColumn) { return !!metadataColumn.queryName; });\n            };\n            Object.defineProperty(CategoricalDataViewBuilder.prototype, \"hasDynamicSeries\", {\n                get: function () {\n                    return !!this.dynamicSeriesMetadata; // In Map visual scenarios, you can have dynamic series without measure columns\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(CategoricalDataViewBuilder.prototype, \"hasStaticSeries\", {\n                get: function () {\n                    return !!this.staticSeriesValues;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return CategoricalDataViewBuilder;\n        }());\n        function getScopeIdentity(source, index, value, valueType) {\n            var identities = source.identities;\n            if (identities) {\n                return identities[index];\n            }\n            debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\n            return data.createDataViewScopeIdentity(SQExprBuilder.equal(source.fields[0], SQExprBuilder.typedConstant(value, valueType)));\n        }\n        function pushIfNotExists(items, itemToAdd) {\n            if (_.contains(items, itemToAdd))\n                return;\n            items.push(itemToAdd);\n        }\n        function applySeriesData(target, source, categoryLength) {\n            debug.assertValue(target, 'target');\n            debug.assertValue(source, 'source');\n            debug.assertValue(categoryLength, 'categoryLength');\n            var values = source.values;\n            debug.assert(categoryLength === values.length, 'categoryLength === values.length');\n            target.values = values;\n            var highlights = source.highlights;\n            if (highlights) {\n                debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\n                target.highlights = highlights;\n            }\n            var aggregates;\n            if (source.minLocal !== undefined) {\n                if (!aggregates)\n                    aggregates = {};\n                aggregates.minLocal = source.minLocal;\n            }\n            if (source.maxLocal !== undefined) {\n                if (!aggregates)\n                    aggregates = {};\n                aggregates.maxLocal = source.maxLocal;\n            }\n            if (aggregates) {\n                target.source.aggregates = aggregates;\n                _.extend(target, aggregates);\n            }\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExpr = powerbi.data.SQExpr;\n        function createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n            return new StaticEvalContext(colorAllocatorCache || data.createColorAllocatorCache(), dataView || { metadata: { columns: [] } }, selectTransforms);\n        }\n        data.createStaticEvalContext = createStaticEvalContext;\n        /**\n         * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\n         * are supported.\n         */\n        var StaticEvalContext = (function () {\n            function StaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorCache = colorAllocatorCache;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            StaticEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorCache.get(expr);\n            };\n            StaticEvalContext.prototype.getExprValue = function (expr) {\n                var dataView = this.dataView, selectTransforms = this.selectTransforms;\n                if (dataView && dataView.table && selectTransforms)\n                    return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\n            };\n            StaticEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            return StaticEvalContext;\n        }());\n        function getExprValueFromTable(expr, selectTransforms, table, rowIdx) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            debug.assertValue(table, 'table');\n            debug.assertValue(rowIdx, 'rowIdx');\n            var rows = table.rows;\n            if (_.isEmpty(rows) || rows.length <= rowIdx)\n                return;\n            var targetExpr = getTargetExpr(expr, selectTransforms);\n            var cols = table.columns;\n            for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                var selectTransform = selectTransforms[selectIdx];\n                if (!SQExpr.equals(selectTransform.expr, targetExpr) || !selectTransform.queryName)\n                    continue;\n                for (var colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\n                    if (selectIdx !== cols[colIdx].index)\n                        continue;\n                    return rows[rowIdx][colIdx];\n                }\n            }\n        }\n        data.getExprValueFromTable = getExprValueFromTable;\n        function getTargetExpr(expr, selectTransforms) {\n            if (SQExpr.isSelectRef(expr)) {\n                for (var _i = 0, selectTransforms_2 = selectTransforms; _i < selectTransforms_2.length; _i++) {\n                    var selectTransform = selectTransforms_2[_i];\n                    if (selectTransform.queryName === expr.expressionName) {\n                        return selectTransform.expr;\n                    }\n                }\n            }\n            return expr;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createMatrixEvalContext(colorAllocatorProvider, dataViewMatrix) {\n            // NOTE: Matrix context-sensitive evaluation is not yet implemented.\n            return data.createStaticEvalContext(colorAllocatorProvider);\n        }\n        data.createMatrixEvalContext = createMatrixEvalContext;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi_1) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var Formatting = jsCommon.Formatting;\n    var RegExpExtensions = jsCommon.RegExpExtensions;\n    /** Formatting Encoder */\n    var FormattingEncoder;\n    (function (FormattingEncoder) {\n        function preserveEscaped(format, specialChars) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = \"\\\\\" + specialChars[i];\n                var newText = String.fromCharCode(0xE000 + i);\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveEscaped = preserveEscaped;\n        function restoreEscaped(format, specialChars) {\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = String.fromCharCode(0xE000 + i);\n                var newText = specialChars[i];\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\n        }\n        FormattingEncoder.restoreEscaped = restoreEscaped;\n        function preserveLiterals(format, literals) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            for (var i = 0;; i++) {\n                var fromIndex = format.indexOf(\"'\");\n                if (fromIndex < 0) {\n                    break;\n                }\n                var toIndex = format.indexOf(\"'\", fromIndex + 1);\n                if (toIndex < 0) {\n                    break;\n                }\n                var literal = format.substring(fromIndex, toIndex + 1);\n                literals.push(literal.substring(1, toIndex - fromIndex));\n                var token = String.fromCharCode(0xE100 + i);\n                format = format.replace(literal, token);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveLiterals = preserveLiterals;\n        function restoreLiterals(format, literals) {\n            var count = literals.length;\n            for (var i = 0; i < count; i++) {\n                var token = String.fromCharCode(0xE100 + i);\n                var literal = literals[i];\n                format = format.replace(token, literal);\n            }\n            return format;\n        }\n        FormattingEncoder.restoreLiterals = restoreLiterals;\n    })(FormattingEncoder || (FormattingEncoder = {}));\n    var IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\n    var ZeroPlaceholder = '0';\n    var DigitPlaceholder = '#';\n    var ExponentialFormatChar = 'E';\n    var NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\n    var NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\n    /** Formatting Service */\n    var FormattingService = (function () {\n        function FormattingService() {\n        }\n        FormattingService.prototype.formatValue = function (value, format, culture) {\n            // Handle special cases\n            if (value === undefined || value === null) {\n                return '';\n            }\n            var gculture = this.getCulture(culture);\n            if (DateTimeFormat.canFormat(value)) {\n                // Dates\n                return DateTimeFormat.format(value, format, gculture);\n            }\n            else if (NumberFormat.canFormat(value)) {\n                // Numbers\n                return NumberFormat.format(value, format, gculture);\n            }\n            else {\n                // Other data types - return as string\n                return value.toString();\n            }\n        };\n        FormattingService.prototype.format = function (formatWithIndexedTokens, args, culture) {\n            var _this = this;\n            if (!formatWithIndexedTokens) {\n                return \"\";\n            }\n            var result = formatWithIndexedTokens.replace(IndexedTokensRegex, function (match, left, right, argToken) {\n                if (left) {\n                    return \"{\";\n                }\n                else if (right) {\n                    return \"}\";\n                }\n                else {\n                    var parts = argToken.split(\":\");\n                    var argIndex = parseInt(parts[0], 10);\n                    var argFormat = parts[1];\n                    return _this.formatValue(args[argIndex], argFormat, culture);\n                }\n            });\n            return result;\n        };\n        FormattingService.prototype.isStandardNumberFormat = function (format) {\n            return NumberFormat.isStandardFormat(format);\n        };\n        FormattingService.prototype.formatNumberWithCustomOverride = function (value, format, nonScientificOverrideFormat, culture) {\n            var gculture = this.getCulture(culture);\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\n        };\n        FormattingService.prototype.dateFormatString = function (unit) {\n            if (!this._dateTimeScaleFormatInfo)\n                this.initialize();\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\n        };\n        /**\n         * Sets the current localization culture\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         */\n        FormattingService.prototype.setCurrentCulture = function (cultureSelector) {\n            if (this._currentCultureSelector !== cultureSelector) {\n                this._currentCulture = this.getCulture(cultureSelector);\n                this._currentCultureSelector = cultureSelector;\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\n            }\n        };\n        /**\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         * Exposing this function for testability of unsupported cultures\n         */\n        FormattingService.prototype.getCulture = function (cultureSelector) {\n            if (cultureSelector == null) {\n                if (this._currentCulture == null) {\n                    this.initialize();\n                }\n                return this._currentCulture;\n            }\n            else {\n                var culture = Globalize.findClosestCulture(cultureSelector);\n                if (!culture)\n                    culture = Globalize.culture(\"en-US\");\n                return culture;\n            }\n        };\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\n        FormattingService.prototype.initialize = function () {\n            var cultureName = this.getCurrentCulture();\n            this.setCurrentCulture(cultureName);\n            var calendarName = this.getUrlParam(\"calendar\");\n            if (calendarName) {\n                var culture = this._currentCulture;\n                var c = culture.calendars[calendarName];\n                if (c) {\n                    culture.calendar = c;\n                }\n            }\n        };\n        /**\n         *  Exposing this function for testability\n         */\n        FormattingService.prototype.getCurrentCulture = function () {\n            var urlParam = this.getUrlParam(\"language\");\n            if (urlParam) {\n                return urlParam;\n            }\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\n                // Get cultureInfo set in powerbi\n                return powerbi.common.cultureInfo;\n            }\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\n        };\n        /**\n         *  Exposing this function for testability\n         *  @param name: queryString name\n         */\n        FormattingService.prototype.getUrlParam = function (name) {\n            var param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\n            return param ? param[1] : undefined;\n        };\n        return FormattingService;\n    }());\n    /**\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for dates.\n     */\n    var DateTimeFormat;\n    (function (DateTimeFormat) {\n        var _currentCachedFormat;\n        var _currentCachedProcessedFormat;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = value instanceof Date;\n            return result;\n        }\n        DateTimeFormat.canFormat = canFormat;\n        /** Formats the date using provided format and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            var isStandard = format.length === 1;\n            try {\n                if (isStandard) {\n                    return formatDateStandard(value, format, culture);\n                }\n                else {\n                    return formatDateCustom(value, format, culture);\n                }\n            }\n            catch (e) {\n                return formatDateStandard(value, \"G\", culture);\n            }\n        }\n        DateTimeFormat.format = format;\n        /** Formats the date using standard format expression */\n        function formatDateStandard(value, format, culture) {\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\n            var patterns = culture.calendar.patterns;\n            // Extend supported set of patterns\n            ensurePatterns(culture.calendar);\n            // Handle extended set of formats\n            var output = Formatting.findDateFormat(value, format, culture.name);\n            if (output.format.length === 1)\n                format = patterns[output.format];\n            else\n                format = output.format;\n            //need to revisit when globalization is enabled\n            culture = Globalize.culture(\"en-US\");\n            return Globalize.format(output.value, format, culture);\n        }\n        /** Formats the date using custom format expression */\n        function formatDateCustom(value, format, culture) {\n            var result;\n            var literals = [];\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            format = FormattingEncoder.preserveLiterals(format, literals);\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            if (format.indexOf(\"F\") > -1) {\n                // F is not supported so we need to replace the F with f based on the milliseconds\n                // Replace all sequences of F longer than 3 with \"FFF\"\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\n                // Based on milliseconds update the format to use fff\n                var milliseconds = value.getMilliseconds();\n                if (milliseconds % 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\n                if ((milliseconds % 100) / 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\n                if ((milliseconds % 1000) / 100 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\n                }\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\n                if (format === \"\" || format === \"%\")\n                    return \"\";\n            }\n            format = processCustomDateTimeFormat(format);\n            result = Globalize.format(value, format, culture);\n            result = localize(result, culture.calendar);\n            result = FormattingEncoder.restoreLiterals(result, literals);\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            return result;\n        }\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\n        function processCustomDateTimeFormat(format) {\n            if (format === _currentCachedFormat) {\n                return _currentCachedProcessedFormat;\n            }\n            _currentCachedFormat = format;\n            format = Formatting.fixDateTimeFormat(format);\n            _currentCachedProcessedFormat = format;\n            return format;\n        }\n        /** Localizes the time separator symbol */\n        function localize(value, dictionary) {\n            var timeSeparator = dictionary[\":\"];\n            if (timeSeparator === \":\") {\n                return value;\n            }\n            var result = \"\";\n            var count = value.length;\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \":\":\n                        result += timeSeparator;\n                        break;\n                    default:\n                        result += char;\n                        break;\n                }\n            }\n            return result;\n        }\n        function ensurePatterns(calendar) {\n            var patterns = calendar.patterns;\n            if (patterns[\"g\"] === undefined) {\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, short time\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, long time\n            }\n        }\n    })(DateTimeFormat || (DateTimeFormat = {}));\n    /**\n     * NumberFormat module contains the static methods for formatting the numbers.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for numeric types including custom formats.\n     */\n    var NumberFormat;\n    (function (NumberFormat) {\n        var NonScientificFormatRegex = /^\\{.+\\}.*/;\n        var NumericalPlaceHolderRegex = /\\{.+\\}/;\n        var ScientificFormatRegex = /e[+-]*[0#]+/i;\n        var StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\n        var TrailingZerosRegex = /0+$/;\n        var DecimalFormatRegex = /\\.([0#]*)/g;\n        var NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\n        var LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\n        var DecimalFormatCharacter = '.';\n        NumberFormat.NumberFormatComponentsDelimeter = ';';\n        function getNonScientificFormatWithPrecision(baseFormat, numericFormat) {\n            if (!numericFormat || baseFormat === undefined)\n                return baseFormat;\n            var newFormat = \"{0:\" + numericFormat + \"}\";\n            return baseFormat.replace(\"{0}\", newFormat);\n        }\n        function getNumericFormat(value, baseFormat) {\n            if (baseFormat == null)\n                return baseFormat;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                if (value > 0)\n                    return getNumericFormatFromComponent(value, positive);\n                else if (value === 0)\n                    return getNumericFormatFromComponent(value, zero);\n                return getNumericFormatFromComponent(value, negative);\n            }\n            return getNumericFormatFromComponent(value, baseFormat);\n        }\n        NumberFormat.getNumericFormat = getNumericFormat;\n        function getNumericFormatFromComponent(value, format) {\n            var match = RegExpExtensions.run(NumericFormatRegex, format);\n            if (match)\n                return match[0];\n            return format;\n        }\n        function addDecimalsToFormat(baseFormat, decimals, trailingZeros) {\n            if (decimals == null)\n                return baseFormat;\n            // Default format string\n            if (baseFormat == null)\n                baseFormat = ZeroPlaceholder;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                var formats = [positive, negative, zero];\n                for (var i = 0; i < formats.length; i++) {\n                    // Update format in formats array\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\n                }\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\n            }\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\n        }\n        NumberFormat.addDecimalsToFormat = addDecimalsToFormat;\n        function addDecimalsToFormatComponent(format, decimals, trailingZeros) {\n            decimals = Math.abs(decimals);\n            if (decimals >= 0) {\n                var placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\n                var decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\n                var match = RegExpExtensions.run(DecimalFormatRegex, format);\n                if (match) {\n                    var beforeDecimal = format.substr(0, match.index);\n                    var formatDecimal = format.substr(match.index + 1, match[1].length);\n                    var afterDecimal = format.substr(match.index + match[0].length);\n                    if (trailingZeros)\n                        // Use explicit decimals argument as placeholders\n                        formatDecimal = decimalPlaceholders;\n                    else {\n                        var decimalChange = decimalPlaceholders.length - formatDecimal.length;\n                        if (decimalChange > 0)\n                            // Append decimalPlaceholders to existing decimal portion of format string\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\n                        else if (decimalChange < 0)\n                            // Remove decimals from formatDecimal\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\n                    }\n                    if (formatDecimal.length > 0)\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\n                    return beforeDecimal + formatDecimal + afterDecimal;\n                }\n                else if (decimalPlaceholders.length > 0)\n                    // Replace last numeric placeholder with decimal portion\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\n            }\n            return format;\n        }\n        function hasFormatComponents(format) {\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\n        }\n        NumberFormat.hasFormatComponents = hasFormatComponents;\n        function getComponents(format) {\n            var signFormat = {\n                hasNegative: false,\n                positive: format,\n                negative: format,\n                zero: format,\n            };\n            var signSpecificFormats = format.split(NumberFormat.NumberFormatComponentsDelimeter);\n            var formatCount = signSpecificFormats.length;\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\n            if (formatCount > 1) {\n                signFormat.hasNegative = true;\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\n                signFormat.negative = signSpecificFormats[1];\n                if (formatCount > 2)\n                    signFormat.zero = signSpecificFormats[2];\n            }\n            return signFormat;\n        }\n        NumberFormat.getComponents = getComponents;\n        var _lastCustomFormatMeta;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = typeof (value) === \"number\";\n            return result;\n        }\n        NumberFormat.canFormat = canFormat;\n        function isStandardFormat(format) {\n            debug.assertValue(format, 'format');\n            return StandardFormatRegex.test(format);\n        }\n        NumberFormat.isStandardFormat = isStandardFormat;\n        /** Formats the number using specified format expression and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            try {\n                if (isStandardFormat(format))\n                    return formatNumberStandard(value, format, culture);\n                return formatNumberCustom(value, format, culture);\n            }\n            catch (e) {\n                return Globalize.format(value, undefined, culture);\n            }\n        }\n        NumberFormat.format = format;\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\n        function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {\n            debug.assertValue(value, 'value');\n            debug.assertValue(format, 'format');\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\n            debug.assertValue(culture, 'culture');\n            debug.assert(!isStandardFormat(format), 'Standard format');\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\n        }\n        NumberFormat.formatWithCustomOverride = formatWithCustomOverride;\n        /** Formats the number using standard format expression */\n        function formatNumberStandard(value, format, culture) {\n            var result;\n            var precision = (format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\n            var numberFormatInfo = culture.numberFormat;\n            var formatChar = format.charAt(0);\n            switch (formatChar) {\n                case \"e\":\n                case \"E\":\n                    if (precision === undefined) {\n                        precision = 6;\n                    }\n                    var mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\n                    result = formatNumberCustom(value, format, culture);\n                    break;\n                case \"f\":\n                case \"F\":\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"g\":\n                case \"G\":\n                    var abs = Math.abs(value);\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\n                    }\n                    else {\n                        // Otherwise use exponential\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\n                        result = result.replace(\"e\", \"E\");\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"r\":\n                case \"R\":\n                    result = value.toString();\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"x\":\n                case \"X\":\n                    result = value.toString(16);\n                    if (formatChar === \"X\") {\n                        result = result.toUpperCase();\n                    }\n                    if (precision !== undefined) {\n                        var actualPrecision = result.length;\n                        var isNegative = value < 0;\n                        if (isNegative) {\n                            actualPrecision--;\n                        }\n                        var paddingZerosCount = precision - actualPrecision;\n                        var paddingZeros = undefined;\n                        if (paddingZerosCount > 0) {\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\n                        }\n                        if (isNegative) {\n                            result = \"-\" + paddingZeros + result.substr(1);\n                        }\n                        else {\n                            result = paddingZeros + result;\n                        }\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                default:\n                    result = Globalize.format(value, format, culture);\n            }\n            return result;\n        }\n        /** Formats the number using custom format expression */\n        function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {\n            var result;\n            var numberFormatInfo = culture.numberFormat;\n            if (isFinite(value)) {\n                // Split format by positive[;negative;zero] pattern\n                var formatComponents = getComponents(format);\n                // Pick a format based on the sign of value\n                if (value > 0) {\n                    format = formatComponents.positive;\n                }\n                else if (value === 0) {\n                    format = formatComponents.zero;\n                }\n                else {\n                    format = formatComponents.negative;\n                }\n                // Normalize value if we have an explicit negative format\n                if (formatComponents.hasNegative)\n                    value = Math.abs(value);\n                // Get format metadata\n                var formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\n                // Preserve literals and escaped chars\n                if (formatMeta.hasEscapes) {\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%\");\n                }\n                var literals = [];\n                if (formatMeta.hasQuotes) {\n                    format = FormattingEncoder.preserveLiterals(format, literals);\n                }\n                // Scientific format\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\n                    var scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\n                    if (scientificMatch) {\n                        // Case 2.1. Scientific custom format\n                        var formatM = format.substr(0, scientificMatch.index);\n                        var formatE = format.substr(scientificMatch.index + 2); // E(+|-)\n                        var precision = getCustomFormatPrecision(formatM, formatMeta);\n                        var scale = getCustomFormatScale(formatM, formatMeta);\n                        if (scale !== 1) {\n                            value = value * scale;\n                        }\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        var s = value.toExponential(precision);\n                        var indexOfE = s.indexOf(\"e\");\n                        var mantissa = s.substr(0, indexOfE);\n                        var exp = s.substr(indexOfE + 1);\n                        var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\n                        var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\n                            resultE = resultE.substr(1);\n                        }\n                        var e = scientificMatch[0].charAt(0);\n                        result = resultM + e + resultE;\n                    }\n                }\n                // Non scientific format\n                if (result === undefined) {\n                    var valueFormatted = void 0;\n                    var isValueGlobalized = false;\n                    var precision = getCustomFormatPrecision(format, formatMeta);\n                    var scale = getCustomFormatScale(format, formatMeta);\n                    if (scale !== 1)\n                        value = value * scale;\n                    // Rounding\n                    value = parseFloat(toNonScientific(value, precision));\n                    if (nonScientificOverrideFormat) {\n                        // Get numeric format from format string\n                        var numericFormat = NumberFormat.getNumericFormat(value, format);\n                        // Add separators and decimalFormat to nonScientificFormat\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\n                        // Format the value\n                        valueFormatted = powerbi_1.formattingService.format(nonScientificOverrideFormat, [value], culture.name);\n                        isValueGlobalized = true;\n                    }\n                    else\n                        valueFormatted = toNonScientific(value, precision);\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\n                }\n                if (formatMeta.hasQuotes) {\n                    result = FormattingEncoder.restoreLiterals(result, literals);\n                }\n                if (formatMeta.hasEscapes) {\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%\");\n                }\n                _lastCustomFormatMeta = formatMeta;\n            }\n            else {\n                return Globalize.format(value, undefined);\n            }\n            return result;\n        }\n        /** Returns string with the fixed point respresentation of the number */\n        function toNonScientific(value, precision) {\n            var result = \"\";\n            var precisionZeros = 0;\n            // Double precision numbers support actual 15-16 decimal digits of precision.\n            if (precision > 16) {\n                precisionZeros = precision - 16;\n                precision = 16;\n            }\n            var digitsBeforeDecimalPoint = powerbi_1.Double.log10(Math.abs(value));\n            if (digitsBeforeDecimalPoint < 16) {\n                if (digitsBeforeDecimalPoint > 0) {\n                    var maxPrecision = 16 - digitsBeforeDecimalPoint;\n                    if (precision > maxPrecision) {\n                        precisionZeros += precision - maxPrecision;\n                        precision = maxPrecision;\n                    }\n                }\n                result = value.toFixed(precision);\n            }\n            else if (digitsBeforeDecimalPoint === 16) {\n                result = value.toFixed(0);\n                precisionZeros += precision;\n                if (precisionZeros > 0) {\n                    result += \".\";\n                }\n            }\n            else {\n                // Different browsers have different implementations of the toFixed().\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\n                // So we need to check for range and convert the to exponential with the max precision.\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\n                // Assert that value is a number and fall back on returning value if it is not\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                if (typeof (value) !== \"number\")\n                    return String(value);\n                result = value.toExponential(15);\n                var indexOfE = result.indexOf(\"e\");\n                if (indexOfE > 0) {\n                    var indexOfDot = result.indexOf(\".\");\n                    var mantissa = result.substr(0, indexOfE);\n                    var exp = result.substr(indexOfE + 1);\n                    var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\n                    if (precision > 0) {\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\n                    }\n                }\n            }\n            if (precisionZeros > 0) {\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\n            }\n            return result;\n        }\n        /**\n         * Returns the formatMetadata of the format\n         * When calculating precision and scale, if format string of\n         * positive[;negative;zero] => positive format will be used\n         * @param (required) format - format string\n         * @param (optional) calculatePrecision - calculate precision of positive format\n         * @param (optional) calculateScale - calculate scale of positive format\n         */\n        function getCustomFormatMetadata(format, calculatePrecision, calculateScale) {\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\n                return _lastCustomFormatMeta;\n            }\n            var result = {\n                format: format,\n                hasEscapes: false,\n                hasQuotes: false,\n                hasE: false,\n                hasCommas: false,\n                hasDots: false,\n                hasPercent: false,\n                hasPermile: false,\n                precision: undefined,\n                scale: undefined,\n            };\n            for (var i = 0, length_1 = format.length; i < length_1; i++) {\n                var c = format.charAt(i);\n                switch (c) {\n                    case \"\\\\\":\n                        result.hasEscapes = true;\n                        break;\n                    case \"'\":\n                    case \"\\\"\":\n                        result.hasQuotes = true;\n                        break;\n                    case \"e\":\n                    case \"E\":\n                        result.hasE = true;\n                        break;\n                    case \",\":\n                        result.hasCommas = true;\n                        break;\n                    case \".\":\n                        result.hasDots = true;\n                        break;\n                    case \"%\":\n                        result.hasPercent = true;\n                        break;\n                    case \"\":\n                        result.hasPermile = true;\n                        break;\n                }\n            }\n            // Use positive format for calculating these values\n            var formatComponents = getComponents(format);\n            if (calculatePrecision)\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\n            if (calculateScale)\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\n            return result;\n        }\n        NumberFormat.getCustomFormatMetadata = getCustomFormatMetadata;\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\n        function getCustomFormatPrecision(format, formatMeta) {\n            if (formatMeta.precision > -1) {\n                return formatMeta.precision;\n            }\n            var result = 0;\n            if (formatMeta.hasDots) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex > -1) {\n                    var count = format.length;\n                    for (var i = dotIndex; i < count; i++) {\n                        var char = format.charAt(i);\n                        if (char.match(NumericPlaceholderRegex))\n                            result++;\n                        // 0.00E+0 :: Break before counting 0 in\n                        // exponential portion of format string\n                        if (char === ExponentialFormatChar)\n                            break;\n                    }\n                    result = Math.min(19, result);\n                }\n            }\n            formatMeta.precision = result;\n            return result;\n        }\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\n        function getCustomFormatScale(format, formatMeta) {\n            if (formatMeta.scale > -1) {\n                return formatMeta.scale;\n            }\n            var result = 1;\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\n                result = result * 100;\n            }\n            if (formatMeta.hasPermile && format.indexOf(\"\") > -1) {\n                result = result * 1000;\n            }\n            if (formatMeta.hasCommas) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex === -1) {\n                    dotIndex = format.length;\n                }\n                for (var i = dotIndex - 1; i > -1; i--) {\n                    var char = format.charAt(i);\n                    if (char === \",\") {\n                        result = result / 1000;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            formatMeta.scale = result;\n            return result;\n        }\n        function fuseNumberWithCustomFormat(value, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized) {\n            var suppressModifyValue = !!nonScientificOverrideFormat;\n            var formatParts = format.split(\".\", 2);\n            if (formatParts.length === 2) {\n                var wholeFormat = formatParts[0];\n                var fractionFormat = formatParts[1];\n                var displayUnit = \"\";\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\n                if (nonScientificOverrideFormat) {\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\n                    value = value.replace(displayUnit, \"\");\n                }\n                var globalizedDecimalSeparator = numberFormatInfo[\".\"];\n                var decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\n                var valueParts = value.split(decimalSeparator, 2);\n                var wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\n                var fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\n                var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\n                var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\n                    return wholeFormattedValue + fractionFormattedValue.value;\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\n            }\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\n        }\n        function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {\n            var groupSymbolIndex = format.indexOf(\",\");\n            var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\n            var groupDigitCount = 0;\n            var groupIndex = 0;\n            var groupSizes = numberFormatInfo.groupSizes || [3];\n            var groupSize = groupSizes[0];\n            var groupSeparator = numberFormatInfo[\",\"];\n            var sign = \"\";\n            var firstChar = value.charAt(0);\n            if (firstChar === \"+\" || firstChar === \"-\") {\n                sign = numberFormatInfo[firstChar];\n                value = value.substr(1);\n            }\n            var isZero = value === \"0\";\n            var result = \"\";\n            var leftBuffer = \"\";\n            var vi = value.length - 1;\n            var fmtOnly = true;\n            // Iterate through format chars and replace 0 and # with the digits from the value string\n            for (var fi = format.length - 1; fi > -1; fi--) {\n                var formatChar = format.charAt(fi);\n                switch (formatChar) {\n                    case ZeroPlaceholder:\n                    case DigitPlaceholder:\n                        fmtOnly = false;\n                        if (leftBuffer !== \"\") {\n                            result = leftBuffer + result;\n                            leftBuffer = \"\";\n                        }\n                        if (!suppressModifyValue) {\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\n                                if (enableGroups) {\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\n                                    if (groupDigitCount === groupSize) {\n                                        result = groupSeparator + result;\n                                        groupIndex++;\n                                        if (groupIndex < groupSizes.length) {\n                                            groupSize = groupSizes[groupIndex];\n                                        }\n                                        groupDigitCount = 1;\n                                    }\n                                    else {\n                                        groupDigitCount++;\n                                    }\n                                }\n                            }\n                            if (vi > -1) {\n                                if (isZero && formatChar === DigitPlaceholder) {\n                                }\n                                else {\n                                    result = value.charAt(vi) + result;\n                                }\n                                vi--;\n                            }\n                            else if (formatChar !== DigitPlaceholder) {\n                                result = formatChar + result;\n                            }\n                        }\n                        break;\n                    case \",\":\n                        // We should skip all the , chars\n                        break;\n                    default:\n                        leftBuffer = formatChar + leftBuffer;\n                        break;\n                }\n            }\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\n            if (!suppressModifyValue) {\n                if (vi > -1 && result !== \"\") {\n                    if (enableGroups) {\n                        while (vi > -1) {\n                            if (groupDigitCount === groupSize) {\n                                result = groupSeparator + result;\n                                groupIndex++;\n                                if (groupIndex < groupSizes.length) {\n                                    groupSize = groupSizes[groupIndex];\n                                }\n                                groupDigitCount = 1;\n                            }\n                            else {\n                                groupDigitCount++;\n                            }\n                            result = value.charAt(vi) + result;\n                            vi--;\n                        }\n                    }\n                    else {\n                        result = value.substr(0, vi + 1) + result;\n                    }\n                }\n                // Insert sign in front of the leftBuffer and result\n                return sign + leftBuffer + result;\n            }\n            if (fmtOnly)\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\n                return sign + leftBuffer + result;\n            return sign + leftBuffer + value + result;\n        }\n        function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {\n            var vi = 0;\n            var fCount = format.length;\n            var vCount = value.length;\n            if (suppressModifyValue) {\n                debug.assert(fCount > 0, \"Empty formatting string\");\n                var lastChar = format.charAt(fCount - 1);\n                if (!lastChar.match(NumericPlaceholderRegex))\n                    return {\n                        value: value + lastChar,\n                        fmtOnly: value === \"\",\n                    };\n                return {\n                    value: value,\n                    fmtOnly: value === \"\",\n                };\n            }\n            var result = \"\", fmtOnly = true;\n            for (var fi = 0; fi < fCount; fi++) {\n                var formatChar = format.charAt(fi);\n                if (vi < vCount) {\n                    switch (formatChar) {\n                        case ZeroPlaceholder:\n                        case DigitPlaceholder:\n                            result += value[vi++];\n                            fmtOnly = false;\n                            break;\n                        default:\n                            result += formatChar;\n                    }\n                }\n                else {\n                    if (formatChar !== DigitPlaceholder) {\n                        result += formatChar;\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\n                    }\n                }\n            }\n            return {\n                value: result,\n                fmtOnly: fmtOnly,\n            };\n        }\n        function localize(value, dictionary) {\n            var plus = dictionary[\"+\"];\n            var minus = dictionary[\"-\"];\n            var dot = dictionary[\".\"];\n            var comma = dictionary[\",\"];\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\n                return value;\n            }\n            var count = value.length;\n            var result = \"\";\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \"+\":\n                        result = result + plus;\n                        break;\n                    case \"-\":\n                        result = result + minus;\n                        break;\n                    case \".\":\n                        result = result + dot;\n                        break;\n                    case \",\":\n                        result = result + comma;\n                        break;\n                    default:\n                        result = result + char;\n                        break;\n                }\n            }\n            return result;\n        }\n    })(NumberFormat = powerbi_1.NumberFormat || (powerbi_1.NumberFormat = {}));\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\n    var DateTimeScaleFormatInfo = (function () {\n        // Constructor\n        /**\n         * Creates new instance of the DateTimeScaleFormatInfo class.\n         * @param culture - culture which calendar info is going to be used to derive the formats.\n         */\n        function DateTimeScaleFormatInfo(culture) {\n            var calendar = culture.calendar;\n            var patterns = calendar.patterns;\n            var monthAbbreviations = calendar[\"months\"][\"namesAbbr\"];\n            var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];\n            var yearMonthPattern = patterns[\"Y\"];\n            var monthDayPattern = patterns[\"M\"];\n            var fullPattern = patterns[\"f\"];\n            var longTimePattern = patterns[\"T\"];\n            var shortTimePattern = patterns[\"t\"];\n            var separator = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\n            var hasYearSymbol = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\n            var yearPos = fullPattern.indexOf(\"yy\");\n            var monthPos = fullPattern.indexOf(\"MMMM\");\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\n            var minutePos = fullPattern.indexOf(\"mm\");\n            var pmPos = fullPattern.indexOf(\"tt\");\n            var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\n            this.MinutePattern = shortTimePattern;\n            this.SecondPattern = longTimePattern;\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\n            // Special cases\n            switch (culture.name) {\n                case \"fi-FI\":\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\n                    break;\n            }\n        }\n        // Methods\n        /**\n         * Returns the format string of the provided DateTimeUnit.\n         * @param unit - date or time unit\n         */\n        DateTimeScaleFormatInfo.prototype.getFormatString = function (unit) {\n            switch (unit) {\n                case powerbi_1.DateTimeUnit.Year:\n                    return this.YearPattern;\n                case powerbi_1.DateTimeUnit.Month:\n                    return this.MonthPattern;\n                case powerbi_1.DateTimeUnit.Week:\n                case powerbi_1.DateTimeUnit.Day:\n                    return this.DayPattern;\n                case powerbi_1.DateTimeUnit.Hour:\n                    return this.HourPattern;\n                case powerbi_1.DateTimeUnit.Minute:\n                    return this.MinutePattern;\n                case powerbi_1.DateTimeUnit.Second:\n                    return this.SecondPattern;\n                case powerbi_1.DateTimeUnit.Millisecond:\n                    return this.MillisecondPattern;\n            }\n            debug.assertFail('Unexpected unit: ' + unit);\n        };\n        return DateTimeScaleFormatInfo;\n    }());\n    powerbi_1.formattingService = new FormattingService();\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\n        var SQExprShortSerializer;\n        (function (SQExprShortSerializer) {\n            function serialize(expr) {\n                return JSON.stringify(expr.accept(SQExprSerializer.instance));\n            }\n            SQExprShortSerializer.serialize = serialize;\n            function serializeArray(exprs) {\n                var str = '[';\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    if (i > 0)\n                        str += ',';\n                    str += SQExprShortSerializer.serialize(exprs[i]);\n                }\n                return str + ']';\n            }\n            SQExprShortSerializer.serializeArray = serializeArray;\n            /** Responsible for serializing an SQExpr into a comparable string. */\n            var SQExprSerializer = (function (_super) {\n                __extends(SQExprSerializer, _super);\n                function SQExprSerializer() {\n                    _super.apply(this, arguments);\n                }\n                SQExprSerializer.prototype.visitColumnRef = function (expr) {\n                    return {\n                        col: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitMeasureRef = function (expr) {\n                    return {\n                        measure: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitAggr = function (expr) {\n                    return {\n                        agg: {\n                            a: expr.arg.accept(this),\n                            f: expr.func,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitEntity = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    debug.assertValue(expr.entity, 'expr.entity');\n                    return {\n                        e: expr.entity\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchyLevel = function (expr) {\n                    return {\n                        h: expr.arg.accept(this),\n                        l: expr.level,\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchy = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        h: expr.hierarchy,\n                    };\n                };\n                SQExprSerializer.prototype.visitPropertyVariationSource = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        n: expr.name,\n                        p: expr.property,\n                    };\n                };\n                SQExprSerializer.prototype.visitAnd = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        and: {\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitCompare = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        comp: {\n                            k: expr.comparison,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitConstant = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        const: {\n                            t: expr.type.primitiveType,\n                            v: expr.value,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitArithmetic = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        arithmetic: {\n                            o: expr.operator,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitScopedEval = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        scopedEval: {\n                            e: expr.expression.accept(this),\n                            s: serializeArray(expr.scope)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitDefault = function (expr) {\n                    debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\n                    return;\n                };\n                SQExprSerializer.instance = new SQExprSerializer();\n                return SQExprSerializer;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprShortSerializer = data.SQExprShortSerializer || (data.SQExprShortSerializer = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var Selector = powerbi.data.Selector;\n        /**\n         * A combination of identifiers used to uniquely identify\n         * data points and their bound geometry.\n         */\n        var SelectionId = (function () {\n            function SelectionId(selector, highlight) {\n                this.selector = selector;\n                this.highlight = highlight;\n                this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\n                this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\n            }\n            SelectionId.prototype.equals = function (other) {\n                if (!this.selector || !other.selector) {\n                    return (!this.selector === !other.selector) && this.highlight === other.highlight;\n                }\n                return this.highlight === other.highlight && Selector.equals(this.selector, other.selector);\n            };\n            /**\n             * Checks equality against other for all identifiers existing in this.\n             */\n            SelectionId.prototype.includes = function (other, ignoreHighlight) {\n                if (ignoreHighlight === void 0) { ignoreHighlight = false; }\n                var thisSelector = this.selector;\n                var otherSelector = other.selector;\n                if (!thisSelector || !otherSelector) {\n                    return false;\n                }\n                var thisData = thisSelector.data;\n                var otherData = otherSelector.data;\n                if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\n                    return false;\n                if (!ignoreHighlight && this.highlight !== other.highlight)\n                    return false;\n                if (thisData) {\n                    if (!otherData)\n                        return false;\n                    if (thisData.length > 0) {\n                        for (var i = 0, ilen = thisData.length; i < ilen; i++) {\n                            var thisValue = thisData[i];\n                            if (!otherData.some(function (otherValue) { return powerbi.DataViewScopeIdentity.equals(thisValue, otherValue); }))\n                                return false;\n                        }\n                    }\n                }\n                return true;\n            };\n            SelectionId.prototype.getKey = function () {\n                return this.key;\n            };\n            SelectionId.prototype.getKeyWithoutHighlight = function () {\n                return this.keyWithoutHighlight;\n            };\n            SelectionId.prototype.hasIdentity = function () {\n                return (this.selector && !!this.selector.data);\n            };\n            SelectionId.prototype.getSelector = function () {\n                return this.selector;\n            };\n            SelectionId.prototype.getSelectorsByColumn = function () {\n                return this.selectorsByColumn;\n            };\n            SelectionId.createNull = function (highlight) {\n                if (highlight === void 0) { highlight = false; }\n                return new SelectionId(null, highlight);\n            };\n            SelectionId.createWithId = function (id, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                if (id) {\n                    selector = {\n                        data: [id]\n                    };\n                }\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithMeasure = function (measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                debug.assertValue(measureId, 'measureId');\n                var selector = {\n                    metadata: measureId\n                };\n                var selectionId = new SelectionId(selector, highlight);\n                selectionId.selectorsByColumn = { metadata: measureId };\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasure = function (id, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                if (id) {\n                    selector.data = [id];\n                }\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id && !measureId)\n                    selector = null;\n                var selectionId = new SelectionId(selector, highlight);\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasureAndCategory = function (id, measureId, queryName, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\n                if (selectionId.selector) {\n                    selectionId.selectorsByColumn = {};\n                    if (id && queryName) {\n                        selectionId.selectorsByColumn.dataMap = {};\n                        selectionId.selectorsByColumn.dataMap[queryName] = id;\n                    }\n                    if (measureId)\n                        selectionId.selectorsByColumn.metadata = measureId;\n                }\n                return selectionId;\n            };\n            SelectionId.createWithIds = function (id1, id2, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector = { data: selectorData };\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithIdsAndMeasure = function (id1, id2, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector.data = selectorData;\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id1 && !id2 && !measureId)\n                    selector = null;\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithSelectorForColumnAndMeasure = function (dataMap, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId;\n                var keys = Object.keys(dataMap);\n                if (keys.length === 2) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], dataMap[keys[1]], measureId, highlight);\n                }\n                else if (keys.length === 1) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], null, measureId, highlight);\n                }\n                else {\n                    selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\n                }\n                var selectorsByColumn = {};\n                if (!_.isEmpty(dataMap))\n                    selectorsByColumn.dataMap = dataMap;\n                if (measureId)\n                    selectorsByColumn.metadata = measureId;\n                if (!dataMap && !measureId)\n                    selectorsByColumn = null;\n                selectionId.selectorsByColumn = selectorsByColumn;\n                return selectionId;\n            };\n            SelectionId.createWithHighlight = function (original) {\n                debug.assertValue(original, 'original');\n                debug.assert(!original.highlight, '!original.highlight');\n                var newId = new SelectionId(original.getSelector(), /*highlight*/ true);\n                newId.selectorsByColumn = original.selectorsByColumn;\n                return newId;\n            };\n            SelectionId.idArray = function (id1, id2) {\n                if (id1 || id2) {\n                    var data_4 = [];\n                    if (id1)\n                        data_4.push(id1);\n                    if (id2 && id2 !== id1)\n                        data_4.push(id2);\n                    return data_4;\n                }\n            };\n            return SelectionId;\n        }());\n        visuals.SelectionId = SelectionId;\n        /**\n         * This class is designed to simplify the creation of SelectionId objects\n         * It allows chaining to build up an object before calling 'create' to build a SelectionId\n         */\n        var SelectionIdBuilder = (function () {\n            function SelectionIdBuilder() {\n            }\n            SelectionIdBuilder.builder = function () {\n                return new SelectionIdBuilder();\n            };\n            SelectionIdBuilder.prototype.withCategory = function (categoryColumn, index) {\n                if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\n                    this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\n                return this;\n            };\n            SelectionIdBuilder.prototype.withSeries = function (seriesColumn, valueColumn) {\n                if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\n                    this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\n                return this;\n            };\n            SelectionIdBuilder.prototype.withMeasure = function (measureId) {\n                this.measure = measureId;\n                return this;\n            };\n            SelectionIdBuilder.prototype.createSelectionId = function () {\n                return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\n            };\n            SelectionIdBuilder.prototype.ensureDataMap = function () {\n                if (!this.dataMap)\n                    this.dataMap = {};\n                return this.dataMap;\n            };\n            return SelectionIdBuilder;\n        }());\n        visuals.SelectionIdBuilder = SelectionIdBuilder;\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n\n\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Allows generic traversal and type discovery for a SQExpr tree. */\r\n    export interface ISQExprVisitorWithArg<T, TArg> {\r\n        visitEntity(expr: SQEntityExpr, arg: TArg): T;\r\n        visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T;\r\n        visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T;\r\n        visitAggr(expr: SQAggregationExpr, arg: TArg): T;\r\n        visitPercentile(expr: SQPercentileExpr, arg: TArg): T;\r\n        visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T;\r\n        visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T;\r\n        visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T;\r\n        visitSelectRef(expr: SQSelectRefExpr, arg: TArg): T;\r\n        visitAnd(expr: SQAndExpr, arg: TArg): T;\r\n        visitBetween(expr: SQBetweenExpr, arg: TArg): T;\r\n        visitIn(expr: SQInExpr, arg: TArg): T;\r\n        visitOr(expr: SQOrExpr, arg: TArg): T;\r\n        visitCompare(expr: SQCompareExpr, arg: TArg): T;\r\n        visitContains(expr: SQContainsExpr, arg: TArg): T;\r\n        visitExists(expr: SQExistsExpr, arg: TArg): T;\r\n        visitNot(expr: SQNotExpr, arg: TArg): T;\r\n        visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T;\r\n        visitConstant(expr: SQConstantExpr, arg: TArg): T;\r\n        visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T;\r\n        visitDateAdd(expr: SQDateAddExpr, arg: TArg): T;\r\n        visitNow(expr: SQNowExpr, arg: TArg): T;\r\n        visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T;\r\n        visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T;\r\n        visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T;\r\n        visitFillRule(expr: SQFillRuleExpr, arg: TArg): T;\r\n        visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T;\r\n        visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T;\r\n    }\r\n\r\n    export interface ISQExprVisitor<T> extends ISQExprVisitorWithArg<T, void> {\r\n    }\r\n\r\n    /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\r\n    export class DefaultSQExprVisitorWithArg<T, TArg> implements ISQExprVisitorWithArg<T, TArg> {\r\n        public visitEntity(expr: SQEntityExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr, arg: TArg): T {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that others may derive from. */\r\n    export class DefaultSQExprVisitor<T> extends DefaultSQExprVisitorWithArg<T, void> implements ISQExprVisitor<T> {\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\r\n    export class DefaultSQExprVisitorWithTraversal implements ISQExprVisitor<void>, IFillRuleDefinitionVisitor<void, void> {\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): void {\r\n            expr.arg.accept(this);\r\n        } \r\n\r\n        public visitPercentile(expr: SQPercentileExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr): void {\r\n            expr.arg.accept(this);\r\n            expr.lower.accept(this);\r\n            expr.upper.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): void {\r\n            let args = expr.args;\r\n            for (let i = 0, len = args.length; i < len; i++)\r\n                args[i].accept(this);\r\n\r\n            let values = expr.values;\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let valueTuple = values[i];\r\n                for (let j = 0, jlen = valueTuple.length; j < jlen; j++)\r\n                    valueTuple[j].accept(this);\r\n            }\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr): void {\r\n            expr.input.accept(this);\r\n\r\n            let rule = expr.rule,\r\n                gradient2 = rule.linearGradient2,\r\n                gradient3 = rule.linearGradient3;\r\n\r\n            if (gradient2) {\r\n                this.visitLinearGradient2(gradient2);\r\n            }\r\n\r\n            if (gradient3) {\r\n                this.visitLinearGradient3(gradient3);\r\n            }\r\n        }\r\n\r\n        public visitLinearGradient2(gradient2: LinearGradient2Definition): void {\r\n            debug.assertValue(gradient2, 'gradient2');\r\n\r\n            this.visitFillRuleStop(gradient2.min);\r\n            this.visitFillRuleStop(gradient2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(gradient3: LinearGradient3Definition): void {\r\n            debug.assertValue(gradient3, 'gradient3');\r\n\r\n            this.visitFillRuleStop(gradient3.min);\r\n            this.visitFillRuleStop(gradient3.mid);\r\n            this.visitFillRuleStop(gradient3.max);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): void {\r\n            expr.expression.accept(this);\r\n\r\n            for (let scopeExpr of expr.scope) {\r\n                scopeExpr.accept(this);\r\n            }\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): void {\r\n            return;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): void {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            stop.color.accept(this);\r\n\r\n            let value = stop.value;\r\n            if (value)\r\n                value.accept(this);\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Defines a custom enumeration data type, and its values. */\r\n    export interface IEnumType {\r\n        /** Gets the members of the enumeration, limited to the validMembers, if appropriate. */\r\n        members(validMembers?: EnumMemberValue[]): IEnumMember[];\r\n    }\r\n\r\n    export function createEnumType(members: IEnumMember[]): IEnumType {\r\n        return new EnumType(members);\r\n    }\r\n\r\n    class EnumType implements IEnumType {\r\n        private allMembers: IEnumMember[];\r\n\r\n        constructor(allMembers: IEnumMember[]) {\r\n            debug.assertValue(allMembers, 'allMembers');\r\n\r\n            this.allMembers = allMembers;\r\n        }\r\n\r\n        public members(validMembers?: EnumMemberValue[]): IEnumMember[] {\r\n            let allMembers = this.allMembers;\r\n            if (!validMembers)\r\n                return allMembers;\r\n\r\n            let membersToReturn: IEnumMember[] = [];\r\n            for (let member of allMembers) {\r\n                if (_.contains(validMembers, member.value))\r\n                    membersToReturn.push(member);\r\n            }\r\n            return membersToReturn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface FillDefinition {\r\n        solid?: {\r\n            color?: SQExpr;\r\n        };\r\n        gradient?: {\r\n            startColor?: SQExpr;\r\n            endColor?: SQExpr;\r\n        };\r\n        pattern?: {\r\n            patternKind?: SQExpr;\r\n            color?: SQExpr;\r\n        };\r\n    }\r\n\r\n    export module FillSolidColorTypeDescriptor {\r\n        /** Gets a value indicating whether the descriptor is nullable or not. */\r\n        export function nullable(descriptor: FillSolidColorTypeDescriptor): boolean {\r\n            debug.assertValue(descriptor, 'descriptor');\r\n\r\n            if (descriptor === true)\r\n                return false;\r\n\r\n            let advancedDescriptor = <FillSolidColorAdvancedTypeDescriptor>descriptor;\r\n            return !!advancedDescriptor.nullable;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ImageTypeDescriptor {\r\n    }\r\n\r\n    export type ImageDefinition = ImageDefinitionGeneric<SQExpr>;\r\n\r\n    export module ImageDefinition {\r\n        export const urlType: ValueTypeDescriptor = { misc: { imageUrl: true } };\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SemanticFilter = powerbi.data.SemanticFilter;\r\n\r\n    export type StructuralObjectDefinition =\r\n        FillDefinition |\r\n        FillRuleDefinition |\r\n        SemanticFilter |\r\n        DefaultValueDefinition |\r\n        ImageDefinition |\r\n        ParagraphsDefinition;\r\n\r\n    export module StructuralTypeDescriptor {\r\n        export function isValid(type: StructuralTypeDescriptor): boolean {\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (type.fill ||\r\n                type.fillRule ||\r\n                type.filter ||\r\n                type.expression ||\r\n                type.image ||\r\n                type.paragraphs) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n\r\n    export interface ValueTypeDescriptor {\r\n        extendedType?: ExtendedType;\r\n    }\r\n    \r\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\r\n    export class ValueType implements ValueTypeDescriptor {\r\n        private static typeCache: { [id: string]: ValueType } = {};\r\n\r\n        private underlyingType: ExtendedType;\r\n        private category: string;\r\n\r\n        private temporalType: TemporalType;\r\n        private geographyType: GeographyType;\r\n        private miscType: MiscellaneousType;\r\n        private formattingType: FormattingType;\r\n        private enumType: IEnumType;\r\n        private scriptingType: ScriptType;\r\n\r\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\r\n        constructor(type: ExtendedType, category?: string, enumType?: IEnumType) {\r\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\r\n            debug.assert(!!category || category === null, 'category');\r\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\r\n\r\n            this.underlyingType = type;\r\n            this.category = category;\r\n\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\r\n                this.temporalType = new TemporalType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\r\n                this.geographyType = new GeographyType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\r\n                this.miscType = new MiscellaneousType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\r\n                this.formattingType = new FormattingType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\r\n                this.enumType = enumType;\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\r\n                this.scriptingType = new ScriptType(type);\r\n            }\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\r\n        public static fromDescriptor(descriptor: ValueTypeDescriptor): ValueType {\r\n            descriptor = descriptor || {};\r\n\r\n            // Simplified primitive types\r\n            if (descriptor.text) return ValueType.fromExtendedType(ExtendedType.Text);\r\n            if (descriptor.integer) return ValueType.fromExtendedType(ExtendedType.Integer);\r\n            if (descriptor.numeric) return ValueType.fromExtendedType(ExtendedType.Double);\r\n            if (descriptor.bool) return ValueType.fromExtendedType(ExtendedType.Boolean);\r\n            if (descriptor.dateTime) return ValueType.fromExtendedType(ExtendedType.DateTime);\r\n            if (descriptor.duration) return ValueType.fromExtendedType(ExtendedType.Duration);\r\n            if (descriptor.binary) return ValueType.fromExtendedType(ExtendedType.Binary);\r\n            if (descriptor.none) return ValueType.fromExtendedType(ExtendedType.None);\r\n\r\n            // Extended types\r\n            if (descriptor.scripting) {\r\n                if (descriptor.scripting.source) return ValueType.fromExtendedType(ExtendedType.ScriptSource);\r\n            }\r\n            if (descriptor.enumeration) return ValueType.fromEnum(descriptor.enumeration);\r\n            if (descriptor.temporal) {\r\n                if (descriptor.temporal.year) return ValueType.fromExtendedType(ExtendedType.Year_Integer);\r\n                if (descriptor.temporal.month) return ValueType.fromExtendedType(ExtendedType.Month_Integer);\r\n            }\r\n            if (descriptor.geography) {\r\n                if (descriptor.geography.address) return ValueType.fromExtendedType(ExtendedType.Address);\r\n                if (descriptor.geography.city) return ValueType.fromExtendedType(ExtendedType.City);\r\n                if (descriptor.geography.continent) return ValueType.fromExtendedType(ExtendedType.Continent);\r\n                if (descriptor.geography.country) return ValueType.fromExtendedType(ExtendedType.Country);\r\n                if (descriptor.geography.county) return ValueType.fromExtendedType(ExtendedType.County);\r\n                if (descriptor.geography.region) return ValueType.fromExtendedType(ExtendedType.Region);\r\n                if (descriptor.geography.postalCode) return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\r\n                if (descriptor.geography.stateOrProvince) return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\r\n                if (descriptor.geography.place) return ValueType.fromExtendedType(ExtendedType.Place);\r\n                if (descriptor.geography.latitude) return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\r\n                if (descriptor.geography.longitude) return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\r\n            }\r\n            if (descriptor.misc) {\r\n                if (descriptor.misc.image) return ValueType.fromExtendedType(ExtendedType.Image);\r\n                if (descriptor.misc.imageUrl) return ValueType.fromExtendedType(ExtendedType.ImageUrl);\r\n                if (descriptor.misc.webUrl) return ValueType.fromExtendedType(ExtendedType.WebUrl);\r\n                if (descriptor.misc.barcode) return ValueType.fromExtendedType(ExtendedType.Barcode_Text);\r\n            }\r\n            if (descriptor.formatting) {\r\n                if (descriptor.formatting.color) return ValueType.fromExtendedType(ExtendedType.Color);\r\n                if (descriptor.formatting.formatString) return ValueType.fromExtendedType(ExtendedType.FormatString);\r\n                if (descriptor.formatting.alignment) return ValueType.fromExtendedType(ExtendedType.Alignment);\r\n                if (descriptor.formatting.labelDisplayUnits) return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\r\n                if (descriptor.formatting.fontSize) return ValueType.fromExtendedType(ExtendedType.FontSize);\r\n                if (descriptor.formatting.labelDensity) return ValueType.fromExtendedType(ExtendedType.LabelDensity);\r\n            }\r\n            if (descriptor.extendedType) {\r\n                return ValueType.fromExtendedType(descriptor.extendedType);\r\n            }\r\n\r\n            return ValueType.fromExtendedType(ExtendedType.Null);\r\n        }\r\n\r\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\r\n        public static fromExtendedType(extendedType: ExtendedType): ValueType {\r\n            extendedType = extendedType || ExtendedType.Null;\r\n\r\n            let primitiveType = getPrimitiveType(extendedType),\r\n                category = getCategoryFromExtendedType(extendedType);\r\n            debug.assert(\r\n                primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null,\r\n                'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\r\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\r\n        public static fromPrimitiveTypeAndCategory(primitiveType: PrimitiveType, category?: string): ValueType {\r\n            primitiveType = primitiveType || PrimitiveType.Null;\r\n            category = category || null;\r\n\r\n            let id = primitiveType.toString();\r\n            if (category)\r\n                id += '|' + category;\r\n\r\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\r\n        }\r\n\r\n        /** Creates a ValueType to describe the given IEnumType. */\r\n        public static fromEnum(enumType: IEnumType): ValueType {\r\n            debug.assertValue(enumType, 'enumType');\r\n\r\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\r\n        }\r\n\r\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\r\n        public static isCompatibleTo(type: ValueTypeDescriptor, otherTypes: ValueTypeDescriptor[]): boolean {\r\n            debug.assertValue(type, 'type');\r\n            debug.assertValue(otherTypes, 'otherTypes');\r\n\r\n            let valueType = ValueType.fromDescriptor(type);\r\n            for (let otherType of otherTypes) {\r\n                let otherValueType = ValueType.fromDescriptor(otherType);\r\n\r\n                if (otherValueType.isCompatibleFrom(valueType))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\r\n        public isCompatibleFrom(other: ValueType): boolean {\r\n            debug.assertValue(other, 'other');\r\n\r\n            let otherPrimitiveType = other.primitiveType;\r\n            if (this === other ||\r\n                this.primitiveType === otherPrimitiveType ||\r\n                otherPrimitiveType === PrimitiveType.Null)\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines if the instance ValueType is equal to the 'other' ValueType\r\n         * @param {ValueType} other the other ValueType to check equality against\r\n         * @returns True if the instance ValueType is equal to the 'other' ValueType\r\n         */\r\n        public equals(other: ValueType): boolean {\r\n            return _.isEqual(this, other);\r\n        }\r\n\r\n        /** Gets the exact primitive type of this ValueType. */\r\n        public get primitiveType(): PrimitiveType {\r\n            return getPrimitiveType(this.underlyingType);\r\n        }\r\n\r\n        /** Gets the exact extended type of this ValueType. */\r\n        public get extendedType(): ExtendedType {\r\n            return this.underlyingType;\r\n        }\r\n\r\n        /** Gets the data category string (if any) for this ValueType. */\r\n        public get categoryString(): string {\r\n            return this.category;\r\n        }\r\n\r\n        // Simplified primitive types\r\n\r\n        /** Indicates whether the type represents text values. */\r\n        public get text(): boolean {\r\n            return this.primitiveType === PrimitiveType.Text;\r\n        }\r\n\r\n        /** Indicates whether the type represents any numeric value. */\r\n        public get numeric(): boolean {\r\n            return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\r\n        }\r\n\r\n        /** Indicates whether the type represents integer numeric values. */\r\n        public get integer(): boolean {\r\n            return this.primitiveType === PrimitiveType.Integer;\r\n        }\r\n\r\n        /** Indicates whether the type represents Boolean values. */\r\n        public get bool(): boolean {\r\n            return this.primitiveType === PrimitiveType.Boolean;\r\n        }\r\n\r\n        /** Indicates whether the type represents any date/time values. */\r\n        public get dateTime(): boolean {\r\n            return this.primitiveType === PrimitiveType.DateTime ||\r\n                this.primitiveType === PrimitiveType.Date ||\r\n                this.primitiveType === PrimitiveType.Time;\r\n        }\r\n\r\n        /** Indicates whether the type represents duration values. */\r\n        public get duration(): boolean {\r\n            return this.primitiveType === PrimitiveType.Duration;\r\n        }\r\n\r\n        /** Indicates whether the type represents binary values. */\r\n        public get binary(): boolean {\r\n            return this.primitiveType === PrimitiveType.Binary;\r\n        }\r\n\r\n        /** Indicates whether the type represents none values. */\r\n        public get none(): boolean {\r\n            return this.primitiveType === PrimitiveType.None;\r\n        }\r\n\r\n        // Extended types\r\n\r\n        /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\r\n        public get temporal(): TemporalType {\r\n            return this.temporalType;\r\n        }\r\n\r\n        /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\r\n        public get geography(): GeographyType {\r\n            return this.geographyType;\r\n        }\r\n\r\n        /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\r\n        public get misc(): MiscellaneousType {\r\n            return this.miscType;\r\n        }\r\n\r\n        /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\r\n        public get formatting(): FormattingType {\r\n            return this.formattingType;\r\n        }\r\n\r\n        /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\r\n        public get enum(): IEnumType {\r\n            return this.enumType;\r\n        }\r\n\r\n        public get scripting(): ScriptType {\r\n            return this.scriptingType;\r\n        }\r\n    }\r\n\r\n    export class ScriptType implements ScriptTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get source(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\r\n        }\r\n    }\r\n\r\n    export class TemporalType implements TemporalTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get year(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\r\n        }\r\n        public get month(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\r\n        }\r\n    }\r\n\r\n    export class GeographyType implements GeographyTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get address(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\r\n        }\r\n        public get city(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\r\n        }\r\n        public get continent(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\r\n        }\r\n        public get country(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\r\n        }\r\n        public get county(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\r\n        }\r\n        public get region(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\r\n        }\r\n        public get postalCode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\r\n        }\r\n        public get stateOrProvince(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\r\n        }\r\n        public get place(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\r\n        }\r\n        public get latitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\r\n        }\r\n        public get longitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\r\n        }\r\n    }\r\n\r\n    export class MiscellaneousType implements MiscellaneousTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get image(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\r\n        }\r\n        public get imageUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\r\n        }\r\n        public get webUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\r\n        }\r\n        public get barcode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Barcode);\r\n        }\r\n    }\r\n\r\n    export class FormattingType implements FormattingTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get color(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\r\n        }\r\n\r\n        public get formatString(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\r\n        }\r\n\r\n        public get alignment(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\r\n        }\r\n\r\n        public get labelDisplayUnits(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\r\n        }\r\n\r\n        public get fontSize(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\r\n        }\r\n\r\n        public get labelDensity(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\r\n        }\r\n    }\r\n\r\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\r\n    export enum PrimitiveType {\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = 2,\r\n        Double = 3,\r\n        Integer = 4,\r\n        Boolean = 5,\r\n        Date = 6,\r\n        DateTime = 7,\r\n        DateTimeZone = 8,\r\n        Time = 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n    }\r\n\r\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\r\n    export enum ExtendedType {\r\n        // Flags (1 << 8-15 range [0xFF00])\r\n        // Important: Enum members must be declared before they are used in TypeScript.\r\n        Numeric = 1 << 8,\r\n        Temporal = 1 << 9,\r\n        Geography = 1 << 10,\r\n        Miscellaneous = 1 << 11,\r\n        Formatting = 1 << 12,\r\n        Scripting = 1 << 13,        \r\n\r\n        // Primitive types (0-255 range [0xFF] | flags)\r\n        // The member names and base values must match those in PrimitiveType.\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = Numeric | 2,\r\n        Double = Numeric | 3,\r\n        Integer = Numeric | 4,\r\n        Boolean = 5,\r\n        Date = Temporal | 6,\r\n        DateTime = Temporal | 7,\r\n        DateTimeZone = Temporal | 8,\r\n        Time = Temporal | 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n\r\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\r\n        // Temporal\r\n        Year = Temporal | (1 << 16),\r\n        Year_Text = Year | Text,\r\n        Year_Integer = Year | Integer,\r\n        Year_Date = Year | Date,\r\n        Year_DateTime = Year | DateTime,\r\n        Month = Temporal | (2 << 16),\r\n        Month_Text = Month | Text,\r\n        Month_Integer = Month | Integer,\r\n        Month_Date = Month | Date,\r\n        Month_DateTime = Month | DateTime,\r\n        // Geography\r\n        Address = Text | Geography | (100 << 16),\r\n        City = Text | Geography | (101 << 16),\r\n        Continent = Text | Geography | (102 << 16),\r\n        Country = Text | Geography | (103 << 16),\r\n        County = Text | Geography | (104 << 16),\r\n        Region = Text | Geography | (105 << 16),\r\n        PostalCode = Geography | (106 << 16),\r\n        PostalCode_Text = PostalCode | Text,\r\n        PostalCode_Integer = PostalCode | Integer,\r\n        StateOrProvince = Text | Geography | (107 << 16),\r\n        Place = Text | Geography | (108 << 16),\r\n        Latitude = Geography | (109 << 16),\r\n        Latitude_Decimal = Latitude | Decimal,\r\n        Latitude_Double = Latitude | Double,\r\n        Longitude = Geography | (110 << 16),\r\n        Longitude_Decimal = Longitude | Decimal,\r\n        Longitude_Double = Longitude | Double,\r\n        // Miscellaneous\r\n        Image = Binary | Miscellaneous | (200 << 16),\r\n        ImageUrl = Text | Miscellaneous | (201 << 16),\r\n        WebUrl = Text | Miscellaneous | (202 << 16),\r\n        Barcode =  Miscellaneous | (203 << 16),\r\n        Barcode_Text = Barcode | Text,\r\n        Barcode_Integer = Barcode | Integer,\r\n\r\n        // Formatting\r\n        Color = Text | Formatting | (300 << 16),\r\n        FormatString = Text | Formatting | (301 << 16),\r\n        Alignment = Text | Formatting | (306 << 16),\r\n        LabelDisplayUnits = Text | Formatting | (307 << 16),\r\n        FontSize = Double | Formatting | (308 << 16),\r\n        LabelDensity = Double | Formatting | (309 << 16),\r\n        // Enumeration\r\n        Enumeration = Text | 400 << 16,\r\n        // Scripting\r\n        ScriptSource = Text | Scripting | (500 << 16),        \r\n        // NOTE: To avoid confusion, underscores should be used only to delimit primitive type variants of an extended type\r\n        // (e.g. Year_Integer or Latitude_Double above)\r\n    }\r\n\r\n    const PrimitiveTypeMask = 0xFF;\r\n    const PrimitiveTypeWithFlagsMask = 0xFFFF;\r\n    const PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\r\n\r\n    function getPrimitiveType(extendedType: ExtendedType): PrimitiveType {\r\n        return extendedType & PrimitiveTypeMask;\r\n    }\r\n\r\n    function isPrimitiveType(extendedType: ExtendedType): boolean {\r\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\r\n    }\r\n\r\n    function getCategoryFromExtendedType(extendedType: ExtendedType): string {\r\n        if (isPrimitiveType(extendedType))\r\n            return null;\r\n\r\n        let category = ExtendedType[extendedType];\r\n        if (category) {\r\n            // Check for ExtendedType declaration without a primitive type.\r\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\r\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\r\n            let delimIdx = category.lastIndexOf('_');\r\n            if (delimIdx > 0) {\r\n                let baseCategory = category.slice(0, delimIdx);\r\n                if (ExtendedType[baseCategory]) {\r\n                    debug.assert(\r\n                        (ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask),\r\n                        'Unexpected value for ExtendedType base member of ' + extendedType);\r\n                    category = baseCategory;\r\n                }\r\n            }\r\n        }\r\n        return category || null;\r\n    }\r\n\r\n    function toExtendedType(primitiveType: PrimitiveType, category?: string): ExtendedType {\r\n        let primitiveString = PrimitiveType[primitiveType];\r\n        let t = ExtendedType[primitiveString];\r\n        if (t == null) {\r\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\r\n            t = ExtendedType.Null;\r\n        }\r\n\r\n        if (primitiveType && category) {\r\n            let categoryType: ExtendedType = ExtendedType[category];\r\n            if (categoryType) {\r\n                let categoryPrimitiveType = getPrimitiveType(categoryType);\r\n                if (categoryPrimitiveType === PrimitiveType.Null) {\r\n                    // Category supports multiple primitive types, check if requested primitive type is supported\r\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\r\n                    categoryType = t | categoryType;\r\n                    if (ExtendedType[categoryType]) {\r\n                        debug.assert(\r\n                            ExtendedType[categoryType] === (category + '_' + primitiveString),\r\n                            'Unexpected name for ExtendedType member ' + categoryType);\r\n                        t = categoryType;\r\n                    }\r\n                }\r\n                else if (categoryPrimitiveType === primitiveType) {\r\n                    // Primitive type matches the single supported type for the category\r\n                    t = categoryType;\r\n                }\r\n            }\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    function matchesExtendedTypeWithAnyPrimitive(a: ExtendedType, b: ExtendedType): boolean {\r\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /**\r\n     * Represents the versions of the data shape binding structure.\r\n     * NOTE Keep this file in sync with the Sql\\InfoNav\\src\\Data\\Contracts\\DsqGeneration\\DataShapeBindingVersions.cs\r\n     * file in the TFS Dev branch.\r\n     */\r\n    export const enum DataShapeBindingVersions {\r\n        /** The initial version of data shape binding */\r\n        Version0 = 0,\r\n        /** Explicit subtotal support for axis groupings. */\r\n        Version1 = 1,\r\n    }\r\n\r\n    export interface DataShapeBindingLimitTarget {\r\n        Primary?: number;\r\n    }\r\n\r\n    export enum DataShapeBindingLimitType {\r\n        Top = 0,\r\n        First = 1,\r\n        Last = 2,\r\n        Sample = 3,\r\n        Bottom = 4,\r\n    }\r\n\r\n    export interface DataShapeBindingLimit {\r\n        Count?: number;\r\n        Target: DataShapeBindingLimitTarget;\r\n        Type: DataShapeBindingLimitType;\r\n    }\r\n\r\n    export interface DataShapeBinding {\r\n        Version?: number;\r\n        Primary: DataShapeBindingAxis;\r\n        Secondary?: DataShapeBindingAxis;\r\n        Aggregates?: DataShapeBindingAggregate[];\r\n        Projections?: number[];\r\n        Limits?: DataShapeBindingLimit[];\r\n        Highlights?: FilterDefinition[];\r\n        DataReduction?: DataShapeBindingDataReduction;\r\n        IncludeEmptyGroups?: boolean;\r\n        SuppressedJoinPredicates?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingDataReduction {\r\n        Primary?: DataShapeBindingDataReductionAlgorithm;\r\n        Secondary?: DataShapeBindingDataReductionAlgorithm;\r\n        DataVolume?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionAlgorithm {\r\n        Top?: DataShapeBindingDataReductionTopLimit;\r\n        Sample?: DataShapeBindingDataReductionSampleLimit;\r\n        Bottom?: DataShapeBindingDataReductionBottomLimit;\r\n        Window?: DataShapeBindingDataReductionDataWindow;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionTopLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionSampleLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionBottomLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionDataWindow {\r\n        Count?: number;\r\n        RestartTokens?: RestartToken;\r\n    }\r\n\r\n    export interface DataShapeBindingAxis {\r\n        Groupings: DataShapeBindingAxisGrouping[];\r\n    }\r\n\r\n    export enum SubtotalType {\r\n        None = 0,\r\n        Before = 1,\r\n        After = 2\r\n    }\r\n\r\n    export interface DataShapeBindingAxisGrouping {\r\n        Projections: number[];\r\n        GroupBy?: number[];\r\n        SuppressedProjections?: number[];\r\n        Subtotal?: SubtotalType;\r\n        ShowItemsWithNoData?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingAggregate {\r\n        Select: number;\r\n        Kind: DataShapeBindingAggregateKind;\r\n    }\r\n\r\n    export const enum DataShapeBindingAggregateKind {\r\n        None = 0,\r\n        Min = 1,\r\n        Max = 1 << 1,\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataShapeBindingDataReduction {\r\n\r\n        export function createFrom(reduction: ReductionAlgorithm): DataShapeBindingDataReductionAlgorithm {\r\n            if (!reduction)\r\n                return;\r\n\r\n            var result: DataShapeBindingDataReductionAlgorithm;\r\n            if (reduction.top) {\r\n                result = {\r\n                    Top: {}\r\n                };\r\n\r\n                if (reduction.top.count)\r\n                    result.Top.Count = reduction.top.count;\r\n            }\r\n\r\n            if (reduction.bottom) {\r\n                result = {\r\n                    Bottom: {}\r\n                };\r\n\r\n                if (reduction.bottom.count)\r\n                    result.Bottom.Count = reduction.bottom.count;\r\n            }\r\n\r\n            if (reduction.sample) {\r\n                result = {\r\n                    Sample: {}\r\n                };\r\n\r\n                if (reduction.sample.count)\r\n                    result.Sample.Count = reduction.sample.count;\r\n            }\r\n\r\n            if (reduction.window) {\r\n                result = {\r\n                    Window: {}\r\n                };\r\n\r\n                if (reduction.window.count)\r\n                    result.Window.Count = reduction.window.count;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface FederatedConceptualSchemaInitOptions {\r\n        schemas: { [name: string]: ConceptualSchema };\r\n        links?: ConceptualSchemaLink[];\r\n    }\r\n\r\n    /** Represents a federated conceptual schema. */\r\n    export class FederatedConceptualSchema {\r\n        private schemas: { [name: string]: ConceptualSchema };\r\n        private links: ConceptualSchemaLink[];\r\n\r\n        constructor(options: FederatedConceptualSchemaInitOptions) {\r\n            debug.assertValue(options, 'options');\r\n\r\n            this.schemas = options.schemas; \r\n            if (options.links)\r\n                this.links = options.links;\r\n        }\r\n\r\n        public schema(name: string): ConceptualSchema {\r\n            return this.schemas[name];\r\n        }\r\n    }\r\n\r\n    /** Describes a semantic relationship between ConceptualSchemas. */\r\n    export interface ConceptualSchemaLink {\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module Selector {\r\n        export function filterFromSelector(selectors: Selector[], isNot?: boolean): SemanticFilter {\r\n            if (_.isEmpty(selectors))\r\n                return;\r\n\r\n            let exprs: SQExpr[] = [];\r\n            for (let i = 0, ilen = selectors.length; i < ilen; i++) {\r\n                let identity = selectors[i];\r\n                let data = identity.data;\r\n                let exprToAdd: SQExpr = undefined;\r\n                if (data && data.length) {\r\n                    for (let j = 0, jlen = data.length; j < jlen; j++) {\r\n                        exprToAdd = SQExprBuilder.and(exprToAdd, <SQExpr>(<DataViewScopeIdentity>identity.data[j]).expr);\r\n                    }\r\n                }\r\n\r\n                if (exprToAdd)\r\n                    exprs.push(exprToAdd);\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return DataViewScopeIdentity.filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function matchesData(selector: Selector, identities: DataViewScopeIdentity[]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(identities, 'identities');\r\n\r\n            let selectorData = selector.data;\r\n            if (selectorData.length !== identities.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = selectorData.length; i < len; i++) {\r\n                let dataItem = selector.data[i];\r\n                let selectorDataItem = <DataViewScopeIdentity>dataItem;\r\n                if (selectorDataItem.expr) {\r\n                    if (!DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\r\n                        return false;\r\n                }\r\n                else {\r\n                    if (!DataViewScopeWildcard.matches(<DataViewScopeWildcard>dataItem, identities[i]))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function matchesKeys(selector: Selector, keysList: SQExpr[][]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(keysList, 'keysList');\r\n\r\n            let selectorData = selector.data,\r\n                selectorDataLength = selectorData.length;\r\n            if (selectorDataLength !== keysList.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < selectorDataLength; i++) {\r\n                let selectorDataItem = selector.data[i],\r\n                    selectorDataExprs: SQExpr[];\r\n\r\n                if ((<DataViewScopeIdentity>selectorDataItem).expr) {\r\n                    selectorDataExprs = ScopeIdentityExtractor.getKeys(<SQExpr>(<DataViewScopeIdentity>selectorDataItem).expr);\r\n                }\r\n                else if ((<DataViewScopeWildcard>selectorDataItem).exprs) {\r\n                    selectorDataExprs = <SQExpr[]>(<DataViewScopeWildcard>selectorDataItem).exprs;\r\n                } else { \r\n                    // In case DataViewRoleWildcard\r\n                    return false;\r\n                }\r\n\r\n                if (!selectorDataExprs)\r\n                    continue;\r\n                if (!SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /** Determines whether two selectors are equal. */\r\n        export function equals(x: Selector, y: Selector): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            if (x.id !== y.id)\r\n                return false;\r\n            if (x.metadata !== y.metadata)\r\n                return false;\r\n            if (!equalsDataArray(x.data, y.data))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsDataArray(x: DataRepetitionSelector[], y: DataRepetitionSelector[]): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            if (x.length !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = x.length; i < len; i++) {\r\n                if (!equalsData(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsData(x: DataRepetitionSelector, y: DataRepetitionSelector): boolean {\r\n            let selector1 = <DataViewScopeIdentity & DataViewRoleWildcard & DataViewScopeWildcard>x;\r\n            let selector2 = <DataViewScopeIdentity & DataViewRoleWildcard & DataViewScopeWildcard>y;\r\n            if (selector1.expr && selector2.expr)\r\n                return DataViewScopeIdentity.equals(selector1, selector2);\r\n\r\n            if (selector1.exprs && selector2.exprs)\r\n                return DataViewScopeWildcard.equals(selector1, selector2);\r\n\r\n            if (selector1.roles && selector2.roles)\r\n                return DataViewRoleWildcard.equals(selector1, selector2);\r\n\r\n            return false;\r\n        }\r\n\r\n        export function getKey(selector: Selector): string {\r\n            let toStringify: any = {};\r\n            if (selector.data) {\r\n                let data = [];\r\n                for (let i = 0, ilen = selector.data.length; i < ilen; i++) {\r\n                    data.push(selector.data[i].key);\r\n                }\r\n                toStringify.data = data;\r\n            }\r\n            if (selector.metadata)\r\n                toStringify.metadata = selector.metadata;\r\n            if (selector.id)\r\n                toStringify.id = selector.id;\r\n            return JSON.stringify(toStringify);\r\n        }\r\n\r\n        export function containsWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (!dataItems)\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                let wildCard = <DataViewScopeWildcard & DataViewRoleWildcard>dataItem;\r\n                if (wildCard.exprs || wildCard.roles)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function hasRoleWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (_.isEmpty(dataItems))\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                if (isRoleWildcard(dataItem))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRoleWildcard(dataItem: DataRepetitionSelector): dataItem is DataViewRoleWildcard {\r\n            return !_.isEmpty((<DataViewRoleWildcard>dataItem).roles);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface QueryDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where?: QueryFilter[];\r\n        OrderBy?: QuerySortClause[];\r\n        Select: QueryExpressionContainer[];\r\n        GroupBy?: QueryExpressionContainer[];\r\n    }\r\n\r\n    export interface FilterDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where: QueryFilter[];\r\n    }    \r\n\r\n    export enum EntitySourceType {\r\n        Table = 0,\r\n        Pod = 1,\r\n    }\r\n\r\n    export interface EntitySource {\r\n        Name: string;\r\n        EntitySet?: string; // TODO: Remove this when Q&A Silverlight is removed and make Entity required\r\n        Entity?: string;\r\n        Schema?: string;\r\n        Type?: EntitySourceType;\r\n    }\r\n\r\n    export interface QueryFilter {\r\n        Target?: QueryExpressionContainer[];\r\n        Condition: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QuerySortClause {\r\n        Expression: QueryExpressionContainer;\r\n        Direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryExpressionContainer {\r\n        Name?: string;\r\n\r\n        SourceRef?: QuerySourceRefExpression;\r\n        Column?: QueryColumnExpression;\r\n        Measure?: QueryMeasureExpression;\r\n        Aggregation?: QueryAggregationExpression;\r\n        Percentile?: QueryPercentileExpression;\r\n        Hierarchy?: QueryHierarchyExpression;\r\n        HierarchyLevel?: QueryHierarchyLevelExpression;\r\n        PropertyVariationSource?: QueryPropertyVariationSourceExpression;\r\n\r\n        // Logical\r\n        And?: QueryBinaryExpression;\r\n        Between?: QueryBetweenExpression;\r\n        In?: QueryInExpression;\r\n        Or?: QueryBinaryExpression;\r\n        Comparison?: QueryComparisonExpression;\r\n        Not?: QueryNotExpression;\r\n        Contains?: QueryContainsExpression;\r\n        StartsWith?: QueryStartsWithExpression;\r\n        Exists?: QueryExistsExpression;\r\n\r\n        // Constants\r\n        Boolean?: QueryBooleanExpression;\r\n        DateTime?: QueryDateTimeExpression;\r\n        DateTimeSecond?: QueryDateTimeSecondExpression;\r\n        Date?: QueryDateTimeExpression;\r\n        Decimal?: QueryDecimalExpression;\r\n        Integer?: QueryIntegerExpression;\r\n        Null?: QueryNullExpression;\r\n        Number?: QueryNumberExpression;\r\n        String?: QueryStringExpression;\r\n        Literal?: QueryLiteralExpression;\r\n\r\n        DateSpan?: QueryDateSpanExpression;\r\n        DateAdd?: QueryDateAddExpression;\r\n        Now?: QueryNowExpression;\r\n\r\n        // Default Values\r\n        DefaultValue?: QueryDefaultValueExpression;\r\n        AnyValue?: QueryAnyValueExpression;\r\n\r\n        Arithmetic?: QueryArithmeticExpression;\r\n\r\n        // Evaluation Expressions\r\n        ScopedEval?: QueryScopedEvalExpression;\r\n\r\n        // Client-only expressions\r\n        FillRule?: QueryFillRuleExpression;\r\n        ResourcePackageItem?: QueryResourcePackageItem;\r\n        SelectRef?: QuerySelectRefExpression;\r\n    }\r\n\r\n    export interface QueryPropertyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryColumnExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QueryMeasureExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QuerySourceRefExpression {\r\n        Source: string;\r\n    }\r\n\r\n    export interface QuerySelectRefExpression {\r\n        ExpressionName: string;\r\n    }\r\n\r\n    export interface QueryAggregationExpression {\r\n        Function: QueryAggregateFunction;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryPercentileExpression {\r\n        Expression: QueryExpressionContainer;\r\n        K: number;\r\n        Exclusive?: boolean;\r\n    }\r\n\r\n    export interface QueryHierarchyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Hierarchy: string;\r\n    }\r\n\r\n    export interface QueryHierarchyLevelExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Level: string;\r\n    }\r\n\r\n    export interface QueryPropertyVariationSourceExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Name: string;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryBinaryExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryBetweenExpression {\r\n        Expression: QueryExpressionContainer;\r\n        LowerBound: QueryExpressionContainer;\r\n        UpperBound: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryInExpression {\r\n        Expressions: QueryExpressionContainer[];\r\n        Values: QueryExpressionContainer[][];\r\n    }\r\n\r\n    export interface QueryComparisonExpression extends QueryBinaryExpression {\r\n        ComparisonKind: QueryComparisonKind;\r\n    }\r\n\r\n    export interface QueryContainsExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryNotExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryStartsWithExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryExistsExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryConstantExpression<T> {\r\n        Value: T;\r\n    }\r\n\r\n    export interface QueryLiteralExpression {\r\n        Value: string;\r\n    }\r\n\r\n    export interface QueryBooleanExpression extends QueryConstantExpression<boolean> { }\r\n    export interface QueryDateTimeExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDateTimeSecondExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDecimalExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryIntegerExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryNumberExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryNullExpression { }\r\n    export interface QueryStringExpression extends QueryConstantExpression<string> { }\r\n\r\n    export interface QueryDateSpanExpression {\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryDateAddExpression {\r\n        Amount: number;\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryNowExpression { }\r\n\r\n    export interface QueryDefaultValueExpression { }\r\n\r\n    export interface QueryAnyValueExpression { }\r\n\r\n    export interface QueryArithmeticExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n        Operator: ArithmeticOperatorKind;\r\n    }\r\n\r\n    export const enum ArithmeticOperatorKind {\r\n        Add = 0,\r\n        Subtract = 1,\r\n        Multiply = 2,\r\n        Divide = 3,\r\n    }\r\n\r\n    export function getArithmeticOperatorName(arithmeticOperatorKind: ArithmeticOperatorKind): string {\r\n        switch (arithmeticOperatorKind) {\r\n            case ArithmeticOperatorKind.Add:\r\n                return \"Add\";\r\n            case ArithmeticOperatorKind.Subtract:\r\n                return \"Subtract\";\r\n            case ArithmeticOperatorKind.Multiply:\r\n                return \"Multiply\";\r\n            case ArithmeticOperatorKind.Divide:\r\n                return \"Divide\";\r\n        }\r\n        throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\r\n    }\r\n\r\n    export interface QueryFillRuleExpression {\r\n        Input: QueryExpressionContainer;\r\n        FillRule: FillRuleGeneric<QueryExpressionContainer, QueryExpressionContainer>;\r\n    }\r\n\r\n    export interface QueryResourcePackageItem {\r\n        PackageName: string;\r\n        PackageType: number;\r\n        ItemName: string;\r\n    }\r\n\r\n    export interface QueryScopedEvalExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Scope: QueryExpressionContainer[];\r\n    }\r\n\r\n    export enum TimeUnit {\r\n        Day = 0,\r\n        Week = 1,\r\n        Month = 2,\r\n        Year = 3,\r\n        Decade = 4,\r\n        Second = 5,\r\n        Minute = 6,\r\n        Hour = 7,\r\n    }\r\n\r\n    export enum QueryAggregateFunction {\r\n        Sum = 0,\r\n        Avg = 1,\r\n        Count = 2,\r\n        Min = 3,\r\n        Max = 4,\r\n        CountNonNull = 5,\r\n        Median = 6,\r\n        StandardDeviation = 7,\r\n        Variance = 8,\r\n    }\r\n\r\n    export enum QueryComparisonKind {\r\n        Equal = 0,\r\n        GreaterThan = 1,\r\n        GreaterThanOrEqual = 2,\r\n        LessThan = 3,\r\n        LessThanOrEqual = 4,\r\n    }\r\n\r\n    /** Defines semantic data types. */\r\n    export enum SemanticType {\r\n        None = 0x0,\r\n        Number = 0x1,\r\n        Integer = Number + 0x2,\r\n        DateTime = 0x4,\r\n        Time = 0x08,\r\n        Date = DateTime + 0x10,\r\n        Month = Integer + 0x20,\r\n        Year = Integer + 0x40,\r\n        YearAndMonth = 0x80,\r\n        MonthAndDay = 0x100,\r\n        Decade = Integer + 0x200,\r\n        YearAndWeek = 0x400,\r\n        String = 0x800,\r\n        Boolean = 0x1000,\r\n        Table = 0x2000,\r\n        Range = 0x4000,\r\n    }\r\n\r\n    export interface QueryMetadata {\r\n        Select?: SelectMetadata[];\r\n        Filters?: FilterMetadata[];\r\n    }\r\n\r\n    // TODO: Stop using SemanticType and ConceptualDataCategory here (may need server contract changes)\r\n    export interface SelectMetadata {\r\n        Restatement: string;\r\n        \r\n        /* SemanticType or PrimitiveType. */\r\n        Type?: number; \r\n\r\n        Format?: string;\r\n        DataCategory?: ConceptualDataCategory;\r\n\r\n        /** The select projection name. */\r\n        Name?: string;\r\n\r\n        /* If defined, this indicates the KPI class*/\r\n        kpiStatusGraphic?: string; // old version of kpi data\r\n\r\n        /* If defined, this indicates the KPI metadata*/\r\n        kpi?: DataViewKpiColumnMetadata;\r\n    }\r\n\r\n    export interface FilterMetadata {\r\n        Restatement: string;\r\n        Kind?: FilterKind;\r\n        /** The expression being filtered.  This is reflected in the filter card UI. */\r\n        expression?: QueryExpressionContainer;\r\n    }\r\n\r\n    export enum FilterKind {\r\n        Default,\r\n        Period,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Represents a projection from a query result. */\r\n    export interface QueryProjection {\r\n        /** Name of item in the semantic query Select clause. */\r\n        queryRef: string;\r\n\r\n        /** Optional format string. */\r\n        format?: string; // TODO: Deprecate this, and populate format string through objects instead.\r\n    }\r\n\r\n    /** A set of QueryProjections, grouped by visualization property, and ordered within that property. */\r\n    export interface QueryProjectionsByRole {\r\n        [roleName: string]: QueryProjectionCollection;\r\n    }\r\n\r\n    export class QueryProjectionCollection {\r\n        private items: QueryProjection[];\r\n\r\n        /* The activeProjectionReference is an array that contains all the items that we are grouping on in case of a drillable\r\n           role. For example, if you have a drill role with [Country, State, City] and the user drilled to state, the active items\r\n           will include [Country and State]. This means that the query will group on both country and state and the state \"last item\"\r\n           is the item that the user drilled to.\r\n        */\r\n        private _activeProjectionRefs: string[];\r\n        private _showAll: boolean;\r\n\r\n        public constructor(items: QueryProjection[], activeProjectionRefs?: string[], showAll?: boolean) {\r\n            debug.assertValue(items, 'items');\r\n\r\n            this.items = items;\r\n            this._activeProjectionRefs = activeProjectionRefs;\r\n            this._showAll = showAll;\r\n        }\r\n\r\n        /** Returns all projections in a mutable array. */\r\n        public all(): QueryProjection[] {\r\n            return this.items;\r\n        }\r\n\r\n        public get activeProjectionRefs(): string[] {\r\n            return this._activeProjectionRefs;\r\n        }\r\n\r\n        public set activeProjectionRefs(queryReferences: string[]) {\r\n            if (!_.isEmpty(queryReferences)) {\r\n                let queryRefs = this.items.map(val => val.queryRef);\r\n\r\n                for (let queryReference of queryReferences) {\r\n                    if (!_.contains(queryRefs, queryReference))\r\n                        return;\r\n                }\r\n\r\n                this._activeProjectionRefs = queryReferences;\r\n            }\r\n        }\r\n\r\n        public get showAll(): boolean {\r\n            return this._showAll;\r\n        }\r\n\r\n        public set showAll(value: boolean) {\r\n            this._showAll = value;\r\n        }\r\n\r\n        public addActiveQueryReference(queryRef: string): void {\r\n            if (!this._activeProjectionRefs)\r\n                this._activeProjectionRefs = [queryRef];\r\n            else\r\n                this._activeProjectionRefs.push(queryRef);\r\n        }\r\n\r\n        public getLastActiveQueryReference(): string {\r\n            if (!_.isEmpty(this._activeProjectionRefs)) {\r\n                return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\r\n            }\r\n        }\r\n\r\n        /** Replaces the given oldQueryRef with newQueryRef in this QueryProjectionCollection. */\r\n        public replaceQueryRef(oldQueryRef: string, newQueryRef: string): void {\r\n            debug.assertValue(oldQueryRef, 'oldQueryRef');\r\n            debug.assertValue(newQueryRef, 'newQueryRef');\r\n            debug.assert(oldQueryRef !== newQueryRef, 'oldQueryRef !== newQueryRef');\r\n            debug.assert(_.isEmpty(this._activeProjectionRefs), 'replaceQueryRef(...) is not supported on the QueryProjectionCollection of a drillable role');\r\n\r\n            // Note: the same queryRef can get projected multiple times\r\n            for (let item of this.items) {\r\n                if (item.queryRef === oldQueryRef) {\r\n                    item.queryRef = newQueryRef;\r\n                }\r\n            }\r\n        }\r\n\r\n        public clone(): QueryProjectionCollection {\r\n            return new QueryProjectionCollection(_.cloneDeep(this.items), _.clone(this._activeProjectionRefs), this._showAll);\r\n        }\r\n    }\r\n\r\n    export module QueryProjectionsByRole {\r\n        /** Clones the QueryProjectionsByRole. */\r\n        export function clone(roles: QueryProjectionsByRole): QueryProjectionsByRole {\r\n            if (!roles)\r\n                return roles;\r\n\r\n            let clonedRoles: QueryProjectionsByRole = {};\r\n\r\n            for (let roleName in roles)\r\n                clonedRoles[roleName] = roles[roleName].clone();\r\n\r\n            return clonedRoles;\r\n        }\r\n\r\n        /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\r\n        export function getRole(roles: QueryProjectionsByRole, name: string): QueryProjectionCollection {\r\n            debug.assertAnyValue(roles, 'roles');\r\n            debug.assertValue(name, 'name');\r\n\r\n            if (!roles)\r\n                return;\r\n\r\n            return roles[name];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export interface VisualElement {\r\n        DataRoles?: DataRole[];\r\n        Settings?: VisualElementSettings;\r\n    }\r\n\r\n    /** Defines common settings for a visual element. */\r\n    export interface VisualElementSettings {\r\n        DisplayUnitSystemType?: DisplayUnitSystemType;\r\n    }\r\n\r\n    export interface DataRole {\r\n        Name: string;\r\n        Projection: number;\r\n        isActive?: boolean;\r\n    }\r\n\r\n    /** The system used to determine display units used during formatting */\r\n    export enum DisplayUnitSystemType {\r\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\r\n        Default,\r\n\r\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\r\n        Verbose,\r\n\r\n        /**\r\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\r\n         * Suitable for dashboard tile cards\r\n         */\r\n        WholeUnits,\r\n\r\n        /**A display unit system that also contains Auto and None units for data labels*/\r\n        DataLabels,\r\n    }\r\n}\r\n\r\nmodule powerbi.data.contracts {\r\n\r\n    export interface DataViewSource {\r\n        data: any;\r\n        type?: string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Repreasents the sequence of the dates/times */\r\n    export class DateTimeSequence {\r\n        // Constants\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;        \r\n\r\n        // Fields\r\n        public min: Date;\r\n        public max: Date;\r\n        public unit: DateTimeUnit;\r\n        public sequence: Date[];\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n\r\n        // Constructors\r\n        /** Creates new instance of the DateTimeSequence */\r\n        constructor(unit: DateTimeUnit) { \r\n            this.unit = unit;\r\n            this.sequence = [];\r\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\r\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Add a new Date to a sequence.\r\n         * @param date - date to add\r\n         */\r\n        public add(date: Date) { \r\n            if (date < this.min) { \r\n                this.min = date;\r\n            }\r\n            if (date > this.max) { \r\n                this.max = date;\r\n            }\r\n            this.sequence.push(date);\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Extends the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public extendToCover(min: Date, max: Date): void {\r\n            let x: Date = this.min;\r\n            while (min < x) {\r\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\r\n                this.sequence.splice(0, 0, x);\r\n            }\r\n            this.min = x;\r\n\r\n            x = this.max;\r\n            while (x < max) {\r\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\r\n                this.sequence.push(x);\r\n            }\r\n            this.max = x;\r\n        }\r\n\r\n        /** \r\n         * Move the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public moveToCover(min: Date, max: Date): void { \r\n            let delta: number = DateTimeSequence.getDelta(min, max, this.unit);\r\n            let count = Math.floor(delta / this.interval);\r\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\r\n\r\n            this.sequence = [];            \r\n            this.sequence.push(this.min);\r\n            this.max = this.min;\r\n            while (this.max < max) {\r\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\r\n                this.sequence.push(this.max);\r\n            }\r\n        }\r\n\r\n        // Static\r\n        /**\r\n         * Calculate a new DateTimeSequence\r\n         * @param dataMin - Date representing min of the data range\r\n         * @param dataMax - Date representing max of the data range\r\n         * @param expectedCount - expected number of intervals in the sequence\r\n         * @param unit - of the intervals in the sequence\r\n         */\r\n        public static calculate(dataMin: Date, dataMax: Date, expectedCount: number, unit?: DateTimeUnit): DateTimeSequence {\r\n            if (!unit) { \r\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\r\n            }\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Month:\r\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Week:\r\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Day:\r\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Hour:\r\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Minute:\r\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Second:\r\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\r\n                default:\r\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\r\n            }\r\n        }\r\n\r\n        public static calculateYears(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\r\n\r\n            // Calculate range and sequence\r\n            let yearsRange = NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\r\n\r\n            // Calculate year sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\r\n            let newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval; \r\n            let date = new Date(newMinYear, 0, 1);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Year);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMonths(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let minYear = dataMin.getFullYear();\r\n            let maxYear = dataMax.getFullYear();\r\n            let minMonth = dataMin.getMonth();\r\n            let maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\r\n            let date = new Date(minYear, 0, 1);\r\n            \r\n            // Calculate month sequence\r\n            let sequence = NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Month);\r\n            return result;\r\n        }\r\n\r\n        public static calculateWeeks(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            let firstDayOfWeek = 0;\r\n            let minDayOfWeek = dataMin.getDay();\r\n            let dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\r\n            let minDay = dataMin.getDate() - dayOffset;\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Week));\r\n\r\n            // Calculate week sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Week);\r\n            return result;\r\n        }\r\n\r\n        public static calculateDays(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, DateTimeUnit.Day));\r\n            \r\n            // Calculate day sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Day);\r\n            return result;\r\n        }\r\n\r\n        public static calculateHours(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Hour));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Hour));\r\n            \r\n            // Calculate hour sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Hour);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMinutes(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Minute));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Minute));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Minute);\r\n            return result;\r\n        }\r\n\r\n        public static calculateSeconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Second));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Second));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Second);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMilliseconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\r\n            let min = DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Millisecond);\r\n            let max = DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Millisecond);\r\n            \r\n            // Calculate milliseconds numeric sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(min, max), expectedCount, 0);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Millisecond);\r\n            return result;\r\n        }\r\n\r\n        public static addInterval(value: Date, interval: number, unit: DateTimeUnit): Date {\r\n            interval = Math.round(interval);\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return DateUtils.addYears(value, interval);\r\n                case DateTimeUnit.Month:\r\n                    return DateUtils.addMonths(value, interval);\r\n                case DateTimeUnit.Week:\r\n                    return DateUtils.addWeeks(value, interval);\r\n                case DateTimeUnit.Day:\r\n                    return DateUtils.addDays(value, interval);\r\n                case DateTimeUnit.Hour:\r\n                    return DateUtils.addHours(value, interval);\r\n                case DateTimeUnit.Minute:\r\n                    return DateUtils.addMinutes(value, interval);\r\n                case DateTimeUnit.Second:\r\n                    return DateUtils.addSeconds(value, interval);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateUtils.addMilliseconds(value, interval);\r\n            }\r\n        }\r\n\r\n        private static fromNumericSequence(date: Date, sequence: NumericSequence, unit: DateTimeUnit) { \r\n            let result = new DateTimeSequence(unit);\r\n            for (let i = 0; i < sequence.sequence.length; i++) { \r\n                let x: number = sequence.sequence[i];\r\n                let d: Date = DateTimeSequence.addInterval(date, x, unit);\r\n                result.add(d);\r\n            }\r\n            result.interval = sequence.interval;\r\n            result.intervalOffset = sequence.intervalOffset;\r\n            return result;\r\n        }\r\n\r\n        private static getDelta(min: Date, max: Date, unit: DateTimeUnit): number {\r\n            let delta: number = 0;\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    delta = max.getFullYear() - min.getFullYear();\r\n                    break;\r\n                case DateTimeUnit.Month:\r\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\r\n                    break;\r\n                case DateTimeUnit.Week:\r\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Day:\r\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Hour:\r\n                    delta = (max.getTime() - min.getTime()) / 3600000;\r\n                    break;\r\n                case DateTimeUnit.Minute:\r\n                    delta = (max.getTime() - min.getTime()) / 60000;\r\n                    break;\r\n                case DateTimeUnit.Second:\r\n                    delta = (max.getTime() - min.getTime()) / 1000;\r\n                    break;\r\n                case DateTimeUnit.Millisecond:\r\n                    delta = max.getTime() - min.getTime();\r\n                    break;\r\n            }\r\n            return delta;\r\n        }\r\n\r\n        public static getIntervalUnit(min:Date, max:Date, maxCount: number): DateTimeUnit {\r\n            maxCount = Math.max(maxCount, 2);\r\n            let totalDays = DateTimeSequence.getDelta(min, max, DateTimeUnit.Day);\r\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\r\n                return DateTimeUnit.Year;\r\n            if (totalDays > 60 && totalDays > 7 * maxCount)\r\n                return DateTimeUnit.Month;\r\n            if (totalDays > 14 && totalDays > 2 * maxCount)\r\n                return DateTimeUnit.Week;\r\n            let totalHours = DateTimeSequence.getDelta(min, max, DateTimeUnit.Hour);\r\n            if (totalDays > 2 && totalHours > 12 * maxCount)\r\n                return DateTimeUnit.Day;\r\n            if (totalHours >= 24 && totalHours >= maxCount)\r\n                return DateTimeUnit.Hour;\r\n            let totalMinutes = DateTimeSequence.getDelta(min, max, DateTimeUnit.Minute);\r\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\r\n                return DateTimeUnit.Minute;\r\n            let totalSeconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Second);\r\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\r\n                return DateTimeUnit.Second;\r\n            let totalMilliseconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Millisecond);\r\n            if (totalMilliseconds > 0)\r\n                return DateTimeUnit.Millisecond;\r\n  \r\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\r\n            let date = min;\r\n            if (date.getMilliseconds() !== 0)\r\n                return DateTimeUnit.Millisecond;\r\n            if (date.getSeconds() !== 0)\r\n                return DateTimeUnit.Second;\r\n            if (date.getMinutes() !== 0)\r\n                return DateTimeUnit.Minute;\r\n            if (date.getHours() !== 0)\r\n                return DateTimeUnit.Hour;\r\n            if (date.getDate() !== 1)\r\n                return DateTimeUnit.Day;\r\n            if (date.getMonth() !== 0)\r\n                return DateTimeUnit.Month;\r\n            \r\n            return DateTimeUnit.Year;\r\n        }\r\n    }\r\n\r\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\r\n    export module DateUtils { \r\n        let MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n        let MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n\r\n        /**\r\n         * Returns bool indicating weither the provided year is a leap year.\r\n         * @param year - year value\r\n         */\r\n        function isLeap(year: number): boolean { \r\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\r\n        }\r\n\r\n        /** \r\n         * Returns number of days in the provided year/month.\r\n         * @param year - year value\r\n         * @param month - month value\r\n         */\r\n        function getMonthDays(year: number, month: number) { \r\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of years to the provided date.\r\n         * @param date - date value\r\n         * @param yearDelta - number of years to add\r\n         */\r\n        export function addYears(date: Date, yearDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n            let isLeapDay = month === 2 && day === 29;\r\n\r\n            let result = new Date(date.getTime());\r\n            year = year + yearDelta;\r\n            if (isLeapDay && !isLeap(year)) {\r\n                day = 28;\r\n            } \r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of months to the provided date.\r\n         * @param date - date value\r\n         * @param monthDelta - number of months to add\r\n         */\r\n        export function addMonths(date: Date, monthDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n           \r\n            let result = new Date(date.getTime());\r\n            year += (monthDelta - (monthDelta % 12)) / 12;\r\n            month += monthDelta % 12;\r\n\r\n            // VSTS 1325771: Certain column charts don't display any data\r\n            // Wrap arround the month if is after december (value 11)\r\n            if (month > 11) {\r\n                month = month % 12;\r\n                year++;\r\n            }\r\n\r\n            day = Math.min(day, getMonthDays(year, month));\r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of weeks to the provided date.\r\n         * @param date - date value\r\n         * @param weeks - number of weeks to add\r\n         */\r\n        export function addWeeks(date: Date, weeks: number): Date { \r\n            return addDays(date, weeks * 7);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of days to the provided date.\r\n         * @param date - date value\r\n         * @param days - number of days to add\r\n         */\r\n        export function addDays(date: Date, days: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();           \r\n            let result = new Date(date.getTime());\r\n            result.setFullYear(year, month, day + days);\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of hours to the provided date.\r\n         * @param date - date value\r\n         * @param hours - number of hours to add\r\n         */\r\n        export function addHours(date: Date, hours: number): Date { \r\n            return new Date(date.getTime() + hours * 3600000);\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of minutes to the provided date.\r\n         * @param date - date value\r\n         * @param minutes - number of minutes to add\r\n         */\r\n        export function addMinutes(date: Date, minutes: number): Date { \r\n            return new Date(date.getTime() + minutes * 60000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of seconds to the provided date.\r\n         * @param date - date value\r\n         * @param seconds - number of seconds to add\r\n         */\r\n        export function addSeconds(date: Date, seconds: number): Date { \r\n            return new Date(date.getTime() + seconds * 1000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of milliseconds to the provided date.\r\n         * @param date - date value\r\n         * @param milliseconds - number of milliseconds to add\r\n         */\r\n        export function addMilliseconds(date: Date, milliseconds: number): Date { \r\n            return new Date(date.getTime() + milliseconds);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    // Constants\r\n    const maxExponent = 24;\r\n    const defaultScientificBigNumbersBoundary = 1E15;\r\n    const scientificSmallNumbersBoundary = 1E-4;\r\n    const PERCENTAGE_FORMAT = '%';\r\n    const SCIENTIFIC_FORMAT = 'E+0';\r\n    const DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\r\n\r\n    // Regular expressions\r\n    /**\r\n     * This regex looks for strings that match one of the following conditions:\r\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\r\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\r\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\r\n     * The entire string (start to end) must match, and the match is not case-sensitive.\r\n     */\r\n    const SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\r\n\r\n    export class DisplayUnit {\r\n        // Fields\r\n        public value: number;\r\n        public title: string;\r\n        public labelFormat: string;\r\n        public applicableRangeMin: number;\r\n        public applicableRangeMax: number;\r\n\r\n        // Methods\r\n        public project(value: number): number {\r\n            if (this.value) {\r\n                return Double.removeDecimalNoise(value / this.value);\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public reverseProject(value: number): number {\r\n            if (this.value) {\r\n                return value * this.value;\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public isApplicableTo(value: number): boolean {\r\n            value = Math.abs(value);\r\n            let precision = Double.getPrecision(value, 3);\r\n            return Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && Double.lessWithPrecision(value, this.applicableRangeMax, precision);\r\n        }\r\n\r\n        public isScaling(): boolean {\r\n            return this.value > 1;\r\n        }\r\n    }\r\n\r\n    export class DisplayUnitSystem {\r\n        // Fields\r\n        public units: DisplayUnit[];\r\n        public displayUnit: DisplayUnit;\r\n        private unitBaseValue: number;\r\n        protected static UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\r\n\r\n        // Constructor\r\n        constructor(units?: DisplayUnit[]) {\r\n            this.units = units ? units : [];\r\n        }\r\n\r\n        // Properties\r\n        public get title(): string {\r\n            return this.displayUnit ? this.displayUnit.title : undefined;\r\n        }\r\n\r\n        // Methods\r\n        public update(value: number): void {\r\n            if (value === undefined)\r\n                return;\r\n\r\n            this.unitBaseValue = value;\r\n            this.displayUnit = this.findApplicableDisplayUnit(value);\r\n        }\r\n\r\n        private findApplicableDisplayUnit(value: number): DisplayUnit {\r\n            for (let unit of this.units) {\r\n                if (unit.isApplicableTo(value))\r\n                    return unit;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        public format(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n            if (this.isFormatSupported(format)) {\r\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\r\n\r\n                if (this.hasScientitifcFormat(format)) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\r\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\r\n                }\r\n                if (decimals != null) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n            }\r\n            \r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        public isPercentageFormat(format: string): boolean {\r\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\r\n        }\r\n\r\n        public shouldRespectScalingUnit(format: string): boolean {\r\n            return !this.isPercentageFormat(format);\r\n        }\r\n\r\n        public getNumberOfDecimalsForFormatting(format: string, decimals?: number) {\r\n            return decimals;\r\n        }\r\n\r\n        public isScalingUnit(): boolean {\r\n            return this.displayUnit && this.displayUnit.isScaling();\r\n        }\r\n\r\n        private formatHelper(value: number, nonScientificFormat: string, format: string, decimals?: number, trailingZeros?: boolean) {\r\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\r\n            if ((format === 'g' || format === 'G') && decimals != null)\r\n                format = visuals.valueFormatter.DefaultNumericFormat;\r\n\r\n            format = NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\r\n\r\n            if (format && !formattingService.isStandardNumberFormat(format))\r\n                return formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\r\n\r\n            if (!format)\r\n                format = 'G';\r\n            if (!nonScientificFormat)\r\n                nonScientificFormat = '{0}';\r\n\r\n            let text = formattingService.formatValue(value, format);\r\n            return formattingService.format(nonScientificFormat, [text]);\r\n        }\r\n\r\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\r\n        public formatSingleValue(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            // Change unit base to a value appropriate for this value\r\n            this.update(this.shouldUseValuePrecision(value) ? Double.getPrecision(value, 8) : value);\r\n\r\n            return this.format(value, format, decimals, trailingZeros);\r\n        }\r\n\r\n        private shouldUseValuePrecision(value: number): boolean {\r\n            if (this.units.length === 0)\r\n                return true;\r\n\r\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\r\n            let applicableRangeMin: number = 0;\r\n            for (let i = 0; i < this.units.length; i++) {\r\n                if (this.units[i].isScaling()) {\r\n                    applicableRangeMin = this.units[i].applicableRangeMin;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return Math.abs(value) < applicableRangeMin;\r\n        }\r\n\r\n        protected isScientific(value: number): boolean {\r\n            return value < - defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\r\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\r\n        }\r\n\r\n        protected hasScientitifcFormat(format: string): boolean {\r\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\r\n        }\r\n\r\n        protected supportsScientificFormat(format: string): boolean {\r\n            if (format)\r\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\r\n\r\n            return true;\r\n        }\r\n\r\n        protected shouldFallbackToScientific(value: number, format: string): boolean {\r\n            return !this.hasScientitifcFormat(format)\r\n                && this.supportsScientificFormat(format)\r\n                && this.isScientific(value);\r\n        }\r\n\r\n        protected getScientificFormat(data: number, format: string, decimals: number, trailingZeros: boolean): string {\r\n            // Use scientific format outside of the range\r\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\r\n                let numericFormat = NumberFormat.getNumericFormat(data, format);\r\n                if (decimals)\r\n                    numericFormat = NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\r\n\r\n                if (numericFormat)\r\n                    return numericFormat + SCIENTIFIC_FORMAT;\r\n                else\r\n                    return DEFAULT_SCIENTIFIC_FORMAT;\r\n            }\r\n\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\r\n    export class NoDisplayUnitSystem extends DisplayUnitSystem {\r\n        // Constructor\r\n        constructor() {\r\n            super([]);\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\r\n        we are showing values (chart axes) and as such it is the default unit system. */\r\n    export class DefaultDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DefaultDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        // Methods\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n\r\n        public static reset(): void {\r\n            DefaultDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DefaultDisplayUnitSystem.units) {\r\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, (value: number, previousUnitValue: number, min: number) => {\r\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\r\n                    if (value - previousUnitValue >= 1000) {\r\n                        return value / 10;\r\n                    }\r\n\r\n                    return min;\r\n                });\r\n\r\n                // Ensure last unit has max of infinity\r\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DefaultDisplayUnitSystem.units;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\r\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\r\n        where we have restricted space but do not want to show partial units. */\r\n    export class WholeUnitsDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public static reset(): void {\r\n            WholeUnitsDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!WholeUnitsDisplayUnitSystem.units) {\r\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\r\n\r\n                // Ensure last unit has max of infinity\r\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n\r\n            return WholeUnitsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export class DataLabelsDisplayUnitSystem extends DisplayUnitSystem {\r\n\r\n        // Constants\r\n        private static AUTO_DISPLAYUNIT_VALUE = 0;\r\n        private static NONE_DISPLAYUNIT_VALUE = 1;\r\n        protected static UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\r\n\r\n        private static units: DisplayUnit[];\r\n\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DataLabelsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DataLabelsDisplayUnitSystem.units) {\r\n                let units = [];\r\n                let adjustMinBasedOnPreviousUnit = (value: number, previousUnitValue: number, min: number): number => {\r\n                    // Never returns true, we are always ignoring\r\n                    // We do not early switch (e.g. 100K instead of 0.1M)\r\n                    // Intended? If so, remove this function, otherwise, remove if statement\r\n                    if (value === -1)\r\n                        if (value - previousUnitValue >= 1000) {\r\n                            return value / 10;\r\n                        }\r\n                    return min;\r\n                };\r\n\r\n                // Add Auto & None\r\n                let names = unitLookup(-1);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                names = unitLookup(0);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                // Add normal units\r\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\r\n\r\n                // Ensure last unit has max of infinity\r\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DataLabelsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export interface DisplayUnitSystemNames {\r\n        title: string;\r\n        format: string;\r\n    }\r\n\r\n    function createDisplayUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames, adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number) {\r\n        let units = [];\r\n        for (let i = 3; i < maxExponent; i++) {\r\n            let names = unitLookup(i);\r\n            if (names)\r\n                addUnitIfNonEmpty(units, Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n        }\r\n\r\n        return units;\r\n    }\r\n\r\n    function addUnitIfNonEmpty(\r\n        units: DisplayUnit[],\r\n        value: number,\r\n        title: string,\r\n        labelFormat: string,\r\n        adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number): void {\r\n        if (title || labelFormat) {\r\n            let min = value;\r\n\r\n            if (units.length > 0) {\r\n                let previousUnit = units[units.length - 1];\r\n\r\n                if (adjustMinBasedOnPreviousUnit)\r\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\r\n\r\n                previousUnit.applicableRangeMax = min;\r\n            }\r\n            let unit = new DisplayUnit();\r\n            unit.value = value;\r\n            unit.applicableRangeMin = min;\r\n            unit.applicableRangeMax = min * 1000;\r\n            unit.title = title;\r\n            unit.labelFormat = labelFormat;\r\n            units.push(unit);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequence {\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;\r\n\r\n        private maxAllowedMargin: number;\r\n        private canExtendMin: boolean;\r\n        private canExtendMax: boolean;\r\n\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n        public min: number;\r\n        public max: number;\r\n        public precision: number;\r\n        public sequence: number[];\r\n\r\n        public static calculate (range: NumericSequenceRange, expectedCount: number, maxAllowedMargin?: number, minPower?: number, useZeroRefPoint?: boolean, steps?: number[]): NumericSequence {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\r\n            debug.assert(minPower === undefined|| (minPower >= Double.MIN_EXP && minPower <= Double.MAX_EXP), \"minPower\");\r\n            debug.assert(maxAllowedMargin === undefined|| (maxAllowedMargin >= 0), \"maxAllowedMargin\");\r\n\r\n            let result = new NumericSequence();\r\n\r\n            if (expectedCount === undefined)\r\n                expectedCount = 10;\r\n            else\r\n                expectedCount = Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (minPower === undefined)\r\n                minPower = Double.MIN_EXP;\r\n            if (useZeroRefPoint === undefined)\r\n                useZeroRefPoint = false;\r\n            if (maxAllowedMargin === undefined)\r\n                maxAllowedMargin = 1;\r\n            if (steps === undefined)\r\n                steps = [1, 2, 5];\r\n\r\n            // Handle single stop case\r\n            if (range.forcedSingleStop) {\r\n                result.interval = range.getSize();\r\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\r\n                result.min = range.min;\r\n                result.max = range.max;\r\n                result.sequence = [range.forcedSingleStop];\r\n                return result;\r\n            }\r\n\r\n            let interval = 0;\r\n            let min = 0;\r\n            let max = 9;\r\n            let canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\r\n            let canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\r\n\r\n            let size = range.getSize();\r\n            let exp = Double.log10(size);\r\n\r\n            // Account for Exp of steps\r\n            let stepExp = Double.log10(steps[0]);\r\n            exp = exp - stepExp;\r\n\r\n            // Account for MaxCount\r\n            let expectedCountExp = Double.log10(expectedCount);\r\n            exp = exp - expectedCountExp;\r\n\r\n            // Account for MinPower\r\n            exp = Math.max(exp, minPower - stepExp + 1);\r\n            let count = undefined;\r\n            // Create array of \"good looking\" numbers\r\n            if (interval !== 0) {\r\n                // If explicit interval is defined - use it instead of the steps array.\r\n                let power = Double.pow10(exp);\r\n                let roundMin = Double.floorToPrecision(range.min, power);\r\n                let roundMax = Double.ceilToPrecision(range.max, power);\r\n                let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\r\n\r\n                roundRange.shrinkByStep(range, interval);\r\n                min = roundRange.min;\r\n                max = roundRange.max;\r\n                count = Math.floor(roundRange.getSize() / interval);\r\n            }\r\n            else {\r\n                // No interval defined -> find optimal interval\r\n                let dexp;\r\n                for (dexp = 0; dexp < 3; dexp++) {\r\n                    let e = exp + dexp;\r\n                    let power = Double.pow10(e);\r\n\r\n                    let roundMin = Double.floorToPrecision(range.min, power);\r\n                    let roundMax = Double.ceilToPrecision(range.max, power);\r\n\r\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\r\n                    let stepsCount = steps.length;\r\n                    let stepPower = Double.pow10(e - 1);\r\n                    for (let i = 0; i < stepsCount; i++) {\r\n                        let step = steps[i] * stepPower;\r\n                        let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\r\n                        roundRange.shrinkByStep(range, step);\r\n\r\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\r\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\r\n                            roundRange.min -= step;\r\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\r\n                            roundRange.max += step;\r\n\r\n                        // Count the intervals\r\n                        count = Double.ceilWithPrecision(roundRange.getSize() / step);\r\n\r\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\r\n                            interval = step;\r\n                            min = roundRange.min;\r\n                            max = roundRange.max;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // Increase the scale power until the interval is found\r\n                    if (interval !== 0)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Avoid extreme count cases (>1000 ticks)\r\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\r\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\r\n                interval = (max - min) / count;\r\n            }\r\n\r\n            result.min = min;\r\n            result.max = max;\r\n            result.interval = interval;\r\n            result.intervalOffset = min - range.min;\r\n            result.maxAllowedMargin = maxAllowedMargin;\r\n            result.canExtendMin = canExtendMin;\r\n            result.canExtendMax = canExtendMax;\r\n\r\n            // Fill in the Sequence\r\n            let precision = Double.getPrecision(interval, 0);\r\n            result.precision = precision;\r\n\r\n            let sequence = [];\r\n\r\n            let x = Double.roundToPrecision(min, precision);\r\n            sequence.push(x);\r\n            for (let i = 0; i < count; i++) {\r\n                x = Double.roundToPrecision(x + interval, precision);\r\n                sequence.push(x);\r\n            }\r\n            \r\n            result.sequence = sequence;\r\n\r\n            result.trimMinMax(range.min, range.max);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid. \r\n         * @min - The minimum of the range.\r\n         * @max - The maximum of the range.\r\n         * @maxCount - The max count of intervals.\r\n         * @steps - array of intervals.\r\n         */\r\n        public static calculateUnits(min: number, max: number, maxCount: number, steps: number[]): NumericSequence {\r\n            // Initialization actions\r\n            maxCount = Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (min === max) {\r\n                max = min + 1;\r\n            }\r\n            let stepCount = 0;\r\n            let step = 0;\r\n\r\n            // Calculate step\r\n            for (let i = 0; i < steps.length; i++)\r\n            {\r\n                step = steps[i];\r\n                let maxStepCount = Double.ceilWithPrecision(max / step);\r\n                let minStepCount = Double.floorWithPrecision(min / step);\r\n                stepCount = maxStepCount - minStepCount;\r\n                    \r\n                if (stepCount <= maxCount) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Calculate the offset\r\n            let offset = -min;\r\n            offset = offset % step;\r\n\r\n            // Create sequence\r\n            let result = new NumericSequence();\r\n            result.sequence = [];\r\n            for (let x = min + offset; ; x += step)\r\n            {\r\n                result.sequence.push(x);\r\n                if (x >= max)\r\n                    break;\r\n            }\r\n            result.interval = step;\r\n            result.intervalOffset = offset;\r\n            result.min = result.sequence[0];\r\n            result.max = result.sequence[result.sequence.length - 1];\r\n            return result;\r\n        }\r\n\r\n        public trimMinMax(min: number, max: number): void {        \r\n            let minMargin = (min - this.min) / this.interval;\r\n            let maxMargin = (this.max - max) / this.interval;\r\n            let marginPrecision = 0.001;\r\n\r\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\r\n                this.min = min;\r\n            }\r\n\r\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\r\n                this.max = max;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequenceRange {\r\n        private static DEFAULT_MAX: number = 10;\r\n        private static MIN_SUPPORTED_DOUBLE = -1E307;\r\n        private static MAX_SUPPORTED_DOUBLE = 1E307;\r\n\r\n        public min: number;\r\n        public max: number;\r\n        public includeZero: boolean;\r\n        public forcedSingleStop: number;\r\n        public hasDataRange: boolean;\r\n        public hasFixedMin: boolean;\r\n        public hasFixedMax: boolean;\r\n\r\n        private _ensureIncludeZero(): void { \r\n            if (this.includeZero) {\r\n                // fixed min and max has higher priority than includeZero\r\n                if (this.min > 0 && !this.hasFixedMin) {\r\n                    this.min = 0;\r\n                }\r\n                if (this.max < 0 && !this.hasFixedMax) {\r\n                    this.max = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureNotEmpty(): void { \r\n            if (this.min === this.max) {\r\n                if (!this.min) {\r\n                    this.min = 0;\r\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\r\n                    this.hasFixedMin = true;\r\n                    this.hasFixedMax = true;\r\n                } else {\r\n                    // We are dealing with a single data value (includeZero is not set)\r\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\r\n                    // Interval is calculated based on the number:\r\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\r\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\r\n                    let value = this.min;\r\n                    let exp = Double.log10(Math.abs(value));\r\n                    let step: number;\r\n                    if (exp >= 0 && exp < 4) {\r\n                        step = 0.5;\r\n                        this.forcedSingleStop = value;\r\n                    } else {\r\n                        step = Double.pow10(exp) / 2;\r\n                        this.forcedSingleStop = null;\r\n                    }\r\n                    this.min = value - step;\r\n                    this.max = value + step;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureDirection() { \r\n            if (this.min > this.max) { \r\n                let temp = this.min;\r\n                this.min = this.max;\r\n                this.max = temp;\r\n            }\r\n        }\r\n\r\n        public getSize(): number {\r\n            return this.max - this.min;\r\n        }\r\n\r\n        public shrinkByStep(range: NumericSequenceRange, step: number) {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(step > 0, \"step\");\r\n\r\n            let oldCount = this.min / step;\r\n            let newCount = range.min / step;\r\n            let deltaCount = Math.floor(newCount - oldCount);\r\n            this.min += deltaCount * step;\r\n\r\n            oldCount = this.max / step;\r\n            newCount = range.max / step;\r\n            deltaCount = Math.ceil(newCount - oldCount);\r\n            this.max += deltaCount * step;\r\n        }\r\n\r\n        public static calculate(dataMin: number, dataMax: number, fixedMin?:number, fixedMax?:number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\r\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.includeZero = includeZero ? true : false;\r\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\r\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\r\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\r\n\r\n            dataMin = Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n            dataMax = Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n\r\n            // Calculate the range using the min, max, dataRange\r\n            if (result.hasFixedMin && result.hasFixedMax) {\r\n                result.min = fixedMin;\r\n                result.max = fixedMax;\r\n            } else if (result.hasFixedMin) {\r\n                result.min = fixedMin;\r\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\r\n            } else if (result.hasFixedMax) {\r\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\r\n                result.max = fixedMax;\r\n            } else if (result.hasDataRange) {\r\n                result.min = dataMin;\r\n                result.max = dataMax;\r\n            } else {\r\n                result.min = 0;\r\n                result.max = 0;\r\n            }\r\n\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            \r\n            if (result.min === 0) {\r\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\r\n            } else if (result.max === 0) {\r\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public static calculateDataRange(dataMin: number, dataMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\r\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\r\n            } else {\r\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\r\n            }\r\n        }\r\n\r\n        public static calculateFixedRange(fixedMin: number, fixedMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assertValue(fixedMin, \"fixedMin\");\r\n            debug.assertValue(fixedMax, \"fixedMax\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.hasDataRange = false;\r\n            result.includeZero = includeZero;\r\n            result.min = fixedMin;\r\n            result.max = fixedMax;\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            result.hasFixedMin = true;\r\n            result.hasFixedMax = true;\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export module ValueUtil {\r\n        export function hasValue(value: any): boolean {\r\n            return value !== undefined && value !== null;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n\r\n    /**\r\n     * Formats the value using provided format expression\r\n     * @param value - value to be formatted and converted to string.\r\n     * @param format - format to be applied if the number shouldn't be abbreviated.\r\n     * If the number should be abbreviated this string is checked for special characters like $ or % if any\r\n     */\r\n    export interface ICustomValueFormatter {\r\n        (value: any, format?: string): string;\r\n    }\r\n\r\n    export interface ICustomValueColumnFormatter {\r\n        (value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier): string;\r\n    }\r\n\r\n    export interface ValueFormatterOptions {\r\n        /** The format string to use. */\r\n        format?: string;\r\n\r\n        /** The data value. */\r\n        value?: any;\r\n\r\n        /** The data value. */\r\n        value2?: any;\r\n\r\n        /** The number of ticks. */\r\n        tickCount?: any;\r\n\r\n        /** The display unit system to use */\r\n        displayUnitSystemType?: DisplayUnitSystemType;\r\n\r\n        /** True if we are formatting single values in isolation (e.g. card), as opposed to multiple values with a common base (e.g. chart axes) */\r\n        formatSingleValues?: boolean;\r\n\r\n        /** True if we want to trim off unnecessary zeroes after the decimal and remove a space before the % symbol */\r\n        allowFormatBeautification?: boolean;\r\n\r\n        /** Specifies the maximum number of decimal places to show*/\r\n        precision?: number;\r\n\r\n        /** Detect axis precision based on value */\r\n        detectAxisPrecision?: boolean;\r\n\r\n        /** Specifies the column type of the data value */\r\n        columnType?: ValueTypeDescriptor;\r\n    }\r\n\r\n    export interface IValueFormatter {\r\n        format(value: any): string;\r\n        displayUnit?: DisplayUnit;\r\n        options?: ValueFormatterOptions;\r\n    }\r\n\r\n    /** Captures all locale-specific options used by the valueFormatter. */\r\n    export interface ValueFormatterLocalizationOptions {\r\n        null: string;\r\n        true: string;\r\n        false: string;\r\n        NaN: string;\r\n        infinity: string;\r\n        negativeInfinity: string;\r\n\r\n        /** Returns a beautified form the given format string. */\r\n        beautify(format: string): string;\r\n\r\n        /** Returns an object describing the given exponent in the current language. */\r\n        describe(exponent: number): DisplayUnitSystemNames;\r\n        restatementComma: string;\r\n        restatementCompoundAnd: string;\r\n        restatementCompoundOr: string;\r\n    }\r\n\r\n    export module valueFormatter {\r\n        import StringExtensions = jsCommon.StringExtensions;\r\n        const BeautifiedFormat: { [x: string]: string } = {\r\n            '0.00 %;-0.00 %;0.00 %': 'Percentage',\r\n            '0.0 %;-0.0 %;0.0 %': 'Percentage1',\r\n        };\r\n\r\n        export const DefaultIntegerFormat = 'g';\r\n        export const DefaultNumericFormat = '#,0.00';\r\n        export const DefaultDateFormat = 'd';\r\n\r\n        const defaultLocalizedStrings = {\r\n            'NullValue': '(Blank)',\r\n            'BooleanTrue': 'True',\r\n            'BooleanFalse': 'False',\r\n            'NaNValue': 'NaN',\r\n            'InfinityValue': '+Infinity',\r\n            'NegativeInfinityValue': '-Infinity',\r\n            'RestatementComma': '{0}, {1}',\r\n            'RestatementCompoundAnd': '{0} and {1}',\r\n            'RestatementCompoundOr': '{0} or {1}',\r\n            'DisplayUnitSystem_EAuto_Title': 'Auto',\r\n            'DisplayUnitSystem_E0_Title': 'None',\r\n            'DisplayUnitSystem_E3_LabelFormat': '{0}K',\r\n            'DisplayUnitSystem_E3_Title': 'Thousands',\r\n            'DisplayUnitSystem_E6_LabelFormat': '{0}M',\r\n            'DisplayUnitSystem_E6_Title': 'Millions',\r\n            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\r\n            'DisplayUnitSystem_E9_Title': 'Billions',\r\n            'DisplayUnitSystem_E12_LabelFormat': '{0}T',\r\n            'DisplayUnitSystem_E12_Title': 'Trillions',\r\n            'Percentage': '#,0.##%',\r\n            'Percentage1': '#,0.#%',\r\n            'TableTotalLabel': 'Total',\r\n            'Tooltip_HighlightedValueDisplayName': 'Highlighted',\r\n            'Funnel_PercentOfFirst': 'Percent of first',\r\n            'Funnel_PercentOfPrevious': 'Percent of previous',\r\n            'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlighted)',\r\n            'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlighted)',\r\n            // Geotagging strings\r\n            'GeotaggingString_Continent': 'continent',\r\n            'GeotaggingString_Continents': 'continents',\r\n            'GeotaggingString_Country': 'country',\r\n            'GeotaggingString_Countries': 'countries',\r\n            'GeotaggingString_State': 'state',\r\n            'GeotaggingString_States': 'states',\r\n            'GeotaggingString_City': 'city',\r\n            'GeotaggingString_Cities': 'cities',\r\n            'GeotaggingString_Town': 'town',\r\n            'GeotaggingString_Towns': 'towns',\r\n            'GeotaggingString_Province': 'province',\r\n            'GeotaggingString_Provinces': 'provinces',\r\n            'GeotaggingString_County': 'county',\r\n            'GeotaggingString_Counties': 'counties',\r\n            'GeotaggingString_Village': 'village',\r\n            'GeotaggingString_Villages': 'villages',\r\n            'GeotaggingString_Post': 'post',\r\n            'GeotaggingString_Zip': 'zip',\r\n            'GeotaggingString_Code': 'code',\r\n            'GeotaggingString_Place': 'place',\r\n            'GeotaggingString_Places': 'places',\r\n            'GeotaggingString_Address': 'address',\r\n            'GeotaggingString_Addresses': 'addresses',\r\n            'GeotaggingString_Street': 'street',\r\n            'GeotaggingString_Streets': 'streets',\r\n            'GeotaggingString_Longitude': 'longitude',\r\n            'GeotaggingString_Longitude_Short': 'lon',\r\n            'GeotaggingString_Latitude': 'latitude',\r\n            'GeotaggingString_Latitude_Short': 'lat',\r\n            'GeotaggingString_PostalCode': 'postal code',\r\n            'GeotaggingString_PostalCodes': 'postal codes',\r\n            'GeotaggingString_ZipCode': 'zip code',\r\n            'GeotaggingString_ZipCodes': 'zip codes',\r\n            'GeotaggingString_Territory': 'territory',\r\n            'GeotaggingString_Territories': 'territories',\r\n        };\r\n\r\n        function beautify(format: string): string {\r\n            let key = BeautifiedFormat[format];\r\n            if (key)\r\n                return defaultLocalizedStrings[key] || format;\r\n            return format;\r\n        }\r\n\r\n        function describeUnit(exponent: number): DisplayUnitSystemNames {\r\n            let exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\r\n\r\n            let title: string = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\r\n            let format: string = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\r\n\r\n            if (title || format)\r\n                return { title: title, format: format };\r\n        }\r\n\r\n        export function getLocalizedString(stringId: string): string {\r\n            return defaultLocalizedStrings[stringId];\r\n        }\r\n\r\n        // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\r\n        let locale: ValueFormatterLocalizationOptions = {\r\n            null: defaultLocalizedStrings['NullValue'],\r\n            true: defaultLocalizedStrings['BooleanTrue'],\r\n            false: defaultLocalizedStrings['BooleanFalse'],\r\n            NaN: defaultLocalizedStrings['NaNValue'],\r\n            infinity: defaultLocalizedStrings['InfinityValue'],\r\n            negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\r\n            beautify: format => beautify(format),\r\n            describe: exponent => describeUnit(exponent),\r\n            restatementComma: defaultLocalizedStrings['RestatementComma'],\r\n            restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\r\n            restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\r\n        };\r\n\r\n        const MaxScaledDecimalPlaces = 2;\r\n        const MaxValueForDisplayUnitRounding = 1000;\r\n        const MinIntegerValueForDisplayUnits = 10000;\r\n        const MinPrecisionForDisplayUnits = 2;\r\n\r\n        const DateTimeMetadataColumn: DataViewMetadataColumn = {\r\n            displayName: '',\r\n            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),\r\n        };\r\n\r\n        export function getFormatMetadata(format: string): powerbi.NumberFormat.NumericFormatMetadata {\r\n            return powerbi.NumberFormat.getCustomFormatMetadata(format);\r\n        }\r\n\r\n        export function setLocaleOptions(options: ValueFormatterLocalizationOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            locale = options;\r\n\r\n            DefaultDisplayUnitSystem.reset();\r\n            WholeUnitsDisplayUnitSystem.reset();\r\n        }\r\n\r\n        export function createDefaultFormatter(formatString: string, allowFormatBeautification: boolean = false): IValueFormatter {\r\n            let formatBeaut: string = allowFormatBeautification ? locale.beautify(formatString) : formatString;\r\n            return {\r\n                format: function (value: any): string {\r\n                    if (value == null)\r\n                        return locale.null;\r\n\r\n                    return formatCore(value, formatBeaut);\r\n                }\r\n            };\r\n        }\r\n\r\n        /** Creates an IValueFormatter to be used for a range of values. */\r\n        export function create(options: ValueFormatterOptions): IValueFormatter {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\r\n\r\n            if (shouldUseNumericDisplayUnits(options)) {\r\n                let displayUnitSystem = createDisplayUnitSystem(options.displayUnitSystemType);\r\n\r\n                let singleValueFormattingMode = !!options.formatSingleValues;\r\n\r\n                displayUnitSystem.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\r\n\r\n                let forcePrecision = options.precision != null;\r\n\r\n                let decimals: number;\r\n\r\n                if (forcePrecision)\r\n                    decimals = -options.precision;\r\n                else if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 1)\r\n                    decimals = -MaxScaledDecimalPlaces;\r\n\r\n                // Detect axis precision\r\n                if (options.detectAxisPrecision) {\r\n                    // Trailing zeroes\r\n                    forcePrecision = true;\r\n\r\n                    let axisValue = options.value;\r\n                    if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 0)\r\n                        axisValue = axisValue / displayUnitSystem.displayUnit.value;\r\n\r\n                    if (Double.isInteger(axisValue))\r\n                        decimals = 0;\r\n                    else\r\n                        decimals = Double.log10(axisValue);\r\n                }\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        let formattedValue: string = getStringFormat(value, true /*nullsAreBlank*/);\r\n                        if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                            return formattedValue;\r\n\r\n                        // Round to Double.DEFAULT_PRECISION\r\n                        if (value && !displayUnitSystem.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision)\r\n                            value = Double.roundToPrecision(value);\r\n\r\n                        return singleValueFormattingMode ?\r\n                            displayUnitSystem.formatSingleValue(value, format, decimals, forcePrecision) :\r\n                            displayUnitSystem.format(value, format, decimals, forcePrecision);\r\n                    },\r\n                    displayUnit: displayUnitSystem.displayUnit,\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\r\n                let unit = DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        if (value == null)\r\n                            return locale.null;\r\n\r\n                        let formatString = formattingService.dateFormatString(unit);\r\n                        return formatCore(value, formatString);\r\n                    },\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            return createDefaultFormatter(format);\r\n        }\r\n\r\n        export function format(value: any, format?: string, allowFormatBeautification?: boolean): string {\r\n            if (value == null)\r\n                return locale.null;\r\n\r\n            return formatCore(\r\n                value,\r\n                !!allowFormatBeautification ? locale.beautify(format) : format);\r\n        }\r\n\r\n        function getValueFormat(value: any, columnType: ValueTypeDescriptor): string {\r\n            // If column type not defined or is not datetime\r\n            // ...and the value is of time datetime,\r\n            // then use the default date format string\r\n            if ((!columnType || !columnType.dateTime) && value instanceof Date)\r\n                return getFormatString(DateTimeMetadataColumn, null, false);\r\n        }\r\n\r\n        export function formatValueColumn(value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier): string {\r\n            let valueFormat = getValueFormat(value, column.type);\r\n            if (valueFormat)\r\n                return formatCore(value, valueFormat);\r\n            else\r\n                return formatCore(value, getFormatString(column, formatStringProp));\r\n        }\r\n\r\n        function createDisplayUnitSystem(displayUnitSystemType?: DisplayUnitSystemType): DisplayUnitSystem {\r\n            if (displayUnitSystemType == null)\r\n                return new DefaultDisplayUnitSystem(locale.describe);\r\n\r\n            switch (displayUnitSystemType) {\r\n                case DisplayUnitSystemType.Default:\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.WholeUnits:\r\n                    return new WholeUnitsDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.Verbose:\r\n                    return new NoDisplayUnitSystem();\r\n                case DisplayUnitSystemType.DataLabels:\r\n                    return new DataLabelsDisplayUnitSystem(locale.describe);\r\n                default:\r\n                    debug.assertFail('Unknown display unit system type');\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n            }\r\n        }\r\n\r\n        function shouldUseNumericDisplayUnits(options: ValueFormatterOptions): boolean {\r\n            let value = options.value;\r\n            let value2 = options.value2;\r\n            let format = options.format;\r\n            // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\r\n            if (options.formatSingleValues && format) {\r\n\r\n                if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\r\n\r\n                    let isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\r\n\r\n                    if (isCustomFormat) {\r\n                        let precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\r\n\r\n                        if (precision < MinPrecisionForDisplayUnits)\r\n                            return false;\r\n                    }\r\n                    else if (Double.isInteger(value))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            if ((typeof value === 'number') || (typeof value2 === 'number')) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        function shouldUseDateUnits(value: any, value2?: any, tickCount?: number): boolean {\r\n            // must check both value and value2 because we'll need to get an interval for date units\r\n            return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\r\n        }\r\n\r\n        /*\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Column format\r\n         *  2. Default PowerView policy for column type\r\n         */\r\n        export function getFormatString(column: DataViewMetadataColumn, formatStringProperty: DataViewObjectPropertyIdentifier, suppressTypeFallback?: boolean): string {\r\n            if (column) {\r\n                if (formatStringProperty) {\r\n                    let propertyValue = DataViewObjects.getValue<string>(column.objects, formatStringProperty);\r\n                    if (propertyValue)\r\n                        return propertyValue;\r\n                }\r\n\r\n                if (!suppressTypeFallback) {\r\n                    let columnType = column.type;\r\n                    if (columnType) {\r\n                        if (columnType.dateTime)\r\n                            return DefaultDateFormat;\r\n                        if (columnType.integer)\r\n                            return DefaultIntegerFormat;\r\n                        if (columnType.numeric)\r\n                            return DefaultNumericFormat;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function formatListCompound(strings: string[], conjunction: string): string {\r\n            let result: string;\r\n\r\n            if (!strings) {\r\n                return null;\r\n            }\r\n\r\n            let length = strings.length;\r\n            if (length > 0) {\r\n                result = strings[0];\r\n                let lastIndex = length - 1;\r\n                for (let i = 1, len = lastIndex; i < len; i++) {\r\n                    let value = strings[i];\r\n                    result = StringExtensions.format(locale.restatementComma, result, value);\r\n                }\r\n\r\n                if (length > 1) {\r\n                    let value = strings[lastIndex];\r\n                    result = StringExtensions.format(conjunction, result, value);\r\n                }\r\n            }\r\n            else {\r\n                result = null;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., and C'  */\r\n        export function formatListAnd(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundAnd);\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., or C' */\r\n        export function formatListOr(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundOr);\r\n        }\r\n\r\n        function formatCore(value: any, format: string): string {\r\n            let formattedValue = getStringFormat(value, false /*nullsAreBlank*/);\r\n\r\n            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                return formattedValue;\r\n\r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        function getStringFormat(value: any, nullsAreBlank: boolean): string {\r\n            if (value == null && nullsAreBlank)\r\n                return locale.null;\r\n\r\n            if (value === true)\r\n                return locale.true;\r\n\r\n            if (value === false)\r\n                return locale.false;\r\n\r\n            if (typeof value === 'number' && isNaN(value))\r\n                return locale.NaN;\r\n\r\n            if (value === Number.NEGATIVE_INFINITY)\r\n                return locale.negativeInfinity;\r\n\r\n            if (value === Number.POSITIVE_INFINITY)\r\n                return locale.infinity;\r\n\r\n            return '';\r\n        }\r\n\r\n        export function getDisplayUnits(displayUnitSystemType: DisplayUnitSystemType): DisplayUnit[] {\r\n            let displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\r\n            return displayUnitSystem.units;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataRoleHelper {\r\n        export function getMeasureIndexOfRole(grouped: DataViewValueColumnGroup[], roleName: string): number {\r\n            if (!_.isEmpty(grouped)) {\r\n                let firstGroup = grouped[0];\r\n                if (firstGroup.values && firstGroup.values.length > 0) {\r\n                    for (let i = 0, len = firstGroup.values.length; i < len; ++i) {\r\n                        let value = firstGroup.values[i];\r\n                        if (value && value.source) {\r\n                            if (hasRole(value.source, roleName))\r\n                                return i;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function getCategoryIndexOfRole(categories: DataViewCategoryColumn[], roleName: string): number {\r\n            if (!_.isEmpty(categories)) {\r\n                for (let i = 0, ilen = categories.length; i < ilen; i++) {\r\n                    if (hasRole(categories[i].source, roleName))\r\n                        return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function hasRole(column: DataViewMetadataColumn, name: string): boolean {\r\n            let roles = column.roles;\r\n            return roles && roles[name];\r\n        }\r\n\r\n        export function hasRoleInDataView(dataView: DataView, name: string): boolean {\r\n            return dataView != null\r\n                && dataView.metadata != null\r\n                && dataView.metadata.columns\r\n                && _.any(dataView.metadata.columns, c => c.roles && c.roles[name] !== undefined);\r\n        }\r\n        \r\n        export function hasRoleInValueColumn(valueColumn: DataViewValueColumn, name: string): boolean {\r\n            return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\r\n\r\n    export function createIDataViewCategoricalReader(dataView: DataView): IDataViewCategoricalReader {\r\n        return new DataViewCategoricalReader(dataView);\r\n    }\r\n\r\n    export interface IDataViewCategoricalReader {\r\n        // Category functions\r\n        hasCategories(): boolean;\r\n        getCategoryCount(): number;\r\n        getCategoryValues(roleName: string): any;\r\n        getCategoryValue(roleName: string, categoryIndex: number): any;\r\n        getCategoryColumn(roleName: string): DataViewCategoryColumn;\r\n        getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn;\r\n        getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[];\r\n        getCategoryDisplayName(roleName: string): string;\r\n        hasCompositeCategories(): boolean;\r\n        hasCategoryWithRole(roleName: string): boolean;\r\n        getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects;\r\n        // Value functions\r\n        hasValues(roleName: string): boolean;\r\n        /**\r\n         * Obtains the value for the given role name, category index, and series index.\r\n         *\r\n         * Note: in cases where have multiple values in a role where the multiple values\r\n         * are not being used to create a static series, the first is obtained. (this is\r\n         * a rare case)\r\n         */\r\n        getValue(roleName: string, categoryIndex: number, seriesIndex?: number): any;\r\n        /**\r\n         * Obtains the highlighted value for the given role name, category index, and series index.\r\n         *\r\n         * Note: in cases where have multiple values in a role where the multiple values\r\n         * are not being used to create a static series, the first is obtained. (this is\r\n         * a rare case)\r\n         */\r\n        getHighlight(roleName: string, categoryIndex: number, seriesIndex?: number): any;\r\n        /**\r\n         * Obtains all the values for the given role name, category index, and series index, drawing\r\n         * from each of the value columns at that intersection.  Used when you have multiple\r\n         * values in a role that are not conceptually a static series.\r\n         */\r\n        getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex?: number): any[];\r\n        /**\r\n         * Obtains all the highlight values for the given role name, category index, and series index, drawing\r\n         * from each of the value columns at that intersection.  Used when you have multiple\r\n         * values in a role that are not conceptually a static series.\r\n         */\r\n        getAllHighlightsForRole(roleName: string, categoryIndex: number, seriesIndex?: number): any[];\r\n        /**\r\n         * Obtains the first non-null value for the given role name and category index.\r\n         * It should mainly be used for values that are expected to be the same across\r\n         * series, but avoids false nulls when the data is sparse.\r\n         */\r\n        getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any;\r\n        getMeasureQueryName(roleName: string): string;\r\n        getValueColumn(roleName: string, seriesIndex?: number): DataViewValueColumn;\r\n        getValueMetadataColumn(roleName: string, seriesIndex?: number): DataViewMetadataColumn;\r\n        getValueDisplayName(roleName: string, seriesIndex?: number): string;\r\n        // Series Methods\r\n        hasDynamicSeries(): boolean;\r\n        /**\r\n         * Get the series count.  This requires a value role name for cases where you may\r\n         * have a static series, but is not required if the only series you expect are dynamic\r\n         * or single series. \r\n         * \r\n         * @param valueRoleName The role of the value for which a static series may exist\r\n         */\r\n        getSeriesCount(valueRoleName?: string): number;\r\n        getSeriesObjects(seriesIndex: number): DataViewObjects;\r\n        getSeriesValueColumns(): DataViewValueColumns;\r\n        getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup;\r\n        getSeriesMetadataColumn(): DataViewMetadataColumn;\r\n        getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[];\r\n        getSeriesName(seriesIndex: number): PrimitiveValue;\r\n        getSeriesDisplayName(): string;\r\n    }\r\n\r\n    /**\r\n     * A mapping used to map indeces within a specific roleName to an index into the values\r\n     * of a grouped.  This is used so that you can iterate over values within a role without\r\n     * expensive filtering or extra traversal.\r\n     */ \r\n    interface RoleIndexMapping {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    class DataViewCategoricalReader implements IDataViewCategoricalReader {\r\n        private dataView: DataView;\r\n        private categories: DataViewCategoryColumn[];\r\n        private grouped: DataViewValueColumnGroup[];\r\n        private dataHasDynamicSeries: boolean;\r\n        private valueRoleIndexMapping: RoleIndexMapping;\r\n        \r\n        // Validation variables\r\n        private hasValidCategories: boolean;\r\n        private hasAnyValidValues: boolean;\r\n\r\n        constructor(dataView: DataView) {\r\n            debug.assertValue(dataView, 'dataView');\r\n            this.dataView = dataView;\r\n            // Validate categories\r\n            let categorical: DataViewCategorical;\r\n            if (dataView)\r\n                categorical = dataView.categorical;\r\n            let categories: DataViewCategoryColumn[];\r\n            if (categorical)\r\n                categories = this.categories = categorical.categories;\r\n            this.hasValidCategories = !_.isEmpty(categories);\r\n\r\n            // Validate values\r\n            let values: DataViewValueColumns;\r\n            if (categorical)\r\n                values = categorical.values;\r\n            // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\r\n            // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\r\n            this.hasAnyValidValues = false;\r\n            if (values != null) {\r\n                let grouped = dataView.categorical.values.grouped();\r\n\r\n                if (grouped.length > 0) {\r\n                    this.hasAnyValidValues = true;\r\n                    this.grouped = grouped;\r\n\r\n                    // Iterate through the first group's values to populate the valueRoleIndexMapping\r\n                    let valueRoleIndexMapping: RoleIndexMapping = {};\r\n                    let firstGroupValues = grouped[0].values;\r\n                    for (let valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\r\n                        let valueRoles = firstGroupValues[valueIndex].source.roles;\r\n                        for (let role in valueRoles) {\r\n                            if (valueRoles[role]) {\r\n                                if (!valueRoleIndexMapping[role])\r\n                                    valueRoleIndexMapping[role] = [];\r\n                                valueRoleIndexMapping[role].push(valueIndex);\r\n                            }\r\n                        }\r\n                    }\r\n                    this.valueRoleIndexMapping = valueRoleIndexMapping;\r\n                }\r\n            }\r\n\r\n            if (this.hasAnyValidValues)\r\n                this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\r\n        }\r\n\r\n        // Category methods\r\n        \r\n        public hasCategories(): boolean {\r\n            return this.hasValidCategories;\r\n        }\r\n\r\n        public getCategoryCount(): number {\r\n            if (this.hasValidCategories)\r\n                return this.categories[0].values.length;\r\n            else\r\n                return 0;\r\n        }\r\n\r\n        public getCategoryValues(roleName: string): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryValue(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values[categoryIndex] : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumn(roleName: string): DataViewCategoryColumn {\r\n            if (this.hasValidCategories)\r\n                return this.getCategoryFromRole(roleName);\r\n        }\r\n\r\n        public getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.source : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[] {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.identityFields : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryDisplayName(roleName: string): string {\r\n            if (this.hasValidCategories) {\r\n                let targetColumn = this.getCategoryColumn(roleName);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        public hasCompositeCategories(): boolean {\r\n            if (this.hasValidCategories)\r\n                return this.categories.length > 1;\r\n        }\r\n\r\n        public hasCategoryWithRole(roleName: string): boolean {\r\n            return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\r\n        }\r\n\r\n        public getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects {\r\n            if (this.hasValidCategories) {\r\n                let category = this.getCategoryFromRole(roleName);\r\n                if (category && category.objects) {\r\n                    return category.objects[categoryIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        private getCategoryFromRole(roleName: string): DataViewCategoryColumn {\r\n            let categories = this.categories;\r\n            return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\r\n        }\r\n\r\n        // Value and measure methods\r\n\r\n        public hasValues(roleName: string): boolean {\r\n            return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\r\n        }\r\n\r\n        public getValue(roleName: string, categoryIndex: number, seriesIndex: number = 0): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    // For dynamic series, we only ever obtain the first value column from a role\r\n                    return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, false /* getHighlight */);\r\n                }\r\n                else {\r\n                    // For static series or single series, we obtain value columns from the first series\r\n                    //    and use the seriesIndex to index into the value columns within the role\r\n                    return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, false /* getHighlight */);\r\n                }\r\n            }\r\n        }\r\n\r\n        public getHighlight(roleName: string, categoryIndex: number, seriesIndex: number = 0): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    // For dynamic series, we only ever obtain the first value column from a role\r\n                    return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, true /* getHighlight */);\r\n                }\r\n                else {\r\n                    // For static series or single series, we obtain value columns from the first series\r\n                    //    and use the seriesIndex to index into the value columns within the role\r\n                    return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, true /* getHighlight */);\r\n                }\r\n            }\r\n        }\r\n\r\n        public getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex: number = 0): any[] {\r\n            if (this.hasValues(roleName)) {\r\n                let valuesInRole = [];\r\n                for (let roleValueIndex, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, false /* getHighlight */));\r\n                }\r\n                return valuesInRole;\r\n            }\r\n        }\r\n\r\n        public getAllHighlightsForRole(roleName: string, categoryIndex: number, seriesIndex: number = 0): any[] {\r\n            if (this.hasValues(roleName)) {\r\n                let valuesInRole = [];\r\n                for (let roleValueIndex, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, true /* getHighlight */));\r\n                }\r\n                return valuesInRole;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Obtains the value from grouped.\r\n         *\r\n         * Grouped:             [0] [1] [2] [3] (seriesIndex)\r\n         *                         /   \\\r\n         * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\r\n         *                    /    \\ \\  \\           \r\n         * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\r\n         * \r\n         *--------------------------------|\r\n         *                      |Category |\r\n         * Series|Value Columns |A B C D E|\r\n         *--------------------------------|\r\n         *      0|col0 (tooltip)|         |\r\n         *       |col1 (value)  |         |\r\n         *       |col2 (value)  |         |\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      1|col0 (tooltip)|         |\r\n         *       |col1 (value)  |0 1 2 3 4|\r\n         *       |col2 (value)  |5 6 7 8 9|\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      2|col0 (tooltip)|...      |\r\n         * \r\n         * valueColumnIndexInRole is for indexing into the values for a single role\r\n         * valueColumnIndex is for indexing into the entire value array including\r\n         * all roles\r\n         * \r\n         * The valueRoleIndexMapping converts roleValueIndex and role (value role\r\n         * with an index of 1) into groupedValueIndex (2)\r\n         *\r\n         * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\r\n         * the second value column with role \"value\" (which is converted to a\r\n         * groupedValueIndex of 2) and the fourth value within that value column.\r\n         */\r\n        private getValueInternal(roleName: string, categoryIndex: number, groupIndex: number, valueColumnIndexInRole: number, getHighlight: boolean): any {\r\n            if (this.hasValues(roleName)) {\r\n                let valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\r\n                let groupedValues = this.grouped[groupIndex].values[valueColumnIndex];\r\n                return getHighlight ? groupedValues.highlights[categoryIndex] : groupedValues.values[categoryIndex];\r\n            }\r\n        }\r\n\r\n        public getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (!this.dataHasDynamicSeries) {\r\n                    debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\r\n                    return this.getValue(roleName, categoryIndex);\r\n                }\r\n                for (let seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\r\n                    let value = this.getValue(roleName, categoryIndex, seriesIndex);\r\n                    if (value != null) {\r\n                        return value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public getMeasureQueryName(roleName: string): string {\r\n            if (this.hasValues(roleName))\r\n                return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\r\n        }\r\n\r\n        public getValueColumn(roleName: string, seriesIndex: number = 0): DataViewValueColumn {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\r\n                }\r\n                else {\r\n                    return this.grouped[0].values[this.valueRoleIndexMapping[roleName][seriesIndex]];\r\n                }\r\n            }\r\n        }\r\n\r\n        public getValueMetadataColumn(roleName: string, seriesIndex: number = 0): DataViewMetadataColumn {\r\n            let valueColumn = this.getValueColumn(roleName, seriesIndex);\r\n            if (valueColumn) {\r\n                return valueColumn.source;\r\n            }\r\n        }\r\n\r\n        public getValueDisplayName(roleName: string, seriesIndex?: number): string {\r\n            if (this.hasValues(roleName)) {\r\n                let targetColumn = this.getValueColumn(roleName, seriesIndex);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Series methods\r\n\r\n        public hasDynamicSeries(): boolean {\r\n            return this.dataHasDynamicSeries;\r\n        }\r\n\r\n        public getSeriesCount(valueRoleName?: string): number {\r\n            if (this.hasAnyValidValues) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    return this.grouped.length;\r\n                }\r\n                else if (valueRoleName) {\r\n                    return this.valueRoleIndexMapping[valueRoleName].length;\r\n                }\r\n                else {\r\n                    return 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        public getSeriesObjects(seriesIndex: number): DataViewObjects {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].objects;\r\n        }\r\n\r\n        public getSeriesValueColumns(): DataViewValueColumns {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values;\r\n        }\r\n\r\n        public getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex];\r\n        }\r\n\r\n        public getSeriesMetadataColumn(): DataViewMetadataColumn {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.source;\r\n        }\r\n\r\n        public getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[] {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.identityFields;\r\n        }\r\n\r\n        public getSeriesName(seriesIndex: number): PrimitiveValue {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].name;\r\n        }\r\n\r\n        public getSeriesDisplayName(): string {\r\n            if (this.hasAnyValidValues && this.dataHasDynamicSeries)\r\n                return this.dataView.categorical.values.source.displayName;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n    import valueFormatter = powerbi.visuals.valueFormatter;\r\n\r\n    export module DataViewConcatenateCategoricalColumns {\r\n\r\n        /* Represents a collection of DataViewCategoryColumn that are tied to the same role. */\r\n        interface CategoryColumnsByRole {\r\n            /* The name of the role shared by all the objects in the categories property. */\r\n            roleName: string;\r\n\r\n            /**\r\n             * The list of columns that are tied to roleName, in the same order as they appear\r\n             * in the categories property of their owner DataViewCategorical object.\r\n             */\r\n            categories: DataViewCategoryColumn[];\r\n        }\r\n\r\n        export function detectAndApply(\r\n            dataView: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            selects: DataViewSelectTransform[],\r\n            projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n\r\n            let result = dataView;\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            if (dataViewCategorical) {\r\n                let concatenationSource: CategoryColumnsByRole = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\r\n\r\n                if (concatenationSource) {\r\n                    // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\r\n                    let columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\r\n                    if (columnsSortedByProjectionOrdering.length >= 2) {\r\n                        let activeItemsToIgnoreInConcatenation =\r\n                            _.chain(projectionActiveItems[concatenationSource.roleName])\r\n                                .filter((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.suppressConcat)\r\n                                .map((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.queryRef)\r\n                                .value();\r\n\r\n                        result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\r\n        export function applyToPlayChartCategorical(\r\n            metadata: DataViewMetadata,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            categoryRoleName: string,\r\n            categorical: DataViewCategorical): DataView {\r\n            debug.assertValue(metadata, 'metadata');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let result: DataView;\r\n            if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\r\n                // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\r\n                // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\r\n                // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\r\n                // use inherit() rather than inheritSingle() here.\r\n                let transformingColumns = inherit(metadata.columns);\r\n                let transformingMetadata = inherit(metadata, m => { m.columns = transformingColumns; });\r\n\r\n                let transformingDataView = { metadata: transformingMetadata, categorical: categorical };\r\n                result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\r\n            }\r\n            else {\r\n                result = { metadata: metadata, categorical: categorical };\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the role and its assocated category columns (from dataViewCategorical.categories)\r\n         * that should be concatenated for the case of hierarchical group.\r\n         *\r\n         * Note: In the future if we support sibling hierarchical groups in categorical,\r\n         * change the return type to CategoryColumnsByRole[] and update detection logic.\r\n         */\r\n        function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical: DataViewCategorical, metadata: DataViewMetadata, dataViewMappings: DataViewMapping[], selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): CategoryColumnsByRole {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\r\n\r\n            let result: CategoryColumnsByRole;\r\n\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\r\n            let projections = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let supportedRoleMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            // The following code will choose a role name only if all supportedRoleMappings share the same role for Categorical Category.\r\n            // Handling multiple supportedRoleMappings is necessary for TransformActions with splits, which can happen in scenarios such as:\r\n            // 1. combo chart with a field for both Line and Column values, and\r\n            // 2. chart with regression line enabled.\r\n            // In case 1, you can pretty much get exactly the one from supportedRoleMappings for which this code is currently processing for,\r\n            // by looking at the index of the current split in DataViewTransformActions.splits.\r\n            // In case 2, however, supportedRoleMappings.length will be different than DataViewTransformActions.splits.length, hence it is\r\n            // not straight forward to figure out for which one in supportedRoleMappings is this code currently processing.\r\n            // SO... This code will just choose the category role name if it is consistent across all supportedRoleMappings.\r\n\r\n            let isEveryRoleMappingForCategorical = !_.isEmpty(supportedRoleMappings) &&\r\n                _.every(supportedRoleMappings, (roleMapping) => !!roleMapping.categorical);\r\n\r\n            if (isEveryRoleMappingForCategorical) {\r\n                let targetRoleName = getSingleCategoryRoleNameInEveryRoleMapping(supportedRoleMappings);\r\n                if (targetRoleName &&\r\n                    isVisualExpectingMaxOneCategoryColumn(targetRoleName, supportedRoleMappings)) {\r\n\r\n                    let categoryColumnsForTargetRole: DataViewCategoryColumn[] = _.filter(\r\n                        dataViewCategorical.categories,\r\n                        (categoryColumn: DataViewCategoryColumn) => categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName]);\r\n\r\n                    // There is no need to concatenate columns unless there is actually more than one column\r\n                    if (categoryColumnsForTargetRole.length >= 2) {\r\n                        // At least for now, we expect all category columns for the same role to have the same number of value entries.\r\n                        // If that's not the case, we won't run the concatenate logic for that role at all...\r\n                        let areValuesCountsEqual: boolean = _.every(\r\n                            categoryColumnsForTargetRole,\r\n                            (categoryColumn: DataViewCategoryColumn) => categoryColumn.values.length === categoryColumnsForTargetRole[0].values.length);\r\n                        \r\n                        if (areValuesCountsEqual) {\r\n                            result = {\r\n                                roleName: targetRoleName,\r\n                                categories: categoryColumnsForTargetRole,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** If all mappings in the specified roleMappings have the same single role name for their categorical category roles, return that role name, else returns undefined. */\r\n        function getSingleCategoryRoleNameInEveryRoleMapping(categoricalRoleMappings: DataViewMapping[]): string {\r\n            debug.assertNonEmpty(categoricalRoleMappings, 'categoricalRoleMappings');\r\n            debug.assert(_.every(categoricalRoleMappings, (roleMapping) => !!roleMapping.categorical), 'All mappings in categoricalRoleMappings must contain a DataViewCategoricalMapping');\r\n\r\n            let result: string;\r\n\r\n            // With \"list\" in role mapping, it is possible to have multiple role names for category.\r\n            // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\r\n            // We can change this if we want to support independent (sibling) group hierarchies in categorical.\r\n            let uniqueCategoryRoles: string[] = _.chain(categoricalRoleMappings)\r\n                .map((roleMapping) => {\r\n                    let categoryRoles = getAllRolesInCategories(roleMapping.categorical);\r\n                    return categoryRoles.length === 1 ? categoryRoles[0] : undefined;\r\n                })\r\n                .uniq() // Note: _.uniq() does not treat two arrays with same elements as equal\r\n                .value();\r\n            \r\n\r\n            let isSameCategoryRoleNameInAllRoleMappings = uniqueCategoryRoles.length === 1 && !_.isUndefined(uniqueCategoryRoles[0]);\r\n            if (isSameCategoryRoleNameInAllRoleMappings) {\r\n                result = uniqueCategoryRoles[0];\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function isVisualExpectingMaxOneCategoryColumn(categoricalRoleName: string, roleMappings: DataViewMapping[]): boolean {\r\n            debug.assertValue(categoricalRoleName, 'categoricalRoleName');\r\n            debug.assertNonEmpty(roleMappings, 'roleMappings');\r\n\r\n            let isVisualExpectingMaxOneCategoryColumn = _.every(\r\n                roleMappings,\r\n                (roleMapping) => {\r\n                    return !_.isEmpty(roleMapping.conditions) &&\r\n                        _.every(roleMapping.conditions, condition => condition[categoricalRoleName] && condition[categoricalRoleName].max === 1);\r\n                });\r\n\r\n            return isVisualExpectingMaxOneCategoryColumn;\r\n        }\r\n\r\n        /**\r\n         * Returns the array of role names that are mapped to categorical categories.\r\n         * Returns an empty array if none exists.\r\n         */\r\n        function getAllRolesInCategories(categoricalRoleMapping: DataViewCategoricalMapping): string[] {\r\n            debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\r\n\r\n            let roleNames: string[] = [];\r\n            DataViewMapping.visitCategoricalCategories(\r\n                categoricalRoleMapping.categories,\r\n                {\r\n                    visitRole: (roleName: string) => {\r\n                        roleNames.push(roleName);\r\n                    }\r\n                });\r\n\r\n            return roleNames;\r\n        }\r\n\r\n        function applyConcatenation(dataView: DataView, objectDescriptors: DataViewObjectDescriptors, roleName: string, columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let formatStringPropId: DataViewObjectPropertyIdentifier = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            let concatenatedValues: string[] = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\r\n\r\n            let columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, categoryColumn => categoryColumn.source);\r\n            let concatenatedColumnMetadata: DataViewMetadataColumn = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\r\n            let transformedDataView = inheritSingle(dataView);\r\n            addToMetadata(transformedDataView, concatenatedColumnMetadata);\r\n\r\n            let concatenatedCategoryColumn: DataViewCategoryColumn = createConcatenatedCategoryColumn(\r\n                columnsSortedByProjectionOrdering,\r\n                concatenatedColumnMetadata,\r\n                concatenatedValues);\r\n\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            let transformedCategoricalCategories: DataViewCategoryColumn[] = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\r\n            transformedCategoricalCategories.push(concatenatedCategoryColumn);\r\n\r\n            let transformedCategorical: DataViewCategorical = inheritSingle(dataViewCategorical);\r\n            transformedCategorical.categories = transformedCategoricalCategories;\r\n            transformedDataView.categorical = transformedCategorical;\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        function concatenateValues(columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[], formatStringPropId: DataViewObjectPropertyIdentifier): string[] {\r\n            debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\r\n            debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\r\n            debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\r\n\r\n            let concatenatedValues: string[] = [];\r\n\r\n            // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\r\n            for (let categoryColumn of columnsSortedByProjectionOrdering) {\r\n                let formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\r\n\r\n                for (let i = 0, len = categoryColumn.values.length; i < len; i++) {\r\n                    if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\r\n                        let value = categoryColumn.values && categoryColumn.values[i];\r\n                        let formattedValue = valueFormatter.format(value, formatString);\r\n                        concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return concatenatedValues;\r\n        }\r\n\r\n        /**\r\n        * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\r\n        */\r\n        function sortColumnsByProjectionOrdering(projectionOrdering: DataViewProjectionOrdering, roleName: string, columns: DataViewCategoryColumn[]): DataViewCategoryColumn[] {\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            let columnsInProjectionOrdering: DataViewCategoryColumn[];\r\n\r\n            if (projectionOrdering) {\r\n                // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\r\n                let columnsByIndex: { [index: number]: DataViewCategoricalColumn } = {};\r\n                for (let column of columns) {\r\n                    if (column.source.roles[roleName]) {\r\n                        debug.assert(!columnsByIndex[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\r\n                        columnsByIndex[column.source.index] = column;\r\n                    }\r\n                }\r\n\r\n                let columnIndicesInProjectionOrdering: number[] = projectionOrdering[roleName];\r\n\r\n                columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\r\n                    .map(columnIndex => columnsByIndex[columnIndex])\r\n                    .filter((column: DataViewCategoricalColumn) => !!column)\r\n                    .value();\r\n            }\r\n            else {\r\n                // If projectionOrder is unspecified, just return the columns for the specified role in their current order\r\n                columnsInProjectionOrdering = _.filter(columns, column => column.source.roles[roleName]);\r\n            }\r\n\r\n            return columnsInProjectionOrdering;\r\n        }\r\n\r\n        /**\r\n         * Creates the column metadata that will back the column with the concatenated values. \r\n         */\r\n        function createConcatenatedColumnMetadata(roleName: string, sourceColumnsSortedByProjectionOrdering: DataViewMetadataColumn[], queryRefsToIgnore?: string[]): DataViewMetadataColumn {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\r\n            debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(c => c.isMeasure).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\r\n\r\n            let concatenatedDisplayName: string;\r\n\r\n            for (let columnSource of sourceColumnsSortedByProjectionOrdering) {\r\n                if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\r\n                    concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\r\n                }\r\n            }\r\n\r\n            let newRoles: { [name: string]: boolean } = {};\r\n            newRoles[roleName] = true;\r\n\r\n            let newColumnMetadata: DataViewMetadataColumn = {\r\n                displayName: concatenatedDisplayName,\r\n                roles: newRoles,\r\n                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)\r\n            };\r\n\r\n            let columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\r\n            if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\r\n                newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\r\n            }\r\n\r\n            // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\r\n            // If queryName is not set at all, the column chart visual will only render column for the first group instance.\r\n            // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\r\n            newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\r\n\r\n            return newColumnMetadata;\r\n        }\r\n\r\n        function addToMetadata(transformedDataView: DataView, newColumn: DataViewMetadataColumn): void {\r\n            debug.assertValue(transformedDataView, 'transformedDataView');\r\n            debug.assertValue(newColumn, 'newColumn');\r\n\r\n            let transformedColumns = inheritSingle(transformedDataView.metadata.columns);\r\n            transformedColumns.push(newColumn);\r\n\r\n            let transformedMetadata = inheritSingle(transformedDataView.metadata);\r\n            transformedMetadata.columns = transformedColumns;\r\n\r\n            transformedDataView.metadata = transformedMetadata;\r\n        }\r\n\r\n        function createConcatenatedCategoryColumn(\r\n            sourceColumnsSortedByProjectionOrdering: DataViewCategoryColumn[],\r\n            columnMetadata: DataViewMetadataColumn,\r\n            concatenatedValues: string[]): DataViewCategoryColumn {\r\n            debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let newCategoryColumn: DataViewCategoryColumn = {\r\n                source: columnMetadata,\r\n                values: concatenatedValues\r\n            };\r\n\r\n            // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\r\n            // So, we'll just take the identities and identityFields from the first column\r\n            let firstColumn = sourceColumnsSortedByProjectionOrdering[0];\r\n\r\n            if (firstColumn.identity) {\r\n                newCategoryColumn.identity = firstColumn.identity;\r\n            }\r\n\r\n            if (firstColumn.identityFields) {\r\n                newCategoryColumn.identityFields = firstColumn.identityFields;\r\n            }\r\n\r\n            // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\r\n            if (firstColumn.objects) {\r\n                newCategoryColumn.objects = firstColumn.objects;\r\n            }\r\n\r\n            return newCategoryColumn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export const enum RoleItemContext {\r\n        CategoricalValue,\r\n        CategoricalValueGroup,\r\n    }\r\n\r\n    export interface IDataViewMappingVisitor {\r\n        visitRole(role: string, context?: RoleItemContext): void;\r\n        visitReduction?(reductionAlgorithm?: ReductionAlgorithm): void;\r\n    }\r\n\r\n    export module DataViewMapping {\r\n        export function visitMapping(mapping: DataViewMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let categorical = mapping.categorical;\r\n            if (categorical)\r\n                visitCategorical(categorical, visitor);\r\n\r\n            let table = mapping.table;\r\n            if (table)\r\n                visitTable(table, visitor);\r\n\r\n            let matrix = mapping.matrix;\r\n            if (matrix)\r\n                visitMatrix(matrix, visitor);\r\n\r\n            let tree = mapping.tree;\r\n            if (tree)\r\n                visitTree(tree, visitor);\r\n            \r\n            let single = mapping.single;\r\n            if (single)\r\n                visitSingle(single, visitor);\r\n        }\r\n\r\n        export function visitCategorical(mapping: DataViewCategoricalMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitCategoricalCategories(mapping.categories, visitor);\r\n\r\n            visitCategoricalValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitCategoricalCategories(mapping: DataViewRoleMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitCategoricalValues(mapping: DataViewRoleMapping | DataViewGroupedRoleMapping | DataViewListRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n\r\n                let groupedRoleMapping = <DataViewGroupedRoleMapping>mapping;\r\n                visitGrouped(groupedRoleMapping, visitor);\r\n\r\n                let group = groupedRoleMapping.group;\r\n                if (group) {\r\n                    for (let item of group.select) {\r\n                        visitBind(<DataViewRoleBindMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                        visitFor(<DataViewRoleForMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitTable(mapping: DataViewTableMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let rows = mapping.rows;\r\n            visitBind(<DataViewRoleBindMapping>rows, visitor);\r\n            visitFor(<DataViewRoleForMapping>rows, visitor);\r\n            visitList(<DataViewListRoleMapping>rows, visitor);\r\n\r\n            visitReduction(rows, visitor);\r\n        }\r\n\r\n        function visitMatrix(mapping: DataViewMatrixMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitMatrixItems(mapping.rows, visitor);\r\n            visitMatrixItems(mapping.columns, visitor);\r\n            visitMatrixItems(mapping.values, visitor);\r\n        }\r\n\r\n        /**\r\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         *\r\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         * @param visitor The visitor.\r\n         */\r\n        export function visitMatrixItems(mapping: DataViewRoleForMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitTree(mapping: DataViewTreeMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitTreeNodes(mapping.nodes, visitor);\r\n            visitTreeValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitTreeNodes(mapping: DataViewRoleForMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitTreeValues(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitBind(mapping: DataViewRoleBindMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let bind = mapping.bind;\r\n            if (bind) {\r\n                if (context != null)\r\n                    visitor.visitRole(bind.to, context);\r\n                else\r\n                    visitor.visitRole(bind.to);\r\n            }\r\n        }\r\n\r\n        function visitFor(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let forValue = mapping.for;\r\n            if (forValue) {\r\n                if (context != null)\r\n                    visitor.visitRole(forValue.in, context);\r\n                else\r\n                    visitor.visitRole(forValue.in);\r\n            }\r\n        }\r\n\r\n        function visitList(mapping: DataViewListRoleMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let select = mapping.select;\r\n            if (select) {\r\n                for (let item of select) {\r\n                    visitBind(<DataViewRoleBindMapping>item, visitor, context);\r\n                    visitFor(<DataViewRoleForMapping>item, visitor, context);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitGrouped(mapping: DataViewGroupedRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (!mapping)\r\n                return;\r\n\r\n            let group = mapping.group;\r\n            if (group) {\r\n                visitor.visitRole(group.by);\r\n\r\n                visitReduction(group, visitor);\r\n            }\r\n        }\r\n\r\n        function visitReduction(mapping: HasReductionAlgorithm, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (visitor.visitReduction) {\r\n                let reductionAlgorithm = mapping.dataReductionAlgorithm;\r\n                if (reductionAlgorithm) {\r\n                    visitor.visitReduction(reductionAlgorithm);\r\n                }\r\n            }\r\n        }\r\n\r\n        function visitSingle(mapping: DataViewSingleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitor.visitRole(mapping.role);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inheritSingle = Prototype.inheritSingle;\r\n\r\n    export interface DataViewNormalizeValuesApplyOptions {\r\n        dataview: DataView;\r\n        dataViewMappings: DataViewMapping[];\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a column is tied to any role that has required type(s).\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns true iff the column in the specified columnIndex is tied to any role that has required type(s), i.e. if the value in that column potentially needs to get normalized.\r\n     */\r\n    export interface IMetadataColumnFilter {\r\n        (columnIndex: number): boolean;\r\n    }\r\n\r\n    /**\r\n     * Returns true iff the specified value is of matching type as required by the role assigned to the column associated with this filter object.\r\n     */\r\n    export interface IColumnValueFilter {\r\n        (value: any): boolean;\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns false iff the specified value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     */\r\n    export interface IValueFilter {\r\n        (columnIndex: number, value: any): boolean;\r\n    }\r\n\r\n    export module DataViewNormalizeValues {\r\n        export function apply(options: DataViewNormalizeValuesApplyOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let rolesToNormalize = _.filter(options.dataRoles, role => !_.isEmpty(role.requiredTypes));\r\n\r\n            filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\r\n        }\r\n\r\n        export function filterVariantMeasures(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[]): void {\r\n            debug.assertValue(dataview, 'dataview');\r\n\r\n            // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\r\n                return;\r\n\r\n            let columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\r\n            let valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\r\n\r\n            let usedMappings = {};\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                // Get dataview specified in mappings which are also in dataview\r\n                for (let dataViewMappingProp in dataViewMapping) {\r\n                    if (dataview[dataViewMappingProp] != null)\r\n                        usedMappings[dataViewMappingProp] = true;\r\n                }\r\n            }\r\n\r\n            if (usedMappings['categorical'])\r\n                filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\r\n            if (usedMappings['table'])\r\n                filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\r\n            if (usedMappings['tree'])\r\n                filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\r\n            if (usedMappings['matrix'])\r\n                filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\r\n            if (usedMappings['single'])\r\n                filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\r\n        }\r\n\r\n        export function generateMetadataColumnFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IMetadataColumnFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => false;\r\n\r\n            let columnsToNormalize = {};\r\n            for (let column of columns) {\r\n                let roles = column.roles;\r\n                if (!roles)\r\n                    continue;\r\n                for (let role of rolesToNormalize) {\r\n                    if (!roles[role.name])\r\n                        continue;\r\n                    columnsToNormalize[column.index] = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return (columnIndex: number) => {\r\n                if (isNaN(columnIndex))\r\n                    return false;\r\n\r\n                return !!columnsToNormalize[columnIndex];\r\n            };\r\n        }\r\n\r\n        export function generateValueFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IValueFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => true;\r\n\r\n            let columnValueFilters: IColumnValueFilter[] = [];\r\n\r\n            // Build columnValueFilters based on role requiredTypes\r\n            for (let column of columns) {\r\n                let columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\r\n\r\n                if (columnValueFilter)\r\n                    columnValueFilters[column.index] = columnValueFilter;\r\n            }\r\n\r\n            return <IValueFilter>(columnIndex: number, value: any) => {\r\n                if (columnValueFilters[columnIndex])\r\n                    return columnValueFilters[columnIndex](value);\r\n\r\n                return true;\r\n            };\r\n        }\r\n\r\n        function generateColumnValueFilter(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): IColumnValueFilter {\r\n            let requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\r\n\r\n            if (_.isEmpty(requiredTypes))\r\n                return;\r\n\r\n            return (value: any): boolean => {\r\n                return doesValueMatchTypes(value, requiredTypes);\r\n            };\r\n        }\r\n\r\n        export function getColumnRequiredTypes(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): ValueType[] {\r\n            let requiredTypes = [];\r\n            let columnRoles = column && column.roles;\r\n\r\n            if (!columnRoles)\r\n                return requiredTypes;\r\n\r\n            for (let role of rolesToNormalize) {\r\n                if (!columnRoles[role.name])\r\n                    continue;\r\n                for (let typeDescriptor of role.requiredTypes) {\r\n                    let type = ValueType.fromDescriptor(typeDescriptor);\r\n                    requiredTypes.push(type);\r\n                }\r\n            }\r\n\r\n            return requiredTypes;\r\n        }\r\n\r\n        function filterVariantMeasuresCategorical(dataview: DataViewCategorical, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let values = dataview && dataview.values;\r\n            if (!values)\r\n                return;\r\n\r\n            let valuesGrouped = values.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            for (let valueGroup of valuesGrouped) {\r\n                let valuesInGroup = valueGroup.values;\r\n                for (let valueColumn of valuesInGroup) {\r\n                    let columnIndex = valueColumn.source.index;\r\n                    if (!columnFilter(columnIndex))\r\n                        continue;\r\n\r\n                    for (let i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\r\n                        valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTable(dataview: DataViewTable, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let columns = dataview && dataview.columns;\r\n\r\n            if (!columns)\r\n                return;\r\n\r\n            let filteredColumns = [];\r\n            for (let column of columns) {\r\n                if (columnFilter(column.index))\r\n                    filteredColumns.push(column.index);\r\n            }\r\n\r\n            let rows = dataview.rows;\r\n            for (let i = 0, ilen = rows.length; i < ilen; i++) {\r\n                for (let index of filteredColumns) {\r\n                    rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTreeNode(node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let columnIndex in node.values) {\r\n                    // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\r\n                    if (columnFilter(<any>columnIndex)) {\r\n                        // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\r\n                        if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\r\n                            node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', <any>columnIndex, valueFilter);\r\n                        else // if node.values[columnIndex] is a primitive value\r\n                            node.values = normalizeVariant(node.values, columnIndex, <any>columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresMatrix(dataview: DataViewMatrix, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let root = dataview && dataview.rows && dataview.rows.root;\r\n\r\n            if (!root)\r\n                return;\r\n\r\n            // Recurse into rows.children\r\n            // e.g. rows.children -> .children -> .children.values\r\n            filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\r\n        }\r\n\r\n        function filterVariantMeasuresMatrixRecursive(dataviewMatrix: DataViewMatrix, node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let id in node.values) {\r\n                    // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\r\n                    let nodeValue: DataViewMatrixNodeValue = node.values[id];\r\n\r\n                    // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\r\n                    let valueSourceIndex: number = nodeValue.valueSourceIndex || 0;\r\n\r\n                    // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\r\n                    let columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\r\n\r\n                    if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\r\n                        node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresSingle(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[], valueFilter: IValueFilter): void {\r\n            if (!dataview.single)\r\n                return;\r\n\r\n            let roleNames: string[] = [];\r\n            for (let role of rolesToNormalize) {\r\n                if (role.name)\r\n                    roleNames.push(role.name);\r\n            }\r\n\r\n            let columns = dataview.metadata.columns;\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                let roleName = dataViewMapping.single.role;\r\n                if (roleNames.indexOf(roleName) !== -1) {\r\n                    let column = firstColumnByRoleName(columns, roleName);\r\n                    if (column)\r\n                        dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        export function normalizeVariant<T>(object: T, key: string|number, columnIndex: number, valueFilter: IValueFilter): T {\r\n            if (!object)\r\n                return;\r\n\r\n            let value = object[key];\r\n            if (value !== null && !valueFilter(columnIndex, value)) {\r\n                object = inheritSingle(object);\r\n                object[key] = null;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        function doesValueMatchTypes<T>(value: T, types: ValueType[]): boolean {\r\n            for (let type of types) {\r\n                if (type.numeric || type.integer)\r\n                    return typeof (value) === 'number';\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function firstColumnByRoleName(columns: DataViewMetadataColumn[], roleName: string): DataViewMetadataColumn {\r\n            for (let column of columns) {\r\n                let columnRoles = column && column.roles;\r\n                if (columnRoles && columnRoles[roleName])\r\n                    return column;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewObjects {\r\n        /** Gets the value of the given object/property pair. */\r\n        export function getValue<T>(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultValue?: T): T {\r\n            debug.assertAnyValue(objects, 'objects');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            if (!objects)\r\n                return defaultValue;\r\n\r\n            let objectOrMap = objects[propertyId.objectName];\r\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\r\n\r\n            let object = <DataViewObject>objectOrMap;\r\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\r\n        }\r\n\r\n        /** Gets an object from objects. */\r\n        export function getObject(objects: DataViewObjects, objectName: string, defaultValue?: DataViewObject): DataViewObject {\r\n            if (objects && objects[objectName]) {\r\n                let object = <DataViewObject>objects[objectName];\r\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\r\n                return object;\r\n            }\r\n            else {\r\n                return defaultValue;\r\n            }\r\n        }\r\n\r\n        /** Gets a map of user-defined objects. */\r\n        export function getUserDefinedObjects(objects: DataViewObjects, objectName: string): DataViewObjectMap {\r\n            if (objects && objects[objectName]) {\r\n                let map = <DataViewObjectMap>objects[objectName];\r\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\r\n                return map;\r\n            }\r\n        }\r\n\r\n        /** Gets the solid color from a fill property. */\r\n        export function getFillColor(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultColor?: string): string {\r\n            let value: Fill = getValue(objects, propertyId);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n\r\n        /** Returns true if the given object represents a collection of user-defined objects */\r\n        export function isUserDefined(objectOrMap: DataViewObject | DataViewObjectMap): boolean {\r\n            return _.isArray(objectOrMap);\r\n        }\r\n    }\r\n\r\n    export module DataViewObject {\r\n        export function getValue<T>(object: DataViewObject, propertyName: string, defaultValue?: T): T {\r\n            debug.assertAnyValue(object, 'object');\r\n            debug.assertValue(propertyName, 'propertyName');\r\n\r\n            if (!object)\r\n                return defaultValue;\r\n\r\n            let propertyValue = <T>object[propertyName];\r\n            if (propertyValue === undefined)\r\n                return defaultValue;\r\n\r\n            return propertyValue;\r\n        }\r\n\r\n        /** Gets the solid color from a fill property using only a propertyName */\r\n        export function getFillColorByPropertyName(objects: DataViewObjects, propertyName: string, defaultColor?: string): string {\r\n            let value: Fill = DataViewObject.getValue(objects, propertyName);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import JsonComparer = jsCommon.JsonComparer;\r\n\r\n    /** Defines the values for particular objects. */\r\n    export interface DataViewObjectDefinitions {\r\n        [objectName: string]: DataViewObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinition {\r\n        selector?: Selector;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export interface DataViewObjectPropertyDefinitions {\r\n        [name: string]: DataViewObjectPropertyDefinition;\r\n    }\r\n\r\n    export type DataViewObjectPropertyDefinition = SQExpr | StructuralObjectDefinition;\r\n\r\n    export module DataViewObjectDefinitions {\r\n\r\n        /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\r\n        export function ensure(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                defns[objectName] = defnsForObject = [];\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n\r\n            let newDefn: DataViewObjectDefinition = {\r\n                selector: selector,\r\n                properties: {},\r\n            };\r\n            defnsForObject.push(newDefn);\r\n\r\n            return newDefn;\r\n        }\r\n\r\n        export function deleteProperty(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector,\r\n            propertyName: string): void {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defn = getObjectDefinition(defns, objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\r\n        }\r\n        \r\n        export function setValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n            debug.assertValue(defns, 'defns');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        export function getValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinition {\r\n\r\n            let properties = getPropertyContainer(defns, propertyId, selector);\r\n            if (!properties)\r\n                return;\r\n\r\n            return properties[propertyId.propertyName];\r\n        }\r\n\r\n        export function getPropertyContainer(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinitions {\r\n\r\n            let defn = getObjectDefinition(defns, propertyId.objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            return defn.properties;\r\n        }\r\n\r\n        export function getObjectDefinition(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertAnyValue(defns, 'defns');\r\n            debug.assertValue(objectName, 'objectName');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!defns)\r\n                return;\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                return;\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n        }\r\n\r\n        export function propertiesAreEqual(a: DataViewObjectPropertyDefinition, b: DataViewObjectPropertyDefinition): boolean {\r\n            if (a instanceof SemanticFilter && b instanceof SemanticFilter) {\r\n                return SemanticFilter.isSameFilter(<SemanticFilter>a, <SemanticFilter>b);\r\n            }\r\n\r\n            return JsonComparer.equals(a, b);\r\n        }\r\n\r\n        export function allPropertiesAreEqual(a: DataViewObjectPropertyDefinitions, b: DataViewObjectPropertyDefinitions): boolean {\r\n            debug.assertValue(a, 'a');\r\n            debug.assertValue(b, 'b');\r\n\r\n            if (Object.keys(a).length !== Object.keys(b).length)\r\n                return false;\r\n\r\n            for (let property in a) {\r\n                if (!propertiesAreEqual(a[property], b[property]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function encodePropertyValue(value: DataViewPropertyValue, valueTypeDescriptor: ValueTypeDescriptor): DataViewObjectPropertyDefinition {\r\n            debug.assertAnyValue(value, 'value');\r\n            debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\r\n\r\n            if (valueTypeDescriptor.bool) {\r\n                if (typeof (value) !== 'boolean')\r\n                    value = false; // This is fallback, which doesn't really belong here.\r\n\r\n                return SQExprBuilder.boolean(<boolean>value);\r\n            }\r\n            else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\r\n                return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.numeric) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).fill) {\r\n                if (value) {\r\n                    return {\r\n                        solid: { color: SQExprBuilder.text(<string>value) }\r\n                    };\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.formatting) {\r\n                if (valueTypeDescriptor.formatting.labelDisplayUnits) {\r\n                    return SQExprBuilder.double(+value);\r\n                }\r\n                else {\r\n                    return SQExprBuilder.text(<string>value);\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.enumeration) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n                else\r\n                    return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.misc) {\r\n                if (value) {\r\n                    value = SQExprBuilder.text(<string>value);\r\n                } else {\r\n                    value = null;\r\n                }\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).image) {\r\n                if (value) {\r\n                    let imageValue = <ImageValue>value;\r\n                    let imageDefinition: ImageDefinition = {\r\n                        name: SQExprBuilder.text(imageValue.name),\r\n                        url: SQExprBuilder.text(imageValue.url),\r\n                    };\r\n\r\n                    if (imageValue.scaling)\r\n                        imageDefinition.scaling = SQExprBuilder.text(imageValue.scaling);\r\n\r\n                    return imageDefinition;\r\n                }\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        export function clone(original: DataViewObjectDefinitions): DataViewObjectDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            let cloned: DataViewObjectDefinitions = {};\r\n\r\n            for (let objectName in original) {\r\n                let originalDefns = original[objectName];\r\n                if (_.isEmpty(originalDefns))\r\n                    continue;\r\n\r\n                let clonedDefns: DataViewObjectDefinition[] = [];\r\n                for (let originalDefn of originalDefns) {\r\n                    clonedDefns.push({\r\n                        properties: cloneProperties(originalDefn.properties),\r\n                        selector: originalDefn.selector,\r\n                    });\r\n                }\r\n                cloned[objectName] = clonedDefns;\r\n            }\r\n\r\n            return cloned;\r\n        }\r\n\r\n        function cloneProperties(original: DataViewObjectPropertyDefinitions): DataViewObjectPropertyDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\r\n            return _.clone(original);\r\n        }\r\n    }\r\n\r\n    export module DataViewObjectDefinition {\r\n\r\n        export function deleteSingleProperty(\r\n            defn: DataViewObjectDefinition,\r\n            propertyName: string): void {\r\n\r\n            //note: We decided that delete is acceptable here and that we don't need optimization here\r\n            delete defn.properties[propertyName];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module DataViewObjectDescriptors {\r\n        /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\r\n        export function findFormatString(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let formattingTypeDesc = ValueType.fromDescriptor(propDesc.type).formatting;\r\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\r\n        export function findFilterOutput(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.filter;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\r\n        export function findDefaultValue(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.expression && propType.expression.defaultValue;\r\n                });\r\n        }\r\n\r\n        function findProperty(descriptors: DataViewObjectDescriptors, propPredicate: (propDesc: DataViewObjectPropertyDescriptor) => boolean): DataViewObjectPropertyIdentifier {\r\n            debug.assertAnyValue(descriptors, 'descriptors');\r\n            debug.assertAnyValue(propPredicate, 'propPredicate');\r\n\r\n            if (!descriptors)\r\n                return;\r\n\r\n            for (let objectName in descriptors) {\r\n                let objPropDescs = descriptors[objectName].properties;\r\n\r\n                for (let propertyName in objPropDescs) {\r\n                    if (propPredicate(objPropDescs[propertyName])) {\r\n                        return {\r\n                            objectName: objectName,\r\n                            propertyName: propertyName,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n*  Power BI Visualizations\r\n*\r\n*  Copyright (c) Microsoft Corporation\r\n*  All rights reserved. \r\n *  MIT License\r\n*\r\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n*  in the Software without restriction, including without limitation the rights\r\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*  copies of the Software, and to permit persons to whom the Software is\r\n*  furnished to do so, subject to the following conditions:\r\n*   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n*   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n*  THE SOFTWARE.\r\n*/\r\n\r\nmodule powerbi.data {\r\n    export interface DataViewObjectDefinitionsByRepetition {\r\n        metadataOnce?: DataViewObjectDefinitionsForSelector;\r\n        userDefined?: DataViewObjectDefinitionsForSelector[];\r\n        metadata?: DataViewObjectDefinitionsForSelector[];\r\n        data: DataViewObjectDefinitionsForSelectorWithRule[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelector {\r\n        selector?: Selector;\r\n        objects: DataViewNamedObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelectorWithRule extends DataViewObjectDefinitionsForSelector {\r\n        rules?: RuleEvaluation[];\r\n    }\r\n\r\n    export interface DataViewNamedObjectDefinition {\r\n        name: string;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export module DataViewObjectEvaluationUtils {\r\n        export function evaluateDataViewObjects(\r\n            evalContext: IEvalContext,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewObjects {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let objects: DataViewObjects;\r\n\r\n            for (let j = 0, jlen = objectDefns.length; j < jlen; j++) {\r\n                let objectDefinition = objectDefns[j],\r\n                    objectName = objectDefinition.name;\r\n\r\n                let evaluatedObject: DataViewObject = DataViewObjectEvaluator.run(\r\n                    evalContext,\r\n                    objectDescriptors[objectName],\r\n                    objectDefinition.properties);\r\n\r\n                if (!evaluatedObject)\r\n                    continue;\r\n\r\n                if (!objects)\r\n                    objects = {};\r\n\r\n                // NOTE: this currently has last-object-wins semantics.\r\n                objects[objectName] = evaluatedObject;\r\n            }\r\n\r\n            return objects;\r\n        }\r\n\r\n        export function groupObjectsBySelector(objectDefinitions: DataViewObjectDefinitions): DataViewObjectDefinitionsByRepetition {\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n\r\n            let grouped: DataViewObjectDefinitionsByRepetition = {\r\n                data: [],\r\n            };\r\n\r\n            if (objectDefinitions) {\r\n                for (let objectName in objectDefinitions) {\r\n                    let objectDefnList = objectDefinitions[objectName];\r\n\r\n                    for (let i = 0, len = objectDefnList.length; i < len; i++) {\r\n                        let objectDefn = objectDefnList[i];\r\n\r\n                        ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\r\n                            name: objectName,\r\n                            properties: objectDefn.properties,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return grouped;\r\n        }\r\n\r\n        function ensureDefinitionListForSelector(grouped: DataViewObjectDefinitionsByRepetition, selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(grouped, 'grouped');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!selector) {\r\n                if (!grouped.metadataOnce)\r\n                    grouped.metadataOnce = { objects: [] };\r\n                return grouped.metadataOnce;\r\n            }\r\n\r\n            let groupedObjects: DataViewObjectDefinitionsForSelector[];\r\n            if (selector.data) {\r\n                groupedObjects = grouped.data;\r\n            }\r\n            else if (selector.metadata) {\r\n                if (!grouped.metadata)\r\n                    grouped.metadata = [];\r\n                groupedObjects = grouped.metadata;\r\n            }\r\n            else if (selector.id) {\r\n                if (!grouped.userDefined)\r\n                    grouped.userDefined = [];\r\n                groupedObjects = grouped.userDefined;\r\n            }\r\n\r\n            debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\r\n\r\n            for (let item of groupedObjects) {\r\n                if (Selector.equals(selector, item.selector))\r\n                    return item;\r\n            }\r\n\r\n            let item: DataViewObjectDefinitionsForSelector = {\r\n                selector: selector,\r\n                objects: [],\r\n            };\r\n            groupedObjects.push(item);\r\n\r\n            return item;\r\n        }\r\n\r\n        export function addImplicitObjects(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            if (selectTransforms) {\r\n                addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n                addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n            }\r\n        }\r\n\r\n        function addDefaultFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let formatStringProp = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            if (!formatStringProp)\r\n                return;\r\n\r\n            for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n                let selectTransform = selectTransforms[selectIdx];\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyFormatString(\r\n                    objectsForAllSelectors,\r\n                    formatStringProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\r\n            }\r\n        }\r\n\r\n        /** Registers properties for default value, if the properties are not explicitly provided. */\r\n        function addDefaultValue (\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let defaultValueProp = DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\r\n            if (!defaultValueProp)\r\n                return;\r\n\r\n            for (let selectTransform of selectTransforms) {\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyDefaultValue(\r\n                    objectsForAllSelectors,\r\n                    defaultValueProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.defaultValue);\r\n            }\r\n        }\r\n\r\n        function getColumnFormatForIndex(columns: DataViewMetadataColumn[], selectIdx: number): string {\r\n            for (let columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\r\n                let column = columns[columnIdx];\r\n                if (!column || column.index !== selectIdx)\r\n                    continue;\r\n\r\n                return column.format;\r\n            }\r\n        }\r\n\r\n        function applyFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            formatStringProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            formatStringValue: string): void {\r\n            if (!formatStringValue)\r\n                return;\r\n\r\n            // There is a format string specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                formatStringProp,\r\n                { metadata: queryName },\r\n                SQExprBuilder.text(formatStringValue));\r\n        }\r\n\r\n        function applyDefaultValue(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            defaultValueProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            defaultValue: DefaultValueDefinition): void {\r\n            if (!defaultValue)\r\n                return;\r\n\r\n            // There is a default value specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                defaultValueProp,\r\n                { metadata: queryName },\r\n                defaultValue);\r\n        }\r\n\r\n        function applyMetadataProperty(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n\r\n            let objectDefns: DataViewObjectDefinitionsForSelector[];\r\n            if (selector) {\r\n                let metadataObjects = objectsForAllSelectors.metadata;\r\n                if (!metadataObjects)\r\n                    metadataObjects = objectsForAllSelectors.metadata = [];\r\n                objectDefns = metadataObjects;\r\n            }\r\n            else {\r\n                let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n                if (!metadataOnce)\r\n                    metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\r\n                objectDefns = [metadataOnce];\r\n            }\r\n\r\n            let targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\r\n            let targetObjectDefn: DataViewNamedObjectDefinition;\r\n            if (targetMetadataObject) {\r\n                let targetObjectDefns = targetMetadataObject.objects;\r\n                targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\r\n                if (targetObjectDefn) {\r\n                    if (targetObjectDefn.properties[propertyId.propertyName])\r\n                        return;\r\n                }\r\n                else {\r\n                    targetObjectDefn = {\r\n                        name: propertyId.objectName,\r\n                        properties: {},\r\n                    };\r\n                    targetObjectDefns.push(targetObjectDefn);\r\n                }\r\n            }\r\n            else {\r\n                targetObjectDefn = {\r\n                    name: propertyId.objectName,\r\n                    properties: {}\r\n                };\r\n\r\n                objectDefns.push({\r\n                    selector: selector,\r\n                    objects: [targetObjectDefn],\r\n                });\r\n            }\r\n\r\n            targetObjectDefn.properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        function findWithMatchingSelector(objects: DataViewObjectDefinitionsForSelector[], selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(objects, 'objects');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            for (let i = 0, len = objects.length; i < len; i++) {\r\n                let object = objects[i];\r\n                if (Selector.equals(object.selector, selector))\r\n                    return object;\r\n            }\r\n        }\r\n\r\n        function findExistingObject(objectDefns: DataViewNamedObjectDefinition[], objectName: string): DataViewNamedObjectDefinition {\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(objectName, 'objectName');\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefn = objectDefns[i];\r\n\r\n                if (objectDefn.name === objectName)\r\n                    return objectDefn;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n \r\n\r\nmodule powerbi.data {\r\n    /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\r\n    export module DataViewObjectEvaluator {\r\n        const colorValueType: ValueType = ValueType.fromDescriptor({ formatting: { color: true } });\r\n        const numericType: ValueType = ValueType.fromDescriptor({ numeric: true });\r\n        const textType: ValueType = ValueType.fromDescriptor({ text: true });\r\n\r\n        export function run(\r\n            evalContext: IEvalContext,\r\n            objectDescriptor: DataViewObjectDescriptor,\r\n            propertyDefinitions: DataViewObjectPropertyDefinitions): DataViewObject {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\r\n            debug.assertValue(propertyDefinitions, 'propertyDefinitions');\r\n\r\n            if (!objectDescriptor)\r\n                return;\r\n\r\n            let object: DataViewObject,\r\n                propertyDescriptors = objectDescriptor.properties;\r\n            for (let propertyName in propertyDefinitions) {\r\n                let propertyDefinition = propertyDefinitions[propertyName],\r\n                    propertyDescriptor = propertyDescriptors[propertyName];\r\n\r\n                if (!propertyDescriptor)\r\n                    continue;\r\n\r\n                let propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\r\n                if (propertyValue === undefined)\r\n                    continue;\r\n\r\n                if (!object)\r\n                    object = {};\r\n                object[propertyName] = propertyValue;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        /** Note: Exported for testability */\r\n        export function evaluateProperty(\r\n            evalContext: IEvalContext,\r\n            propertyDescriptor: DataViewObjectPropertyDescriptor,\r\n            propertyDefinition: DataViewObjectPropertyDefinition): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(propertyDescriptor, 'propertyDescriptor');\r\n            debug.assertValue(propertyDefinition, 'propertyDefinition');\r\n\r\n            let structuralType = <StructuralTypeDescriptor>propertyDescriptor.type;\r\n            if (structuralType && structuralType.expression)\r\n                return propertyDefinition;\r\n\r\n            let value = evaluateValue(evalContext, <any>propertyDefinition, ValueType.fromDescriptor(propertyDescriptor.type));\r\n            if (value !== undefined || (propertyDefinition instanceof RuleEvaluation))\r\n                return value;\r\n\r\n            return evaluateFill(evalContext, <FillDefinition>propertyDefinition, structuralType)\r\n                || evaluateFillRule(evalContext, <FillRuleDefinition>propertyDefinition, structuralType)\r\n                || evaluateImage(evalContext, <ImageDefinition>propertyDefinition, structuralType)\r\n                || evaluateParagraphs(evalContext, <ParagraphsDefinition>propertyDefinition, structuralType)\r\n                || propertyDefinition;\r\n        }\r\n\r\n        function evaluateFill(evalContext: IEvalContext, fillDefn: FillDefinition, type: StructuralTypeDescriptor): Fill {\r\n            let fillType = type.fill;\r\n            if (!fillType)\r\n                return;\r\n\r\n            if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\r\n                return {\r\n                    solid: {\r\n                        color: evaluateValue(evalContext, fillDefn.solid.color, ValueType.fromExtendedType(ExtendedType.Color)),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateFillRule(evalContext: IEvalContext, fillRuleDefn: FillRuleDefinition, type: StructuralTypeDescriptor): FillRule {\r\n            if (!type.fillRule)\r\n                return;\r\n\r\n            if (fillRuleDefn.linearGradient2) {\r\n                let linearGradient2 = fillRuleDefn.linearGradient2;\r\n                return {\r\n                    linearGradient2: {\r\n                        min: evaluateColorStop(evalContext, linearGradient2.min),\r\n                        max: evaluateColorStop(evalContext, linearGradient2.max),\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (fillRuleDefn.linearGradient3) {\r\n                let linearGradient3 = fillRuleDefn.linearGradient3;\r\n                return {\r\n                    linearGradient3: {\r\n                        min: evaluateColorStop(evalContext, linearGradient3.min),\r\n                        mid: evaluateColorStop(evalContext, linearGradient3.mid),\r\n                        max: evaluateColorStop(evalContext, linearGradient3.max),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateColorStop(evalContext: IEvalContext, colorStop: RuleColorStopDefinition): RuleColorStop {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(colorStop, 'colorStop');\r\n\r\n            let step: RuleColorStop = {\r\n                color: evaluateValue(evalContext, colorStop.color, colorValueType),\r\n            };\r\n\r\n            let value = evaluateValue(evalContext, colorStop.value, numericType);\r\n            if (value != null)\r\n                step.value = value;\r\n\r\n            return step;\r\n        }\r\n\r\n        function evaluateImage(evalContext: IEvalContext, definition: ImageDefinition, type: StructuralTypeDescriptor): ImageValue {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.image || !definition)\r\n                return;\r\n\r\n            let value: ImageValue = {\r\n                name: evaluateValue(evalContext, definition.name, textType),\r\n                url: evaluateValue(evalContext, definition.url, ValueType.fromDescriptor(ImageDefinition.urlType)),\r\n            };\r\n\r\n            if (definition.scaling)\r\n                value.scaling = evaluateValue(evalContext, definition.scaling, textType);\r\n\r\n            return value;\r\n        }\r\n\r\n        function evaluateParagraphs(evalContext: IEvalContext, definition: ParagraphsDefinition, type: StructuralTypeDescriptor): Paragraphs {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.paragraphs || !definition)\r\n                return;\r\n\r\n            return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\r\n        }\r\n\r\n        function evaluateParagraph(evalContext: IEvalContext, definition: ParagraphDefinition): Paragraph {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: Paragraph;\r\n\r\n            let definitionTextRuns = definition.textRuns;\r\n            let evaluatedTextRuns: TextRun[] = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\r\n            if (definitionTextRuns !== evaluatedTextRuns) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.textRuns = evaluatedTextRuns;\r\n            }\r\n\r\n            return evaluated || <Paragraph>definition;\r\n        }\r\n\r\n        function evaluateTextRun(evalContext: IEvalContext, definition: TextRunDefinition): TextRun {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: TextRun;\r\n\r\n            let definitionValue = definition.value;\r\n            let evaluatedValue = evaluateValue(evalContext, <any> definitionValue, textType);\r\n            if (evaluatedValue !== undefined) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.value = evaluatedValue;\r\n            }\r\n\r\n            return evaluated || <TextRun>definition;\r\n        }\r\n\r\n        /**\r\n         * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\r\n         * other than the input to it.\r\n         */\r\n        function evaluateArrayCopyOnChange<TDefinition, TEvaluated>(\r\n            evalContext: IEvalContext,\r\n            definitions: TDefinition[],\r\n            evaluator: (ctx: IEvalContext, defn: TDefinition) => TEvaluated): TEvaluated[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definitions, 'definitions');\r\n            debug.assertValue(evaluator, 'evaluator');\r\n\r\n            let evaluatedValues: TEvaluated[];\r\n\r\n            for (let i = 0, len = definitions.length; i < len; i++) {\r\n                let definition = definitions[i];\r\n                let evaluated: TEvaluated = evaluator(evalContext, definition);\r\n\r\n                // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\r\n                // between TEvaluated & TDefinition\r\n                if (!evaluatedValues && <any>definition !== evaluated) {\r\n                    evaluatedValues = _.take(<TEvaluated[]><any>definitions, i);\r\n                }\r\n\r\n                if (evaluatedValues) {\r\n                    evaluatedValues.push(evaluated);\r\n                }\r\n            }\r\n\r\n            return evaluatedValues || <TEvaluated[]><any>definitions;\r\n        }\r\n\r\n        function evaluateValue(evalContext: IEvalContext, definition: SQExpr | RuleEvaluation, valueType: ValueType): any {\r\n            if (definition instanceof SQExpr)\r\n                return ExpressionEvaluator.evaluate(<SQExpr>definition, evalContext);\r\n\r\n            if (definition instanceof RuleEvaluation)\r\n                return (<RuleEvaluation>definition).evaluate(evalContext);\r\n        }\r\n\r\n        /** Responsible for evaluating SQExprs into values. */\r\n        class ExpressionEvaluator extends DefaultSQExprVisitorWithArg<PrimitiveValue, IEvalContext> {\r\n            private static instance: ExpressionEvaluator = new ExpressionEvaluator();\r\n\r\n            public static evaluate(expr: SQExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                if (expr == null)\r\n                    return;\r\n\r\n                return expr.accept(ExpressionEvaluator.instance, evalContext);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return expr.value;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitFillRule(expr: SQFillRuleExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                let inputValue = expr.input.accept(this, evalContext);\r\n                if (inputValue !== undefined) {\r\n                    let colorAllocator = evalContext.getColorAllocator(expr);\r\n                    if (colorAllocator) {\r\n                        return colorAllocator.color(inputValue);\r\n                    }\r\n                }\r\n            }\r\n\r\n            public visitSelectRef(expr: SQSelectRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n        }\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n\r\n    export module DataViewPivotCategorical {\r\n        /**\r\n         * Pivots categories in a categorical DataView into valueGroupings.\r\n         * This is akin to a mathematical matrix transpose.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return null;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return null;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values) || values.source)\r\n                return null;\r\n\r\n            let category = categories[0],\r\n                categoryIdentities = category.identity,\r\n                categoryValues = category.values,\r\n                pivotedColumns: DataViewMetadataColumn[] = [],\r\n                pivotedValues: DataViewValueColumn[] = [];\r\n            for (let rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\r\n                let categoryValue = categoryValues[rowIdx],\r\n                    categoryIdentity = categoryIdentities[rowIdx];\r\n                for (let colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\r\n                    let value = values[colIdx],\r\n                        pivotedColumn = inherit(value.source);\r\n\r\n                    // A value has a series group, which is not implemented for pivoting -- just give up.\r\n                    if (value.identity)\r\n                        return null;\r\n\r\n                    pivotedColumn.groupName = categoryValue;\r\n                    let pivotedValue: DataViewValueColumn = {\r\n                        source: pivotedColumn,\r\n                        values: [value.values[rowIdx]],\r\n                        identity: categoryIdentity,\r\n                        min: value.min,\r\n                        max: value.max,\r\n                        subtotal: value.subtotal\r\n                    };\r\n\r\n                    let highlights = value.highlights;\r\n                    if (highlights) {\r\n                        pivotedValue.highlights = [highlights[rowIdx]];\r\n                    }\r\n\r\n                    pivotedColumns.push(pivotedColumn);\r\n                    pivotedValues.push(pivotedValue);\r\n                }\r\n            }\r\n\r\n            let pivotedMetadata = inherit(dataView.metadata);\r\n            pivotedMetadata.columns = pivotedColumns;\r\n\r\n            values = DataViewTransform.createValueColumns(pivotedValues, <SQExpr[]>category.identityFields, category.source);\r\n            return {\r\n                metadata: pivotedMetadata,\r\n                categorical: {\r\n                    values: values,\r\n                },\r\n                matrix: dataView.matrix\r\n            };\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewPivotMatrix {\r\n        /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\r\n        export function apply(dataViewMatrix: DataViewMatrix, context: MatrixTransformationContext): void {\r\n            debug.assertValue(dataViewMatrix, 'dataViewMatrix');\r\n\r\n            if (!context.columnHierarchyRewritten)\r\n                dataViewMatrix.columns = Prototype.inherit(dataViewMatrix.columns);\r\n            let columns = dataViewMatrix.columns;\r\n\r\n            if (!context.rowHierarchyRewritten)\r\n                dataViewMatrix.rows = Prototype.inherit(dataViewMatrix.rows);\r\n            let rows = dataViewMatrix.rows;\r\n\r\n            if (columns.levels.length > 1)\r\n                return;\r\n\r\n            let pivotedRowNode: DataViewMatrixNode = {\r\n                level: 0\r\n            };\r\n\r\n            let columnLeafNodes: DataViewMatrixNode[] = columns.root.children;\r\n            let measureCount = columnLeafNodes.length;\r\n\r\n            // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\r\n            // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\r\n            // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \r\n            // in a matrix with 2+ column fields and 2+ measure fields.\r\n            // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\r\n            // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\r\n            let pivotResultMeasureHeaderLevel = rows.levels.length;\r\n\r\n            if (measureCount > 0) {\r\n                let index = 0;\r\n                let callback = function (node: DataViewMatrixNode) {\r\n                    // Collect values and remove them from row leaves\r\n                    if (node.values) {\r\n                        if (!pivotedRowNode.values)\r\n                            pivotedRowNode.values = {};\r\n\r\n                        for (let i = 0; i < measureCount; i++)\r\n                            pivotedRowNode.values[index++] = node.values[i];\r\n\r\n                        delete node.values;\r\n                    }\r\n\r\n                    // Create measure headers if there are more than one measures\r\n                    if (measureCount > 1) {\r\n                        if (!node.children)\r\n                            node.children = [];\r\n\r\n                        for (let j = 0; j < measureCount; j++) {\r\n                            let measureHeaderLeaf: DataViewMatrixNode = { level: pivotResultMeasureHeaderLevel };\r\n\r\n                            // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\r\n                            let columnLeafNode = columnLeafNodes[j];\r\n                            measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\r\n\r\n                            if (node.isSubtotal)\r\n                                measureHeaderLeaf.isSubtotal = true;\r\n\r\n                            node.children.push(measureHeaderLeaf);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                if (context.hierarchyTreesRewritten) {\r\n                    forEachLeaf(rows.root, callback);\r\n                }\r\n                else {\r\n                    dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\r\n                }\r\n            }\r\n            else {\r\n                if (!context.hierarchyTreesRewritten) {\r\n                    dataViewMatrix.columns.root = cloneTree(rows.root);\r\n                }\r\n            }\r\n\r\n            if (measureCount > 1) {\r\n                // Keep measure headers, but move them to the innermost level\r\n                let level: DataViewHierarchyLevel = { sources: columns.levels[0].sources };\r\n                rows.levels.push(level);\r\n\r\n                columns.levels.length = 0;\r\n            }\r\n\r\n            if (context.hierarchyTreesRewritten) {\r\n                dataViewMatrix.columns.root = rows.root;\r\n                dataViewMatrix.rows.root = {\r\n                    children: [pivotedRowNode]\r\n                };\r\n            }\r\n            else {\r\n                let updatedRowRoot = Prototype.inherit(dataViewMatrix.rows.root);\r\n                updatedRowRoot.children = [pivotedRowNode];\r\n                dataViewMatrix.rows.root = updatedRowRoot;\r\n            }\r\n\r\n            dataViewMatrix.columns.levels = rows.levels;\r\n            dataViewMatrix.rows.levels = [];\r\n        }\r\n\r\n        function forEachLeaf(root: DataViewMatrixNode, callback: (node: DataViewMatrixNode) => void): void {\r\n            let children = root.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachLeaf(children[i], callback);\r\n\r\n                return;\r\n            }\r\n\r\n            callback(root);\r\n        }\r\n\r\n        export function cloneTree(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            return cloneTreeExecuteOnLeaf(node);\r\n        }\r\n\r\n        export function cloneTreeExecuteOnLeaf(node: DataViewMatrixNode, callback?: (node: DataViewMatrixNode) => void): DataViewMatrixNode {\r\n            let updatedNode = Prototype.inherit(node);\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                let newChildren: DataViewTreeNode[] = [];\r\n\r\n                for (let i = 0, ilen = children.length; i < ilen; i++) {\r\n                    let updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\r\n                    newChildren.push(updatedChild);\r\n                }\r\n                updatedNode.children = newChildren;\r\n            }\r\n            else {\r\n                if (callback)\r\n                    callback(updatedNode);\r\n            }\r\n\r\n            return updatedNode;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewSelfCrossJoin {\r\n        /**\r\n         * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\r\n         * to itself as a value grouping.\r\n         * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            if (!dataView.categorical)\r\n                return;\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\r\n                return;\r\n            if (dataViewCategorical.values && dataViewCategorical.values.source)\r\n                return;\r\n\r\n            return applyCategorical(dataView.metadata, dataViewCategorical);\r\n        }\r\n\r\n        function applyCategorical(dataViewMetadata: DataViewMetadata, dataViewCategorical: DataViewCategorical): DataView {\r\n            debug.assertValue(dataViewMetadata, 'dataViewMetadata');\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\r\n\r\n            let category = dataViewCategorical.categories[0],\r\n                categoryValues = category.values,\r\n                categoryLength = categoryValues.length;\r\n\r\n            if (categoryLength === 0)\r\n                return;\r\n\r\n            let valuesArray: DataViewValueColumn[] = dataViewCategorical.values\r\n                ? dataViewCategorical.values.grouped()[0].values\r\n                : [];\r\n            let transformedDataView = createCategoricalDataViewBuilder()\r\n                .withCategories(dataViewCategorical.categories)\r\n                .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\r\n                .build();\r\n\r\n            dataViewMetadata = Prototype.inherit(dataViewMetadata);\r\n            dataViewMetadata.columns = transformedDataView.metadata.columns;\r\n\r\n            return {\r\n                metadata: dataViewMetadata,\r\n                categorical: transformedDataView.categorical,\r\n            };\r\n        }\r\n\r\n        function createGroupedValues(\r\n            category: DataViewCategoryColumn,\r\n            categoryValues: any[],\r\n            categoryLength: number,\r\n            valuesArray: DataViewValueColumn[]): DataViewBuilderGroupedValuesOptions {\r\n            debug.assertValue(category, 'category');\r\n            debug.assertValue(categoryValues, 'categoryValues');\r\n            debug.assertValue(categoryLength, 'categoryLength');\r\n            debug.assertValue(valuesArray, 'valuesArray');\r\n\r\n            let nullValuesArray: any[] = createNullValues(categoryLength),\r\n                valuesArrayLen = valuesArray.length,\r\n                seriesData: DataViewBuilderSeriesData[][] = [];\r\n\r\n            for (let i = 0; i < categoryLength; i++) {\r\n                let seriesDataItem: DataViewBuilderSeriesData[] = [];\r\n\r\n                for (let j = 0; j < valuesArrayLen; j++) {\r\n                    let originalValueColumn = valuesArray[j],\r\n                        originalHighlightValues = originalValueColumn.highlights;\r\n\r\n                    let seriesDataItemCategory: DataViewBuilderSeriesData = {\r\n                        values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\r\n                    };\r\n                    if (originalHighlightValues)\r\n                        seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\r\n\r\n                    seriesDataItem.push(seriesDataItemCategory);\r\n                }\r\n\r\n                seriesData.push(seriesDataItem);\r\n            }\r\n\r\n            return {\r\n                groupColumn: {\r\n                    source: category.source,\r\n                    identityFrom: { fields: <SQExpr[]>category.identityFields, identities: category.identity },\r\n                    values: category.values,\r\n                },\r\n                valueColumns: _.map(valuesArray, v => <DataViewBuilderColumnOptions>{ source: v.source }),\r\n                data: seriesData,\r\n            };\r\n        }\r\n    }\r\n\r\n    function createNullValues(length: number): any[] {\r\n        debug.assertValue(length, 'length');\r\n\r\n        let array = new Array(length);\r\n        for (let i = 0; i < length; i++)\r\n            array[i] = null;\r\n        return array;\r\n    }\r\n\r\n    function inheritArrayWithValue(nullValues: any[], original: any[], index: number): any[] {\r\n        let inherited = Prototype.inherit(nullValues);\r\n        inherited[index] = original[index];\r\n\r\n        return inherited;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\r\n    import inheritSingle = powerbi.Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export module DataViewPivotCategoricalToPrimaryGroups {\r\n\r\n        /**\r\n         * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\r\n         * pivot the secondary before the primary.\r\n         */\r\n        export function pivotBinding(binding: DataShapeBinding, allMappings: CompiledDataViewMapping[], finalMapping: CompiledDataViewMapping, defaultDataVolume: number): void {\r\n            // unpivot is inferred from result in DataViewTransform.apply but it does not have the\r\n            // compiled mappings available, let alone the merged mapping, only the original\r\n            // DataViewMappings. to keep that inference easy, only apply pivot when there's\r\n            // only one matching mapping\r\n            if (!allMappings || allMappings.length !== 1)\r\n                return;\r\n\r\n            if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\r\n                return;\r\n\r\n            if (!binding)\r\n                return;\r\n\r\n            if (!canPivotCategorical(binding, finalMapping))\r\n                return;\r\n\r\n            // pivot secondary onto front of primary\r\n            binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\r\n\r\n            binding.Secondary = undefined;\r\n        \r\n            // set primary to pivot reduction\r\n            binding.DataReduction = {\r\n                Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\r\n                DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\r\n            };\r\n        }\r\n\r\n        /** narrowly targets scatter chart scenario for now to keep code simple */\r\n        function isPivotableAxis(axis: powerbi.data.DataShapeBindingAxis): boolean {\r\n            return axis\r\n                && axis.Groupings\r\n                && axis.Groupings.length === 1\r\n                && !_.isEmpty(axis.Groupings[0].Projections)\r\n                && !axis.Groupings[0].Subtotal\r\n                && _.isEmpty(axis.Groupings[0].SuppressedProjections);\r\n        }\r\n\r\n        function canPivotCategorical(binding: DataShapeBinding, mapping: CompiledDataViewMapping): boolean {\r\n            if (!isPivotableAxis(binding.Primary))\r\n                return false;\r\n            if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\r\n                return false;\r\n\r\n            // don't pivot if either axis has a data reduction\r\n            if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        export function unpivotResult(oldDataView: DataView, selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\r\n                return oldDataView;\r\n\r\n            // This returns a subsetted version of the DataView rather than using prototypal inheritance because\r\n            // any dataviews in the old one (including ones invented after this code is written) will correspond\r\n            // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\r\n            // querying code made.\r\n            let newDataView: DataView = {\r\n                metadata: {\r\n                    columns: ArrayExtensions.copy(oldDataView.metadata.columns),\r\n                },\r\n            };\r\n            \r\n            // preserve view types that aren't affected by pivoting\r\n            if (oldDataView.single)\r\n                newDataView.single = oldDataView.single;\r\n            if (oldDataView.table)\r\n                newDataView.table = oldDataView.table;\r\n\r\n            // other views are derived from matrix\r\n            if (oldDataView.matrix) {\r\n                let newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\r\n\r\n                // categorical only if there's data\r\n                if (!_.isEmpty(newDataViewMatrix.valueSources)) {\r\n                    // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \r\n                    // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\r\n                    // this.canPivotCategorical() would have returned false in the first place for this query.\r\n                    let hasCompositeGroupInSeries = utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\r\n                    if (!hasCompositeGroupInSeries) {\r\n                        newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return newDataView;\r\n        }\r\n\r\n        /**\r\n         * Infer from the query result and the visual mappings whether the query was pivoted.\r\n         * Narrowly targets scatter chart scenario for now to keep code simple\r\n         */\r\n        function inferUnpivotTransform(selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], dataView: DataView, projectionActiveItems: DataViewProjectionActiveItems): boolean {\r\n            if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\r\n                return false;\r\n\r\n            // select applicable mappings based on select roles\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\r\n            let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let supportedDataViewMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\r\n            if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\r\n                return false;\r\n\r\n            let categoricalMapping = supportedDataViewMappings[0].categorical;\r\n            if (!categoricalMapping)\r\n                return false;\r\n\r\n            // pivoted query will have produced a matrix\r\n            let matrixDataview = dataView.matrix;\r\n            if (!matrixDataview)\r\n                return false;\r\n\r\n            // matrix must have two levels of grouping\r\n            if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\r\n                return false;\r\n            \r\n            // get category and value grouping roles\r\n            let categoryGroups: string[] = [];\r\n            let valueGroups: string[] = [];\r\n\r\n            let addGroupingRole = (roleName: string, groups: string[]) => {\r\n                let roleProjections: QueryProjectionCollection = projections[roleName];\r\n                if (!roleProjections)\r\n                    return;\r\n\r\n                for (let roleProjection of roleProjections.all()) {\r\n                    if (roleKinds[roleProjection.queryRef] === VisualDataRoleKind.Grouping)\r\n                        groups.push(roleProjection.queryRef);\r\n                }\r\n            };\r\n\r\n            DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, categoryGroups); }\r\n            });\r\n\r\n            DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, valueGroups); }\r\n            });\r\n\r\n            // need both for pivot to have been done\r\n            if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\r\n                return false;\r\n\r\n            // if there was a pivot, there won't be any measures left in the columns\r\n            for (let level of matrixDataview.columns.levels) {\r\n                for (let source of level.sources) {\r\n                    if (!source.isMeasure)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        interface DataViewMatrixNodeValues {\r\n            [id: number]: DataViewMatrixNodeValue;\r\n        }\r\n\r\n        /**\r\n         * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\r\n         * this function changes that so that the categories become the rows and the series the columns.\r\n         */\r\n        function unpivotMatrix(oldMatrix: DataViewMatrix): DataViewMatrix {\r\n            let oldRows = oldMatrix.rows;\r\n            let oldRoot = oldRows.root;\r\n            let oldChildren = <DataViewMatrixNode[]>oldRoot.children;\r\n\r\n            // series are the outer grouping\r\n            let series: DataViewMatrixNode[] = [];\r\n            let seriesIdLevel = oldRows.levels[0];\r\n            let seriesIdFields = oldRoot.childIdentityFields;\r\n\r\n            // categories are the inner grouping. \r\n            let categoryIndex: _.Dictionary<number> = {};\r\n            let categories: DataViewMatrixNode[] = [];\r\n            let categoryIdLevel = oldRows.levels[1];\r\n            let categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\r\n\r\n            let measureCount = oldMatrix.valueSources.length;\r\n\r\n            // within each series value, the category list may not be complete so cannot simply use the inner loop index\r\n            // to reference it.\r\n            let findCategory = (identity: DataViewScopeIdentity) => {\r\n                let index = categoryIndex[identity.key];\r\n\r\n                debug.assert(index !== undefined, \"findcat() !== undefined\");\r\n\r\n                return index;\r\n            };\r\n\r\n            // collect series and categories from the row hierarchy\r\n            if (oldChildren) {\r\n                let addCategory = (categoryNode: DataViewMatrixNode) => {\r\n                    let key = categoryNode.identity.key;\r\n                    let index = categoryIndex[key];\r\n                    if (index === undefined) {\r\n                        index = categories.length;\r\n                        categoryIndex[key] = index;\r\n                        categories.push(categoryNode);\r\n                    }\r\n                };\r\n\r\n                for (let seriesNode of oldChildren) {\r\n                    series.push(seriesNode);\r\n\r\n                    for (let categoryNode of <DataViewMatrixNode[]>seriesNode.children) {\r\n                        addCategory(categoryNode);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // extract intersection values from pivoted matrix\r\n            // values will be indexed by categories then series\r\n            let matrixValues: DataViewMatrixNodeValues[][] = new Array<DataViewMatrixNodeValues[]>(categories.length);\r\n            for (let j = 0; j < series.length; ++j) { // outer is series\r\n                let seriesNode = oldChildren[j];\r\n                for (let categoryNode of seriesNode.children) { // inner is categories but maybe a subset\r\n                    let i = findCategory(categoryNode.identity); // must lookup actual category index\r\n\r\n                    if (!matrixValues[i])\r\n                        matrixValues[i] = new Array<DataViewMatrixNodeValues>(series.length);\r\n\r\n                    matrixValues[i][j] = categoryNode.values;\r\n                }\r\n            }\r\n\r\n            // columns of the unpivoted matrix are the series\r\n            let newColumns: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(series, s => {\r\n                        let inheritedNode = inheritSingle(s);\r\n                        inheritedNode.level = 0; // s.level should already be 0, but just in case...\r\n                        inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\r\n                        inheritedNode.childIdentityFields = undefined;\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: seriesIdFields,\r\n                },\r\n                levels: [\r\n                    seriesIdLevel,\r\n                    \r\n                ],\r\n            };\r\n\r\n            // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\r\n            if (measureCount > 0) {\r\n                let newColChildren: DataViewMatrixNode[] = _.map(oldMatrix.columns.root.children, (srcnode: DataViewMatrixNode) => {\r\n                    let dstnode: DataViewMatrixNode = { level: 1 };\r\n                    if (srcnode.levelSourceIndex)\r\n                        dstnode.levelSourceIndex = srcnode.levelSourceIndex;\r\n                    return dstnode;\r\n                });\r\n\r\n                for (let i = 0; i < newColumns.root.children.length; ++i)\r\n                    newColumns.root.children[i].children = newColChildren;\r\n\r\n                newColumns.levels.push(oldMatrix.columns.levels[0]);\r\n            }\r\n\r\n            // rows of the unpivoted matrix are the categories\r\n            let newRows: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(categories, c => {\r\n                        let inheritedNode = inheritSingle(c);\r\n                        inheritedNode.level = 0;\r\n                        inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\r\n                        inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: categoryIdFields,\r\n                },\r\n                levels: [\r\n                    categoryIdLevel,\r\n                ],\r\n            };\r\n\r\n            // put values into rows\r\n            if (measureCount > 0) {\r\n                for (let i = 0; i < categories.length; ++i) {\r\n                    let row = newRows.root.children[i];\r\n                    let rowValues: DataViewMatrixNodeValues = {};\r\n\r\n                    for (let j = 0; j < series.length; ++j) {\r\n                        let mvalues = matrixValues[i] && matrixValues[i][j];\r\n                        for (let k = 0; k < measureCount; ++k) {\r\n                            let l = j * measureCount + k;\r\n                            rowValues[l] = !mvalues\r\n                                ? ( k === 0 ? { value: null } : { value: null, valueSourceIndex: k } )\r\n                                : mvalues[k];\r\n                        }\r\n                    }\r\n\r\n                    row.values = rowValues;\r\n                }\r\n            }\r\n\r\n            let newMatrix: DataViewMatrix = {\r\n                rows: newRows,\r\n                columns: newColumns,\r\n                valueSources: oldMatrix.valueSources,\r\n            };\r\n\r\n            return newMatrix;\r\n        }\r\n\r\n        /** build a categorical data view from an unpivoted matrix. */\r\n        function categoricalFromUnpivotedMatrix(matrix: DataViewMatrix, columnMetadata: DataViewMetadataColumn[]): DataViewCategorical {\r\n            let seriesCount = matrix.columns.root.children.length;\r\n            let measureMetadata = matrix.valueSources;\r\n            let measureCount = measureMetadata.length;\r\n\r\n            let categories: DataViewCategoryColumn[] = createCategoryColumnsFromUnpivotedMatrix(matrix);\r\n\r\n            // create grouped values\r\n            let groups: DataViewValueColumnGroup[] = [];\r\n            for (let j = 0; j < seriesCount; ++j) {\r\n                let seriesColumn = matrix.columns.root.children[j];\r\n                let group: DataViewValueColumnGroup = {\r\n                    values: [],\r\n                    identity: seriesColumn.identity,\r\n                    name: seriesColumn.value || null,\r\n                };\r\n\r\n                groups.push(group);\r\n\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    let valueColumnMetadataSrc = measureMetadata[k];\r\n                    let valueColumnMetadataDst: DataViewMetadataColumn = <DataViewMetadataColumn>{};\r\n                    for (let key in valueColumnMetadataSrc)\r\n                        valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\r\n                    valueColumnMetadataDst.groupName = group.name;\r\n\r\n                    columnMetadata.push(valueColumnMetadataDst);\r\n\r\n                    let valueColumn: DataViewValueColumn = {\r\n                        source: valueColumnMetadataDst,\r\n                        values: [],\r\n                        identity: group.identity,\r\n                    };\r\n\r\n                    group.values.push(valueColumn);\r\n\r\n                    // grab measure values in the group from across rows of matrix\r\n                    let index = k + j * measureCount;\r\n\r\n                    for (let categoryNode of matrix.rows.root.children) {\r\n                        let value = categoryNode.values[index].value;\r\n\r\n                        valueColumn.values.push(value);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // and now ungrouped\r\n            let values: DataViewValueColumns = <DataViewValueColumns>[];\r\n            for (let group of groups) {\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    values.push(group.values[k]);\r\n                }\r\n            }\r\n\r\n            values.grouped = () => groups;\r\n            values.identityFields = matrix.columns.root.childIdentityFields;\r\n            values.source = matrix.columns.levels[0].sources[0];\r\n\r\n            // final assembly\r\n            let categorical: DataViewCategorical = {\r\n                categories: categories,\r\n                values: values,\r\n            };\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix: DataViewMatrix): DataViewCategoryColumn[] {\r\n            debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\r\n            debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1),\r\n                'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\r\n\r\n            // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \r\n            // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \r\n            // same amongst the resulting DataViewCategoryColumns.\r\n            let categoryIdentity = _.map(unpivotedMatrix.rows.root.children, x => x.identity);\r\n            let categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\r\n            let categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\r\n\r\n            let categories: DataViewCategoryColumn[] = [];\r\n            for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\r\n                let groupLevelValues = _.map(unpivotedMatrix.rows.root.children, (categoryNode: DataViewMatrixNode) => {\r\n                    let levelValues: DataViewMatrixGroupValue[] = categoryNode.levelValues;\r\n\r\n                    // Please refer to the interface comments on when this is undefined... But in today's code\r\n                    // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \r\n                    if (levelValues !== undefined) {\r\n                        debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i),\r\n                            'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\r\n                        return levelValues[i].value;\r\n                    }\r\n                });\r\n\r\n                categories.push({\r\n                    source: categorySourceColumns[i],\r\n                    values: groupLevelValues,\r\n                    identity: categoryIdentity,\r\n                    identityFields: categoryIdentityFields,\r\n                });\r\n            }\r\n\r\n            return categories;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n    import INumberDictionary = jsCommon.INumberDictionary;\r\n\r\n    export interface DataViewTransformApplyOptions {\r\n        prototype: DataView;\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        dataViewMappings?: DataViewMapping[];\r\n        transforms: DataViewTransformActions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /** Describes the Transform actions to be done to a prototype DataView. */\r\n    export interface DataViewTransformActions {\r\n        /** Describes transform metadata for each semantic query select item, as the arrays align, by index. */\r\n        selects?: DataViewSelectTransform[];\r\n\r\n        /** Describes the DataViewObject definitions. */\r\n        objects?: DataViewObjectDefinitions;\r\n\r\n        /** Describes the splitting of a single input DataView into multiple DataViews. */\r\n        splits?: DataViewSplitTransform[];\r\n\r\n        /** Describes the projection metadata which includes projection ordering and active items. */\r\n        roles?: DataViewRoleTransformMetadata;\r\n    }\r\n\r\n    export interface DataViewSplitTransform {\r\n        selects: INumberDictionary<boolean>;\r\n    }\r\n\r\n    export interface DataViewProjectionOrdering {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItemInfo {\r\n        queryRef: string;\r\n\r\n        /** Describes if the active item should be ignored in concatenation.\r\n            If the active item has a drill filter, it will not be used in concatenation.\r\n            If the value of suppressConcat is true, the activeItem will be ommitted from concatenation. */\r\n        suppressConcat?: boolean;\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItems {\r\n        [roleName: string]: DataViewProjectionActiveItemInfo[];\r\n    }\r\n\r\n    export interface DataViewRoleTransformMetadata {\r\n        /** Describes the order of selects (referenced by query index) in each role. */\r\n        ordering?: DataViewProjectionOrdering;\r\n\r\n        /** Describes the active items in each role. */\r\n        activeItems?: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export interface MatrixTransformationContext {\r\n        rowHierarchyRewritten: boolean;\r\n        columnHierarchyRewritten: boolean;\r\n        hierarchyTreesRewritten: boolean;\r\n    }\r\n\r\n    interface ValueRewrite<T> {\r\n        from: T;\r\n        to: T;\r\n    }\r\n\r\n    interface NumberToNumberMapping {\r\n        [position: number]: number;\r\n    }\r\n\r\n    const enum CategoricalDataViewTransformation {\r\n        None,\r\n        Pivot,\r\n        SelfCrossJoin,\r\n    }\r\n\r\n    export const enum StandardDataViewKinds {\r\n        None = 0,\r\n        Categorical = 1,\r\n        Matrix = 1 << 1,\r\n        Single = 1 << 2,\r\n        Table = 1 << 3,\r\n        Tree = 1 << 4,\r\n    }\r\n\r\n    // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\r\n    export module DataViewTransform {\r\n        const fillRulePropertyDescriptor: DataViewObjectPropertyDescriptor = { type: { fillRule: {} } };\r\n\r\n        const enum ColumnIdentifierKind {\r\n            QueryName,\r\n            Role,\r\n        }\r\n\r\n        export function apply(options: DataViewTransformApplyOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\r\n\r\n            let prototype = options.prototype,\r\n                objectDescriptors = options.objectDescriptors,\r\n                dataViewMappings = options.dataViewMappings,\r\n                transforms = options.transforms,\r\n                projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems,\r\n                colorAllocatorFactory = options.colorAllocatorFactory,\r\n                dataRoles = options.dataRoles;\r\n\r\n            if (!prototype)\r\n                return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\r\n\r\n            if (!transforms)\r\n                return [prototype];\r\n\r\n            // Transform Query DataView\r\n            prototype = DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\r\n            let visualDataViews: DataView[] = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\r\n\r\n            // Transform and generate derived visual DataViews\r\n            visualDataViews = DataViewRegression.run({\r\n                dataViewMappings: dataViewMappings,\r\n                visualDataViews: visualDataViews,\r\n                dataRoles: dataRoles,\r\n                objectDescriptors: objectDescriptors,\r\n                objectDefinitions: transforms.objects,\r\n                colorAllocatorFactory: colorAllocatorFactory,\r\n                transformSelects: transforms.selects,\r\n                metadata: prototype.metadata,\r\n                projectionActiveItems: projectionActiveItems,\r\n            });\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        function transformQueryToVisualDataView(\r\n            prototype: DataView,\r\n            transforms: DataViewTransformActions,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            dataViewMappings: DataViewMapping[],\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[]): DataView[] {\r\n            let transformedDataViews: DataView[] = [];\r\n            let splits = transforms.splits;\r\n            if (_.isEmpty(splits)) {\r\n                transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\r\n            } else {\r\n                for (let split of splits) {\r\n                    let transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\r\n                    transformedDataViews.push(transformed);\r\n                }\r\n            }\r\n            return transformedDataViews;\r\n        }\r\n\r\n        function transformEmptyDataView(objectDescriptors: DataViewObjectDescriptors, transforms: DataViewTransformActions, colorAllocatorFactory: IColorAllocatorFactory): DataView[] {\r\n            if (transforms && transforms.objects) {\r\n                let emptyDataView: DataView = {\r\n                    metadata: {\r\n                        columns: [],\r\n                    }\r\n                };\r\n\r\n                transformObjects(\r\n                    emptyDataView,\r\n                    StandardDataViewKinds.None,\r\n                    objectDescriptors,\r\n                    transforms.objects,\r\n                    transforms.selects,\r\n                    colorAllocatorFactory);\r\n\r\n                return [emptyDataView];\r\n            }\r\n\r\n            return [];\r\n        }\r\n\r\n        function transformDataView(\r\n            prototype: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            transforms: DataViewTransformActions,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[],\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(transforms, 'transforms');\r\n            debug.assert(!selectsToInclude ||\r\n                _.filter(\r\n                    Object.keys(selectsToInclude),\r\n                    (selectIndex) => selectsToInclude[selectIndex] && (!transforms.selects || !transforms.selects[selectIndex]))\r\n                    .length === 0, // asserts that the number of select indices in selectsToInclude without a corresponding Select Transform === 0\r\n                'If selectsToInclude is specified, every Select Index in it must have a corresponding Select Transform.');\r\n\r\n            let targetKinds = getTargetKinds(roleMappings);\r\n            let transformed = inherit(prototype);\r\n            transformed.metadata = inherit(prototype.metadata);\r\n\r\n            let projectionOrdering = transforms.roles && transforms.roles.ordering;\r\n            let projectionActiveItems = transforms.roles && transforms.roles.activeItems;\r\n            transformed = transformSelects(transformed, targetKinds, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\r\n            transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\r\n\r\n            // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\r\n            transformed = DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\r\n\r\n            DataViewNormalizeValues.apply({\r\n                dataview: transformed,\r\n                dataViewMappings: roleMappings,\r\n                dataRoles: dataRoles,\r\n            });\r\n\r\n            return transformed;\r\n        }\r\n\r\n        function getTargetKinds(roleMappings: DataViewMapping[]): StandardDataViewKinds {\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n\r\n            if (!roleMappings)\r\n                return StandardDataViewKinds.None;\r\n\r\n            let result = StandardDataViewKinds.None;\r\n            for (let roleMapping of roleMappings) {\r\n                if (roleMapping.categorical)\r\n                    result |= StandardDataViewKinds.Categorical;\r\n                if (roleMapping.matrix)\r\n                    result |= StandardDataViewKinds.Matrix;\r\n                if (roleMapping.single)\r\n                    result |= StandardDataViewKinds.Single;\r\n                if (roleMapping.table)\r\n                    result |= StandardDataViewKinds.Table;\r\n                if (roleMapping.tree)\r\n                    result |= StandardDataViewKinds.Tree;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function transformSelects(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            roleMappings: DataViewMapping[],\r\n            selectTransforms: DataViewSelectTransform[],\r\n            projectionOrdering?: DataViewProjectionOrdering,\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n\r\n            let columnRewrites: ValueRewrite<DataViewMetadataColumn>[] = [];\r\n            if (selectTransforms) {\r\n                dataView.metadata.columns = applyTransformsToColumns(\r\n                    dataView.metadata.columns,\r\n                    selectTransforms,\r\n                    columnRewrites);\r\n            }\r\n\r\n            // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\r\n\r\n            if (dataView.categorical && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Categorical)) {\r\n                dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                // NOTE: This is slightly DSR-specific.\r\n                dataView = pivotIfNecessary(dataView, roleMappings);\r\n            }\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a matrix.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (dataView.matrix && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Matrix)) {\r\n                let matrixTransformationContext: MatrixTransformationContext = {\r\n                    rowHierarchyRewritten: false,\r\n                    columnHierarchyRewritten: false,\r\n                    hierarchyTreesRewritten: false\r\n                };\r\n                dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                if (shouldPivotMatrix(dataView.matrix, roleMappings))\r\n                    DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\r\n            }\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a table.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (dataView.table && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Table)) {\r\n                dataView.table = applyRewritesToTable(dataView.table, columnRewrites, projectionOrdering);\r\n            }\r\n\r\n            return dataView;\r\n        }\r\n\r\n        function applyTransformsToColumns(\r\n            prototypeColumns: DataViewMetadataColumn[],\r\n            selects: DataViewSelectTransform[],\r\n            rewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn[] {\r\n            debug.assertValue(prototypeColumns, 'columns');\r\n\r\n            if (!selects)\r\n                return prototypeColumns;\r\n\r\n            //column may contain undefined entries\r\n            let columns = inherit(prototypeColumns);\r\n\r\n            for (let i = 0, len = prototypeColumns.length; i < len; i++) {\r\n                let prototypeColumn = prototypeColumns[i];\r\n                let select = selects[prototypeColumn.index];\r\n                if (!select)\r\n                    continue;\r\n\r\n                let column: DataViewMetadataColumn = columns[i] = inherit(prototypeColumn);\r\n\r\n                if (select.roles)\r\n                    column.roles = select.roles;\r\n                if (select.type)\r\n                    column.type = select.type;\r\n                column.format = getFormatForColumn(select, column);\r\n\r\n                if (select.displayName)\r\n                    column.displayName = select.displayName;\r\n                if (select.queryName)\r\n                    column.queryName = select.queryName;\r\n                if (select.kpi)\r\n                    column.kpi = select.kpi;\r\n                if (select.sort)\r\n                    column.sort = select.sort;\r\n                if (select.discourageAggregationAcrossGroups)\r\n                    column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\r\n\r\n                rewrites.push({\r\n                    from: prototypeColumn,\r\n                    to: column,\r\n                });\r\n            }\r\n\r\n            return columns;\r\n        }\r\n\r\n        /**\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Select format\r\n         *  2. Column format\r\n         */\r\n        function getFormatForColumn(select: DataViewSelectTransform, column: DataViewMetadataColumn): string {\r\n            // TODO: we already copied the select.Format to column.format, we probably don't need this check\r\n            return select.format || column.format;\r\n        }\r\n\r\n        function applyRewritesToCategorical(prototype: DataViewCategorical, columnRewrites: ValueRewrite<DataViewMetadataColumn>[], selectsToInclude?: INumberDictionary<boolean>): DataViewCategorical {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            let categorical = inherit(prototype);\r\n\r\n            function override(value: { source?: DataViewMetadataColumn }) {\r\n                let rewrittenSource = findOverride(value.source, columnRewrites);\r\n                if (rewrittenSource) {\r\n                    let rewritten = inherit(value);\r\n                    rewritten.source = rewrittenSource;\r\n                    return rewritten;\r\n                }\r\n            }\r\n\r\n            let categories = Prototype.overrideArray(prototype.categories, override);\r\n            if (categories)\r\n                categorical.categories = categories;\r\n\r\n            let valuesOverride = Prototype.overrideArray(prototype.values, override);\r\n            let valueColumns = valuesOverride || prototype.values;\r\n\r\n            if (valueColumns) {\r\n                if (valueColumns.source) {\r\n                    if (selectsToInclude && !selectsToInclude[valueColumns.source.index]) {\r\n                        // if processing a split and this is the split without series...\r\n                        valueColumns.source = undefined;\r\n                    }\r\n                    else {\r\n                        let rewrittenValuesSource = findOverride(valueColumns.source, columnRewrites);\r\n                        if (rewrittenValuesSource)\r\n                            valueColumns.source = rewrittenValuesSource;\r\n                    }\r\n                }\r\n\r\n                if (selectsToInclude) {\r\n                    // Apply selectsToInclude to values by removing value columns not included\r\n                    for (let i = valueColumns.length - 1; i >= 0; i--) {\r\n                        if (!selectsToInclude[valueColumns[i].source.index]) {\r\n                            valueColumns.splice(i, 1);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let isDynamicSeries = !!valueColumns.source;\r\n\r\n                debug.assert(_.every(valueColumns, (valueColumn) => isDynamicSeries === !!valueColumn.identity),\r\n                    'After applying selectsToInclude, all remaining DataViewValueColumn objects should have a consistent scope type (static vs. dynamic) with the parent DataViewValueColumns object.');\r\n                    \r\n                // Dynamic or not, always update the return values of grouped() to have the rewritten 'source' property\r\n                let seriesGroups: DataViewValueColumnGroup[];\r\n                if (isDynamicSeries) {\r\n                    // We have a dynamic series, so update the return value of grouped() to have the DataViewValueColumn objects with rewritten 'source'.\r\n                    // Also, exclude any column that belongs to a static series.\r\n                    seriesGroups = inherit(valueColumns.grouped());\r\n\r\n                    // The following assert is not a rule that's set in stone.  If it becomes false someday, update the code below to remove static series from seriesGroups.\r\n                    debug.assert(_.every(seriesGroups, (group) => !!group.identity), 'If the categorical has a dynamic series, query DataView is expected to have a grouped() function that returns only dynamic series groups, even when there is any column that belongs to a static group (in the case of combo chart and splits).  If this assertion becomes false someday, update the code below to remove static series from seriesGroups.');\r\n\r\n                    let nextSeriesGroupIndex = 0;\r\n                    let currentSeriesGroup: DataViewValueColumnGroup;\r\n                    for (let i = 0, ilen = valueColumns.length; i < ilen; i++) {\r\n                        let currentValueColumn = valueColumns[i];\r\n                        if (!currentSeriesGroup || (currentValueColumn.identity !== currentSeriesGroup.identity)) {\r\n                            currentSeriesGroup = inherit(seriesGroups[nextSeriesGroupIndex]);\r\n                            seriesGroups[nextSeriesGroupIndex] = currentSeriesGroup;\r\n                            currentSeriesGroup.values = [];\r\n                            nextSeriesGroupIndex++;\r\n                            debug.assert(currentValueColumn.identity === currentSeriesGroup.identity, 'expecting the value columns are sequenced by series groups');\r\n                        }\r\n                        currentSeriesGroup.values.push(currentValueColumn);\r\n                    }\r\n                }\r\n                else {\r\n                    // We are in a static series, so we should throw away the grouped and recreate it using the static values\r\n                    //   which have already been filtered\r\n                    seriesGroups = [{ values: valueColumns }];\r\n                }\r\n\r\n                valueColumns.grouped = () => seriesGroups;\r\n                categorical.values = valueColumns;\r\n            }\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function applyRewritesToTable(\r\n            prototype: DataViewTable,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            projectionOrdering: DataViewProjectionOrdering): DataViewTable {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            let table = inherit(prototype);\r\n\r\n            // Copy the rewritten columns into the table view\r\n            let override = (metadata: DataViewMetadataColumn) => findOverride(metadata, columnRewrites);\r\n            let columns = Prototype.overrideArray(prototype.columns, override);\r\n            if (columns)\r\n                table.columns = columns;\r\n\r\n            if (!projectionOrdering)\r\n                return table;\r\n\r\n            let newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\r\n            if (!newToOldPositions)\r\n                return table;\r\n\r\n            // Reorder the columns\r\n            let columnsClone = columns.slice(0);\r\n            let keys = Object.keys(newToOldPositions);\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let sourceColumn = columnsClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === columns.length)\r\n                    columns.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < columns.length, 'The column index is out of range for reordering.');\r\n                    columns[i] = sourceColumn;\r\n                }\r\n            }\r\n\r\n            // Reorder the rows\r\n            let rows = Prototype.overrideArray(table.rows,\r\n                (row: any[]) => {\r\n                    let newRow: any[] = [];\r\n                    for (let i = 0, len = keys.length; i < len; ++i)\r\n                        newRow[i] = row[newToOldPositions[keys[i]]];\r\n\r\n                    return newRow;\r\n                });\r\n\r\n            if (rows)\r\n                table.rows = rows;\r\n\r\n            return table;\r\n        }\r\n\r\n        /** Creates a mapping of new position to original position. */\r\n        function createTableColumnPositionMapping(\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n            let roles = Object.keys(projectionOrdering);\r\n\r\n            // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\r\n            if (roles.length !== 1)\r\n                return;\r\n\r\n            let role = roles[0],\r\n                originalOrder = _.map(columnRewrites, (rewrite: ValueRewrite<DataViewMetadataColumn>) => rewrite.from.index),\r\n                newOrder = projectionOrdering[role];\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        function applyRewritesToMatrix(\r\n            prototype: DataViewMatrix,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            context: MatrixTransformationContext): DataViewMatrix {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n            debug.assertValue(roleMappings, 'roleMappings');\r\n            \r\n            let firstRoleMappingWithMatrix = _.find(roleMappings, (roleMapping) => !!roleMapping.matrix);\r\n            debug.assertValue(firstRoleMappingWithMatrix, 'roleMappings - at least one role mapping is expected to target DataViewMatrix');\r\n\r\n            let matrixMapping = firstRoleMappingWithMatrix.matrix;\r\n            let matrix = inherit(prototype);\r\n\r\n            function override(metadata: DataViewMetadataColumn) {\r\n                return findOverride(metadata, columnRewrites);\r\n            }\r\n\r\n            function overrideHierarchy(hierarchy: DataViewHierarchy): DataViewHierarchy {\r\n                let rewrittenHierarchy: DataViewHierarchy = null;\r\n\r\n                let newLevels = Prototype.overrideArray(\r\n                    hierarchy.levels,\r\n                    (level: DataViewHierarchyLevel) => {\r\n                        let newLevel: DataViewHierarchyLevel = null;\r\n                        let levelSources = Prototype.overrideArray(level.sources, override);\r\n                        if (levelSources)\r\n                            newLevel = ensureRewritten<DataViewHierarchyLevel>(newLevel, level, h => h.sources = levelSources);\r\n\r\n                        return newLevel;\r\n                    });\r\n                if (newLevels)\r\n                    rewrittenHierarchy = ensureRewritten<DataViewHierarchy>(rewrittenHierarchy, hierarchy, r => r.levels = newLevels);\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n\r\n            let rows = overrideHierarchy(matrix.rows);\r\n            if (rows) {\r\n                matrix.rows = rows;\r\n                context.rowHierarchyRewritten = true;\r\n            }\r\n\r\n            let columns = overrideHierarchy(matrix.columns);\r\n            if (columns) {\r\n                matrix.columns = columns;\r\n                context.columnHierarchyRewritten = true;\r\n            }\r\n\r\n            let valueSources = Prototype.overrideArray(matrix.valueSources, override);\r\n            if (valueSources) {\r\n                matrix.valueSources = valueSources;\r\n\r\n                // Only need to reorder if we have more than one value source, and they are all bound to the same role\r\n                let matrixValues = <DataViewRoleForMapping>matrixMapping.values;\r\n                if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\r\n                    let columnLevels = columns.levels.length;\r\n                    if (columnLevels > 0) {\r\n                        let newToOldPositions = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\r\n                        if (newToOldPositions) {\r\n                            let keys = Object.keys(newToOldPositions);\r\n                            let numKeys = keys.length;\r\n\r\n                            // Reorder the value columns\r\n                            columns.root = DataViewPivotMatrix.cloneTree(columns.root);\r\n                            if (columnLevels === 1)\r\n                                reorderChildNodes(columns.root, newToOldPositions);\r\n                            else\r\n                                forEachNodeAtLevel(columns.root, columnLevels - 2, (node: DataViewMatrixNode) => reorderChildNodes(node, newToOldPositions));\r\n\r\n                            // Reorder the value rows\r\n                            matrix.rows.root = DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, (node: DataViewMatrixNode) => {\r\n\r\n                                if (!node.values)\r\n                                    return;\r\n\r\n                                let newValues: { [id: number]: DataViewTreeNodeValue } = {};\r\n\r\n                                let iterations = Object.keys(node.values).length / numKeys;\r\n                                for (let i = 0, len = iterations; i < len; i++) {\r\n                                    let offset = i * numKeys;\r\n                                    for (let keysIndex = 0; keysIndex < numKeys; keysIndex++)\r\n                                        newValues[offset + keysIndex] = node.values[offset + newToOldPositions[keys[keysIndex]]];\r\n                                }\r\n\r\n                                node.values = newValues;\r\n                            });\r\n\r\n                            context.hierarchyTreesRewritten = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\r\n\r\n            return matrix;\r\n        }\r\n\r\n        function reorderChildNodes(node: DataViewMatrixNode, newToOldPositions: NumberToNumberMapping): void {\r\n            let keys = Object.keys(newToOldPositions);\r\n            let numKeys = keys.length;\r\n            let children = node.children;\r\n\r\n            let childrenClone = children.slice(0);\r\n            for (let i = 0, len = numKeys; i < len; i++) {\r\n                let sourceColumn = childrenClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === children.length)\r\n                    children.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < children.length, 'The column index is out of range for reordering.');\r\n                    children[i] = sourceColumn;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\r\n         * and values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified prototype is necessary.\r\n         */\r\n        function reorderMatrixCompositeGroups(\r\n            prototype: DataViewMatrix,\r\n            supportedDataViewMapping: DataViewMatrixMapping,\r\n            projection: DataViewProjectionOrdering): DataViewMatrix {\r\n\r\n            let transformedDataView: DataViewMatrix;\r\n\r\n            if (prototype && supportedDataViewMapping && projection) {\r\n\r\n                // reorder levelValues in any composite groups in rows hierarchy\r\n                let transformedRowsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedRowsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedRowsHierarchy || prototype.rows,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                // reorder levelValues in any composite groups in columns hierarchy\r\n                let transformedColumnsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedColumnsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedColumnsHierarchy || prototype.columns,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                if (transformedRowsHierarchy || transformedColumnsHierarchy) {\r\n                    transformedDataView = inheritSingle(prototype);\r\n                    transformedDataView.rows = transformedRowsHierarchy || transformedDataView.rows;\r\n                    transformedDataView.columns = transformedColumnsHierarchy || transformedDataView.columns;\r\n                }\r\n            }\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\r\n         * values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\r\n         */\r\n        function reorderMatrixHierarchyCompositeGroups(\r\n            matrixHierarchy: DataViewHierarchy,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): DataViewHierarchy {\r\n            debug.assertValue(matrixHierarchy, 'matrixHierarchy');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n\r\n            let transformedHierarchy: DataViewHierarchy;\r\n            let selectIndicesInProjectionOrder: number[] = projection[hierarchyRole];\r\n\r\n            // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\r\n            let hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\r\n            if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\r\n                for (let i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\r\n                    var hierarchyLevel: DataViewHierarchyLevel = matrixHierarchy.levels[i];\r\n\r\n                    // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\r\n                    let newToOldLevelSourceIndicesMapping: NumberToNumberMapping =\r\n                        createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\r\n\r\n                    if (newToOldLevelSourceIndicesMapping) {\r\n                        if (_.isUndefined(transformedHierarchy)) {\r\n                            // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\r\n                            // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\r\n                            transformedHierarchy = inheritSingle(matrixHierarchy);\r\n                            transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\r\n\r\n                            // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\r\n                            // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\r\n                            // happen in other hierarchy levels in the later iterations of this for-loop.\r\n                            transformedHierarchy.root = utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\r\n                        }\r\n\r\n                        // reorder the metadata columns in the sources array at that level\r\n                        let transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\r\n                        transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\r\n\r\n                        // reorder the level values in the composite group nodes at the current hierarchy level\r\n                        reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return transformedHierarchy;\r\n        }\r\n\r\n        /**\r\n         * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\r\n         * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\r\n         *\r\n         * The returned value maps level source indices from the new target order (calculated from projection order)\r\n         * back to the original order as they appear in the specified hierarchyLevel's sources.\r\n         * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\r\n         *\r\n         * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\r\n         *\r\n         * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\r\n         * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\r\n         * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\r\n         */\r\n        function createMatrixHierarchyLevelSourcesPositionMapping(\r\n            hierarchyLevel: DataViewHierarchyLevel,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): NumberToNumberMapping {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n            debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\r\n\r\n            let newToOldLevelSourceIndicesMapping: NumberToNumberMapping;\r\n            let levelSourceColumns = hierarchyLevel.sources;\r\n\r\n            if (levelSourceColumns && levelSourceColumns.length >= 2) {\r\n                // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\r\n\r\n                let columnsForHierarchyRoleOrderedByLevelSourceIndex = utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(\r\n                    levelSourceColumns,\r\n                    projection,\r\n                    hierarchyRole);\r\n\r\n                if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\r\n                    // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\r\n                    let columnsForHierarchyRoleOrderedByProjection = _.sortBy(\r\n                        columnsForHierarchyRoleOrderedByLevelSourceIndex,\r\n                        columnInfo => columnInfo.projectionOrderIndex);\r\n\r\n                    newToOldLevelSourceIndicesMapping = createOrderMapping(\r\n                        _.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, columnInfo => columnInfo.sourceIndex),\r\n                        _.map(columnsForHierarchyRoleOrderedByProjection, columnInfo => columnInfo.sourceIndex));\r\n                }\r\n            }\r\n\r\n            return newToOldLevelSourceIndicesMapping;\r\n        }\r\n\r\n        /**\r\n         * Applies re-ordering on the specified transformingHierarchyLevel's sources.\r\n         * Returns the same object as the specified transformingHierarchyLevel.\r\n         */\r\n        function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel: DataViewHierarchyLevel, newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewHierarchyLevel {\r\n            debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let originalLevelSources = transformingHierarchyLevel.sources;\r\n\r\n            transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\r\n\r\n            let newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\r\n            for (let i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\r\n                let newLevelSourceIndex = newLevelSourceIndices[i];\r\n                let oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\r\n\r\n                debug.assert(oldLevelSourceIndex < originalLevelSources.length,\r\n                    'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\r\n\r\n                transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\r\n            }\r\n\r\n            return transformingHierarchyLevel;\r\n        }\r\n\r\n        /**\r\n         * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\r\n         * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\r\n         *\r\n         * Returns the same object as the specified transformingHierarchyRootNode.\r\n         */\r\n        function reorderMatrixHierarchyLevelValues(\r\n            transformingHierarchyRootNode: DataViewMatrixNode,\r\n            transformingHierarchyLevelIndex: number,\r\n            newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewMatrixNode {\r\n            debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let oldToNewLevelSourceIndicesMapping: NumberToNumberMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\r\n\r\n            forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, (transformingMatrixNode: DataViewMatrixNode) => {\r\n                let originalLevelValues = transformingMatrixNode.levelValues;\r\n\r\n                // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\r\n                // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\r\n                // The following code isn't correct in the special case where a column is projected twice in this composite group,\r\n                // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\r\n                // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\r\n\r\n                if (!_.isEmpty(originalLevelValues)) {\r\n                    // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\r\n                    // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\r\n                    // because we don't want to accidentally modify the array AND its value references in Query DataView\r\n                    let newlyOrderedLevelValues = _.sortBy(originalLevelValues, levelValue => oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]);\r\n\r\n                    for (let i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\r\n                        let transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\r\n                        transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\r\n                        newlyOrderedLevelValues[i] = transformingLevelValue;\r\n                    }\r\n\r\n                    transformingMatrixNode.levelValues = newlyOrderedLevelValues;\r\n\r\n                    // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\r\n                    // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\r\n                    let newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\r\n                    if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\r\n                        transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\r\n                    }\r\n                    if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\r\n                        transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return transformingHierarchyRootNode;\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of new position to original position.\r\n         *\r\n         * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\r\n         * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\r\n         * - the value in the key-value pair is the index of the particular column in the original order\r\n         */\r\n        function createMatrixValuesPositionMapping(\r\n            matrixValues: DataViewRoleForMapping,\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            valueSources: DataViewMetadataColumn[],\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n\r\n            let role = matrixValues.for.in;\r\n            let newOrder = projectionOrdering[role];\r\n\r\n            let originalOrder = _.chain(columnRewrites)\r\n                .filter(rewrite => _.contains(valueSources, rewrite.to))\r\n                .map(rewrite => rewrite.from.index)\r\n                .value();\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\r\n         * originalOrder array.\r\n         * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\r\n         * under the context of the caller code), e.g. the Select Index in projection ordering array.\r\n         * Also, the specified originalOrder must contain every value that exists in newOrder.\r\n         *\r\n         * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\r\n         * key-value pair, each of which represents the new and old indices of a particular column:\r\n         * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\r\n         * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\r\n         *\r\n         * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\r\n         *\r\n         * If the specified originalOrder and newOrder are same, then this function returns undefined.\r\n         *\r\n         * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\r\n         * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\r\n         */\r\n        function createOrderMapping(originalOrder: number[], newOrder: number[]): NumberToNumberMapping {\r\n            // Optimization: avoid rewriting if the current order is correct\r\n            if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, (x: number, y: number) => x === y))\r\n                return;\r\n\r\n            let mapping: NumberToNumberMapping = {};\r\n            for (let i = 0, len = newOrder.length; i < len; ++i) {\r\n                let newPosition = newOrder[i];\r\n                mapping[i] = originalOrder.indexOf(newPosition);\r\n            }\r\n\r\n            return mapping;\r\n        }\r\n\r\n        function createReversedMapping(mapping: NumberToNumberMapping): NumberToNumberMapping {\r\n            debug.assertValue(mapping, 'mapping');\r\n\r\n            let reversed: NumberToNumberMapping = {};\r\n\r\n            for (let key in mapping) {\r\n                // Note: key is a string after we get it out from mapping, thus we need to parse it\r\n                // back into a number before putting it as the value in the reversed mapping\r\n                let value = mapping[key];\r\n                let keyAsNumber = parseInt(key, 10);\r\n                reversed[value] = keyAsNumber;\r\n            }\r\n\r\n            debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length,\r\n                'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\r\n\r\n            return reversed;\r\n        }\r\n\r\n        export function forEachNodeAtLevel(node: DataViewMatrixNode, targetLevel: number, callback: (node: DataViewMatrixNode) => void): void {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(targetLevel >= 0, 'argetLevel >= 0');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            if (node.level === targetLevel) {\r\n                callback(node);\r\n                return;\r\n            }\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachNodeAtLevel(children[i], targetLevel, callback);\r\n            }\r\n        }\r\n\r\n        function findOverride(source: DataViewMetadataColumn, columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn {\r\n            for (let i = 0, len = columnRewrites.length; i < len; i++) {\r\n                let columnRewrite = columnRewrites[i];\r\n                if (columnRewrite.from === source)\r\n                    return columnRewrite.to;\r\n            }\r\n        }\r\n\r\n        function ensureRewritten<T>(rewritten: T, prototype: T, callback?: (rewritten: T) => void): T {\r\n            if (!rewritten)\r\n                rewritten = inherit(prototype);\r\n\r\n            if (callback)\r\n                callback(rewritten);\r\n\r\n            return rewritten;\r\n        }\r\n\r\n        export function transformObjects(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!objectDescriptors)\r\n                return;\r\n\r\n            let objectsForAllSelectors = DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\r\n            DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\r\n\r\n            let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n            let dataObjects = objectsForAllSelectors.data;\r\n            if (metadataOnce)\r\n                evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\r\n\r\n            let metadataObjects = objectsForAllSelectors.metadata;\r\n            if (metadataObjects) {\r\n                for (let i = 0, len = metadataObjects.length; i < len; i++) {\r\n                    let metadataObject = metadataObjects[i];\r\n                    let objectDefns = metadataObject.objects;\r\n                    let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                    evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\r\n                }\r\n            }\r\n\r\n            for (let i = 0, len = dataObjects.length; i < len; i++) {\r\n                let dataObject = dataObjects[i];\r\n                let objectDefns = dataObject.objects;\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\r\n            }\r\n\r\n            let userDefined = objectsForAllSelectors.userDefined;\r\n            if (userDefined) {\r\n                // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\r\n                evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\r\n            }\r\n        }\r\n\r\n        function evaluateUserDefinedObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewObjectDefinitionsForSelector[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let dataViewObjects: DataViewObjects = dataView.metadata.objects;\r\n            if (!dataViewObjects) {\r\n                dataViewObjects = dataView.metadata.objects = {};\r\n            }\r\n\r\n            for (let objectDefn of objectDefns) {\r\n                let id = objectDefn.selector.id;\r\n\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\r\n                let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n                let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName];\r\n\r\n                    let map = <DataViewObjectMap>dataViewObjects[objectName];\r\n                    if (!map)\r\n                        map = dataViewObjects[objectName] = [];\r\n                    debug.assert(DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\r\n\r\n                    // NOTE: We do not check for duplicate ids.\r\n                    map.push({ id: id, object: object });\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Evaluates and sets properties on the DataView metadata. */\r\n        function evaluateMetadataObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            dataObjects: DataViewObjectDefinitionsForSelectorWithRule[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(dataObjects, 'dataObjects');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n            let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n            if (objects) {\r\n                dataView.metadata.objects = objects;\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName],\r\n                        objectDesc = objectDescriptors[objectName];\r\n\r\n                    for (let propertyName in object) {\r\n                        let propertyDesc = objectDesc.properties[propertyName],\r\n                            ruleDesc = propertyDesc.rule;\r\n                        if (!ruleDesc)\r\n                            continue;\r\n\r\n                        let definition = createRuleEvaluationInstance(\r\n                            dataView,\r\n                            colorAllocatorFactory,\r\n                            ruleDesc,\r\n                            objectName,\r\n                            object[propertyName],\r\n                            propertyDesc.type);\r\n                        if (!definition)\r\n                            continue;\r\n\r\n                        dataObjects.push(definition);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstance(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            objectName: string,\r\n            propertyValue: DataViewPropertyValue,\r\n            ruleType: StructuralTypeDescriptor): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n            debug.assertValue(ruleType, 'ruleType');\r\n\r\n            let ruleOutput = ruleDesc.output;\r\n            if (!ruleOutput)\r\n                return;\r\n\r\n            let selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\r\n            if (!selectorToCreate)\r\n                return;\r\n\r\n            if (ruleType.fillRule) {\r\n                return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, <FillRule>propertyValue);\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstanceFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            selectorToCreate: Selector,\r\n            objectName: string,\r\n            propertyValue: FillRule): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(selectorToCreate, 'selectorToCreate');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, ColumnIdentifierKind.Role, propertyValue);\r\n\r\n            if (!colorAllocator)\r\n                return;\r\n\r\n            let rule = new ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\r\n            let fillRuleProperties: DataViewObjectPropertyDefinitions = {};\r\n            fillRuleProperties[ruleDesc.output.property] = {\r\n                solid: { color: rule }\r\n            };\r\n\r\n            return {\r\n                selector: selectorToCreate,\r\n                rules: [rule],\r\n                objects: [{\r\n                    name: objectName,\r\n                    properties: fillRuleProperties,\r\n                }]\r\n            };\r\n        }\r\n\r\n        function tryCreateColorAllocatorForFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValue: FillRule): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            if (propertyValue.linearGradient2)\r\n                return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\r\n\r\n            if (propertyValue.linearGradient3)\r\n                return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient2(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient2: LinearGradient2): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient2, 'linearGradient2');\r\n\r\n            linearGradient2 = propertyValueFillRule.linearGradient2;\r\n            if (linearGradient2.min.value === undefined ||\r\n                linearGradient2.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                if (linearGradient2.min.value === undefined)\r\n                    linearGradient2.min.value = inputRange.min;\r\n                if (linearGradient2.max.value === undefined)\r\n                    linearGradient2.max.value = inputRange.max;\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient3(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient3: LinearGradient3): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient3, 'linearGradient3');\r\n\r\n            let splitScales: boolean;\r\n            linearGradient3 = propertyValueFillRule.linearGradient3;\r\n            if (linearGradient3.min.value === undefined ||\r\n                linearGradient3.mid.value === undefined ||\r\n                linearGradient3.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                splitScales =\r\n                linearGradient3.min.value === undefined &&\r\n                linearGradient3.max.value === undefined &&\r\n                linearGradient3.mid.value !== undefined;\r\n\r\n                if (linearGradient3.min.value === undefined) {\r\n                    linearGradient3.min.value = inputRange.min;\r\n                }\r\n                if (linearGradient3.max.value === undefined) {\r\n                    linearGradient3.max.value = inputRange.max;\r\n                }\r\n                if (linearGradient3.mid.value === undefined) {\r\n                    let midValue: number = (linearGradient3.max.value + linearGradient3.min.value) / 2;\r\n                    linearGradient3.mid.value = midValue;\r\n                }\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\r\n        }\r\n\r\n        function populateColorAllocatorCache(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): IColorAllocatorCache {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let cache = createColorAllocatorCache();\r\n            let staticEvalContext = createStaticEvalContext();\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefnProperties = objectDefns[i].properties;\r\n\r\n                for (let propertyName in objectDefnProperties) {\r\n                    let fillProperty = <FillDefinition>objectDefnProperties[propertyName];\r\n                    if (fillProperty &&\r\n                        fillProperty.solid &&\r\n                        fillProperty.solid.color &&\r\n                        fillProperty.solid.color.kind === SQExprKind.FillRule) {\r\n\r\n                        let fillRuleExpr = <SQFillRuleExpr>fillProperty.solid.color;\r\n\r\n                        let inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\r\n                        if (!inputExprQueryName)\r\n                            continue;\r\n\r\n                        let fillRule = DataViewObjectEvaluator.evaluateProperty(\r\n                            staticEvalContext,\r\n                            fillRulePropertyDescriptor,\r\n                            fillRuleExpr.rule);\r\n\r\n                        let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, ColumnIdentifierKind.QueryName, fillRule);\r\n                        if (colorAllocator)\r\n                            cache.register(fillRuleExpr, colorAllocator);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return cache;\r\n        }\r\n\r\n        function evaluateDataRepetition(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\r\n\r\n            let containsWildcard = Selector.containsWildcard(selector);\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Categorical)) {\r\n                // 1) Match against categories\r\n                evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // 2) Match against valueGrouping\r\n                evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewMatrix = dataView.matrix;\r\n            if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Matrix)) {\r\n                let rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenMatrix) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.matrix = rewrittenMatrix;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewTable = dataView.table;\r\n            if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Table)) {\r\n                let rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\r\n                let rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenTable) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.table = rewrittenTable;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n        }\r\n\r\n        function rewriteTableRoleSelector(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            if (Selector.hasRoleWildcard(selector)) {\r\n                selector = findSelectorForRoleWildcard(dataViewTable, selector);\r\n            }\r\n\r\n            return selector;\r\n        }\r\n\r\n        function findSelectorForRoleWildcard(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            let resultingSelector: Selector = {\r\n                data: [],\r\n                id: selector.id,\r\n                metadata: selector.metadata\r\n            };\r\n\r\n            for (let dataSelector of selector.data) {\r\n                if (Selector.isRoleWildcard(dataSelector)) {\r\n                    let selectorRoles = dataSelector.roles;\r\n                    let allColumnsBelongToSelectorRole: boolean = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\r\n                    let exprs = dataViewTable.identityFields;\r\n                    if (allColumnsBelongToSelectorRole && exprs) {\r\n                        resultingSelector.data.push(DataViewScopeWildcard.fromExprs(<SQExpr[]>exprs));\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\r\n                    resultingSelector.data.push(dataSelector);\r\n                }\r\n            }\r\n\r\n            return resultingSelector;\r\n        }\r\n\r\n        function isUniqueDataSelector(dataSelectors: DataRepetitionSelector[], newSelector: DataRepetitionSelector): boolean {\r\n            if (_.isEmpty(dataSelectors))\r\n                return true;\r\n\r\n            return !_.any(dataSelectors, (dataSelector: DataRepetitionSelector) => dataSelector.key === newSelector.key);\r\n        }\r\n\r\n        function allColumnsBelongToRole(columns: DataViewMetadataColumn[], selectorRoles: string[]): boolean {\r\n            for (let column of columns) {\r\n                var roles = column.roles;\r\n                if (!roles || !_.any(selectorRoles, (selectorRole) => roles[selectorRole]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalCategory(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\r\n                return;\r\n\r\n            let targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\r\n            if (!targetColumn)\r\n                return;\r\n\r\n            let identities = targetColumn.identities,\r\n                foundMatch: boolean,\r\n                evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            if (!identities)\r\n                return;\r\n\r\n            debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\r\n\r\n            for (let i = 0, len = identities.length; i < len; i++) {\r\n                let identity = identities[i];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(i);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n                        if (!targetColumn.column.objects) {\r\n                            targetColumn.column.objects = [];\r\n                            targetColumn.column.objects.length = len;\r\n                        }\r\n                        targetColumn.column.objects[i] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n\r\n                    foundMatch = true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalValueGrouping(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let dataViewCategoricalValues = dataViewCategorical.values;\r\n            if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\r\n                return;\r\n\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[dataViewCategoricalValues.identityFields]))\r\n                return;\r\n\r\n            let valuesGrouped = dataViewCategoricalValues.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\r\n            // This should be enhanced in the future.\r\n            let evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            let foundMatch: boolean;\r\n            for (let i = 0, len = valuesGrouped.length; i < len; i++) {\r\n                let valueGroup = valuesGrouped[i];\r\n                let selectorMetadata = selector.metadata;\r\n                let valuesInGroup = valueGroup.values;\r\n                if (containsWildcard || Selector.matchesData(selector, [valueGroup.identity])) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n\r\n                        if (selectorMetadata) {\r\n                            for (let j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\r\n                                let valueColumn = valuesInGroup[j],\r\n                                    valueSource = valueColumn.source;\r\n                                if (valueSource.queryName === selectorMetadata) {\r\n                                    let valueSourceOverwrite = Prototype.inherit(valueSource);\r\n                                    valueSourceOverwrite.objects = objects;\r\n                                    valueColumn.source = valueSourceOverwrite;\r\n\r\n                                    foundMatch = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            valueGroup.objects = objects;\r\n                            setGrouped(dataViewCategoricalValues, valuesGrouped);\r\n\r\n                            foundMatch = true;\r\n                        }\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrix(\r\n            dataViewMatrix: DataViewMatrix,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewMatrix {\r\n\r\n            let evalContext = createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\r\n            let rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            let rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n\r\n            if (rewrittenRows || rewrittenCols) {\r\n                let rewrittenMatrix = inheritSingle(dataViewMatrix);\r\n\r\n                if (rewrittenRows)\r\n                    rewrittenMatrix.rows = rewrittenRows;\r\n                if (rewrittenCols)\r\n                    rewrittenMatrix.columns = rewrittenCols;\r\n\r\n                return rewrittenMatrix;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixHierarchy(\r\n            evalContext: IEvalContext,\r\n            dataViewMatrixHierarchy: DataViewHierarchy,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewHierarchy {\r\n            debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (!dataViewMatrixHierarchy)\r\n                return;\r\n\r\n            let root = dataViewMatrixHierarchy.root;\r\n            if (!root)\r\n                return;\r\n\r\n            let rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            if (rewrittenRoot) {\r\n                let rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\r\n                rewrittenHierarchy.root = rewrittenRoot;\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixNode(\r\n            evalContext: IEvalContext,\r\n            dataViewNode: DataViewMatrixNode,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewMatrixNode {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(dataViewNode, 'dataViewNode');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let childNodes = dataViewNode.children;\r\n            if (!childNodes)\r\n                return;\r\n\r\n            let rewrittenNode: DataViewMatrixNode;\r\n            let shouldSearchChildren: boolean;\r\n            let childIdentityFields = dataViewNode.childIdentityFields;\r\n            if (childIdentityFields) {\r\n                // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\r\n                shouldSearchChildren = Selector.matchesKeys(selector, <SQExpr[][]>[childIdentityFields]);\r\n            }\r\n\r\n            for (let i = 0, len = childNodes.length; i < len; i++) {\r\n                let childNode = childNodes[i],\r\n                    identity = childNode.identity,\r\n                    rewrittenChildNode: DataViewMatrixNode = null;\r\n\r\n                if (shouldSearchChildren) {\r\n                    if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                        // TODO: Need to initialize context for rule-based properties.  Rule-based properties\r\n                        // (such as fillRule/gradients) are not currently implemented.\r\n\r\n                        let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                        if (objects) {\r\n                            rewrittenChildNode = inheritSingle(childNode);\r\n                            rewrittenChildNode.objects = objects;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rewrittenChildNode = evaluateDataRepetitionMatrixNode(\r\n                        evalContext,\r\n                        childNode,\r\n                        objectDescriptors,\r\n                        selector,\r\n                        rules,\r\n                        containsWildcard,\r\n                        objectDefns);\r\n                }\r\n\r\n                if (rewrittenChildNode) {\r\n                    if (!rewrittenNode)\r\n                        rewrittenNode = inheritNodeAndChildren(dataViewNode);\r\n                    rewrittenNode.children[i] = rewrittenChildNode;\r\n\r\n                    if (!containsWildcard) {\r\n                        // NOTE: once we find a match for a non-wildcard selector, stop looking.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return rewrittenNode;\r\n        }\r\n\r\n        function inheritNodeAndChildren(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            if (Object.getPrototypeOf(node) !== Object.prototype) {\r\n                return node;\r\n            }\r\n\r\n            let inherited = inheritSingle(node);\r\n            inherited.children = inherit(node.children);\r\n            return inherited;\r\n        }\r\n\r\n        function evaluateDataRepetitionTable(\r\n            dataViewTable: DataViewTable,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewTable {\r\n            debug.assertValue(dataViewTable, 'dataViewTable');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let evalContext = createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\r\n            let rewrittenRows = evaluateDataRepetitionTableRows(\r\n                evalContext,\r\n                dataViewTable.columns,\r\n                dataViewTable.rows,\r\n                dataViewTable.identity,\r\n                dataViewTable.identityFields,\r\n                objectDescriptors,\r\n                selector,\r\n                rules,\r\n                containsWildcard,\r\n                objectDefns);\r\n\r\n            if (rewrittenRows) {\r\n                let rewrittenTable = inheritSingle(dataViewTable);\r\n                rewrittenTable.rows = rewrittenRows;\r\n\r\n                return rewrittenTable;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionTableRows(\r\n            evalContext: ITableEvalContext,\r\n            columns: DataViewMetadataColumn[],\r\n            rows: DataViewTableRow[],\r\n            identities: DataViewScopeIdentity[],\r\n            identityFields: ISQExpr[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewTableRow[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(rows, 'rows');\r\n            debug.assertAnyValue(identities, 'identities');\r\n            debug.assertAnyValue(identityFields, 'identityFields');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (_.isEmpty(identities) || _.isEmpty(identityFields))\r\n                return;\r\n\r\n            if (!selector.metadata ||\r\n                !Selector.matchesKeys(selector, <SQExpr[][]>[identityFields]))\r\n                return;\r\n\r\n            let colIdx = _.findIndex(columns, col => col.queryName === selector.metadata);\r\n            if (colIdx < 0)\r\n                return;\r\n\r\n            debug.assert(rows.length === identities.length, 'row length mismatch');\r\n            let colLen = columns.length;\r\n            let inheritedRows: DataViewTableRow[];\r\n\r\n            for (let rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\r\n                let identity = identities[rowIdx];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(rowIdx);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        if (!inheritedRows)\r\n                            inheritedRows = inheritSingle(rows);\r\n\r\n                        let inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\r\n                        let objectsForColumns = inheritedRow.objects;\r\n                        if (!objectsForColumns)\r\n                            inheritedRow.objects = objectsForColumns = new Array(colLen);\r\n\r\n                        objectsForColumns[colIdx] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return inheritedRows;\r\n        }\r\n\r\n        function evaluateMetadataRepetition(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n            // revisit this, likely when we do lazy evaluation of DataView.\r\n            let columns = dataView.metadata.columns,\r\n                metadataId = selector.metadata,\r\n                evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                let column = columns[i];\r\n                if (column.queryName === metadataId) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects)\r\n                        column.objects = objects;\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Attempts to find a column that can possibly match the selector. */\r\n        function findSelectedCategoricalColumn(dataViewCategorical: DataViewCategorical, selector: Selector) {\r\n            debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\r\n\r\n            let categoricalColumn = dataViewCategorical.categories[0];\r\n            if (!categoricalColumn.identityFields)\r\n                return;\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[categoricalColumn.identityFields]))\r\n                return;\r\n\r\n            let identities = categoricalColumn.identity,\r\n                targetColumn: DataViewCategoricalColumn = categoricalColumn;\r\n\r\n            let selectedMetadataId = selector.metadata;\r\n            if (selectedMetadataId) {\r\n                let valueColumns = dataViewCategorical.values;\r\n                if (valueColumns) {\r\n                    for (let i = 0, len = valueColumns.length; i < len; i++) {\r\n                        let valueColumn = valueColumns[i];\r\n                        if (valueColumn.source.queryName === selectedMetadataId) {\r\n                            targetColumn = valueColumn;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                column: targetColumn,\r\n                identities: identities,\r\n            };\r\n        }\r\n\r\n        function findSelectorForRuleInput(dataView: DataView, selectorRoles: string[]): Selector {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectorRoles, 'selectorRoles');\r\n\r\n            if (selectorRoles.length !== 1)\r\n                return;\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return;\r\n\r\n            let categories = dataViewCategorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let categoryColumn = categories[0],\r\n                categoryRoles = categoryColumn.source.roles,\r\n                categoryIdentityFields = categoryColumn.identityFields;\r\n            if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\r\n                return;\r\n\r\n            return { data: [DataViewScopeWildcard.fromExprs(<SQExpr[]>categoryIdentityFields)] };\r\n        }\r\n\r\n        function findFirstQueryNameForExpr(selectTransforms: DataViewSelectTransform[], expr: SQExpr): string {\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (SQExpr.isSelectRef(expr))\r\n                return expr.expressionName;\r\n\r\n            if (!selectTransforms)\r\n                return;\r\n\r\n            for (let i = 0, len = selectTransforms.length; i < len; i++) {\r\n                let select = selectTransforms[i],\r\n                    columnExpr = select.expr;\r\n\r\n                if (!columnExpr || !SQExpr.equals(expr, select.expr))\r\n                    continue;\r\n\r\n                return select.queryName;\r\n            }\r\n        }\r\n\r\n        /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\r\n        function findRuleInputColumnNumberRange(dataView: DataView, identifier: string, identifierKind: ColumnIdentifierKind): NumberRange {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n\r\n            let columns = dataView.metadata.columns;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                let column = columns[i];\r\n\r\n                if (identifierKind === ColumnIdentifierKind.Role) {\r\n                    let valueColRoles = column.roles;\r\n\r\n                    if (!valueColRoles || !valueColRoles[identifier])\r\n                        continue;\r\n                }\r\n                else {\r\n                    debug.assert(identifierKind === ColumnIdentifierKind.QueryName, 'identifierKind === ColumnIdentifierKind.QueryName');\r\n\r\n                    if (column.queryName !== identifier)\r\n                        continue;\r\n                }\r\n\r\n                let aggregates = column.aggregates;\r\n                if (!aggregates)\r\n                    continue;\r\n\r\n                let min = <number>aggregates.min;\r\n                if (min === undefined)\r\n                    min = <number>aggregates.minLocal;\r\n                if (min === undefined)\r\n                    continue;\r\n\r\n                let max = <number>aggregates.max;\r\n                if (max === undefined)\r\n                    max = <number>aggregates.maxLocal;\r\n                if (max === undefined)\r\n                    continue;\r\n\r\n                return { min: min, max: max };\r\n            }\r\n        }\r\n\r\n        // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\r\n        export function createValueColumns(\r\n            values: DataViewValueColumn[] = [],\r\n            valueIdentityFields?: SQExpr[],\r\n            source?: DataViewMetadataColumn): DataViewValueColumns {\r\n            let result = <DataViewValueColumns>values;\r\n            setGrouped(<DataViewValueColumns>values);\r\n\r\n            if (valueIdentityFields)\r\n                result.identityFields = valueIdentityFields;\r\n\r\n            if (source)\r\n                result.source = source;\r\n\r\n            return result;\r\n        }\r\n\r\n        export function setGrouped(values: DataViewValueColumns, groupedResult?: DataViewValueColumnGroup[]): void {\r\n            values.grouped = groupedResult\r\n                ? () => groupedResult\r\n                : () => groupValues(values);\r\n        }\r\n\r\n        /** Group together the values with a common identity. */\r\n        function groupValues(values: DataViewValueColumn[]): DataViewValueColumnGroup[] {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let groups: DataViewValueColumnGroup[] = [],\r\n                currentGroup: DataViewValueColumnGroup;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n\r\n                if (!currentGroup || currentGroup.identity !== value.identity) {\r\n                    currentGroup = {\r\n                        values: []\r\n                    };\r\n\r\n                    if (value.identity) {\r\n                        currentGroup.identity = value.identity;\r\n\r\n                        let source = value.source;\r\n\r\n                        // allow null, which will be formatted as (Blank).\r\n                        if (source.groupName !== undefined)\r\n                            currentGroup.name = source.groupName;\r\n                        else if (source.displayName)\r\n                            currentGroup.name = source.displayName;\r\n                    }\r\n\r\n                    groups.push(currentGroup);\r\n                }\r\n\r\n                currentGroup.values.push(value);\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function pivotIfNecessary(dataView: DataView, dataViewMappings: DataViewMapping[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let transformedDataView: DataView;\r\n            switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\r\n                case CategoricalDataViewTransformation.Pivot:\r\n                    transformedDataView = DataViewPivotCategorical.apply(dataView);\r\n                    break;\r\n\r\n                case CategoricalDataViewTransformation.SelfCrossJoin:\r\n                    transformedDataView = DataViewSelfCrossJoin.apply(dataView);\r\n                    break;\r\n            }\r\n\r\n            return transformedDataView || dataView;\r\n        }\r\n\r\n        function determineCategoricalTransformation(categorical: DataViewCategorical, dataViewMappings: DataViewMapping[]): CategoricalDataViewTransformation {\r\n            if (!categorical || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values))\r\n                return;\r\n\r\n            if (values.grouped().some(vg => !!vg.identity))\r\n                return;\r\n\r\n            // If we made it here, the DataView has a single category and no valueGrouping.\r\n            let categoryRoles = categories[0].source.roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingCategorical = dataViewMappings[i].categorical;\r\n                if (!roleMappingCategorical)\r\n                    continue;\r\n\r\n                if (!hasRolesGrouped(categoryRoles, <DataViewGroupedRoleMapping>roleMappingCategorical.values))\r\n                    continue;\r\n\r\n                // If we made it here, the DataView's single category has the value grouping role.\r\n                let categoriesMapping = roleMappingCategorical.categories;\r\n                let hasCategoryRole =\r\n                    hasRolesBind(categoryRoles, <DataViewRoleBindMappingWithReduction>categoriesMapping) ||\r\n                    hasRolesFor(categoryRoles, <DataViewRoleForMappingWithReduction>categoriesMapping);\r\n\r\n                if (hasCategoryRole)\r\n                    return CategoricalDataViewTransformation.SelfCrossJoin;\r\n\r\n                return CategoricalDataViewTransformation.Pivot;\r\n            }\r\n        }\r\n\r\n        function shouldPivotMatrix(matrix: DataViewMatrix, dataViewMappings: DataViewMapping[]): boolean {\r\n            if (!matrix || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let rowLevels = matrix.rows.levels;\r\n            if (rowLevels.length < 1)\r\n                return;\r\n\r\n            let rows = matrix.rows.root.children;\r\n            if (!rows || rows.length === 0)\r\n                return;\r\n\r\n            let rowRoles = rowLevels[0].sources[0].roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingMatrix = dataViewMappings[i].matrix;\r\n                if (!roleMappingMatrix)\r\n                    continue;\r\n\r\n                if (!hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.rows) &&\r\n                    hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.columns)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        function hasRolesBind(roles: { [name: string]: boolean }, roleMapping: DataViewRoleBindMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.bind)\r\n                return roles[roleMapping.bind.to];\r\n        }\r\n\r\n        function hasRolesFor(roles: { [name: string]: boolean }, roleMapping: DataViewRoleForMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.for)\r\n                return roles[roleMapping.for.in];\r\n        }\r\n\r\n        function hasRolesGrouped(roles: { [name: string]: boolean }, roleMapping: DataViewGroupedRoleMapping): boolean {\r\n            if (roles && roleMapping && roleMapping.group)\r\n                return roles[roleMapping.group.by];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\r\n\r\n    export function createDisplayNameGetter(displayNameKey: string): (IStringResourceProvider) => string {\r\n        return (resourceProvider: IStringResourceProvider) => resourceProvider.get(displayNameKey);\r\n    }\r\n\r\n    export function getDisplayName(displayNameGetter: data.DisplayNameGetter, resourceProvider: jsCommon.IStringResourceProvider): string {\r\n        if (typeof displayNameGetter === 'function')\r\n            return displayNameGetter(resourceProvider);\r\n\r\n        if (typeof displayNameGetter === 'string')\r\n            return displayNameGetter;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    /** Enumeration of DateTimeUnits */\r\n    export enum DateTimeUnit {\r\n        Year,\r\n        Month,\r\n        Week,\r\n        Day,\r\n        Hour,\r\n        Minute,\r\n        Second,\r\n        Millisecond,\r\n    }\r\n\r\n    export interface IFormattingService {\r\n        /** \r\n         * Formats the value using provided format expression and culture\r\n         * @param value - value to be formatted and converted to string.\r\n         * @param format - format to be applied. If undefined or empty then generic format is used.        \r\n         */\r\n        formatValue(value: any, format?: string): string;\r\n\r\n        /** \r\n         * Replaces the indexed format tokens (for example {0:c2}) in the format string with the localized formatted arguments.\r\n         * @param formatWithIndexedTokens - format string with a set of indexed format tokens.\r\n         * @param args - array of values which should replace the tokens in the format string.\r\n         * @param culture - localization culture. If undefined then the current culture is used.\r\n         */\r\n        format(formatWithIndexedTokens: string, args: any[], culture?: string): string;\r\n\r\n        /** Gets a value indicating whether the specified format a standard numeric format specifier. */\r\n        isStandardNumberFormat(format: string): boolean;\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string): string;\r\n\r\n        /** Gets the format string to use for dates in particular units. */\r\n        dateFormatString(unit: DateTimeUnit): string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Represents common expression patterns for 'field' expressions such as columns, column aggregates, measures, etc. */\r\n    export interface FieldExprPattern {\r\n        column?: FieldExprColumnPattern;\r\n        columnAggr?: FieldExprColumnAggrPattern;\r\n        columnHierarchyLevelVariation?: FieldExprColumnHierarchyLevelVariationPattern;\r\n        entity?: FieldExprEntityPattern;\r\n        entityAggr?: FieldExprEntityAggrPattern;\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        hierarchyLevel?: FieldExprHierarchyLevelPattern;\r\n        hierarchyLevelAggr?: FieldExprHierarchyLevelAggrPattern;\r\n        measure?: FieldExprMeasurePattern;\r\n        percentile?: FieldExprPercentilePattern;\r\n        percentOfGrandTotal?: FieldExprPercentOfGrandTotalPattern;\r\n        selectRef?: FieldExprSelectRefPattern;\r\n    }\r\n\r\n    /** By design there is no default, no-op visitor. Components concerned with patterns need to be aware of all patterns as they are added. */\r\n    export interface IFieldExprPatternVisitor<T> {\r\n        visitColumn(column: FieldExprColumnPattern): T;\r\n        visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): T;\r\n        visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): T;\r\n        visitEntity(entity: FieldExprEntityPattern): T;\r\n        visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): T;\r\n        visitHierarchy(hierarchy: FieldExprHierarchyPattern): T;\r\n        visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): T;\r\n        visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): T;\r\n        visitMeasure(measure: FieldExprMeasurePattern): T;\r\n        visitPercentile(percentile: FieldExprPercentilePattern): T;\r\n        visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): T;\r\n        visitSelectRef(selectRef: FieldExprSelectRefPattern): T;\r\n    }\r\n\r\n    export interface FieldExprEntityPattern {\r\n        schema: string;\r\n        entity: string;\r\n        entityVar?: string;\r\n    }\r\n\r\n    export interface FieldExprEntityItemPattern extends FieldExprEntityPattern {\r\n    }\r\n\r\n    export interface FieldExprEntityPropertyPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n    }\r\n\r\n    export type FieldExprColumnPattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprMeasurePattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprHierarchyPattern = FieldExprEntityPropertyPattern;\r\n\r\n    export type FieldExprPropertyPattern = FieldExprColumnPattern | FieldExprMeasurePattern | FieldExprHierarchyPattern;\r\n\r\n    export interface FieldExprEntityAggrPattern extends FieldExprEntityPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnAggrPattern extends FieldExprColumnPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n        level: string;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelAggrPattern extends FieldExprHierarchyLevelPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnHierarchyLevelVariationPattern {\r\n        source: FieldExprColumnPattern;\r\n        level: FieldExprHierarchyLevelPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    export interface FieldExprPercentilePattern {\r\n        arg: FieldExprPattern;\r\n        k: number;\r\n        exclusive: boolean;\r\n    }\r\n\r\n    export interface FieldExprPercentOfGrandTotalPattern {\r\n        baseExpr: FieldExprPattern;\r\n    }\r\n\r\n    export interface FieldExprSelectRefPattern {\r\n        expressionName: string;\r\n    }\r\n\r\n    export module SQExprBuilder {\r\n        export function fieldExpr(fieldExpr: FieldExprPattern): SQExpr {\r\n            let sqExpr = FieldExprPattern.visit<SQExpr>(fieldExpr, FieldExprToSQExprVisitor.instance);\r\n            debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\r\n            return sqExpr;\r\n        }\r\n\r\n        export function fromColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromColumn(columnAggr), columnAggr.aggregate);\r\n        }\r\n\r\n        export function fromColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return columnRef(fromEntity(column), column.name);\r\n        }\r\n\r\n        export function fromEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n            return entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\r\n        }\r\n\r\n        export function fromEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromEntity(entityAggr), entityAggr.aggregate);\r\n        }\r\n\r\n        export function fromHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\r\n        }\r\n\r\n        export function fromHierarchyLevel(hierarchyLevelPattern: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n            return hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\r\n        }\r\n\r\n        export function fromHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n            return hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\r\n        }\r\n\r\n        class FieldExprToSQExprVisitor implements IFieldExprPatternVisitor<SQExpr> {\r\n            public static instance: FieldExprToSQExprVisitor = new FieldExprToSQExprVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n                return fromColumn(column);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n                return fromColumnAggr(columnAggr);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariationPattern: FieldExprColumnHierarchyLevelVariationPattern): SQPropertyVariationSourceExpr {\r\n                return propertyVariationSource(\r\n                    this.visitEntity(columnHierarchyLevelVariationPattern.source),\r\n                    columnHierarchyLevelVariationPattern.source.name,\r\n                    columnHierarchyLevelVariationPattern.level.name);\r\n            }\r\n\r\n            public visitEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n                return fromEntity(entityPattern);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n                return fromEntityAggr(entityAggr);\r\n            }\r\n\r\n            public visitHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n                return fromHierarchy(hierarchyPattern);\r\n            }\r\n\r\n            public visitHierarchyLevel(level: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n                return fromHierarchyLevel(level);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n                return fromHierarchyLevelAggr(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): SQMeasureRefExpr {\r\n                return measureRef(this.visitEntity(measure), measure.name);\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): SQPercentileExpr {\r\n                let arg = SQExprBuilder.fieldExpr(percentile.arg);\r\n                return SQExprBuilder.percentile(arg, percentile.k, percentile.exclusive);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): SQArithmeticExpr {\r\n                let baseSQExpr = SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr);\r\n                return arithmetic(\r\n                    baseSQExpr,\r\n                    SQExprBuilder.scopedEval(baseSQExpr, []),\r\n                    ArithmeticOperatorKind.Divide);\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): SQSelectRefExpr {\r\n                return SQExprBuilder.selectRef(selectRef.expressionName);\r\n            }\r\n        }\r\n    }\r\n\r\n    export module SQExprConverter {\r\n        export function asFieldPattern(sqExpr: SQExpr): FieldExprPattern {\r\n            return sqExpr.accept(FieldExprPatternBuilder.instance);\r\n        }\r\n    }\r\n\r\n    interface FieldExprSourceVariationPattern {\r\n        column: FieldExprColumnPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    interface SourceExprPattern {\r\n        entity?: FieldExprEntityPattern;\r\n\r\n        // TODO: Change FieldExprHierarchyPattern to FieldExprHierarchyLevelPattern\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    interface HierarchySourceExprPattern {\r\n        hierarchy: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    class FieldExprPatternBuilder extends DefaultSQExprVisitor<FieldExprPattern> {\r\n        public static instance: FieldExprPatternBuilder = new FieldExprPatternBuilder();\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let columnRef = <FieldExprColumnPattern>sourceRef.entity;\r\n                columnRef.name = expr.ref;\r\n\r\n                return { column: columnRef };\r\n            }\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let measureRef = <FieldExprMeasurePattern>sourceRef.entity;\r\n                measureRef.name = expr.ref;\r\n\r\n                return { measure: measureRef };\r\n            }\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): FieldExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): FieldExprPattern {\r\n            let fieldPattern: FieldExprPattern = expr.arg.accept(this);\r\n            if (fieldPattern && fieldPattern.column) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.column;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.columnAggr) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.columnAggr;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.hierarchyLevel) {\r\n                let argAggr = <FieldExprHierarchyLevelAggrPattern>fieldPattern.hierarchyLevel;\r\n                argAggr.aggregate = expr.func;\r\n                return { hierarchyLevelAggr: argAggr };\r\n            }\r\n\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let argAggr = <FieldExprEntityAggrPattern>sourcePattern.entity;\r\n                argAggr.aggregate = expr.func;\r\n\r\n                return { entityAggr: argAggr };\r\n            }\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): FieldExprPattern {\r\n            return {\r\n                percentile: {\r\n                    arg: expr.arg.accept(this),\r\n                    k: expr.k,\r\n                    exclusive: expr.exclusive,\r\n                }\r\n            };\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): FieldExprPattern {\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let hierarchyRef = <FieldExprHierarchyPattern>(sourcePattern.entity);\r\n                hierarchyRef.name = expr.hierarchy;\r\n                return { hierarchy: hierarchyRef };\r\n            }\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): FieldExprPattern {\r\n            let hierarchySourceExprPattern: HierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\r\n            if (!hierarchySourceExprPattern)\r\n                return;\r\n\r\n            let hierarchyLevel: FieldExprHierarchyLevelPattern;\r\n            if (hierarchySourceExprPattern.hierarchy) {\r\n                hierarchyLevel = {\r\n                    entity: hierarchySourceExprPattern.hierarchy.entity,\r\n                    schema: hierarchySourceExprPattern.hierarchy.schema,\r\n                    name: hierarchySourceExprPattern.hierarchy.name,\r\n                    level: expr.level,\r\n                };\r\n            }\r\n\r\n            if (hierarchySourceExprPattern.variation) {\r\n                return {\r\n                    columnHierarchyLevelVariation: {\r\n                        source: {\r\n                            entity: hierarchySourceExprPattern.variation.column.entity,\r\n                            schema: hierarchySourceExprPattern.variation.column.schema,\r\n                            name: hierarchySourceExprPattern.variation.column.name,\r\n                        },\r\n                        level: hierarchyLevel,\r\n                        variationName: hierarchySourceExprPattern.variation.variationName,\r\n                    }\r\n                };\r\n            }\r\n\r\n            return { hierarchyLevel: hierarchyLevel };\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): FieldExprPattern {\r\n            let percentOfGrandTotalPattern: FieldExprPattern = {\r\n                percentOfGrandTotal: {\r\n                    baseExpr: expr.left.accept(this)\r\n                }\r\n            };\r\n\r\n            if (SQExpr.equals(expr, SQExprBuilder.fieldExpr(percentOfGrandTotalPattern))) {\r\n                return percentOfGrandTotalPattern;\r\n            }\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr): FieldExprPattern {\r\n            return {\r\n                selectRef: {\r\n                    expressionName: expr.expressionName,\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    class SourceExprPatternBuilder extends DefaultSQExprVisitor<SourceExprPattern> {\r\n        public static instance: SourceExprPatternBuilder = new SourceExprPatternBuilder();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SourceExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SourceExprPattern {\r\n            let entityExpr = <SQEntityExpr>expr.arg;\r\n\r\n            if (entityExpr instanceof SQEntityExpr) {\r\n                let propertyVariationSource: FieldExprColumnPattern = {\r\n                    schema: entityExpr.schema,\r\n                    entity: entityExpr.entity,\r\n                    name: expr.property,\r\n                };\r\n\r\n                if (entityExpr.variable)\r\n                    propertyVariationSource.entityVar = entityExpr.variable;\r\n\r\n                return {\r\n                    variation: {\r\n                        column: propertyVariationSource,\r\n                        variationName: expr.name,\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    class HierarchyExprPatternBuiler extends DefaultSQExprVisitor<HierarchySourceExprPattern> {\r\n        public static instance: HierarchyExprPatternBuiler = new HierarchyExprPatternBuiler();\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): HierarchySourceExprPattern {\r\n            let exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            let hierarchyRef: FieldExprHierarchyPattern;\r\n            let variationRef: FieldExprSourceVariationPattern;\r\n\r\n            if (exprPattern.variation) {\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.variation.column.schema,\r\n                    entity: exprPattern.variation.column.entity,\r\n                };\r\n                variationRef = exprPattern.variation;\r\n            }\r\n            else\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.entity.schema,\r\n                    entity: exprPattern.entity.entity,\r\n                };\r\n\r\n            return {\r\n                hierarchy: hierarchyRef,\r\n                variation: variationRef\r\n            };\r\n        }\r\n    }\r\n\r\n    export module FieldExprPattern {\r\n\r\n        export function visit<T>(expr: SQExpr | FieldExprPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let fieldExprPattern = expr instanceof SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\r\n            debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\r\n\r\n            if (fieldExprPattern.column)\r\n                return visitColumn(fieldExprPattern.column, visitor);\r\n            if (fieldExprPattern.columnAggr)\r\n                return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation)\r\n                return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\r\n            if (fieldExprPattern.entity)\r\n                return visitEntity(fieldExprPattern.entity, visitor);\r\n            if (fieldExprPattern.entityAggr)\r\n                return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\r\n            if (fieldExprPattern.hierarchy)\r\n                return visitHierarchy(fieldExprPattern.hierarchy, visitor);\r\n            if (fieldExprPattern.hierarchyLevel)\r\n                return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\r\n            if (fieldExprPattern.hierarchyLevelAggr)\r\n                return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\r\n            if (fieldExprPattern.measure)\r\n                return visitMeasure(fieldExprPattern.measure, visitor);\r\n            if (fieldExprPattern.percentile)\r\n                return visitPercentile(fieldExprPattern.percentile, visitor);\r\n            if (fieldExprPattern.percentOfGrandTotal)\r\n                return visitPercentOfGrandTotal(fieldExprPattern.percentOfGrandTotal, visitor);\r\n            if (fieldExprPattern.selectRef)\r\n                return visitSelectRef(fieldExprPattern.selectRef, visitor);\r\n\r\n            debug.assertFail('failed to visit a fieldExprPattern.');\r\n            return;\r\n        }\r\n\r\n        function visitColumn<T>(column: FieldExprColumnPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(column, 'column');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumn(column);\r\n        }\r\n\r\n        function visitColumnAggr<T>(columnAggr: FieldExprColumnAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(columnAggr, 'columnAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnAggr(columnAggr);\r\n        }\r\n\r\n        function visitColumnHierarchyLevelVariation<T>(\r\n            columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern,\r\n            visitor: IFieldExprPatternVisitor<T>): T {\r\n\r\n            debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\r\n        }\r\n\r\n        function visitEntity<T>(entity: FieldExprEntityPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(entity, 'entity');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntity(entity);\r\n        }\r\n\r\n        function visitEntityAggr<T>(entityAggr: FieldExprEntityAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(entityAggr, 'entityAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntityAggr(entityAggr);\r\n        }\r\n\r\n        function visitHierarchy<T>(hierarchy: FieldExprHierarchyPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchy(hierarchy);\r\n        }\r\n\r\n        function visitHierarchyLevel<T>(hierarchyLevel: FieldExprHierarchyLevelPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevel(hierarchyLevel);\r\n        }\r\n\r\n        function visitHierarchyLevelAggr<T>(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\r\n        }\r\n\r\n        function visitMeasure<T>(measure: FieldExprMeasurePattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(measure, 'measure');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitMeasure(measure);\r\n        }\r\n\r\n        function visitSelectRef<T>(selectRef: FieldExprSelectRefPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(selectRef, 'selectRef');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitSelectRef(selectRef);\r\n        }\r\n\r\n        function visitPercentile<T>(percentile: FieldExprPercentilePattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(percentile, 'percentile');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitPercentile(percentile);\r\n        }\r\n\r\n        function visitPercentOfGrandTotal<T>(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(percentOfGrandTotal, 'percentOfGrandTotal');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitPercentOfGrandTotal(percentOfGrandTotal);\r\n        }\r\n\r\n        export function toColumnRefSQExpr(columnPattern: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return SQExprBuilder.columnRef(\r\n                SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar),\r\n                columnPattern.name);\r\n        }\r\n\r\n        export function getAggregate(fieldExpr: FieldExprPattern): QueryAggregateFunction {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n\r\n            return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\r\n        }\r\n\r\n        export function isAggregation(fieldExpr: FieldExprPattern): boolean {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n\r\n            return visit(fieldExpr, FieldExprPatternIsAggregationVisitor.instance);\r\n        }\r\n\r\n        export function hasFieldExprName(fieldExpr: FieldExprPattern): boolean {\r\n            return (fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.measure) !== undefined;\r\n        }\r\n\r\n        export function getPropertyName(fieldExpr: FieldExprPattern): string {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprPropertyNameVisitor.instance);\r\n        }\r\n\r\n        export function getHierarchyName(fieldExpr: FieldExprPattern): string {\r\n            let hierarchy = fieldExpr.hierarchy;\r\n            if (hierarchy)\r\n                return hierarchy.name;\r\n        }\r\n\r\n        export function getColumnRef(fieldExpr: FieldExprPattern): FieldExprPropertyPattern {\r\n            if (fieldExpr.columnHierarchyLevelVariation)\r\n                return fieldExpr.columnHierarchyLevelVariation.source;\r\n\r\n            return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\r\n        }\r\n\r\n        export function getFieldExprName(fieldExpr: FieldExprPattern): string {\r\n            let name = getPropertyName(fieldExpr);\r\n\r\n            if (name)\r\n                return name;\r\n\r\n            // In case it is an entity\r\n            return toFieldExprEntityPattern(fieldExpr).entity;\r\n        }\r\n        \r\n        export function getSchema(fieldExpr: FieldExprPattern): string {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n            \r\n            let item = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            debug.assertAnyValue(item, 'expected fieldExpr to be an entity item');\r\n            \r\n            return item.schema;\r\n        }\r\n\r\n        export function toFieldExprEntityPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        export function toFieldExprEntityItemPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        class FieldExprPatternAggregateVisitor implements IFieldExprPatternVisitor<QueryAggregateFunction> {\r\n            public static instance: FieldExprPatternAggregateVisitor = new FieldExprPatternAggregateVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): QueryAggregateFunction {\r\n                return columnAggr.aggregate;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): QueryAggregateFunction {\r\n                return entityAggr.aggregate;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): QueryAggregateFunction {\r\n                return hierarchyLevelAggr.aggregate;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): QueryAggregateFunction {\r\n                // NOTE: Percentile behaves like an aggregate (i.e., can be performed over numeric columns like a SUM), but\r\n                // this function can't really convey that because percentile (intentionally) isn't in QueryAggregateFunction enum.\r\n                // This should be revisited when we have UI support for the Percentile aggregate.\r\n                return;\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): QueryAggregateFunction {\r\n                return SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr));\r\n            }\r\n        }\r\n\r\n        class FieldExprPatternIsAggregationVisitor implements IFieldExprPatternVisitor<boolean> {\r\n            public static instance: FieldExprPatternIsAggregationVisitor = new FieldExprPatternIsAggregationVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): boolean {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        class FieldExprToEntityExprPatternBuilder implements IFieldExprPatternVisitor<FieldExprEntityItemPattern> {\r\n            public static instance: FieldExprToEntityExprPatternBuilder = new FieldExprToEntityExprPatternBuilder();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): FieldExprEntityItemPattern {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): FieldExprEntityItemPattern {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): FieldExprEntityItemPattern {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n\r\n            private static toEntityItemExprPattern(exprPattern: FieldExprEntityItemPattern): FieldExprEntityItemPattern {\r\n                debug.assertValue(exprPattern, 'exprPattern');\r\n\r\n                let pattern: FieldExprEntityItemPattern = { schema: exprPattern.schema, entity: exprPattern.entity };\r\n\r\n                if (exprPattern.entityVar) {\r\n                    pattern.entityVar = exprPattern.entityVar;\r\n                }\r\n\r\n                return pattern;\r\n            }\r\n        }\r\n        \r\n        class FieldExprPropertyNameVisitor implements IFieldExprPatternVisitor<string> {\r\n            public static instance: FieldExprPropertyNameVisitor = new FieldExprPropertyNameVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): string {\r\n                return column.name;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): string {\r\n                return columnAggr.name;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): string {\r\n                return measure.name;\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): string {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): string {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export module DataViewAnalysis {\r\n        import ArrayExtensions = jsCommon.ArrayExtensions;\r\n        import QueryProjectionsByRole = powerbi.data.QueryProjectionsByRole;\r\n        import DataViewObjectDescriptors = powerbi.data.DataViewObjectDescriptors;\r\n        import DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\r\n\r\n        export interface ValidateAndReshapeResult {\r\n            dataView?: DataView;\r\n            isValid: boolean;\r\n        }\r\n\r\n        export interface RoleKindByQueryRef {\r\n            [queryRef: string]: VisualDataRoleKind;\r\n        }\r\n\r\n        export interface DataViewMappingResult {\r\n            supportedMappings: DataViewMapping[];\r\n\r\n            /** A set of mapping errors if there are no supported mappings */\r\n            mappingErrors: DataViewMappingMatchError[];\r\n        }\r\n\r\n        export enum DataViewMappingMatchErrorCode {\r\n            conditionRangeTooLarge,\r\n            conditionRangeTooSmall,\r\n            conditionKindExpectedMeasure,\r\n            conditionKindExpectedGrouping,\r\n            conditionKindExpectedGroupingOrMeasure,\r\n        }\r\n\r\n        export interface DataViewMappingMatchError {\r\n            code: DataViewMappingMatchErrorCode;\r\n            roleName: string;\r\n            mappingIndex?: number;\r\n            conditionIndex?: number;\r\n        }\r\n\r\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\r\n        export function validateAndReshape(dataView: DataView, dataViewMappings: DataViewMapping[]): ValidateAndReshapeResult {\r\n            if (!dataViewMappings || dataViewMappings.length === 0)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            if (dataView) {\r\n                for (let dataViewMapping of dataViewMappings) {\r\n                    // Keep the original when possible.\r\n                    if (supports(dataView, dataViewMapping))\r\n                        return { dataView: dataView, isValid: true };\r\n\r\n                    if (dataViewMapping.categorical && dataView.categorical)\r\n                        return reshapeCategorical(dataView, dataViewMapping);\r\n\r\n                    if (dataViewMapping.tree && dataView.tree)\r\n                        return reshapeTree(dataView, dataViewMapping.tree);\r\n\r\n                    if (dataViewMapping.single && dataView.single)\r\n                        return reshapeSingle(dataView, dataViewMapping.single);\r\n\r\n                    if (dataViewMapping.table && dataView.table)\r\n                        return reshapeTable(dataView, dataViewMapping.table);\r\n                }\r\n            }\r\n            else if (ScriptResultUtil.findScriptResult(dataViewMappings)) {\r\n                // Currently, PBI Service treats R Script Visuals as static images.\r\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\r\n                // to support the PBI Desktop scenario.\r\n                // This code will be removed once PBI Service fully supports R Script Visuals.\r\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\r\n                return { dataView: dataView, isValid: true };\r\n            }\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeCategorical(dataView: DataView, dataViewMapping: DataViewMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\r\n\r\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\r\n            let categoryRoleMapping = dataViewMapping.categorical;\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return { isValid: false };\r\n\r\n            let rowCount;\r\n            if (categoryRoleMapping.rowCount) {\r\n                rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (rowCount && rowCount.max) {\r\n                    let updated: DataViewCategorical;\r\n                    let categories = categorical.categories;\r\n                    let maxRowCount = rowCount.max;\r\n                    let originalLength = undefined;\r\n                    if (categories) {\r\n                        for (let i = 0, len = categories.length; i < len; i++) {\r\n                            let category = categories[i];\r\n                            originalLength = category.values.length;\r\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n\r\n                                // Row count too large: Trim it to fit.\r\n                                let updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\r\n\r\n                                updated = updated || { categories: [] };\r\n                                updated.categories.push({\r\n                                    source: category.source,\r\n                                    values: updatedCategories\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\r\n                        if (!originalLength)\r\n                            originalLength = categorical.values[0].values.length;\r\n\r\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n                            updated = updated || {};\r\n                            updated.values = data.DataViewTransform.createValueColumns();\r\n\r\n                            for (let i = 0, len = categorical.values.length; i < len; i++) {\r\n                                let column = categorical.values[i],\r\n                                    updatedColumn: DataViewValueColumn = {\r\n                                        source: column.source,\r\n                                        values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\r\n                                    };\r\n\r\n                                if (column.min !== undefined)\r\n                                    updatedColumn.min = column.min;\r\n                                if (column.max !== undefined)\r\n                                    updatedColumn.max = column.max;\r\n                                if (column.subtotal !== undefined)\r\n                                    updatedColumn.subtotal = column.subtotal;\r\n\r\n                                updated.values.push(updatedColumn);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (updated) {\r\n                        dataView = {\r\n                            metadata: dataView.metadata,\r\n                            categorical: updated,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (supportsCategorical(dataView, dataViewMapping))\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return null;\r\n        }\r\n\r\n        function reshapeSingle(dataView: DataView, singleRoleMapping: DataViewSingleMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (dataView.single)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            // TODO: Need to implement the reshaping of Tree\r\n            let metadata = dataView.metadata;\r\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTable(dataView: DataView, tableRoleMapping: DataViewTableMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (dataView.table)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        export function countGroups(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (!columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        export function countMeasures(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        /** Indicates whether the dataView conforms to the specified schema. */\r\n        export function supports(dataView: DataView, roleMapping: DataViewMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            if (!roleMapping || !dataView)\r\n                return false;\r\n\r\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\r\n                return false;\r\n\r\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\r\n                return false;\r\n\r\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\r\n                return false;\r\n\r\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsCategorical(dataView: DataView, categoryRoleMapping: DataViewCategoricalMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return false;\r\n\r\n            // TODO: Disabling this implementation isn't right.\r\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\r\n            //    return false;\r\n\r\n            if (categoryRoleMapping.rowCount) {\r\n                let rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\r\n                    rowCount = categoryRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\r\n                        len = dataViewCategorical.values[0].values.length;\r\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\r\n                        len = dataViewCategorical.categories[0].values.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsSingle(dataViewSingle: DataViewSingle, singleRoleMapping: DataViewSingleMapping): boolean {\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (!dataViewSingle)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): boolean {\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            let metadata = dataView.metadata;\r\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\r\n        }\r\n\r\n        function supportsTable(dataViewTable: DataViewTable, tableRoleMapping: DataViewTableMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (!dataViewTable)\r\n                return false;\r\n\r\n            if (tableRoleMapping.rowCount) {\r\n                let rowCount = tableRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\r\n                    rowCount = tableRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewTable.rows && dataViewTable.rows.length)\r\n                        len = dataViewTable.rows.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsScriptResult(dataView: DataViewScriptResultData, scriptResultRoleMapping: DataViewScriptResultMapping): boolean {\r\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\r\n\r\n            if (!dataView)\r\n                return false;\r\n\r\n            if (!dataView.imageBase64)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the range in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        export function validateRange(value: number, roleCondition: RoleCondition, ignoreMin?: boolean): DataViewMappingMatchErrorCode {\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (!roleCondition)\r\n                return;\r\n\r\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\r\n\r\n            if (roleCondition.max !== undefined && roleCondition.max < value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        function validateKind(roleCondition: RoleCondition, roleName: string, projections: QueryProjectionsByRole, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchErrorCode {\r\n            if (!roleCondition || roleCondition.kind === undefined) {\r\n                return;\r\n            }\r\n            let expectedKind = roleCondition.kind;\r\n            let roleCollection = projections[roleName];\r\n            if (roleCollection) {\r\n                let roleProjections = roleCollection.all();\r\n                for (let roleProjection of roleProjections) {\r\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\r\n                        switch (expectedKind) {\r\n                            case VisualDataRoleKind.Measure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\r\n                            case VisualDataRoleKind.Grouping:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\r\n                            case VisualDataRoleKind.GroupingOrMeasure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Determines the appropriate DataViewMappings for the projections. */\r\n        export function chooseDataViewMappings(\r\n            projections: QueryProjectionsByRole,\r\n            mappings: DataViewMapping[],\r\n            roleKindByQueryRef: RoleKindByQueryRef,\r\n            objectDescriptors?: DataViewObjectDescriptors,\r\n            objectDefinitions?: DataViewObjectDefinitions): DataViewMappingResult {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertAnyValue(mappings, 'mappings');\r\n\r\n            let supportedMappings: DataViewMapping[] = [];\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            if (!_.isEmpty(mappings)) {\r\n                for (let mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\r\n                    let mapping = mappings[mappingIndex],\r\n                        mappingConditions = mapping.conditions,\r\n                        requiredProperties = mapping.requiredProperties;\r\n                    let allPropertiesValid: boolean = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\r\n                    let conditionsMet: DataViewMappingCondition[] = [];\r\n\r\n                    if (!_.isEmpty(mappingConditions)) {\r\n                        for (let conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\r\n                            let condition = mappingConditions[conditionIndex];\r\n                            let currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\r\n                            if (!_.isEmpty(currentConditionErrors)) {\r\n                                for (let error of currentConditionErrors) {\r\n                                    error.mappingIndex = mappingIndex;\r\n                                    error.conditionIndex = conditionIndex;\r\n                                    errors.push(error);\r\n                                }\r\n                            }\r\n                            else\r\n                                conditionsMet.push(condition);\r\n                        }\r\n                    }\r\n                    else {\r\n                        conditionsMet.push({});\r\n                    }\r\n\r\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\r\n                        let supportedMapping = _.cloneDeep(mapping);\r\n\r\n                        let updatedConditions = _.filter(conditionsMet, (condition) => Object.keys(condition).length > 0);\r\n                        if (!_.isEmpty(updatedConditions))\r\n                            supportedMapping.conditions = updatedConditions;\r\n                        supportedMappings.push(supportedMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\r\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\r\n            };\r\n        }\r\n\r\n        function checkForConditionErrors(projections: QueryProjectionsByRole, condition: DataViewMappingCondition, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchError[] {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertValue(condition, 'condition');\r\n\r\n            let conditionRoles = Object.keys(condition);\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            for (let i = 0, len = conditionRoles.length; i < len; i++) {\r\n                let roleName: string = conditionRoles[i],\r\n                    isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs),\r\n                    roleCondition = condition[roleName];\r\n\r\n                let roleCount = getPropertyCount(roleName, projections, isDrillable);\r\n                let rangeError = validateRange(roleCount, roleCondition);\r\n                if (rangeError != null) {\r\n                    errors.push({\r\n                        code: rangeError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n                let kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\r\n                if (kindError != null) {\r\n                    errors.push({\r\n                        code: kindError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return errors;\r\n        }\r\n\r\n        function areAllPropertiesValid(requiredProperties: DataViewObjectPropertyIdentifier[], objectDescriptors: DataViewObjectDescriptors, objectDefinitions?: DataViewObjectDefinitions): boolean {\r\n            if (_.isEmpty(requiredProperties))\r\n                return true;\r\n\r\n            if (!objectDescriptors || !objectDefinitions)\r\n                return false;\r\n\r\n            let staticEvalContext: data.IEvalContext = data.createStaticEvalContext();\r\n\r\n            return _.every(requiredProperties, (requiredProperty) => {\r\n                let objectDescriptorValue = null;\r\n                let objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\r\n                if (objectDescriptorProperty)\r\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\r\n                let objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\r\n\r\n                if (!objectDescriptorValue || !objectDefinitionValue)\r\n                    return false;\r\n\r\n                return data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\r\n            });\r\n        }\r\n\r\n        export function getPropertyCount(roleName: string, projections: QueryProjectionsByRole, useActiveIfAvailable?: boolean): number {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(projections, 'projections');\r\n\r\n            let projectionsForRole = projections[roleName];\r\n            if (projectionsForRole) {\r\n                if (useActiveIfAvailable)\r\n                    return 1;\r\n                return projectionsForRole.all().length;\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function hasSameCategoryIdentity(dataView1: DataView, dataView2: DataView): boolean {\r\n            if (dataView1\r\n                && dataView2\r\n                && dataView1.categorical\r\n                && dataView2.categorical) {\r\n                let dv1Categories = dataView1.categorical.categories;\r\n                let dv2Categories = dataView2.categorical.categories;\r\n                if (dv1Categories\r\n                    && dv2Categories\r\n                    && dv1Categories.length === dv2Categories.length) {\r\n                    for (let i = 0, len = dv1Categories.length; i < len; i++) {\r\n                        let dv1Identity = dv1Categories[i].identity;\r\n                        let dv2Identity = dv2Categories[i].identity;\r\n\r\n                        let dv1Length = getLengthOptional(dv1Identity);\r\n                        if (dv1Length !== getLengthOptional(dv2Identity))\r\n                            return false;\r\n\r\n                        for (let j = 0; j < dv1Length; j++) {\r\n                            if (!DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\r\n                                return false;\r\n                        }\r\n                    }\r\n\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function getLengthOptional(identity: DataViewScopeIdentity[]): number {\r\n            if (identity)\r\n                return identity.length;\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function areMetadataColumnsEquivalent(column1: DataViewMetadataColumn, column2: DataViewMetadataColumn): boolean {\r\n            if (!column1 && !column2)\r\n                return true;\r\n\r\n            if (!column1 || !column2)\r\n                return false;\r\n\r\n            if (column1.displayName !== column2.displayName)\r\n                return false;\r\n\r\n            if (column1.queryName !== column2.queryName)\r\n                return false;\r\n\r\n            if (column1.isMeasure !== column2.isMeasure)\r\n                return false;\r\n\r\n            if (column1.type !== column2.type)\r\n                return false;\r\n\r\n            if (column1.sort !== column2.sort)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\r\n        export function isMetadataEquivalent(metadata1: DataViewMetadata, metadata2: DataViewMetadata): boolean {\r\n            if (!metadata1 && !metadata2)\r\n                return true;\r\n\r\n            if (!metadata1 || !metadata2)\r\n                return false;\r\n\r\n            let previousColumnsLength = metadata1.columns.length;\r\n            let newColumnsLength = metadata2.columns.length;\r\n\r\n            if (previousColumnsLength !== newColumnsLength)\r\n                return false;\r\n\r\n            for (let i: number = 0; i < newColumnsLength; i++) {\r\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewRoleWildcard {\r\n        export function fromRoles(roles: string[]): DataViewRoleWildcard {\r\n            return new DataViewRoleWildcardImpl(roles);\r\n        }\r\n\r\n        export function equals(firstRoleWildcard: DataViewRoleWildcard, secondRoleWildcard: DataViewRoleWildcard): boolean {\r\n            return firstRoleWildcard.key &&\r\n                secondRoleWildcard.key &&\r\n                firstRoleWildcard.key === secondRoleWildcard.key &&\r\n                ArrayExtensions.sequenceEqual<string>(\r\n                    firstRoleWildcard.roles,\r\n                    secondRoleWildcard.roles,\r\n                    (role1: string, role2: string) => role1 === role2);\r\n        }\r\n\r\n        class DataViewRoleWildcardImpl implements DataViewRoleWildcard {\r\n            private _roles: string[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(roles: string[]) {\r\n                debug.assertNonEmpty(roles, 'roles');\r\n\r\n                this._roles = roles;\r\n                this._key = new Lazy<string>(() => JSON.stringify(this.roles));\r\n            }\r\n\r\n            public get roles(): string[] {\r\n                return this._roles;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewScopeIdentity {\r\n        /** Compares the two DataViewScopeIdentity values for equality. */\r\n        export function equals(x: DataViewScopeIdentity, y: DataViewScopeIdentity, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            return data.SQExpr.equals(<data.SQExpr>x.expr, <data.SQExpr>y.expr, ignoreCase);\r\n        }\r\n\r\n        export function filterFromIdentity(identities: DataViewScopeIdentity[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(identities))\r\n                return;\r\n            \r\n            let exprs: data.SQExpr[] = [];\r\n            for (let identity of identities) {\r\n                exprs.push(<data.SQExpr>identity.expr);\r\n            }\r\n\r\n            return filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function filterFromExprs(orExprs: data.SQExpr[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(orExprs))\r\n                return;\r\n\r\n            let resultExpr: data.SQExpr;\r\n            for (let orExpr of orExprs) {\r\n                let inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\r\n                if (resultExpr)\r\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\r\n                else\r\n                    resultExpr = inExpr || orExpr;\r\n            }\r\n            \r\n            if (resultExpr) {\r\n                if (isNot)\r\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\r\n            }\r\n\r\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\r\n        }\r\n    }\r\n\r\n    export module data {\r\n        import Lazy = jsCommon.Lazy;\r\n\r\n        export function createDataViewScopeIdentity(expr: SQExpr): DataViewScopeIdentity {\r\n            return new DataViewScopeIdentityImpl(expr);\r\n        }\r\n\r\n        class DataViewScopeIdentityImpl implements DataViewScopeIdentity {\r\n            private _expr: SQExpr;\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(expr: SQExpr) {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                this._expr = expr;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serialize(expr));\r\n            }\r\n\r\n            public get expr(): SQExpr {\r\n                return this._expr;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewScopeWildcard {\r\n        export function matches(wildcard: DataViewScopeWildcard, instance: DataViewScopeIdentity): boolean {\r\n            let instanceExprs = ScopeIdentityExtractor.getKeys(<SQExpr>instance.expr);\r\n            if (!instanceExprs)\r\n                return false;\r\n\r\n            return SQExprUtils.sequenceEqual(<SQExpr[]>wildcard.exprs, instanceExprs);\r\n        }\r\n\r\n        export function equals(firstScopeWildcard: DataViewScopeWildcard, secondScopeWildcard: DataViewScopeWildcard): boolean {\r\n            return firstScopeWildcard.key === secondScopeWildcard.key &&\r\n                SQExprUtils.sequenceEqual(<SQExpr[]>firstScopeWildcard.exprs, <SQExpr[]>secondScopeWildcard.exprs);\r\n        }\r\n\r\n        export function fromExprs(exprs: SQExpr[]): DataViewScopeWildcard {\r\n            return new DataViewScopeWildcardImpl(exprs);\r\n        }\r\n\r\n        class DataViewScopeWildcardImpl implements DataViewScopeWildcard {\r\n            private _exprs: SQExpr[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(exprs: SQExpr[]) {\r\n                debug.assertValue(exprs, 'exprs');\r\n\r\n                this._exprs = exprs;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serializeArray(exprs));\r\n            }\r\n\r\n            public get exprs(): SQExpr[] {\r\n                return this._exprs;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface IColorAllocatorCache {\r\n        get(key: SQFillRuleExpr): IColorAllocator;\r\n        register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this;\r\n    }\r\n\r\n    export function createColorAllocatorCache(): IColorAllocatorCache {\r\n        return new ColorAllocatorProvider();\r\n    }\r\n\r\n    interface ColorAllocatorCacheEntry {\r\n        key: SQFillRuleExpr;\r\n        allocator: IColorAllocator;\r\n    }\r\n\r\n    class ColorAllocatorProvider implements IColorAllocatorCache {\r\n        private cache: ColorAllocatorCacheEntry[];\r\n\r\n        constructor() {\r\n            this.cache = [];\r\n        }\r\n\r\n        public get(key: SQFillRuleExpr): IColorAllocator {\r\n            debug.assertValue(key, 'key');\r\n\r\n            for (let entry of this.cache) {\r\n                if (entry.key === key)\r\n                    return entry.allocator;\r\n            }\r\n        }\r\n\r\n        public register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this {\r\n            debug.assertValue(key, 'key');\r\n            debug.assertValue(colorAllocator, 'colorAllocator');\r\n            debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\r\n\r\n            this.cache.push({\r\n                key: key,\r\n                allocator: colorAllocator,\r\n            });\r\n\r\n            return this;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewRegressionRunOptions {\r\n        dataViewMappings: DataViewMapping[];\r\n        visualDataViews: DataView[];\r\n        dataRoles: VisualDataRole[];\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        objectDefinitions: DataViewObjectDefinitions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        transformSelects: DataViewSelectTransform[];\r\n        metadata: DataViewMetadata;\r\n        projectionActiveItems: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export module DataViewRegression {\r\n        // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\r\n        // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\r\n        const regressionXQueryName: string = 'RegressionX';\r\n        const regressionSeriesQueryName: string = 'RegressionSeries';\r\n        export const regressionYQueryName: string = 'RegressionY';\r\n\r\n        export function run(options: DataViewRegressionRunOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let dataViewMappings: DataViewMapping[] = options.dataViewMappings;\r\n            let visualDataViews: DataView[] = options.visualDataViews;\r\n            let dataRoles: VisualDataRole[] = options.dataRoles;\r\n            let objectDescriptors: DataViewObjectDescriptors = options.objectDescriptors;\r\n            let objectDefinitions: DataViewObjectDefinitions = options.objectDefinitions;\r\n            let colorAllocatorFactory: IColorAllocatorFactory = options.colorAllocatorFactory;\r\n            let transformSelects: DataViewSelectTransform[] = options.transformSelects;\r\n            let projectionActiveItems = options.projectionActiveItems;\r\n            let metadata: DataViewMetadata = options.metadata;\r\n\r\n            if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\r\n                // compute linear regression line if applicable\r\n                let roleKindByQueryRef: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\r\n                let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\r\n                if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\r\n                    return visualDataViews;\r\n\r\n                let applicableDataViewMappings: DataViewMapping[] = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\r\n\r\n                if (applicableDataViewMappings) {\r\n                    let regressionDataViewMapping: DataViewMapping = _.find(applicableDataViewMappings, (dataViewMapping) => {\r\n                        return dataViewMapping.usage && dataViewMapping.usage.regression;\r\n                    });\r\n\r\n                    if (regressionDataViewMapping) {\r\n                        let regressionDataViews: DataView[] = [];\r\n                        for (let visualDataView of visualDataViews) {\r\n                            let regressionDataView: DataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\r\n\r\n                            if (regressionDataView)\r\n                                regressionDataViews.push(regressionDataView);\r\n                        }\r\n\r\n                        if (!_.isEmpty(regressionDataViews))\r\n                            visualDataViews.push(...regressionDataViews);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        /**\r\n         * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\r\n         * It works on scalar axis only.\r\n         * The algorithm is as follows\r\n         *\r\n         * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\r\n         * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\r\n         * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\r\n         * If highlights values are present, repeat steps 2 & 3 using highlight values.\r\n         * 4. Create the new dataView using the points computed above\r\n         */\r\n        export function linearRegressionTransform(\r\n            sourceDataView: DataView,\r\n            dataRoles: VisualDataRole[],\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\r\n            debug.assertValue(dataRoles, 'dataRoles');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!sourceDataView.categorical)\r\n                return;\r\n\r\n            // Step 1\r\n            let xColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.X, sourceDataView.categorical, dataRoles);\r\n            let yColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.Y, sourceDataView.categorical, dataRoles);\r\n\r\n            if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\r\n                return;\r\n\r\n            let xColumnSource = xColumns[0].source;\r\n            let yColumnSource = yColumns[0].source;\r\n\r\n            let combineSeries = true;\r\n            if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\r\n                let regressionUsage = regressionDataViewMapping.usage.regression;\r\n\r\n                let combineSeriesPropertyId = regressionUsage['combineSeries'];\r\n                if (combineSeriesPropertyId) {\r\n                    combineSeries = DataViewObjects.getValue<boolean>(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\r\n                }\r\n            }\r\n\r\n            // Step 2\r\n            let dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\r\n            let lineDefSet = calculateLineDefinitions(dataPointsBySeries);\r\n            let xMin = lineDefSet.xMin;\r\n            let xMax = lineDefSet.xMax;\r\n\r\n            let shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\r\n            let highlightsLineDefSet: LineDefinitionSet;\r\n            if (shouldComputeHightlights) {\r\n                let highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\r\n                highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\r\n                if (highlightsLineDefSet) {\r\n                    xMin = _.min([xMin, highlightsLineDefSet.xMin]);\r\n                    xMax = _.max([xMax, highlightsLineDefSet.xMax]);\r\n                }\r\n                else {\r\n                    shouldComputeHightlights = false;\r\n                }\r\n            }\r\n\r\n            // Step 3\r\n            let valuesByTrend: number[][] = [];\r\n            for (let trend of lineDefSet.lineDefs) {\r\n                valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n            }\r\n\r\n            let highlightsByTrend: number[][];\r\n            if (shouldComputeHightlights) {\r\n                highlightsByTrend = [];\r\n                for (let trend of highlightsLineDefSet.lineDefs) {\r\n                    highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n                }\r\n            }\r\n\r\n            // Step 4\r\n            let groupValues: PrimitiveValue[];\r\n            if (combineSeries) {\r\n                groupValues = ['combinedRegressionSeries'];\r\n            }\r\n            else {\r\n                // If we are producing a trend line per series we need to maintain the group identities so that we can map between the \r\n                // trend line and the original series (to match the color for example).\r\n                if (sourceDataView.categorical.values.source) {\r\n                    // Source data view has dynamic series.\r\n                    let groups = sourceDataView.categorical.values.grouped();\r\n                    groupValues = _.map(groups, (group) => group.name);\r\n                }\r\n                else {\r\n                    // Source data view has static or no series.\r\n                    groupValues = _.map(yColumns, (column) => column.source.queryName);\r\n                }\r\n            }\r\n\r\n            // Step 5\r\n            let regressionDataView: DataView = createRegressionDataView(\r\n                xColumnSource,\r\n                yColumnSource,\r\n                groupValues,\r\n                [xMin, xMax],\r\n                valuesByTrend,\r\n                highlightsByTrend,\r\n                sourceDataView,\r\n                regressionDataViewMapping,\r\n                objectDescriptors,\r\n                objectDefinitions,\r\n                colorAllocatorFactory);\r\n\r\n            return regressionDataView;\r\n        }\r\n\r\n        function calculateLineDefinitions(dataPointsBySeries: DataPointSet[]): LineDefinitionSet {\r\n            let xMin: PrimitiveValue;\r\n            let xMax: PrimitiveValue;\r\n            let lineDefs: LineDefinition[] = [];\r\n            for (let dataPointSet of dataPointsBySeries) {\r\n                let unsortedXValues: PrimitiveValue[] = dataPointSet.xValues;\r\n                let unsortedYValues: PrimitiveValue[] = dataPointSet.yValues;\r\n\r\n                if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\r\n                    return;\r\n\r\n                // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\r\n                let xDataType: string = getDataType(unsortedXValues);\r\n                if (!xDataType)\r\n                    return;\r\n                let yDataType: string = getDataType(unsortedYValues);\r\n                if (!yDataType)\r\n                    return;\r\n\r\n                let sortedDataPointSet: DataPointSet = sortValues(unsortedXValues, unsortedYValues);\r\n                let minCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[0];\r\n                let maxCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\r\n\r\n                let lineDef: LineDefinition = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\r\n\r\n                xMin = _.min([xMin, minCategoryValue]);\r\n                xMax = _.max([xMax, maxCategoryValue]);\r\n\r\n                lineDefs.push(lineDef);\r\n            }\r\n\r\n            return {\r\n                lineDefs: lineDefs,\r\n                xMin: xMin,\r\n                xMax: xMax,\r\n            };\r\n        }\r\n\r\n        function getColumnsForCartesianRoleKind(roleKind: CartesianRoleKind, categorical: DataViewCategorical, roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            debug.assertValue(roleKind, 'roleKind');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n\r\n            let categories = categorical.categories;\r\n            if (_.isEmpty(categories))\r\n                return;\r\n\r\n            debug.assert(categories.length === 1, 'composite category columns not supported');\r\n            let categoryColumn = categories[0];\r\n            columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n        }\r\n\r\n        function getColumnsWithRoleKind(roleKind: CartesianRoleKind, columns: DataViewCategoricalColumn[], roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            if (_.isEmpty(columns))\r\n                return;\r\n\r\n            return _.filter(columns, (column) => {\r\n                for (let roleName in column.source.roles) {\r\n                    if (!column.source.roles[roleName])\r\n                        continue;\r\n\r\n                    let role = _.find(roles, (role) => role.name === roleName);\r\n                    if (role && role.cartesianKind === roleKind)\r\n                        return true;\r\n                }\r\n\r\n                return false;\r\n            });\r\n        }\r\n\r\n        function getDataType(values: PrimitiveValue[]): string {\r\n            let firstNonNull: PrimitiveValue = _.find(values, (value) => value != null);\r\n            if (firstNonNull == null)\r\n                return;\r\n\r\n            let dataType: string = typeof firstNonNull;\r\n\r\n            if (_.some(values, (value) => value != null && typeof value !== dataType))\r\n                return;\r\n\r\n            return dataType;\r\n        }\r\n\r\n        function sortValues(unsortedXValues: PrimitiveValue[], unsortedYValues: PrimitiveValue[]): DataPointSet {\r\n            debug.assertValue(unsortedXValues, 'unsortedXValues');\r\n            debug.assertValue(unsortedYValues, 'unsortedYValues');\r\n\r\n            let zippedValues = _.zip(unsortedXValues, unsortedYValues);\r\n            let [xValues, yValues] = _.chain(zippedValues)\r\n                .filter((valuePair) => valuePair[0] != null && valuePair[1] != null)\r\n                .sortBy((valuePair) => valuePair[0])\r\n                .unzip()\r\n                .value();\r\n\r\n            return {\r\n                xValues: xValues,\r\n                yValues: yValues\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Computes a line definition using linear regression.\r\n         *   xBar: average of X values, yBar: average of Y values\r\n         *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\r\n         *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\r\n         *   Slope: ssXY / ssXX\r\n         *   Intercept: yBar - xBar * slope\r\n         */\r\n        function computeRegressionLine(xValues: number[], yValues: number[]): LineDefinition {\r\n            debug.assertValue(xValues, 'xValues');\r\n            debug.assertValue(yValues, 'yValues');\r\n\r\n            let xBar = _.sum(xValues) / xValues.length;\r\n            let yBar = _.sum(yValues) / yValues.length;\r\n\r\n            let ssXX = _.chain(xValues)\r\n                .map((x) => {\r\n                    return (x - xBar) ** 2;\r\n                })\r\n                .sum();\r\n\r\n            let ssXY = _.chain(xValues)\r\n                .map((x, i) => {\r\n                    return (x - xBar) * (yValues[i] - yBar);\r\n                })\r\n                .sum();\r\n\r\n            let slope = ssXY / ssXX;\r\n            let intercept = yBar - (xBar * slope);\r\n\r\n            return {\r\n                slope: slope,\r\n                intercept: intercept\r\n            };\r\n        }\r\n\r\n        function computeLineYValues(lineDef: LineDefinition, x1: number, x2: number): number[] {\r\n            return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\r\n        }\r\n\r\n        function getValuesFromColumn(column: DataViewCategoricalColumn, preferHighlights: boolean): PrimitiveValue[] {\r\n            if (preferHighlights) {\r\n                // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                if (valueColumn.highlights) {\r\n                    return valueColumn.highlights;\r\n                }\r\n            }\r\n\r\n            return column.values;\r\n        }\r\n\r\n        function getDataPointsBySeries(xColumns: DataViewCategoricalColumn[], yColumns: DataViewCategoricalColumn[], combineSeries: boolean, preferHighlights: boolean): DataPointSet[] {\r\n            let dataPointsBySeries: DataPointSet[] = [];\r\n            let xValueArray: PrimitiveValue[][] = _.map(xColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n            let seriesYValues: PrimitiveValue[][] = _.map(yColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n\r\n            let multipleXValueColumns: boolean = xColumns.length > 1;\r\n            for (let i = 0; i < seriesYValues.length; i++) {\r\n                let xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\r\n                let yValues = seriesYValues[i];\r\n\r\n                if (combineSeries && dataPointsBySeries.length > 0) {\r\n                    dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\r\n                    dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\r\n                }\r\n                else {\r\n                    dataPointsBySeries.push({\r\n                        xValues: xValues,\r\n                        yValues: yValues,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return dataPointsBySeries;\r\n        }\r\n\r\n        function createRegressionDataView(\r\n            xColumnSource: DataViewMetadataColumn,\r\n            yColumnSource: DataViewMetadataColumn,\r\n            groupValues: PrimitiveValue[],\r\n            categories: PrimitiveValue[],\r\n            values: PrimitiveValue[][],\r\n            highlights: PrimitiveValue[][],\r\n            sourceDataView: DataView,\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(xColumnSource, 'xColumnSource');\r\n            debug.assertValue(yColumnSource, 'yColumnSource');\r\n            debug.assertValue(categories, 'categories');\r\n            debug.assertValue(values, 'values');\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertAnyValue(highlights, 'highlights');\r\n            debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\r\n\r\n            let xRole: string = (<DataViewRoleForMapping>regressionDataViewMapping.categorical.categories).for.in;\r\n            let grouped = (<DataViewGroupedRoleMapping>regressionDataViewMapping.categorical.values).group;\r\n            let yRole: string;\r\n            let seriesRole: string;\r\n            if (grouped && !_.isEmpty(grouped.select)) {\r\n                yRole = (<DataViewRoleForMapping>grouped.select[0]).for ?\r\n                    (<DataViewRoleForMapping>grouped.select[0]).for.in :\r\n                    (<DataViewRoleBindMapping>grouped.select[0]).bind.to;\r\n                seriesRole = grouped.by;\r\n            }\r\n            if (!yRole || !seriesRole)\r\n                return;\r\n\r\n            let categoricalRoles: { [name: string]: boolean } = {[xRole]: true};\r\n            let valueRoles: { [name: string]: boolean } = {[yRole]: true};\r\n            let seriesRoles: { [name: string]: boolean } = {[seriesRole]: true};\r\n\r\n            let valuesBySeries: DataViewBuilderSeriesData[][] = [];\r\n            for (let index in values) {\r\n                let seriesData: DataViewBuilderSeriesData = {\r\n                    values: values[index],\r\n                };\r\n\r\n                if (highlights)\r\n                    seriesData.highlights = highlights[index];\r\n\r\n                valuesBySeries.push([seriesData]);\r\n            }\r\n\r\n            let regressionDataView: DataView = createCategoricalDataViewBuilder()\r\n                .withCategory({\r\n                    source: {\r\n                        displayName: xColumnSource.displayName,\r\n                        queryName: regressionXQueryName,\r\n                        type: xColumnSource.type,\r\n                        isMeasure: false,\r\n                        roles: categoricalRoles\r\n                    },\r\n                    values: categories,\r\n                    identityFrom: {\r\n                        fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\r\n                    },\r\n                })\r\n                .withGroupedValues({\r\n                    groupColumn: {\r\n                        source: {\r\n                            displayName: yColumnSource.displayName + 'Regression',\r\n                            queryName: regressionSeriesQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: seriesRoles\r\n                        },\r\n                        values: groupValues,\r\n                        identityFrom: {\r\n                            fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\r\n                        }\r\n                    },\r\n                    valueColumns: [{\r\n                        source: {\r\n                            displayName: yColumnSource.displayName,\r\n                            queryName: regressionYQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: valueRoles\r\n                        },\r\n                    }],\r\n                    data: valuesBySeries\r\n                })\r\n                .build();\r\n            DataViewTransform.transformObjects(regressionDataView, data.StandardDataViewKinds.Categorical, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\r\n            return regressionDataView;\r\n        }\r\n\r\n        function hasHighlightValues(columns: DataViewCategoricalColumn[]): boolean {\r\n            return _.any(columns, (column) => {\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                return valueColumn.highlights != null;\r\n            });\r\n        }\r\n    }\r\n\r\n    interface DataPointSet {\r\n        xValues: any[];\r\n        yValues: any[];\r\n    }\r\n\r\n    interface LineDefinition {\r\n        slope: number;\r\n        intercept: number;\r\n    }\r\n\r\n    interface LineDefinitionSet {\r\n        lineDefs: LineDefinition[];\r\n        xMin: PrimitiveValue;\r\n        xMax: PrimitiveValue;\r\n    }\r\n}\r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewSelectTransform {\r\n        displayName?: string;\r\n        queryName?: string;\r\n        format?: string;\r\n        type?: ValueType;\r\n        roles?: { [roleName: string]: boolean };\r\n        kpi?: DataViewKpiColumnMetadata;\r\n        sort?: SortDirection;\r\n        expr?: SQExpr;\r\n        discourageAggregationAcrossGroups?: boolean;\r\n\r\n        /** Describes the default value applied to a column, if any. */\r\n        defaultValue?: DefaultValueDefinition;\r\n    }\r\n\r\n    export module DataViewSelectTransform {\r\n        /** Convert selection info to projections */\r\n        export function projectionsFromSelects(selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): QueryProjectionsByRole {\r\n            debug.assertAnyValue(selects, \"selects\");\r\n            debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\r\n\r\n            let projections: QueryProjectionsByRole = {};\r\n            for (let select of selects) {\r\n                let roles = select.roles;\r\n                if (!roles)\r\n                    continue;\r\n\r\n                for (let roleName in roles) {\r\n                    if (roles[roleName]) {\r\n                        let qp = projections[roleName];\r\n                        if (!qp)\r\n                            qp = projections[roleName] = new QueryProjectionCollection([]);\r\n                        qp.all().push({ queryRef: select.queryName });\r\n\r\n                        if (projectionActiveItems && projectionActiveItems[roleName])\r\n                            qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], (activeItem: DataViewProjectionActiveItemInfo) => activeItem.queryRef);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return projections;\r\n        }\r\n\r\n        /** Use selections and metadata to fashion query role kinds */\r\n        export function createRoleKindFromMetadata(selects: DataViewSelectTransform[], metadata: DataViewMetadata): RoleKindByQueryRef {\r\n            let roleKindByQueryRef: DataViewAnalysis.RoleKindByQueryRef = {};\r\n            for (let column of metadata.columns) {\r\n                if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\r\n                    continue;\r\n\r\n                let select = selects[column.index];\r\n                if (select) {\r\n                    let queryRef = select.queryName;\r\n                    if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\r\n                        roleKindByQueryRef[queryRef] = column.isMeasure ? VisualDataRoleKind.Measure : VisualDataRoleKind.Grouping;\r\n                    }\r\n                }\r\n            }\r\n            return roleKindByQueryRef;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface ICategoricalEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createCategoricalEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewCategorical: DataViewCategorical): ICategoricalEvalContext {\r\n        return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\r\n    }\r\n\r\n    class CategoricalEvalContext implements ICategoricalEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewCategorical;\r\n        private columnsByRole: { [name: string]: DataViewCategoricalColumn };\r\n        private index: number;\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewCategorical) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.columnsByRole = {};\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            let columnsByRole = this.columnsByRole;\r\n            let column = columnsByRole[roleName];\r\n            if (!column)\r\n                column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\r\n            \r\n            if (!column)\r\n                return;\r\n\r\n            let index = this.index;\r\n            if (index != null)\r\n                return column.values[this.index];\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.index = index;\r\n        }\r\n    }\r\n\r\n    function findRuleInputColumn(dataViewCategorical: DataViewCategorical, inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n\r\n        return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\r\n            findRuleInputInColumns(dataViewCategorical.categories, inputRole);\r\n    }\r\n\r\n    function findRuleInputInColumns(columns: DataViewCategoricalColumn[], inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertAnyValue(columns, 'columns');\r\n\r\n        if (!columns)\r\n            return;\r\n\r\n        for (let column of columns) {\r\n            let roles = column.source.roles;\r\n            if (!roles || !roles[inputRole])\r\n                continue;\r\n\r\n            return column;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ITableEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createTableEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewTable: DataViewTable, selectTransforms: DataViewSelectTransform[]): ITableEvalContext {\r\n        return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\r\n    }\r\n\r\n    class TableEvalContext implements ITableEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewTable;\r\n        private rowIdx: number;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewTable, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let rowIdx = this.rowIdx;\r\n            if (rowIdx == null)\r\n                return;\r\n\r\n            return getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.rowIdx = index;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class RuleEvaluation {\r\n        // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class ColorRuleEvaluation extends RuleEvaluation {\r\n        private inputRole: string;\r\n        private allocator: IColorAllocator;\r\n\r\n        constructor(inputRole: string, allocator: IColorAllocator) {\r\n            debug.assertValue(inputRole, 'inputRole');\r\n            debug.assertValue(allocator, 'allocator');\r\n\r\n            super();\r\n            this.inputRole = inputRole;\r\n            this.allocator = allocator;\r\n        }\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n\r\n            let value: any = evalContext.getRoleValue(this.inputRole);\r\n            if (value !== undefined)\r\n                return this.allocator.color(value);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    export module DataViewMatrixUtils {\r\n\r\n        /**\r\n         * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the \r\n         * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the \r\n         * particular leaf node in the context of this forEachLeafNode(...) invocation.\r\n         *\r\n         * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\r\n         *\r\n         * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified \r\n         * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\r\n         * then treePath will be an array of length 1 containing that very node.\r\n         *\r\n         * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\r\n         * If your callback needs to retain a copy of the treePath, please clone the array before returning.\r\n         */\r\n        export function forEachLeafNode(\r\n            rootNodes: DataViewMatrixNode | DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): void {\r\n            debug.assertAnyValue(rootNodes, 'rootNodes');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\r\n            // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \r\n            // for the fact that all the properties on DataViewMatrixNode are optional...\r\n            if (rootNodes) {\r\n                if (isNodeArray(rootNodes)) {\r\n                    let index = 0;\r\n                    for (let rootNode of rootNodes) {\r\n                        if (rootNode) {\r\n                            index = forEachLeafNodeRecursive(rootNode, index, [], callback);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    forEachLeafNodeRecursive(rootNodes, 0, [], callback);\r\n                }\r\n            }\r\n        }\r\n\r\n        function isNodeArray(nodeOrNodeArray: DataViewMatrixNode | DataViewMatrixNode[]): nodeOrNodeArray is DataViewMatrixNode[] {\r\n            return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\r\n        }\r\n\r\n        /**\r\n         * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\r\n         * Returns the index for the next node after the last node that this function invokes callback with.\r\n         *\r\n         * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\r\n         */\r\n        function forEachLeafNodeRecursive(\r\n            matrixNode: DataViewMatrixNode,\r\n            nextIndex: number,\r\n            treePath: DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): number {\r\n            debug.assertValue(matrixNode, 'matrixNode');\r\n            debug.assertValue(treePath, 'treePath');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // If treePath already contains matrixNode, then either one of the following errors has happened:\r\n            // 1. the caller code mistakenly added matrixNode to treePath, or\r\n            // 2. the callback modified treePath by adding a node to it, or\r\n            // 3. the matrix hierarchy contains a cyclical node reference.');\r\n            debug.assert(!_.contains(treePath, matrixNode),\r\n                'pre-condition: treePath must not already contain matrixNode');\r\n\r\n            treePath.push(matrixNode);\r\n\r\n            if (_.isEmpty(matrixNode.children)) { // if it is a leaf node\r\n                callback(matrixNode, nextIndex, treePath);\r\n                nextIndex++;\r\n            }\r\n            else {\r\n                let children = matrixNode.children;\r\n                for (let nextChild of children) {\r\n                    if (nextChild) {\r\n                        nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\r\n                    }\r\n                }\r\n            }\r\n\r\n            debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\r\n            treePath.pop();\r\n\r\n            return nextIndex;\r\n        }\r\n\r\n        /**\r\n         * Returned an object tree where each node and its children property are inherited from the specified node \r\n         * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\r\n         *\r\n         * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array \r\n         * property, i.e. its children property is the same array object referenced in the input node's object tree.\r\n         *\r\n         * @param node The input node with the hierarchy object tree.\r\n         * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\r\n         * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is \r\n         * not already an inherited object. Same goes for the node's children property.  This is useful for creating \r\n         * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for \r\n         * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains \r\n         * inherited objects.\r\n         */\r\n        export function inheritMatrixNodeHierarchy(\r\n            node: DataViewMatrixNode,\r\n            deepestLevelToInherit: number,\r\n            useInheritSingle: boolean): DataViewMatrixNode {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\r\n            debug.assertValue(useInheritSingle, 'useInheritSingle');\r\n\r\n            let returnNode = node;\r\n\r\n            // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\r\n            // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\r\n            // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\r\n            //  {\r\n            //    \"level\": 0,\r\n            //    \"isSubtotal\": true,\r\n            //    \"children\": [\r\n            //      { \"level\": 2, \"isSubtotal\": true },\r\n            //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\r\n            //    ]\r\n            //  }\r\n            let isRootNode = _.isUndefined(node.level);\r\n            let shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\r\n            if (shouldInheritCurrentNode) {\r\n                let inheritFunc = useInheritSingle ? inheritSingle : inherit;\r\n                let inheritedNode: DataViewMatrixNode = inheritFunc(node);\r\n\r\n                let shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\r\n                if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\r\n                    inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\r\n                    for (let i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\r\n                        inheritedNode.children[i] =\r\n                            inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\r\n                    }\r\n                }\r\n\r\n                returnNode = inheritedNode;\r\n            }\r\n\r\n            return returnNode;\r\n        }\r\n\r\n        /**\r\n         * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\r\n         * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\r\n         * Year === 2016, Quarter === 'Qtr 1', Month === 1.\r\n         *\r\n         * Returns false if the specified matrixOrHierarchy does not contain any composite group, \r\n         * or if matrixOrHierarchy is null or undefined.\r\n         */\r\n        export function containsCompositeGroup(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): boolean {\r\n            debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\r\n\r\n            let hasCompositeGroup = false;\r\n\r\n            if (matrixOrHierarchy) {\r\n                if (isMatrix(matrixOrHierarchy)) {\r\n                    hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\r\n                        containsCompositeGroup(matrixOrHierarchy.columns);\r\n                }\r\n                else {\r\n                    let hierarchyLevels = matrixOrHierarchy.levels;\r\n                    if (!_.isEmpty(hierarchyLevels)) {\r\n                        for (var level of hierarchyLevels) {\r\n                            // it takes at least 2 columns at the same hierarchy level to form a composite group...\r\n                            if (level.sources && (level.sources.length >= 2)) {\r\n\r\n                                debug.assert(_.all(level.sources, sourceColumn => sourceColumn.isMeasure === level.sources[0].isMeasure),\r\n                                    'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\r\n\r\n                                // Measure headers are not group\r\n                                let isMeasureHeadersLevel = level.sources[0].isMeasure;\r\n                                if (!isMeasureHeadersLevel) {\r\n                                    hasCompositeGroup = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return hasCompositeGroup;\r\n        }\r\n\r\n        function isMatrix(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): matrixOrHierarchy is DataViewMatrix {\r\n            return 'rows' in matrixOrHierarchy &&\r\n                'columns' in matrixOrHierarchy &&\r\n                'valueSources' in matrixOrHierarchy;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    export module DataViewMetadataColumnUtils {\r\n\r\n        export interface MetadataColumnAndProjectionIndex {\r\n            /**\r\n            * A metadata column taken from a source collection, e.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n            */\r\n            metadataColumn: DataViewMetadataColumn;\r\n\r\n            /**\r\n             * The index of this.metadataColumn in its sources collection.\r\n             *\r\n             * E.g.1 This can be the value of the property DataViewMatrixGroupValue.levelSourceIndex which is the index of this.metadataColumn in DataViewHierarchyLevel.sources.\r\n             * E.g.2 This can be the value of the property DataViewMatrixNodeValue.valueSourceIndex which refer to columns in DataViewMatrix.valueSources.\r\n             */\r\n            sourceIndex: number;\r\n\r\n            /**\r\n            * The index of this.metadataColumn in the projection ordering of a given role.\r\n            */\r\n            projectionOrderIndex: number;\r\n        }\r\n\r\n        /**\r\n         * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\r\n         */\r\n        export function isForRole(metadataColumn: DataViewMetadataColumn, targetRole: string): boolean {\r\n            debug.assertValue(metadataColumn, 'metadataColumn');\r\n            debug.assertValue(targetRole, 'targetRole');\r\n\r\n            let roles = metadataColumn.roles;\r\n            return roles && roles[targetRole];\r\n        }\r\n\r\n        /**\r\n         * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\r\n         *\r\n         * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the \r\n         * specified columnSources must be a non-filtered array of column sources from the DataView, such as\r\n         * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\r\n         *\r\n         * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n         * @param projection The projection ordering.  It must contain an ordering for the specified role.\r\n         * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\r\n         */\r\n        export function joinMetadataColumnsAndProjectionOrder(\r\n            columnSources: DataViewMetadataColumn[],\r\n            projection: DataViewProjectionOrdering,\r\n            role: string): MetadataColumnAndProjectionIndex[] {\r\n            debug.assertAnyValue(columnSources, 'columnSources');\r\n            debug.assert(_.all(columnSources, column => _.isNumber(column.index)),\r\n                'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\r\n            debug.assertNonEmpty(projection[role], 'projection[role]');\r\n            debug.assert(_.all(columnSources, column => !isForRole(column, role) || _.contains(projection[role], column.index)),\r\n                'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\r\n\r\n            let jointResult: MetadataColumnAndProjectionIndex[] = [];\r\n\r\n            if (!_.isEmpty(columnSources)) {\r\n                let projectionOrderSelectIndices = projection[role];\r\n                let selectIndexToProjectionIndexMap: { [selectIndex: number]: number } = {};\r\n                for (let i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\r\n                    let selectIndex = projectionOrderSelectIndices[i];\r\n                    selectIndexToProjectionIndexMap[selectIndex] = i;\r\n                }\r\n\r\n                for (let j = 0, jlen = columnSources.length; j < jlen; j++) {\r\n                    var column = columnSources[j];\r\n                    if (isForRole(column, role)) {\r\n                        let jointColumnInfo: MetadataColumnAndProjectionIndex = {\r\n                            metadataColumn: column,\r\n                            sourceIndex: j,\r\n                            projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\r\n                        };\r\n\r\n                        jointResult.push(jointColumnInfo);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return jointResult;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export class ConceptualSchema {\r\n        public entities: ArrayNamedItems<ConceptualEntity>;\r\n        public capabilities: ConceptualCapabilities;\r\n\r\n        /** Indicates whether the user can edit this ConceptualSchema.  This is used to enable/disable model authoring UX. */\r\n        public canEdit: boolean;\r\n\r\n        public findProperty(entityName: string, propertyName: string): ConceptualProperty {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            return entity.properties.withName(propertyName);\r\n        }\r\n\r\n        public findHierarchy(entityName: string, name: string): ConceptualHierarchy {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.hierarchies))\r\n                return;\r\n\r\n            return entity.hierarchies.withName(name);\r\n        }\r\n\r\n        public findHierarchyByVariation(\r\n            variationEntityName: string,\r\n            variationColumnName: string,\r\n            variationName: string,\r\n            hierarchyName: string): ConceptualHierarchy {\r\n\r\n            let variationEntity = this.entities.withName(variationEntityName);\r\n            if (!variationEntity || _.isEmpty(variationEntity.properties))\r\n                return;\r\n\r\n            let variationProperty = variationEntity.properties.withName(variationColumnName);\r\n            if (!variationProperty)\r\n                return;\r\n\r\n            let variationColumn = variationProperty.column;\r\n            if (!variationColumn || _.isEmpty(variationColumn.variations))\r\n                return;\r\n\r\n            let variation = variationColumn.variations.withName(variationName);\r\n            if (variation) {\r\n                let targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\r\n                if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\r\n                    return;\r\n\r\n                return targetEntity.hierarchies.withName(hierarchyName);\r\n            }\r\n        }\r\n\r\n        /**\r\n        * Returns the first property of the entity whose kpi is tied to kpiProperty\r\n        */\r\n        public findPropertyWithKpi(entityName: string, kpiProperty: ConceptualProperty): ConceptualProperty {\r\n            debug.assertValue(kpiProperty, 'kpiProperty');\r\n\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            for (let prop of entity.properties) {\r\n                if (prop &&\r\n                    prop.measure &&\r\n                    prop.measure.kpi &&\r\n                    (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\r\n                    return prop;\r\n            }\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    export interface ConceptualCapabilities {\r\n        discourageQueryAggregateUsage: boolean;\r\n        normalizedFiveStateKpiRange: boolean;\r\n        supportsMedian: boolean;\r\n        supportsPercentile: boolean;\r\n        supportsScopedEval: boolean;\r\n    }\r\n\r\n    export interface ConceptualPropertyItemContainer {\r\n        properties: ArrayNamedItems<ConceptualProperty>;\r\n        hierarchies?: ArrayNamedItems<ConceptualHierarchy>;\r\n        displayFolders?: ArrayNamedItems<ConceptualDisplayFolder>;\r\n    }\r\n\r\n    export interface ConceptualPropertyItem {\r\n        name: string;\r\n        displayName: string;\r\n        hidden?: boolean;\r\n    }\r\n\r\n    export interface ConceptualEntity extends ConceptualPropertyItemContainer {\r\n        name: string;\r\n        displayName: string;\r\n        visibility?: ConceptualVisibility;\r\n        calculated?: boolean;\r\n        queryable?: ConceptualQueryableState;\r\n        navigationProperties?: ArrayNamedItems<ConceptualNavigationProperty>;\r\n    }\r\n\r\n    export interface ConceptualDisplayFolder extends ConceptualPropertyItem, ConceptualPropertyItemContainer {\r\n    }\r\n\r\n    export interface ConceptualProperty extends ConceptualPropertyItem {\r\n        type: ValueType;\r\n        kind: ConceptualPropertyKind;\r\n        format?: string;\r\n        column?: ConceptualColumn;\r\n        queryable?: ConceptualQueryableState;\r\n        measure?: ConceptualMeasure;\r\n        kpiValue?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualHierarchy extends ConceptualPropertyItem {\r\n        levels: ArrayNamedItems<ConceptualHierarchyLevel>;\r\n    }\r\n\r\n    export interface ConceptualHierarchyLevel extends ConceptualPropertyItem {\r\n        column: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualNavigationProperty {\r\n        name: string;\r\n        isActive: boolean;\r\n        sourceColumn?: ConceptualColumn;\r\n        targetEntity: ConceptualEntity;\r\n        sourceMultiplicity: ConceptualMultiplicity;\r\n        targetMultiplicity: ConceptualMultiplicity;\r\n    }\r\n\r\n    export interface ConceptualVariationSource {\r\n        name: string;\r\n        isDefault: boolean;\r\n        navigationProperty?: ConceptualNavigationProperty;\r\n        defaultHierarchy?: ConceptualHierarchy;\r\n        defaultProperty?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualColumn {\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n        keys?: ArrayNamedItems<ConceptualProperty>;\r\n        idOnEntityKey?: boolean;\r\n        calculated?: boolean;\r\n        defaultValue?: SQConstantExpr;\r\n        variations?: ArrayNamedItems<ConceptualVariationSource>;\r\n        aggregateBehavior?: ConceptualAggregateBehavior;\r\n    }\r\n\r\n    export interface ConceptualMeasure {\r\n        kpi?: ConceptualPropertyKpi;\r\n    }\r\n\r\n    export interface ConceptualPropertyKpi {\r\n        statusMetadata: DataViewKpiColumnMetadata;\r\n        trendMetadata?: DataViewKpiColumnMetadata;\r\n        status?: ConceptualProperty;\r\n        goal?: ConceptualProperty;\r\n        trend?: ConceptualProperty;\r\n    }\r\n\r\n    export const enum ConceptualVisibility {\r\n        Visible = 0,\r\n        Hidden = 1,\r\n        ShowAsVariationsOnly = 2,\r\n        IsPrivate = 4,\r\n    }\r\n\r\n    export const enum ConceptualQueryableState {\r\n        Queryable = 0,\r\n        Error = 1,\r\n    }\r\n\r\n    export const enum ConceptualMultiplicity {\r\n        ZeroOrOne = 0,\r\n        One = 1,\r\n        Many = 2,\r\n    }\r\n\r\n    export const enum ConceptualPropertyKind {\r\n        Column,\r\n        Measure,\r\n        Kpi,\r\n    }\r\n\r\n    export const enum ConceptualDefaultAggregate {\r\n        Default,\r\n        None,\r\n        Sum,\r\n        Count,\r\n        Min,\r\n        Max,\r\n        Average,\r\n        DistinctCount,\r\n    }\r\n\r\n    // TODO: Remove this (replaced by ValueType)\r\n    export enum ConceptualDataCategory {\r\n        None,\r\n        Address,\r\n        City,\r\n        Company,\r\n        Continent,\r\n        Country,\r\n        County,\r\n        Date,\r\n        Image,\r\n        ImageUrl,\r\n        Latitude,\r\n        Longitude,\r\n        Organization,\r\n        Place,\r\n        PostalCode,\r\n        Product,\r\n        StateOrProvince,\r\n        WebUrl,\r\n    }\r\n\r\n    export const enum ConceptualAggregateBehavior {\r\n        Default,\r\n        DiscourageAcrossGroups,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import FederatedConceptualSchema = powerbi.data.FederatedConceptualSchema;\r\n    import FieldExprColumnPattern = powerbi.data.FieldExprColumnPattern;\r\n    import FieldExprColumnAggrPattern = powerbi.data.FieldExprColumnAggrPattern;\r\n    import FieldExprColumnHierarchyLevelVariationPattern = powerbi.data.FieldExprColumnHierarchyLevelVariationPattern;\r\n    import FieldExprEntityPattern = powerbi.data.FieldExprEntityPattern;\r\n    import FieldExprEntityAggrPattern = powerbi.data.FieldExprEntityAggrPattern;\r\n    import FieldExprHierarchyPattern = powerbi.data.FieldExprHierarchyPattern;\r\n    import FieldExprHierarchyLevelPattern = powerbi.data.FieldExprHierarchyLevelPattern;\r\n    import FieldExprHierarchyLevelAggrPattern = powerbi.data.FieldExprHierarchyLevelAggrPattern;\r\n    import FieldExprMeasurePattern = powerbi.data.FieldExprMeasurePattern;\r\n    import FieldExprPattern = powerbi.data.FieldExprPattern;\r\n    import FieldExprPercentilePattern = powerbi.data.FieldExprPercentilePattern;\r\n    import FieldExprSelectRefPattern = powerbi.data.FieldExprSelectRefPattern;\r\n    import FieldExprPercentOfGrandTotalPattern = powerbi.data.FieldExprPercentOfGrandTotalPattern;\r\n    import IFieldExprPatternVisitor = powerbi.data.IFieldExprPatternVisitor;\r\n    import QueryProjectionsByRole = data.QueryProjectionsByRole;\r\n\r\n    export interface ScriptResult {\r\n        source: string;\r\n        provider: string;\r\n    }\r\n\r\n    export module ScriptResultUtil {\r\n\r\n        export function findScriptResult(dataViewMappings: DataViewMapping[] | data.CompiledDataViewMapping[]): DataViewScriptResultMapping | data.CompiledDataViewScriptResultMapping {\r\n            if (dataViewMappings && dataViewMappings.length === 1) {\r\n                return dataViewMappings[0].scriptResult;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResult(dataViewMappings: data.CompiledDataViewMapping[]): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult) {\r\n                let objects = dataViewMappings[0].metadata.objects;\r\n                let source: string = DataViewObjects.getValue<string>(objects, scriptResult.script.source);\r\n                let provider: string = DataViewObjects.getValue<string>(objects, scriptResult.script.provider);\r\n                return {\r\n                    source: source,\r\n                    provider: provider\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResultFromVisualConfig(dataViewMappings: DataViewMapping[], objects: powerbi.data.DataViewObjectDefinitions): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult && objects) {\r\n                let scriptSource = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\r\n                let provider = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\r\n                return {\r\n                    source: scriptSource ? scriptSource.value : null,\r\n                    provider: provider ? provider.value : null\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function getScriptInput(projections: QueryProjectionsByRole, selects: ArrayNamedItems<data.NamedSQExpr>, schema: FederatedConceptualSchema): data.ScriptInput {\r\n            let scriptInput: data.ScriptInput = {\r\n                VariableName: \"dataset\",\r\n                Columns: []\r\n            };\r\n\r\n            // Go over all the projections, and create an input column according to the order\r\n            // of the projections (including duplicate expressions)\r\n            if (projections && selects && !_.isEmpty(selects)) {\r\n                let scriptInputColumnNames: string[] = [];\r\n                let scriptInputColumns: data.ScriptInputColumn[] = [];\r\n                for (let role in projections) {\r\n                    for (let projection of projections[role].all()) {\r\n                        let select = selects.withName(projection.queryRef);\r\n                        if (select) {\r\n                            let scriptInputColumn = <data.ScriptInputColumn>{\r\n                                QueryName: select.name,\r\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\r\n                            };\r\n\r\n                            scriptInputColumns.push(scriptInputColumn);\r\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Make sure the names of the columns are unique\r\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\r\n\r\n                // Update the names of the columns\r\n                for (let i = 0; i < scriptInputColumnNames.length; i++) {\r\n                    let scriptInputColumn = scriptInputColumns[i];\r\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\r\n                }\r\n\r\n                scriptInput.Columns = scriptInputColumns;\r\n            }\r\n\r\n            return scriptInput;\r\n        }\r\n\r\n        class ScriptInputColumnNameVisitor implements IFieldExprPatternVisitor<string>\r\n        {\r\n            private federatedSchema: FederatedConceptualSchema;\r\n\r\n            constructor(federatedSchema: FederatedConceptualSchema) {\r\n                this.federatedSchema = federatedSchema;\r\n            }\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): string {\r\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): string {\r\n                return entity.entity;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): string {\r\n                return entityAggr.entity;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): string {\r\n                /*Hierarchy levels are not supported yet*/\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): string {\r\n                return FieldExprPattern.visit(selectRef, this);\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): string {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): string {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n\r\n            private static getNameForHierarchy(pattern: FieldExprHierarchyPattern, federatedScheam: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedScheam.schema(pattern.schema),\r\n                    hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\r\n\r\n                if (hierarchy)\r\n                    return hierarchy.name;\r\n            }\r\n\r\n            private static getNameForProperty(pattern: data.FieldExprPropertyPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedSchema.schema(pattern.schema),\r\n                    property = schema.findProperty(pattern.entity, pattern.name);\r\n\r\n                if (property)\r\n                    return property.name;\r\n            }\r\n\r\n            private static getVariationLevelName(pattern: FieldExprColumnHierarchyLevelVariationPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let source = pattern.source;\r\n                let prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\r\n                if (!prop)\r\n                    return;\r\n\r\n                let variations = prop.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === pattern.variationName)\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            if (level.name === pattern.level.level)\r\n                                return level.column.name;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.segmentation {\r\n\r\n    export interface DataViewTableSegment extends DataViewTable {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewTreeSegmentNode extends DataViewTreeNode {\r\n        /** Indicates whether the node is a duplicate of a node from a previous segment. */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export interface DataViewCategoricalSegment extends DataViewCategorical {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewMatrixSegmentNode extends DataViewMatrixNode {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export module DataViewMerger {\r\n\r\n        export function mergeDataViews(source: DataView, segment: DataView): void {\r\n\r\n            if (!DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\r\n                debug.assertFail(\"Cannot merge data views with different metadata columns\");\r\n            }\r\n\r\n            // The last segment is complete. We mark the source as complete.\r\n            if (!segment.metadata.segment)\r\n                delete source.metadata.segment;\r\n\r\n            if (source.table && segment.table)\r\n                mergeTables(source.table, <DataViewTableSegment>segment.table);\r\n\r\n            if (source.categorical && segment.categorical)\r\n                mergeCategorical(source.categorical, <DataViewCategoricalSegment>segment.categorical);\r\n\r\n            // Tree cannot support subtotals hence we can get into situations\r\n            // where a node has no children in one segment and more than 1 child\r\n            // in another segment.\r\n            if (source.tree && segment.tree)\r\n                mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\r\n\r\n            if (source.matrix && segment.matrix)\r\n                mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTables(source: DataViewTable, segment: DataViewTableSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            if (_.isEmpty(segment.rows))\r\n                return;\r\n\r\n            let mergeIndex = segment.lastMergeIndex + 1;\r\n            merge(source.rows, segment.rows, mergeIndex);\r\n\r\n            debug.assert(!source.identity === !segment.identity, 'The existence of identity in the new segment is different than the source');\r\n            if (segment.identity)\r\n                merge(source.identity, segment.identity, mergeIndex);\r\n        }\r\n\r\n        /**\r\n         * Merge categories values and identities\r\n         *\r\n         * Note: Public for testability\r\n         */\r\n        export function mergeCategorical(source: DataViewCategorical, segment: DataViewCategoricalSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            // Merge categories values and identities\r\n            if (source.categories && segment.categories) {\r\n                let segmentCategoriesLength = segment.categories.length;\r\n                debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\r\n\r\n                for (let categoryIndex: number = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\r\n                    let segmentCategory = segment.categories[categoryIndex];\r\n                    let sourceCategory = source.categories[categoryIndex];\r\n\r\n                    debug.assert(DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\r\n                    debug.assert(_.isUndefined(sourceCategory.values) ? _.isUndefined(sourceCategory.identity) : true, 'Source category is missing values but has identities.');\r\n\r\n                    let mergeIndex = segment.lastMergeIndex + 1;\r\n                    if (segmentCategory.values) {\r\n                        merge(sourceCategory.values, segmentCategory.values, mergeIndex);\r\n                    }\r\n\r\n                    if (segmentCategory.identity) {\r\n                        merge(sourceCategory.identity, segmentCategory.identity, mergeIndex);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Merge values for each value column\r\n            if (source.values && segment.values) {\r\n                let segmentValuesLength = segment.values.length;\r\n                debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\r\n\r\n                for (let valueIndex: number = 0; valueIndex < segmentValuesLength; valueIndex++) {\r\n                    let segmentValue = segment.values[valueIndex];\r\n                    let sourceValue = source.values[valueIndex];\r\n\r\n                    debug.assert(DataViewAnalysis.areMetadataColumnsEquivalent(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\r\n\r\n                    if (!sourceValue.values && segmentValue.values) {\r\n                        sourceValue.values = [];\r\n                    }\r\n\r\n                    let mergeIndex = segment.lastMergeIndex + 1;\r\n                    if (segmentValue.values) {\r\n                        merge(sourceValue.values, segmentValue.values, mergeIndex);\r\n                    }\r\n\r\n                    if (segmentValue.highlights) {\r\n                        merge(sourceValue.highlights, segmentValue.highlights, mergeIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Merges the segment array starting at the specified index into the source array\r\n         * and returns the segment slice that wasn't merged.\r\n         * The segment array is spliced up to specified index in the process.\r\n         */\r\n        function merge(source: any[], segment: any[], index?: number): any[] {\r\n            if (index >= segment.length)\r\n                return segment;\r\n\r\n            let result: any[] = [];\r\n            if (index !== undefined)\r\n                result = segment.splice(0, index);\r\n\r\n            Array.prototype.push.apply(source, segment);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTreeNodes(sourceRoot: DataViewTreeNode, segmentRoot: DataViewTreeNode, allowDifferentStructure: boolean): void {\r\n            debug.assertValue(sourceRoot, 'sourceRoot');\r\n            debug.assertValue(segmentRoot, 'segmentRoot');\r\n\r\n            if (!segmentRoot.children || segmentRoot.children.length === 0)\r\n                return;\r\n\r\n            if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\r\n                sourceRoot.children = segmentRoot.children;\r\n                return;\r\n            }\r\n\r\n            debug.assert(sourceRoot.children && sourceRoot.children.length >= 0,\r\n                \"Source tree has different structure than segment.\");\r\n\r\n            let firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\r\n            let lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\r\n            let mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\r\n\r\n            if (mergedChildren.length > 0)\r\n                mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\r\n        }\r\n\r\n        function findFirstAppendIndex(children: DataViewTreeNode[]): number {\r\n            if (children.length === 0)\r\n                return 0;\r\n\r\n            let i: number = 0;\r\n            for (; i < children.length; i++) {\r\n                let childSegment: DataViewTreeSegmentNode = <DataViewTreeSegmentNode>children[i];\r\n                if (!childSegment.isMerge)\r\n                    break;\r\n            }\r\n\r\n            return i;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Rewrites an expression tree, including all descendant nodes. */\r\n    export class SQExprRewriter implements ISQExprVisitor<SQExpr>, IFillRuleDefinitionVisitor<LinearGradient2Definition, LinearGradient3Definition> {\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQColumnRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQMeasureRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(rewrittenArg, expr.func);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPercentileExpr(rewrittenArg, expr.k, expr.exclusive);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyExpr(rewrittenArg, expr.hierarchy);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyLevelExpr(rewrittenArg, expr.level);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitAnd(orig: SQAndExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQAndExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitBetween(orig: SQBetweenExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this),\r\n                origLower = orig.lower,\r\n                rewrittenLower = origLower.accept(this),\r\n                origUpper = orig.upper,\r\n                rewrittenUpper = origUpper.accept(this);\r\n\r\n            if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\r\n                return orig;\r\n\r\n            return new SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\r\n        }\r\n\r\n        public visitIn(orig: SQInExpr): SQExpr {\r\n            let origArgs = orig.args,\r\n                rewrittenArgs = this.rewriteAll(origArgs),\r\n                origValues: SQExpr[][] = orig.values,\r\n                rewrittenValues: SQExpr[][];\r\n\r\n            for (let i = 0, len = origValues.length; i < len; i++) {\r\n                let origValueTuple = origValues[i],\r\n                    rewrittenValueTuple = this.rewriteAll(origValueTuple);\r\n\r\n                if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\r\n                    rewrittenValues = ArrayExtensions.take(origValues, i);\r\n\r\n                if (rewrittenValues)\r\n                    rewrittenValues.push(rewrittenValueTuple);\r\n            }\r\n\r\n            if (origArgs === rewrittenArgs && !rewrittenValues)\r\n                return orig;\r\n\r\n            return new SQInExpr(rewrittenArgs, rewrittenValues || origValues);\r\n        }\r\n\r\n        private rewriteAll(origExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(origExprs, 'origExprs');\r\n\r\n            let rewrittenResult: SQExpr[];\r\n            for (let i = 0, len = origExprs.length; i < len; i++) {\r\n                let origExpr = origExprs[i],\r\n                    rewrittenExpr = origExpr.accept(this);\r\n\r\n                if (origExpr !== rewrittenExpr && !rewrittenResult)\r\n                    rewrittenResult = ArrayExtensions.take(origExprs, i);\r\n\r\n                if (rewrittenResult)\r\n                    rewrittenResult.push(rewrittenExpr);\r\n            }\r\n\r\n            return rewrittenResult || origExprs;\r\n        }\r\n\r\n        public visitOr(orig: SQOrExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQOrExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitCompare(orig: SQCompareExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitContains(orig: SQContainsExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQContainsExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitExists(orig: SQExistsExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQExistsExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitNot(orig: SQNotExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQNotExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitStartsWith(orig: SQStartsWithExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQStartsWithExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitDateSpan(orig: SQDateSpanExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateSpanExpr(orig.unit, rewrittenArg);\r\n        }\r\n\r\n        public visitDateAdd(orig: SQDateAddExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\r\n        }\r\n\r\n        public visitNow(orig: SQNowExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitDefaultValue(orig: SQDefaultValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitAnyValue(orig: SQAnyValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitArithmetic(orig: SQArithmeticExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\r\n        }\r\n\r\n        public visitScopedEval(orig: SQScopedEvalExpr): SQExpr {\r\n            let origExpression = orig.expression,\r\n                rewrittenExpression = origExpression.accept(this),\r\n                origScope = orig.scope,\r\n                rewrittenScope = this.rewriteAll(origScope);\r\n\r\n            if (origExpression === rewrittenExpression && origScope === rewrittenScope)\r\n                return orig;\r\n\r\n            return new SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\r\n        }\r\n\r\n        public visitFillRule(orig: SQFillRuleExpr): SQExpr {\r\n            let origInput = orig.input,\r\n                rewrittenInput = origInput.accept(this);\r\n\r\n            let origRule = orig.rule;\r\n\r\n            let origGradient2 = origRule.linearGradient2,\r\n                rewrittenGradient2 = origGradient2;\r\n            if (origGradient2) {\r\n                rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\r\n            }\r\n\r\n            let origGradient3 = origRule.linearGradient3,\r\n                rewrittenGradient3 = origGradient3;\r\n            if (origGradient3) {\r\n                rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\r\n            }\r\n\r\n            if (origInput !== rewrittenInput ||\r\n                origGradient2 !== rewrittenGradient2 ||\r\n                origGradient3 !== rewrittenGradient3) {\r\n                let rewrittenRule: FillRuleDefinition = {};\r\n                if (rewrittenGradient2)\r\n                    rewrittenRule.linearGradient2 = rewrittenGradient2;\r\n                if (rewrittenGradient3)\r\n                    rewrittenRule.linearGradient3 = rewrittenGradient3;\r\n\r\n                return new SQFillRuleExpr(rewrittenInput, rewrittenRule);\r\n            }\r\n\r\n            return orig;\r\n        }\r\n\r\n        public visitLinearGradient2(origGradient2: LinearGradient2Definition): LinearGradient2Definition {\r\n            debug.assertValue(origGradient2, 'origGradient2');\r\n\r\n            let origMin = origGradient2.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMax = origGradient2.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient2;\r\n        }\r\n\r\n        public visitLinearGradient3(origGradient3: LinearGradient3Definition): LinearGradient3Definition {\r\n            debug.assertValue(origGradient3, 'origGradient3');\r\n\r\n            let origMin = origGradient3.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMid = origGradient3.mid,\r\n                rewrittenMid = this.visitFillRuleStop(origMid),\r\n                origMax = origGradient3.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    mid: rewrittenMid,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient3;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): RuleColorStopDefinition {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            let origColor = stop.color,\r\n                rewrittenColor = stop.color.accept(this);\r\n\r\n            let origValue = stop.value,\r\n                rewrittenValue = origValue;\r\n            if (origValue)\r\n                rewrittenValue = origValue.accept(this);\r\n\r\n            if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\r\n                let rewrittenStop: RuleColorStopDefinition = {\r\n                    color: rewrittenColor\r\n                };\r\n\r\n                if (rewrittenValue)\r\n                    rewrittenStop.value = rewrittenValue;\r\n\r\n                return rewrittenStop;\r\n            }\r\n\r\n            return stop;\r\n        }\r\n\r\n        public visitResourcePackageItem(orig: SQResourcePackageItemExpr): SQExpr {\r\n            return orig;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Responsible for writing equality comparisons against a field to an SQInExpr. */\r\n    export module EqualsToInRewriter {\r\n        export function run(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(new Rewriter());\r\n        }\r\n\r\n        class Rewriter extends SQExprRewriter {\r\n            private current: InBuilder;\r\n\r\n            constructor() {\r\n                super();\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): SQExpr {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return this.visitUnsupported(expr);\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let leftIsComparand = this.isComparand(expr.left);\r\n                let rightIsComparand = this.isComparand(expr.right);\r\n                if (leftIsComparand === rightIsComparand)\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let operand: SQExpr = leftIsComparand\r\n                    ? expr.left\r\n                    : expr.right;\r\n                let value: SQExpr = leftIsComparand\r\n                    ? expr.right\r\n                    : expr.left;\r\n\r\n                let current = this.current;\r\n                if (!current) {\r\n                    return SQExprBuilder.inExpr([operand], [[value]]);\r\n                }\r\n\r\n                current.add(operand, value);\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitOr(expr: SQOrExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current: InBuilder;\r\n                if (!this.current) {\r\n                    current = this.current = new InBuilder();\r\n                }\r\n\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n\r\n                if (current) {\r\n                    this.current = null;\r\n                    return current.complete() || expr;\r\n                }\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current = this.current;\r\n                if (current) {\r\n                    // NOTE: Composite keys are not supported by this algorithm.\r\n                    current.cancel();\r\n                    return expr;\r\n                }\r\n\r\n                return super.visitAnd(expr);\r\n            }\r\n\r\n            private visitUnsupported(expr: SQExpr): SQExpr {\r\n                let current = this.current;\r\n                if (current)\r\n                    current.cancel();\r\n\r\n                return expr;\r\n            }\r\n\r\n            private isSupported(expr: SQExpr): boolean {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return expr instanceof SQCompareExpr\r\n                    || expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQConstantExpr\r\n                    || expr instanceof SQHierarchyLevelExpr\r\n                    || expr instanceof SQOrExpr\r\n                    || expr instanceof SQAndExpr;\r\n            }\r\n\r\n            private isComparand(expr: SQExpr): boolean {\r\n                return expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQHierarchyLevelExpr;\r\n            }\r\n        }\r\n\r\n        class InBuilder {\r\n            private operand: SQExpr;\r\n            private values: SQExpr[];\r\n            private cancelled: boolean;\r\n\r\n            public add(operand: SQExpr, value: SQExpr): void {\r\n                debug.assertValue(operand, 'operand');\r\n                debug.assertValue(value, 'value');\r\n\r\n                if (this.cancelled)\r\n                    return;\r\n\r\n                if (this.operand && !SQExpr.equals(operand, this.operand)) {\r\n                    this.cancel();\r\n                    return;\r\n                }\r\n\r\n                this.operand = operand;\r\n\r\n                let values = this.values;\r\n                if (!values)\r\n                    values = this.values = [];\r\n\r\n                values.push(value);\r\n            }\r\n\r\n            public cancel(): void {\r\n                this.cancelled = true;\r\n            }\r\n\r\n            public complete(): SQInExpr {\r\n                if (this.cancelled || !this.operand)\r\n                    return;\r\n\r\n                return SQExprBuilder.inExpr([this.operand], _.map(this.values, v => [v]));\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface FilterValueScopeIdsContainer {\r\n            isNot: boolean;\r\n            scopeIds: DataViewScopeIdentity[];\r\n        }\r\n\r\n    export module SQExprConverter {\r\n        export function asScopeIdsContainer(filter: SemanticFilter, fieldSQExprs: SQExpr[]): FilterValueScopeIdsContainer {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\r\n\r\n            let filterItems = filter.conditions();\r\n            debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\r\n            let filterItem = filterItems[0];\r\n            if (filterItem) {\r\n                let visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\r\n                if (filterItem.accept(visitor))\r\n                    return visitor.getResult();\r\n            }\r\n        }\r\n\r\n        /** Gets a comparand value from the given DataViewScopeIdentity. */\r\n        export function getFirstComparandValue(identity: DataViewScopeIdentity): any {\r\n            debug.assertValue(identity, 'identity');\r\n\r\n            let comparandExpr = (<SQExpr>identity.expr).accept(new FindComparandVisitor());\r\n            if (comparandExpr)\r\n                return comparandExpr.value;\r\n        }\r\n    }\r\n\r\n    /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\r\n    class FilterScopeIdsCollectorVisitor extends DefaultSQExprVisitor<boolean>{\r\n        private isRoot: boolean;\r\n        private isNot: boolean;\r\n        private keyExprsCount: number;\r\n        private valueExprs: SQExpr[];\r\n        private fieldExprs: SQExpr[];\r\n\r\n        constructor(fieldSQExprs:SQExpr[]) {\r\n            super();\r\n            this.isRoot = true;\r\n            this.isNot = false;\r\n            this.keyExprsCount = null;\r\n            this.valueExprs = [];\r\n\r\n            // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\r\n            // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\r\n            // need to drop it in order to use JsonComparer.\r\n            this.fieldExprs = [];\r\n            for (let field of fieldSQExprs) {\r\n                this.fieldExprs.push(SQExprBuilder.removeEntityVariables(field));\r\n            }\r\n        }\r\n\r\n        public getResult(): FilterValueScopeIdsContainer {\r\n            debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');            \r\n\r\n            let valueExprs = this.valueExprs,\r\n                scopeIds: DataViewScopeIdentity[] = [];\r\n            let valueCount: number = this.keyExprsCount || 1;\r\n\r\n            for (let startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\r\n                let values = valueExprs.slice(startIndex, endIndex);\r\n                let scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\r\n\r\n                if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, DataViewScopeIdentity.equals))\r\n                    scopeIds.push(scopeId);\r\n\r\n                startIndex += valueCount;\r\n                endIndex += valueCount;\r\n            }\r\n\r\n            return {\r\n                isNot: this.isNot,\r\n                scopeIds: scopeIds,\r\n            };\r\n        }\r\n\r\n        private static getScopeIdentity(fieldExprs: SQExpr[], valueExprs: SQExpr[]): DataViewScopeIdentity {\r\n            debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\r\n            debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\r\n\r\n            let compoundSQExpr: SQExpr;\r\n            for (let i = 0, len = fieldExprs.length; i < len; i++) {\r\n                let equalsExpr = SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\r\n                if (!compoundSQExpr)\r\n                    compoundSQExpr = equalsExpr;\r\n                else\r\n                    compoundSQExpr = SQExprBuilder.and(compoundSQExpr, equalsExpr);\r\n            }\r\n\r\n            return createDataViewScopeIdentity(compoundSQExpr);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): boolean {\r\n            if (!this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isNot = true;\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): boolean {\r\n            if (this.isRoot && expr.type.primitiveType === PrimitiveType.Null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);            \r\n            return true;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n\r\n            if (expr.comparison !== QueryComparisonKind.Equal)\r\n                return this.unsupportedSQExpr();\r\n\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): boolean {\r\n            this.keyExprsCount = 0;\r\n            let result: boolean;\r\n            this.isRoot = false;\r\n            for (let arg of expr.args) {\r\n                result = arg.accept(this);\r\n                if (!result)\r\n                    return this.unsupportedSQExpr();\r\n\r\n                this.keyExprsCount++;\r\n            }\r\n\r\n            if (this.keyExprsCount !== this.fieldExprs.length)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let values = expr.values;\r\n            for (let valueTuple of values) {\r\n                let jlen = valueTuple.length;\r\n                debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\r\n\r\n                for (let value of valueTuple) {\r\n                    result = value.accept(this);\r\n                    if (!result)\r\n                        return this.unsupportedSQExpr();\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): boolean {\r\n            if (this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let fixedExpr = SQExprBuilder.removeEntityVariables(expr);\r\n            if (this.keyExprsCount !== null)\r\n                return SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\r\n\r\n            return SQExpr.equals(this.fieldExprs[0], fixedExpr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): boolean {\r\n            return this.unsupportedSQExpr();\r\n        }\r\n\r\n        private unsupportedSQExpr(): boolean {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    class FindComparandVisitor extends DefaultSQExprVisitor<SQConstantExpr> {\r\n        public visitAnd(expr: SQAndExpr): SQConstantExpr {\r\n            return expr.left.accept(this) || expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQConstantExpr {\r\n            if (expr.comparison === QueryComparisonKind.Equal) {\r\n                if (expr.right instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.right;\r\n                if (expr.left instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.left;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\r\n    export module ScopeIdentityExtractor {\r\n        export function getKeys(expr: SQExpr): SQExpr[] {\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return null;\r\n\r\n            return ArrayExtensions.emptyToNull(extractor.keys);\r\n        }\r\n\r\n        export function getInExpr(expr: SQExpr): SQInExpr{\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return;\r\n            \r\n            let keys = ArrayExtensions.emptyToNull(extractor.keys);\r\n            let keyValues = ArrayExtensions.emptyToNull(extractor.values);\r\n\r\n            if (keys && keyValues)\r\n                return data.SQExprBuilder.inExpr(keys, [keyValues]);\r\n        }\r\n\r\n        /**\r\n         * Recognizes expressions of the form:\r\n         * 1) Equals(ColRef, Constant)\r\n         * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\r\n         * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\r\n         */\r\n        class ScopeIdExtractorImpl extends DefaultSQExprVisitor<void> {\r\n            public keys: SQExpr[] = [];\r\n            public values: SQConstantExpr[] = [];\r\n            public malformed: boolean;\r\n\r\n            public visitAnd(expr: SQAndExpr): void {\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): void {\r\n                if (expr.comparison !== QueryComparisonKind.Equal) {\r\n                    this.visitDefault(expr);\r\n                    return;\r\n                }\r\n                debug.assert(expr.left instanceof SQExpr && expr.right instanceof SQConstantExpr, 'invalid compare expr operands');\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): void {\r\n                this.values.push(expr);\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): void {\r\n                this.malformed = true;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module PrimitiveValueEncoding {\r\n        const SingleQuoteRegex = /'/g;\r\n\r\n        export function decimal(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'M';\r\n        }\r\n\r\n        export function double(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'D';\r\n        }\r\n\r\n        export function integer(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'L';\r\n        }\r\n\r\n        export function dateTime(value: Date): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\r\n            // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\r\n            // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\r\n            let date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\r\n            let dateTimeString = date.toISOString();\r\n\r\n            // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\r\n            // we will drop it.\r\n            // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\r\n            if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\r\n                dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\r\n            return \"datetime'\" + dateTimeString + \"'\";\r\n        }\r\n\r\n        export function text(value: string): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\r\n        }\r\n\r\n        export function nullEncoding(): string {\r\n            return 'null';\r\n        }\r\n\r\n        export function boolean(value: boolean): string {\r\n            return value ? 'true' : 'false';\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Agg = powerbi.data.QueryAggregateFunction;\r\n\r\n    export interface ISQAggregationOperations {\r\n        /** Returns an array of supported aggregates for a given expr and role type. */\r\n        getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[];\r\n\r\n        isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean;\r\n\r\n        createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr;\r\n    }\r\n\r\n    export function createSQAggregationOperations(datetimeMinMaxSupported: boolean): ISQAggregationOperations {\r\n        return new SQAggregationOperations(datetimeMinMaxSupported);\r\n    }\r\n\r\n    class SQAggregationOperations implements ISQAggregationOperations {\r\n        constructor(private datetimeMinMaxSupported: boolean) {\r\n        }\r\n\r\n        public getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[] {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertAnyValue(targetTypes, 'targetTypes');\r\n\r\n            let metadata = getMetadataForUnderlyingType(expr, schema);\r\n\r\n            // don't use expr.validate as validate will be using this function and we end up in a recursive loop\r\n            if (!metadata)\r\n                return [];\r\n\r\n            let valueType = metadata.type,\r\n                fieldKind = metadata.kind,\r\n                isPropertyIdentity = metadata.idOnEntityKey;\r\n\r\n            if (!valueType)\r\n                return [];\r\n\r\n            // Cannot aggregate on model measures\r\n            if (fieldKind === FieldKind.Measure)\r\n                return [];\r\n\r\n            if (valueType.numeric || valueType.integer) {\r\n                let aggregates = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                let currentSchema = schema.schema(fieldExprItem.schema);\r\n                if (currentSchema.capabilities.supportsMedian)\r\n                    aggregates.push(Agg.Median);\r\n\r\n                return aggregates;\r\n            }\r\n\r\n            let aggregates: QueryAggregateFunction[] = [];\r\n\r\n            // Min/Max of DateTime\r\n            if (this.datetimeMinMaxSupported &&\r\n                valueType.dateTime &&\r\n                (_.isEmpty(targetTypes) || ValueType.isCompatibleTo(valueType, targetTypes))) {\r\n                aggregates.push(Agg.Min);\r\n                aggregates.push(Agg.Max);\r\n            }\r\n\r\n            // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\r\n            // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\r\n            let distinctCountAggExists = SQExprInfo.getAggregate(expr) === Agg.Count;\r\n            if (!(isPropertyIdentity && !distinctCountAggExists))\r\n                aggregates.push(Agg.Count);\r\n\r\n            aggregates.push(Agg.CountNonNull);\r\n\r\n            return aggregates;\r\n        }\r\n\r\n        public isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\r\n            return _.contains(supportedAggregates, aggregate);\r\n        }\r\n\r\n        public createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n            if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\r\n                aggregate = preferredAggregate;\r\n            }\r\n            else {\r\n                aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\r\n            }\r\n            if (aggregate !== undefined)\r\n                expr = SQExprBuilder.aggregate(expr, aggregate);\r\n\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    function getMetadataForUnderlyingType(expr: SQExpr, schema: FederatedConceptualSchema): SQExprMetadata {\r\n        // Unwrap the aggregate (if the expr has one), and look at the underlying type.\r\n        let metadata = SQExprBuilder.removeAggregate(expr).getMetadata(schema);\r\n\r\n        if (!metadata)\r\n            metadata = expr.getMetadata(schema);\r\n\r\n        return metadata;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module SQHierarchyExprUtils {\r\n        export function getConceptualHierarchyLevelFromExpr(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            fieldExpr: FieldExprPattern): ConceptualHierarchyLevel {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            let hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\r\n            if (hierarchyLevel)\r\n                return SQHierarchyExprUtils.getConceptualHierarchyLevel(\r\n                    conceptualSchema,\r\n                    fieldExprItem.schema,\r\n                    fieldExprItem.entity,\r\n                    hierarchyLevel.name,\r\n                    hierarchyLevel.level);\r\n        }\r\n\r\n        export function getConceptualHierarchyLevel(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            schemaName: string,\r\n            entity: string,\r\n            hierarchy: string,\r\n            hierarchyLevel: string): ConceptualHierarchyLevel {\r\n\r\n            let schema = conceptualSchema.schema(schemaName);\r\n            let conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\r\n            if (conceptualHierarchy) {\r\n                return conceptualHierarchy.levels.withName(hierarchyLevel);\r\n            }\r\n        }\r\n\r\n        export function getConceptualHierarchy(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): ConceptualHierarchy {\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchy = <SQHierarchyExpr>sqExpr;\r\n\r\n                if (sqExpr.arg instanceof SQEntityExpr) {\r\n                    let entityExpr = <SQEntityExpr>sqExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(entityExpr.schema)\r\n                        .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\r\n                } else if (sqExpr.arg instanceof SQPropertyVariationSourceExpr) {\r\n                    let variationExpr = <SQPropertyVariationSourceExpr>sqExpr.arg;\r\n                    let sourceEntityExpr = <SQEntityExpr>variationExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(sourceEntityExpr.schema)\r\n                        .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function expandExpr(schema: FederatedConceptualSchema, expr: SQExpr, suppressHierarchyLevelExpansion?: boolean): SQExpr | SQExpr[] {\r\n            return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\r\n                SQExprVariationConverter.expand(expr, schema) ||\r\n                // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\r\n                (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\r\n                expr;\r\n        }\r\n\r\n        export function isHierarchyOrVariation(schema: FederatedConceptualSchema, expr: SQExpr): boolean {\r\n            if (expr instanceof SQHierarchyExpr || expr instanceof SQHierarchyLevelExpr)\r\n                return true;\r\n\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Return column reference expression for hierarchy level expression.\r\n        export function getSourceVariationExpr(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\r\n\r\n                return SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\r\n            }\r\n        }\r\n\r\n        // Return hierarchy expression for hierarchy level expression.\r\n        export function getSourceHierarchy(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQHierarchyExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            let hierarchyLevel = fieldExprPattern.hierarchyLevel;\r\n            if (hierarchyLevel) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\r\n                return SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\r\n            }\r\n        }\r\n\r\n        export function getHierarchySourceAsVariationSource(hierarchyLevelExpr: SQHierarchyLevelExpr): SQPropertyVariationSourceExpr {\r\n\r\n            // Make sure the hierarchy level source is a hierarchy\r\n            if (!(hierarchyLevelExpr.arg instanceof SQHierarchyExpr))\r\n                return;\r\n                        \r\n            // Check if the hierarchy source if a variation\r\n            let hierarchyRef = <SQHierarchyExpr>hierarchyLevelExpr.arg;\r\n            if (hierarchyRef.arg instanceof SQPropertyVariationSourceExpr)\r\n                return <SQPropertyVariationSourceExpr>hierarchyRef.arg;\r\n        }\r\n\r\n        /**\r\n        * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\r\n        */\r\n        export function areHierarchyLevelsOrdered(allLevels: SQHierarchyLevelExpr[], firstExpr: SQExpr, secondExpr: SQExpr): boolean {\r\n\r\n            // Validate that both items hierarchy levels\r\n            if (!(firstExpr instanceof SQHierarchyLevelExpr) || !(secondExpr instanceof SQHierarchyLevelExpr))\r\n                return false;\r\n\r\n            let firstLevel = <SQHierarchyLevelExpr>firstExpr;\r\n            let secondLevel = <SQHierarchyLevelExpr>secondExpr;\r\n\r\n            // Validate that both items belong to the same hierarchy\r\n            if (!SQExpr.equals(firstLevel.arg, secondLevel.arg))\r\n                return false;\r\n\r\n            // Determine the order\r\n            let firstIndex = SQExprUtils.indexOfExpr(allLevels, firstLevel);\r\n            let secondIndex = SQExprUtils.indexOfExpr(allLevels, secondLevel);\r\n\r\n            return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\r\n        }\r\n\r\n        /**\r\n         * Given an ordered set of levels and an ordered subset of those levels, returns the index where\r\n         * expr should be inserted into the subset to maintain the correct order.\r\n         */\r\n        export function getInsertionIndex(allLevels: SQHierarchyLevelExpr[], orderedSubsetOfLevels: SQHierarchyLevelExpr[], expr: SQHierarchyLevelExpr): number {\r\n\r\n            let insertIndex = 0;\r\n\r\n            // Loop through the supplied levels until the insertion would no longer be in the correct order\r\n            while (insertIndex < orderedSubsetOfLevels.length &&\r\n                areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\r\n                insertIndex++;\r\n            }\r\n\r\n            return insertIndex;\r\n        }\r\n    }\r\n\r\n    export module SQExprHierarchyToHierarchyLevelConverter {\r\n        export function convert(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(sqExpr, 'sqExpr');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchyExpr = <SQHierarchyExpr>sqExpr;\r\n\r\n                let conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\r\n                if (conceptualHierarchy)\r\n                    return _.map(conceptualHierarchy.levels, hierarchyLevel => SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name));\r\n            }\r\n        }\r\n    }\r\n\r\n    module SQExprHierarchyLevelConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n            let exprs: SQExpr[] = [];\r\n\r\n            if (expr instanceof SQHierarchyLevelExpr) {\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                if (fieldExpr.hierarchyLevel) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                    let hierarchy = schema\r\n                        .schema(fieldExprItem.schema)\r\n                        .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\r\n\r\n                    if (hierarchy) {\r\n                        let hierarchyLevels = hierarchy.levels;\r\n                        for (let hierarchyLevel of hierarchyLevels) {\r\n                            if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\r\n                                exprs.push(expr);\r\n                                break;\r\n                            }\r\n                            else\r\n                                exprs.push(\r\n                                    SQExprBuilder.hierarchyLevel(\r\n                                        SQExprBuilder.hierarchy(\r\n                                            SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                            hierarchy.name),\r\n                                        hierarchyLevel.name)\r\n                                );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return exprs;\r\n        }\r\n    }\r\n\r\n    module SQExprVariationConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n\r\n            let exprs: SQExpr[];\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0) {\r\n                    let variations = column.variations;\r\n\r\n                    // for SU11, we support only one variation\r\n                    debug.assert(variations.length === 1, \"variations.length\");\r\n                    let variation = variations[0];\r\n\r\n                    let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                    exprs = [];\r\n                    if (variation.defaultHierarchy) {\r\n                        let hierarchyExpr = SQExprBuilder.hierarchy(\r\n                            SQExprBuilder.propertyVariationSource(\r\n                                SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                variation.name, conceptualProperty.name),\r\n                            variation.defaultHierarchy.name);\r\n\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            exprs.push(SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\r\n                    }\r\n                }\r\n            }\r\n\r\n            return exprs;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    // A group can consist of either a single expression, or a collection of hierarchy expressions\r\n    export interface SQExprGroup {\r\n        expr: SQExpr;\r\n        children: SQHierarchyLevelExpr[];\r\n\r\n        /** Index of expression in the query. */\r\n        selectQueryIndex: number;\r\n    };\r\n\r\n    export module SQExprGroupUtils {\r\n        /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\r\n        export function groupExprs(schema: FederatedConceptualSchema, exprs: SQExpr[]): SQExprGroup[] {\r\n            let groups: SQExprGroup[] = [];\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i];\r\n                debug.assertValue(expr, \"Expression not found\");\r\n\r\n                if (!(expr instanceof SQHierarchyLevelExpr)) {\r\n                    groups.push({ expr: expr, children: null, selectQueryIndex: i });\r\n                }\r\n                else {\r\n                    addChildToGroup(schema, groups, expr, i);\r\n                }\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function addChildToGroup(\r\n            schema: FederatedConceptualSchema,\r\n            groups: SQExprGroup[],\r\n            expr: SQHierarchyLevelExpr,\r\n            selectQueryIndex: number): void {\r\n\r\n            // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \r\n            // a new Group or to the last Group\r\n            let shouldAddExpressionToNewGroup = true;\r\n            let exprSource = SQHierarchyExprUtils.getSourceVariationExpr(expr) || SQHierarchyExprUtils.getSourceHierarchy(expr);\r\n            let lastGroup = _.last(groups);\r\n\r\n            // The relevant group is always the last added. If it has the same source hierarchy,\r\n            // and is properly ordered within that hierarchy, we will need to add to this group.\r\n            if (lastGroup && lastGroup.children && SQExpr.equals(lastGroup.expr, exprSource)) {\r\n                let expandedExpr = SQHierarchyExprUtils.expandExpr(schema, expr.arg);\r\n                if (expandedExpr instanceof Array) {\r\n                    let allHierarchyLevels = <SQHierarchyLevelExpr[]>expandedExpr;\r\n                    shouldAddExpressionToNewGroup = !SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\r\n                }\r\n            }\r\n\r\n            if (shouldAddExpressionToNewGroup)\r\n                // Use the Sourcevariation as the expression for the group.\r\n                groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\r\n            else {\r\n                debug.assertValue(lastGroup, 'There should be a group to add the variation to');\r\n                debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\r\n                lastGroup.children.push(expr);\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    /** Represents an immutable expression within a SemanticQuery. */\r\n    export abstract class SQExpr implements ISQExpr {\r\n        private _kind: SQExprKind;\r\n\r\n        constructor(kind: SQExprKind) {\r\n            debug.assertValue(kind, 'kind');\r\n\r\n            this._kind = kind;\r\n        }\r\n\r\n        public static equals(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            return SQExprEqualityVisitor.run(x, y, ignoreCase);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.accept(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            debug.assertFail('abstract method');\r\n            return;\r\n        }\r\n\r\n        public get kind(): SQExprKind {\r\n            return this._kind;\r\n        }\r\n\r\n        public static isColumn(expr: SQExpr): expr is SQColumnRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ColumnRef;\r\n        }\r\n\r\n        public static isConstant(expr: SQExpr): expr is SQConstantExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Constant;\r\n        }\r\n\r\n        public static isEntity(expr: SQExpr): expr is SQEntityExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Entity;\r\n        }\r\n\r\n        public static isHierarchy(expr: SQExpr): expr is SQHierarchyExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Hierarchy;\r\n        }\r\n\r\n        public static isHierarchyLevel(expr: SQExpr): expr is SQHierarchyLevelExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.HierarchyLevel;\r\n        }\r\n\r\n        public static isAggregation(expr: SQExpr): expr is SQAggregationExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Aggregation;\r\n        }\r\n\r\n        public static isMeasure(expr: SQExpr): expr is SQMeasureRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.MeasureRef;\r\n        }\r\n\r\n        public static isSelectRef(expr: SQExpr): expr is SQSelectRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.SelectRef;\r\n        }\r\n\r\n        public static isResourcePackageItem(expr: SQExpr): expr is SQResourcePackageItemExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ResourcePackageItem;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            if (field.column || field.columnAggr || field.measure)\r\n                return this.getMetadataForProperty(field, federatedSchema);\r\n\r\n            if (field.hierarchyLevel || field.hierarchyLevelAggr)\r\n                return this.getMetadataForHierarchyLevel(field, federatedSchema);\r\n\r\n            if (field.columnHierarchyLevelVariation)\r\n                return this.getMetadataForVariation(field, federatedSchema);\r\n\r\n            if (field.percentOfGrandTotal)\r\n                return this.getMetadataForPercentOfGrandTotal();\r\n\r\n            return SQExpr.getMetadataForEntity(field, federatedSchema);\r\n        }\r\n\r\n        public getDefaultAggregate(federatedSchema: FederatedConceptualSchema, forceAggregation: boolean = false): QueryAggregateFunction {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n\r\n            if (property && property.kind === ConceptualPropertyKind.Column) {\r\n                let propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\r\n\r\n                if ((property.type.integer || property.type.numeric) &&\r\n                    propertyDefaultAggregate !== ConceptualDefaultAggregate.None) {\r\n                    aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\r\n                    if (aggregate === undefined)\r\n                        aggregate = defaultAggregateForDataType(property.type);\r\n                }\r\n\r\n                // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \r\n                // aggregate on CountNonNull.\r\n                if (aggregate === undefined && forceAggregation) {\r\n                    aggregate = QueryAggregateFunction.CountNonNull;\r\n                }\r\n            }\r\n\r\n            return aggregate;\r\n        }\r\n\r\n        /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\r\n        public getKeyColumns(schema: FederatedConceptualSchema): SQExpr[] {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n\r\n            let keySQExprs: SQExpr[] = [];\r\n            let keys = this.getPropertyKeys(schema);\r\n            if (keys && keys.length > 0) {\r\n                for (let i = 0, len = keys.length; i < len; i++) {\r\n                    keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\r\n                }\r\n            }\r\n            else\r\n                keySQExprs.push(columnRefExpr);\r\n\r\n            return keySQExprs;\r\n        }\r\n\r\n        /** Returns a value indicating whether the expression would group on keys other than itself.*/\r\n        public hasGroupOnKeys(schema: FederatedConceptualSchema): boolean {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n            let keys = this.getPropertyKeys(schema);\r\n\r\n            if (!keys || keys.length < 1)\r\n                return false;\r\n\r\n            if (keys.length > 1)\r\n                return true;\r\n\r\n            let keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\r\n            return !SQExpr.equals(keySqExpr, this);\r\n        }\r\n\r\n        private getPropertyKeys(schema: FederatedConceptualSchema): jsCommon.ArrayNamedItems<ConceptualProperty> {\r\n            let property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            return property.column ? property.column.keys : undefined;\r\n        }\r\n\r\n        public getConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let propertyName = FieldExprPattern.getPropertyName(field);\r\n\r\n            if (propertyName)\r\n                return federatedSchema\r\n                    .schema(fieldExprItem.schema)\r\n                    .findProperty(fieldExprItem.entity, propertyName);\r\n        }\r\n\r\n        public getTargetEntityForVariation(federatedSchema: FederatedConceptualSchema, variationName: string): string {\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (property && property.column && !_.isEmpty(property.column.variations)) {\r\n                let variations = property.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === variationName)\r\n                        return variation.navigationProperty.targetEntity.name;\r\n            }\r\n        }\r\n\r\n        public getTargetEntity(federatedSchema: FederatedConceptualSchema): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\r\n        }\r\n\r\n        private getHierarchyLevelConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\r\n            if (fieldExprHierachyLevel) {\r\n                let fieldExprEntity = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n\r\n                let hierarchy = federatedSchema\r\n                    .schema(fieldExprEntity.schema)\r\n                    .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\r\n\r\n                if (hierarchy) {\r\n                    let hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\r\n                    if (hierarchyLevel)\r\n                        return hierarchyLevel.column;\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForVariation(field: data.FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let sourceProperty = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\r\n\r\n            if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\r\n                for (let variation of sourceProperty.column.variations) {\r\n                    if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\r\n                        for (let level of variation.defaultHierarchy.levels) {\r\n                            if (level.name === columnHierarchyLevelVariation.level.level) {\r\n                                let property = level.column;\r\n                                return {\r\n                                    kind: (property.kind === ConceptualPropertyKind.Measure) ? FieldKind.Measure : FieldKind.Column,\r\n                                    type: property.type,\r\n                                    format: property.format,\r\n                                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                                    defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n                                };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForHierarchyLevel(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private getMetadataForPercentOfGrandTotal(): SQExprMetadata {\r\n            return {\r\n                kind: FieldKind.Measure,\r\n                format: '#,##0.##%',\r\n                type: ValueType.fromExtendedType(ExtendedType.Double)\r\n            };\r\n        }\r\n\r\n        private getPropertyMetadata(field: FieldExprPattern, property: ConceptualProperty): SQExprMetadata {\r\n            let format = property.format;\r\n            let type = property.type;\r\n            let columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\r\n\r\n            if (columnAggregate) {\r\n                switch (columnAggregate.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        type = ValueType.fromExtendedType(ExtendedType.Integer);\r\n                        format = undefined;\r\n                        break;\r\n                    case QueryAggregateFunction.Avg:\r\n                        if (type.integer)\r\n                            type = ValueType.fromExtendedType(ExtendedType.Double);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return {\r\n                kind: (property.kind === ConceptualPropertyKind.Measure || (columnAggregate && columnAggregate.aggregate !== undefined)) ? FieldKind.Measure : FieldKind.Column,\r\n                type: type,\r\n                format: format,\r\n                idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\r\n                defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n            };\r\n        }\r\n\r\n        private getMetadataForProperty(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private static getMetadataForEntity(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let entity = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .entities\r\n                .withName(fieldExprItem.entity);\r\n\r\n            if (!entity)\r\n                return;\r\n\r\n            // We only support count and countnonnull for entity.\r\n            if (field.entityAggr) {\r\n                switch (field.entityAggr.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        return {\r\n                            kind: FieldKind.Measure,\r\n                            type: ValueType.fromExtendedType(ExtendedType.Integer),\r\n                            format: undefined,\r\n                            idOnEntityKey: false,\r\n                            aggregate: field.entityAggr.aggregate\r\n                        };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export const enum SQExprKind {\r\n        Entity,\r\n        ColumnRef,\r\n        MeasureRef,\r\n        Aggregation,\r\n        PropertyVariationSource,\r\n        Hierarchy,\r\n        HierarchyLevel,\r\n        And,\r\n        Between,\r\n        In,\r\n        Or,\r\n        Contains,\r\n        Compare,\r\n        StartsWith,\r\n        Exists,\r\n        Not,\r\n        Constant,\r\n        DateSpan,\r\n        DateAdd,\r\n        Now,\r\n        AnyValue,\r\n        DefaultValue,\r\n        Arithmetic,\r\n        FillRule,\r\n        ResourcePackageItem,\r\n        ScopedEval,\r\n        Scope,\r\n        Percentile,\r\n        SelectRef,\r\n    }\r\n\r\n    export interface SQExprMetadata {\r\n        kind: FieldKind;\r\n        type: ValueType;\r\n        format?: string;\r\n        idOnEntityKey?: boolean;\r\n        aggregate?: QueryAggregateFunction;\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n    }\r\n\r\n    export const enum FieldKind {\r\n        /** Indicates the field references a column, which evaluates to a distinct set of values (e.g., Year, Name, SalesQuantity, etc.). */\r\n        Column,\r\n\r\n        /** Indicates the field references a measure, which evaluates to a single value (e.g., SalesYTD, Sum(Sales), etc.). */\r\n        Measure,\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateForDataType(type: ValueType): QueryAggregateFunction {\r\n        if (type.integer || type.numeric)\r\n            return QueryAggregateFunction.Sum;\r\n\r\n        return QueryAggregateFunction.Count;\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateToQueryAggregateFunction(aggregate: ConceptualDefaultAggregate): QueryAggregateFunction {\r\n        switch (aggregate) {\r\n            case ConceptualDefaultAggregate.Average:\r\n                return QueryAggregateFunction.Avg;\r\n            case ConceptualDefaultAggregate.Count:\r\n                return QueryAggregateFunction.CountNonNull;\r\n            case ConceptualDefaultAggregate.DistinctCount:\r\n                return QueryAggregateFunction.Count;\r\n            case ConceptualDefaultAggregate.Max:\r\n                return QueryAggregateFunction.Max;\r\n            case ConceptualDefaultAggregate.Min:\r\n                return QueryAggregateFunction.Min;\r\n            case ConceptualDefaultAggregate.Sum:\r\n                return QueryAggregateFunction.Sum;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    export class SQEntityExpr extends SQExpr {\r\n        public schema: string;\r\n        public entity: string;\r\n        public variable: string;\r\n\r\n        constructor(schema: string, entity: string, variable?: string) {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            super(SQExprKind.Entity);\r\n            this.schema = schema;\r\n            this.entity = entity;\r\n            if (variable)\r\n                this.variable = variable;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitEntity(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQArithmeticExpr extends SQExpr {\r\n        public left: SQExpr;\r\n        public right: SQExpr;\r\n        public operator: ArithmeticOperatorKind;\r\n\r\n        constructor(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n            debug.assertValue(operator, 'operator');\r\n\r\n            super(SQExprKind.Arithmetic);\r\n            this.left = left;\r\n            this.right = right;\r\n            this.operator = operator;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitArithmetic(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQScopedEvalExpr extends SQExpr {\r\n        public expression: SQExpr;\r\n        public scope: SQExpr[];\r\n\r\n        constructor(expression: SQExpr, scope: SQExpr[]) {\r\n            debug.assertValue(expression, 'expression');\r\n            debug.assertValue(scope, 'scope');\r\n\r\n            super(SQExprKind.ScopedEval);\r\n            this.expression = expression;\r\n            this.scope = scope;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitScopedEval(this, arg);\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            return this.expression.getMetadata(federatedSchema);\r\n        }\r\n    }\r\n\r\n    export abstract class SQPropRefExpr extends SQExpr {\r\n        public ref: string;\r\n        public source: SQExpr;\r\n\r\n        constructor(kind: SQExprKind, source: SQExpr, ref: string) {\r\n            debug.assertValue(kind, 'kind');\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            super(kind);\r\n            this.source = source;\r\n            this.ref = ref;\r\n        }\r\n    }\r\n\r\n    export class SQColumnRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.ColumnRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitColumnRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQMeasureRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.MeasureRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitMeasureRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAggregationExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public func: QueryAggregateFunction;\r\n\r\n        constructor(arg: SQExpr, func: QueryAggregateFunction) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(func, 'func');\r\n\r\n            super(SQExprKind.Aggregation);\r\n            this.arg = arg;\r\n            this.func = func;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAggr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPercentileExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public k: number;\r\n        public exclusive: boolean;\r\n\r\n        constructor(arg: SQExpr, k: number, exclusive: boolean) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(k, 'k');\r\n            debug.assert(0 <= k && k <= 1, '0 <= k && k <= 1');\r\n            debug.assertValue(exclusive, 'exclusive');\r\n\r\n            super(SQExprKind.Percentile);\r\n            this.arg = arg;\r\n            this.k = k;\r\n            this.exclusive = exclusive;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let argMetadata = this.arg.getMetadata(federatedSchema);\r\n            if (argMetadata) {\r\n                return {\r\n                    kind: FieldKind.Measure,\r\n                    type: argMetadata.type,\r\n                };\r\n            }\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPercentile(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPropertyVariationSourceExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public name: string;\r\n        public property: string;\r\n\r\n        constructor(arg: SQExpr, name: string, property: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(name, 'name');\r\n            debug.assertValue(property, 'property');\r\n\r\n            super(SQExprKind.PropertyVariationSource);\r\n            this.arg = arg;\r\n            this.name = name;\r\n            this.property = property;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPropertyVariationSource(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public hierarchy: string;\r\n\r\n        constructor(arg: SQExpr, hierarchy: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n\r\n            super(SQExprKind.Hierarchy);\r\n            this.arg = arg;\r\n            this.hierarchy = hierarchy;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchy(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyLevelExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public level: string;\r\n\r\n        constructor(arg: SQExpr, level: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(level, 'level');\r\n\r\n            super(SQExprKind.HierarchyLevel);\r\n            this.arg = arg;\r\n            this.level = level;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchyLevel(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQSelectRefExpr extends SQExpr {\r\n        public expressionName: string;\r\n\r\n        constructor(expressionName: string) {\r\n            debug.assertValue(expressionName, 'arg');\r\n\r\n            super(SQExprKind.SelectRef);\r\n            this.expressionName = expressionName;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitSelectRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAndExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.And);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQBetweenExpr extends SQExpr {\r\n        arg: SQExpr;\r\n        lower: SQExpr;\r\n        upper: SQExpr;\r\n\r\n        constructor(arg: SQExpr, lower: SQExpr, upper: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(lower, 'lower');\r\n            debug.assertValue(upper, 'upper');\r\n\r\n            super(SQExprKind.Between);\r\n            this.arg = arg;\r\n            this.lower = lower;\r\n            this.upper = upper;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitBetween(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQInExpr extends SQExpr {\r\n        args: SQExpr[];\r\n        values: SQExpr[][];\r\n\r\n        constructor(args: SQExpr[], values: SQExpr[][]) {\r\n            debug.assertValue(args, 'args');\r\n            debug.assertValue(values, 'values');\r\n\r\n            super(SQExprKind.In);\r\n            this.args = args;\r\n            this.values = values;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitIn(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQOrExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Or);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitOr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQCompareExpr extends SQExpr {\r\n        comparison: QueryComparisonKind;\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(comparison: QueryComparisonKind, left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(comparison, 'kind');\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Compare);\r\n            this.comparison = comparison;\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitCompare(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQContainsExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Contains);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitContains(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQStartsWithExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.StartsWith);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitStartsWith(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQExistsExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Exists);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitExists(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNotExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Not);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNot(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQConstantExpr extends SQExpr implements ISQConstantExpr {\r\n        public type: ValueType;\r\n\r\n        /** The native JavaScript representation of the value. */\r\n        public value: any;\r\n\r\n        /** The string encoded, lossless representation of the value. */\r\n        public valueEncoded: string;\r\n\r\n        constructor(type: ValueType, value: any, valueEncoded: string) {\r\n            debug.assertValue(type, 'type');\r\n\r\n            super(SQExprKind.Constant);\r\n            this.type = type;\r\n            this.value = value;\r\n            this.valueEncoded = valueEncoded;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitConstant(this, arg);\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            return {\r\n                // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\r\n                // A getType or similiar function in the future would be more appropriate. \r\n                kind: FieldKind.Measure,\r\n                type: this.type,\r\n            };\r\n        }\r\n    }\r\n\r\n    export class SQDateSpanExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateSpan);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateSpan(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDateAddExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public amount: number;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, amount: number, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(amount, 'amount');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateAdd);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n            this.amount = amount;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateAdd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNowExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.Now);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNow(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDefaultValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.DefaultValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDefaultValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAnyValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.AnyValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnyValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQFillRuleExpr extends SQExpr {\r\n        public input: SQExpr;\r\n        public rule: FillRuleDefinition;\r\n\r\n        constructor(\r\n            input: SQExpr,\r\n            fillRule: FillRuleDefinition) {\r\n            debug.assertValue(input, 'input');\r\n            debug.assertValue(fillRule, 'fillRule');\r\n\r\n            super(SQExprKind.FillRule);\r\n            this.input = input;\r\n            this.rule = fillRule;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitFillRule(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQResourcePackageItemExpr extends SQExpr {\r\n        public packageName: string;\r\n        public packageType: number;\r\n        public itemName: string;\r\n\r\n        constructor(packageName: string, packageType: number, itemName: string) {\r\n            debug.assertValue(packageName, 'packageName');\r\n            debug.assertValue(itemName, 'itemName');\r\n\r\n            super(SQExprKind.ResourcePackageItem);\r\n            this.packageName = packageName;\r\n            this.packageType = packageType;\r\n            this.itemName = itemName;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitResourcePackageItem(this, arg);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for creating & manipulating expressions. */\r\n    export module SQExprBuilder {\r\n        export function entity(schema: string, entity: string, variable?: string): SQEntityExpr {\r\n            return new SQEntityExpr(schema, entity, variable);\r\n        }\r\n\r\n        export function columnRef(source: SQExpr, prop: string): SQColumnRefExpr {\r\n            return new SQColumnRefExpr(source, prop);\r\n        }\r\n\r\n        export function measureRef(source: SQExpr, prop: string): SQMeasureRefExpr {\r\n            return new SQMeasureRefExpr(source, prop);\r\n        }\r\n\r\n        export function aggregate(source: SQExpr, aggregate: QueryAggregateFunction): SQAggregationExpr {\r\n            return new SQAggregationExpr(source, aggregate);\r\n        }\r\n\r\n        export function selectRef(expressionName: string): SQSelectRefExpr {\r\n            return new SQSelectRefExpr(expressionName);\r\n        }\r\n\r\n        export function percentile(source: SQExpr, k: number, exclusive: boolean): SQPercentileExpr {\r\n            return new SQPercentileExpr(source, k, exclusive);\r\n        }\r\n\r\n        export function arithmetic(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind): SQArithmeticExpr {\r\n            return new SQArithmeticExpr(left, right, operator);\r\n        }\r\n\r\n        export function scopedEval(expression: SQExpr, scope: SQExpr[]): SQScopedEvalExpr {\r\n            return new SQScopedEvalExpr(expression, scope);\r\n        }\r\n\r\n        export function hierarchy(source: SQExpr, hierarchy: string): SQHierarchyExpr {\r\n            return new SQHierarchyExpr(source, hierarchy);\r\n        }\r\n\r\n        export function propertyVariationSource(source: SQExpr, name: string, property: string): SQPropertyVariationSourceExpr {\r\n            return new SQPropertyVariationSourceExpr(source, name, property);\r\n        }\r\n\r\n        export function hierarchyLevel(source: SQExpr, level: string): SQHierarchyLevelExpr {\r\n            return new SQHierarchyLevelExpr(source, level);\r\n        }\r\n\r\n        export function and(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n\r\n            return new SQAndExpr(left, right);\r\n        }\r\n\r\n        export function between(arg: SQExpr, lower: SQExpr, upper: SQExpr): SQBetweenExpr {\r\n            return new SQBetweenExpr(arg, lower, upper);\r\n        }\r\n\r\n        export function inExpr(args: SQExpr[], values: SQExpr[][]): SQInExpr {\r\n            return new SQInExpr(args, values);\r\n        }\r\n\r\n        export function or(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n            if (left instanceof SQInExpr && right instanceof SQInExpr) {\r\n                let inExpr = tryUseInExprs(<SQInExpr>left, <SQInExpr>right);\r\n                if (inExpr)\r\n                    return inExpr;\r\n            }\r\n\r\n            return new SQOrExpr(left, right);\r\n        }\r\n\r\n        function tryUseInExprs(left: SQInExpr, right: SQInExpr): SQInExpr {\r\n            if (!left.args || !right.args)\r\n                return;\r\n\r\n            let leftArgLen = left.args.length;\r\n            let rightArgLen = right.args.length;\r\n            if (leftArgLen !== rightArgLen)\r\n                return;\r\n\r\n            for (let i = 0; i < leftArgLen; ++i) {\r\n                if (!SQExpr.equals(left.args[i], right.args[i]))\r\n                    return;\r\n            }\r\n\r\n            let combinedValues = left.values.concat(right.values);\r\n            return SQExprBuilder.inExpr(left.args, combinedValues);\r\n        }\r\n\r\n        export function compare(kind: QueryComparisonKind, left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return new SQCompareExpr(kind, left, right);\r\n        }\r\n\r\n        export function contains(left: SQExpr, right: SQExpr): SQContainsExpr {\r\n            return new SQContainsExpr(left, right);\r\n        }\r\n\r\n        export function exists(arg: SQExpr): SQExistsExpr {\r\n            return new SQExistsExpr(arg);\r\n        }\r\n\r\n        export function equal(left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return compare(QueryComparisonKind.Equal, left, right);\r\n        }\r\n\r\n        export function not(arg: SQExpr): SQNotExpr {\r\n            return new SQNotExpr(arg);\r\n        }\r\n\r\n        export function startsWith(left: SQExpr, right: SQExpr): SQStartsWithExpr {\r\n            return new SQStartsWithExpr(left, right);\r\n        }\r\n\r\n        export function nullConstant(): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Null),\r\n                null,\r\n                PrimitiveValueEncoding.nullEncoding());\r\n        }\r\n\r\n        export function now(): SQNowExpr {\r\n            return new SQNowExpr();\r\n        }\r\n\r\n        export function defaultValue(): SQDefaultValueExpr {\r\n            return new SQDefaultValueExpr();\r\n        }\r\n\r\n        export function anyValue(): SQAnyValueExpr {\r\n            return new SQAnyValueExpr();\r\n        }\r\n\r\n        export function boolean(value: boolean): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Boolean),\r\n                value,\r\n                PrimitiveValueEncoding.boolean(value));\r\n        }\r\n\r\n        export function dateAdd(unit: TimeUnit, amount: number, arg: SQExpr): SQDateAddExpr {\r\n            return new SQDateAddExpr(unit, amount, arg);\r\n        }\r\n\r\n        export function dateTime(value: Date, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.dateTime(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.DateTime), value, valueEncoded);\r\n        }\r\n\r\n        export function dateSpan(unit: TimeUnit, arg: SQExpr): SQDateSpanExpr {\r\n            return new SQDateSpanExpr(unit, arg);\r\n        }\r\n\r\n        export function decimal(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.decimal(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Decimal), value, valueEncoded);\r\n        }\r\n\r\n        export function double(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.double(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Double), value, valueEncoded);\r\n        }\r\n\r\n        export function integer(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.integer(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Integer), value, valueEncoded);\r\n        }\r\n\r\n        export function text(value: string, valueEncoded?: string): SQConstantExpr {\r\n            debug.assert(!valueEncoded || valueEncoded === PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\r\n\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Text),\r\n                value,\r\n                valueEncoded || PrimitiveValueEncoding.text(value));\r\n        }\r\n\r\n        /** Returns an SQExpr that evaluates to the constant value. */\r\n        export function typedConstant(value: PrimitiveValue, type: ValueTypeDescriptor): SQConstantExpr {\r\n            if (value == null)\r\n                return nullConstant();\r\n\r\n            if (_.isBoolean(value)) {\r\n                return boolean(<boolean>value);\r\n            }\r\n\r\n            if (_.isString(value)) {\r\n                return text(<string>value);\r\n            }\r\n\r\n            if (_.isNumber(value)) {\r\n                if (type.integer && Double.isInteger(<number>value))\r\n                    return integer(<number>value);\r\n\r\n                return double(<number>value);\r\n            }\r\n\r\n            if (value instanceof Date) {\r\n                return dateTime(value);\r\n            }\r\n        }\r\n\r\n        export function setAggregate(expr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return FieldExprChangeAggregateRewriter.rewrite(expr, aggregate);\r\n        }\r\n\r\n        export function removeAggregate(expr: SQExpr): SQExpr {\r\n            return FieldExprRemoveAggregateRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function setPercentOfGrandTotal(expr: SQExpr): SQExpr {\r\n            return SQExprSetPercentOfGrandTotalRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removePercentOfGrandTotal(expr: SQExpr): SQExpr {\r\n            return SQExprRemovePercentOfGrandTotalRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removeEntityVariables(expr: SQExpr): SQExpr {\r\n            return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function fillRule(expr: SQExpr, rule: FillRuleDefinition): SQFillRuleExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(rule, 'rule');\r\n\r\n            return new SQFillRuleExpr(expr, rule);\r\n        }\r\n\r\n        export function resourcePackageItem(packageName: string, packageType: number, itemName: string): SQResourcePackageItemExpr {\r\n            return new SQResourcePackageItemExpr(packageName, packageType, itemName);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for obtaining information about expressions. */\r\n    export module SQExprInfo {\r\n        export function getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            return SQExprAggregateInfoVisitor.getAggregate(expr);\r\n        }\r\n    }\r\n\r\n    class SQExprEqualityVisitor implements ISQExprVisitorWithArg<boolean, SQExpr>, IFillRuleDefinitionVisitor<boolean, boolean> {\r\n        private static instance: SQExprEqualityVisitor = new SQExprEqualityVisitor(/* ignoreCase */ false);\r\n        private static ignoreCaseInstance: SQExprEqualityVisitor = new SQExprEqualityVisitor(true);\r\n        private ignoreCase: boolean;\r\n\r\n        public static run(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n            if (ignoreCase)\r\n                return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\r\n\r\n            return x.accept(SQExprEqualityVisitor.instance, y);\r\n        }\r\n\r\n        constructor(ignoreCase: boolean) {\r\n            this.ignoreCase = ignoreCase;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, comparand: SQColumnRefExpr): boolean {\r\n            return comparand instanceof SQColumnRefExpr &&\r\n                expr.ref === (<SQColumnRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQColumnRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, comparand: SQMeasureRefExpr): boolean {\r\n            return comparand instanceof SQMeasureRefExpr &&\r\n                expr.ref === (<SQMeasureRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQMeasureRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAggregationExpr &&\r\n                expr.func === (<SQAggregationExpr>comparand).func &&\r\n                this.equals(expr.arg, (<SQAggregationExpr>comparand).arg);\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQPercentileExpr &&\r\n                expr.exclusive === comparand.exclusive &&\r\n                expr.k === comparand.k &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, comparand: SQHierarchyExpr): boolean {\r\n            return comparand instanceof SQHierarchyExpr &&\r\n                expr.hierarchy === comparand.hierarchy &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, comparand: SQHierarchyLevelExpr): boolean {\r\n            return comparand instanceof SQHierarchyLevelExpr &&\r\n                expr.level === comparand.level &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, comparand: SQPropertyVariationSourceExpr): boolean {\r\n            return comparand instanceof SQPropertyVariationSourceExpr &&\r\n                expr.name === comparand.name &&\r\n                expr.property === comparand.property &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr, comparand: SQSelectRefExpr): boolean {\r\n            return comparand instanceof SQSelectRefExpr &&\r\n                expr.expressionName === comparand.expressionName;\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQBetweenExpr &&\r\n                this.equals(expr.arg, (<SQBetweenExpr>comparand).arg) &&\r\n                this.equals(expr.lower, (<SQBetweenExpr>comparand).lower) &&\r\n                this.equals(expr.upper, (<SQBetweenExpr>comparand).upper);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, comparand: SQExpr): boolean {\r\n            if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, (<SQInExpr>comparand).args))\r\n                return false;\r\n\r\n            let values = expr.values,\r\n                compareValues = (<SQInExpr>comparand).values;\r\n            if (values.length !== compareValues.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                if (!this.equalsAll(values[i], compareValues[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQEntityExpr &&\r\n                expr.schema === (<SQEntityExpr>comparand).schema &&\r\n                expr.entity === (<SQEntityExpr>comparand).entity &&\r\n                this.optionalEqual(expr.variable, (<SQEntityExpr>comparand).variable);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAndExpr &&\r\n                this.equals(expr.left, (<SQAndExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQAndExpr>comparand).right);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQOrExpr &&\r\n                this.equals(expr.left, (<SQOrExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQOrExpr>comparand).right);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQCompareExpr &&\r\n                expr.comparison === (<SQCompareExpr>comparand).comparison &&\r\n                this.equals(expr.left, (<SQCompareExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQCompareExpr>comparand).right);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQContainsExpr &&\r\n                this.equals(expr.left, (<SQContainsExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQContainsExpr>comparand).right);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateSpanExpr &&\r\n                expr.unit === (<SQDateSpanExpr>comparand).unit &&\r\n                this.equals(expr.arg, (<SQDateSpanExpr>comparand).arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateAddExpr &&\r\n                expr.unit === (<SQDateAddExpr>comparand).unit &&\r\n                expr.amount === (<SQDateAddExpr>comparand).amount &&\r\n                this.equals(expr.arg, (<SQDateAddExpr>comparand).arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQExistsExpr &&\r\n                this.equals(expr.arg, (<SQExistsExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNotExpr &&\r\n                this.equals(expr.arg, (<SQNotExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNowExpr;\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDefaultValueExpr;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAnyValueExpr;\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQResourcePackageItemExpr &&\r\n                expr.packageName === comparand.packageName &&\r\n                expr.packageType === comparand.packageType &&\r\n                expr.itemName === comparand.itemName;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQStartsWithExpr &&\r\n                this.equals(expr.left, (<SQStartsWithExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQStartsWithExpr>comparand).right);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQConstantExpr && expr.type === (<SQConstantExpr>comparand).type)\r\n                return expr.type.text && this.ignoreCase ?\r\n                    StringExtensions.equalIgnoreCase(expr.valueEncoded, (<SQConstantExpr>comparand).valueEncoded) :\r\n                    expr.valueEncoded === (<SQConstantExpr>comparand).valueEncoded;\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\r\n                let leftRule = expr.rule,\r\n                    rightRule = comparand.rule;\r\n\r\n                if (leftRule === rightRule)\r\n                    return true;\r\n\r\n                let leftLinearGradient2 = leftRule.linearGradient2,\r\n                    rightLinearGradient2 = rightRule.linearGradient2;\r\n                if (leftLinearGradient2 && rightLinearGradient2) {\r\n                    return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\r\n                }\r\n\r\n                let leftLinearGradient3 = leftRule.linearGradient3,\r\n                    rightLinearGradient3 = rightRule.linearGradient3;\r\n                if (leftLinearGradient3 && rightLinearGradient3) {\r\n                    return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitLinearGradient2(left2: LinearGradient2Definition, right2: LinearGradient2Definition): boolean {\r\n            debug.assertValue(left2, 'left2');\r\n            debug.assertValue(right2, 'right2');\r\n\r\n            return this.equalsFillRuleStop(left2.min, right2.min) &&\r\n                this.equalsFillRuleStop(left2.max, right2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(left3: LinearGradient3Definition, right3: LinearGradient3Definition): boolean {\r\n            debug.assertValue(left3, 'left3');\r\n            debug.assertValue(right3, 'right3');\r\n\r\n            return this.equalsFillRuleStop(left3.min, right3.min) &&\r\n                this.equalsFillRuleStop(left3.mid, right3.mid) &&\r\n                this.equalsFillRuleStop(left3.max, right3.max);\r\n        }\r\n\r\n        private equalsFillRuleStop(stop1: RuleColorStopDefinition, stop2: RuleColorStopDefinition): boolean {\r\n            debug.assertValue(stop1, 'stop1');\r\n            debug.assertValue(stop2, 'stop2');\r\n\r\n            if (!this.equals(stop1.color, stop2.color))\r\n                return false;\r\n\r\n            if (!stop1.value)\r\n                return stop1.value === stop2.value;\r\n\r\n            return this.equals(stop1.value, stop2.value);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQArithmeticExpr &&\r\n                expr.operator === (<SQArithmeticExpr>comparand).operator &&\r\n                this.equals(expr.left, (<SQArithmeticExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQArithmeticExpr>comparand).right);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQScopedEvalExpr &&\r\n                this.equals(expr.expression, comparand.expression) &&\r\n                this.equalsAll(expr.scope, comparand.scope);\r\n        }\r\n\r\n        private optionalEqual(x: string, y: string) {\r\n            // Only check equality if both values are specified.\r\n            if (x && y)\r\n                return x === y;\r\n\r\n            return true;\r\n        }\r\n\r\n        private equals(x: SQExpr, y: SQExpr): boolean {\r\n            return x.accept(this, y);\r\n        }\r\n\r\n        private equalsAll(x: SQExpr[], y: SQExpr[]): boolean {\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!this.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /** Rewrites a root-level expression. */\r\n    class SQExprRootRewriter extends DefaultSQExprVisitor<SQExpr> {\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    export const enum SQExprValidationError {\r\n        invalidAggregateFunction,\r\n        invalidSchemaReference,\r\n        invalidEntityReference,\r\n        invalidColumnReference,\r\n        invalidMeasureReference,\r\n        invalidHierarchyReference,\r\n        invalidHierarchyLevelReference,\r\n        invalidLeftOperandType,\r\n        invalidRightOperandType,\r\n        invalidValueType,\r\n        invalidPercentileArgument,\r\n    }\r\n\r\n    export class SQExprValidationVisitor extends SQExprRewriter {\r\n        public errors: SQExprValidationError[];\r\n        private schema: FederatedConceptualSchema;\r\n        private aggrUtils: ISQAggregationOperations;\r\n\r\n        constructor(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]) {\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertValue(aggrUtils, 'aggrUtils');\r\n\r\n            super();\r\n            this.schema = schema;\r\n            this.aggrUtils = aggrUtils;\r\n            if (errors)\r\n                this.errors = errors;\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): SQExpr {\r\n            let inExpr = <SQInExpr>super.visitIn(expr);\r\n            let args = inExpr.args;\r\n            let values = inExpr.values;\r\n            for (let valueTuple of values) {\r\n                debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\r\n                for (let i = 0, len = valueTuple.length; i < len; ++i)\r\n                    this.validateCompatibleType(args[i], valueTuple[i]);\r\n            }\r\n\r\n            return inExpr;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQExpr {\r\n            let compareExpr = <SQCompareExpr>super.visitCompare(expr);\r\n            this.validateCompatibleType(compareExpr.left, compareExpr.right);\r\n\r\n            return compareExpr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.column.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Column ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidColumnReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.measure.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Measure ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidMeasureReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let aggregateExpr = <SQAggregationExpr>super.visitAggr(expr);\r\n\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\r\n            if (columnRefExpr) {\r\n                if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/null))\r\n                    this.register(SQExprValidationError.invalidAggregateFunction);\r\n            }\r\n\r\n            return aggregateExpr;\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem: FieldExprHierarchyPattern = <FieldExprHierarchyPattern>fieldExpr.hierarchy;\r\n                if (fieldExprItem) {\r\n                    this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\r\n                } else {\r\n                    this.register(SQExprValidationError.invalidHierarchyReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let hierarchyLevelFieldExprItem: FieldExprHierarchyLevelPattern = <FieldExprHierarchyLevelPattern>fieldExpr.hierarchyLevel;\r\n                if (hierarchyLevelFieldExprItem) {\r\n                    this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\r\n                } else if (!fieldExpr.columnHierarchyLevelVariation) {\r\n                    this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): SQExpr {\r\n            expr.arg.accept(this);\r\n\r\n            if (_.isEmpty(this.errors)) {\r\n                let argMetadata = expr.arg.getMetadata(this.schema);\r\n                if (!argMetadata ||\r\n                    argMetadata.kind !== FieldKind.Column ||\r\n                    !(argMetadata.type && (argMetadata.type.integer || argMetadata.type.numeric))) {\r\n                    this.register(SQExprValidationError.invalidPercentileArgument);\r\n                }\r\n            }\r\n\r\n            return expr;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            this.validateEntity(expr.schema, expr.entity);\r\n            return expr;\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): SQExpr {\r\n            this.validateArithmeticTypes(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): SQExpr {\r\n            // No validation necessary\r\n            return expr;\r\n        }\r\n\r\n        private validateOperandsAndTypeForStartOrContains(left: SQExpr, right: SQExpr): void {\r\n            if (left instanceof SQColumnRefExpr) {\r\n                this.visitColumnRef(<SQColumnRefExpr>left);\r\n            } else if (left instanceof SQHierarchyLevelExpr) {\r\n                this.visitHierarchyLevel(<SQHierarchyLevelExpr>left);\r\n            } else {\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            }\r\n\r\n            if (!(right instanceof SQConstantExpr) || !(<SQConstantExpr>right).type.text)\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n            else\r\n                this.validateCompatibleType(left, right);\r\n        }\r\n\r\n        private validateArithmeticTypes(left: SQExpr, right: SQExpr): void {\r\n            if (!SQExprUtils.supportsArithmetic(left, this.schema))\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            if (!SQExprUtils.supportsArithmetic(right, this.schema))\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n        }\r\n\r\n        private validateCompatibleType(left: SQExpr, right: SQExpr): void {\r\n            let leftMetadata = left.getMetadata(this.schema),\r\n                leftType = leftMetadata && leftMetadata.type,\r\n                rightMetadata = right.getMetadata(this.schema),\r\n                rightType = rightMetadata && rightMetadata.type;\r\n\r\n            if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\r\n                this.register(SQExprValidationError.invalidValueType);\r\n        }\r\n\r\n        private validateEntity(schemaName: string, entityName: string): ConceptualEntity {\r\n            let schema = this.schema.schema(schemaName);\r\n            if (schema) {\r\n                let entity = schema.entities.withName(entityName);\r\n                if (entity)\r\n                    return entity;\r\n\r\n                this.register(SQExprValidationError.invalidEntityReference);\r\n            }\r\n            else {\r\n                this.register(SQExprValidationError.invalidSchemaReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchy(schemaName: string, entityName: string, hierarchyName: string): ConceptualHierarchy {\r\n            let entity = this.validateEntity(schemaName, entityName);\r\n            if (entity) {\r\n                let hierarchy = entity.hierarchies.withName(hierarchyName);\r\n                if (hierarchy)\r\n                    return hierarchy;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchyLevel(schemaName: string, entityName: string, hierarchyName: string, levelName: string): ConceptualHierarchyLevel {\r\n            let hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\r\n            if (hierarchy) {\r\n                let hierarchyLevel = hierarchy.levels.withName(levelName);\r\n                if (hierarchyLevel)\r\n                    return hierarchyLevel;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n            }\r\n        }\r\n\r\n        private register(error: SQExprValidationError) {\r\n            if (!this.errors)\r\n                this.errors = [];\r\n            this.errors.push(error);\r\n        }\r\n\r\n        private isQueryable(fieldExpr: FieldExprPattern): boolean {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\r\n                let hierarchyLevelConceptualProperty = SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\r\n                return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== ConceptualQueryableState.Error;\r\n            }\r\n\r\n            return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, FieldExprPattern.getPropertyName(fieldExpr)).queryable !== ConceptualQueryableState.Error;\r\n        }\r\n    }\r\n\r\n    /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\r\n    class SQExprAggregateInfoVisitor extends DefaultSQExprVisitor<QueryAggregateFunction> {\r\n        public visitAggr(expr: SQAggregationExpr): QueryAggregateFunction {\r\n            return expr.func;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): QueryAggregateFunction {\r\n            return;\r\n        }\r\n\r\n        public static getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            let visitor = new SQExprAggregateInfoVisitor();\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQExprColumnRef expression or undefined.*/\r\n    class SQExprColumnRefInfoVisitor extends DefaultSQExprVisitor<SQColumnRefExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQColumnRefExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let ref: string = expr.level;\r\n            let hierarchy = <SQHierarchyExpr>(expr.arg);\r\n            let sourceExpr: SQColumnRefExpr = hierarchy.accept(this);\r\n\r\n            if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\r\n                let propertyVariationSource = <SQPropertyVariationSourceExpr>hierarchy.arg;\r\n                let targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\r\n\r\n                if (sourceExpr && targetEntity) {\r\n                    let schemaName = (<SQEntityExpr>(sourceExpr.source)).schema;\r\n                    let targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\r\n                    let schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\r\n\r\n                    if (schemaHierarchy) {\r\n                        for (let level of schemaHierarchy.levels)\r\n                            if (level.name === ref)\r\n                                return new SQColumnRefExpr(targetEntityExpr, level.column.name);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let entityExpr = <SQEntityExpr>(hierarchy.arg);\r\n                let hierarchyLevelRef = SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema,\r\n                    entityExpr.schema,\r\n                    entityExpr.entity,\r\n                    hierarchy.hierarchy,\r\n                    expr.level);\r\n\r\n                if (hierarchyLevelRef)\r\n                    return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\r\n            }\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQColumnRefExpr {\r\n            let propertyName = expr.property;\r\n            return new SQColumnRefExpr(expr.arg, propertyName);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQColumnRefExpr {\r\n            return;\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQEntityExpr expression or undefined.*/\r\n    class SQEntityExprInfoVisitor extends DefaultSQExprVisitor<SQEntityExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQEntityExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntity(expr);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQEntityExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQEntityExpr {\r\n            return expr.source.accept(this);\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n\r\n        public static getEntity(columnRef: SQColumnRefExpr): SQEntityExpr {\r\n            let field = SQExprConverter.asFieldPattern(columnRef);\r\n            let column = field.column;\r\n            return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\r\n        }\r\n\r\n        public static getEntityExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQEntityExpr {\r\n            let visitor = new SQEntityExprInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    class SQExprChangeAggregateRewriter extends SQExprRootRewriter {\r\n        private func: QueryAggregateFunction;\r\n\r\n        constructor(func: QueryAggregateFunction) {\r\n            debug.assertValue(func, 'func');\r\n\r\n            super();\r\n            this.func = func;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            if (expr.func === this.func)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(expr.arg, this.func);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            return new SQAggregationExpr(expr, this.func);\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, func: QueryAggregateFunction): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(func, 'func');\r\n\r\n            let rewriter = new SQExprChangeAggregateRewriter(func);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    class FieldExprChangeAggregateRewriter implements IFieldExprPatternVisitor<SQExpr> {\r\n        private sqExpr: SQExpr;\r\n        private aggregate: QueryAggregateFunction;\r\n\r\n        constructor(sqExpr: SQExpr, aggregate: QueryAggregateFunction) {\r\n            this.sqExpr = sqExpr;\r\n            this.aggregate = aggregate;\r\n        }\r\n\r\n        public static rewrite(sqExpr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return FieldExprPattern.visit(sqExpr, new FieldExprChangeAggregateRewriter(sqExpr, aggregate));\r\n        }\r\n\r\n        public visitPercentOfGrandTotal(pattern: FieldExprPercentOfGrandTotalPattern): SQExpr {\r\n            pattern.baseExpr = SQExprConverter.asFieldPattern(\r\n                SQExprChangeAggregateRewriter.rewrite(\r\n                    SQExprBuilder.fieldExpr(pattern.baseExpr),\r\n                    this.aggregate));\r\n            return SQExprBuilder.fieldExpr({ percentOfGrandTotal: pattern });\r\n        }\r\n\r\n        public visitColumn(column: FieldExprColumnPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitSelectRef(selectRef: FieldExprSelectRefPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntity(entity: FieldExprEntityPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchy(hierarchy: FieldExprHierarchyPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitMeasure(measure: FieldExprMeasurePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitPercentile(percentile: FieldExprPercentilePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        private defaultRewrite(): SQExpr {\r\n            return SQExprChangeAggregateRewriter.rewrite(this.sqExpr, this.aggregate);\r\n        }\r\n    }\r\n\r\n    class FieldExprRemoveAggregateRewriter implements IFieldExprPatternVisitor<SQExpr> {\r\n\r\n        constructor(private sqExpr: SQExpr) {\r\n        }\r\n\r\n        public static rewrite(sqExpr: SQExpr): SQExpr {\r\n            return FieldExprPattern.visit(sqExpr, new FieldExprRemoveAggregateRewriter(sqExpr));\r\n        }\r\n\r\n        public visitPercentOfGrandTotal(pattern: FieldExprPercentOfGrandTotalPattern): SQExpr {\r\n            return FieldExprRemoveAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr));\r\n        }\r\n\r\n        public visitColumn(column: FieldExprColumnPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitSelectRef(selectRef: FieldExprSelectRefPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntity(entity: FieldExprEntityPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchy(hierarchy: FieldExprHierarchyPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitMeasure(measure: FieldExprMeasurePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitPercentile(percentile: FieldExprPercentilePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        private defaultRewrite(): SQExpr {\r\n            return SQExprRemoveAggregateRewriter.rewrite(this.sqExpr);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveAggregateRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemoveAggregateRewriter = new SQExprRemoveAggregateRewriter();\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            return expr.arg;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveAggregateRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveEntityVariablesRewriter extends SQExprRewriter {\r\n        private static instance: SQExprRemoveEntityVariablesRewriter = new SQExprRemoveEntityVariablesRewriter();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            if (expr.variable)\r\n                return SQExprBuilder.entity(expr.schema, expr.entity);\r\n\r\n            return expr;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemovePercentOfGrandTotalRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemovePercentOfGrandTotalRewriter = new SQExprRemovePercentOfGrandTotalRewriter();\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            return expr.accept(SQExprRemovePercentOfGrandTotalRewriter.instance);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr && fieldExpr.percentOfGrandTotal)\r\n                expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfGrandTotal.baseExpr);\r\n\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    class SQExprSetPercentOfGrandTotalRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprSetPercentOfGrandTotalRewriter = new SQExprSetPercentOfGrandTotalRewriter();\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            return expr.accept(SQExprSetPercentOfGrandTotalRewriter.instance);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr && !fieldExpr.percentOfGrandTotal)\r\n                expr = SQExprBuilder.fieldExpr({ percentOfGrandTotal: { baseExpr: SQExprConverter.asFieldPattern(expr) } });\r\n\r\n            return expr;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import ConceptualEntity = powerbi.data.ConceptualEntity;\r\n    import ConceptualMultiplicity = powerbi.data.ConceptualMultiplicity;\r\n    import SQEntityExpr = powerbi.data.SQEntityExpr;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    export module SQExprUtils {\r\n        export function supportsArithmetic(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let metadata = expr.getMetadata(schema),\r\n                type = metadata && metadata.type;\r\n\r\n            if (!metadata || !type) {\r\n                return false;\r\n            }\r\n            \r\n            return type.numeric || type.dateTime || type.duration;\r\n        }\r\n\r\n        export function indexOfExpr(items: SQExpr[], searchElement: SQExpr): number {\r\n            debug.assertValue(items, 'items');\r\n            debug.assertValue(searchElement, 'searchElement');\r\n\r\n            for (let i = 0, len = items.length; i < len; i++) {\r\n                if (SQExpr.equals(items[i], searchElement))\r\n                    return i;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function sequenceEqual(x: SQExpr[], y: SQExpr[]): boolean {\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!SQExpr.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n        \r\n        export function uniqueName(namedItems: NamedSQExpr[], expr: SQExpr, exprDefaultName?: string): string {\r\n            debug.assertValue(namedItems, 'namedItems');\r\n\r\n            // Determine all names\r\n            let names: { [name: string]: boolean } = {};\r\n            for (let i = 0, len = namedItems.length; i < len; i++)\r\n                names[namedItems[i].name] = true;\r\n\r\n            return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\r\n        }\r\n\r\n        /** Generates a default expression name  */\r\n        export function defaultName(expr: SQExpr, fallback: string = 'select'): string {\r\n            if (!expr)\r\n                return fallback;\r\n\r\n            return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a model measure or an aggregate. */\r\n        export function isMeasure(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsMeasureVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\r\n        export function isAnyValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsAnyValueVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\r\n        export function isDefaultValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsDefaultValueVisitor.instance);\r\n        }\r\n\r\n        export function discourageAggregation(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let capabilities = getSchemaCapabilities(expr, schema);\r\n            return capabilities && capabilities.discourageQueryAggregateUsage;\r\n        }\r\n\r\n        export function getAggregateBehavior(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualAggregateBehavior {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let column = getConceptualColumn(expr, schema);\r\n            if (column)\r\n                return column.aggregateBehavior;\r\n        }\r\n\r\n        export function getSchemaCapabilities(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualCapabilities {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(expr);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let conceptualSchema = schema.schema(fieldExprItem.schema);\r\n            if (conceptualSchema)\r\n                return conceptualSchema.capabilities;\r\n        }\r\n\r\n        export function getKpiMetadata(expr: SQExpr, schema: FederatedConceptualSchema): DataViewKpiColumnMetadata {\r\n            let kpiStatusProperty = getKpiStatusProperty(expr, schema);\r\n            if (kpiStatusProperty)\r\n                return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\r\n\r\n            let kpiTrendProperty = getKpiTrendProperty(expr, schema);\r\n            if (kpiTrendProperty)\r\n                return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\r\n        }\r\n\r\n        export function getConceptualEntity(entityExpr: SQEntityExpr, schema: FederatedConceptualSchema): ConceptualEntity {\r\n            debug.assertValue(entityExpr, 'entityExpr');\r\n\r\n            let conceptualEntity = schema\r\n                .schema(entityExpr.schema)\r\n                .entities\r\n                .withName(entityExpr.entity);\r\n            return conceptualEntity;\r\n        }\r\n\r\n        function getKpiStatusProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.status === property)\r\n                return property;\r\n        }\r\n\r\n        function getKpiTrendProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.trend === property)\r\n                return property;\r\n        }\r\n\r\n        export function getDefaultValue(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): SQConstantExpr {\r\n            let column = getConceptualColumn(fieldSQExpr, schema);\r\n            if (column)\r\n                return column.defaultValue;\r\n        }\r\n\r\n        function getConceptualColumn(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): ConceptualColumn {\r\n            if (!fieldSQExpr || !schema)\r\n                return;\r\n\r\n            let sqField = SQExprConverter.asFieldPattern(fieldSQExpr);\r\n            if (!sqField)\r\n                return;\r\n\r\n            let column: FieldExprPropertyPattern = sqField.column;\r\n\r\n            if (column) {\r\n                if (schema.schema(column.schema) && sqField.column.name) {\r\n                    let property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\r\n\r\n                    if (property)\r\n                        return property.column;\r\n                }\r\n            }\r\n            else {\r\n                let hierarchyLevelField: FieldExprHierarchyLevelPattern = sqField.hierarchyLevel;\r\n                if (hierarchyLevelField) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(sqField);\r\n                    let schemaName = fieldExprItem.schema;\r\n                    if (schema.schema(schemaName)) {\r\n                        let hierarchy = schema.schema(schemaName)\r\n                            .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\r\n\r\n                        if (hierarchy) {\r\n                            let hierarchyLevel: ConceptualHierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\r\n                            if (hierarchyLevel && hierarchyLevel.column)\r\n                                return hierarchyLevel.column.column;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function getDefaultValues(fieldSQExprs: SQExpr[], schema: FederatedConceptualSchema): SQConstantExpr[] {\r\n            if (_.isEmpty(fieldSQExprs) || !schema)\r\n                return;\r\n            let result: SQConstantExpr[] = [];\r\n            for (let sqExpr of fieldSQExprs) {\r\n                let defaultValue = getDefaultValue(sqExpr, schema);\r\n                if (defaultValue)\r\n                    result.push(defaultValue);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Return compare or and expression for key value pairs. */\r\n        export function getDataViewScopeIdentityComparisonExpr(fieldsExpr: SQExpr[], values: SQConstantExpr[]): SQExpr {\r\n            debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\r\n\r\n            let compareExprs: SQCompareExpr[] = [];\r\n            for (let i = 0; i < fieldsExpr.length; i++) {\r\n                compareExprs.push(SQExprBuilder.compare(QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\r\n            }\r\n\r\n            if (_.isEmpty(compareExprs))\r\n                return;\r\n\r\n            let resultExpr: SQExpr;\r\n            for (let compareExpr of compareExprs) {\r\n                resultExpr = SQExprBuilder.and(resultExpr, compareExpr);\r\n            }\r\n\r\n            return resultExpr;\r\n        }\r\n\r\n        export function getActiveTablesNames(queryDefn: data.SemanticQuery): string[] {\r\n            let tables: string[] = [];\r\n            if (queryDefn) {\r\n                let selectedItems = queryDefn.from();\r\n                if (selectedItems !== undefined) {\r\n                    for (let key of selectedItems.keys()) {\r\n                        let entityObj = selectedItems.entity(key);\r\n                        if (tables.indexOf(entityObj.entity) < 0)\r\n                            tables.push(entityObj.entity);\r\n                    }\r\n                }\r\n            }\r\n            return tables;\r\n        }\r\n\r\n        export function isRelatedToMany(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne);\r\n        }\r\n\r\n        export function isRelatedToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many);\r\n        }\r\n\r\n        function isRelated(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr,\r\n            sourceMultiplicity: ConceptualMultiplicity,\r\n            targetMultiplicity: ConceptualMultiplicity): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n\r\n            if (_.isEmpty(source.navigationProperties))\r\n                return false;\r\n\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let queue: ConceptualEntity[] = [];\r\n            queue.push(source);\r\n\r\n            // walk the relationship path from source.\r\n            while (!_.isEmpty(queue)) {\r\n                let current = queue.shift();\r\n\r\n                let navProperties = current.navigationProperties;\r\n                if (_.isEmpty(navProperties))\r\n                    continue;\r\n\r\n                for (let navProperty of navProperties) {\r\n                    if (!navProperty.isActive)\r\n                        continue;\r\n\r\n                    if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\r\n                        if (navProperty.targetEntity === target)\r\n                            return true;\r\n                        queue.push(navProperty.targetEntity);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRelatedOneToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let sourceNavigations = source.navigationProperties;\r\n            let targetNavigations = target.navigationProperties;\r\n\r\n            if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\r\n                return false;\r\n\r\n            return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\r\n        }\r\n\r\n        function hasOneToOneNavigation(navigationProperties: ArrayNamedItems<ConceptualNavigationProperty>, targetEntity: ConceptualEntity): boolean {\r\n            if (_.isEmpty(navigationProperties))\r\n                return false;\r\n\r\n            for (let navigationProperty of navigationProperties) {\r\n                if (!navigationProperty.isActive)\r\n                    continue;\r\n\r\n                if (navigationProperty.targetEntity !== targetEntity)\r\n                    continue;\r\n\r\n                if (navigationProperty.sourceMultiplicity === ConceptualMultiplicity.ZeroOrOne &&\r\n                    navigationProperty.targetMultiplicity === ConceptualMultiplicity.ZeroOrOne) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\r\n            and returns a new array. When available, we should use _.unionWith from lodash. */\r\n        export function concatUnique(leftExprs: SQExpr[], rightExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(leftExprs, 'leftExprs');\r\n            debug.assertValue(rightExprs, 'rightExprs');\r\n\r\n            let concatExprs = ArrayExtensions.copy(leftExprs);\r\n            for (let expr of rightExprs) {\r\n                if (indexOfExpr(concatExprs, expr) === -1) {\r\n                    concatExprs.push(expr);\r\n                }\r\n            }\r\n\r\n            return concatExprs;\r\n        }\r\n\r\n        class SQExprDefaultNameGenerator extends DefaultSQExprVisitorWithArg<string, string> {\r\n            public static instance: SQExprDefaultNameGenerator = new SQExprDefaultNameGenerator();\r\n\r\n            public visitEntity(expr: SQEntityExpr): string {\r\n                return expr.entity;\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, fallback: string): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, fallback: string): string {\r\n                return QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\r\n            }\r\n\r\n            public visitPercentile(expr: SQPercentileExpr, fallback: string): string {\r\n                let func = expr.exclusive\r\n                    ? 'Percentile.Exc('\r\n                    : 'Percentile.Inc(';\r\n\r\n                return func + expr.arg.accept(this) + ', ' + expr.k + ')';\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr, fallback: string): string {\r\n                return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): string {\r\n                return 'const';\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr, fallback: string): string {\r\n                return fallback || 'expr';\r\n            }\r\n        }\r\n\r\n        class IsMeasureVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsMeasureVisitor = new IsMeasureVisitor();\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsDefaultValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsDefaultValueVisitor = new IsDefaultValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsAnyValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsAnyValueVisitor = new IsAnyValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export class SemanticQueryRewriter {\r\n        private exprRewriter: ISQExprVisitor<SQExpr>;\r\n\r\n        constructor(exprRewriter: ISQExprVisitor<SQExpr>) {\r\n            this.exprRewriter = exprRewriter;\r\n        }\r\n\r\n        public rewriteFrom(fromValue: SQFrom): SQFrom {\r\n            let fromContents: { [name: string]: SQFromEntitySource } = {};\r\n            let originalFrom = fromValue,\r\n                originalFromKeys = originalFrom.keys();\r\n            for (let i = 0, len = originalFromKeys.length; i < len; i++) {\r\n                let keyName = originalFromKeys[i],\r\n                    originalEntityRef = originalFrom.entity(keyName),\r\n                    originalEntityExpr = SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName),\r\n                    updatedEntityExpr = <SQEntityExpr>originalEntityExpr.accept(this.exprRewriter);\r\n                \r\n                fromContents[keyName] = {\r\n                    schema: updatedEntityExpr.schema,\r\n                    entity: updatedEntityExpr.entity,\r\n                };\r\n            }\r\n            return new SQFrom(fromContents);\r\n        }\r\n\r\n        public rewriteSelect(selectItems: NamedSQExpr[], from: SQFrom): NamedSQExpr[]{\r\n            debug.assertValue(selectItems, 'selectItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            return this.rewriteNamedSQExpressions(selectItems, from);\r\n        }\r\n\r\n        public rewriteGroupBy(groupByitems: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertAnyValue(groupByitems, 'groupByitems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(groupByitems))\r\n                return;\r\n\r\n            return this.rewriteNamedSQExpressions(groupByitems, from);\r\n        }\r\n\r\n        private rewriteNamedSQExpressions(expressions: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertValue(expressions, 'expressions');\r\n\r\n            return _.map(expressions, item => {\r\n                return {\r\n                    name: item.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from)\r\n                };\r\n            });\r\n        }\r\n\r\n        public rewriteOrderBy(orderByItems: SQSortDefinition[], from: SQFrom): SQSortDefinition[]{\r\n            debug.assertAnyValue(orderByItems, 'orderByItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(orderByItems))\r\n                return;\r\n\r\n            let orderBy: SQSortDefinition[] = [];\r\n            for (let i = 0, len = orderByItems.length; i < len; i++) {\r\n                let item = orderByItems[i],\r\n                    updatedExpr = SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\r\n                orderBy.push({\r\n                        direction: item.direction,\r\n                        expr: updatedExpr,\r\n                    });\r\n            }\r\n\r\n            return orderBy;\r\n        }\r\n\r\n        public rewriteWhere(whereItems: SQFilter[], from: SQFrom): SQFilter[]{\r\n            debug.assertAnyValue(whereItems, 'whereItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(whereItems))\r\n                return;\r\n\r\n            let where: SQFilter[] = [];\r\n            for (let i = 0, len = whereItems.length; i < len; i++) {\r\n                let originalWhere = whereItems[i];\r\n\r\n                let updatedWhere: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\r\n                };\r\n\r\n                if (originalWhere.target)\r\n                    updatedWhere.target = _.map(originalWhere.target, e => SQExprRewriterWithSourceRenames.rewrite(e.accept(this.exprRewriter), from));\r\n\r\n                where.push(updatedWhere);\r\n            }\r\n\r\n            return where;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export interface NamedSQExpr {\r\n        name: string;\r\n        expr: SQExpr;\r\n    }\r\n\r\n    export interface SQFilter {\r\n        target?: SQExpr[];\r\n        condition: SQExpr;\r\n    }\r\n\r\n    /** Represents an entity reference in SemanticQuery from. */\r\n    export interface SQFromEntitySource {\r\n        entity: string;\r\n        schema: string;\r\n    }\r\n\r\n    /** Represents a sort over an expression. */\r\n    export interface SQSortDefinition {\r\n        expr: SQExpr;\r\n        direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryFromEnsureEntityResult {\r\n        name: string;\r\n        new?: boolean;\r\n    }\r\n\r\n    export interface SQSourceRenames {\r\n        [from: string]: string;\r\n    }\r\n\r\n    /**\r\n     * Represents a semantic query that is:\r\n     * 1) Round-trippable with a JSON QueryDefinition.\r\n     * 2) Immutable\r\n     * 3) Long-lived and does not have strong references to a conceptual model (only names).\r\n     */\r\n    export class SemanticQuery {\r\n        private static empty: SemanticQuery;\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n        private orderByItems: SQSortDefinition[];\r\n        private selectItems: NamedSQExpr[];\r\n        private groupByItems: NamedSQExpr[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[], orderBy: SQSortDefinition[], select: NamedSQExpr[], groupBy: NamedSQExpr[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(select, 'select');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n            this.orderByItems = orderBy;\r\n            this.selectItems = select;\r\n            this.groupByItems = groupBy;\r\n        }\r\n\r\n        public static create(): SemanticQuery {\r\n            if (!SemanticQuery.empty)\r\n                SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\r\n\r\n            return SemanticQuery.empty;\r\n        }\r\n\r\n        private static createWithTrimmedFrom(\r\n            from: SQFrom,\r\n            where: SQFilter[],\r\n            orderBy: SQSortDefinition[],\r\n            select: NamedSQExpr[],\r\n            groupBy: NamedSQExpr[]): SemanticQuery {\r\n\r\n            let unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\r\n\r\n            // Where\r\n            if (where) {\r\n                for (let i = 0, len = where.length; i < len; i++) {\r\n                    let filter = where[i];\r\n\r\n                    filter.condition.accept(unreferencedKeyFinder);\r\n\r\n                    let filterTarget = filter.target;\r\n                    if (filterTarget) {\r\n                        for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                            if (filterTarget[j])\r\n                                filterTarget[j].accept(unreferencedKeyFinder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // OrderBy\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++)\r\n                    orderBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            // Select\r\n            for (let i = 0, len = select.length; i < len; i++)\r\n                select[i].expr.accept(unreferencedKeyFinder);\r\n\r\n            // GroupBy\r\n            if (groupBy) {\r\n                for (let i = 0, len = groupBy.length; i < len; i++)\r\n                    groupBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            let unreferencedKeys = unreferencedKeyFinder.result();\r\n            for (let i = 0, len = unreferencedKeys.length; i < len; i++)\r\n                from.remove(unreferencedKeys[i]);\r\n\r\n            return new SemanticQuery(from, where, orderBy, select, groupBy);\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        /** Returns a query equivalent to this, with the specified selected items. */\r\n        select(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the items being selected in this query. */\r\n        select(): ArrayNamedItems<NamedSQExpr>;\r\n        public select(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getSelect();\r\n\r\n            return this.setSelect(values);\r\n        }\r\n\r\n        private getSelect(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.selectItems);\r\n        }\r\n\r\n        private static createNamedExpressionArray(items: NamedSQExpr[]): ArrayNamedItems<NamedSQExpr> {\r\n            return ArrayExtensions.extendWithName<NamedSQExpr>(_.map(items, s => {\r\n                return {\r\n                    name: s.name,\r\n                    expr: s.expr,\r\n                };\r\n            }));\r\n        }\r\n\r\n        private setSelect(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private static rewriteExpressionsWithSourceRenames(values: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            let items: NamedSQExpr[] = [];\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n                items.push({\r\n                    name: value.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\r\n                });\r\n            }\r\n\r\n            return items;\r\n        } \r\n\r\n        /** Removes the given expression from the select. */\r\n        public removeSelect(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let originalItems = this.selectItems,\r\n                selectItems: NamedSQExpr[] = [];\r\n            for (let i = 0, len = originalItems.length; i < len; i++) {\r\n                let originalExpr = originalItems[i];\r\n                if (SQExpr.equals(originalExpr.expr, expr))\r\n                    continue;\r\n\r\n                selectItems.push(originalExpr);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Removes the given expression from order by. */\r\n        public removeOrderBy(expr: SQExpr): SemanticQuery {\r\n            let sorts = this.orderBy();\r\n            for (let i = sorts.length - 1; i >= 0; i--) {\r\n                if (SQExpr.equals(sorts[i].expr, expr))\r\n                    sorts.splice(i, 1);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public selectNameOf(expr: SQExpr): string {\r\n            let index = SQExprUtils.indexOfExpr(_.map(this.selectItems, s => s.expr), expr);\r\n            if (index >= 0)\r\n                return this.selectItems[index].name;\r\n        }\r\n\r\n        public setSelectAt(index: number, expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (index >= this.selectItems.length)\r\n                return;\r\n\r\n            let select = this.select(),\r\n                from = this.fromValue.clone(),\r\n                originalName = select[index].name;\r\n            select[index] = {\r\n                name: originalName,\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\r\n        }\r\n\r\n        /** Adds a the expression to the select clause. */\r\n        public addSelect(expr: SQExpr, exprName?: string): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let selectItems = this.select(),\r\n                from = this.fromValue.clone();\r\n            selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private createNamedExpr(currentNames: ArrayNamedItems<NamedSQExpr>, from: SQFrom, expr: SQExpr, exprName?: string): NamedSQExpr{\r\n            return {\r\n                name: SQExprUtils.uniqueName(currentNames, expr, exprName),\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n        } \r\n\r\n        /** Returns a query equivalent to this, with the specified groupBy items. */\r\n        groupBy(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the groupby items in this query. */\r\n        groupBy(): ArrayNamedItems<NamedSQExpr>;\r\n        public groupBy(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getGroupBy();\r\n\r\n            return this.setGroupBy(values);\r\n        }\r\n\r\n        private getGroupBy(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.groupByItems);\r\n        }\r\n\r\n        private setGroupBy(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        public addGroupBy(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let groupByItems = this.groupBy(),\r\n                from = this.fromValue.clone();\r\n            groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the sorting for this query. */\r\n        orderBy(values: SQSortDefinition[]): SemanticQuery;\r\n        orderBy(): SQSortDefinition[];\r\n\r\n        public orderBy(values?: SQSortDefinition[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getOrderBy();\r\n\r\n            return this.setOrderBy(values);\r\n        }\r\n\r\n        private getOrderBy(): SQSortDefinition[] {\r\n            let result: SQSortDefinition[] = [];\r\n\r\n            let orderBy = this.orderByItems;\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++) {\r\n                    let clause = orderBy[i];\r\n\r\n                    result.push({\r\n                        expr: clause.expr,\r\n                        direction: clause.direction,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setOrderBy(values: SQSortDefinition[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedOrderBy: SQSortDefinition[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let clause = values[i];\r\n                updatedOrderBy.push({\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\r\n                    direction: clause.direction,\r\n                });\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the filters for this query. */\r\n        where(values: SQFilter[]): SemanticQuery;\r\n        where(): SQFilter[];\r\n\r\n        public where(values?: SQFilter[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getWhere();\r\n\r\n            return this.setWhere(values);\r\n        }\r\n\r\n        private getWhere(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            if (whereItems) {\r\n                for (let i = 0, len = whereItems.length; i < len; i++)\r\n                    result.push(whereItems[i]);\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setWhere(values: SQFilter[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedWhere: SQFilter[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let filter = values[i];\r\n                let updatedFilter: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\r\n                };\r\n\r\n                let filterTarget = filter.target;\r\n                if (filterTarget) {\r\n                    updatedFilter.target = [];\r\n                    for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                        if (filterTarget[j]) {\r\n                            let updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\r\n                            updatedFilter.target.push(updatedTarget);\r\n                        }\r\n                }\r\n\r\n                updatedWhere.push(updatedFilter);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public addWhere(filter: SemanticFilter): SemanticQuery {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedWhere: SQFilter[] = this.where(),\r\n                incomingWhere: SQFilter[] = filter.where(),\r\n                from = this.fromValue.clone();\r\n\r\n            for (let i = 0, len = incomingWhere.length; i < len; i++) {\r\n                let clause = incomingWhere[i];\r\n\r\n                let updatedClause: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\r\n                };\r\n\r\n                if (clause.target)\r\n                    updatedClause.target = _.map(clause.target, t => SQExprRewriterWithSourceRenames.rewrite(t, from));\r\n\r\n                updatedWhere.push(updatedClause);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticQuery {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n            let orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\r\n            let select = rewriter.rewriteSelect(this.selectItems, from);\r\n            let groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\r\n        }\r\n    }\r\n\r\n    /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\r\n    export class SemanticFilter implements ISemanticFilter {\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n        }\r\n\r\n        public static fromSQExpr(contract: SQExpr): SemanticFilter {\r\n            debug.assertValue(contract, 'contract');\r\n\r\n            let from = new SQFrom();\r\n\r\n            let rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\r\n            // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\r\n            //         Thus not setting a target here.\r\n            let where: SQFilter[] = [{\r\n                condition: rewrittenContract\r\n            }];\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static getDefaultValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.defaultValue());\r\n        }\r\n\r\n        public static getAnyValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.anyValue());\r\n        }\r\n\r\n        private static getDataViewScopeIdentityComparisonFilters(fieldSQExprs: SQExpr | SQExpr[], value: SQExpr): SemanticFilter {\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (fieldSQExprs instanceof Array) {\r\n                let values: SQConstantExpr[] = Array.apply(null, Array(fieldSQExprs.length)).map(() => { return value; });\r\n                return SemanticFilter.fromSQExpr(SQExprUtils.getDataViewScopeIdentityComparisonExpr(<SQExpr[]>fieldSQExprs, values));\r\n            }\r\n\r\n            return SemanticFilter.fromSQExpr(SQExprBuilder.equal(<SQExpr>fieldSQExprs, value));\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        public conditions(): SQExpr[] {\r\n            let expressions: SQExpr[] = [];\r\n\r\n            let where = this.whereItems;\r\n            for (let i = 0, len = where.length; i < len; i++) {\r\n                let filter = where[i];\r\n                expressions.push(filter.condition);\r\n            }\r\n            return expressions;\r\n        }\r\n\r\n        public where(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            for (let i = 0, len = whereItems.length; i < len; i++)\r\n                result.push(whereItems[i]);\r\n\r\n            return result;\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticFilter {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.rewrite(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        /** Merges a list of SemanticFilters into one. */\r\n        public static merge(filters: SemanticFilter[]): SemanticFilter {\r\n            if (_.isEmpty(filters))\r\n                return null;\r\n\r\n            if (filters.length === 1)\r\n                return filters[0];\r\n\r\n            let firstFilter = filters[0];\r\n            let from = firstFilter.from(),\r\n                where: SQFilter[] = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\r\n\r\n            for (let i = 1, len = filters.length; i < len; i++)\r\n                SemanticFilter.applyFilter(filters[i], from, where);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static isDefaultFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isDefaultValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isAnyFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isAnyValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isSameFilter(leftFilter: SemanticFilter, rightFilter: SemanticFilter): boolean {\r\n            if (jsCommon.JsonComparer.equals<SemanticFilter>(leftFilter, rightFilter)) {\r\n                return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\r\n                    || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private static applyFilter(filter: SemanticFilter, from: SQFrom, where: SQFilter[]): void {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            // Where\r\n            let filterWhereItems = filter.whereItems;\r\n            for (let i = 0; i < filterWhereItems.length; i++) {\r\n                let filterWhereItem = filterWhereItems[i];\r\n\r\n                let updatedWhereItem: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\r\n                };\r\n\r\n                if (filterWhereItem.target)\r\n                    updatedWhereItem.target = _.map(filterWhereItem.target, e => SQExprRewriterWithSourceRenames.rewrite(e, from));\r\n\r\n                where.push(updatedWhereItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Represents a SemanticQuery/SemanticFilter from clause. */\r\n    export class SQFrom {\r\n        private items: { [name: string]: SQFromEntitySource };\r\n\r\n        constructor(items?: { [name: string]: SQFromEntitySource }) {\r\n            this.items = items || {};\r\n        }\r\n\r\n        public keys(): string[] {\r\n            return Object.keys(this.items);\r\n        }\r\n\r\n        public entity(key: string): SQFromEntitySource {\r\n            return this.items[key];\r\n        }\r\n\r\n        public ensureEntity(entity: SQFromEntitySource, desiredVariableName?: string): QueryFromEnsureEntityResult {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            // 1) Reuse a reference to the entity among the already referenced\r\n            let keys = this.keys();\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let key = keys[i],\r\n                    item = this.items[key];\r\n                if (item && entity.entity === item.entity && entity.schema === item.schema)\r\n                    return { name: key };\r\n            }\r\n\r\n            // 2) Add a reference to the entity\r\n            let candidateName = desiredVariableName || this.candidateName(entity.entity),\r\n                uniqueName: string = candidateName,\r\n                i = 2;\r\n            while (this.items[uniqueName]) {\r\n                uniqueName = candidateName + i++;\r\n            }\r\n\r\n            this.items[uniqueName] = entity;\r\n            return { name: uniqueName, new: true };\r\n        }\r\n\r\n        public remove(key: string): void {\r\n            delete this.items[key];\r\n        }\r\n\r\n        /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\r\n        private candidateName(ref: string): string {\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            let idx = ref.lastIndexOf('.');\r\n            if (idx >= 0 && (idx !== ref.length - 1))\r\n                ref = ref.substr(idx + 1);\r\n\r\n            return ref.substring(0, 1).toLowerCase();\r\n        }\r\n\r\n        public clone(): SQFrom {\r\n            // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\r\n            let cloned = new SQFrom();\r\n\r\n            // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\r\n            $.extend(cloned.items, this.items);\r\n\r\n            return cloned;\r\n        }\r\n    }\r\n\r\n    export class SQExprRewriterWithSourceRenames extends SQExprRewriter {\r\n        private renames: SQSourceRenames;\r\n\r\n        constructor(renames: SQSourceRenames) {\r\n            debug.assertValue(renames, 'renames');\r\n\r\n            super();\r\n            this.renames = renames;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            let updatedName = this.renames[expr.entity];\r\n\r\n            if (updatedName)\r\n                return new SQEntityExpr(expr.schema, expr.entity, updatedName);\r\n\r\n            return super.visitEntity(expr);\r\n        }\r\n\r\n        public rewriteFilter(filter: SQFilter): SQFilter {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedTargets = undefined;\r\n            if (filter.target)\r\n                updatedTargets = this.rewriteArray(filter.target);\r\n\r\n            let updatedCondition = filter.condition.accept(this);\r\n\r\n            if (filter.condition === updatedCondition && filter.target === updatedTargets)\r\n                return filter;\r\n\r\n            let updatedFilter: SQFilter = {\r\n                condition: updatedCondition,\r\n            };\r\n\r\n            if (updatedTargets)\r\n                updatedFilter.target = updatedTargets;\r\n\r\n            return updatedFilter;\r\n        }\r\n\r\n        public rewriteArray(exprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(exprs, 'exprs');\r\n\r\n            let updatedExprs: SQExpr[];\r\n\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i],\r\n                    rewrittenExpr = expr.accept(this);\r\n\r\n                if (expr !== rewrittenExpr && !updatedExprs)\r\n                    updatedExprs = ArrayExtensions.take(exprs, i);\r\n\r\n                if (updatedExprs)\r\n                    updatedExprs.push(rewrittenExpr);\r\n            }\r\n\r\n            return updatedExprs || exprs;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, from: SQFrom): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(from, 'from');\r\n\r\n            let renames = QuerySourceRenameDetector.run(expr, from);\r\n            let rewriter = new SQExprRewriterWithSourceRenames(renames);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    /** Responsible for updating a QueryFrom based on SQExpr references. */\r\n    class QuerySourceRenameDetector extends DefaultSQExprVisitorWithTraversal {\r\n        private from: SQFrom;\r\n        private renames: SQSourceRenames;\r\n\r\n        public static run(expr: SQExpr, from: SQFrom): SQSourceRenames {\r\n            let detector = new QuerySourceRenameDetector(from);\r\n            expr.accept(detector);\r\n\r\n            return detector.renames;\r\n        }\r\n\r\n        constructor(from: SQFrom) {\r\n            debug.assertValue(from, 'from');\r\n            super();\r\n\r\n            this.from = from;\r\n            this.renames = {};\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            // TODO: Renames must take the schema into account, not just entity set name.\r\n            let existingEntity = this.from.entity(expr.variable);\r\n            if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\r\n                return;\r\n\r\n            let actualEntity = this.from.ensureEntity(\r\n                {\r\n                    schema: expr.schema,\r\n                    entity: expr.entity,\r\n                },\r\n                expr.variable);\r\n\r\n            this.renames[expr.entity] = actualEntity.name;\r\n        }\r\n    }\r\n\r\n    /** Visitor for finding unreferenced sources. */\r\n    class UnreferencedKeyFinder extends DefaultSQExprVisitorWithTraversal {\r\n        private keys: string[];\r\n\r\n        constructor(keys: string[]) {\r\n            debug.assertValue(keys, 'keys');\r\n\r\n            super();\r\n            this.keys = keys;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            let index = this.keys.indexOf(expr.variable);\r\n            if (index >= 0)\r\n                this.keys.splice(index, 1);\r\n        }\r\n\r\n        public result(): string[] {\r\n            return this.keys;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataViewTransform = powerbi.data.DataViewTransform;\r\n    import SQExprBuilder = powerbi.data.SQExprBuilder;\r\n\r\n    /** Utility for creating a DataView from columns of data. */\r\n    export interface IDataViewBuilderCategorical {\r\n        withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical;\r\n        withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical;\r\n        withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical;\r\n        withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical;\r\n\r\n        build(): DataView;\r\n    }\r\n\r\n    export interface DataViewBuilderColumnOptions {\r\n        source: DataViewMetadataColumn;\r\n    }\r\n\r\n    export interface DataViewBuilderCategoryColumnOptions extends DataViewBuilderColumnOptions {\r\n        values: PrimitiveValue[];\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n    }\r\n\r\n    export interface DataViewBuilderValuesOptions {\r\n        columns: DataViewBuilderValuesColumnOptions[];\r\n    }\r\n\r\n    export interface DataViewBuilderGroupedValuesOptions {\r\n        groupColumn: DataViewBuilderCategoryColumnOptions;\r\n        valueColumns: DataViewBuilderColumnOptions[];\r\n        data: DataViewBuilderSeriesData[][];\r\n    }\r\n\r\n    /** Indicates the source set of identities. */\r\n    export interface DataViewBuilderColumnIdentitySource {\r\n        fields: SQExpr[];\r\n        identities?: DataViewScopeIdentity[];\r\n    }\r\n\r\n    export interface DataViewBuilderValuesColumnOptions extends DataViewBuilderColumnOptions, DataViewBuilderSeriesData {\r\n    }\r\n\r\n    export interface DataViewBuilderSeriesData {\r\n        values: PrimitiveValue[];\r\n        highlights?: PrimitiveValue[];\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        maxLocal?: any;\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        minLocal?: any;\r\n    }\r\n\r\n    export function createCategoricalDataViewBuilder(): IDataViewBuilderCategorical {\r\n        return new CategoricalDataViewBuilder();\r\n    }\r\n\r\n    interface ColumnMetadata {\r\n        column: DataViewMetadataColumn;\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n        values: PrimitiveValue[];\r\n    }\r\n\r\n    class CategoricalDataViewBuilder implements IDataViewBuilderCategorical {\r\n        private categories: DataViewCategoryColumn[];\r\n        private staticMeasureColumns: DataViewMetadataColumn[];\r\n        private dynamicMeasureColumns: DataViewMetadataColumn[];\r\n        private dynamicSeriesMetadata: ColumnMetadata;\r\n        private columnIndex: number;\r\n        private staticSeriesValues: DataViewBuilderValuesColumnOptions[];\r\n        private dynamicSeriesValues: DataViewBuilderSeriesData[][];\r\n\r\n        constructor() {\r\n            this.categories = [];\r\n            this.staticMeasureColumns = [];\r\n            this.dynamicMeasureColumns = [];\r\n            this.columnIndex = 0;\r\n        }\r\n\r\n        public withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical {\r\n            let categoryValues = options.values,\r\n                identityFrom = options.identityFrom,\r\n                type = options.source.type;\r\n\r\n            let categoryColumn: DataViewCategoryColumn = {\r\n                source: options.source,\r\n                identityFields: options.identityFrom.fields,\r\n                identity: options.identityFrom.identities || [],\r\n                values: categoryValues,\r\n            };\r\n\r\n            if (!options.identityFrom.identities) {\r\n                for (let categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\r\n                    categoryColumn.identity.push(\r\n                        getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\r\n                }\r\n            }\r\n\r\n            if (!this.categories)\r\n                this.categories = [];\r\n\r\n            this.categories.push(categoryColumn);\r\n\r\n            return this;\r\n        }\r\n\r\n        public withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical {\r\n            if (_.isEmpty(this.categories))\r\n                this.categories = categories;\r\n            else\r\n                Array.prototype.push.apply(this.categories, categories);\r\n\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Adds static series columns.\r\n         *\r\n         * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in \r\n         * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\r\n         */\r\n        public withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let columns = options.columns;\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            for (let column of columns) {\r\n                this.staticMeasureColumns.push(column.source);\r\n            }\r\n\r\n            this.staticSeriesValues = columns;\r\n\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Adds dynamic series columns.\r\n         *\r\n         * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in \r\n         * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\r\n         */\r\n        public withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let groupColumn = options.groupColumn;\r\n            debug.assertValue(groupColumn, 'groupColumn');\r\n\r\n            this.dynamicSeriesMetadata = {\r\n                column: groupColumn.source,\r\n                identityFrom: groupColumn.identityFrom,\r\n                values: groupColumn.values,\r\n            };\r\n\r\n            let valueColumns = options.valueColumns;\r\n            for (let valueColumn of valueColumns) {\r\n                this.dynamicMeasureColumns.push(valueColumn.source);\r\n            }\r\n\r\n            this.dynamicSeriesValues = options.data;\r\n\r\n            return this;\r\n        }\r\n\r\n        private fillData(dataViewValues: DataViewValueColumns) {\r\n            let categoryColumn = _.first(this.categories);\r\n            let categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 1;\r\n\r\n            if (this.hasDynamicSeries) {\r\n                for (let seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\r\n                    let seriesMeasures = this.dynamicSeriesValues[seriesIndex];\r\n                    debug.assert(seriesMeasures.length === this.dynamicMeasureColumns.length, 'seriesMeasures.length === this.dynamicMeasureColumns.length');\r\n\r\n                    for (let measureIndex = 0, measuresLen = this.dynamicMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                        let groupIndex = seriesIndex * measuresLen + measureIndex;\r\n\r\n                        applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.hasStaticSeries) {\r\n                // Note: when the target categorical has both dynamic and static series, append static measures at the end of the values array.\r\n                let staticColumnsStartingIndex = this.hasDynamicSeries ? (this.dynamicSeriesValues.length * this.dynamicMeasureColumns.length) : 0;\r\n\r\n                for (let measureIndex = 0, measuresLen = this.staticMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                    applySeriesData(dataViewValues[staticColumnsStartingIndex + measureIndex], this.staticSeriesValues[measureIndex], categoryLength);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the DataView with metadata and DataViewCategorical.\r\n         * Returns undefined if the combination of parameters is illegal, such as having both dynamic series and static series when building a visual DataView.\r\n         */\r\n        public build(): DataView {\r\n            let metadataColumns: DataViewMetadataColumn[] = [];\r\n            let categorical: DataViewCategorical = {};\r\n\r\n            let categoryMetadata = this.categories;\r\n            let dynamicSeriesMetadata = this.dynamicSeriesMetadata;\r\n\r\n            // --- Build metadata columns and value groups ---\r\n            for (let columnMetadata of categoryMetadata) {\r\n                pushIfNotExists(metadataColumns, columnMetadata.source);\r\n            }\r\n\r\n            if (this.hasDynamicSeries) {\r\n                // Dynamic series, or Dyanmic & Static series.\r\n                pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\r\n\r\n                categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\r\n\r\n                // For each series value we will make one column per measure\r\n                let seriesValues = dynamicSeriesMetadata.values;\r\n                for (let seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\r\n                    let seriesValue = seriesValues[seriesIndex];\r\n                    let seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\r\n\r\n                    for (let measure of this.dynamicMeasureColumns) {\r\n                        let column = _.clone(measure);\r\n                        column.groupName = <string>seriesValue;\r\n\r\n                        pushIfNotExists(metadataColumns, column);\r\n                        categorical.values.push({\r\n                            source: column,\r\n                            values: [],\r\n                            identity: seriesIdentity,\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (this.hasStaticSeries) {\r\n                    // IMPORTANT: In the Dyanmic & Static series case, the groups array shall not include any static group. This is to match the behavior of dsrReader.\r\n                    // Get the current return value of grouped() before adding static measure columns, an use that as the return value of this categorical.\r\n                    // Otherwise, the default behavior of DataViewValueColumns.grouped() from DataViewTransform.createValueColumns() is to create series groups from all measure columns.\r\n                    let dynamicSeriesGroups = categorical.values.grouped();\r\n                    categorical.values.grouped = () => dynamicSeriesGroups;\r\n\r\n                    this.appendStaticMeasureColumns(metadataColumns, categorical.values);\r\n                }\r\n            }\r\n            else {\r\n                // Static series only / no series\r\n                categorical.values = DataViewTransform.createValueColumns();\r\n                this.appendStaticMeasureColumns(metadataColumns, categorical.values);\r\n            }\r\n\r\n            let categories = this.categories;\r\n            if (!_.isEmpty(categories))\r\n                categorical.categories = categories;\r\n\r\n            // --- Fill in data point values ---\r\n            this.fillData(categorical.values);\r\n\r\n            let dataView: DataView = {\r\n                metadata: {\r\n                    columns: metadataColumns,\r\n                },\r\n                categorical: categorical,\r\n            };\r\n\r\n            if (this.isLegalDataView(dataView)) {\r\n                return dataView;\r\n            }\r\n        }\r\n\r\n        private appendStaticMeasureColumns(metadataColumns: DataViewMetadataColumn[], valueColumns: DataViewValueColumns): void {\r\n            debug.assertValue(metadataColumns, 'metadataColumns');\r\n            debug.assertValue(valueColumns, 'valueColumns');\r\n\r\n            if (!_.isEmpty(this.staticMeasureColumns)) {\r\n                for (let column of this.staticMeasureColumns) {\r\n                    pushIfNotExists(metadataColumns, column);\r\n                    valueColumns.push({\r\n                        source: column,\r\n                        values: [],\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        private isLegalDataView(dataView: DataView): boolean {\r\n            if (this.hasDynamicSeries && this.hasStaticSeries && CategoricalDataViewBuilder.isVisualDataView(dataView.metadata.columns)) {\r\n                // It is illegal to have both dynamic series and static series in a visual DataViewCategorical,\r\n                // because the DataViewValueColumns interface today cannot express that 100% (see its 'source' property and return value of its 'grouped()' function).\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * This function infers that if any metdata column has 'queryName', \r\n         * then the user of this builder is building a visual DataView (as opposed to query DataView).\r\n         *\r\n         * @param metadataColumns The complete collection of metadata columns in the categorical.\r\n         */\r\n        private static isVisualDataView(metadataColumns: DataViewMetadataColumn[]): boolean {\r\n            return !_.isEmpty(metadataColumns) &&\r\n                _.any(metadataColumns, (metadataColumn) => !!metadataColumn.queryName);\r\n        }\r\n\r\n        private get hasDynamicSeries(): boolean {\r\n            return !!this.dynamicSeriesMetadata; // In Map visual scenarios, you can have dynamic series without measure columns\r\n        }\r\n\r\n        private get hasStaticSeries(): boolean {\r\n            return !!this.staticSeriesValues;\r\n        }\r\n    }\r\n\r\n    function getScopeIdentity(\r\n        source: DataViewBuilderColumnIdentitySource,\r\n        index: number,\r\n        value: PrimitiveValue,\r\n        valueType: ValueTypeDescriptor): DataViewScopeIdentity {\r\n        let identities = source.identities;\r\n        if (identities) {\r\n            return identities[index];\r\n        }\r\n\r\n        debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\r\n\r\n        return createDataViewScopeIdentity(\r\n            SQExprBuilder.equal(\r\n                source.fields[0],\r\n                SQExprBuilder.typedConstant(value, valueType)));\r\n    }\r\n\r\n    function pushIfNotExists(items: DataViewMetadataColumn[], itemToAdd: DataViewMetadataColumn): void {\r\n        if (_.contains(items, itemToAdd))\r\n            return;\r\n\r\n        items.push(itemToAdd);\r\n    }\r\n\r\n    function applySeriesData(target: DataViewValueColumn, source: DataViewBuilderSeriesData, categoryLength: number): void {\r\n        debug.assertValue(target, 'target');\r\n        debug.assertValue(source, 'source');\r\n        debug.assertValue(categoryLength, 'categoryLength');\r\n\r\n        let values = source.values;\r\n        debug.assert(categoryLength === values.length, 'categoryLength === values.length');\r\n\r\n        target.values = values;\r\n\r\n        let highlights = source.highlights;\r\n        if (highlights) {\r\n            debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\r\n\r\n            target.highlights = highlights;\r\n        }\r\n\r\n        let aggregates: DataViewColumnAggregates;\r\n        if (source.minLocal !== undefined) {\r\n            if (!aggregates)\r\n                aggregates = {};\r\n\r\n            aggregates.minLocal = source.minLocal;\r\n        }\r\n\r\n        if (source.maxLocal !== undefined) {\r\n            if (!aggregates)\r\n                aggregates = {};\r\n\r\n            aggregates.maxLocal = source.maxLocal;\r\n        }\r\n\r\n        if (aggregates) {\r\n            target.source.aggregates = aggregates;\r\n            _.extend(target, aggregates);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export function createStaticEvalContext(colorAllocatorCache?: IColorAllocatorCache): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView?: DataView, selectTransforms?: DataViewSelectTransform[]): IEvalContext {\r\n        return new StaticEvalContext(\r\n            colorAllocatorCache || createColorAllocatorCache(),\r\n            dataView || { metadata: { columns: [] } },\r\n            selectTransforms);\r\n    }\r\n\r\n    /**\r\n     * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\r\n     * are supported.\r\n     */\r\n    class StaticEvalContext implements IEvalContext {\r\n        private colorAllocatorCache: IColorAllocatorCache;\r\n        private dataView: DataView;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorCache = colorAllocatorCache;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorCache.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            let dataView = this.dataView,\r\n                selectTransforms = this.selectTransforms;\r\n            if (dataView && dataView.table && selectTransforms)\r\n                return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n    }\r\n\r\n    export function getExprValueFromTable(expr: SQExpr, selectTransforms: DataViewSelectTransform[], table: DataViewTable, rowIdx: number): PrimitiveValue {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n        debug.assertValue(table, 'table');\r\n        debug.assertValue(rowIdx, 'rowIdx');\r\n\r\n        let rows = table.rows;\r\n        if (_.isEmpty(rows) || rows.length <= rowIdx)\r\n            return;\r\n\r\n        let targetExpr = getTargetExpr(expr, selectTransforms);\r\n        let cols = table.columns;\r\n        for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n            let selectTransform = selectTransforms[selectIdx];\r\n\r\n            if (!SQExpr.equals(selectTransform.expr, targetExpr) || !selectTransform.queryName)\r\n                continue;\r\n\r\n            for (let colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\r\n                if (selectIdx !== cols[colIdx].index)\r\n                    continue;\r\n\r\n                return rows[rowIdx][colIdx];\r\n            }\r\n        }\r\n    }\r\n\r\n    function getTargetExpr(expr: SQExpr, selectTransforms: DataViewSelectTransform[]): SQExpr {\r\n        if (SQExpr.isSelectRef(expr)) {\r\n            for (let selectTransform of selectTransforms) {\r\n                if (selectTransform.queryName === expr.expressionName) {\r\n                    return selectTransform.expr;\r\n                }\r\n            }\r\n        }\r\n\r\n        return expr;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export function createMatrixEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewMatrix: DataViewMatrix): IEvalContext {\r\n        // NOTE: Matrix context-sensitive evaluation is not yet implemented.\r\n        return createStaticEvalContext(colorAllocatorProvider);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import Formatting = jsCommon.Formatting;\r\n    import RegExpExtensions = jsCommon.RegExpExtensions;\r\n\r\n    /** Culture interfaces. These match the Globalize library interfaces intentionally. */\r\n    export interface Culture {\r\n        name: string;\r\n        calendar: Calendar;\r\n        calendars: CalendarDictionary;\r\n        numberFormat: NumberFormatInfo;\r\n    }\r\n\r\n    export interface Calendar {\r\n        patterns: any;\r\n        firstDay: number;\r\n    }\r\n\r\n    export interface CalendarDictionary {\r\n        [key: string]: Calendar;\r\n    }\r\n\r\n    export interface NumberFormatInfo {\r\n        decimals: number;\r\n        groupSizes: number[];\r\n        negativeInfinity: string;\r\n        positiveInfinity: string;\r\n    }\r\n\r\n    /**\r\n     *  Creating a dummy module to declare cultureInfo string, so we could do a strongly typed usage in Visuals\r\n     */\r\n    declare module powerbi.common {\r\n        let cultureInfo: string;\r\n    }\r\n\r\n    /** Formatting Encoder */\r\n    module FormattingEncoder {\r\n        export function preserveEscaped(format: string, specialChars: string): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = \"\\\\\" + specialChars[i];\r\n                let newText = String.fromCharCode(0xE000 + i);\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreEscaped(format: string, specialChars: string): string {\r\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = String.fromCharCode(0xE000 + i);\r\n                let newText = specialChars[i];\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\r\n        }\r\n\r\n        export function preserveLiterals(format: string, literals: string[]): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            for (let i = 0; ; i++) {\r\n                let fromIndex = format.indexOf(\"'\");\r\n                if (fromIndex < 0) {\r\n                    break;\r\n                }\r\n                let toIndex = format.indexOf(\"'\", fromIndex + 1);\r\n                if (toIndex < 0) {\r\n                    break;\r\n                }\r\n                let literal = format.substring(fromIndex, toIndex + 1);\r\n                literals.push(literal.substring(1, toIndex - fromIndex));\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                format = format.replace(literal, token);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreLiterals(format: string, literals: string[]): string {\r\n            let count = literals.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                let literal = literals[i];\r\n                format = format.replace(token, literal);\r\n            }\r\n            return format;\r\n        }\r\n    }\r\n\r\n    const IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\r\n    const ZeroPlaceholder = '0';\r\n    const DigitPlaceholder = '#';\r\n    const ExponentialFormatChar = 'E';\r\n    const NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\r\n    const NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\r\n\r\n    /** Formatting Service */\r\n    class FormattingService implements IFormattingService {\r\n\r\n        _currentCultureSelector: string;\r\n        _currentCulture: Culture;\r\n        _dateTimeScaleFormatInfo: DateTimeScaleFormatInfo;\r\n\r\n        public formatValue(value: any, format?: string, culture?: string): string {\r\n            // Handle special cases\r\n            if (value === undefined || value === null) {\r\n                return '';\r\n            }\r\n            let gculture = this.getCulture(culture);\r\n\r\n            if (DateTimeFormat.canFormat(value)) {\r\n                // Dates\r\n                return DateTimeFormat.format(value, format, gculture);\r\n            } else if (NumberFormat.canFormat(value)) {\r\n                // Numbers\r\n                return NumberFormat.format(value, format, gculture);\r\n            } else {\r\n                // Other data types - return as string\r\n                return value.toString();\r\n            }\r\n        }\r\n\r\n        public format(formatWithIndexedTokens: string, args: any[], culture?: string): string {\r\n            if (!formatWithIndexedTokens) {\r\n                return \"\";\r\n            }\r\n            let result = formatWithIndexedTokens.replace(IndexedTokensRegex, (match: string, left: string, right: string, argToken: string) => {\r\n                if (left) {\r\n                    return \"{\";\r\n                } else if (right) {\r\n                    return \"}\";\r\n                } else {\r\n                    let parts = argToken.split(\":\");\r\n                    let argIndex = parseInt(parts[0], 10);\r\n                    let argFormat = parts[1];\r\n                    return this.formatValue(args[argIndex], argFormat, culture);\r\n                }\r\n            });\r\n\r\n            return result;\r\n        }\r\n\r\n        public isStandardNumberFormat(format: string): boolean {\r\n            return NumberFormat.isStandardFormat(format);\r\n        }\r\n\r\n        public formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string, culture?: string): string {\r\n            let gculture = this.getCulture(culture);\r\n\r\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\r\n        }\r\n\r\n        public dateFormatString(unit: DateTimeUnit): string {\r\n            if (!this._dateTimeScaleFormatInfo)\r\n                this.initialize();\r\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\r\n        }\r\n\r\n        /**\r\n         * Sets the current localization culture\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         */\r\n        private setCurrentCulture(cultureSelector: string): void {\r\n            if (this._currentCultureSelector !== cultureSelector) {\r\n                this._currentCulture = this.getCulture(cultureSelector);\r\n                this._currentCultureSelector = cultureSelector;\r\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         * Exposing this function for testability of unsupported cultures\r\n         */\r\n        public getCulture(cultureSelector?: string): Culture {\r\n            if (cultureSelector == null) {\r\n                if (this._currentCulture == null) {\r\n                    this.initialize();\r\n                }\r\n                return this._currentCulture;\r\n            } else {\r\n                let culture = Globalize.findClosestCulture(cultureSelector);\r\n                if (!culture)\r\n                    culture = Globalize.culture(\"en-US\");\r\n                return culture;\r\n            }\r\n        }\r\n\r\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\r\n        private initialize() {\r\n            let cultureName = this.getCurrentCulture();\r\n            this.setCurrentCulture(cultureName);\r\n            let calendarName = this.getUrlParam(\"calendar\");\r\n            if (calendarName) {\r\n                let culture = this._currentCulture;\r\n                let c = culture.calendars[calendarName];\r\n                if (c) {\r\n                    culture.calendar = c;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability \r\n         */\r\n        public getCurrentCulture(): string {\r\n            let urlParam = this.getUrlParam(\"language\");\r\n\r\n            if (urlParam) {\r\n                return urlParam;\r\n            }\r\n\r\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\r\n                // Get cultureInfo set in powerbi\r\n                return powerbi.common.cultureInfo;\r\n            }\r\n\r\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability\r\n         *  @param name: queryString name\r\n         */\r\n        public getUrlParam(name: string): string {\r\n            let param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\r\n            return param ? param[1] : undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for dates.\r\n     */\r\n    module DateTimeFormat {\r\n\r\n        let _currentCachedFormat: string;\r\n        let _currentCachedProcessedFormat: string;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = value instanceof Date;\r\n            return result;\r\n        }\r\n\r\n        /** Formats the date using provided format and culture */\r\n        export function format(value: Date, format: string, culture: Culture): string {\r\n            format = format || \"G\";\r\n            let isStandard = format.length === 1;\r\n            try {\r\n                if (isStandard) {\r\n                    return formatDateStandard(value, format, culture);\r\n                } else {\r\n                    return formatDateCustom(value, format, culture);\r\n                }\r\n            } catch (e) {\r\n                return formatDateStandard(value, \"G\", culture);\r\n            }\r\n        }\r\n\r\n        /** Formats the date using standard format expression */\r\n        function formatDateStandard(value: Date, format: string, culture: Culture) {\r\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\r\n            let patterns = culture.calendar.patterns;\r\n            // Extend supported set of patterns\r\n            ensurePatterns(culture.calendar);\r\n            // Handle extended set of formats\r\n            let output = Formatting.findDateFormat(value, format, culture.name);\r\n            if (output.format.length === 1)\r\n                format = patterns[output.format];\r\n            else\r\n                format = output.format;\r\n            //need to revisit when globalization is enabled\r\n            culture = Globalize.culture(\"en-US\");\r\n            return Globalize.format(output.value, format, culture);\r\n        }\r\n\r\n        /** Formats the date using custom format expression */\r\n        function formatDateCustom(value: Date, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let literals: string[] = [];\r\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            format = FormattingEncoder.preserveLiterals(format, literals);\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            if (format.indexOf(\"F\") > -1) {\r\n                // F is not supported so we need to replace the F with f based on the milliseconds\r\n                // Replace all sequences of F longer than 3 with \"FFF\"\r\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\r\n                // Based on milliseconds update the format to use fff\r\n                let milliseconds = value.getMilliseconds();\r\n                if (milliseconds % 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\r\n                if ((milliseconds % 100) / 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\r\n                if ((milliseconds % 1000) / 100 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\r\n                if (format === \"\" || format === \"%\")\r\n                    return \"\";\r\n            }\r\n            format = processCustomDateTimeFormat(format);\r\n            result = Globalize.format(value, format, culture);\r\n            result = localize(result, culture.calendar);\r\n            result = FormattingEncoder.restoreLiterals(result, literals);\r\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            return result;\r\n        }\r\n\r\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\r\n        function processCustomDateTimeFormat(format: string): string {\r\n            if (format === _currentCachedFormat) {\r\n                return _currentCachedProcessedFormat;\r\n            }\r\n            _currentCachedFormat = format;\r\n            format = Formatting.fixDateTimeFormat(format);\r\n            _currentCachedProcessedFormat = format;\r\n            return format;\r\n        }\r\n\r\n        /** Localizes the time separator symbol */\r\n        function localize(value: string, dictionary: any): string {\r\n            let timeSeparator = dictionary[\":\"];\r\n            if (timeSeparator === \":\") {\r\n                return value;\r\n            }\r\n            let result = \"\";\r\n            let count = value.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \":\":\r\n                        result += timeSeparator;\r\n                        break;\r\n                    default:\r\n                        result += char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function ensurePatterns(calendar: GlobalizeCalendar) {\r\n            let patterns = calendar.patterns;\r\n            if (patterns[\"g\"] === undefined) {\r\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, short time\r\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, long time\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * NumberFormat module contains the static methods for formatting the numbers.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for numeric types including custom formats.\r\n     */\r\n    export module NumberFormat {\r\n\r\n        const NonScientificFormatRegex = /^\\{.+\\}.*/;\r\n        const NumericalPlaceHolderRegex = /\\{.+\\}/;\r\n        const ScientificFormatRegex = /e[+-]*[0#]+/i;\r\n        const StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\r\n        const TrailingZerosRegex = /0+$/;\r\n        const DecimalFormatRegex = /\\.([0#]*)/g;\r\n        const NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\r\n        const LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\r\n        const DecimalFormatCharacter = '.';\r\n\r\n        export const NumberFormatComponentsDelimeter = ';';\r\n\r\n        export interface NumericFormatMetadata {\r\n            format: string;\r\n            hasEscapes: boolean;\r\n            hasQuotes: boolean;\r\n            hasE: boolean;\r\n            hasCommas: boolean;\r\n            hasDots: boolean;\r\n            hasPercent: boolean;\r\n            hasPermile: boolean;\r\n            precision: number;\r\n            scale: number;\r\n        }\r\n\r\n        export interface NumberFormatComponents {\r\n            hasNegative: boolean;\r\n            positive: string;\r\n            negative: string;\r\n            zero: string;\r\n        }\r\n\r\n        function getNonScientificFormatWithPrecision(baseFormat: string, numericFormat: string): string {\r\n            if (!numericFormat || baseFormat === undefined)\r\n                return baseFormat;\r\n\r\n            let newFormat = \"{0:\" + numericFormat + \"}\";\r\n\r\n            return baseFormat.replace(\"{0}\", newFormat);\r\n        }\r\n\r\n        export function getNumericFormat(value: number, baseFormat: string): string {\r\n            if (baseFormat == null)\r\n                return baseFormat;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n\r\n                if (value > 0)\r\n                    return getNumericFormatFromComponent(value, positive);\r\n                else if (value === 0)\r\n                    return getNumericFormatFromComponent(value, zero);\r\n\r\n                return getNumericFormatFromComponent(value, negative);\r\n            }\r\n\r\n            return getNumericFormatFromComponent(value, baseFormat);\r\n        }\r\n\r\n        function getNumericFormatFromComponent(value: number, format: string): string {\r\n            let match = RegExpExtensions.run(NumericFormatRegex, format);\r\n            if (match)\r\n                return match[0];\r\n\r\n            return format;\r\n        }\r\n\r\n        export function addDecimalsToFormat(baseFormat: string, decimals: number, trailingZeros: boolean): string {\r\n            if (decimals == null)\r\n                return baseFormat;\r\n\r\n            // Default format string\r\n            if (baseFormat == null)\r\n                baseFormat = ZeroPlaceholder;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n                let formats = [positive, negative, zero];\r\n                for (let i = 0; i < formats.length; i++) {\r\n                    // Update format in formats array\r\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\r\n                }\r\n\r\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\r\n            }\r\n\r\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\r\n        }\r\n\r\n        function addDecimalsToFormatComponent(format: string, decimals: number, trailingZeros: boolean): string {\r\n            decimals = Math.abs(decimals);\r\n\r\n            if (decimals >= 0) {\r\n                let placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\r\n                let decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\r\n\r\n                let match = RegExpExtensions.run(DecimalFormatRegex, format);\r\n                if (match) {\r\n                    let beforeDecimal = format.substr(0, match.index);\r\n                    let formatDecimal = format.substr(match.index + 1, match[1].length);\r\n                    let afterDecimal = format.substr(match.index + match[0].length);\r\n\r\n                    if (trailingZeros)\r\n                        // Use explicit decimals argument as placeholders\r\n                        formatDecimal = decimalPlaceholders;\r\n                    else {\r\n                        let decimalChange = decimalPlaceholders.length - formatDecimal.length;\r\n                        if (decimalChange > 0)\r\n                            // Append decimalPlaceholders to existing decimal portion of format string\r\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\r\n                        else if (decimalChange < 0)\r\n                            // Remove decimals from formatDecimal\r\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\r\n                    }\r\n\r\n                    if (formatDecimal.length > 0)\r\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\r\n\r\n                    return beforeDecimal + formatDecimal + afterDecimal;\r\n                }\r\n                else if (decimalPlaceholders.length > 0)\r\n                    // Replace last numeric placeholder with decimal portion\r\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\r\n            }\r\n\r\n            return format;\r\n        }\r\n\r\n        export function hasFormatComponents(format: string): boolean {\r\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\r\n        }\r\n\r\n        export function getComponents(format: string): NumberFormatComponents {\r\n            let signFormat: NumberFormatComponents = {\r\n                hasNegative: false,\r\n                positive: format,\r\n                negative: format,\r\n                zero: format,\r\n            };\r\n\r\n            let signSpecificFormats = format.split(NumberFormatComponentsDelimeter);\r\n            let formatCount = signSpecificFormats.length;\r\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\r\n\r\n            if (formatCount > 1) {\r\n                signFormat.hasNegative = true;\r\n\r\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\r\n                signFormat.negative = signSpecificFormats[1];\r\n\r\n                if (formatCount > 2)\r\n                    signFormat.zero = signSpecificFormats[2];\r\n            }\r\n\r\n            return signFormat;\r\n        }\r\n\r\n        let _lastCustomFormatMeta: NumericFormatMetadata;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = typeof (value) === \"number\";\r\n            return result;\r\n        }\r\n\r\n        export function isStandardFormat(format: string): boolean {\r\n            debug.assertValue(format, 'format');\r\n            return StandardFormatRegex.test(format);\r\n        }\r\n\r\n        /** Formats the number using specified format expression and culture */\r\n        export function format(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture): string {\r\n            format = format || \"G\";\r\n            try {\r\n                if (isStandardFormat(format))\r\n                    return formatNumberStandard(value, format, culture);\r\n\r\n                return formatNumberCustom(value, format, culture);\r\n            } catch (e) {\r\n                return Globalize.format(value, undefined, culture);\r\n            }\r\n        }\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        export function formatWithCustomOverride(\r\n            value: number,\r\n            format: string,\r\n            nonScientificOverrideFormat: string,\r\n            culture: Culture): string {\r\n            debug.assertValue(value, 'value');\r\n            debug.assertValue(format, 'format');\r\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\r\n            debug.assertValue(culture, 'culture');\r\n            debug.assert(!isStandardFormat(format), 'Standard format');\r\n\r\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\r\n        }\r\n\r\n        /** Formats the number using standard format expression */\r\n        function formatNumberStandard(value: number, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let precision = <number>(format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\r\n            let numberFormatInfo = culture.numberFormat;\r\n            let formatChar = format.charAt(0);\r\n            switch (formatChar) {\r\n                case \"e\":\r\n                case \"E\":\r\n                    if (precision === undefined) {\r\n                        precision = 6;\r\n                    }\r\n                    let mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\r\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\r\n                    result = formatNumberCustom(value, format, culture);\r\n                    break;\r\n                case \"f\":\r\n                case \"F\":\r\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    let abs = Math.abs(value);\r\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\r\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\r\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\r\n                    } else {\r\n                        // Otherwise use exponential\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\r\n                        result = result.replace(\"e\", \"E\");\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"r\":\r\n                case \"R\":\r\n                    result = value.toString();\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"x\":\r\n                case \"X\":\r\n                    result = value.toString(16);\r\n                    if (formatChar === \"X\") {\r\n                        result = result.toUpperCase();\r\n                    }\r\n                    if (precision !== undefined) {\r\n                        let actualPrecision = result.length;\r\n                        let isNegative = value < 0;\r\n                        if (isNegative) {\r\n                            actualPrecision--;\r\n                        }\r\n                        let paddingZerosCount = precision - actualPrecision;\r\n                        let paddingZeros = undefined;\r\n                        if (paddingZerosCount > 0) {\r\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\r\n                        }\r\n                        if (isNegative) {\r\n                            result = \"-\" + paddingZeros + result.substr(1);\r\n                        } else {\r\n                            result = paddingZeros + result;\r\n                        }\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                default:\r\n                    result = Globalize.format(value, format, culture);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Formats the number using custom format expression */\r\n        function formatNumberCustom(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture,\r\n            nonScientificOverrideFormat?: string): string {\r\n            let result: string;\r\n            let numberFormatInfo = culture.numberFormat;\r\n            if (isFinite(value)) {\r\n                // Split format by positive[;negative;zero] pattern\r\n                let formatComponents = getComponents(format);\r\n\r\n                // Pick a format based on the sign of value\r\n                if (value > 0) {\r\n                    format = formatComponents.positive;\r\n                } else if (value === 0) {\r\n                    format = formatComponents.zero;\r\n                } else {\r\n                    format = formatComponents.negative;\r\n                }\r\n\r\n                // Normalize value if we have an explicit negative format\r\n                if (formatComponents.hasNegative)\r\n                    value = Math.abs(value);\r\n\r\n                // Get format metadata\r\n                let formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\r\n\r\n                // Preserve literals and escaped chars\r\n                if (formatMeta.hasEscapes) {\r\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%\");\r\n                }\r\n                let literals: string[] = [];\r\n                if (formatMeta.hasQuotes) {\r\n                    format = FormattingEncoder.preserveLiterals(format, literals);\r\n                }\r\n\r\n                // Scientific format\r\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\r\n                    let scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\r\n                    if (scientificMatch) {\r\n                        // Case 2.1. Scientific custom format\r\n                        let formatM = format.substr(0, scientificMatch.index);\r\n                        let formatE = format.substr(scientificMatch.index + 2); // E(+|-)\r\n                        let precision = getCustomFormatPrecision(formatM, formatMeta);\r\n                        let scale = getCustomFormatScale(formatM, formatMeta);\r\n                        if (scale !== 1) {\r\n                            value = value * scale;\r\n                        }\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        let s = value.toExponential(precision);\r\n                        let indexOfE = s.indexOf(\"e\");\r\n                        let mantissa = s.substr(0, indexOfE);\r\n                        let exp = s.substr(indexOfE + 1);\r\n                        let resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\r\n                        let resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\r\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\r\n                            resultE = resultE.substr(1);\r\n                        }\r\n                        let e = scientificMatch[0].charAt(0);\r\n                        result = resultM + e + resultE;\r\n                    }\r\n                }\r\n\r\n                // Non scientific format\r\n                if (result === undefined) {\r\n                    let valueFormatted: string;\r\n                    let isValueGlobalized: boolean = false;\r\n                    let precision = getCustomFormatPrecision(format, formatMeta);\r\n                    let scale = getCustomFormatScale(format, formatMeta);\r\n\r\n                    if (scale !== 1)\r\n                        value = value * scale;\r\n\r\n                    // Rounding\r\n                    value = parseFloat(toNonScientific(value, precision));\r\n\r\n                    if (nonScientificOverrideFormat) {\r\n                        // Get numeric format from format string\r\n                        let numericFormat = NumberFormat.getNumericFormat(value, format);\r\n\r\n                        // Add separators and decimalFormat to nonScientificFormat\r\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\r\n\r\n                        // Format the value\r\n                        valueFormatted = formattingService.format(nonScientificOverrideFormat, [value], culture.name);\r\n                        isValueGlobalized = true;\r\n                    }\r\n                    else\r\n                        valueFormatted = toNonScientific(value, precision);\r\n\r\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\r\n                }\r\n                if (formatMeta.hasQuotes) {\r\n                    result = FormattingEncoder.restoreLiterals(result, literals);\r\n                }\r\n                if (formatMeta.hasEscapes) {\r\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%\");\r\n                }\r\n\r\n                _lastCustomFormatMeta = formatMeta;\r\n            } else {\r\n                return Globalize.format(value, undefined);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Returns string with the fixed point respresentation of the number */\r\n        function toNonScientific(value: number, precision: number): string {\r\n            let result = \"\";\r\n            let precisionZeros = 0;\r\n            // Double precision numbers support actual 15-16 decimal digits of precision.\r\n            if (precision > 16) {\r\n                precisionZeros = precision - 16;\r\n                precision = 16;\r\n            }\r\n            let digitsBeforeDecimalPoint = Double.log10(Math.abs(value));\r\n            if (digitsBeforeDecimalPoint < 16) {\r\n                if (digitsBeforeDecimalPoint > 0) {\r\n                    let maxPrecision = 16 - digitsBeforeDecimalPoint;\r\n                    if (precision > maxPrecision) {\r\n                        precisionZeros += precision - maxPrecision;\r\n                        precision = maxPrecision;\r\n                    }\r\n                }\r\n                result = value.toFixed(precision);\r\n            } else if (digitsBeforeDecimalPoint === 16) {\r\n                result = value.toFixed(0);\r\n                precisionZeros += precision;\r\n                if (precisionZeros > 0) {\r\n                    result += \".\";\r\n                }\r\n            } else { // digitsBeforeDecimalPoint > 16\r\n                // Different browsers have different implementations of the toFixed().\r\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\r\n                // So we need to check for range and convert the to exponential with the max precision.\r\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\r\n                // Assert that value is a number and fall back on returning value if it is not\r\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                if (typeof (value) !== \"number\")\r\n                    return String(value);\r\n                result = value.toExponential(15);\r\n                let indexOfE = result.indexOf(\"e\");\r\n                if (indexOfE > 0) {\r\n                    let indexOfDot = result.indexOf(\".\");\r\n                    let mantissa = result.substr(0, indexOfE);\r\n                    let exp = result.substr(indexOfE + 1);\r\n                    let powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\r\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\r\n                    if (precision > 0) {\r\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\r\n                    }\r\n                }\r\n            }\r\n            if (precisionZeros > 0) {\r\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the formatMetadata of the format\r\n         * When calculating precision and scale, if format string of\r\n         * positive[;negative;zero] => positive format will be used\r\n         * @param (required) format - format string\r\n         * @param (optional) calculatePrecision - calculate precision of positive format\r\n         * @param (optional) calculateScale - calculate scale of positive format\r\n         */\r\n        export function getCustomFormatMetadata(format: string, calculatePrecision?: boolean, calculateScale?: boolean): NumericFormatMetadata {\r\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\r\n                return _lastCustomFormatMeta;\r\n            }\r\n\r\n            let result = {\r\n                format: format,\r\n                hasEscapes: false,\r\n                hasQuotes: false,\r\n                hasE: false,\r\n                hasCommas: false,\r\n                hasDots: false,\r\n                hasPercent: false,\r\n                hasPermile: false,\r\n                precision: undefined,\r\n                scale: undefined,\r\n            };\r\n\r\n            for (let i = 0, length = format.length; i < length; i++) {\r\n                let c = format.charAt(i);\r\n                switch (c) {\r\n                    case \"\\\\\":\r\n                        result.hasEscapes = true;\r\n                        break;\r\n                    case \"'\":\r\n                    case \"\\\"\":\r\n                        result.hasQuotes = true;\r\n                        break;\r\n                    case \"e\":\r\n                    case \"E\":\r\n                        result.hasE = true;\r\n                        break;\r\n                    case \",\":\r\n                        result.hasCommas = true;\r\n                        break;\r\n                    case \".\":\r\n                        result.hasDots = true;\r\n                        break;\r\n                    case \"%\":\r\n                        result.hasPercent = true;\r\n                        break;\r\n                    case \"\":\r\n                        result.hasPermile = true;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Use positive format for calculating these values\r\n            let formatComponents = getComponents(format);\r\n\r\n            if (calculatePrecision)\r\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\r\n            if (calculateScale)\r\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\r\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\r\n        function getCustomFormatPrecision(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.precision > -1) {\r\n                return formatMeta.precision;\r\n            }\r\n            let result = 0;\r\n            if (formatMeta.hasDots) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex > -1) {\r\n                    let count = format.length;\r\n                    for (let i = dotIndex; i < count; i++) {\r\n                        let char = format.charAt(i);\r\n                        if (char.match(NumericPlaceholderRegex))\r\n                            result++;\r\n                        // 0.00E+0 :: Break before counting 0 in\r\n                        // exponential portion of format string\r\n                        if (char === ExponentialFormatChar)\r\n                            break;\r\n                    }\r\n                    result = Math.min(19, result);\r\n                }\r\n            }\r\n\r\n            formatMeta.precision = result;\r\n            return result;\r\n        }\r\n\r\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\r\n        function getCustomFormatScale(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.scale > -1) {\r\n                return formatMeta.scale;\r\n            }\r\n            let result = 1;\r\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\r\n                result = result * 100;\r\n            }\r\n            if (formatMeta.hasPermile && format.indexOf(\"\") > -1) {\r\n                result = result * 1000;\r\n            }\r\n            if (formatMeta.hasCommas) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex === -1) {\r\n                    dotIndex = format.length;\r\n                }\r\n                for (let i = dotIndex - 1; i > -1; i--) {\r\n                    let char = format.charAt(i);\r\n                    if (char === \",\") {\r\n                        result = result / 1000;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            formatMeta.scale = result;\r\n            return result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormat(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, nonScientificOverrideFormat?: string, isValueGlobalized?: boolean): string {\r\n            let suppressModifyValue = !!nonScientificOverrideFormat;\r\n            let formatParts = format.split(\".\", 2);\r\n            if (formatParts.length === 2) {\r\n                let wholeFormat = formatParts[0];\r\n                let fractionFormat = formatParts[1];\r\n                let displayUnit = \"\";\r\n\r\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\r\n                if (nonScientificOverrideFormat) {\r\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\r\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\r\n                    value = value.replace(displayUnit, \"\");\r\n                }\r\n\r\n                let globalizedDecimalSeparator = numberFormatInfo[\".\"];\r\n                let decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\r\n                let valueParts = value.split(decimalSeparator, 2);\r\n                let wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\r\n                let fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\r\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\r\n\r\n                let wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\r\n                let fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\r\n\r\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\r\n                    return wholeFormattedValue + fractionFormattedValue.value;\r\n\r\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\r\n            }\r\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatLeft(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, suppressModifyValue?: boolean): string {\r\n            let groupSymbolIndex = format.indexOf(\",\");\r\n            let enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\r\n            let groupDigitCount = 0;\r\n            let groupIndex = 0;\r\n            let groupSizes = numberFormatInfo.groupSizes || [3];\r\n            let groupSize = groupSizes[0];\r\n            let groupSeparator = numberFormatInfo[\",\"];\r\n            let sign = \"\";\r\n            let firstChar = value.charAt(0);\r\n            if (firstChar === \"+\" || firstChar === \"-\") {\r\n                sign = numberFormatInfo[firstChar];\r\n                value = value.substr(1);\r\n            }\r\n            let isZero = value === \"0\";\r\n            let result = \"\";\r\n            let leftBuffer = \"\";\r\n            let vi = value.length - 1;\r\n            let fmtOnly = true;\r\n            // Iterate through format chars and replace 0 and # with the digits from the value string\r\n            for (let fi = format.length - 1; fi > -1; fi--) {\r\n                let formatChar = format.charAt(fi);\r\n                switch (formatChar) {\r\n                    case ZeroPlaceholder:\r\n                    case DigitPlaceholder:\r\n                        fmtOnly = false;\r\n                        if (leftBuffer !== \"\") {\r\n                            result = leftBuffer + result;\r\n                            leftBuffer = \"\";\r\n                        }\r\n                        if (!suppressModifyValue) {\r\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\r\n                                if (enableGroups) {\r\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\r\n                                    if (groupDigitCount === groupSize) {\r\n                                        result = groupSeparator + result;\r\n                                        groupIndex++;\r\n                                        if (groupIndex < groupSizes.length) {\r\n                                            groupSize = groupSizes[groupIndex];\r\n                                        }\r\n                                        groupDigitCount = 1;\r\n                                    } else {\r\n                                        groupDigitCount++;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (vi > -1) {\r\n                                if (isZero && formatChar === DigitPlaceholder) {\r\n                                    // Special case - if we need to format a zero value and the # symbol is used - we don't copy it into the result)\r\n                                } else {\r\n                                    result = value.charAt(vi) + result;\r\n                                }\r\n                                vi--;\r\n                            } else if (formatChar !== DigitPlaceholder) {\r\n                                result = formatChar + result;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \",\":\r\n                        // We should skip all the , chars\r\n                        break;\r\n                    default:\r\n                        leftBuffer = formatChar + leftBuffer;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\r\n            if (!suppressModifyValue) {\r\n                if (vi > -1 && result !== \"\") {\r\n                    if (enableGroups) {\r\n                        while (vi > -1) {\r\n                            if (groupDigitCount === groupSize) {\r\n                                result = groupSeparator + result;\r\n                                groupIndex++;\r\n                                if (groupIndex < groupSizes.length) {\r\n                                    groupSize = groupSizes[groupIndex];\r\n                                }\r\n                                groupDigitCount = 1;\r\n                            } else {\r\n                                groupDigitCount++;\r\n                            }\r\n                            result = value.charAt(vi) + result;\r\n                            vi--;\r\n                        }\r\n                    } else {\r\n                        result = value.substr(0, vi + 1) + result;\r\n                    }\r\n                }\r\n                // Insert sign in front of the leftBuffer and result\r\n                return sign + leftBuffer + result;\r\n            }\r\n\r\n            if (fmtOnly)\r\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\r\n                return sign + leftBuffer + result;\r\n\r\n            return sign + leftBuffer + value + result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatRight(value: string, format: string, suppressModifyValue?: boolean): { value: string; fmtOnly?: boolean } {\r\n            let vi = 0;\r\n            let fCount = format.length;\r\n            let vCount = value.length;\r\n\r\n            if (suppressModifyValue) {\r\n                debug.assert(fCount > 0, \"Empty formatting string\");\r\n\r\n                let lastChar = format.charAt(fCount - 1);\r\n                if (!lastChar.match(NumericPlaceholderRegex))\r\n                    return {\r\n                        value: value + lastChar,\r\n                        fmtOnly: value === \"\",\r\n                    };\r\n\r\n                return {\r\n                    value: value,\r\n                    fmtOnly: value === \"\",\r\n                };\r\n            }\r\n\r\n            let result = \"\",\r\n                fmtOnly: boolean = true;\r\n            for (let fi = 0; fi < fCount; fi++) {\r\n                let formatChar = format.charAt(fi);\r\n                if (vi < vCount) {\r\n                    switch (formatChar) {\r\n                        case ZeroPlaceholder:\r\n                        case DigitPlaceholder:\r\n                            result += value[vi++];\r\n                            fmtOnly = false;\r\n                            break;\r\n                        default:\r\n                            result += formatChar;\r\n                    }\r\n                } else {\r\n                    if (formatChar !== DigitPlaceholder) {\r\n                        result += formatChar;\r\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                value: result,\r\n                fmtOnly: fmtOnly,\r\n            };\r\n        }\r\n\r\n        function localize(value: string, dictionary: any): string {\r\n            let plus = dictionary[\"+\"];\r\n            let minus = dictionary[\"-\"];\r\n            let dot = dictionary[\".\"];\r\n            let comma = dictionary[\",\"];\r\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\r\n                return value;\r\n            }\r\n            let count = value.length;\r\n            let result = \"\";\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \"+\":\r\n                        result = result + plus;\r\n                        break;\r\n                    case \"-\":\r\n                        result = result + minus;\r\n                        break;\r\n                    case \".\":\r\n                        result = result + dot;\r\n                        break;\r\n                    case \",\":\r\n                        result = result + comma;\r\n                        break;\r\n                    default:\r\n                        result = result + char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n    }\r\n\r\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\r\n    class DateTimeScaleFormatInfo {\r\n\r\n        // Fields\r\n        public YearPattern: string;\r\n        public MonthPattern: string;\r\n        public DayPattern: string;\r\n        public HourPattern: string;\r\n        public MinutePattern: string;\r\n        public SecondPattern: string;\r\n        public MillisecondPattern: string;\r\n\r\n        // Constructor\r\n        /**\r\n         * Creates new instance of the DateTimeScaleFormatInfo class.\r\n         * @param culture - culture which calendar info is going to be used to derive the formats.\r\n         */\r\n        constructor(culture: Culture) {\r\n            let calendar: Calendar = culture.calendar;\r\n            let patterns: any = calendar.patterns;\r\n            let monthAbbreviations: any = calendar[\"months\"][\"namesAbbr\"];\r\n            let cultureHasMonthAbbr: boolean = monthAbbreviations && monthAbbreviations[0];\r\n            let yearMonthPattern: string = patterns[\"Y\"];\r\n            let monthDayPattern: string = patterns[\"M\"];\r\n            let fullPattern: string = patterns[\"f\"];\r\n            let longTimePattern: string = patterns[\"T\"];\r\n            let shortTimePattern: string = patterns[\"t\"];\r\n            let separator: string = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\r\n\r\n            let hasYearSymbol: boolean = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\r\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\r\n\r\n            let yearPos: number = fullPattern.indexOf(\"yy\");\r\n            let monthPos: number = fullPattern.indexOf(\"MMMM\");\r\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\r\n\r\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\r\n\r\n            let minutePos: number = fullPattern.indexOf(\"mm\");\r\n            let pmPos: number = fullPattern.indexOf(\"tt\");\r\n            let shortHourPattern: string = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\r\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\r\n\r\n            this.MinutePattern = shortTimePattern;\r\n\r\n            this.SecondPattern = longTimePattern;\r\n\r\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\r\n\r\n            // Special cases\r\n            switch (culture.name) {\r\n                case \"fi-FI\":\r\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\r\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Methods\r\n\r\n        /**\r\n         * Returns the format string of the provided DateTimeUnit.\r\n         * @param unit - date or time unit\r\n         */\r\n        public getFormatString(unit: DateTimeUnit): string {\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return this.YearPattern;\r\n                case DateTimeUnit.Month:\r\n                    return this.MonthPattern;\r\n                case DateTimeUnit.Week:\r\n                case DateTimeUnit.Day:\r\n                    return this.DayPattern;\r\n                case DateTimeUnit.Hour:\r\n                    return this.HourPattern;\r\n                case DateTimeUnit.Minute:\r\n                    return this.MinutePattern;\r\n                case DateTimeUnit.Second:\r\n                    return this.SecondPattern;\r\n                case DateTimeUnit.Millisecond:\r\n                    return this.MillisecondPattern;\r\n            }\r\n\r\n            debug.assertFail('Unexpected unit: ' + unit);\r\n        }\r\n    }\r\n\r\n    export var formattingService: IFormattingService = new FormattingService();\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\r\n    export module SQExprShortSerializer {\r\n        export function serialize(expr: SQExpr): string {\r\n            return JSON.stringify(expr.accept(SQExprSerializer.instance));\r\n        }\r\n\r\n        export function serializeArray(exprs: SQExpr[]): string {\r\n            let str = '[';\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                if (i > 0)\r\n                    str += ',';\r\n                str += SQExprShortSerializer.serialize(exprs[i]);\r\n            }\r\n            return str + ']';\r\n        }\r\n\r\n        /** Responsible for serializing an SQExpr into a comparable string. */\r\n        class SQExprSerializer extends DefaultSQExprVisitor<{}> {\r\n            public static instance: SQExprSerializer = new SQExprSerializer();\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): {} {\r\n                return {\r\n                    col: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): {} {\r\n                return {\r\n                    measure: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): {} {\r\n                return {\r\n                    agg: {\r\n                        a: expr.arg.accept(this),\r\n                        f: expr.func,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitEntity(expr: SQEntityExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n                debug.assertValue(expr.entity, 'expr.entity');\r\n\r\n                return {\r\n                    e: expr.entity\r\n                };\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): {} {\r\n                return {\r\n                    h: expr.arg.accept(this),\r\n                    l: expr.level,\r\n                };\r\n            }\r\n\r\n            public visitHierarchy(expr: SQHierarchyExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    h: expr.hierarchy,\r\n                };\r\n            }\r\n\r\n            public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    n: expr.name,\r\n                    p: expr.property,\r\n                };\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    and: {\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    comp: {\r\n                        k: expr.comparison,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    const: {\r\n                        t: expr.type.primitiveType,\r\n                        v: expr.value,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    arithmetic: {\r\n                        o: expr.operator,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitScopedEval(expr: SQScopedEvalExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    scopedEval: {\r\n                        e: expr.expression.accept(this),\r\n                        s: serializeArray(expr.scope)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): {} {\r\n                debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n    import Selector = powerbi.data.Selector;\r\n    import SelectorsByColumn = powerbi.SelectorsByColumn;\r\n    import SelectorForColumn = powerbi.SelectorForColumn;\r\n\r\n    /**\r\n     * A combination of identifiers used to uniquely identify\r\n     * data points and their bound geometry.\r\n     */\r\n    export class SelectionId implements ISelectionId {\r\n        private selector: Selector;\r\n        // This is a new data structure to support drilling -- in the long term it should replace the 'selector' field\r\n        private selectorsByColumn: SelectorsByColumn;\r\n        private key: string;\r\n        private keyWithoutHighlight: string;\r\n\r\n        public highlight: boolean;\r\n\r\n        constructor(selector: Selector, highlight: boolean) {\r\n            this.selector = selector;\r\n            this.highlight = highlight;\r\n            this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\r\n            this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\r\n        }\r\n\r\n        public equals(other: SelectionId): boolean {\r\n            if (!this.selector || !other.selector) {\r\n                return (!this.selector === !other.selector) && this.highlight === other.highlight;\r\n            }\r\n            return this.highlight === other.highlight &&  Selector.equals(this.selector, other.selector);\r\n        }\r\n        \r\n        /**\r\n         * Checks equality against other for all identifiers existing in this.\r\n         */\r\n        public includes(other: SelectionId, ignoreHighlight: boolean = false): boolean {\r\n            let thisSelector = this.selector;\r\n            let otherSelector = other.selector;\r\n            if (!thisSelector || !otherSelector) {\r\n                return false;\r\n            }\r\n            let thisData = thisSelector.data;\r\n            let otherData = otherSelector.data;\r\n            if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\r\n                return false;\r\n            if (!ignoreHighlight && this.highlight !== other.highlight)\r\n                return false;\r\n            if (thisData) {\r\n                if (!otherData)\r\n                    return false;\r\n                if (thisData.length > 0) {\r\n                    for (let i = 0, ilen = thisData.length; i < ilen; i++) {\r\n                        var thisValue = <DataViewScopeIdentity>thisData[i];\r\n                        if (!otherData.some((otherValue: DataViewScopeIdentity) => DataViewScopeIdentity.equals(thisValue, otherValue)))\r\n                            return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public getKey(): string {\r\n            return this.key;\r\n        }\r\n\r\n        public getKeyWithoutHighlight(): string {\r\n            return this.keyWithoutHighlight;\r\n        }\r\n        \r\n        public hasIdentity(): boolean {\r\n            return (this.selector && !!this.selector.data);\r\n        }\r\n\r\n        public getSelector(): Selector {\r\n            return this.selector;\r\n        }\r\n\r\n        public getSelectorsByColumn(): Selector {\r\n            return this.selectorsByColumn;\r\n        }\r\n\r\n        public static createNull(highlight: boolean = false): SelectionId {\r\n            return new SelectionId(null, highlight);\r\n        }\r\n\r\n        public static createWithId(id: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            if (id) {\r\n                selector = {\r\n                    data: [id]\r\n                };\r\n            }\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithMeasure(measureId: string, highlight: boolean = false): SelectionId {\r\n            debug.assertValue(measureId, 'measureId');\r\n\r\n            let selector: Selector = {\r\n                metadata: measureId\r\n            };\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n            selectionId.selectorsByColumn = { metadata: measureId };\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasure(id: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: powerbi.data.Selector = {};\r\n            if (id) {\r\n                selector.data = [id];\r\n            }\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id && !measureId)\r\n                selector = null;\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasureAndCategory(id: DataViewScopeIdentity, measureId: string, queryName: string, highlight: boolean = false): SelectionId {\r\n            let selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\r\n\r\n            if (selectionId.selector) {\r\n                selectionId.selectorsByColumn = {};\r\n                if (id && queryName) {\r\n                    selectionId.selectorsByColumn.dataMap = {};\r\n                    selectionId.selectorsByColumn.dataMap[queryName] = id;\r\n                }\r\n                if (measureId)\r\n                    selectionId.selectorsByColumn.metadata = measureId;\r\n            }\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIds(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector = { data: selectorData };\r\n            \r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithIdsAndMeasure(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = {};\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector.data = selectorData;\r\n\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id1 && !id2 && !measureId)\r\n                selector = null;\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithSelectorForColumnAndMeasure(dataMap: SelectorForColumn, measureId: string, highlight: boolean = false): SelectionId {\r\n\r\n            let selectionId: visuals.SelectionId;\r\n            let keys = Object.keys(dataMap);\r\n            if (keys.length === 2) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], <DataViewScopeIdentity>dataMap[keys[1]], measureId, highlight);\r\n            } else if (keys.length === 1) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], null, measureId, highlight);\r\n            } else {\r\n                selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\r\n            }\r\n\r\n            let selectorsByColumn: SelectorsByColumn = {};\r\n            if (!_.isEmpty(dataMap))\r\n                selectorsByColumn.dataMap = dataMap;\r\n            if (measureId)\r\n                selectorsByColumn.metadata = measureId;\r\n            if (!dataMap && !measureId)\r\n                selectorsByColumn = null;\r\n\r\n            selectionId.selectorsByColumn = selectorsByColumn;\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithHighlight(original: SelectionId): SelectionId {\r\n            debug.assertValue(original, 'original');\r\n            debug.assert(!original.highlight, '!original.highlight');\r\n\r\n            let newId = new SelectionId(original.getSelector(), /*highlight*/ true);\r\n            newId.selectorsByColumn = original.selectorsByColumn;\r\n\r\n            return newId;\r\n        }\r\n\r\n        private static idArray(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity): DataViewScopeIdentity[] {\r\n            if (id1 || id2) {\r\n                let data = [];\r\n                if (id1)\r\n                    data.push(id1);\r\n                if (id2 && id2 !== id1)\r\n                    data.push(id2);\r\n                return data;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This class is designed to simplify the creation of SelectionId objects\r\n     * It allows chaining to build up an object before calling 'create' to build a SelectionId\r\n     */\r\n    export class SelectionIdBuilder implements ISelectionIdBuilder {\r\n        private dataMap: SelectorForColumn;\r\n        private measure: string;\r\n\r\n        public static builder(): SelectionIdBuilder {\r\n            return new SelectionIdBuilder();\r\n        }\r\n\r\n        public withCategory(categoryColumn: DataViewCategoryColumn, index: number): this{\r\n            if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\r\n                this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\r\n            \r\n            return this;\r\n        }\r\n\r\n        public withSeries(seriesColumn: DataViewValueColumns, valueColumn: DataViewValueColumn | DataViewValueColumnGroup): this {\r\n            if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\r\n                this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\r\n\r\n            return this;\r\n        }\r\n\r\n        public withMeasure(measureId: string): this {\r\n            this.measure = measureId;\r\n\r\n            return this;\r\n        }\r\n\r\n        public createSelectionId(): SelectionId {\r\n            return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\r\n        }\r\n\r\n        private ensureDataMap(): SelectorForColumn {\r\n            if (!this.dataMap)\r\n                this.dataMap = {};\r\n\r\n            return this.dataMap;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"/source/"}