{"version":3,"sources":["VisualsData.js","../ts/visualsData/semanticQuery/sqExprVisitor.ts","../ts/visualsData/types/enumType.ts","../ts/visualsData/types/fill.ts","../ts/visualsData/types/image.ts","../ts/visualsData/types/structuralType.ts","../ts/visualsData/types/valueType.ts","../ts/visualsData/contracts/dataShapeBinding.ts","../ts/visualsData/contracts/dataShapeBindingDataReduction.ts","../ts/visualsData/contracts/federatedConceptualSchema.ts","../ts/visualsData/contracts/selector.ts","../ts/visualsData/contracts/query.ts","../ts/visualsData/contracts/queryProjection.ts","../ts/visualsData/contracts/visualData.ts","../ts/visualsData/formatting/dateTimeSequence.ts","../ts/visualsData/formatting/displayUnitSystem.ts","../ts/visualsData/formatting/numericSequence.ts","../ts/visualsData/formatting/numericSequenceRange.ts","../ts/visualsData/formatting/valueFormatter.ts","../ts/visualsData/dataView/dataRoleHelper.ts","../ts/visualsData/dataView/dataViewCategoricalReader.ts","../ts/visualsData/dataView/dataViewConcatenateCategoricalColumns.ts","../ts/visualsData/dataView/dataViewMappingVisitor.ts","../ts/visualsData/dataView/dataViewNormalizeValues.ts","../ts/visualsData/dataView/dataViewObject.ts","../ts/visualsData/dataView/dataViewObjectDefinition.ts","../ts/visualsData/dataView/dataViewObjectDescriptor.ts","../ts/visualsData/dataView/dataViewObjectEvaluationUtils.ts","../ts/visualsData/dataView/dataViewObjectEvaluator.ts","../ts/visualsData/dataView/dataViewPivotCategorical.ts","../ts/visualsData/dataView/dataViewPivotMatrix.ts","../ts/visualsData/dataView/dataViewSelfCrossJoin.ts","../ts/visualsData/dataView/dataViewPivotCategoricalToPrimaryGroups.ts","../ts/visualsData/dataView/dataViewTransform.ts","../ts/visualsData/displayNameGetter.ts","../ts/visualsData/iFormattingService.ts","../ts/visualsData/semanticQuery/exprPatterns/fieldExprPattern.ts","../ts/visualsData/dataView/dataViewAnalysis.ts","../ts/visualsData/dataView/dataViewRoleWildcard.ts","../ts/visualsData/dataView/dataViewScopeIdentity.ts","../ts/visualsData/dataView/dataViewScopeWildcard.ts","../ts/visualsData/dataView/rules/colorAllocatorCache.ts","../ts/visualsData/dataView/dataViewRegression.ts","../ts/visualsData/dataView/dataViewSelectTransform.ts","../ts/visualsData/dataView/rules/categoricalEvalContext.ts","../ts/visualsData/dataView/rules/tableEvalContext.ts","../ts/visualsData/dataView/rules/ruleEvaluation.ts","../ts/visualsData/dataView/rules/colorRuleEvaluation.ts","../ts/visualsData/dataView/utils/dataViewMatrixUtils.ts","../ts/visualsData/dataView/utils/dataViewMetadataColumnUtils.ts","../ts/visualsData/contracts/conceptualSchema.ts","../ts/visualsData/dataView/scriptResultUtil.ts","../ts/visualsData/segmentation/dataViewMerger.ts","../ts/visualsData/semanticQuery/sqExprRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/equalsToInRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/filterScopeIdsCollector.ts","../ts/visualsData/semanticQuery/exprPatterns/scopeIdentityExtractor.ts","../ts/visualsData/semanticQuery/primitiveValueEncoding.ts","../ts/visualsData/semanticQuery/sqAggregationOperations.ts","../ts/visualsData/semanticQuery/sqHierarchyExprUtils.ts","../ts/visualsData/semanticQuery/sqExprGroupUtils.ts","../ts/visualsData/semanticQuery/sqExpr.ts","../ts/visualsData/semanticQuery/sqExprUtils.ts","../ts/visualsData/semanticQuery/semanticQueryRewriter.ts","../ts/visualsData/semanticQuery/semanticQuery.ts","../ts/visualsData/dataView/dataViewBuilder.ts","../ts/visualsData/dataView/rules/staticEvalContext.ts","../ts/visualsData/dataView/rules/matrixEvalContext.ts","../ts/visualsData/services/formattingService.ts","../ts/visualsData/services/serialization/sqExprShortSerializer.ts","../ts/visualsData/selection/selectionId.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","powerbi","data","DefaultSQExprVisitorWithArg","visitEntity","expr","arg","visitDefault","visitColumnRef","visitMeasureRef","visitAggr","visitPercentile","visitHierarchy","visitHierarchyLevel","visitPropertyVariationSource","visitSelectRef","visitBetween","visitIn","visitAnd","visitOr","visitCompare","visitContains","visitExists","visitNot","visitStartsWith","visitConstant","visitDateSpan","visitDateAdd","visitNow","visitDefaultValue","visitAnyValue","visitArithmetic","visitFillRule","visitResourcePackageItem","visitScopedEval","DefaultSQExprVisitor","_super","apply","arguments","DefaultSQExprVisitorWithTraversal","source","accept","lower","upper","args","i","len","length","values","valueTuple","j","jlen","left","right","input","rule","gradient2","linearGradient2","gradient3","linearGradient3","visitLinearGradient2","visitLinearGradient3","visitFillRuleStop","min","max","mid","expression","_i","_a","scope","scopeExpr","stop","color","value","createEnumType","members","EnumType","allMembers","validMembers","membersToReturn","allMembers_1","member","_","contains","push","FillSolidColorTypeDescriptor","nullable","descriptor","advancedDescriptor","ImageDefinition","urlType","misc","imageUrl","StructuralTypeDescriptor","isValid","type","fill","fillRule","filter","image","paragraphs","getPrimitiveType","extendedType","PrimitiveTypeMask","isPrimitiveType","PrimitiveTypeWithFlagsMask","getCategoryFromExtendedType","category","ExtendedType","delimIdx","lastIndexOf","baseCategory","slice","toExtendedType","primitiveType","primitiveString","PrimitiveType","t","Null","categoryType","categoryPrimitiveType","matchesExtendedTypeWithAnyPrimitive","a","PrimitiveTypeFlagsExcludedMask","EnumExtensions","jsCommon","ValueType","enumType","underlyingType","hasFlag","Temporal","temporalType","TemporalType","Geography","geographyType","GeographyType","Miscellaneous","miscType","MiscellaneousType","Formatting","formattingType","FormattingType","Enumeration","Scripting","scriptingType","ScriptType","fromDescriptor","text","fromExtendedType","Text","integer","Integer","numeric","Double","bool","Boolean","dateTime","DateTime","duration","Duration","binary","Binary","none","None","scripting","ScriptSource","enumeration","fromEnum","temporal","year","Year_Integer","month","Month_Integer","geography","address","Address","city","City","continent","Continent","country","Country","county","County","region","Region","postalCode","PostalCode_Text","stateOrProvince","StateOrProvince","place","Place","latitude","Latitude_Double","longitude","Longitude_Double","Image","ImageUrl","webUrl","WebUrl","barcode","Barcode_Text","formatting","Color","formatString","FormatString","alignment","Alignment","labelDisplayUnits","LabelDisplayUnits","fontSize","FontSize","labelDensity","LabelDensity","fromPrimitiveTypeAndCategory","id","toString","typeCache","isCompatibleTo","otherTypes","valueType","otherTypes_1","otherType","otherValueType","isCompatibleFrom","other","otherPrimitiveType","equals","isEqual","defineProperty","get","enumerable","configurable","Numeric","Date","Time","Year","Month","PostalCode","Latitude","Longitude","Barcode","DataShapeBindingLimitType","SubtotalType","DataShapeBindingDataReduction","createFrom","reduction","result","top","Top","count","Count","bottom","Bottom","sample","Sample","window","Window","FederatedConceptualSchema","options","schemas","links","schema","name","data_1","Selector","filterFromSelector","selectors","isNot","isEmpty","exprs","ilen","identity","data_2","exprToAdd","undefined","SQExprBuilder","and","DataViewScopeIdentity","filterFromExprs","matchesData","selector","identities","selectorData","dataItem","selectorDataItem","DataViewScopeWildcard","matches","matchesKeys","keysList","selectorDataLength","selectorDataExprs","ScopeIdentityExtractor","getKeys","SQExprUtils","sequenceEqual","x","y","metadata","equalsDataArray","equalsData","selector1","selector2","roles","DataViewRoleWildcard","getKey","toStringify","data_3","key","JSON","stringify","containsWildcard","dataItems","dataItems_1","wildCard","hasRoleWildcard","dataItems_2","isRoleWildcard","getArithmeticOperatorName","arithmeticOperatorKind","Error","EntitySourceType","TimeUnit","QueryAggregateFunction","QueryComparisonKind","SemanticType","FilterKind","QueryProjectionCollection","items","activeProjectionRefs","showAll","_activeProjectionRefs","_showAll","all","set","queryReferences","queryRefs","map","val","queryRef","queryReferences_1","queryReference","addActiveQueryReference","getLastActiveQueryReference","replaceQueryRef","oldQueryRef","newQueryRef","item","clone","cloneDeep","QueryProjectionsByRole","clonedRoles","roleName","getRole","DisplayUnitSystemType","DateTimeSequence","unit","sequence","add","date","extendToCover","addInterval","interval","splice","moveToCover","delta","getDelta","Math","floor","calculate","dataMin","dataMax","expectedCount","getIntervalUnit","DateTimeUnit","calculateYears","calculateMonths","Week","calculateWeeks","Day","calculateDays","Hour","calculateHours","Minute","calculateMinutes","Second","calculateSeconds","Millisecond","calculateMilliseconds","yearsRange","NumericSequenceRange","calculateDataRange","getFullYear","NumericSequence","newMinYear","fromNumericSequence","minYear","maxYear","minMonth","getMonth","maxMonth","calculateUnits","firstDayOfWeek","minDayOfWeek","getDay","dayOffset","minDay","getDate","ceilWithPrecision","floorWithPrecision","getHours","getMinutes","getSeconds","round","DateUtils","addYears","addMonths","addWeeks","addDays","addHours","addMinutes","addSeconds","addMilliseconds","intervalOffset","getTime","maxCount","totalDays","totalHours","totalMinutes","totalSeconds","totalMilliseconds","getMilliseconds","MIN_COUNT","MAX_COUNT","isLeap","getMonthDays","MonthDaysLeap","MonthDays","yearDelta","day","isLeapDay","setFullYear","monthDelta","weeks","days","hours","minutes","seconds","milliseconds","createDisplayUnits","unitLookup","adjustMinBasedOnPreviousUnit","units","maxExponent","names","addUnitIfNonEmpty","pow10","title","format","labelFormat","previousUnit","applicableRangeMax","DisplayUnit","applicableRangeMin","defaultScientificBigNumbersBoundary","scientificSmallNumbersBoundary","PERCENTAGE_FORMAT","SCIENTIFIC_FORMAT","DEFAULT_SCIENTIFIC_FORMAT","SUPPORTED_SCIENTIFIC_FORMATS","project","removeDecimalNoise","reverseProject","isApplicableTo","abs","precision","getPrecision","greaterOrEqualWithPrecision","lessWithPrecision","isScaling","DisplayUnitSystem","displayUnit","update","unitBaseValue","findApplicableDisplayUnit","decimals","trailingZeros","isFormatSupported","getNumberOfDecimalsForFormatting","hasScientitifcFormat","formatHelper","isScalingUnit","shouldRespectScalingUnit","formattingService","formatValue","UNSUPPORTED_FORMATS","test","isPercentageFormat","indexOf","nonScientificFormat","visuals","valueFormatter","DefaultNumericFormat","NumberFormat","addDecimalsToFormat","isStandardNumberFormat","formatNumberWithCustomOverride","formatSingleValue","shouldUseValuePrecision","isScientific","toUpperCase","supportsScientificFormat","shouldFallbackToScientific","getScientificFormat","numericFormat","getNumericFormat","NoDisplayUnitSystem","call","DefaultDisplayUnitSystem","getUnits","reset","previousUnitValue","Infinity","WholeUnitsDisplayUnitSystem","DataLabelsDisplayUnitSystem","AUTO_DISPLAYUNIT_VALUE","NONE_DISPLAYUNIT_VALUE","concat","range","maxAllowedMargin","minPower","useZeroRefPoint","steps","ensureInRange","MIN_EXP","forcedSingleStop","getSize","canExtendMin","hasFixedMin","canExtendMax","hasFixedMax","size","exp","log10","stepExp","expectedCountExp","power","roundMin","floorToPrecision","roundMax","ceilToPrecision","roundRange","calculateFixedRange","shrinkByStep","dexp","e","stepsCount","stepPower","step","roundToPrecision","trimMinMax","stepCount","maxStepCount","minStepCount","offset","minMargin","maxMargin","marginPrecision","_ensureIncludeZero","includeZero","_ensureNotEmpty","DEFAULT_MAX","_ensureDirection","temp","oldCount","newCount","deltaCount","ceil","fixedMin","fixedMax","hasDataRange","ValueUtil","hasValue","MIN_SUPPORTED_DOUBLE","MAX_SUPPORTED_DOUBLE","beautify","BeautifiedFormat","defaultLocalizedStrings","describeUnit","exponent","exponentLookup","getLocalizedString","stringId","getFormatMetadata","getCustomFormatMetadata","setLocaleOptions","locale","createDefaultFormatter","allowFormatBeautification","formatBeaut","formatCore","shouldUseNumericDisplayUnits","displayUnitSystem_1","createDisplayUnitSystem","displayUnitSystemType","singleValueFormattingMode_1","formatSingleValues","value2","decimals_1","forcePrecision_1","MaxScaledDecimalPlaces","detectAxisPrecision","axisValue","isInteger","formattedValue","getStringFormat","StringExtensions","isNullOrUndefinedOrWhiteSpaceString","MaxValueForDisplayUnitRounding","shouldUseDateUnits","tickCount","unit_1","dateFormatString","formatVariantMeasureValue","column","formatStringProp","nullsAreBlank","valueFormat","getFormatString","DateTimeMetadataColumn","describe","Default","WholeUnits","Verbose","DataLabels","MinIntegerValueForDisplayUnits","isCustomFormat","isStandardFormat","MinPrecisionForDisplayUnits","formatStringProperty","suppressTypeFallback","propertyValue","DataViewObjects","getValue","objects","columnType","DefaultDateFormat","DefaultIntegerFormat","formatListCompound","strings","conjunction","lastIndex","restatementComma","formatListAnd","restatementCompoundAnd","formatListOr","restatementCompoundOr","isNaN","NaN","Number","NEGATIVE_INFINITY","negativeInfinity","POSITIVE_INFINITY","infinity","getDisplayUnits","displayUnitSystem","0.00 %;-0.00 %;0.00 %","0.0 %;-0.0 %;0.0 %","NullValue","BooleanTrue","BooleanFalse","NaNValue","InfinityValue","NegativeInfinityValue","RestatementComma","RestatementCompoundAnd","RestatementCompoundOr","DisplayUnitSystem_EAuto_Title","DisplayUnitSystem_E0_Title","DisplayUnitSystem_E3_LabelFormat","DisplayUnitSystem_E3_Title","DisplayUnitSystem_E6_LabelFormat","DisplayUnitSystem_E6_Title","DisplayUnitSystem_E9_LabelFormat","DisplayUnitSystem_E9_Title","DisplayUnitSystem_E12_LabelFormat","DisplayUnitSystem_E12_Title","Percentage","Percentage1","TableTotalLabel","Tooltip_HighlightedValueDisplayName","Funnel_PercentOfFirst","Funnel_PercentOfPrevious","Funnel_PercentOfFirst_Highlight","Funnel_PercentOfPrevious_Highlight","GeotaggingString_Continent","GeotaggingString_Continents","GeotaggingString_Country","GeotaggingString_Countries","GeotaggingString_State","GeotaggingString_States","GeotaggingString_City","GeotaggingString_Cities","GeotaggingString_Town","GeotaggingString_Towns","GeotaggingString_Province","GeotaggingString_Provinces","GeotaggingString_County","GeotaggingString_Counties","GeotaggingString_Village","GeotaggingString_Villages","GeotaggingString_Post","GeotaggingString_Zip","GeotaggingString_Code","GeotaggingString_Place","GeotaggingString_Places","GeotaggingString_Address","GeotaggingString_Addresses","GeotaggingString_Street","GeotaggingString_Streets","GeotaggingString_Longitude","GeotaggingString_Longitude_Short","GeotaggingString_Latitude","GeotaggingString_Latitude_Short","GeotaggingString_PostalCode","GeotaggingString_PostalCodes","GeotaggingString_ZipCode","GeotaggingString_ZipCodes","GeotaggingString_Territory","GeotaggingString_Territories","null","true","false","displayName","DataRoleHelper","getMeasureIndexOfRole","grouped","firstGroup","hasRole","getCategoryIndexOfRole","categories","hasRoleInDataView","dataView","columns","any","c","hasRoleInValueColumn","valueColumn","createIDataViewCategoricalReader","DataViewCategoricalReader","categorical","hasValidCategories","hasAnyValidValues","valueRoleIndexMapping","firstGroupValues","valueIndex","valueCount","valueRoles","role","dataHasDynamicSeries","hasCategories","getCategoryCount","getCategoryValues","getCategoryFromRole","getCategoryValue","categoryIndex","getCategoryColumn","getCategoryMetadataColumn","getCategoryColumnIdentityFields","identityFields","getCategoryDisplayName","targetColumn","hasCompositeCategories","hasCategoryWithRole","getCategoryObjects","hasValues","hasHighlights","highlights","seriesIndex","getValueInternal","getHighlight","getAllValuesForRole","valuesInRole","roleValueIndex","roleValueCount","getAllHighlightsForRole","groupIndex","valueColumnIndexInRole","valueColumnIndex","groupedValues","getFirstNonNullValueForCategory","seriesCount","getMeasureQueryName","queryName","getValueColumn","getValueMetadataColumn","getAllValueMetadataColumnsForRole","getValueDisplayName","hasDynamicSeries","getSeriesCount","valueRoleName","roleIndexMap","getSeriesObjects","getSeriesValueColumns","getSeriesValueColumnGroup","getSeriesMetadataColumn","getSeriesColumnIdentityFields","getSeriesName","getSeriesDisplayName","DataViewConcatenateCategoricalColumns","inherit","Prototype","inheritSingle","detectAndApply","objectDescriptors","roleMappings","projectionOrdering","selects","projectionActiveItems","dataViewCategorical","concatenationSource","detectCategoricalRoleForHierarchicalGroup","columnsSortedByProjectionOrdering","sortColumnsByProjectionOrdering","activeItemsToIgnoreInConcatenation","chain","activeItemInfo","suppressConcat","applyConcatenation","applyToPlayChartCategorical","categoryRoleName","transformingColumns_1","transformingMetadata","m","transformingDataView","dataViewMappings","roleKinds","DataViewSelectTransform","createRoleKindFromMetadata","projections","projectionsFromSelects","supportedRoleMappings","DataViewAnalysis","chooseDataViewMappings","supportedMappings","isEveryRoleMappingForCategorical","every","roleMapping","targetRoleName_1","getSingleCategoryRoleNameInEveryRoleMapping","isVisualExpectingMaxOneCategoryColumn","categoryColumnsForTargetRole_1","categoryColumn","areValuesCountsEqual","categoricalRoleMappings","uniqueCategoryRoles","categoryRoles","getAllRolesInCategories","uniq","isSameCategoryRoleNameInAllRoleMappings","isUndefined","categoricalRoleName","conditions","condition","categoricalRoleMapping","roleNames","DataViewMapping","visitCategoricalCategories","visitRole","queryRefsToIgnore","formatStringPropId","DataViewObjectDescriptors","findFormatString","concatenatedValues","concatenateValues","columnsSourceSortedByProjectionOrdering","concatenatedColumnMetadata","createConcatenatedColumnMetadata","transformedDataView","addToMetadata","concatenatedCategoryColumn","createConcatenatedCategoryColumn","transformedCategoricalCategories","difference","transformedCategorical","columnsSortedByProjectionOrdering_1","columnsInProjectionOrdering","columnsByIndex_1","columns_1","index","columnIndicesInProjectionOrdering","columnIndex","sourceColumnsSortedByProjectionOrdering","concatenatedDisplayName","sourceColumnsSortedByProjectionOrdering_1","columnSource","newRoles","newColumnMetadata","columnSourceForCurrentDrillLevel","last","isMeasure","newColumn","transformedColumns","transformedMetadata","columnMetadata","newCategoryColumn","firstColumn","visitMapping","mapping","visitor","visitCategorical","table","visitTable","matrix","visitMatrix","tree","visitTree","single","visitSingle","visitCategoricalValues","visitBind","visitFor","visitList","visitReduction","groupedRoleMapping","visitGrouped","group","select","rows","visitMatrixItems","visitTreeNodes","nodes","visitTreeValues","context","bind","to","forValue","select_1","by","reductionAlgorithm","dataReductionAlgorithm","DataViewNormalizeValues","rolesToNormalize","dataRoles","requiredTypes","filterVariantMeasures","dataview","columnFilter","generateMetadataColumnFilter","valueFilter","generateValueFilter","usedMappings","dataViewMappings_1","dataViewMapping","dataViewMappingProp","filterVariantMeasuresCategorical","filterVariantMeasuresTable","filterVariantMeasuresTreeNode","root","filterVariantMeasuresMatrix","filterVariantMeasuresSingle","columnsToNormalize","columns_2","rolesToNormalize_1","columnValueFilters","columns_3","columnValueFilter","generateColumnValueFilter","getColumnRequiredTypes","doesValueMatchTypes","columnRoles","rolesToNormalize_2","_b","typeDescriptor","valuesGrouped","valuesGrouped_1","valueGroup","valuesInGroup","valuesInGroup_1","normalizeVariant","filteredColumns","columns_4","filteredColumns_1","node","children","child","filterVariantMeasuresMatrixRecursive","dataviewMatrix","nodeValue","valueSourceIndex","valueSources","isNumber","rolesToNormalize_3","dataViewMappings_2","firstColumnByRoleName","object","types","types_1","columns_5","propertyId","defaultValue","objectOrMap","objectName","DataViewObject","propertyName","getObject","getUserDefinedObjects","getFillColor","defaultColor","solid","isUserDefined","isArray","getFillColorByPropertyName","DataViewObjectDefinitions","JsonComparer","ensure","defns","defnsForObject","defn","newDefn","properties","deleteProperty","getObjectDefinition","DataViewObjectDefinition","deleteSingleProperty","setValue","getPropertyContainer","propertiesAreEqual","SemanticFilter","isSameFilter","allPropertiesAreEqual","keys","property","encodePropertyValue","valueTypeDescriptor","$","isNumeric","imageValue","imageDefinition","url","scaling","original","cloned","originalDefns","clonedDefns","originalDefns_1","originalDefn","cloneProperties","descriptors","findProperty","propDesc","formattingTypeDesc","findFilterOutput","propType","findDefaultValue","propPredicate","objPropDescs","DataViewObjectEvaluationUtils","evaluateDataViewObjects","evalContext","objectDefns","objectDefinition","evaluatedObject","DataViewObjectEvaluator","run","groupObjectsBySelector","objectDefinitions","objectDefnList","objectDefn","ensureDefinitionListForSelector","metadataOnce","groupedObjects","userDefined","groupedObjects_1","item_1","addImplicitObjects","objectsForAllSelectors","selectTransforms","addDefaultFormatString","addDefaultValue","selectIdx","selectLen","selectTransform","applyFormatString","getColumnFormatForIndex","defaultValueProp","selectTransforms_1","applyDefaultValue","columnIdx","columnLen","formatStringValue","applyMetadataProperty","metadataObjects","targetObjectDefn","targetMetadataObject","findWithMatchingSelector","targetObjectDefns","findExistingObject","objectDescriptor","propertyDefinitions","propertyDescriptors","propertyDefinition","propertyDescriptor","evaluateProperty","structuralType","evaluateValue","RuleEvaluation","evaluateFill","evaluateFillRule","evaluateImage","evaluateParagraphs","fillDefn","fillType","fillRuleDefn","evaluateColorStop","colorStop","colorValueType","numericType","definition","textType","evaluateArrayCopyOnChange","evaluateParagraph","evaluated","definitionTextRuns","textRuns","evaluatedTextRuns","evaluateTextRun","definitionValue","evaluatedValue","definitions","evaluator","evaluatedValues","take","SQExpr","ExpressionEvaluator","evaluate","instance","getExprValue","inputValue","colorAllocator","getColorAllocator","DataViewPivotCategorical","categoryIdentities","categoryValues","pivotedColumns","pivotedValues","rowIdx","rowCount","categoryValue","categoryIdentity","colIdx","colCount","pivotedColumn","groupName","pivotedValue","subtotal","pivotedMetadata","DataViewTransform","createValueColumns","DataViewPivotMatrix","dataViewMatrix","columnHierarchyRewritten","rowHierarchyRewritten","levels","pivotedRowNode","level","columnLeafNodes","measureCount","pivotResultMeasureHeaderLevel","index_1","callback","measureHeaderLeaf","columnLeafNode","levelSourceIndex","isSubtotal","hierarchyTreesRewritten","forEachLeaf","cloneTreeExecuteOnLeaf","cloneTree","sources","updatedRowRoot","updatedNode","newChildren","updatedChild","createNullValues","array","Array","inheritArrayWithValue","nullValues","inherited","DataViewSelfCrossJoin","applyCategorical","dataViewMetadata","categoryLength","valuesArray","createCategoricalDataViewBuilder","withCategories","withGroupedValues","createGroupedValues","build","nullValuesArray","valuesArrayLen","seriesData","seriesDataItem","originalValueColumn","originalHighlightValues","seriesDataItemCategory","groupColumn","identityFrom","fields","valueColumns","v","DataViewPivotCategoricalToPrimaryGroups","ArrayExtensions","pivotBinding","binding","allMappings","finalMapping","defaultDataVolume","canPivotCategorical","Primary","Groupings","Secondary","DataReduction","DataVolume","dataVolume","isPivotableAxis","axis","Projections","Subtotal","SuppressedProjections","unpivotResult","oldDataView","inferUnpivotTransform","newDataView","copy","newDataViewMatrix","unpivotMatrix","hasCompositeGroupInSeries","utils","DataViewMatrixUtils","containsCompositeGroup","categoricalFromUnpivotedMatrix","supportedDataViewMappings","categoricalMapping","matrixDataview","categoryGroups","valueGroups","addGroupingRole","groups","roleProjections","roleProjection","VisualDataRoleKind","Grouping","_c","oldMatrix","oldRows","oldRoot","oldChildren","series","seriesIdLevel","seriesIdFields","childIdentityFields","categoryIdLevel","categoryIdFields","findCategory","addCategory","categoryNode","oldChildren_1","seriesNode","matrixValues","_d","newColumns","s","inheritedNode","newColChildren","srcnode","dstnode","newRows","row","rowValues","mvalues","k","l","newMatrix","measureMetadata","createCategoryColumnsFromUnpivotedMatrix","seriesColumn","valueColumnMetadataSrc","valueColumnMetadataDst","groups_1","unpivotedMatrix","categoryIdentityFields","categorySourceColumns","groupLevelValues","levelValues","transforms","activeItems","colorAllocatorFactory","transformEmptyDataView","visualDataViews","transformQueryToVisualDataView","DataViewRegression","transformSelects","transformedDataViews","splits","transformDataView","splits_1","split","transformed","emptyDataView","transformObjects","selectsToInclude","targetKinds","getTargetKinds","ordering","roleMappings_1","targetDataViewKinds","columnRewrites","applyTransformsToColumns","applyRewritesToCategorical","pivotIfNecessary","matrixTransformationContext","applyRewritesToMatrix","shouldPivotMatrix","applyRewritesToTable","prototypeColumns","rewrites","prototypeColumn","getFormatForColumn","kpi","sort","discourageAggregationAcrossGroups","from","override","rewrittenSource","findOverride","rewritten","overrideArray","valuesOverride","rewrittenValuesSource","seriesGroups_1","isDynamicSeries_1","nextSeriesGroupIndex","currentSeriesGroup","currentValueColumn","newToOldPositions","createTableColumnPositionMapping","columnsClone","sourceColumn","newRow","originalOrder","rewrite","newOrder","createOrderMapping","overrideHierarchy","hierarchy","rewrittenHierarchy","newLevels","newLevel","levelSources","ensureRewritten","h","r","firstRoleMappingWithMatrix","find","matrixMapping","columnLevels","newToOldPositions_1","createMatrixValuesPositionMapping","keys_1","numKeys_1","reorderChildNodes","forEachNodeAtLevel","newValues","iterations","keysIndex","reorderMatrixCompositeGroups","numKeys","childrenClone","supportedDataViewMapping","projection","transformedRowsHierarchy_1","reorderMatrixHierarchyCompositeGroups","transformedColumnsHierarchy_1","matrixHierarchy","hierarchyRole","transformedHierarchy","selectIndicesInProjectionOrder","hasMultipleColumnsInProjection","hierarchyLevel","newToOldLevelSourceIndicesMapping","createMatrixHierarchyLevelSourcesPositionMapping","inheritMatrixNodeHierarchy","transformingHierarchyLevel","reorderMatrixHierarchyLevelColumnSources","reorderMatrixHierarchyLevelValues","levelSourceColumns","columnsForHierarchyRoleOrderedByLevelSourceIndex","DataViewMetadataColumnUtils","joinMetadataColumnsAndProjectionOrder","columnsForHierarchyRoleOrderedByProjection","sortBy","columnInfo","projectionOrderIndex","sourceIndex","originalLevelSources","newLevelSourceIndices","newLevelSourceIndex","oldLevelSourceIndex","transformingHierarchyRootNode","transformingHierarchyLevelIndex","oldToNewLevelSourceIndicesMapping","createReversedMapping","transformingMatrixNode","originalLevelValues","newlyOrderedLevelValues","levelValue","transformingLevelValue","newlyOrderedLastLevelValue","newPosition","reversed","keyAsNumber","parseInt","targetLevel","columnRewrite","dataObjects","evaluateMetadataObjects","metadataObject","colorAllocatorCache","populateColorAllocatorCache","evaluateMetadataRepetition","dataObject","evaluateDataRepetition","rules","evaluateUserDefinedObjects","dataViewObjects","objectDefns_1","createStaticEvalContext","objectDesc","propertyDesc","ruleDesc","createRuleEvaluationInstance","ruleType","ruleOutput","output","selectorToCreate","findSelectorForRuleInput","createRuleEvaluationInstanceFillRule","tryCreateColorAllocatorForFillRule","inputRole","ColorRuleEvaluation","fillRuleProperties","identifier","identifierKind","createColorAllocatorLinearGradient2","createColorAllocatorLinearGradient3","propertyValueFillRule","inputRange","findRuleInputColumnNumberRange","splitScales","midValue","cache","createColorAllocatorCache","staticEvalContext","objectDefnProperties","fillProperty","kind","fillRuleExpr","inputExprQueryName","findFirstQueryNameForExpr","fillRulePropertyDescriptor","register","evaluateDataRepetitionCategoricalCategory","evaluateDataRepetitionCategoricalValueGrouping","rewrittenMatrix","evaluateDataRepetitionMatrix","dataViewTable","rewrittenSelector","rewriteTableRoleSelector","rewrittenTable","evaluateDataRepetitionTable","findSelectorForRoleWildcard","resultingSelector","dataSelector","selectorRoles","allColumnsBelongToSelectorRole","allColumnsBelongToRole","fromExprs","isUniqueDataSelector","dataSelectors","newSelector","columns_6","selectorRole","findSelectedCategoricalColumn","foundMatch","createCategoricalEvalContext","setCurrentRowIndex","dataViewCategoricalValues","selectorMetadata","valueSource","valueSourceOverwrite","setGrouped","createMatrixEvalContext","rewrittenRows","evaluateDataRepetitionMatrixHierarchy","rewrittenCols","dataViewMatrixHierarchy","rewrittenRoot","evaluateDataRepetitionMatrixNode","dataViewNode","childNodes","rewrittenNode","shouldSearchChildren","childNode","rewrittenChildNode","inheritNodeAndChildren","getPrototypeOf","createTableEvalContext","evaluateDataRepetitionTableRows","findIndex","col","inheritedRows","colLen","rowLen","inheritedRow","objectsForColumns","metadataId","categoricalColumn","selectedMetadataId","isSelectRef","expressionName","columnExpr","valueColRoles","aggregates","minLocal","maxLocal","valueIdentityFields","groupedResult","groupValues","currentGroup","determineCategoricalTransformation","some","vg","roleMappingCategorical","hasRolesGrouped","categoriesMapping","hasCategoryRole","hasRolesBind","hasRolesFor","rowLevels","rowRoles","roleMappingMatrix","createDisplayNameGetter","displayNameKey","resourceProvider","getDisplayName","displayNameGetter","fieldExpr","sqExpr","FieldExprPattern","visit","FieldExprToSQExprVisitor","fromColumnAggr","columnAggr","aggregate","fromColumn","columnRef","fromEntity","entityPattern","entity","entityVar","fromEntityAggr","entityAggr","fromHierarchyLevelAggr","hierarchyLevelAggr","fromHierarchyLevel","hierarchyLevelPattern","fromHierarchy","hierarchyPattern","visitColumn","visitColumnAggr","visitColumnHierarchyLevelVariation","columnHierarchyLevelVariationPattern","propertyVariationSource","visitEntityAggr","visitHierarchyLevelAggr","visitMeasure","measure","measureRef","percentile","exclusive","visitPercentOfGrandTotal","percentOfGrandTotal","baseSQExpr","baseExpr","arithmetic","scopedEval","selectRef","SQExprConverter","asFieldPattern","FieldExprPatternBuilder","sourceRef","SourceExprPatternBuilder","ref","entityRef","variable","fieldPattern","argAggr","func","sourcePattern","hierarchyRef","hierarchySourceExprPattern","HierarchyExprPatternBuiler","variation","columnHierarchyLevelVariation","variationName","percentOfGrandTotalPattern","entityExpr","SQEntityExpr","variationRef","exprPattern","fieldExprPattern","toColumnRefSQExpr","columnPattern","getAggregate","FieldExprPatternAggregateVisitor","isAggregation","FieldExprPatternIsAggregationVisitor","hasFieldExprName","getPropertyName","FieldExprPropertyNameVisitor","getHierarchyName","getColumnRef","getFieldExprName","toFieldExprEntityPattern","getSchema","toFieldExprEntityItemPattern","FieldExprToEntityExprPatternBuilder","SQExprInfo","toEntityItemExprPattern","pattern","validateAndReshape","dataViewMappings_3","supports","reshapeCategorical","reshapeTree","reshapeSingle","reshapeTable","ScriptResultUtil","findScriptResult","categoryRoleMapping","supported","updated","maxRowCount","originalLength","updatedCategories","updatedColumn","supportsCategorical","singleRoleMapping","treeRoleMapping","validateRange","countGroups","depth","tableRoleMapping","countMeasures","usePreferredDataViewSchema","scriptResult","supportsScriptResult","supportsTree","supportsSingle","supportsTable","preferred","dataViewSingle","scriptResultRoleMapping","imageBase64","roleCondition","ignoreMin","DataViewMappingMatchErrorCode","conditionRangeTooSmall","conditionRangeTooLarge","validateKind","roleKindByQueryRef","expectedKind","roleCollection","roleProjections_1","Measure","conditionKindExpectedMeasure","conditionKindExpectedGrouping","GroupingOrMeasure","conditionKindExpectedGroupingOrMeasure","mappings","errors","mappingIndex","mappingCount","mappingConditions","requiredProperties","allPropertiesValid","areAllPropertiesValid","conditionsMet","conditionIndex","conditionCount","currentConditionErrors","checkForConditionErrors","currentConditionErrors_1","error","supportedMapping","updatedConditions","emptyToNull","mappingErrors","conditionRoles","isDrillable","roleCount","getPropertyCount","rangeError","code","kindError","requiredProperty","objectDescriptorValue","objectDescriptorProperty","objectDefinitionValue","useActiveIfAvailable","projectionsForRole","hasSameCategoryIdentity","dataView1","dataView2","dv1Categories","dv2Categories","dv1Identity","dv2Identity","dv1Length","getLengthOptional","areMetadataColumnsEquivalent","column1","column2","isMetadataEquivalent","metadata1","metadata2","previousColumnsLength","newColumnsLength","Lazy","fromRoles","DataViewRoleWildcardImpl","firstRoleWildcard","secondRoleWildcard","role1","role2","_this","_roles","_key","ignoreCase","filterFromIdentity","identities_1","orExprs","resultExpr","orExprs_1","orExpr","inExpr","getInExpr","or","not","fromSQExpr","createDataViewScopeIdentity","DataViewScopeIdentityImpl","_expr","SQExprShortSerializer","serialize","wildcard","instanceExprs","firstScopeWildcard","secondScopeWildcard","DataViewScopeWildcardImpl","_exprs","serializeArray","ColorAllocatorProvider","entry","allocator","applicableDataViewMappings","regressionDataViewMapping","usage","regression","regressionDataViews","visualDataViews_1","visualDataView","regressionDataView","linearRegressionTransform","sourceDataView","xColumns","getColumnsForCartesianRoleKind","yColumns","xColumnSource","yColumnSource","combineSeries","regressionUsage","combineSeriesPropertyId","dataPointsBySeries","getDataPointsBySeries","lineDefSet","calculateLineDefinitions","highlightsLineDefSet","xMin","xMax","shouldComputeHightlights","hasHighlightValues","highlightDataPointsBySeries","valuesByTrend","lineDefs","trend","computeLineYValues","highlightsByTrend","createRegressionDataView","dataPointsBySeries_1","dataPointSet","unsortedXValues","xValues","unsortedYValues","yValues","xDataType","getDataType","yDataType","sortedDataPointSet","sortValues","minCategoryValue","maxCategoryValue","lineDef","computeRegressionLine","roleKind","getColumnsWithRoleKind","_loop_1","cartesianKind","state_1","firstNonNull","dataType","zippedValues","zip","valuePair","unzip","xBar","sum","yBar","ssXX","pow","ssXY","slope","intercept","x1","x2","getValuesFromColumn","preferHighlights","xValueArray","seriesYValues","multipleXValueColumns","yRole","seriesRole","xRole","categoricalRoles","seriesRoles","valuesBySeries","withCategory","regressionXQueryName","regressionSeriesQueryName","regressionYQueryName","selects_1","qp","activeItem","colorAllocatorProvider","CategoricalEvalContext","findRuleInputColumn","findRuleInputInColumns","columns_7","columnsByRole","getRoleValue","TableEvalContext","getExprValueFromTable","forEachLeafNode","rootNodes","isNodeArray","rootNodes_1","rootNode","forEachLeafNodeRecursive","nodeOrNodeArray","isArrayOrInheritedArray","matrixNode","nextIndex","treePath","children_1","nextChild","pop","deepestLevelToInherit","useInheritSingle","returnNode","isRootNode","shouldInheritCurrentNode","inheritFunc","shouldInheritChildNodes","matrixOrHierarchy","hasCompositeGroup","isMatrix","hierarchyLevels","hierarchyLevels_1","isMeasureHeadersLevel","isForRole","metadataColumn","targetRole","columnSources","jointResult","projectionOrderSelectIndices","selectIndexToProjectionIndexMap","selectIndex","jointColumnInfo","ConceptualSchema","entityName","entities","withName","findHierarchy","hierarchies","findHierarchyByVariation","variationEntityName","variationColumnName","hierarchyName","variationEntity","variationProperty","variationColumn","variations","targetEntity","navigationProperty","findPropertyWithKpi","kpiProperty","prop","status","goal","ConceptualDataCategory","extractScriptResult","script","provider","extractScriptResultFromVisualConfig","scriptSource","getScriptInput","scriptInput","VariableName","Columns","scriptInputColumnNames","scriptInputColumns","scriptInputColumn","QueryName","Name","ScriptInputColumnNameVisitor","ensureUniqueNames","federatedSchema","getNameForProperty","getVariationLevelName","getNameForHierarchy","federatedScheam","variations_1","defaultHierarchy","segmentation","DataViewMerger","mergeDataViews","segment","mergeTables","mergeCategorical","mergeTreeNodes","mergeIndex","lastMergeIndex","merge","segmentCategoriesLength","segmentCategory","sourceCategory","segmentValuesLength","segmentValue","sourceValue","sourceRoot","segmentRoot","allowDifferentStructure","firstAppendIndex","findFirstAppendIndex","lastSourceChild","mergedChildren","childSegment","isMerge","SQExprRewriter","origArg","rewrittenArg","SQColumnRefExpr","SQMeasureRefExpr","SQAggregationExpr","SQPercentileExpr","SQHierarchyExpr","SQHierarchyLevelExpr","SQPropertyVariationSourceExpr","orig","origLeft","rewrittenLeft","origRight","rewrittenRight","SQAndExpr","origLower","rewrittenLower","origUpper","rewrittenUpper","SQBetweenExpr","rewrittenValues","origArgs","rewrittenArgs","rewriteAll","origValues","origValueTuple","rewrittenValueTuple","SQInExpr","origExprs","rewrittenResult","origExpr","rewrittenExpr","SQOrExpr","SQCompareExpr","comparison","SQContainsExpr","SQExistsExpr","SQNotExpr","SQStartsWithExpr","SQDateSpanExpr","SQDateAddExpr","amount","SQArithmeticExpr","operator","origExpression","rewrittenExpression","origScope","rewrittenScope","SQScopedEvalExpr","origInput","rewrittenInput","origRule","origGradient2","rewrittenGradient2","origGradient3","rewrittenGradient3","rewrittenRule","SQFillRuleExpr","origMin","rewrittenMin","origMax","rewrittenMax","origMid","rewrittenMid","origColor","rewrittenColor","origValue","rewrittenValue","rewrittenStop","EqualsToInRewriter","Rewriter","Equal","visitUnsupported","isSupported","leftIsComparand","isComparand","rightIsComparand","operand","current","InBuilder","complete","cancel","SQConstantExpr","cancelled","asScopeIdsContainer","fieldSQExprs","filterItems","filterItem","FilterScopeIdsCollectorVisitor","getResult","getFirstComparandValue","comparandExpr","FindComparandVisitor","isRoot","keyExprsCount","valueExprs","fieldExprs","fieldSQExprs_1","field","removeEntityVariables","scopeIds","startIndex","endIndex","scopeId","getScopeIdentity","isInArray","compoundSQExpr","equalsExpr","equal","unsupportedSQExpr","values_1","valueTuple_1","fixedExpr","extractor","ScopeIdExtractorImpl","malformed","keyValues","PrimitiveValueEncoding","decimal","double","getTimezoneOffset","dateTimeString","toISOString","endsWith","substr","replace","SingleQuoteRegex","nullEncoding","boolean","createSQAggregationOperations","datetimeMinMaxSupported","SQAggregationOperations","getMetadataForUnderlyingType","removeAggregate","getMetadata","Agg","getSupportedAggregates","targetTypes","fieldKind","isPropertyIdentity","idOnEntityKey","aggregates_1","Sum","Avg","Min","Max","CountNonNull","StandardDeviation","Variance","fieldExprItem","currentSchema","capabilities","supportsMedian","Median","distinctCountAggExists","isSupportedAggregate","supportedAggregates","createExprWithAggregate","aggregateNonNumericFields","preferredAggregate","getDefaultAggregate","SQHierarchyExprUtils","getConceptualHierarchyLevelFromExpr","conceptualSchema","getConceptualHierarchyLevel","schemaName","conceptualHierarchy","getConceptualHierarchy","variationExpr","sourceEntityExpr","expandExpr","suppressHierarchyLevelExpansion","SQExprHierarchyToHierarchyLevelConverter","convert","SQExprVariationConverter","expand","SQExprHierarchyLevelConverter","isHierarchyOrVariation","conceptualProperty","getConceptualProperty","getSourceVariationExpr","hierarchyLevelExpr","getSourceHierarchy","getHierarchySourceAsVariationSource","areHierarchyLevelsOrdered","allLevels","firstExpr","secondExpr","firstLevel","secondLevel","firstIndex","indexOfExpr","secondIndex","getInsertionIndex","orderedSubsetOfLevels","insertIndex","hierarchyExpr","hierarchyLevels_2","SQExprGroupUtils","groupExprs","addChildToGroup","selectQueryIndex","shouldAddExpressionToNewGroup","exprSource","lastGroup","expandedExpr","allHierarchyLevels","defaultAggregateForDataType","defaultAggregateToQueryAggregateFunction","_kind","SQExprEqualityVisitor","validate","aggrUtils","validator","SQExprValidationVisitor","isColumn","isConstant","isEntity","isHierarchy","isHierarchyLevel","isResourcePackageItem","getMetadataForProperty","getMetadataForHierarchyLevel","getMetadataForVariation","getMetadataForPercentOfGrandTotal","getMetadataForEntity","forceAggregation","getHierarchyLevelConceptualProperty","propertyDefaultAggregate","defaultAggregate","getKeyColumns","columnRefExpr","SQExprColumnRefInfoVisitor","getColumnRefSQExpr","keySQExprs","getPropertyKeys","hasGroupOnKeys","keySqExpr","getTargetEntityForVariation","variations_2","getTargetEntity","SQEntityExprInfoVisitor","getEntityExpr","fieldExprHierachyLevel","fieldExprEntity","sourceProperty","getPropertyMetadata","columnAggregate","SQPropRefExpr","argMetadata","SQSelectRefExpr","valueEncoded","SQNowExpr","SQDefaultValueExpr","SQAnyValueExpr","SQResourcePackageItemExpr","packageName","packageType","itemName","between","inExpr_1","tryUseInExprs","leftArgLen","rightArgLen","combinedValues","compare","exists","startsWith","nullConstant","now","anyValue","dateAdd","dateSpan","Decimal","typedConstant","isBoolean","isString","setAggregate","FieldExprChangeAggregateRewriter","FieldExprRemoveAggregateRewriter","setPercentOfGrandTotal","SQExprSetPercentOfGrandTotalRewriter","removePercentOfGrandTotal","SQExprRemovePercentOfGrandTotalRewriter","SQExprRemoveEntityVariablesRewriter","resourcePackageItem","SQExprAggregateInfoVisitor","ignoreCaseInstance","comparand","equalsAll","compareValues","optionalEqual","equalIgnoreCase","leftRule","rightRule","leftLinearGradient2","rightLinearGradient2","leftLinearGradient3","rightLinearGradient3","left2","right2","equalsFillRuleStop","left3","right3","stop1","stop2","SQExprRootRewriter","values_2","validateCompatibleType","compareExpr","validateEntity","isQueryable","aggregateExpr","validateHierarchy","hierarchyLevelFieldExprItem","validateHierarchyLevel","validateOperandsAndTypeForStartOrContains","validateArithmeticTypes","supportsArithmetic","leftMetadata","leftType","rightMetadata","rightType","levelName","hierarchyLevelConceptualProperty","queryable","sourceExpr","targetEntityExpr","schemaHierarchy","hierarchyLevelRef","getEntity","SQExprChangeAggregateRewriter","rewriter","defaultRewrite","SQExprRemoveAggregateRewriter","searchElement","uniqueName","namedItems","exprDefaultName","findUniqueName","defaultName","fallback","SQExprDefaultNameGenerator","IsMeasureVisitor","isAnyValue","IsAnyValueVisitor","isDefaultValue","IsDefaultValueVisitor","discourageAggregation","getSchemaCapabilities","discourageQueryAggregateUsage","getAggregateBehavior","getConceptualColumn","aggregateBehavior","getKpiMetadata","kpiStatusProperty","getKpiStatusProperty","kpiValue","statusMetadata","kpiTrendProperty","getKpiTrendProperty","trendMetadata","getConceptualEntity","conceptualEntity","getDefaultValue","fieldSQExpr","sqField","hierarchyLevelField","getDefaultValues","fieldSQExprs_2","getDataViewScopeIdentityComparisonExpr","fieldsExpr","compareExprs","compareExprs_1","getActiveTablesNames","queryDefn","tables","selectedItems","entityObj","isRelatedToMany","targetExpr","isRelated","isRelatedToOne","sourceMultiplicity","targetMultiplicity","navigationProperties","target","queue","shift","navProperties","navProperties_1","navProperty","isActive","isRelatedOneToOne","sourceNavigations","targetNavigations","hasOneToOneNavigation","navigationProperties_1","concatUnique","leftExprs","rightExprs","concatExprs","rightExprs_1","SemanticQueryRewriter","exprRewriter","rewriteFrom","fromValue","fromContents","originalFrom","originalFromKeys","keyName","originalEntityRef","originalEntityExpr","updatedEntityExpr","SQFrom","rewriteSelect","selectItems","rewriteNamedSQExpressions","rewriteGroupBy","groupByitems","expressions","SQExprRewriterWithSourceRenames","rewriteOrderBy","orderByItems","orderBy","updatedExpr","direction","rewriteWhere","whereItems","where","originalWhere","updatedWhere","SemanticQuery","groupBy","groupByItems","empty","createWithTrimmedFrom","unreferencedKeyFinder","UnreferencedKeyFinder","filterTarget","unreferencedKeys","remove","getSelect","setSelect","createNamedExpressionArray","extendWithName","rewriteExpressionsWithSourceRenames","removeSelect","originalItems","originalExpr","removeOrderBy","sorts","selectNameOf","setSelectAt","originalName","addSelect","exprName","createNamedExpr","currentNames","getGroupBy","setGroupBy","addGroupBy","getOrderBy","setOrderBy","clause","updatedOrderBy","getWhere","setWhere","updatedFilter","updatedTarget","addWhere","incomingWhere","updatedClause","contract","rewrittenContract","getDefaultValueFilter","getDataViewScopeIdentityComparisonFilters","getAnyValueFilter","filters","firstFilter","applyFilter","isDefaultFilter","isAnyFilter","leftFilter","rightFilter","filterWhereItems","filterWhereItem","updatedWhereItem","ensureEntity","desiredVariableName","i_1","candidateName","new","idx","substring","toLowerCase","extend","renames","updatedName","rewriteFilter","updatedTargets","rewriteArray","updatedCondition","updatedExprs","QuerySourceRenameDetector","detector","existingEntity","actualEntity","CategoricalDataViewBuilder","pushIfNotExists","itemToAdd","applySeriesData","staticMeasureColumns","dynamicMeasureColumns","withValues","columns_8","staticSeriesValues","dynamicSeriesMetadata","valueColumns_1","dynamicSeriesValues","fillData","dataViewValues","first","seriesMeasures","measureIndex","measuresLen","hasStaticSeries","staticColumnsStartingIndex","metadataColumns","categoryMetadata","categoryMetadata_1","seriesValues","seriesValue","seriesIdentity","dynamicSeriesGroups_1","appendStaticMeasureColumns","isLegalDataView","isVisualDataView","StaticEvalContext","cols","findSelectIndex","findAggregateValue","aggregateValue","findAggregates","getOptional","value1","powerbi_1","FormattingEncoder","RegExpExtensions","preserveEscaped","specialChars","oldText","newText","String","fromCharCode","replaceAll","restoreEscaped","preserveLiterals","literals","fromIndex","toIndex","literal","token","restoreLiterals","DateTimeFormat","IndexedTokensRegex","ZeroPlaceholder","DigitPlaceholder","ExponentialFormatChar","NumericPlaceholders","NumericPlaceholderRegex","RegExp","join","FormattingService","culture","gculture","getCulture","canFormat","formatWithIndexedTokens","match","argToken","parts","argIndex","argFormat","nonScientificOverrideFormat","formatWithCustomOverride","_dateTimeScaleFormatInfo","initialize","setCurrentCulture","cultureSelector","_currentCultureSelector","_currentCulture","DateTimeScaleFormatInfo","Globalize","findClosestCulture","cultureName","getCurrentCulture","calendarName","getUrlParam","calendars","calendar","urlParam","common","cultureInfo","navigator","userLanguage","param","location","search","isStandard","formatDateStandard","formatDateCustom","patterns","ensurePatterns","findDateFormat","processCustomDateTimeFormat","localize","_currentCachedFormat","_currentCachedProcessedFormat","fixDateTimeFormat","dictionary","timeSeparator","char","charAt","getNonScientificFormatWithPrecision","baseFormat","newFormat","hasFormatComponents","getComponents","positive","negative","zero","getNumericFormatFromComponent","NumericFormatRegex","formats","addDecimalsToFormatComponent","NumberFormatComponentsDelimeter","placeholder","decimalPlaceholders","repeat","DecimalFormatRegex","beforeDecimal","formatDecimal","afterDecimal","decimalChange","DecimalFormatCharacter","LastNumericPlaceholderRegex","signFormat","hasNegative","signSpecificFormats","formatCount","StandardFormatRegex","formatNumberStandard","formatNumberCustom","numberFormatInfo","numberFormat","formatChar","mantissaDecimalDigits","toFixed","toPrecision","toExponential","actualPrecision","isNegative","paddingZerosCount","paddingZeros","isFinite","formatComponents","formatMeta","hasEscapes","hasQuotes","hasE","scientificMatch","ScientificFormatRegex","formatM","formatE","getCustomFormatPrecision","scale","getCustomFormatScale","indexOfE","mantissa","resultM","fuseNumberWithCustomFormat","resultE","valueFormatted","isValueGlobalized","parseFloat","toNonScientific","_lastCustomFormatMeta","precisionZeros","digitsBeforeDecimalPoint","maxPrecision","indexOfDot","powerZeros","calculatePrecision","calculateScale","hasCommas","hasDots","hasPercent","hasPermile","length_1","dotIndex","suppressModifyValue","formatParts","wholeFormat","fractionFormat","NumericalPlaceHolderRegex","globalizedDecimalSeparator","decimalSeparator","valueParts","wholeValue","fractionValue","TrailingZerosRegex","wholeFormattedValue","fuseNumberWithCustomFormatLeft","fractionFormattedValue","fuseNumberWithCustomFormatRight","fmtOnly","groupSymbolIndex","enableGroups","groupDigitCount","groupSizes","groupSize","groupSeparator","sign","firstChar","isZero","leftBuffer","vi","fi","fCount","vCount","lastChar","plus","minus","dot","comma","monthAbbreviations","cultureHasMonthAbbr","yearMonthPattern","monthDayPattern","fullPattern","longTimePattern","shortTimePattern","separator","hasYearSymbol","YearPattern","yearPos","monthPos","MonthPattern","DayPattern","minutePos","pmPos","shortHourPattern","HourPattern","MinutePattern","SecondPattern","MillisecondPattern","SQExprSerializer","str","agg","f","n","comp","const","o","SelectionId","highlight","keyWithoutHighlight","includes","ignoreHighlight","thisSelector","otherSelector","thisData","otherData","thisValue","otherValue","getKeyWithoutHighlight","hasIdentity","getSelector","getSelectorsByColumn","selectorsByColumn","createNull","createWithId","createWithMeasure","measureId","selectionId","createWithIdAndMeasure","createWithIdAndMeasureAndCategory","dataMap","createWithIds","id1","id2","idArray","createWithIdsAndMeasure","createWithSelectorForColumnAndMeasure","createWithHighlight","newId","data_4","SelectionIdBuilder","builder","ensureDataMap","withSeries","withMeasure","createSelectionId"],"mappings":"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","file":"VisualsData.min.js","sourcesContent":["var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n///<reference path=\"../../Typedefs/jquery/jquery.d.ts\"/>\n///<reference path=\"../../Typedefs/globalize/globalize.d.ts\"/>\n///<reference path=\"../../Typedefs/lodash/lodash.d.ts\"/>\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\n        var DefaultSQExprVisitorWithArg = (function () {\n            function DefaultSQExprVisitorWithArg() {\n            }\n            DefaultSQExprVisitorWithArg.prototype.visitEntity = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitColumnRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitMeasureRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAggr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPercentile = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchy = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchyLevel = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPropertyVariationSource = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitSelectRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitBetween = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitIn = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitOr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitCompare = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitContains = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitExists = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNot = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitStartsWith = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitConstant = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateSpan = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateAdd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNow = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefaultValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnyValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitArithmetic = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitFillRule = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitResourcePackageItem = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitScopedEval = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefault = function (expr, arg) {\n                return;\n            };\n            return DefaultSQExprVisitorWithArg;\n        }());\n        data.DefaultSQExprVisitorWithArg = DefaultSQExprVisitorWithArg;\n        /** Default ISQExprVisitor implementation that others may derive from. */\n        var DefaultSQExprVisitor = (function (_super) {\n            __extends(DefaultSQExprVisitor, _super);\n            function DefaultSQExprVisitor() {\n                _super.apply(this, arguments);\n            }\n            return DefaultSQExprVisitor;\n        }(DefaultSQExprVisitorWithArg));\n        data.DefaultSQExprVisitor = DefaultSQExprVisitor;\n        /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\n        var DefaultSQExprVisitorWithTraversal = (function () {\n            function DefaultSQExprVisitorWithTraversal() {\n            }\n            DefaultSQExprVisitorWithTraversal.prototype.visitEntity = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitColumnRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitMeasureRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAggr = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPercentile = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchy = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchyLevel = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPropertyVariationSource = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitSelectRef = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitBetween = function (expr) {\n                expr.arg.accept(this);\n                expr.lower.accept(this);\n                expr.upper.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitIn = function (expr) {\n                var args = expr.args;\n                for (var i = 0, len = args.length; i < len; i++)\n                    args[i].accept(this);\n                var values = expr.values;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var valueTuple = values[i];\n                    for (var j = 0, jlen = valueTuple.length; j < jlen; j++)\n                        valueTuple[j].accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnd = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitOr = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitCompare = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitContains = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitExists = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNot = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitStartsWith = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitConstant = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateSpan = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateAdd = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNow = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefaultValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnyValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitArithmetic = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRule = function (expr) {\n                expr.input.accept(this);\n                var rule = expr.rule, gradient2 = rule.linearGradient2, gradient3 = rule.linearGradient3;\n                if (gradient2) {\n                    this.visitLinearGradient2(gradient2);\n                }\n                if (gradient3) {\n                    this.visitLinearGradient3(gradient3);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient2 = function (gradient2) {\n                debug.assertValue(gradient2, 'gradient2');\n                this.visitFillRuleStop(gradient2.min);\n                this.visitFillRuleStop(gradient2.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient3 = function (gradient3) {\n                debug.assertValue(gradient3, 'gradient3');\n                this.visitFillRuleStop(gradient3.min);\n                this.visitFillRuleStop(gradient3.mid);\n                this.visitFillRuleStop(gradient3.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitResourcePackageItem = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitScopedEval = function (expr) {\n                expr.expression.accept(this);\n                for (var _i = 0, _a = expr.scope; _i < _a.length; _i++) {\n                    var scopeExpr = _a[_i];\n                    scopeExpr.accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefault = function (expr) {\n                return;\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                stop.color.accept(this);\n                var value = stop.value;\n                if (value)\n                    value.accept(this);\n            };\n            return DefaultSQExprVisitorWithTraversal;\n        }());\n        data.DefaultSQExprVisitorWithTraversal = DefaultSQExprVisitorWithTraversal;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    function createEnumType(members) {\n        return new EnumType(members);\n    }\n    powerbi.createEnumType = createEnumType;\n    var EnumType = (function () {\n        function EnumType(allMembers) {\n            debug.assertValue(allMembers, 'allMembers');\n            this.allMembers = allMembers;\n        }\n        EnumType.prototype.members = function (validMembers) {\n            var allMembers = this.allMembers;\n            if (!validMembers)\n                return allMembers;\n            var membersToReturn = [];\n            for (var _i = 0, allMembers_1 = allMembers; _i < allMembers_1.length; _i++) {\n                var member = allMembers_1[_i];\n                if (_.contains(validMembers, member.value))\n                    membersToReturn.push(member);\n            }\n            return membersToReturn;\n        };\n        return EnumType;\n    }());\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var FillSolidColorTypeDescriptor;\n    (function (FillSolidColorTypeDescriptor) {\n        /** Gets a value indicating whether the descriptor is nullable or not. */\n        function nullable(descriptor) {\n            debug.assertValue(descriptor, 'descriptor');\n            if (descriptor === true)\n                return false;\n            var advancedDescriptor = descriptor;\n            return !!advancedDescriptor.nullable;\n        }\n        FillSolidColorTypeDescriptor.nullable = nullable;\n    })(FillSolidColorTypeDescriptor = powerbi.FillSolidColorTypeDescriptor || (powerbi.FillSolidColorTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var ImageDefinition;\n    (function (ImageDefinition) {\n        ImageDefinition.urlType = { misc: { imageUrl: true } };\n    })(ImageDefinition = powerbi.ImageDefinition || (powerbi.ImageDefinition = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StructuralTypeDescriptor;\n    (function (StructuralTypeDescriptor) {\n        function isValid(type) {\n            debug.assertValue(type, 'type');\n            if (type.fill ||\n                type.fillRule ||\n                type.filter ||\n                type.expression ||\n                type.image ||\n                type.paragraphs) {\n                return true;\n            }\n            return false;\n        }\n        StructuralTypeDescriptor.isValid = isValid;\n    })(StructuralTypeDescriptor = powerbi.StructuralTypeDescriptor || (powerbi.StructuralTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var EnumExtensions = jsCommon.EnumExtensions;\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\n    var ValueType = (function () {\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\n        function ValueType(type, category, enumType) {\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\n            debug.assert(!!category || category === null, 'category');\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\n            this.underlyingType = type;\n            this.category = category;\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\n                this.temporalType = new TemporalType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\n                this.geographyType = new GeographyType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\n                this.miscType = new MiscellaneousType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\n                this.formattingType = new FormattingType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\n                this.enumType = enumType;\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\n                this.scriptingType = new ScriptType(type);\n            }\n        }\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\n        ValueType.fromDescriptor = function (descriptor) {\n            descriptor = descriptor || {};\n            // Simplified primitive types\n            if (descriptor.text)\n                return ValueType.fromExtendedType(ExtendedType.Text);\n            if (descriptor.integer)\n                return ValueType.fromExtendedType(ExtendedType.Integer);\n            if (descriptor.numeric)\n                return ValueType.fromExtendedType(ExtendedType.Double);\n            if (descriptor.bool)\n                return ValueType.fromExtendedType(ExtendedType.Boolean);\n            if (descriptor.dateTime)\n                return ValueType.fromExtendedType(ExtendedType.DateTime);\n            if (descriptor.duration)\n                return ValueType.fromExtendedType(ExtendedType.Duration);\n            if (descriptor.binary)\n                return ValueType.fromExtendedType(ExtendedType.Binary);\n            if (descriptor.none)\n                return ValueType.fromExtendedType(ExtendedType.None);\n            // Extended types\n            if (descriptor.scripting) {\n                if (descriptor.scripting.source)\n                    return ValueType.fromExtendedType(ExtendedType.ScriptSource);\n            }\n            if (descriptor.enumeration)\n                return ValueType.fromEnum(descriptor.enumeration);\n            if (descriptor.temporal) {\n                if (descriptor.temporal.year)\n                    return ValueType.fromExtendedType(ExtendedType.Year_Integer);\n                if (descriptor.temporal.month)\n                    return ValueType.fromExtendedType(ExtendedType.Month_Integer);\n            }\n            if (descriptor.geography) {\n                if (descriptor.geography.address)\n                    return ValueType.fromExtendedType(ExtendedType.Address);\n                if (descriptor.geography.city)\n                    return ValueType.fromExtendedType(ExtendedType.City);\n                if (descriptor.geography.continent)\n                    return ValueType.fromExtendedType(ExtendedType.Continent);\n                if (descriptor.geography.country)\n                    return ValueType.fromExtendedType(ExtendedType.Country);\n                if (descriptor.geography.county)\n                    return ValueType.fromExtendedType(ExtendedType.County);\n                if (descriptor.geography.region)\n                    return ValueType.fromExtendedType(ExtendedType.Region);\n                if (descriptor.geography.postalCode)\n                    return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\n                if (descriptor.geography.stateOrProvince)\n                    return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\n                if (descriptor.geography.place)\n                    return ValueType.fromExtendedType(ExtendedType.Place);\n                if (descriptor.geography.latitude)\n                    return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\n                if (descriptor.geography.longitude)\n                    return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\n            }\n            if (descriptor.misc) {\n                if (descriptor.misc.image)\n                    return ValueType.fromExtendedType(ExtendedType.Image);\n                if (descriptor.misc.imageUrl)\n                    return ValueType.fromExtendedType(ExtendedType.ImageUrl);\n                if (descriptor.misc.webUrl)\n                    return ValueType.fromExtendedType(ExtendedType.WebUrl);\n                if (descriptor.misc.barcode)\n                    return ValueType.fromExtendedType(ExtendedType.Barcode_Text);\n            }\n            if (descriptor.formatting) {\n                if (descriptor.formatting.color)\n                    return ValueType.fromExtendedType(ExtendedType.Color);\n                if (descriptor.formatting.formatString)\n                    return ValueType.fromExtendedType(ExtendedType.FormatString);\n                if (descriptor.formatting.alignment)\n                    return ValueType.fromExtendedType(ExtendedType.Alignment);\n                if (descriptor.formatting.labelDisplayUnits)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\n                if (descriptor.formatting.fontSize)\n                    return ValueType.fromExtendedType(ExtendedType.FontSize);\n                if (descriptor.formatting.labelDensity)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDensity);\n            }\n            if (descriptor.extendedType) {\n                return ValueType.fromExtendedType(descriptor.extendedType);\n            }\n            return ValueType.fromExtendedType(ExtendedType.Null);\n        };\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\n        ValueType.fromExtendedType = function (extendedType) {\n            extendedType = extendedType || ExtendedType.Null;\n            var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);\n            debug.assert(primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null, 'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\n        };\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\n        ValueType.fromPrimitiveTypeAndCategory = function (primitiveType, category) {\n            primitiveType = primitiveType || PrimitiveType.Null;\n            category = category || null;\n            var id = primitiveType.toString();\n            if (category)\n                id += '|' + category;\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\n        };\n        /** Creates a ValueType to describe the given IEnumType. */\n        ValueType.fromEnum = function (enumType) {\n            debug.assertValue(enumType, 'enumType');\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\n        };\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\n        ValueType.isCompatibleTo = function (type, otherTypes) {\n            debug.assertValue(type, 'type');\n            debug.assertValue(otherTypes, 'otherTypes');\n            var valueType = ValueType.fromDescriptor(type);\n            for (var _i = 0, otherTypes_1 = otherTypes; _i < otherTypes_1.length; _i++) {\n                var otherType = otherTypes_1[_i];\n                var otherValueType = ValueType.fromDescriptor(otherType);\n                if (otherValueType.isCompatibleFrom(valueType))\n                    return true;\n            }\n            return false;\n        };\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\n        ValueType.prototype.isCompatibleFrom = function (other) {\n            debug.assertValue(other, 'other');\n            var otherPrimitiveType = other.primitiveType;\n            if (this === other ||\n                this.primitiveType === otherPrimitiveType ||\n                otherPrimitiveType === PrimitiveType.Null)\n                return true;\n            return false;\n        };\n        /**\n         * Determines if the instance ValueType is equal to the 'other' ValueType\n         * @param {ValueType} other the other ValueType to check equality against\n         * @returns True if the instance ValueType is equal to the 'other' ValueType\n         */\n        ValueType.prototype.equals = function (other) {\n            return _.isEqual(this, other);\n        };\n        Object.defineProperty(ValueType.prototype, \"primitiveType\", {\n            /** Gets the exact primitive type of this ValueType. */\n            get: function () {\n                return getPrimitiveType(this.underlyingType);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"extendedType\", {\n            /** Gets the exact extended type of this ValueType. */\n            get: function () {\n                return this.underlyingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"categoryString\", {\n            /** Gets the data category string (if any) for this ValueType. */\n            get: function () {\n                return this.category;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"text\", {\n            // Simplified primitive types\n            /** Indicates whether the type represents text values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Text;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"numeric\", {\n            /** Indicates whether the type represents any numeric value. */\n            get: function () {\n                return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"integer\", {\n            /** Indicates whether the type represents integer numeric values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Integer;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"bool\", {\n            /** Indicates whether the type represents Boolean values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Boolean;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"dateTime\", {\n            /** Indicates whether the type represents any date/time values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.DateTime ||\n                    this.primitiveType === PrimitiveType.Date ||\n                    this.primitiveType === PrimitiveType.Time;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"duration\", {\n            /** Indicates whether the type represents duration values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Duration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"binary\", {\n            /** Indicates whether the type represents binary values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Binary;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"none\", {\n            /** Indicates whether the type represents none values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.None;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"temporal\", {\n            // Extended types\n            /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\n            get: function () {\n                return this.temporalType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"geography\", {\n            /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\n            get: function () {\n                return this.geographyType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"misc\", {\n            /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\n            get: function () {\n                return this.miscType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"formatting\", {\n            /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\n            get: function () {\n                return this.formattingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"enum\", {\n            /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\n            get: function () {\n                return this.enumType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"scripting\", {\n            get: function () {\n                return this.scriptingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ValueType.typeCache = {};\n        return ValueType;\n    }());\n    powerbi.ValueType = ValueType;\n    var ScriptType = (function () {\n        function ScriptType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(ScriptType.prototype, \"source\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return ScriptType;\n    }());\n    powerbi.ScriptType = ScriptType;\n    var TemporalType = (function () {\n        function TemporalType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(TemporalType.prototype, \"year\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TemporalType.prototype, \"month\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return TemporalType;\n    }());\n    powerbi.TemporalType = TemporalType;\n    var GeographyType = (function () {\n        function GeographyType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(GeographyType.prototype, \"address\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"city\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"continent\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"country\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"county\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"region\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"postalCode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"stateOrProvince\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"place\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"latitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"longitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return GeographyType;\n    }());\n    powerbi.GeographyType = GeographyType;\n    var MiscellaneousType = (function () {\n        function MiscellaneousType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(MiscellaneousType.prototype, \"image\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"imageUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"webUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"barcode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Barcode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return MiscellaneousType;\n    }());\n    powerbi.MiscellaneousType = MiscellaneousType;\n    var FormattingType = (function () {\n        function FormattingType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(FormattingType.prototype, \"color\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"formatString\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"alignment\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDisplayUnits\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"fontSize\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDensity\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return FormattingType;\n    }());\n    powerbi.FormattingType = FormattingType;\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\n    (function (PrimitiveType) {\n        PrimitiveType[PrimitiveType[\"Null\"] = 0] = \"Null\";\n        PrimitiveType[PrimitiveType[\"Text\"] = 1] = \"Text\";\n        PrimitiveType[PrimitiveType[\"Decimal\"] = 2] = \"Decimal\";\n        PrimitiveType[PrimitiveType[\"Double\"] = 3] = \"Double\";\n        PrimitiveType[PrimitiveType[\"Integer\"] = 4] = \"Integer\";\n        PrimitiveType[PrimitiveType[\"Boolean\"] = 5] = \"Boolean\";\n        PrimitiveType[PrimitiveType[\"Date\"] = 6] = \"Date\";\n        PrimitiveType[PrimitiveType[\"DateTime\"] = 7] = \"DateTime\";\n        PrimitiveType[PrimitiveType[\"DateTimeZone\"] = 8] = \"DateTimeZone\";\n        PrimitiveType[PrimitiveType[\"Time\"] = 9] = \"Time\";\n        PrimitiveType[PrimitiveType[\"Duration\"] = 10] = \"Duration\";\n        PrimitiveType[PrimitiveType[\"Binary\"] = 11] = \"Binary\";\n        PrimitiveType[PrimitiveType[\"None\"] = 12] = \"None\";\n    })(powerbi.PrimitiveType || (powerbi.PrimitiveType = {}));\n    var PrimitiveType = powerbi.PrimitiveType;\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\n    (function (ExtendedType) {\n        // Flags (1 << 8-15 range [0xFF00])\n        // Important: Enum members must be declared before they are used in TypeScript.\n        ExtendedType[ExtendedType[\"Numeric\"] = 256] = \"Numeric\";\n        ExtendedType[ExtendedType[\"Temporal\"] = 512] = \"Temporal\";\n        ExtendedType[ExtendedType[\"Geography\"] = 1024] = \"Geography\";\n        ExtendedType[ExtendedType[\"Miscellaneous\"] = 2048] = \"Miscellaneous\";\n        ExtendedType[ExtendedType[\"Formatting\"] = 4096] = \"Formatting\";\n        ExtendedType[ExtendedType[\"Scripting\"] = 8192] = \"Scripting\";\n        // Primitive types (0-255 range [0xFF] | flags)\n        // The member names and base values must match those in PrimitiveType.\n        ExtendedType[ExtendedType[\"Null\"] = 0] = \"Null\";\n        ExtendedType[ExtendedType[\"Text\"] = 1] = \"Text\";\n        ExtendedType[ExtendedType[\"Decimal\"] = 258] = \"Decimal\";\n        ExtendedType[ExtendedType[\"Double\"] = 259] = \"Double\";\n        ExtendedType[ExtendedType[\"Integer\"] = 260] = \"Integer\";\n        ExtendedType[ExtendedType[\"Boolean\"] = 5] = \"Boolean\";\n        ExtendedType[ExtendedType[\"Date\"] = 518] = \"Date\";\n        ExtendedType[ExtendedType[\"DateTime\"] = 519] = \"DateTime\";\n        ExtendedType[ExtendedType[\"DateTimeZone\"] = 520] = \"DateTimeZone\";\n        ExtendedType[ExtendedType[\"Time\"] = 521] = \"Time\";\n        ExtendedType[ExtendedType[\"Duration\"] = 10] = \"Duration\";\n        ExtendedType[ExtendedType[\"Binary\"] = 11] = \"Binary\";\n        ExtendedType[ExtendedType[\"None\"] = 12] = \"None\";\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\n        // Temporal\n        ExtendedType[ExtendedType[\"Year\"] = 66048] = \"Year\";\n        ExtendedType[ExtendedType[\"Year_Text\"] = 66049] = \"Year_Text\";\n        ExtendedType[ExtendedType[\"Year_Integer\"] = 66308] = \"Year_Integer\";\n        ExtendedType[ExtendedType[\"Year_Date\"] = 66054] = \"Year_Date\";\n        ExtendedType[ExtendedType[\"Year_DateTime\"] = 66055] = \"Year_DateTime\";\n        ExtendedType[ExtendedType[\"Month\"] = 131584] = \"Month\";\n        ExtendedType[ExtendedType[\"Month_Text\"] = 131585] = \"Month_Text\";\n        ExtendedType[ExtendedType[\"Month_Integer\"] = 131844] = \"Month_Integer\";\n        ExtendedType[ExtendedType[\"Month_Date\"] = 131590] = \"Month_Date\";\n        ExtendedType[ExtendedType[\"Month_DateTime\"] = 131591] = \"Month_DateTime\";\n        // Geography\n        ExtendedType[ExtendedType[\"Address\"] = 6554625] = \"Address\";\n        ExtendedType[ExtendedType[\"City\"] = 6620161] = \"City\";\n        ExtendedType[ExtendedType[\"Continent\"] = 6685697] = \"Continent\";\n        ExtendedType[ExtendedType[\"Country\"] = 6751233] = \"Country\";\n        ExtendedType[ExtendedType[\"County\"] = 6816769] = \"County\";\n        ExtendedType[ExtendedType[\"Region\"] = 6882305] = \"Region\";\n        ExtendedType[ExtendedType[\"PostalCode\"] = 6947840] = \"PostalCode\";\n        ExtendedType[ExtendedType[\"PostalCode_Text\"] = 6947841] = \"PostalCode_Text\";\n        ExtendedType[ExtendedType[\"PostalCode_Integer\"] = 6948100] = \"PostalCode_Integer\";\n        ExtendedType[ExtendedType[\"StateOrProvince\"] = 7013377] = \"StateOrProvince\";\n        ExtendedType[ExtendedType[\"Place\"] = 7078913] = \"Place\";\n        ExtendedType[ExtendedType[\"Latitude\"] = 7144448] = \"Latitude\";\n        ExtendedType[ExtendedType[\"Latitude_Decimal\"] = 7144706] = \"Latitude_Decimal\";\n        ExtendedType[ExtendedType[\"Latitude_Double\"] = 7144707] = \"Latitude_Double\";\n        ExtendedType[ExtendedType[\"Longitude\"] = 7209984] = \"Longitude\";\n        ExtendedType[ExtendedType[\"Longitude_Decimal\"] = 7210242] = \"Longitude_Decimal\";\n        ExtendedType[ExtendedType[\"Longitude_Double\"] = 7210243] = \"Longitude_Double\";\n        // Miscellaneous\n        ExtendedType[ExtendedType[\"Image\"] = 13109259] = \"Image\";\n        ExtendedType[ExtendedType[\"ImageUrl\"] = 13174785] = \"ImageUrl\";\n        ExtendedType[ExtendedType[\"WebUrl\"] = 13240321] = \"WebUrl\";\n        ExtendedType[ExtendedType[\"Barcode\"] = 13305856] = \"Barcode\";\n        ExtendedType[ExtendedType[\"Barcode_Text\"] = 13305857] = \"Barcode_Text\";\n        ExtendedType[ExtendedType[\"Barcode_Integer\"] = 13306116] = \"Barcode_Integer\";\n        // Formatting\n        ExtendedType[ExtendedType[\"Color\"] = 19664897] = \"Color\";\n        ExtendedType[ExtendedType[\"FormatString\"] = 19730433] = \"FormatString\";\n        ExtendedType[ExtendedType[\"Alignment\"] = 20058113] = \"Alignment\";\n        ExtendedType[ExtendedType[\"LabelDisplayUnits\"] = 20123649] = \"LabelDisplayUnits\";\n        ExtendedType[ExtendedType[\"FontSize\"] = 20189443] = \"FontSize\";\n        ExtendedType[ExtendedType[\"LabelDensity\"] = 20254979] = \"LabelDensity\";\n        // Enumeration\n        ExtendedType[ExtendedType[\"Enumeration\"] = 26214401] = \"Enumeration\";\n        // Scripting\n        ExtendedType[ExtendedType[\"ScriptSource\"] = 32776193] = \"ScriptSource\";\n    })(powerbi.ExtendedType || (powerbi.ExtendedType = {}));\n    var ExtendedType = powerbi.ExtendedType;\n    var PrimitiveTypeMask = 0xFF;\n    var PrimitiveTypeWithFlagsMask = 0xFFFF;\n    var PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\n    function getPrimitiveType(extendedType) {\n        return extendedType & PrimitiveTypeMask;\n    }\n    function isPrimitiveType(extendedType) {\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\n    }\n    function getCategoryFromExtendedType(extendedType) {\n        if (isPrimitiveType(extendedType))\n            return null;\n        var category = ExtendedType[extendedType];\n        if (category) {\n            // Check for ExtendedType declaration without a primitive type.\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\n            var delimIdx = category.lastIndexOf('_');\n            if (delimIdx > 0) {\n                var baseCategory = category.slice(0, delimIdx);\n                if (ExtendedType[baseCategory]) {\n                    debug.assert((ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask), 'Unexpected value for ExtendedType base member of ' + extendedType);\n                    category = baseCategory;\n                }\n            }\n        }\n        return category || null;\n    }\n    function toExtendedType(primitiveType, category) {\n        var primitiveString = PrimitiveType[primitiveType];\n        var t = ExtendedType[primitiveString];\n        if (t == null) {\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\n            t = ExtendedType.Null;\n        }\n        if (primitiveType && category) {\n            var categoryType = ExtendedType[category];\n            if (categoryType) {\n                var categoryPrimitiveType = getPrimitiveType(categoryType);\n                if (categoryPrimitiveType === PrimitiveType.Null) {\n                    // Category supports multiple primitive types, check if requested primitive type is supported\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\n                    categoryType = t | categoryType;\n                    if (ExtendedType[categoryType]) {\n                        debug.assert(ExtendedType[categoryType] === (category + '_' + primitiveString), 'Unexpected name for ExtendedType member ' + categoryType);\n                        t = categoryType;\n                    }\n                }\n                else if (categoryPrimitiveType === primitiveType) {\n                    // Primitive type matches the single supported type for the category\n                    t = categoryType;\n                }\n            }\n        }\n        return t;\n    }\n    function matchesExtendedTypeWithAnyPrimitive(a, b) {\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (DataShapeBindingLimitType) {\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Top\"] = 0] = \"Top\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"First\"] = 1] = \"First\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Last\"] = 2] = \"Last\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Sample\"] = 3] = \"Sample\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Bottom\"] = 4] = \"Bottom\";\n        })(data.DataShapeBindingLimitType || (data.DataShapeBindingLimitType = {}));\n        var DataShapeBindingLimitType = data.DataShapeBindingLimitType;\n        (function (SubtotalType) {\n            SubtotalType[SubtotalType[\"None\"] = 0] = \"None\";\n            SubtotalType[SubtotalType[\"Before\"] = 1] = \"Before\";\n            SubtotalType[SubtotalType[\"After\"] = 2] = \"After\";\n        })(data.SubtotalType || (data.SubtotalType = {}));\n        var SubtotalType = data.SubtotalType;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataShapeBindingDataReduction;\n        (function (DataShapeBindingDataReduction) {\n            function createFrom(reduction) {\n                if (!reduction)\n                    return;\n                var result;\n                if (reduction.top) {\n                    result = {\n                        Top: {}\n                    };\n                    if (reduction.top.count)\n                        result.Top.Count = reduction.top.count;\n                }\n                if (reduction.bottom) {\n                    result = {\n                        Bottom: {}\n                    };\n                    if (reduction.bottom.count)\n                        result.Bottom.Count = reduction.bottom.count;\n                }\n                if (reduction.sample) {\n                    result = {\n                        Sample: {}\n                    };\n                    if (reduction.sample.count)\n                        result.Sample.Count = reduction.sample.count;\n                }\n                if (reduction.window) {\n                    result = {\n                        Window: {}\n                    };\n                    if (reduction.window.count)\n                        result.Window.Count = reduction.window.count;\n                }\n                return result;\n            }\n            DataShapeBindingDataReduction.createFrom = createFrom;\n        })(DataShapeBindingDataReduction = data.DataShapeBindingDataReduction || (data.DataShapeBindingDataReduction = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Represents a federated conceptual schema. */\n        var FederatedConceptualSchema = (function () {\n            function FederatedConceptualSchema(options) {\n                debug.assertValue(options, 'options');\n                this.schemas = options.schemas;\n                if (options.links)\n                    this.links = options.links;\n            }\n            FederatedConceptualSchema.prototype.schema = function (name) {\n                return this.schemas[name];\n            };\n            return FederatedConceptualSchema;\n        }());\n        data.FederatedConceptualSchema = FederatedConceptualSchema;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data_1) {\n        var Selector;\n        (function (Selector) {\n            function filterFromSelector(selectors, isNot) {\n                if (_.isEmpty(selectors))\n                    return;\n                var exprs = [];\n                for (var i = 0, ilen = selectors.length; i < ilen; i++) {\n                    var identity = selectors[i];\n                    var data_2 = identity.data;\n                    var exprToAdd = undefined;\n                    if (data_2 && data_2.length) {\n                        for (var j = 0, jlen = data_2.length; j < jlen; j++) {\n                            exprToAdd = data_1.SQExprBuilder.and(exprToAdd, identity.data[j].expr);\n                        }\n                    }\n                    if (exprToAdd)\n                        exprs.push(exprToAdd);\n                }\n                if (!_.isEmpty(exprs))\n                    return powerbi.DataViewScopeIdentity.filterFromExprs(exprs, isNot);\n            }\n            Selector.filterFromSelector = filterFromSelector;\n            function matchesData(selector, identities) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(identities, 'identities');\n                var selectorData = selector.data;\n                if (selectorData.length !== identities.length)\n                    return false;\n                for (var i = 0, len = selectorData.length; i < len; i++) {\n                    var dataItem = selector.data[i];\n                    var selectorDataItem = dataItem;\n                    if (selectorDataItem.expr) {\n                        if (!powerbi.DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\n                            return false;\n                    }\n                    else {\n                        if (!data_1.DataViewScopeWildcard.matches(dataItem, identities[i]))\n                            return false;\n                    }\n                }\n                return true;\n            }\n            Selector.matchesData = matchesData;\n            function matchesKeys(selector, keysList) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(keysList, 'keysList');\n                var selectorData = selector.data, selectorDataLength = selectorData.length;\n                if (selectorDataLength !== keysList.length)\n                    return false;\n                for (var i = 0; i < selectorDataLength; i++) {\n                    var selectorDataItem = selector.data[i], selectorDataExprs = void 0;\n                    if (selectorDataItem.expr) {\n                        selectorDataExprs = data_1.ScopeIdentityExtractor.getKeys(selectorDataItem.expr);\n                    }\n                    else if (selectorDataItem.exprs) {\n                        selectorDataExprs = selectorDataItem.exprs;\n                    }\n                    else {\n                        // In case DataViewRoleWildcard\n                        return false;\n                    }\n                    if (!selectorDataExprs)\n                        continue;\n                    if (!data_1.SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\n                        return false;\n                }\n                return true;\n            }\n            Selector.matchesKeys = matchesKeys;\n            /** Determines whether two selectors are equal. */\n            function equals(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (x.id !== y.id)\n                    return false;\n                if (x.metadata !== y.metadata)\n                    return false;\n                if (!equalsDataArray(x.data, y.data))\n                    return false;\n                return true;\n            }\n            Selector.equals = equals;\n            function equalsDataArray(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                if (x.length !== y.length)\n                    return false;\n                for (var i = 0, len = x.length; i < len; i++) {\n                    if (!equalsData(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            function equalsData(x, y) {\n                var selector1 = x;\n                var selector2 = y;\n                if (selector1.expr && selector2.expr)\n                    return powerbi.DataViewScopeIdentity.equals(selector1, selector2);\n                if (selector1.exprs && selector2.exprs)\n                    return data_1.DataViewScopeWildcard.equals(selector1, selector2);\n                if (selector1.roles && selector2.roles)\n                    return data_1.DataViewRoleWildcard.equals(selector1, selector2);\n                return false;\n            }\n            function getKey(selector) {\n                var toStringify = {};\n                if (selector.data) {\n                    var data_3 = [];\n                    for (var i = 0, ilen = selector.data.length; i < ilen; i++) {\n                        data_3.push(selector.data[i].key);\n                    }\n                    toStringify.data = data_3;\n                }\n                if (selector.metadata)\n                    toStringify.metadata = selector.metadata;\n                if (selector.id)\n                    toStringify.id = selector.id;\n                return JSON.stringify(toStringify);\n            }\n            Selector.getKey = getKey;\n            function containsWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (!dataItems)\n                    return false;\n                for (var _i = 0, dataItems_1 = dataItems; _i < dataItems_1.length; _i++) {\n                    var dataItem = dataItems_1[_i];\n                    var wildCard = dataItem;\n                    if (wildCard.exprs || wildCard.roles)\n                        return true;\n                }\n                return false;\n            }\n            Selector.containsWildcard = containsWildcard;\n            function hasRoleWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (_.isEmpty(dataItems))\n                    return false;\n                for (var _i = 0, dataItems_2 = dataItems; _i < dataItems_2.length; _i++) {\n                    var dataItem = dataItems_2[_i];\n                    if (isRoleWildcard(dataItem))\n                        return true;\n                }\n                return false;\n            }\n            Selector.hasRoleWildcard = hasRoleWildcard;\n            function isRoleWildcard(dataItem) {\n                return !_.isEmpty(dataItem.roles);\n            }\n            Selector.isRoleWildcard = isRoleWildcard;\n        })(Selector = data_1.Selector || (data_1.Selector = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (EntitySourceType) {\n            EntitySourceType[EntitySourceType[\"Table\"] = 0] = \"Table\";\n            EntitySourceType[EntitySourceType[\"Pod\"] = 1] = \"Pod\";\n        })(data.EntitySourceType || (data.EntitySourceType = {}));\n        var EntitySourceType = data.EntitySourceType;\n        function getArithmeticOperatorName(arithmeticOperatorKind) {\n            switch (arithmeticOperatorKind) {\n                case 0 /* Add */:\n                    return \"Add\";\n                case 1 /* Subtract */:\n                    return \"Subtract\";\n                case 2 /* Multiply */:\n                    return \"Multiply\";\n                case 3 /* Divide */:\n                    return \"Divide\";\n            }\n            throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\n        }\n        data.getArithmeticOperatorName = getArithmeticOperatorName;\n        (function (TimeUnit) {\n            TimeUnit[TimeUnit[\"Day\"] = 0] = \"Day\";\n            TimeUnit[TimeUnit[\"Week\"] = 1] = \"Week\";\n            TimeUnit[TimeUnit[\"Month\"] = 2] = \"Month\";\n            TimeUnit[TimeUnit[\"Year\"] = 3] = \"Year\";\n            TimeUnit[TimeUnit[\"Decade\"] = 4] = \"Decade\";\n            TimeUnit[TimeUnit[\"Second\"] = 5] = \"Second\";\n            TimeUnit[TimeUnit[\"Minute\"] = 6] = \"Minute\";\n            TimeUnit[TimeUnit[\"Hour\"] = 7] = \"Hour\";\n        })(data.TimeUnit || (data.TimeUnit = {}));\n        var TimeUnit = data.TimeUnit;\n        (function (QueryAggregateFunction) {\n            QueryAggregateFunction[QueryAggregateFunction[\"Sum\"] = 0] = \"Sum\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Avg\"] = 1] = \"Avg\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Count\"] = 2] = \"Count\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Min\"] = 3] = \"Min\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Max\"] = 4] = \"Max\";\n            QueryAggregateFunction[QueryAggregateFunction[\"CountNonNull\"] = 5] = \"CountNonNull\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Median\"] = 6] = \"Median\";\n            QueryAggregateFunction[QueryAggregateFunction[\"StandardDeviation\"] = 7] = \"StandardDeviation\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Variance\"] = 8] = \"Variance\";\n        })(data.QueryAggregateFunction || (data.QueryAggregateFunction = {}));\n        var QueryAggregateFunction = data.QueryAggregateFunction;\n        (function (QueryComparisonKind) {\n            QueryComparisonKind[QueryComparisonKind[\"Equal\"] = 0] = \"Equal\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThan\"] = 1] = \"GreaterThan\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThanOrEqual\"] = 2] = \"GreaterThanOrEqual\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThan\"] = 3] = \"LessThan\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThanOrEqual\"] = 4] = \"LessThanOrEqual\";\n        })(data.QueryComparisonKind || (data.QueryComparisonKind = {}));\n        var QueryComparisonKind = data.QueryComparisonKind;\n        /** Defines semantic data types. */\n        (function (SemanticType) {\n            SemanticType[SemanticType[\"None\"] = 0] = \"None\";\n            SemanticType[SemanticType[\"Number\"] = 1] = \"Number\";\n            SemanticType[SemanticType[\"Integer\"] = 3] = \"Integer\";\n            SemanticType[SemanticType[\"DateTime\"] = 4] = \"DateTime\";\n            SemanticType[SemanticType[\"Time\"] = 8] = \"Time\";\n            SemanticType[SemanticType[\"Date\"] = 20] = \"Date\";\n            SemanticType[SemanticType[\"Month\"] = 35] = \"Month\";\n            SemanticType[SemanticType[\"Year\"] = 67] = \"Year\";\n            SemanticType[SemanticType[\"YearAndMonth\"] = 128] = \"YearAndMonth\";\n            SemanticType[SemanticType[\"MonthAndDay\"] = 256] = \"MonthAndDay\";\n            SemanticType[SemanticType[\"Decade\"] = 515] = \"Decade\";\n            SemanticType[SemanticType[\"YearAndWeek\"] = 1024] = \"YearAndWeek\";\n            SemanticType[SemanticType[\"String\"] = 2048] = \"String\";\n            SemanticType[SemanticType[\"Boolean\"] = 4096] = \"Boolean\";\n            SemanticType[SemanticType[\"Table\"] = 8192] = \"Table\";\n            SemanticType[SemanticType[\"Range\"] = 16384] = \"Range\";\n        })(data.SemanticType || (data.SemanticType = {}));\n        var SemanticType = data.SemanticType;\n        (function (FilterKind) {\n            FilterKind[FilterKind[\"Default\"] = 0] = \"Default\";\n            FilterKind[FilterKind[\"Period\"] = 1] = \"Period\";\n        })(data.FilterKind || (data.FilterKind = {}));\n        var FilterKind = data.FilterKind;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var QueryProjectionCollection = (function () {\n            function QueryProjectionCollection(items, activeProjectionRefs, showAll) {\n                debug.assertValue(items, 'items');\n                this.items = items;\n                this._activeProjectionRefs = activeProjectionRefs;\n                this._showAll = showAll;\n            }\n            /** Returns all projections in a mutable array. */\n            QueryProjectionCollection.prototype.all = function () {\n                return this.items;\n            };\n            Object.defineProperty(QueryProjectionCollection.prototype, \"activeProjectionRefs\", {\n                get: function () {\n                    return this._activeProjectionRefs;\n                },\n                set: function (queryReferences) {\n                    if (!_.isEmpty(queryReferences)) {\n                        var queryRefs = this.items.map(function (val) { return val.queryRef; });\n                        for (var _i = 0, queryReferences_1 = queryReferences; _i < queryReferences_1.length; _i++) {\n                            var queryReference = queryReferences_1[_i];\n                            if (!_.contains(queryRefs, queryReference))\n                                return;\n                        }\n                        this._activeProjectionRefs = queryReferences;\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(QueryProjectionCollection.prototype, \"showAll\", {\n                get: function () {\n                    return this._showAll;\n                },\n                set: function (value) {\n                    this._showAll = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            QueryProjectionCollection.prototype.addActiveQueryReference = function (queryRef) {\n                if (!this._activeProjectionRefs)\n                    this._activeProjectionRefs = [queryRef];\n                else\n                    this._activeProjectionRefs.push(queryRef);\n            };\n            QueryProjectionCollection.prototype.getLastActiveQueryReference = function () {\n                if (!_.isEmpty(this._activeProjectionRefs)) {\n                    return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\n                }\n            };\n            /** Replaces the given oldQueryRef with newQueryRef in this QueryProjectionCollection. */\n            QueryProjectionCollection.prototype.replaceQueryRef = function (oldQueryRef, newQueryRef) {\n                debug.assertValue(oldQueryRef, 'oldQueryRef');\n                debug.assertValue(newQueryRef, 'newQueryRef');\n                debug.assert(oldQueryRef !== newQueryRef, 'oldQueryRef !== newQueryRef');\n                debug.assert(_.isEmpty(this._activeProjectionRefs), 'replaceQueryRef(...) is not supported on the QueryProjectionCollection of a drillable role');\n                // Note: the same queryRef can get projected multiple times\n                for (var _i = 0, _a = this.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    if (item.queryRef === oldQueryRef) {\n                        item.queryRef = newQueryRef;\n                    }\n                }\n            };\n            QueryProjectionCollection.prototype.clone = function () {\n                return new QueryProjectionCollection(_.cloneDeep(this.items), _.clone(this._activeProjectionRefs), this._showAll);\n            };\n            return QueryProjectionCollection;\n        }());\n        data.QueryProjectionCollection = QueryProjectionCollection;\n        var QueryProjectionsByRole;\n        (function (QueryProjectionsByRole) {\n            /** Clones the QueryProjectionsByRole. */\n            function clone(roles) {\n                if (!roles)\n                    return roles;\n                var clonedRoles = {};\n                for (var roleName in roles)\n                    clonedRoles[roleName] = roles[roleName].clone();\n                return clonedRoles;\n            }\n            QueryProjectionsByRole.clone = clone;\n            /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\n            function getRole(roles, name) {\n                debug.assertAnyValue(roles, 'roles');\n                debug.assertValue(name, 'name');\n                if (!roles)\n                    return;\n                return roles[name];\n            }\n            QueryProjectionsByRole.getRole = getRole;\n        })(QueryProjectionsByRole = data.QueryProjectionsByRole || (data.QueryProjectionsByRole = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** The system used to determine display units used during formatting */\n    (function (DisplayUnitSystemType) {\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Default\"] = 0] = \"Default\";\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Verbose\"] = 1] = \"Verbose\";\n        /**\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\n         * Suitable for dashboard tile cards\n         */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"WholeUnits\"] = 2] = \"WholeUnits\";\n        /**A display unit system that also contains Auto and None units for data labels*/\n        DisplayUnitSystemType[DisplayUnitSystemType[\"DataLabels\"] = 3] = \"DataLabels\";\n    })(powerbi.DisplayUnitSystemType || (powerbi.DisplayUnitSystemType = {}));\n    var DisplayUnitSystemType = powerbi.DisplayUnitSystemType;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Repreasents the sequence of the dates/times */\n    var DateTimeSequence = (function () {\n        // Constructors\n        /** Creates new instance of the DateTimeSequence */\n        function DateTimeSequence(unit) {\n            this.unit = unit;\n            this.sequence = [];\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\n        }\n        // Methods\n        /**\n         * Add a new Date to a sequence.\n         * @param date - date to add\n         */\n        DateTimeSequence.prototype.add = function (date) {\n            if (date < this.min) {\n                this.min = date;\n            }\n            if (date > this.max) {\n                this.max = date;\n            }\n            this.sequence.push(date);\n        };\n        // Methods\n        /**\n         * Extends the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.extendToCover = function (min, max) {\n            var x = this.min;\n            while (min < x) {\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\n                this.sequence.splice(0, 0, x);\n            }\n            this.min = x;\n            x = this.max;\n            while (x < max) {\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\n                this.sequence.push(x);\n            }\n            this.max = x;\n        };\n        /**\n         * Move the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.moveToCover = function (min, max) {\n            var delta = DateTimeSequence.getDelta(min, max, this.unit);\n            var count = Math.floor(delta / this.interval);\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\n            this.sequence = [];\n            this.sequence.push(this.min);\n            this.max = this.min;\n            while (this.max < max) {\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\n                this.sequence.push(this.max);\n            }\n        };\n        // Static\n        /**\n         * Calculate a new DateTimeSequence\n         * @param dataMin - Date representing min of the data range\n         * @param dataMax - Date representing max of the data range\n         * @param expectedCount - expected number of intervals in the sequence\n         * @param unit - of the intervals in the sequence\n         */\n        DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {\n            if (!unit) {\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\n            }\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Month:\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Week:\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Day:\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Second:\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\n                default:\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\n            }\n        };\n        DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\n            // Calculate range and sequence\n            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\n            // Calculate year sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\n            var newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval;\n            var date = new Date(newMinYear, 0, 1);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Year);\n            return result;\n        };\n        DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var minYear = dataMin.getFullYear();\n            var maxYear = dataMax.getFullYear();\n            var minMonth = dataMin.getMonth();\n            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\n            var date = new Date(minYear, 0, 1);\n            // Calculate month sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Month);\n            return result;\n        };\n        DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            var firstDayOfWeek = 0;\n            var minDayOfWeek = dataMin.getDay();\n            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\n            var minDay = dataMin.getDate() - dayOffset;\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Week));\n            // Calculate week sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Week);\n            return result;\n        };\n        DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, powerbi.DateTimeUnit.Day));\n            // Calculate day sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Day);\n            return result;\n        };\n        DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Hour));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Hour));\n            // Calculate hour sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Hour);\n            return result;\n        };\n        DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Minute));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Minute));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Minute);\n            return result;\n        };\n        DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Second));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Second));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Second);\n            return result;\n        };\n        DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\n            var min = DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Millisecond);\n            var max = DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Millisecond);\n            // Calculate milliseconds numeric sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Millisecond);\n            return result;\n        };\n        DateTimeSequence.addInterval = function (value, interval, unit) {\n            interval = Math.round(interval);\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateUtils.addYears(value, interval);\n                case powerbi.DateTimeUnit.Month:\n                    return DateUtils.addMonths(value, interval);\n                case powerbi.DateTimeUnit.Week:\n                    return DateUtils.addWeeks(value, interval);\n                case powerbi.DateTimeUnit.Day:\n                    return DateUtils.addDays(value, interval);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateUtils.addHours(value, interval);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateUtils.addMinutes(value, interval);\n                case powerbi.DateTimeUnit.Second:\n                    return DateUtils.addSeconds(value, interval);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateUtils.addMilliseconds(value, interval);\n            }\n        };\n        DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {\n            var result = new DateTimeSequence(unit);\n            for (var i = 0; i < sequence.sequence.length; i++) {\n                var x = sequence.sequence[i];\n                var d = DateTimeSequence.addInterval(date, x, unit);\n                result.add(d);\n            }\n            result.interval = sequence.interval;\n            result.intervalOffset = sequence.intervalOffset;\n            return result;\n        };\n        DateTimeSequence.getDelta = function (min, max, unit) {\n            var delta = 0;\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    delta = max.getFullYear() - min.getFullYear();\n                    break;\n                case powerbi.DateTimeUnit.Month:\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\n                    break;\n                case powerbi.DateTimeUnit.Week:\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Day:\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Hour:\n                    delta = (max.getTime() - min.getTime()) / 3600000;\n                    break;\n                case powerbi.DateTimeUnit.Minute:\n                    delta = (max.getTime() - min.getTime()) / 60000;\n                    break;\n                case powerbi.DateTimeUnit.Second:\n                    delta = (max.getTime() - min.getTime()) / 1000;\n                    break;\n                case powerbi.DateTimeUnit.Millisecond:\n                    delta = max.getTime() - min.getTime();\n                    break;\n            }\n            return delta;\n        };\n        DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {\n            maxCount = Math.max(maxCount, 2);\n            var totalDays = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Day);\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\n                return powerbi.DateTimeUnit.Year;\n            if (totalDays > 60 && totalDays > 7 * maxCount)\n                return powerbi.DateTimeUnit.Month;\n            if (totalDays > 14 && totalDays > 2 * maxCount)\n                return powerbi.DateTimeUnit.Week;\n            var totalHours = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Hour);\n            if (totalDays > 2 && totalHours > 12 * maxCount)\n                return powerbi.DateTimeUnit.Day;\n            if (totalHours >= 24 && totalHours >= maxCount)\n                return powerbi.DateTimeUnit.Hour;\n            var totalMinutes = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Minute);\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\n                return powerbi.DateTimeUnit.Minute;\n            var totalSeconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Second);\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\n                return powerbi.DateTimeUnit.Second;\n            var totalMilliseconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Millisecond);\n            if (totalMilliseconds > 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\n            var date = min;\n            if (date.getMilliseconds() !== 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            if (date.getSeconds() !== 0)\n                return powerbi.DateTimeUnit.Second;\n            if (date.getMinutes() !== 0)\n                return powerbi.DateTimeUnit.Minute;\n            if (date.getHours() !== 0)\n                return powerbi.DateTimeUnit.Hour;\n            if (date.getDate() !== 1)\n                return powerbi.DateTimeUnit.Day;\n            if (date.getMonth() !== 0)\n                return powerbi.DateTimeUnit.Month;\n            return powerbi.DateTimeUnit.Year;\n        };\n        // Constants\n        DateTimeSequence.MIN_COUNT = 1;\n        DateTimeSequence.MAX_COUNT = 1000;\n        return DateTimeSequence;\n    }());\n    powerbi.DateTimeSequence = DateTimeSequence;\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\n    var DateUtils;\n    (function (DateUtils) {\n        var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        /**\n         * Returns bool indicating weither the provided year is a leap year.\n         * @param year - year value\n         */\n        function isLeap(year) {\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\n        }\n        /**\n         * Returns number of days in the provided year/month.\n         * @param year - year value\n         * @param month - month value\n         */\n        function getMonthDays(year, month) {\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\n        }\n        /**\n         * Adds a specified number of years to the provided date.\n         * @param date - date value\n         * @param yearDelta - number of years to add\n         */\n        function addYears(date, yearDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var isLeapDay = month === 2 && day === 29;\n            var result = new Date(date.getTime());\n            year = year + yearDelta;\n            if (isLeapDay && !isLeap(year)) {\n                day = 28;\n            }\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addYears = addYears;\n        /**\n         * Adds a specified number of months to the provided date.\n         * @param date - date value\n         * @param monthDelta - number of months to add\n         */\n        function addMonths(date, monthDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            year += (monthDelta - (monthDelta % 12)) / 12;\n            month += monthDelta % 12;\n            // VSTS 1325771: Certain column charts don't display any data\n            // Wrap arround the month if is after december (value 11)\n            if (month > 11) {\n                month = month % 12;\n                year++;\n            }\n            day = Math.min(day, getMonthDays(year, month));\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addMonths = addMonths;\n        /**\n         * Adds a specified number of weeks to the provided date.\n         * @param date - date value\n         * @param weeks - number of weeks to add\n         */\n        function addWeeks(date, weeks) {\n            return addDays(date, weeks * 7);\n        }\n        DateUtils.addWeeks = addWeeks;\n        /**\n         * Adds a specified number of days to the provided date.\n         * @param date - date value\n         * @param days - number of days to add\n         */\n        function addDays(date, days) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            result.setFullYear(year, month, day + days);\n            return result;\n        }\n        DateUtils.addDays = addDays;\n        /**\n         * Adds a specified number of hours to the provided date.\n         * @param date - date value\n         * @param hours - number of hours to add\n         */\n        function addHours(date, hours) {\n            return new Date(date.getTime() + hours * 3600000);\n        }\n        DateUtils.addHours = addHours;\n        /**\n         * Adds a specified number of minutes to the provided date.\n         * @param date - date value\n         * @param minutes - number of minutes to add\n         */\n        function addMinutes(date, minutes) {\n            return new Date(date.getTime() + minutes * 60000);\n        }\n        DateUtils.addMinutes = addMinutes;\n        /**\n         * Adds a specified number of seconds to the provided date.\n         * @param date - date value\n         * @param seconds - number of seconds to add\n         */\n        function addSeconds(date, seconds) {\n            return new Date(date.getTime() + seconds * 1000);\n        }\n        DateUtils.addSeconds = addSeconds;\n        /**\n         * Adds a specified number of milliseconds to the provided date.\n         * @param date - date value\n         * @param milliseconds - number of milliseconds to add\n         */\n        function addMilliseconds(date, milliseconds) {\n            return new Date(date.getTime() + milliseconds);\n        }\n        DateUtils.addMilliseconds = addMilliseconds;\n    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    // Constants\n    var maxExponent = 24;\n    var defaultScientificBigNumbersBoundary = 1E15;\n    var scientificSmallNumbersBoundary = 1E-4;\n    var PERCENTAGE_FORMAT = '%';\n    var SCIENTIFIC_FORMAT = 'E+0';\n    var DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\n    // Regular expressions\n    /**\n     * This regex looks for strings that match one of the following conditions:\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\n     * The entire string (start to end) must match, and the match is not case-sensitive.\n     */\n    var SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\n    var DisplayUnit = (function () {\n        function DisplayUnit() {\n        }\n        // Methods\n        DisplayUnit.prototype.project = function (value) {\n            if (this.value) {\n                return powerbi.Double.removeDecimalNoise(value / this.value);\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.reverseProject = function (value) {\n            if (this.value) {\n                return value * this.value;\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.isApplicableTo = function (value) {\n            value = Math.abs(value);\n            var precision = powerbi.Double.getPrecision(value, 3);\n            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);\n        };\n        DisplayUnit.prototype.isScaling = function () {\n            return this.value > 1;\n        };\n        return DisplayUnit;\n    }());\n    powerbi.DisplayUnit = DisplayUnit;\n    var DisplayUnitSystem = (function () {\n        // Constructor\n        function DisplayUnitSystem(units) {\n            this.units = units ? units : [];\n        }\n        Object.defineProperty(DisplayUnitSystem.prototype, \"title\", {\n            // Properties\n            get: function () {\n                return this.displayUnit ? this.displayUnit.title : undefined;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        DisplayUnitSystem.prototype.update = function (value) {\n            if (value === undefined)\n                return;\n            this.unitBaseValue = value;\n            this.displayUnit = this.findApplicableDisplayUnit(value);\n        };\n        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {\n            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {\n                var unit = _a[_i];\n                if (unit.isApplicableTo(value))\n                    return unit;\n            }\n            return undefined;\n        };\n        DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros) {\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\n            if (this.isFormatSupported(format)) {\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\n                if (this.hasScientitifcFormat(format)) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\n                }\n                if (decimals != null) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n            }\n            return powerbi.formattingService.formatValue(value, format);\n        };\n        DisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DisplayUnitSystem.prototype.isPercentageFormat = function (format) {\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\n        };\n        DisplayUnitSystem.prototype.shouldRespectScalingUnit = function (format) {\n            return !this.isPercentageFormat(format);\n        };\n        DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function (format, decimals) {\n            return decimals;\n        };\n        DisplayUnitSystem.prototype.isScalingUnit = function () {\n            return this.displayUnit && this.displayUnit.isScaling();\n        };\n        DisplayUnitSystem.prototype.formatHelper = function (value, nonScientificFormat, format, decimals, trailingZeros) {\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\n            if ((format === 'g' || format === 'G') && decimals != null)\n                format = powerbi.visuals.valueFormatter.DefaultNumericFormat;\n            format = powerbi.NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\n            if (format && !powerbi.formattingService.isStandardNumberFormat(format))\n                return powerbi.formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\n            if (!format)\n                format = 'G';\n            if (!nonScientificFormat)\n                nonScientificFormat = '{0}';\n            var text = powerbi.formattingService.formatValue(value, format);\n            return powerbi.formattingService.format(nonScientificFormat, [text]);\n        };\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\n        DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals, trailingZeros) {\n            // Change unit base to a value appropriate for this value\n            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);\n            return this.format(value, format, decimals, trailingZeros);\n        };\n        DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {\n            if (this.units.length === 0)\n                return true;\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\n            var applicableRangeMin = 0;\n            for (var i = 0; i < this.units.length; i++) {\n                if (this.units[i].isScaling()) {\n                    applicableRangeMin = this.units[i].applicableRangeMin;\n                    break;\n                }\n            }\n            return Math.abs(value) < applicableRangeMin;\n        };\n        DisplayUnitSystem.prototype.isScientific = function (value) {\n            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\n        };\n        DisplayUnitSystem.prototype.hasScientitifcFormat = function (format) {\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\n        };\n        DisplayUnitSystem.prototype.supportsScientificFormat = function (format) {\n            if (format)\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\n            return true;\n        };\n        DisplayUnitSystem.prototype.shouldFallbackToScientific = function (value, format) {\n            return !this.hasScientitifcFormat(format)\n                && this.supportsScientificFormat(format)\n                && this.isScientific(value);\n        };\n        DisplayUnitSystem.prototype.getScientificFormat = function (data, format, decimals, trailingZeros) {\n            // Use scientific format outside of the range\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\n                var numericFormat = powerbi.NumberFormat.getNumericFormat(data, format);\n                if (decimals)\n                    numericFormat = powerbi.NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\n                if (numericFormat)\n                    return numericFormat + SCIENTIFIC_FORMAT;\n                else\n                    return DEFAULT_SCIENTIFIC_FORMAT;\n            }\n            return format;\n        };\n        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\n        return DisplayUnitSystem;\n    }());\n    powerbi.DisplayUnitSystem = DisplayUnitSystem;\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\n    var NoDisplayUnitSystem = (function (_super) {\n        __extends(NoDisplayUnitSystem, _super);\n        // Constructor\n        function NoDisplayUnitSystem() {\n            _super.call(this, []);\n        }\n        return NoDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\n        we are showing values (chart axes) and as such it is the default unit system. */\n    var DefaultDisplayUnitSystem = (function (_super) {\n        __extends(DefaultDisplayUnitSystem, _super);\n        // Constructor\n        function DefaultDisplayUnitSystem(unitLookup) {\n            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));\n        }\n        // Methods\n        DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        DefaultDisplayUnitSystem.reset = function () {\n            DefaultDisplayUnitSystem.units = null;\n        };\n        DefaultDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DefaultDisplayUnitSystem.units) {\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, function (value, previousUnitValue, min) {\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\n                    if (value - previousUnitValue >= 1000) {\n                        return value / 10;\n                    }\n                    return min;\n                });\n                // Ensure last unit has max of infinity\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DefaultDisplayUnitSystem.units;\n        };\n        return DefaultDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\n        where we have restricted space but do not want to show partial units. */\n    var WholeUnitsDisplayUnitSystem = (function (_super) {\n        __extends(WholeUnitsDisplayUnitSystem, _super);\n        // Constructor\n        function WholeUnitsDisplayUnitSystem(unitLookup) {\n            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        WholeUnitsDisplayUnitSystem.reset = function () {\n            WholeUnitsDisplayUnitSystem.units = null;\n        };\n        WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!WholeUnitsDisplayUnitSystem.units) {\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\n                // Ensure last unit has max of infinity\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return WholeUnitsDisplayUnitSystem.units;\n        };\n        WholeUnitsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        return WholeUnitsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;\n    var DataLabelsDisplayUnitSystem = (function (_super) {\n        __extends(DataLabelsDisplayUnitSystem, _super);\n        function DataLabelsDisplayUnitSystem(unitLookup) {\n            _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DataLabelsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DataLabelsDisplayUnitSystem.units) {\n                var units = [];\n                var adjustMinBasedOnPreviousUnit = function (value, previousUnitValue, min) {\n                    // Never returns true, we are always ignoring\n                    // We do not early switch (e.g. 100K instead of 0.1M)\n                    // Intended? If so, remove this function, otherwise, remove if statement\n                    if (value === -1)\n                        if (value - previousUnitValue >= 1000) {\n                            return value / 10;\n                        }\n                    return min;\n                };\n                // Add Auto & None\n                var names = unitLookup(-1);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                names = unitLookup(0);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                // Add normal units\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\n                // Ensure last unit has max of infinity\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DataLabelsDisplayUnitSystem.units;\n        };\n        DataLabelsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        // Constants\n        DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0;\n        DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1;\n        DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\n        return DataLabelsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;\n    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {\n        var units = [];\n        for (var i = 3; i < maxExponent; i++) {\n            var names = unitLookup(i);\n            if (names)\n                addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\n        }\n        return units;\n    }\n    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {\n        if (title || labelFormat) {\n            var min = value;\n            if (units.length > 0) {\n                var previousUnit = units[units.length - 1];\n                if (adjustMinBasedOnPreviousUnit)\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\n                previousUnit.applicableRangeMax = min;\n            }\n            var unit = new DisplayUnit();\n            unit.value = value;\n            unit.applicableRangeMin = min;\n            unit.applicableRangeMax = min * 1000;\n            unit.title = title;\n            unit.labelFormat = labelFormat;\n            units.push(unit);\n        }\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequence = (function () {\n        function NumericSequence() {\n        }\n        NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {\n            debug.assertValue(range, \"range\");\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\n            debug.assert(minPower === undefined || (minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP), \"minPower\");\n            debug.assert(maxAllowedMargin === undefined || (maxAllowedMargin >= 0), \"maxAllowedMargin\");\n            var result = new NumericSequence();\n            if (expectedCount === undefined)\n                expectedCount = 10;\n            else\n                expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (minPower === undefined)\n                minPower = powerbi.Double.MIN_EXP;\n            if (useZeroRefPoint === undefined)\n                useZeroRefPoint = false;\n            if (maxAllowedMargin === undefined)\n                maxAllowedMargin = 1;\n            if (steps === undefined)\n                steps = [1, 2, 5];\n            // Handle single stop case\n            if (range.forcedSingleStop) {\n                result.interval = range.getSize();\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\n                result.min = range.min;\n                result.max = range.max;\n                result.sequence = [range.forcedSingleStop];\n                return result;\n            }\n            var interval = 0;\n            var min = 0;\n            var max = 9;\n            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\n            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\n            var size = range.getSize();\n            var exp = powerbi.Double.log10(size);\n            // Account for Exp of steps\n            var stepExp = powerbi.Double.log10(steps[0]);\n            exp = exp - stepExp;\n            // Account for MaxCount\n            var expectedCountExp = powerbi.Double.log10(expectedCount);\n            exp = exp - expectedCountExp;\n            // Account for MinPower\n            exp = Math.max(exp, minPower - stepExp + 1);\n            var count = undefined;\n            // Create array of \"good looking\" numbers\n            if (interval !== 0) {\n                // If explicit interval is defined - use it instead of the steps array.\n                var power = powerbi.Double.pow10(exp);\n                var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\n                roundRange.shrinkByStep(range, interval);\n                min = roundRange.min;\n                max = roundRange.max;\n                count = Math.floor(roundRange.getSize() / interval);\n            }\n            else {\n                // No interval defined -> find optimal interval\n                var dexp = void 0;\n                for (dexp = 0; dexp < 3; dexp++) {\n                    var e = exp + dexp;\n                    var power = powerbi.Double.pow10(e);\n                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\n                    var stepsCount = steps.length;\n                    var stepPower = powerbi.Double.pow10(e - 1);\n                    for (var i = 0; i < stepsCount; i++) {\n                        var step = steps[i] * stepPower;\n                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\n                        roundRange.shrinkByStep(range, step);\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\n                            roundRange.min -= step;\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\n                            roundRange.max += step;\n                        // Count the intervals\n                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step);\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\n                            interval = step;\n                            min = roundRange.min;\n                            max = roundRange.max;\n                            break;\n                        }\n                    }\n                    // Increase the scale power until the interval is found\n                    if (interval !== 0)\n                        break;\n                }\n            }\n            // Avoid extreme count cases (>1000 ticks)\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\n                interval = (max - min) / count;\n            }\n            result.min = min;\n            result.max = max;\n            result.interval = interval;\n            result.intervalOffset = min - range.min;\n            result.maxAllowedMargin = maxAllowedMargin;\n            result.canExtendMin = canExtendMin;\n            result.canExtendMax = canExtendMax;\n            // Fill in the Sequence\n            var precision = powerbi.Double.getPrecision(interval, 0);\n            result.precision = precision;\n            var sequence = [];\n            var x = powerbi.Double.roundToPrecision(min, precision);\n            sequence.push(x);\n            for (var i = 0; i < count; i++) {\n                x = powerbi.Double.roundToPrecision(x + interval, precision);\n                sequence.push(x);\n            }\n            result.sequence = sequence;\n            result.trimMinMax(range.min, range.max);\n            return result;\n        };\n        /**\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid.\n         * @min - The minimum of the range.\n         * @max - The maximum of the range.\n         * @maxCount - The max count of intervals.\n         * @steps - array of intervals.\n         */\n        NumericSequence.calculateUnits = function (min, max, maxCount, steps) {\n            // Initialization actions\n            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (min === max) {\n                max = min + 1;\n            }\n            var stepCount = 0;\n            var step = 0;\n            // Calculate step\n            for (var i = 0; i < steps.length; i++) {\n                step = steps[i];\n                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);\n                var minStepCount = powerbi.Double.floorWithPrecision(min / step);\n                stepCount = maxStepCount - minStepCount;\n                if (stepCount <= maxCount) {\n                    break;\n                }\n            }\n            // Calculate the offset\n            var offset = -min;\n            offset = offset % step;\n            // Create sequence\n            var result = new NumericSequence();\n            result.sequence = [];\n            for (var x = min + offset;; x += step) {\n                result.sequence.push(x);\n                if (x >= max)\n                    break;\n            }\n            result.interval = step;\n            result.intervalOffset = offset;\n            result.min = result.sequence[0];\n            result.max = result.sequence[result.sequence.length - 1];\n            return result;\n        };\n        NumericSequence.prototype.trimMinMax = function (min, max) {\n            var minMargin = (min - this.min) / this.interval;\n            var maxMargin = (this.max - max) / this.interval;\n            var marginPrecision = 0.001;\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\n                this.min = min;\n            }\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\n                this.max = max;\n            }\n        };\n        NumericSequence.MIN_COUNT = 1;\n        NumericSequence.MAX_COUNT = 1000;\n        return NumericSequence;\n    }());\n    powerbi.NumericSequence = NumericSequence;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequenceRange = (function () {\n        function NumericSequenceRange() {\n        }\n        NumericSequenceRange.prototype._ensureIncludeZero = function () {\n            if (this.includeZero) {\n                // fixed min and max has higher priority than includeZero\n                if (this.min > 0 && !this.hasFixedMin) {\n                    this.min = 0;\n                }\n                if (this.max < 0 && !this.hasFixedMax) {\n                    this.max = 0;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureNotEmpty = function () {\n            if (this.min === this.max) {\n                if (!this.min) {\n                    this.min = 0;\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\n                    this.hasFixedMin = true;\n                    this.hasFixedMax = true;\n                }\n                else {\n                    // We are dealing with a single data value (includeZero is not set)\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\n                    // Interval is calculated based on the number:\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\n                    var value = this.min;\n                    var exp = powerbi.Double.log10(Math.abs(value));\n                    var step = void 0;\n                    if (exp >= 0 && exp < 4) {\n                        step = 0.5;\n                        this.forcedSingleStop = value;\n                    }\n                    else {\n                        step = powerbi.Double.pow10(exp) / 2;\n                        this.forcedSingleStop = null;\n                    }\n                    this.min = value - step;\n                    this.max = value + step;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureDirection = function () {\n            if (this.min > this.max) {\n                var temp = this.min;\n                this.min = this.max;\n                this.max = temp;\n            }\n        };\n        NumericSequenceRange.prototype.getSize = function () {\n            return this.max - this.min;\n        };\n        NumericSequenceRange.prototype.shrinkByStep = function (range, step) {\n            debug.assertValue(range, \"range\");\n            debug.assert(step > 0, \"step\");\n            var oldCount = this.min / step;\n            var newCount = range.min / step;\n            var deltaCount = Math.floor(newCount - oldCount);\n            this.min += deltaCount * step;\n            oldCount = this.max / step;\n            newCount = range.max / step;\n            deltaCount = Math.ceil(newCount - oldCount);\n            this.max += deltaCount * step;\n        };\n        NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\n            var result = new NumericSequenceRange();\n            result.includeZero = includeZero ? true : false;\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\n            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            // Calculate the range using the min, max, dataRange\n            if (result.hasFixedMin && result.hasFixedMax) {\n                result.min = fixedMin;\n                result.max = fixedMax;\n            }\n            else if (result.hasFixedMin) {\n                result.min = fixedMin;\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\n            }\n            else if (result.hasFixedMax) {\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\n                result.max = fixedMax;\n            }\n            else if (result.hasDataRange) {\n                result.min = dataMin;\n                result.max = dataMax;\n            }\n            else {\n                result.min = 0;\n                result.max = 0;\n            }\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            if (result.min === 0) {\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\n            }\n            else if (result.max === 0) {\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\n            }\n            return result;\n        };\n        NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\n            }\n            else {\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\n            }\n        };\n        NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {\n            debug.assertValue(fixedMin, \"fixedMin\");\n            debug.assertValue(fixedMax, \"fixedMax\");\n            var result = new NumericSequenceRange();\n            result.hasDataRange = false;\n            result.includeZero = includeZero;\n            result.min = fixedMin;\n            result.max = fixedMax;\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            result.hasFixedMin = true;\n            result.hasFixedMax = true;\n            return result;\n        };\n        NumericSequenceRange.DEFAULT_MAX = 10;\n        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;\n        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;\n        return NumericSequenceRange;\n    }());\n    powerbi.NumericSequenceRange = NumericSequenceRange;\n    /** Note: Exported for testability */\n    var ValueUtil;\n    (function (ValueUtil) {\n        function hasValue(value) {\n            return value !== undefined && value !== null;\n        }\n        ValueUtil.hasValue = hasValue;\n    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var valueFormatter;\n        (function (valueFormatter) {\n            var StringExtensions = jsCommon.StringExtensions;\n            var BeautifiedFormat = {\n                '0.00 %;-0.00 %;0.00 %': 'Percentage',\n                '0.0 %;-0.0 %;0.0 %': 'Percentage1',\n            };\n            valueFormatter.DefaultIntegerFormat = 'g';\n            valueFormatter.DefaultNumericFormat = '#,0.00';\n            valueFormatter.DefaultDateFormat = 'd';\n            var defaultLocalizedStrings = {\n                'NullValue': '(Blank)',\n                'BooleanTrue': 'True',\n                'BooleanFalse': 'False',\n                'NaNValue': 'NaN',\n                'InfinityValue': '+Infinity',\n                'NegativeInfinityValue': '-Infinity',\n                'RestatementComma': '{0}, {1}',\n                'RestatementCompoundAnd': '{0} and {1}',\n                'RestatementCompoundOr': '{0} or {1}',\n                'DisplayUnitSystem_EAuto_Title': 'Auto',\n                'DisplayUnitSystem_E0_Title': 'None',\n                'DisplayUnitSystem_E3_LabelFormat': '{0}K',\n                'DisplayUnitSystem_E3_Title': 'Thousands',\n                'DisplayUnitSystem_E6_LabelFormat': '{0}M',\n                'DisplayUnitSystem_E6_Title': 'Millions',\n                'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\n                'DisplayUnitSystem_E9_Title': 'Billions',\n                'DisplayUnitSystem_E12_LabelFormat': '{0}T',\n                'DisplayUnitSystem_E12_Title': 'Trillions',\n                'Percentage': '#,0.##%',\n                'Percentage1': '#,0.#%',\n                'TableTotalLabel': 'Total',\n                'Tooltip_HighlightedValueDisplayName': 'Highlighted',\n                'Funnel_PercentOfFirst': 'Percent of first',\n                'Funnel_PercentOfPrevious': 'Percent of previous',\n                'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlighted)',\n                'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlighted)',\n                // Geotagging strings\n                'GeotaggingString_Continent': 'continent',\n                'GeotaggingString_Continents': 'continents',\n                'GeotaggingString_Country': 'country',\n                'GeotaggingString_Countries': 'countries',\n                'GeotaggingString_State': 'state',\n                'GeotaggingString_States': 'states',\n                'GeotaggingString_City': 'city',\n                'GeotaggingString_Cities': 'cities',\n                'GeotaggingString_Town': 'town',\n                'GeotaggingString_Towns': 'towns',\n                'GeotaggingString_Province': 'province',\n                'GeotaggingString_Provinces': 'provinces',\n                'GeotaggingString_County': 'county',\n                'GeotaggingString_Counties': 'counties',\n                'GeotaggingString_Village': 'village',\n                'GeotaggingString_Villages': 'villages',\n                'GeotaggingString_Post': 'post',\n                'GeotaggingString_Zip': 'zip',\n                'GeotaggingString_Code': 'code',\n                'GeotaggingString_Place': 'place',\n                'GeotaggingString_Places': 'places',\n                'GeotaggingString_Address': 'address',\n                'GeotaggingString_Addresses': 'addresses',\n                'GeotaggingString_Street': 'street',\n                'GeotaggingString_Streets': 'streets',\n                'GeotaggingString_Longitude': 'longitude',\n                'GeotaggingString_Longitude_Short': 'lon',\n                'GeotaggingString_Latitude': 'latitude',\n                'GeotaggingString_Latitude_Short': 'lat',\n                'GeotaggingString_PostalCode': 'postal code',\n                'GeotaggingString_PostalCodes': 'postal codes',\n                'GeotaggingString_ZipCode': 'zip code',\n                'GeotaggingString_ZipCodes': 'zip codes',\n                'GeotaggingString_Territory': 'territory',\n                'GeotaggingString_Territories': 'territories',\n            };\n            function beautify(format) {\n                var key = BeautifiedFormat[format];\n                if (key)\n                    return defaultLocalizedStrings[key] || format;\n                return format;\n            }\n            function describeUnit(exponent) {\n                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\n                var title = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\n                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\n                if (title || format)\n                    return { title: title, format: format };\n            }\n            function getLocalizedString(stringId) {\n                return defaultLocalizedStrings[stringId];\n            }\n            valueFormatter.getLocalizedString = getLocalizedString;\n            // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\n            var locale = {\n                null: defaultLocalizedStrings['NullValue'],\n                true: defaultLocalizedStrings['BooleanTrue'],\n                false: defaultLocalizedStrings['BooleanFalse'],\n                NaN: defaultLocalizedStrings['NaNValue'],\n                infinity: defaultLocalizedStrings['InfinityValue'],\n                negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\n                beautify: function (format) { return beautify(format); },\n                describe: function (exponent) { return describeUnit(exponent); },\n                restatementComma: defaultLocalizedStrings['RestatementComma'],\n                restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\n                restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\n            };\n            var MaxScaledDecimalPlaces = 2;\n            var MaxValueForDisplayUnitRounding = 1000;\n            var MinIntegerValueForDisplayUnits = 10000;\n            var MinPrecisionForDisplayUnits = 2;\n            var DateTimeMetadataColumn = {\n                displayName: '',\n                type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.DateTime),\n            };\n            function getFormatMetadata(format) {\n                return powerbi.NumberFormat.getCustomFormatMetadata(format);\n            }\n            valueFormatter.getFormatMetadata = getFormatMetadata;\n            function setLocaleOptions(options) {\n                debug.assertValue(options, 'options');\n                locale = options;\n                powerbi.DefaultDisplayUnitSystem.reset();\n                powerbi.WholeUnitsDisplayUnitSystem.reset();\n            }\n            valueFormatter.setLocaleOptions = setLocaleOptions;\n            function createDefaultFormatter(formatString, allowFormatBeautification) {\n                if (allowFormatBeautification === void 0) { allowFormatBeautification = false; }\n                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;\n                return {\n                    format: function (value) {\n                        if (value == null)\n                            return locale.null;\n                        return formatCore(value, formatBeaut);\n                    }\n                };\n            }\n            valueFormatter.createDefaultFormatter = createDefaultFormatter;\n            /** Creates an IValueFormatter to be used for a range of values. */\n            function create(options) {\n                debug.assertValue(options, 'options');\n                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\n                if (shouldUseNumericDisplayUnits(options)) {\n                    var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType);\n                    var singleValueFormattingMode_1 = !!options.formatSingleValues;\n                    displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\n                    var forcePrecision_1 = options.precision != null;\n                    var decimals_1;\n                    if (forcePrecision_1)\n                        decimals_1 = -options.precision;\n                    else if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1)\n                        decimals_1 = -MaxScaledDecimalPlaces;\n                    // Detect axis precision\n                    if (options.detectAxisPrecision) {\n                        // Trailing zeroes\n                        forcePrecision_1 = true;\n                        var axisValue = options.value;\n                        if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 0)\n                            axisValue = axisValue / displayUnitSystem_1.displayUnit.value;\n                        if (powerbi.Double.isInteger(axisValue))\n                            decimals_1 = 0;\n                        else\n                            decimals_1 = powerbi.Double.log10(axisValue);\n                    }\n                    return {\n                        format: function (value) {\n                            var formattedValue = getStringFormat(value, true /*nullsAreBlank*/);\n                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                                return formattedValue;\n                            // Round to Double.DEFAULT_PRECISION\n                            if (value && !displayUnitSystem_1.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision_1)\n                                value = powerbi.Double.roundToPrecision(value);\n                            return singleValueFormattingMode_1 ?\n                                displayUnitSystem_1.formatSingleValue(value, format, decimals_1, forcePrecision_1) :\n                                displayUnitSystem_1.format(value, format, decimals_1, forcePrecision_1);\n                        },\n                        displayUnit: displayUnitSystem_1.displayUnit,\n                        options: options\n                    };\n                }\n                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\n                    var unit_1 = powerbi.DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\n                    return {\n                        format: function (value) {\n                            if (value == null)\n                                return locale.null;\n                            var formatString = powerbi.formattingService.dateFormatString(unit_1);\n                            return formatCore(value, formatString);\n                        },\n                        options: options\n                    };\n                }\n                return createDefaultFormatter(format);\n            }\n            valueFormatter.create = create;\n            function format(value, format, allowFormatBeautification) {\n                if (value == null)\n                    return locale.null;\n                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);\n            }\n            valueFormatter.format = format;\n            /**\n             * Value formatting function to handle variant measures.\n             * For a Date/Time value within a non-date/time field, it's formatted with the default date/time formatString instead of as a number\n             * @param {any} value Value to be formatted\n             * @param {DataViewMetadataColumn} column Field which the value belongs to\n             * @param {DataViewObjectPropertyIdentifier} formatStringProp formatString Property ID\n             * @param {boolean} nullsAreBlank? Whether to show \"(Blank)\" instead of empty string for null values\n             * @returns Formatted value\n             */\n            function formatVariantMeasureValue(value, column, formatStringProp, nullsAreBlank) {\n                // If column type is not datetime, but the value is of time datetime,\n                // then use the default date format string\n                if (!(column && column.type && column.type.dateTime) && value instanceof Date) {\n                    var valueFormat = getFormatString(DateTimeMetadataColumn, null, false);\n                    return formatCore(value, valueFormat, nullsAreBlank);\n                }\n                else {\n                    return formatCore(value, getFormatString(column, formatStringProp), nullsAreBlank);\n                }\n            }\n            valueFormatter.formatVariantMeasureValue = formatVariantMeasureValue;\n            function createDisplayUnitSystem(displayUnitSystemType) {\n                if (displayUnitSystemType == null)\n                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                switch (displayUnitSystemType) {\n                    case powerbi.DisplayUnitSystemType.Default:\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.WholeUnits:\n                        return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.Verbose:\n                        return new powerbi.NoDisplayUnitSystem();\n                    case powerbi.DisplayUnitSystemType.DataLabels:\n                        return new powerbi.DataLabelsDisplayUnitSystem(locale.describe);\n                    default:\n                        debug.assertFail('Unknown display unit system type');\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                }\n            }\n            function shouldUseNumericDisplayUnits(options) {\n                var value = options.value;\n                var value2 = options.value2;\n                var format = options.format;\n                // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\n                if (options.formatSingleValues && format) {\n                    if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\n                        var isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\n                        if (isCustomFormat) {\n                            var precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\n                            if (precision < MinPrecisionForDisplayUnits)\n                                return false;\n                        }\n                        else if (powerbi.Double.isInteger(value))\n                            return false;\n                    }\n                }\n                if ((typeof value === 'number') || (typeof value2 === 'number')) {\n                    return true;\n                }\n            }\n            function shouldUseDateUnits(value, value2, tickCount) {\n                // must check both value and value2 because we'll need to get an interval for date units\n                return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\n            }\n            /*\n             * Get the column format. Order of precendence is:\n             *  1. Column format\n             *  2. Default PowerView policy for column type\n             */\n            function getFormatString(column, formatStringProperty, suppressTypeFallback) {\n                if (column) {\n                    if (formatStringProperty) {\n                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);\n                        if (propertyValue)\n                            return propertyValue;\n                    }\n                    if (!suppressTypeFallback) {\n                        var columnType = column.type;\n                        if (columnType) {\n                            if (columnType.dateTime)\n                                return valueFormatter.DefaultDateFormat;\n                            if (columnType.integer)\n                                return valueFormatter.DefaultIntegerFormat;\n                            if (columnType.numeric)\n                                return valueFormatter.DefaultNumericFormat;\n                        }\n                    }\n                }\n            }\n            valueFormatter.getFormatString = getFormatString;\n            function formatListCompound(strings, conjunction) {\n                var result;\n                if (!strings) {\n                    return null;\n                }\n                var length = strings.length;\n                if (length > 0) {\n                    result = strings[0];\n                    var lastIndex = length - 1;\n                    for (var i = 1, len = lastIndex; i < len; i++) {\n                        var value = strings[i];\n                        result = StringExtensions.format(locale.restatementComma, result, value);\n                    }\n                    if (length > 1) {\n                        var value = strings[lastIndex];\n                        result = StringExtensions.format(conjunction, result, value);\n                    }\n                }\n                else {\n                    result = null;\n                }\n                return result;\n            }\n            /** The returned string will look like 'A, B, ..., and C'  */\n            function formatListAnd(strings) {\n                return formatListCompound(strings, locale.restatementCompoundAnd);\n            }\n            valueFormatter.formatListAnd = formatListAnd;\n            /** The returned string will look like 'A, B, ..., or C' */\n            function formatListOr(strings) {\n                return formatListCompound(strings, locale.restatementCompoundOr);\n            }\n            valueFormatter.formatListOr = formatListOr;\n            function formatCore(value, format, nullsAreBlank) {\n                var formattedValue = getStringFormat(value, nullsAreBlank ? nullsAreBlank : false /*nullsAreBlank*/);\n                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                    return formattedValue;\n                return powerbi.formattingService.formatValue(value, format);\n            }\n            function getStringFormat(value, nullsAreBlank) {\n                if (value == null && nullsAreBlank)\n                    return locale.null;\n                if (value === true)\n                    return locale.true;\n                if (value === false)\n                    return locale.false;\n                if (typeof value === 'number' && isNaN(value))\n                    return locale.NaN;\n                if (value === Number.NEGATIVE_INFINITY)\n                    return locale.negativeInfinity;\n                if (value === Number.POSITIVE_INFINITY)\n                    return locale.infinity;\n                return '';\n            }\n            function getDisplayUnits(displayUnitSystemType) {\n                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\n                return displayUnitSystem.units;\n            }\n            valueFormatter.getDisplayUnits = getDisplayUnits;\n        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper;\n        (function (DataRoleHelper) {\n            function getMeasureIndexOfRole(grouped, roleName) {\n                if (!_.isEmpty(grouped)) {\n                    var firstGroup = grouped[0];\n                    if (firstGroup.values && firstGroup.values.length > 0) {\n                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {\n                            var value = firstGroup.values[i];\n                            if (value && value.source) {\n                                if (hasRole(value.source, roleName))\n                                    return i;\n                            }\n                        }\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;\n            function getCategoryIndexOfRole(categories, roleName) {\n                if (!_.isEmpty(categories)) {\n                    for (var i = 0, ilen = categories.length; i < ilen; i++) {\n                        if (hasRole(categories[i].source, roleName))\n                            return i;\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;\n            function hasRole(column, name) {\n                var roles = column.roles;\n                return roles && roles[name];\n            }\n            DataRoleHelper.hasRole = hasRole;\n            function hasRoleInDataView(dataView, name) {\n                return dataView != null\n                    && dataView.metadata != null\n                    && dataView.metadata.columns\n                    && _.any(dataView.metadata.columns, function (c) { return c.roles && c.roles[name] !== undefined; });\n            }\n            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;\n            function hasRoleInValueColumn(valueColumn, name) {\n                return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\n            }\n            DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;\n        })(DataRoleHelper = data.DataRoleHelper || (data.DataRoleHelper = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper = powerbi.data.DataRoleHelper;\n        function createIDataViewCategoricalReader(dataView) {\n            return new DataViewCategoricalReader(dataView);\n        }\n        data.createIDataViewCategoricalReader = createIDataViewCategoricalReader;\n        var DataViewCategoricalReader = (function () {\n            function DataViewCategoricalReader(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                this.dataView = dataView;\n                // Validate categories\n                var categorical;\n                if (dataView)\n                    categorical = dataView.categorical;\n                var categories;\n                if (categorical)\n                    categories = this.categories = categorical.categories;\n                this.hasValidCategories = !_.isEmpty(categories);\n                // Validate values\n                var values;\n                if (categorical)\n                    values = categorical.values;\n                // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\n                // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\n                this.hasAnyValidValues = false;\n                if (values != null) {\n                    var grouped = dataView.categorical.values.grouped();\n                    if (grouped.length > 0) {\n                        this.hasAnyValidValues = true;\n                        this.grouped = grouped;\n                        // Iterate through the first group's values to populate the valueRoleIndexMapping\n                        var valueRoleIndexMapping = {};\n                        var firstGroupValues = grouped[0].values;\n                        for (var valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\n                            var valueRoles = firstGroupValues[valueIndex].source.roles;\n                            for (var role in valueRoles) {\n                                if (valueRoles[role]) {\n                                    if (!valueRoleIndexMapping[role])\n                                        valueRoleIndexMapping[role] = [];\n                                    valueRoleIndexMapping[role].push(valueIndex);\n                                }\n                            }\n                        }\n                        this.valueRoleIndexMapping = valueRoleIndexMapping;\n                    }\n                }\n                if (this.hasAnyValidValues)\n                    this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\n            }\n            // Category methods\n            DataViewCategoricalReader.prototype.hasCategories = function () {\n                return this.hasValidCategories;\n            };\n            DataViewCategoricalReader.prototype.getCategoryCount = function () {\n                if (this.hasValidCategories)\n                    return this.categories[0].values.length;\n                else\n                    return 0;\n            };\n            DataViewCategoricalReader.prototype.getCategoryValues = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryValue = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values[categoryIndex] : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumn = function (roleName) {\n                if (this.hasValidCategories)\n                    return this.getCategoryFromRole(roleName);\n            };\n            DataViewCategoricalReader.prototype.getCategoryMetadataColumn = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.source : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumnIdentityFields = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.identityFields : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryDisplayName = function (roleName) {\n                if (this.hasValidCategories) {\n                    var targetColumn = this.getCategoryColumn(roleName);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.hasCompositeCategories = function () {\n                if (this.hasValidCategories)\n                    return this.categories.length > 1;\n            };\n            DataViewCategoricalReader.prototype.hasCategoryWithRole = function (roleName) {\n                return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\n            };\n            DataViewCategoricalReader.prototype.getCategoryObjects = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var category = this.getCategoryFromRole(roleName);\n                    if (category && category.objects) {\n                        return category.objects[categoryIndex];\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryFromRole = function (roleName) {\n                var categories = this.categories;\n                return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\n            };\n            // Value and measure methods\n            DataViewCategoricalReader.prototype.hasValues = function (roleName) {\n                return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\n            };\n            DataViewCategoricalReader.prototype.hasHighlights = function (roleName) {\n                if (this.hasValues(roleName)) {\n                    return !_.isEmpty(this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].highlights);\n                }\n                return false;\n            };\n            DataViewCategoricalReader.prototype.getValue = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        // For dynamic series, we only ever obtain the first value column from a role\n                        return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, false /* getHighlight */);\n                    }\n                    else {\n                        // For static series or single series, we obtain value columns from the first series\n                        //    and use the seriesIndex to index into the value columns within the role\n                        return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, false /* getHighlight */);\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getHighlight = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        // For dynamic series, we only ever obtain the first value column from a role\n                        return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, true /* getHighlight */);\n                    }\n                    else {\n                        // For static series or single series, we obtain value columns from the first series\n                        //    and use the seriesIndex to index into the value columns within the role\n                        return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, true /* getHighlight */);\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllValuesForRole = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var valuesInRole = [];\n                    for (var roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, false /* getHighlight */));\n                    }\n                    return valuesInRole;\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllHighlightsForRole = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var valuesInRole = [];\n                    for (var roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, true /* getHighlight */));\n                    }\n                    return valuesInRole;\n                }\n            };\n            /**\n             * Obtains the value from grouped.\n             *\n             * Grouped:             [0] [1] [2] [3] (seriesIndex)\n             *                         /   \\\n             * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\n             *                    /    \\ \\  \\\n             * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\n             *\n             *--------------------------------|\n             *                      |Category |\n             * Series|Value Columns |A B C D E|\n             *--------------------------------|\n             *      0|col0 (tooltip)|         |\n             *       |col1 (value)  |         |\n             *       |col2 (value)  |         |\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      1|col0 (tooltip)|         |\n             *       |col1 (value)  |0 1 2 3 4|\n             *       |col2 (value)  |5 6 7 8 9|\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      2|col0 (tooltip)|...      |\n             *\n             * valueColumnIndexInRole is for indexing into the values for a single role\n             * valueColumnIndex is for indexing into the entire value array including\n             * all roles\n             *\n             * The valueRoleIndexMapping converts roleValueIndex and role (value role\n             * with an index of 1) into groupedValueIndex (2)\n             *\n             * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\n             * the second value column with role \"value\" (which is converted to a\n             * groupedValueIndex of 2) and the fourth value within that value column.\n             */\n            DataViewCategoricalReader.prototype.getValueInternal = function (roleName, categoryIndex, groupIndex, valueColumnIndexInRole, getHighlight) {\n                if (this.hasValues(roleName)) {\n                    var valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\n                    var groupedValues = this.grouped[groupIndex].values[valueColumnIndex];\n                    return getHighlight ? groupedValues.highlights[categoryIndex] : groupedValues.values[categoryIndex];\n                }\n            };\n            DataViewCategoricalReader.prototype.getFirstNonNullValueForCategory = function (roleName, categoryIndex) {\n                if (this.hasValues(roleName)) {\n                    if (!this.dataHasDynamicSeries) {\n                        debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\n                        return this.getValue(roleName, categoryIndex);\n                    }\n                    for (var seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\n                        var value = this.getValue(roleName, categoryIndex, seriesIndex);\n                        if (value != null) {\n                            return value;\n                        }\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getMeasureQueryName = function (roleName) {\n                if (this.hasValues(roleName))\n                    return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\n            };\n            DataViewCategoricalReader.prototype.getValueColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\n                    }\n                    else {\n                        return this.grouped[0].values[this.valueRoleIndexMapping[roleName][seriesIndex]];\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getValueMetadataColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                var valueColumn = this.getValueColumn(roleName, seriesIndex);\n                if (valueColumn) {\n                    return valueColumn.source;\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllValueMetadataColumnsForRole = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var metadata = [];\n                    for (var roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        var column = this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][roleValueIndex]].source;\n                        metadata.push(column);\n                    }\n                    return metadata;\n                }\n            };\n            DataViewCategoricalReader.prototype.getValueDisplayName = function (roleName, seriesIndex) {\n                if (this.hasValues(roleName)) {\n                    var targetColumn = this.getValueColumn(roleName, seriesIndex);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            // Series methods\n            DataViewCategoricalReader.prototype.hasDynamicSeries = function () {\n                return this.dataHasDynamicSeries;\n            };\n            DataViewCategoricalReader.prototype.getSeriesCount = function (valueRoleName) {\n                if (!this.hasAnyValidValues)\n                    return;\n                if (this.dataHasDynamicSeries) {\n                    return this.grouped.length;\n                }\n                else {\n                    var roleIndexMap = valueRoleName && this.valueRoleIndexMapping[valueRoleName];\n                    if (roleIndexMap)\n                        return roleIndexMap.length;\n                    return 1;\n                }\n            };\n            DataViewCategoricalReader.prototype.getSeriesObjects = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].objects;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumns = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumnGroup = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex];\n            };\n            DataViewCategoricalReader.prototype.getSeriesMetadataColumn = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.source;\n            };\n            DataViewCategoricalReader.prototype.getSeriesColumnIdentityFields = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.identityFields;\n            };\n            DataViewCategoricalReader.prototype.getSeriesName = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].name;\n            };\n            DataViewCategoricalReader.prototype.getSeriesDisplayName = function () {\n                if (this.hasAnyValidValues && this.dataHasDynamicSeries)\n                    return this.dataView.categorical.values.source.displayName;\n            };\n            return DataViewCategoricalReader;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var valueFormatter = powerbi.visuals.valueFormatter;\n        var DataViewConcatenateCategoricalColumns;\n        (function (DataViewConcatenateCategoricalColumns) {\n            function detectAndApply(dataView, objectDescriptors, roleMappings, projectionOrdering, selects, projectionActiveItems) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                var result = dataView;\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical) {\n                    var concatenationSource = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\n                    if (concatenationSource) {\n                        // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\n                        var columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\n                        if (columnsSortedByProjectionOrdering.length >= 2) {\n                            var activeItemsToIgnoreInConcatenation = _.chain(projectionActiveItems[concatenationSource.roleName])\n                                .filter(function (activeItemInfo) { return activeItemInfo.suppressConcat; })\n                                .map(function (activeItemInfo) { return activeItemInfo.queryRef; })\n                                .value();\n                            result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\n                        }\n                    }\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.detectAndApply = detectAndApply;\n            /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\n            function applyToPlayChartCategorical(metadata, objectDescriptors, categoryRoleName, categorical) {\n                debug.assertValue(metadata, 'metadata');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(categorical, 'categorical');\n                var result;\n                if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\n                    // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\n                    // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\n                    // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\n                    // use inherit() rather than inheritSingle() here.\n                    var transformingColumns_1 = inherit(metadata.columns);\n                    var transformingMetadata = inherit(metadata, function (m) { m.columns = transformingColumns_1; });\n                    var transformingDataView = { metadata: transformingMetadata, categorical: categorical };\n                    result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\n                }\n                else {\n                    result = { metadata: metadata, categorical: categorical };\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical = applyToPlayChartCategorical;\n            /**\n             * Returns the role and its assocated category columns (from dataViewCategorical.categories)\n             * that should be concatenated for the case of hierarchical group.\n             *\n             * Note: In the future if we support sibling hierarchical groups in categorical,\n             * change the return type to CategoryColumnsByRole[] and update detection logic.\n             */\n            function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, metadata, dataViewMappings, selects, projectionActiveItems) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\n                var result;\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var supportedRoleMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                // The following code will choose a role name only if all supportedRoleMappings share the same role for Categorical Category.\n                // Handling multiple supportedRoleMappings is necessary for TransformActions with splits, which can happen in scenarios such as:\n                // 1. combo chart with a field for both Line and Column values, and\n                // 2. chart with regression line enabled.\n                // In case 1, you can pretty much get exactly the one from supportedRoleMappings for which this code is currently processing for,\n                // by looking at the index of the current split in DataViewTransformActions.splits.\n                // In case 2, however, supportedRoleMappings.length will be different than DataViewTransformActions.splits.length, hence it is\n                // not straight forward to figure out for which one in supportedRoleMappings is this code currently processing.\n                // SO... This code will just choose the category role name if it is consistent across all supportedRoleMappings.\n                var isEveryRoleMappingForCategorical = !_.isEmpty(supportedRoleMappings) &&\n                    _.every(supportedRoleMappings, function (roleMapping) { return !!roleMapping.categorical; });\n                if (isEveryRoleMappingForCategorical) {\n                    var targetRoleName_1 = getSingleCategoryRoleNameInEveryRoleMapping(supportedRoleMappings);\n                    if (targetRoleName_1 &&\n                        isVisualExpectingMaxOneCategoryColumn(targetRoleName_1, supportedRoleMappings)) {\n                        var categoryColumnsForTargetRole_1 = _.filter(dataViewCategorical.categories, function (categoryColumn) { return categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName_1]; });\n                        // There is no need to concatenate columns unless there is actually more than one column\n                        if (categoryColumnsForTargetRole_1.length >= 2) {\n                            // At least for now, we expect all category columns for the same role to have the same number of value entries.\n                            // If that's not the case, we won't run the concatenate logic for that role at all...\n                            var areValuesCountsEqual = _.every(categoryColumnsForTargetRole_1, function (categoryColumn) { return categoryColumn.values.length === categoryColumnsForTargetRole_1[0].values.length; });\n                            if (areValuesCountsEqual) {\n                                result = {\n                                    roleName: targetRoleName_1,\n                                    categories: categoryColumnsForTargetRole_1,\n                                };\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n            /** If all mappings in the specified roleMappings have the same single role name for their categorical category roles, return that role name, else returns undefined. */\n            function getSingleCategoryRoleNameInEveryRoleMapping(categoricalRoleMappings) {\n                debug.assertNonEmpty(categoricalRoleMappings, 'categoricalRoleMappings');\n                debug.assert(_.every(categoricalRoleMappings, function (roleMapping) { return !!roleMapping.categorical; }), 'All mappings in categoricalRoleMappings must contain a DataViewCategoricalMapping');\n                var result;\n                // With \"list\" in role mapping, it is possible to have multiple role names for category.\n                // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\n                // We can change this if we want to support independent (sibling) group hierarchies in categorical.\n                var uniqueCategoryRoles = _.chain(categoricalRoleMappings)\n                    .map(function (roleMapping) {\n                    var categoryRoles = getAllRolesInCategories(roleMapping.categorical);\n                    return categoryRoles.length === 1 ? categoryRoles[0] : undefined;\n                })\n                    .uniq() // Note: _.uniq() does not treat two arrays with same elements as equal\n                    .value();\n                var isSameCategoryRoleNameInAllRoleMappings = uniqueCategoryRoles.length === 1 && !_.isUndefined(uniqueCategoryRoles[0]);\n                if (isSameCategoryRoleNameInAllRoleMappings) {\n                    result = uniqueCategoryRoles[0];\n                }\n                return result;\n            }\n            function isVisualExpectingMaxOneCategoryColumn(categoricalRoleName, roleMappings) {\n                debug.assertValue(categoricalRoleName, 'categoricalRoleName');\n                debug.assertNonEmpty(roleMappings, 'roleMappings');\n                var isVisualExpectingMaxOneCategoryColumn = _.every(roleMappings, function (roleMapping) {\n                    return !_.isEmpty(roleMapping.conditions) &&\n                        _.every(roleMapping.conditions, function (condition) { return condition[categoricalRoleName] && condition[categoricalRoleName].max === 1; });\n                });\n                return isVisualExpectingMaxOneCategoryColumn;\n            }\n            /**\n             * Returns the array of role names that are mapped to categorical categories.\n             * Returns an empty array if none exists.\n             */\n            function getAllRolesInCategories(categoricalRoleMapping) {\n                debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\n                var roleNames = [];\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalRoleMapping.categories, {\n                    visitRole: function (roleName) {\n                        roleNames.push(roleName);\n                    }\n                });\n                return roleNames;\n            }\n            function applyConcatenation(dataView, objectDescriptors, roleName, columnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(roleName, 'roleName');\n                debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\n                var formatStringPropId = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                var concatenatedValues = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\n                var columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, function (categoryColumn) { return categoryColumn.source; });\n                var concatenatedColumnMetadata = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\n                var transformedDataView = inheritSingle(dataView);\n                addToMetadata(transformedDataView, concatenatedColumnMetadata);\n                var concatenatedCategoryColumn = createConcatenatedCategoryColumn(columnsSortedByProjectionOrdering, concatenatedColumnMetadata, concatenatedValues);\n                var dataViewCategorical = dataView.categorical;\n                var transformedCategoricalCategories = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\n                transformedCategoricalCategories.push(concatenatedCategoryColumn);\n                var transformedCategorical = inheritSingle(dataViewCategorical);\n                transformedCategorical.categories = transformedCategoricalCategories;\n                transformedDataView.categorical = transformedCategorical;\n                return transformedDataView;\n            }\n            function concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId) {\n                debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\n                debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\n                debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\n                var concatenatedValues = [];\n                // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\n                for (var _i = 0, columnsSortedByProjectionOrdering_1 = columnsSortedByProjectionOrdering; _i < columnsSortedByProjectionOrdering_1.length; _i++) {\n                    var categoryColumn = columnsSortedByProjectionOrdering_1[_i];\n                    var formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\n                    for (var i = 0, len = categoryColumn.values.length; i < len; i++) {\n                        if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\n                            var value = categoryColumn.values && categoryColumn.values[i];\n                            var formattedValue = valueFormatter.format(value, formatString);\n                            concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\n                        }\n                    }\n                }\n                return concatenatedValues;\n            }\n            /**\n            * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\n            */\n            function sortColumnsByProjectionOrdering(projectionOrdering, roleName, columns) {\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                debug.assertValue(roleName, 'roleName');\n                debug.assertValue(columns, 'columns');\n                var columnsInProjectionOrdering;\n                if (projectionOrdering) {\n                    // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\n                    var columnsByIndex_1 = {};\n                    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n                        var column = columns_1[_i];\n                        if (column.source.roles[roleName]) {\n                            debug.assert(!columnsByIndex_1[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\n                            columnsByIndex_1[column.source.index] = column;\n                        }\n                    }\n                    var columnIndicesInProjectionOrdering = projectionOrdering[roleName];\n                    columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\n                        .map(function (columnIndex) { return columnsByIndex_1[columnIndex]; })\n                        .filter(function (column) { return !!column; })\n                        .value();\n                }\n                else {\n                    // If projectionOrder is unspecified, just return the columns for the specified role in their current order\n                    columnsInProjectionOrdering = _.filter(columns, function (column) { return column.source.roles[roleName]; });\n                }\n                return columnsInProjectionOrdering;\n            }\n            /**\n             * Creates the column metadata that will back the column with the concatenated values.\n             */\n            function createConcatenatedColumnMetadata(roleName, sourceColumnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(roleName, 'roleName');\n                debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\n                debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(function (c) { return c.isMeasure; }).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\n                var concatenatedDisplayName;\n                for (var _i = 0, sourceColumnsSortedByProjectionOrdering_1 = sourceColumnsSortedByProjectionOrdering; _i < sourceColumnsSortedByProjectionOrdering_1.length; _i++) {\n                    var columnSource = sourceColumnsSortedByProjectionOrdering_1[_i];\n                    if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\n                        concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\n                    }\n                }\n                var newRoles = {};\n                newRoles[roleName] = true;\n                var newColumnMetadata = {\n                    displayName: concatenatedDisplayName,\n                    roles: newRoles,\n                    type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Text)\n                };\n                var columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\n                if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\n                    newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\n                }\n                // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\n                // If queryName is not set at all, the column chart visual will only render column for the first group instance.\n                // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\n                newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\n                return newColumnMetadata;\n            }\n            function addToMetadata(transformedDataView, newColumn) {\n                debug.assertValue(transformedDataView, 'transformedDataView');\n                debug.assertValue(newColumn, 'newColumn');\n                var transformedColumns = inheritSingle(transformedDataView.metadata.columns);\n                transformedColumns.push(newColumn);\n                var transformedMetadata = inheritSingle(transformedDataView.metadata);\n                transformedMetadata.columns = transformedColumns;\n                transformedDataView.metadata = transformedMetadata;\n            }\n            function createConcatenatedCategoryColumn(sourceColumnsSortedByProjectionOrdering, columnMetadata, concatenatedValues) {\n                debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\n                var newCategoryColumn = {\n                    source: columnMetadata,\n                    values: concatenatedValues\n                };\n                // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\n                // So, we'll just take the identities and identityFields from the first column\n                var firstColumn = sourceColumnsSortedByProjectionOrdering[0];\n                if (firstColumn.identity) {\n                    newCategoryColumn.identity = firstColumn.identity;\n                }\n                if (firstColumn.identityFields) {\n                    newCategoryColumn.identityFields = firstColumn.identityFields;\n                }\n                // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\n                if (firstColumn.objects) {\n                    newCategoryColumn.objects = firstColumn.objects;\n                }\n                return newCategoryColumn;\n            }\n        })(DataViewConcatenateCategoricalColumns = data.DataViewConcatenateCategoricalColumns || (data.DataViewConcatenateCategoricalColumns = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewMapping;\n    (function (DataViewMapping) {\n        function visitMapping(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var categorical = mapping.categorical;\n            if (categorical)\n                visitCategorical(categorical, visitor);\n            var table = mapping.table;\n            if (table)\n                visitTable(table, visitor);\n            var matrix = mapping.matrix;\n            if (matrix)\n                visitMatrix(matrix, visitor);\n            var tree = mapping.tree;\n            if (tree)\n                visitTree(tree, visitor);\n            var single = mapping.single;\n            if (single)\n                visitSingle(single, visitor);\n        }\n        DataViewMapping.visitMapping = visitMapping;\n        function visitCategorical(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitCategoricalCategories(mapping.categories, visitor);\n            visitCategoricalValues(mapping.values, visitor);\n        }\n        DataViewMapping.visitCategorical = visitCategorical;\n        function visitCategoricalCategories(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor);\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitCategoricalCategories = visitCategoricalCategories;\n        function visitCategoricalValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor, 0 /* CategoricalValue */);\n                visitFor(mapping, visitor, 0 /* CategoricalValue */);\n                visitList(mapping, visitor, 0 /* CategoricalValue */);\n                var groupedRoleMapping = mapping;\n                visitGrouped(groupedRoleMapping, visitor);\n                var group = groupedRoleMapping.group;\n                if (group) {\n                    for (var _i = 0, _a = group.select; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        visitBind(item, visitor, 1 /* CategoricalValueGroup */);\n                        visitFor(item, visitor, 1 /* CategoricalValueGroup */);\n                    }\n                }\n            }\n        }\n        DataViewMapping.visitCategoricalValues = visitCategoricalValues;\n        function visitTable(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var rows = mapping.rows;\n            visitBind(rows, visitor);\n            visitFor(rows, visitor);\n            visitList(rows, visitor);\n            visitReduction(rows, visitor);\n        }\n        DataViewMapping.visitTable = visitTable;\n        function visitMatrix(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitMatrixItems(mapping.rows, visitor);\n            visitMatrixItems(mapping.columns, visitor);\n            visitMatrixItems(mapping.values, visitor);\n        }\n        /**\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         *\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         * @param visitor The visitor.\n         */\n        function visitMatrixItems(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitMatrixItems = visitMatrixItems;\n        function visitTree(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitTreeNodes(mapping.nodes, visitor);\n            visitTreeValues(mapping.values, visitor);\n        }\n        function visitTreeNodes(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeNodes = visitTreeNodes;\n        function visitTreeValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeValues = visitTreeValues;\n        function visitBind(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var bind = mapping.bind;\n            if (bind) {\n                if (context != null)\n                    visitor.visitRole(bind.to, context);\n                else\n                    visitor.visitRole(bind.to);\n            }\n        }\n        function visitFor(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var forValue = mapping.for;\n            if (forValue) {\n                if (context != null)\n                    visitor.visitRole(forValue.in, context);\n                else\n                    visitor.visitRole(forValue.in);\n            }\n        }\n        function visitList(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var select = mapping.select;\n            if (select) {\n                for (var _i = 0, select_1 = select; _i < select_1.length; _i++) {\n                    var item = select_1[_i];\n                    visitBind(item, visitor, context);\n                    visitFor(item, visitor, context);\n                }\n            }\n        }\n        function visitGrouped(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (!mapping)\n                return;\n            var group = mapping.group;\n            if (group) {\n                visitor.visitRole(group.by);\n                visitReduction(group, visitor);\n            }\n        }\n        DataViewMapping.visitGrouped = visitGrouped;\n        function visitReduction(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (visitor.visitReduction) {\n                var reductionAlgorithm = mapping.dataReductionAlgorithm;\n                if (reductionAlgorithm) {\n                    visitor.visitReduction(reductionAlgorithm);\n                }\n            }\n        }\n        function visitSingle(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitor.visitRole(mapping.role);\n        }\n    })(DataViewMapping = powerbi.DataViewMapping || (powerbi.DataViewMapping = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewNormalizeValues;\n        (function (DataViewNormalizeValues) {\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                var rolesToNormalize = _.filter(options.dataRoles, function (role) { return !_.isEmpty(role.requiredTypes); });\n                filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\n            }\n            DataViewNormalizeValues.apply = apply;\n            function filterVariantMeasures(dataview, dataViewMappings, rolesToNormalize) {\n                debug.assertValue(dataview, 'dataview');\n                // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\n                    return;\n                var columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\n                var valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\n                var usedMappings = {};\n                for (var _i = 0, dataViewMappings_1 = dataViewMappings; _i < dataViewMappings_1.length; _i++) {\n                    var dataViewMapping = dataViewMappings_1[_i];\n                    // Get dataview specified in mappings which are also in dataview\n                    for (var dataViewMappingProp in dataViewMapping) {\n                        if (dataview[dataViewMappingProp] != null)\n                            usedMappings[dataViewMappingProp] = true;\n                    }\n                }\n                if (usedMappings['categorical'])\n                    filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\n                if (usedMappings['table'])\n                    filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\n                if (usedMappings['tree'])\n                    filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\n                if (usedMappings['matrix'])\n                    filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\n                if (usedMappings['single'])\n                    filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\n            }\n            DataViewNormalizeValues.filterVariantMeasures = filterVariantMeasures;\n            function generateMetadataColumnFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return false; };\n                var columnsToNormalize = {};\n                for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {\n                    var column = columns_2[_i];\n                    var roles = column.roles;\n                    if (!roles)\n                        continue;\n                    for (var _a = 0, rolesToNormalize_1 = rolesToNormalize; _a < rolesToNormalize_1.length; _a++) {\n                        var role = rolesToNormalize_1[_a];\n                        if (!roles[role.name])\n                            continue;\n                        columnsToNormalize[column.index] = true;\n                        break;\n                    }\n                }\n                return function (columnIndex) {\n                    if (isNaN(columnIndex))\n                        return false;\n                    return !!columnsToNormalize[columnIndex];\n                };\n            }\n            DataViewNormalizeValues.generateMetadataColumnFilter = generateMetadataColumnFilter;\n            function generateValueFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return true; };\n                var columnValueFilters = [];\n                // Build columnValueFilters based on role requiredTypes\n                for (var _i = 0, columns_3 = columns; _i < columns_3.length; _i++) {\n                    var column = columns_3[_i];\n                    var columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\n                    if (columnValueFilter)\n                        columnValueFilters[column.index] = columnValueFilter;\n                }\n                return function (columnIndex, value) {\n                    if (columnValueFilters[columnIndex])\n                        return columnValueFilters[columnIndex](value);\n                    return true;\n                };\n            }\n            DataViewNormalizeValues.generateValueFilter = generateValueFilter;\n            function generateColumnValueFilter(column, rolesToNormalize) {\n                var requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\n                if (_.isEmpty(requiredTypes))\n                    return;\n                return function (value) {\n                    return doesValueMatchTypes(value, requiredTypes);\n                };\n            }\n            function getColumnRequiredTypes(column, rolesToNormalize) {\n                var requiredTypes = [];\n                var columnRoles = column && column.roles;\n                if (!columnRoles)\n                    return requiredTypes;\n                for (var _i = 0, rolesToNormalize_2 = rolesToNormalize; _i < rolesToNormalize_2.length; _i++) {\n                    var role = rolesToNormalize_2[_i];\n                    if (!columnRoles[role.name])\n                        continue;\n                    for (var _a = 0, _b = role.requiredTypes; _a < _b.length; _a++) {\n                        var typeDescriptor = _b[_a];\n                        var type = powerbi.ValueType.fromDescriptor(typeDescriptor);\n                        requiredTypes.push(type);\n                    }\n                }\n                return requiredTypes;\n            }\n            DataViewNormalizeValues.getColumnRequiredTypes = getColumnRequiredTypes;\n            function filterVariantMeasuresCategorical(dataview, columnFilter, valueFilter) {\n                var values = dataview && dataview.values;\n                if (!values)\n                    return;\n                var valuesGrouped = values.grouped();\n                if (!valuesGrouped)\n                    return;\n                for (var _i = 0, valuesGrouped_1 = valuesGrouped; _i < valuesGrouped_1.length; _i++) {\n                    var valueGroup = valuesGrouped_1[_i];\n                    var valuesInGroup = valueGroup.values;\n                    for (var _a = 0, valuesInGroup_1 = valuesInGroup; _a < valuesInGroup_1.length; _a++) {\n                        var valueColumn = valuesInGroup_1[_a];\n                        var columnIndex = valueColumn.source.index;\n                        if (!columnFilter(columnIndex))\n                            continue;\n                        for (var i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\n                            valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\n                        }\n                    }\n                }\n            }\n            function filterVariantMeasuresTable(dataview, columnFilter, valueFilter) {\n                var columns = dataview && dataview.columns;\n                if (!columns)\n                    return;\n                var filteredColumns = [];\n                for (var _i = 0, columns_4 = columns; _i < columns_4.length; _i++) {\n                    var column = columns_4[_i];\n                    if (columnFilter(column.index))\n                        filteredColumns.push(column.index);\n                }\n                var rows = dataview.rows;\n                for (var i = 0, ilen = rows.length; i < ilen; i++) {\n                    for (var _a = 0, filteredColumns_1 = filteredColumns; _a < filteredColumns_1.length; _a++) {\n                        var index = filteredColumns_1[_a];\n                        rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresTreeNode(node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var columnIndex in node.values) {\n                        // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\n                        if (columnFilter(columnIndex)) {\n                            // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\n                            if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\n                                node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', columnIndex, valueFilter);\n                            else\n                                node.values = normalizeVariant(node.values, columnIndex, columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresMatrix(dataview, columnFilter, valueFilter) {\n                var root = dataview && dataview.rows && dataview.rows.root;\n                if (!root)\n                    return;\n                // Recurse into rows.children\n                // e.g. rows.children -> .children -> .children.values\n                filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\n            }\n            function filterVariantMeasuresMatrixRecursive(dataviewMatrix, node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var id in node.values) {\n                        // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\n                        var nodeValue = node.values[id];\n                        // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\n                        var valueSourceIndex = nodeValue.valueSourceIndex || 0;\n                        // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\n                        var columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\n                        if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\n                            node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter) {\n                if (!dataview.single)\n                    return;\n                var roleNames = [];\n                for (var _i = 0, rolesToNormalize_3 = rolesToNormalize; _i < rolesToNormalize_3.length; _i++) {\n                    var role = rolesToNormalize_3[_i];\n                    if (role.name)\n                        roleNames.push(role.name);\n                }\n                var columns = dataview.metadata.columns;\n                for (var _a = 0, dataViewMappings_2 = dataViewMappings; _a < dataViewMappings_2.length; _a++) {\n                    var dataViewMapping = dataViewMappings_2[_a];\n                    var roleName = dataViewMapping.single.role;\n                    if (roleNames.indexOf(roleName) !== -1) {\n                        var column = firstColumnByRoleName(columns, roleName);\n                        if (column)\n                            dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\n                        return;\n                    }\n                }\n            }\n            function normalizeVariant(object, key, columnIndex, valueFilter) {\n                if (!object)\n                    return;\n                var value = object[key];\n                if (value !== null && !valueFilter(columnIndex, value)) {\n                    object = inheritSingle(object);\n                    object[key] = null;\n                }\n                return object;\n            }\n            DataViewNormalizeValues.normalizeVariant = normalizeVariant;\n            function doesValueMatchTypes(value, types) {\n                for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n                    var type = types_1[_i];\n                    if (type.numeric || type.integer)\n                        return typeof (value) === 'number';\n                }\n                return false;\n            }\n            function firstColumnByRoleName(columns, roleName) {\n                for (var _i = 0, columns_5 = columns; _i < columns_5.length; _i++) {\n                    var column = columns_5[_i];\n                    var columnRoles = column && column.roles;\n                    if (columnRoles && columnRoles[roleName])\n                        return column;\n                }\n            }\n        })(DataViewNormalizeValues = data.DataViewNormalizeValues || (data.DataViewNormalizeValues = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewObjects;\n    (function (DataViewObjects) {\n        /** Gets the value of the given object/property pair. */\n        function getValue(objects, propertyId, defaultValue) {\n            debug.assertAnyValue(objects, 'objects');\n            debug.assertValue(propertyId, 'propertyId');\n            if (!objects)\n                return defaultValue;\n            var objectOrMap = objects[propertyId.objectName];\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\n            var object = objectOrMap;\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\n        }\n        DataViewObjects.getValue = getValue;\n        /** Gets an object from objects. */\n        function getObject(objects, objectName, defaultValue) {\n            if (objects && objects[objectName]) {\n                var object = objects[objectName];\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\n                return object;\n            }\n            else {\n                return defaultValue;\n            }\n        }\n        DataViewObjects.getObject = getObject;\n        /** Gets a map of user-defined objects. */\n        function getUserDefinedObjects(objects, objectName) {\n            if (objects && objects[objectName]) {\n                var map = objects[objectName];\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\n                return map;\n            }\n        }\n        DataViewObjects.getUserDefinedObjects = getUserDefinedObjects;\n        /** Gets the solid color from a fill property. */\n        function getFillColor(objects, propertyId, defaultColor) {\n            var value = getValue(objects, propertyId);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObjects.getFillColor = getFillColor;\n        /** Returns true if the given object represents a collection of user-defined objects */\n        function isUserDefined(objectOrMap) {\n            return _.isArray(objectOrMap);\n        }\n        DataViewObjects.isUserDefined = isUserDefined;\n    })(DataViewObjects = powerbi.DataViewObjects || (powerbi.DataViewObjects = {}));\n    var DataViewObject;\n    (function (DataViewObject) {\n        function getValue(object, propertyName, defaultValue) {\n            debug.assertAnyValue(object, 'object');\n            debug.assertValue(propertyName, 'propertyName');\n            if (!object)\n                return defaultValue;\n            var propertyValue = object[propertyName];\n            if (propertyValue === undefined)\n                return defaultValue;\n            return propertyValue;\n        }\n        DataViewObject.getValue = getValue;\n        /** Gets the solid color from a fill property using only a propertyName */\n        function getFillColorByPropertyName(objects, propertyName, defaultColor) {\n            var value = DataViewObject.getValue(objects, propertyName);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;\n    })(DataViewObject = powerbi.DataViewObject || (powerbi.DataViewObject = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var JsonComparer = jsCommon.JsonComparer;\n        var DataViewObjectDefinitions;\n        (function (DataViewObjectDefinitions) {\n            /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\n            function ensure(defns, objectName, selector) {\n                debug.assertValue(defns, 'defns');\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    defns[objectName] = defnsForObject = [];\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n                var newDefn = {\n                    selector: selector,\n                    properties: {},\n                };\n                defnsForObject.push(newDefn);\n                return newDefn;\n            }\n            DataViewObjectDefinitions.ensure = ensure;\n            function deleteProperty(defns, objectName, selector, propertyName) {\n                debug.assertValue(defns, 'defns');\n                var defn = getObjectDefinition(defns, objectName, selector);\n                if (!defn)\n                    return;\n                DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\n            }\n            DataViewObjectDefinitions.deleteProperty = deleteProperty;\n            function setValue(defns, propertyId, selector, value) {\n                debug.assertValue(defns, 'defns');\n                debug.assertValue(propertyId, 'propertyId');\n                ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\n            }\n            DataViewObjectDefinitions.setValue = setValue;\n            function getValue(defns, propertyId, selector) {\n                var properties = getPropertyContainer(defns, propertyId, selector);\n                if (!properties)\n                    return;\n                return properties[propertyId.propertyName];\n            }\n            DataViewObjectDefinitions.getValue = getValue;\n            function getPropertyContainer(defns, propertyId, selector) {\n                var defn = getObjectDefinition(defns, propertyId.objectName, selector);\n                if (!defn)\n                    return;\n                return defn.properties;\n            }\n            DataViewObjectDefinitions.getPropertyContainer = getPropertyContainer;\n            function getObjectDefinition(defns, objectName, selector) {\n                debug.assertAnyValue(defns, 'defns');\n                debug.assertValue(objectName, 'objectName');\n                debug.assertAnyValue(selector, 'selector');\n                if (!defns)\n                    return;\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    return;\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n            }\n            DataViewObjectDefinitions.getObjectDefinition = getObjectDefinition;\n            function propertiesAreEqual(a, b) {\n                if (a instanceof data.SemanticFilter && b instanceof data.SemanticFilter) {\n                    return data.SemanticFilter.isSameFilter(a, b);\n                }\n                return JsonComparer.equals(a, b);\n            }\n            DataViewObjectDefinitions.propertiesAreEqual = propertiesAreEqual;\n            function allPropertiesAreEqual(a, b) {\n                debug.assertValue(a, 'a');\n                debug.assertValue(b, 'b');\n                if (Object.keys(a).length !== Object.keys(b).length)\n                    return false;\n                for (var property in a) {\n                    if (!propertiesAreEqual(a[property], b[property]))\n                        return false;\n                }\n                return true;\n            }\n            DataViewObjectDefinitions.allPropertiesAreEqual = allPropertiesAreEqual;\n            function encodePropertyValue(value, valueTypeDescriptor) {\n                debug.assertAnyValue(value, 'value');\n                debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\n                if (valueTypeDescriptor.bool) {\n                    if (typeof (value) !== 'boolean')\n                        value = false; // This is fallback, which doesn't really belong here.\n                    return data.SQExprBuilder.boolean(value);\n                }\n                else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\n                    return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.numeric) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                }\n                else if (valueTypeDescriptor.fill) {\n                    if (value) {\n                        return {\n                            solid: { color: data.SQExprBuilder.text(value) }\n                        };\n                    }\n                }\n                else if (valueTypeDescriptor.formatting) {\n                    if (valueTypeDescriptor.formatting.labelDisplayUnits) {\n                        return data.SQExprBuilder.double(+value);\n                    }\n                    else {\n                        return data.SQExprBuilder.text(value);\n                    }\n                }\n                else if (valueTypeDescriptor.enumeration) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                    else\n                        return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.misc) {\n                    if (value) {\n                        value = data.SQExprBuilder.text(value);\n                    }\n                    else {\n                        value = null;\n                    }\n                }\n                else if (valueTypeDescriptor.image) {\n                    if (value) {\n                        var imageValue = value;\n                        var imageDefinition = {\n                            name: data.SQExprBuilder.text(imageValue.name),\n                            url: data.SQExprBuilder.text(imageValue.url),\n                        };\n                        if (imageValue.scaling)\n                            imageDefinition.scaling = data.SQExprBuilder.text(imageValue.scaling);\n                        return imageDefinition;\n                    }\n                }\n                return value;\n            }\n            DataViewObjectDefinitions.encodePropertyValue = encodePropertyValue;\n            function clone(original) {\n                debug.assertValue(original, 'original');\n                var cloned = {};\n                for (var objectName in original) {\n                    var originalDefns = original[objectName];\n                    if (_.isEmpty(originalDefns))\n                        continue;\n                    var clonedDefns = [];\n                    for (var _i = 0, originalDefns_1 = originalDefns; _i < originalDefns_1.length; _i++) {\n                        var originalDefn = originalDefns_1[_i];\n                        clonedDefns.push({\n                            properties: cloneProperties(originalDefn.properties),\n                            selector: originalDefn.selector,\n                        });\n                    }\n                    cloned[objectName] = clonedDefns;\n                }\n                return cloned;\n            }\n            DataViewObjectDefinitions.clone = clone;\n            function cloneProperties(original) {\n                debug.assertValue(original, 'original');\n                // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\n                return _.clone(original);\n            }\n        })(DataViewObjectDefinitions = data.DataViewObjectDefinitions || (data.DataViewObjectDefinitions = {}));\n        var DataViewObjectDefinition;\n        (function (DataViewObjectDefinition) {\n            function deleteSingleProperty(defn, propertyName) {\n                //note: We decided that delete is acceptable here and that we don't need optimization here\n                delete defn.properties[propertyName];\n            }\n            DataViewObjectDefinition.deleteSingleProperty = deleteSingleProperty;\n        })(DataViewObjectDefinition = data.DataViewObjectDefinition || (data.DataViewObjectDefinition = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectDescriptors;\n        (function (DataViewObjectDescriptors) {\n            /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\n            function findFormatString(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var formattingTypeDesc = powerbi.ValueType.fromDescriptor(propDesc.type).formatting;\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\n                });\n            }\n            DataViewObjectDescriptors.findFormatString = findFormatString;\n            /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\n            function findFilterOutput(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.filter;\n                });\n            }\n            DataViewObjectDescriptors.findFilterOutput = findFilterOutput;\n            /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\n            function findDefaultValue(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.expression && propType.expression.defaultValue;\n                });\n            }\n            DataViewObjectDescriptors.findDefaultValue = findDefaultValue;\n            function findProperty(descriptors, propPredicate) {\n                debug.assertAnyValue(descriptors, 'descriptors');\n                debug.assertAnyValue(propPredicate, 'propPredicate');\n                if (!descriptors)\n                    return;\n                for (var objectName in descriptors) {\n                    var objPropDescs = descriptors[objectName].properties;\n                    for (var propertyName in objPropDescs) {\n                        if (propPredicate(objPropDescs[propertyName])) {\n                            return {\n                                objectName: objectName,\n                                propertyName: propertyName,\n                            };\n                        }\n                    }\n                }\n            }\n        })(DataViewObjectDescriptors = data.DataViewObjectDescriptors || (data.DataViewObjectDescriptors = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n*  Power BI Visualizations\n*\n*  Copyright (c) Microsoft Corporation\n*  All rights reserved.\n *  MIT License\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n*\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n*  THE SOFTWARE.\n*/\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectEvaluationUtils;\n        (function (DataViewObjectEvaluationUtils) {\n            function evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var objects;\n                for (var j = 0, jlen = objectDefns.length; j < jlen; j++) {\n                    var objectDefinition = objectDefns[j], objectName = objectDefinition.name;\n                    var evaluatedObject = data.DataViewObjectEvaluator.run(evalContext, objectDescriptors[objectName], objectDefinition.properties);\n                    if (!evaluatedObject)\n                        continue;\n                    if (!objects)\n                        objects = {};\n                    // NOTE: this currently has last-object-wins semantics.\n                    objects[objectName] = evaluatedObject;\n                }\n                return objects;\n            }\n            DataViewObjectEvaluationUtils.evaluateDataViewObjects = evaluateDataViewObjects;\n            function groupObjectsBySelector(objectDefinitions) {\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                var grouped = {\n                    data: [],\n                };\n                if (objectDefinitions) {\n                    for (var objectName in objectDefinitions) {\n                        var objectDefnList = objectDefinitions[objectName];\n                        for (var i = 0, len = objectDefnList.length; i < len; i++) {\n                            var objectDefn = objectDefnList[i];\n                            ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\n                                name: objectName,\n                                properties: objectDefn.properties,\n                            });\n                        }\n                    }\n                }\n                return grouped;\n            }\n            DataViewObjectEvaluationUtils.groupObjectsBySelector = groupObjectsBySelector;\n            function ensureDefinitionListForSelector(grouped, selector) {\n                debug.assertValue(grouped, 'grouped');\n                debug.assertAnyValue(selector, 'selector');\n                if (!selector) {\n                    if (!grouped.metadataOnce)\n                        grouped.metadataOnce = { objects: [] };\n                    return grouped.metadataOnce;\n                }\n                var groupedObjects;\n                if (selector.data) {\n                    groupedObjects = grouped.data;\n                }\n                else if (selector.metadata) {\n                    if (!grouped.metadata)\n                        grouped.metadata = [];\n                    groupedObjects = grouped.metadata;\n                }\n                else if (selector.id) {\n                    if (!grouped.userDefined)\n                        grouped.userDefined = [];\n                    groupedObjects = grouped.userDefined;\n                }\n                debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\n                for (var _i = 0, groupedObjects_1 = groupedObjects; _i < groupedObjects_1.length; _i++) {\n                    var item_1 = groupedObjects_1[_i];\n                    if (data.Selector.equals(selector, item_1.selector))\n                        return item_1;\n                }\n                var item = {\n                    selector: selector,\n                    objects: [],\n                };\n                groupedObjects.push(item);\n                return item;\n            }\n            function addImplicitObjects(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                if (selectTransforms) {\n                    addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                    addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                }\n            }\n            DataViewObjectEvaluationUtils.addImplicitObjects = addImplicitObjects;\n            function addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                if (!formatStringProp)\n                    return;\n                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                    var selectTransform = selectTransforms[selectIdx];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyFormatString(objectsForAllSelectors, formatStringProp, selectTransform.queryName, selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\n                }\n            }\n            /** Registers properties for default value, if the properties are not explicitly provided. */\n            function addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var defaultValueProp = data.DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\n                if (!defaultValueProp)\n                    return;\n                for (var _i = 0, selectTransforms_1 = selectTransforms; _i < selectTransforms_1.length; _i++) {\n                    var selectTransform = selectTransforms_1[_i];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyDefaultValue(objectsForAllSelectors, defaultValueProp, selectTransform.queryName, selectTransform.defaultValue);\n                }\n            }\n            function getColumnFormatForIndex(columns, selectIdx) {\n                for (var columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\n                    var column = columns[columnIdx];\n                    if (!column || column.index !== selectIdx)\n                        continue;\n                    return column.format;\n                }\n            }\n            function applyFormatString(objectsForAllSelectors, formatStringProp, queryName, formatStringValue) {\n                if (!formatStringValue)\n                    return;\n                // There is a format string specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, formatStringProp, { metadata: queryName }, data.SQExprBuilder.text(formatStringValue));\n            }\n            function applyDefaultValue(objectsForAllSelectors, defaultValueProp, queryName, defaultValue) {\n                if (!defaultValue)\n                    return;\n                // There is a default value specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, defaultValueProp, { metadata: queryName }, defaultValue);\n            }\n            function applyMetadataProperty(objectsForAllSelectors, propertyId, selector, value) {\n                var objectDefns;\n                if (selector) {\n                    var metadataObjects = objectsForAllSelectors.metadata;\n                    if (!metadataObjects)\n                        metadataObjects = objectsForAllSelectors.metadata = [];\n                    objectDefns = metadataObjects;\n                }\n                else {\n                    var metadataOnce = objectsForAllSelectors.metadataOnce;\n                    if (!metadataOnce)\n                        metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\n                    objectDefns = [metadataOnce];\n                }\n                var targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\n                var targetObjectDefn;\n                if (targetMetadataObject) {\n                    var targetObjectDefns = targetMetadataObject.objects;\n                    targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\n                    if (targetObjectDefn) {\n                        if (targetObjectDefn.properties[propertyId.propertyName])\n                            return;\n                    }\n                    else {\n                        targetObjectDefn = {\n                            name: propertyId.objectName,\n                            properties: {},\n                        };\n                        targetObjectDefns.push(targetObjectDefn);\n                    }\n                }\n                else {\n                    targetObjectDefn = {\n                        name: propertyId.objectName,\n                        properties: {}\n                    };\n                    objectDefns.push({\n                        selector: selector,\n                        objects: [targetObjectDefn],\n                    });\n                }\n                targetObjectDefn.properties[propertyId.propertyName] = value;\n            }\n            function findWithMatchingSelector(objects, selector) {\n                debug.assertValue(objects, 'objects');\n                debug.assertAnyValue(selector, 'selector');\n                for (var i = 0, len = objects.length; i < len; i++) {\n                    var object = objects[i];\n                    if (data.Selector.equals(object.selector, selector))\n                        return object;\n                }\n            }\n            function findExistingObject(objectDefns, objectName) {\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(objectName, 'objectName');\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefn = objectDefns[i];\n                    if (objectDefn.name === objectName)\n                        return objectDefn;\n                }\n            }\n        })(DataViewObjectEvaluationUtils = data.DataViewObjectEvaluationUtils || (data.DataViewObjectEvaluationUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\n        var DataViewObjectEvaluator;\n        (function (DataViewObjectEvaluator) {\n            var colorValueType = powerbi.ValueType.fromDescriptor({ formatting: { color: true } });\n            var numericType = powerbi.ValueType.fromDescriptor({ numeric: true });\n            var textType = powerbi.ValueType.fromDescriptor({ text: true });\n            function run(evalContext, objectDescriptor, propertyDefinitions) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\n                debug.assertValue(propertyDefinitions, 'propertyDefinitions');\n                if (!objectDescriptor)\n                    return;\n                var object, propertyDescriptors = objectDescriptor.properties;\n                for (var propertyName in propertyDefinitions) {\n                    var propertyDefinition = propertyDefinitions[propertyName], propertyDescriptor = propertyDescriptors[propertyName];\n                    if (!propertyDescriptor)\n                        continue;\n                    var propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\n                    if (propertyValue === undefined)\n                        continue;\n                    if (!object)\n                        object = {};\n                    object[propertyName] = propertyValue;\n                }\n                return object;\n            }\n            DataViewObjectEvaluator.run = run;\n            /** Note: Exported for testability */\n            function evaluateProperty(evalContext, propertyDescriptor, propertyDefinition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(propertyDescriptor, 'propertyDescriptor');\n                debug.assertValue(propertyDefinition, 'propertyDefinition');\n                var structuralType = propertyDescriptor.type;\n                if (structuralType && structuralType.expression)\n                    return propertyDefinition;\n                var value = evaluateValue(evalContext, propertyDefinition, powerbi.ValueType.fromDescriptor(propertyDescriptor.type));\n                if (value !== undefined || (propertyDefinition instanceof data.RuleEvaluation))\n                    return value;\n                return evaluateFill(evalContext, propertyDefinition, structuralType)\n                    || evaluateFillRule(evalContext, propertyDefinition, structuralType)\n                    || evaluateImage(evalContext, propertyDefinition, structuralType)\n                    || evaluateParagraphs(evalContext, propertyDefinition, structuralType)\n                    || propertyDefinition;\n            }\n            DataViewObjectEvaluator.evaluateProperty = evaluateProperty;\n            function evaluateFill(evalContext, fillDefn, type) {\n                var fillType = type.fill;\n                if (!fillType)\n                    return;\n                if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\n                    return {\n                        solid: {\n                            color: evaluateValue(evalContext, fillDefn.solid.color, powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Color)),\n                        }\n                    };\n                }\n            }\n            function evaluateFillRule(evalContext, fillRuleDefn, type) {\n                if (!type.fillRule)\n                    return;\n                if (fillRuleDefn.linearGradient2) {\n                    var linearGradient2 = fillRuleDefn.linearGradient2;\n                    return {\n                        linearGradient2: {\n                            min: evaluateColorStop(evalContext, linearGradient2.min),\n                            max: evaluateColorStop(evalContext, linearGradient2.max),\n                        }\n                    };\n                }\n                if (fillRuleDefn.linearGradient3) {\n                    var linearGradient3 = fillRuleDefn.linearGradient3;\n                    return {\n                        linearGradient3: {\n                            min: evaluateColorStop(evalContext, linearGradient3.min),\n                            mid: evaluateColorStop(evalContext, linearGradient3.mid),\n                            max: evaluateColorStop(evalContext, linearGradient3.max),\n                        }\n                    };\n                }\n            }\n            function evaluateColorStop(evalContext, colorStop) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(colorStop, 'colorStop');\n                var step = {\n                    color: evaluateValue(evalContext, colorStop.color, colorValueType),\n                };\n                var value = evaluateValue(evalContext, colorStop.value, numericType);\n                if (value != null)\n                    step.value = value;\n                return step;\n            }\n            function evaluateImage(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.image || !definition)\n                    return;\n                var value = {\n                    name: evaluateValue(evalContext, definition.name, textType),\n                    url: evaluateValue(evalContext, definition.url, powerbi.ValueType.fromDescriptor(powerbi.ImageDefinition.urlType)),\n                };\n                if (definition.scaling)\n                    value.scaling = evaluateValue(evalContext, definition.scaling, textType);\n                return value;\n            }\n            function evaluateParagraphs(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.paragraphs || !definition)\n                    return;\n                return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\n            }\n            function evaluateParagraph(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionTextRuns = definition.textRuns;\n                var evaluatedTextRuns = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\n                if (definitionTextRuns !== evaluatedTextRuns) {\n                    evaluated = _.clone(definition);\n                    evaluated.textRuns = evaluatedTextRuns;\n                }\n                return evaluated || definition;\n            }\n            function evaluateTextRun(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionValue = definition.value;\n                var evaluatedValue = evaluateValue(evalContext, definitionValue, textType);\n                if (evaluatedValue !== undefined) {\n                    evaluated = _.clone(definition);\n                    evaluated.value = evaluatedValue;\n                }\n                return evaluated || definition;\n            }\n            /**\n             * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\n             * other than the input to it.\n             */\n            function evaluateArrayCopyOnChange(evalContext, definitions, evaluator) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definitions, 'definitions');\n                debug.assertValue(evaluator, 'evaluator');\n                var evaluatedValues;\n                for (var i = 0, len = definitions.length; i < len; i++) {\n                    var definition = definitions[i];\n                    var evaluated = evaluator(evalContext, definition);\n                    // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\n                    // between TEvaluated & TDefinition\n                    if (!evaluatedValues && definition !== evaluated) {\n                        evaluatedValues = _.take(definitions, i);\n                    }\n                    if (evaluatedValues) {\n                        evaluatedValues.push(evaluated);\n                    }\n                }\n                return evaluatedValues || definitions;\n            }\n            function evaluateValue(evalContext, definition, valueType) {\n                if (definition instanceof data.SQExpr)\n                    return ExpressionEvaluator.evaluate(definition, evalContext);\n                if (definition instanceof data.RuleEvaluation)\n                    return definition.evaluate(evalContext);\n            }\n            /** Responsible for evaluating SQExprs into values. */\n            var ExpressionEvaluator = (function (_super) {\n                __extends(ExpressionEvaluator, _super);\n                function ExpressionEvaluator() {\n                    _super.apply(this, arguments);\n                }\n                ExpressionEvaluator.evaluate = function (expr, evalContext) {\n                    if (expr == null)\n                        return;\n                    return expr.accept(ExpressionEvaluator.instance, evalContext);\n                };\n                ExpressionEvaluator.prototype.visitColumnRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitConstant = function (expr, evalContext) {\n                    return expr.value;\n                };\n                ExpressionEvaluator.prototype.visitMeasureRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitAggr = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitFillRule = function (expr, evalContext) {\n                    var inputValue = expr.input.accept(this, evalContext);\n                    if (inputValue !== undefined) {\n                        var colorAllocator = evalContext.getColorAllocator(expr);\n                        if (colorAllocator) {\n                            return colorAllocator.color(inputValue);\n                        }\n                    }\n                };\n                ExpressionEvaluator.prototype.visitSelectRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.instance = new ExpressionEvaluator();\n                return ExpressionEvaluator;\n            }(data.DefaultSQExprVisitorWithArg));\n        })(DataViewObjectEvaluator = data.DataViewObjectEvaluator || (data.DataViewObjectEvaluator = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var DataViewPivotCategorical;\n        (function (DataViewPivotCategorical) {\n            /**\n             * Pivots categories in a categorical DataView into valueGroupings.\n             * This is akin to a mathematical matrix transpose.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                var categorical = dataView.categorical;\n                if (!categorical)\n                    return null;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return null;\n                var values = categorical.values;\n                if (_.isEmpty(values) || values.source)\n                    return null;\n                var category = categories[0], categoryIdentities = category.identity, categoryValues = category.values, pivotedColumns = [], pivotedValues = [];\n                for (var rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\n                    var categoryValue = categoryValues[rowIdx], categoryIdentity = categoryIdentities[rowIdx];\n                    for (var colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\n                        var value = values[colIdx], pivotedColumn = inherit(value.source);\n                        // A value has a series group, which is not implemented for pivoting -- just give up.\n                        if (value.identity)\n                            return null;\n                        pivotedColumn.groupName = categoryValue;\n                        var pivotedValue = {\n                            source: pivotedColumn,\n                            values: [value.values[rowIdx]],\n                            identity: categoryIdentity,\n                            min: value.min,\n                            max: value.max,\n                            subtotal: value.subtotal\n                        };\n                        var highlights = value.highlights;\n                        if (highlights) {\n                            pivotedValue.highlights = [highlights[rowIdx]];\n                        }\n                        pivotedColumns.push(pivotedColumn);\n                        pivotedValues.push(pivotedValue);\n                    }\n                }\n                var pivotedMetadata = inherit(dataView.metadata);\n                pivotedMetadata.columns = pivotedColumns;\n                values = data.DataViewTransform.createValueColumns(pivotedValues, category.identityFields, category.source);\n                return {\n                    metadata: pivotedMetadata,\n                    categorical: {\n                        values: values,\n                    },\n                    matrix: dataView.matrix\n                };\n            }\n            DataViewPivotCategorical.apply = apply;\n        })(DataViewPivotCategorical = data.DataViewPivotCategorical || (data.DataViewPivotCategorical = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewPivotMatrix;\n        (function (DataViewPivotMatrix) {\n            /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\n            function apply(dataViewMatrix, context) {\n                debug.assertValue(dataViewMatrix, 'dataViewMatrix');\n                if (!context.columnHierarchyRewritten)\n                    dataViewMatrix.columns = powerbi.Prototype.inherit(dataViewMatrix.columns);\n                var columns = dataViewMatrix.columns;\n                if (!context.rowHierarchyRewritten)\n                    dataViewMatrix.rows = powerbi.Prototype.inherit(dataViewMatrix.rows);\n                var rows = dataViewMatrix.rows;\n                if (columns.levels.length > 1)\n                    return;\n                var pivotedRowNode = {\n                    level: 0\n                };\n                var columnLeafNodes = columns.root.children;\n                var measureCount = columnLeafNodes.length;\n                // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\n                // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\n                // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \n                // in a matrix with 2+ column fields and 2+ measure fields.\n                // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\n                // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\n                var pivotResultMeasureHeaderLevel = rows.levels.length;\n                if (measureCount > 0) {\n                    var index_1 = 0;\n                    var callback = function (node) {\n                        // Collect values and remove them from row leaves\n                        if (node.values) {\n                            if (!pivotedRowNode.values)\n                                pivotedRowNode.values = {};\n                            for (var i = 0; i < measureCount; i++)\n                                pivotedRowNode.values[index_1++] = node.values[i];\n                            delete node.values;\n                        }\n                        // Create measure headers if there are more than one measures\n                        if (measureCount > 1) {\n                            if (!node.children)\n                                node.children = [];\n                            for (var j = 0; j < measureCount; j++) {\n                                var measureHeaderLeaf = { level: pivotResultMeasureHeaderLevel };\n                                // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\n                                var columnLeafNode = columnLeafNodes[j];\n                                measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\n                                if (node.isSubtotal)\n                                    measureHeaderLeaf.isSubtotal = true;\n                                node.children.push(measureHeaderLeaf);\n                            }\n                        }\n                    };\n                    if (context.hierarchyTreesRewritten) {\n                        forEachLeaf(rows.root, callback);\n                    }\n                    else {\n                        dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\n                    }\n                }\n                else {\n                    if (!context.hierarchyTreesRewritten) {\n                        dataViewMatrix.columns.root = cloneTree(rows.root);\n                    }\n                }\n                if (measureCount > 1) {\n                    // Keep measure headers, but move them to the innermost level\n                    var level = { sources: columns.levels[0].sources };\n                    rows.levels.push(level);\n                    columns.levels.length = 0;\n                }\n                if (context.hierarchyTreesRewritten) {\n                    dataViewMatrix.columns.root = rows.root;\n                    dataViewMatrix.rows.root = {\n                        children: [pivotedRowNode]\n                    };\n                }\n                else {\n                    var updatedRowRoot = powerbi.Prototype.inherit(dataViewMatrix.rows.root);\n                    updatedRowRoot.children = [pivotedRowNode];\n                    dataViewMatrix.rows.root = updatedRowRoot;\n                }\n                dataViewMatrix.columns.levels = rows.levels;\n                dataViewMatrix.rows.levels = [];\n            }\n            DataViewPivotMatrix.apply = apply;\n            function forEachLeaf(root, callback) {\n                var children = root.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachLeaf(children[i], callback);\n                    return;\n                }\n                callback(root);\n            }\n            function cloneTree(node) {\n                return cloneTreeExecuteOnLeaf(node);\n            }\n            DataViewPivotMatrix.cloneTree = cloneTree;\n            function cloneTreeExecuteOnLeaf(node, callback) {\n                var updatedNode = powerbi.Prototype.inherit(node);\n                var children = node.children;\n                if (children && children.length > 0) {\n                    var newChildren = [];\n                    for (var i = 0, ilen = children.length; i < ilen; i++) {\n                        var updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\n                        newChildren.push(updatedChild);\n                    }\n                    updatedNode.children = newChildren;\n                }\n                else {\n                    if (callback)\n                        callback(updatedNode);\n                }\n                return updatedNode;\n            }\n            DataViewPivotMatrix.cloneTreeExecuteOnLeaf = cloneTreeExecuteOnLeaf;\n        })(DataViewPivotMatrix = data.DataViewPivotMatrix || (data.DataViewPivotMatrix = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelfCrossJoin;\n        (function (DataViewSelfCrossJoin) {\n            /**\n             * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\n             * to itself as a value grouping.\n             * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                if (!dataView.categorical)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\n                    return;\n                if (dataViewCategorical.values && dataViewCategorical.values.source)\n                    return;\n                return applyCategorical(dataView.metadata, dataViewCategorical);\n            }\n            DataViewSelfCrossJoin.apply = apply;\n            function applyCategorical(dataViewMetadata, dataViewCategorical) {\n                debug.assertValue(dataViewMetadata, 'dataViewMetadata');\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\n                var category = dataViewCategorical.categories[0], categoryValues = category.values, categoryLength = categoryValues.length;\n                if (categoryLength === 0)\n                    return;\n                var valuesArray = dataViewCategorical.values\n                    ? dataViewCategorical.values.grouped()[0].values\n                    : [];\n                var transformedDataView = data.createCategoricalDataViewBuilder()\n                    .withCategories(dataViewCategorical.categories)\n                    .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\n                    .build();\n                dataViewMetadata = powerbi.Prototype.inherit(dataViewMetadata);\n                dataViewMetadata.columns = transformedDataView.metadata.columns;\n                return {\n                    metadata: dataViewMetadata,\n                    categorical: transformedDataView.categorical,\n                };\n            }\n            function createGroupedValues(category, categoryValues, categoryLength, valuesArray) {\n                debug.assertValue(category, 'category');\n                debug.assertValue(categoryValues, 'categoryValues');\n                debug.assertValue(categoryLength, 'categoryLength');\n                debug.assertValue(valuesArray, 'valuesArray');\n                var nullValuesArray = createNullValues(categoryLength), valuesArrayLen = valuesArray.length, seriesData = [];\n                for (var i = 0; i < categoryLength; i++) {\n                    var seriesDataItem = [];\n                    for (var j = 0; j < valuesArrayLen; j++) {\n                        var originalValueColumn = valuesArray[j], originalHighlightValues = originalValueColumn.highlights;\n                        var seriesDataItemCategory = {\n                            values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\n                        };\n                        if (originalHighlightValues)\n                            seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\n                        seriesDataItem.push(seriesDataItemCategory);\n                    }\n                    seriesData.push(seriesDataItem);\n                }\n                return {\n                    groupColumn: {\n                        source: category.source,\n                        identityFrom: { fields: category.identityFields, identities: category.identity },\n                        values: category.values,\n                    },\n                    valueColumns: _.map(valuesArray, function (v) { return { source: v.source }; }),\n                    data: seriesData,\n                };\n            }\n        })(DataViewSelfCrossJoin = data.DataViewSelfCrossJoin || (data.DataViewSelfCrossJoin = {}));\n        function createNullValues(length) {\n            debug.assertValue(length, 'length');\n            var array = new Array(length);\n            for (var i = 0; i < length; i++)\n                array[i] = null;\n            return array;\n        }\n        function inheritArrayWithValue(nullValues, original, index) {\n            var inherited = powerbi.Prototype.inherit(nullValues);\n            inherited[index] = original[index];\n            return inherited;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewPivotCategoricalToPrimaryGroups;\n        (function (DataViewPivotCategoricalToPrimaryGroups) {\n            /**\n             * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\n             * pivot the secondary before the primary.\n             */\n            function pivotBinding(binding, allMappings, finalMapping, defaultDataVolume) {\n                // unpivot is inferred from result in DataViewTransform.apply but it does not have the\n                // compiled mappings available, let alone the merged mapping, only the original\n                // DataViewMappings. to keep that inference easy, only apply pivot when there's\n                // only one matching mapping\n                if (!allMappings || allMappings.length !== 1)\n                    return;\n                if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\n                    return;\n                if (!binding)\n                    return;\n                if (!canPivotCategorical(binding, finalMapping))\n                    return;\n                // pivot secondary onto front of primary\n                binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\n                binding.Secondary = undefined;\n                // set primary to pivot reduction\n                binding.DataReduction = {\n                    Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\n                    DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\n                };\n            }\n            DataViewPivotCategoricalToPrimaryGroups.pivotBinding = pivotBinding;\n            /** narrowly targets scatter chart scenario for now to keep code simple */\n            function isPivotableAxis(axis) {\n                return axis\n                    && axis.Groupings\n                    && axis.Groupings.length === 1\n                    && !_.isEmpty(axis.Groupings[0].Projections)\n                    && !axis.Groupings[0].Subtotal\n                    && _.isEmpty(axis.Groupings[0].SuppressedProjections);\n            }\n            function canPivotCategorical(binding, mapping) {\n                if (!isPivotableAxis(binding.Primary))\n                    return false;\n                if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\n                    return false;\n                // don't pivot if either axis has a data reduction\n                if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\n                    return false;\n                return true;\n            }\n            function unpivotResult(oldDataView, selects, dataViewMappings, projectionActiveItems) {\n                if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\n                    return oldDataView;\n                // This returns a subsetted version of the DataView rather than using prototypal inheritance because\n                // any dataviews in the old one (including ones invented after this code is written) will correspond\n                // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\n                // querying code made.\n                var newDataView = {\n                    metadata: {\n                        columns: ArrayExtensions.copy(oldDataView.metadata.columns),\n                    },\n                };\n                // preserve view types that aren't affected by pivoting\n                if (oldDataView.single)\n                    newDataView.single = oldDataView.single;\n                if (oldDataView.table)\n                    newDataView.table = oldDataView.table;\n                // other views are derived from matrix\n                if (oldDataView.matrix) {\n                    var newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\n                    // categorical only if there's data\n                    if (!_.isEmpty(newDataViewMatrix.valueSources)) {\n                        // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \n                        // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\n                        // this.canPivotCategorical() would have returned false in the first place for this query.\n                        var hasCompositeGroupInSeries = data.utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\n                        if (!hasCompositeGroupInSeries) {\n                            newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\n                        }\n                    }\n                }\n                return newDataView;\n            }\n            DataViewPivotCategoricalToPrimaryGroups.unpivotResult = unpivotResult;\n            /**\n             * Infer from the query result and the visual mappings whether the query was pivoted.\n             * Narrowly targets scatter chart scenario for now to keep code simple\n             */\n            function inferUnpivotTransform(selects, dataViewMappings, dataView, projectionActiveItems) {\n                if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\n                    return false;\n                // select applicable mappings based on select roles\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var supportedDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\n                if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\n                    return false;\n                var categoricalMapping = supportedDataViewMappings[0].categorical;\n                if (!categoricalMapping)\n                    return false;\n                // pivoted query will have produced a matrix\n                var matrixDataview = dataView.matrix;\n                if (!matrixDataview)\n                    return false;\n                // matrix must have two levels of grouping\n                if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\n                    return false;\n                // get category and value grouping roles\n                var categoryGroups = [];\n                var valueGroups = [];\n                var addGroupingRole = function (roleName, groups) {\n                    var roleProjections = projections[roleName];\n                    if (!roleProjections)\n                        return;\n                    for (var _i = 0, _a = roleProjections.all(); _i < _a.length; _i++) {\n                        var roleProjection = _a[_i];\n                        if (roleKinds[roleProjection.queryRef] === powerbi.VisualDataRoleKind.Grouping)\n                            groups.push(roleProjection.queryRef);\n                    }\n                };\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, categoryGroups); }\n                });\n                powerbi.DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, valueGroups); }\n                });\n                // need both for pivot to have been done\n                if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\n                    return false;\n                // if there was a pivot, there won't be any measures left in the columns\n                for (var _i = 0, _a = matrixDataview.columns.levels; _i < _a.length; _i++) {\n                    var level = _a[_i];\n                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {\n                        var source = _c[_b];\n                        if (!source.isMeasure)\n                            return false;\n                    }\n                }\n                return true;\n            }\n            /**\n             * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\n             * this function changes that so that the categories become the rows and the series the columns.\n             */\n            function unpivotMatrix(oldMatrix) {\n                var oldRows = oldMatrix.rows;\n                var oldRoot = oldRows.root;\n                var oldChildren = oldRoot.children;\n                // series are the outer grouping\n                var series = [];\n                var seriesIdLevel = oldRows.levels[0];\n                var seriesIdFields = oldRoot.childIdentityFields;\n                // categories are the inner grouping. \n                var categoryIndex = {};\n                var categories = [];\n                var categoryIdLevel = oldRows.levels[1];\n                var categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\n                var measureCount = oldMatrix.valueSources.length;\n                // within each series value, the category list may not be complete so cannot simply use the inner loop index\n                // to reference it.\n                var findCategory = function (identity) {\n                    var index = categoryIndex[identity.key];\n                    debug.assert(index !== undefined, \"findcat() !== undefined\");\n                    return index;\n                };\n                // collect series and categories from the row hierarchy\n                if (oldChildren) {\n                    var addCategory = function (categoryNode) {\n                        var key = categoryNode.identity.key;\n                        var index = categoryIndex[key];\n                        if (index === undefined) {\n                            index = categories.length;\n                            categoryIndex[key] = index;\n                            categories.push(categoryNode);\n                        }\n                    };\n                    for (var _i = 0, oldChildren_1 = oldChildren; _i < oldChildren_1.length; _i++) {\n                        var seriesNode = oldChildren_1[_i];\n                        series.push(seriesNode);\n                        for (var _a = 0, _b = seriesNode.children; _a < _b.length; _a++) {\n                            var categoryNode = _b[_a];\n                            addCategory(categoryNode);\n                        }\n                    }\n                }\n                // extract intersection values from pivoted matrix\n                // values will be indexed by categories then series\n                var matrixValues = new Array(categories.length);\n                for (var j = 0; j < series.length; ++j) {\n                    var seriesNode = oldChildren[j];\n                    for (var _c = 0, _d = seriesNode.children; _c < _d.length; _c++) {\n                        var categoryNode = _d[_c];\n                        var i = findCategory(categoryNode.identity); // must lookup actual category index\n                        if (!matrixValues[i])\n                            matrixValues[i] = new Array(series.length);\n                        matrixValues[i][j] = categoryNode.values;\n                    }\n                }\n                // columns of the unpivoted matrix are the series\n                var newColumns = {\n                    root: {\n                        children: _.map(series, function (s) {\n                            var inheritedNode = inheritSingle(s);\n                            inheritedNode.level = 0; // s.level should already be 0, but just in case...\n                            inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\n                            inheritedNode.childIdentityFields = undefined;\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: seriesIdFields,\n                    },\n                    levels: [\n                        seriesIdLevel,\n                    ],\n                };\n                // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\n                if (measureCount > 0) {\n                    var newColChildren = _.map(oldMatrix.columns.root.children, function (srcnode) {\n                        var dstnode = { level: 1 };\n                        if (srcnode.levelSourceIndex)\n                            dstnode.levelSourceIndex = srcnode.levelSourceIndex;\n                        return dstnode;\n                    });\n                    for (var i = 0; i < newColumns.root.children.length; ++i)\n                        newColumns.root.children[i].children = newColChildren;\n                    newColumns.levels.push(oldMatrix.columns.levels[0]);\n                }\n                // rows of the unpivoted matrix are the categories\n                var newRows = {\n                    root: {\n                        children: _.map(categories, function (c) {\n                            var inheritedNode = inheritSingle(c);\n                            inheritedNode.level = 0;\n                            inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\n                            inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: categoryIdFields,\n                    },\n                    levels: [\n                        categoryIdLevel,\n                    ],\n                };\n                // put values into rows\n                if (measureCount > 0) {\n                    for (var i = 0; i < categories.length; ++i) {\n                        var row = newRows.root.children[i];\n                        var rowValues = {};\n                        for (var j = 0; j < series.length; ++j) {\n                            var mvalues = matrixValues[i] && matrixValues[i][j];\n                            for (var k = 0; k < measureCount; ++k) {\n                                var l = j * measureCount + k;\n                                rowValues[l] = !mvalues\n                                    ? (k === 0 ? { value: null } : { value: null, valueSourceIndex: k })\n                                    : mvalues[k];\n                            }\n                        }\n                        row.values = rowValues;\n                    }\n                }\n                var newMatrix = {\n                    rows: newRows,\n                    columns: newColumns,\n                    valueSources: oldMatrix.valueSources,\n                };\n                return newMatrix;\n            }\n            /** build a categorical data view from an unpivoted matrix. */\n            function categoricalFromUnpivotedMatrix(matrix, columnMetadata) {\n                var seriesCount = matrix.columns.root.children.length;\n                var measureMetadata = matrix.valueSources;\n                var measureCount = measureMetadata.length;\n                var categories = createCategoryColumnsFromUnpivotedMatrix(matrix);\n                // create grouped values\n                var groups = [];\n                for (var j = 0; j < seriesCount; ++j) {\n                    var seriesColumn = matrix.columns.root.children[j];\n                    var group = {\n                        values: [],\n                        identity: seriesColumn.identity,\n                        name: seriesColumn.value || null,\n                    };\n                    groups.push(group);\n                    for (var k = 0; k < measureCount; ++k) {\n                        var valueColumnMetadataSrc = measureMetadata[k];\n                        var valueColumnMetadataDst = {};\n                        for (var key in valueColumnMetadataSrc)\n                            valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\n                        valueColumnMetadataDst.groupName = group.name;\n                        columnMetadata.push(valueColumnMetadataDst);\n                        var valueColumn = {\n                            source: valueColumnMetadataDst,\n                            values: [],\n                            identity: group.identity,\n                        };\n                        group.values.push(valueColumn);\n                        // grab measure values in the group from across rows of matrix\n                        var index = k + j * measureCount;\n                        for (var _i = 0, _a = matrix.rows.root.children; _i < _a.length; _i++) {\n                            var categoryNode = _a[_i];\n                            var value = categoryNode.values[index].value;\n                            valueColumn.values.push(value);\n                        }\n                    }\n                }\n                // and now ungrouped\n                var values = [];\n                for (var _b = 0, groups_1 = groups; _b < groups_1.length; _b++) {\n                    var group = groups_1[_b];\n                    for (var k = 0; k < measureCount; ++k) {\n                        values.push(group.values[k]);\n                    }\n                }\n                values.grouped = function () { return groups; };\n                values.identityFields = matrix.columns.root.childIdentityFields;\n                values.source = matrix.columns.levels[0].sources[0];\n                // final assembly\n                var categorical = {\n                    categories: categories,\n                    values: values,\n                };\n                return categorical;\n            }\n            function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix) {\n                debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\n                debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1), 'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\n                // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \n                // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \n                // same amongst the resulting DataViewCategoryColumns.\n                var categoryIdentity = _.map(unpivotedMatrix.rows.root.children, function (x) { return x.identity; });\n                var categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\n                var categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\n                var categories = [];\n                for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\n                    var groupLevelValues = _.map(unpivotedMatrix.rows.root.children, function (categoryNode) {\n                        var levelValues = categoryNode.levelValues;\n                        // Please refer to the interface comments on when this is undefined... But in today's code\n                        // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \n                        if (levelValues !== undefined) {\n                            debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i), 'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\n                            return levelValues[i].value;\n                        }\n                    });\n                    categories.push({\n                        source: categorySourceColumns[i],\n                        values: groupLevelValues,\n                        identity: categoryIdentity,\n                        identityFields: categoryIdentityFields,\n                    });\n                }\n                return categories;\n            }\n        })(DataViewPivotCategoricalToPrimaryGroups = data.DataViewPivotCategoricalToPrimaryGroups || (data.DataViewPivotCategoricalToPrimaryGroups = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var EnumExtensions = jsCommon.EnumExtensions;\n        // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\n        var DataViewTransform;\n        (function (DataViewTransform) {\n            var fillRulePropertyDescriptor = { type: { fillRule: {} } };\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\n                var prototype = options.prototype, objectDescriptors = options.objectDescriptors, dataViewMappings = options.dataViewMappings, transforms = options.transforms, projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems, colorAllocatorFactory = options.colorAllocatorFactory, dataRoles = options.dataRoles;\n                if (!prototype)\n                    return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\n                if (!transforms)\n                    return [prototype];\n                // Transform Query DataView\n                prototype = data.DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\n                var visualDataViews = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\n                // Transform and generate derived visual DataViews\n                visualDataViews = data.DataViewRegression.run({\n                    dataViewMappings: dataViewMappings,\n                    visualDataViews: visualDataViews,\n                    dataRoles: dataRoles,\n                    objectDescriptors: objectDescriptors,\n                    objectDefinitions: transforms.objects,\n                    colorAllocatorFactory: colorAllocatorFactory,\n                    transformSelects: transforms.selects,\n                    metadata: prototype.metadata,\n                    projectionActiveItems: projectionActiveItems,\n                });\n                return visualDataViews;\n            }\n            DataViewTransform.apply = apply;\n            function transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles) {\n                var transformedDataViews = [];\n                var splits = transforms.splits;\n                if (_.isEmpty(splits)) {\n                    transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\n                }\n                else {\n                    for (var _i = 0, splits_1 = splits; _i < splits_1.length; _i++) {\n                        var split = splits_1[_i];\n                        var transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\n                        transformedDataViews.push(transformed);\n                    }\n                }\n                return transformedDataViews;\n            }\n            function transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory) {\n                if (transforms && transforms.objects) {\n                    var emptyDataView = {\n                        metadata: {\n                            columns: [],\n                        }\n                    };\n                    transformObjects(emptyDataView, 0 /* None */, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                    return [emptyDataView];\n                }\n                return [];\n            }\n            function transformDataView(prototype, objectDescriptors, roleMappings, transforms, colorAllocatorFactory, dataRoles, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(transforms, 'transforms');\n                debug.assert(!selectsToInclude ||\n                    _.filter(Object.keys(selectsToInclude), function (selectIndex) { return selectsToInclude[selectIndex] && (!transforms.selects || !transforms.selects[selectIndex]); })\n                        .length === 0, // asserts that the number of select indices in selectsToInclude without a corresponding Select Transform === 0\n                'If selectsToInclude is specified, every Select Index in it must have a corresponding Select Transform.');\n                var targetKinds = getTargetKinds(roleMappings);\n                var transformed = inherit(prototype);\n                transformed.metadata = inherit(prototype.metadata);\n                var projectionOrdering = transforms.roles && transforms.roles.ordering;\n                var projectionActiveItems = transforms.roles && transforms.roles.activeItems;\n                transformed = transformSelects(transformed, targetKinds, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\n                transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\n                transformed = data.DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\n                data.DataViewNormalizeValues.apply({\n                    dataview: transformed,\n                    dataViewMappings: roleMappings,\n                    dataRoles: dataRoles,\n                });\n                return transformed;\n            }\n            function getTargetKinds(roleMappings) {\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                if (!roleMappings)\n                    return 0 /* None */;\n                var result = 0 /* None */;\n                for (var _i = 0, roleMappings_1 = roleMappings; _i < roleMappings_1.length; _i++) {\n                    var roleMapping = roleMappings_1[_i];\n                    if (roleMapping.categorical)\n                        result |= 1 /* Categorical */;\n                    if (roleMapping.matrix)\n                        result |= 2 /* Matrix */;\n                    if (roleMapping.single)\n                        result |= 4 /* Single */;\n                    if (roleMapping.table)\n                        result |= 8 /* Table */;\n                    if (roleMapping.tree)\n                        result |= 16 /* Tree */;\n                }\n                return result;\n            }\n            function transformSelects(dataView, targetDataViewKinds, roleMappings, selectTransforms, projectionOrdering, selectsToInclude) {\n                var columnRewrites = [];\n                if (selectTransforms) {\n                    dataView.metadata.columns = applyTransformsToColumns(dataView.metadata.columns, selectTransforms, columnRewrites);\n                }\n                // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\n                if (dataView.categorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {\n                    dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    // NOTE: This is slightly DSR-specific.\n                    dataView = pivotIfNecessary(dataView, roleMappings);\n                }\n                // Don't perform this potentially expensive transform unless we actually have a matrix.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (dataView.matrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {\n                    var matrixTransformationContext = {\n                        rowHierarchyRewritten: false,\n                        columnHierarchyRewritten: false,\n                        hierarchyTreesRewritten: false\n                    };\n                    dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    if (shouldPivotMatrix(dataView.matrix, roleMappings))\n                        data.DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\n                }\n                // Don't perform this potentially expensive transform unless we actually have a table.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (dataView.table && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {\n                    dataView.table = applyRewritesToTable(dataView.table, columnRewrites, projectionOrdering);\n                }\n                return dataView;\n            }\n            function applyTransformsToColumns(prototypeColumns, selects, rewrites) {\n                debug.assertValue(prototypeColumns, 'columns');\n                if (!selects)\n                    return prototypeColumns;\n                //column may contain undefined entries\n                var columns = inherit(prototypeColumns);\n                for (var i = 0, len = prototypeColumns.length; i < len; i++) {\n                    var prototypeColumn = prototypeColumns[i];\n                    var select = selects[prototypeColumn.index];\n                    if (!select)\n                        continue;\n                    var column = columns[i] = inherit(prototypeColumn);\n                    if (select.roles)\n                        column.roles = select.roles;\n                    if (select.type)\n                        column.type = select.type;\n                    column.format = getFormatForColumn(select, column);\n                    if (select.displayName)\n                        column.displayName = select.displayName;\n                    if (select.queryName)\n                        column.queryName = select.queryName;\n                    if (select.kpi)\n                        column.kpi = select.kpi;\n                    if (select.sort)\n                        column.sort = select.sort;\n                    if (select.discourageAggregationAcrossGroups)\n                        column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\n                    rewrites.push({\n                        from: prototypeColumn,\n                        to: column,\n                    });\n                }\n                return columns;\n            }\n            /**\n             * Get the column format. Order of precendence is:\n             *  1. Select format\n             *  2. Column format\n             */\n            function getFormatForColumn(select, column) {\n                // TODO: we already copied the select.Format to column.format, we probably don't need this check\n                return select.format || column.format;\n            }\n            function applyRewritesToCategorical(prototype, columnRewrites, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                var categorical = inherit(prototype);\n                function override(value) {\n                    var rewrittenSource = findOverride(value.source, columnRewrites);\n                    if (rewrittenSource) {\n                        var rewritten = inherit(value);\n                        rewritten.source = rewrittenSource;\n                        return rewritten;\n                    }\n                }\n                var categories = powerbi.Prototype.overrideArray(prototype.categories, override);\n                if (categories)\n                    categorical.categories = categories;\n                var valuesOverride = powerbi.Prototype.overrideArray(prototype.values, override);\n                var valueColumns = valuesOverride || prototype.values;\n                if (valueColumns) {\n                    if (valueColumns.source) {\n                        if (selectsToInclude && !selectsToInclude[valueColumns.source.index]) {\n                            // if processing a split and this is the split without series...\n                            valueColumns.source = undefined;\n                        }\n                        else {\n                            var rewrittenValuesSource = findOverride(valueColumns.source, columnRewrites);\n                            if (rewrittenValuesSource)\n                                valueColumns.source = rewrittenValuesSource;\n                        }\n                    }\n                    if (selectsToInclude) {\n                        // Apply selectsToInclude to values by removing value columns not included\n                        for (var i = valueColumns.length - 1; i >= 0; i--) {\n                            if (!selectsToInclude[valueColumns[i].source.index]) {\n                                valueColumns.splice(i, 1);\n                            }\n                        }\n                    }\n                    var isDynamicSeries_1 = !!valueColumns.source;\n                    debug.assert(_.every(valueColumns, function (valueColumn) { return isDynamicSeries_1 === !!valueColumn.identity; }), 'After applying selectsToInclude, all remaining DataViewValueColumn objects should have a consistent scope type (static vs. dynamic) with the parent DataViewValueColumns object.');\n                    // Dynamic or not, always update the return values of grouped() to have the rewritten 'source' property\n                    var seriesGroups_1;\n                    if (isDynamicSeries_1) {\n                        // We have a dynamic series, so update the return value of grouped() to have the DataViewValueColumn objects with rewritten 'source'.\n                        // Also, exclude any column that belongs to a static series.\n                        seriesGroups_1 = inherit(valueColumns.grouped());\n                        // The following assert is not a rule that's set in stone.  If it becomes false someday, update the code below to remove static series from seriesGroups.\n                        debug.assert(_.every(seriesGroups_1, function (group) { return !!group.identity; }), 'If the categorical has a dynamic series, query DataView is expected to have a grouped() function that returns only dynamic series groups, even when there is any column that belongs to a static group (in the case of combo chart and splits).  If this assertion becomes false someday, update the code below to remove static series from seriesGroups.');\n                        var nextSeriesGroupIndex = 0;\n                        var currentSeriesGroup = void 0;\n                        for (var i = 0, ilen = valueColumns.length; i < ilen; i++) {\n                            var currentValueColumn = valueColumns[i];\n                            if (!currentSeriesGroup || (currentValueColumn.identity !== currentSeriesGroup.identity)) {\n                                currentSeriesGroup = inherit(seriesGroups_1[nextSeriesGroupIndex]);\n                                seriesGroups_1[nextSeriesGroupIndex] = currentSeriesGroup;\n                                currentSeriesGroup.values = [];\n                                nextSeriesGroupIndex++;\n                                debug.assert(currentValueColumn.identity === currentSeriesGroup.identity, 'expecting the value columns are sequenced by series groups');\n                            }\n                            currentSeriesGroup.values.push(currentValueColumn);\n                        }\n                    }\n                    else {\n                        // We are in a static series, so we should throw away the grouped and recreate it using the static values\n                        //   which have already been filtered\n                        seriesGroups_1 = [{ values: valueColumns }];\n                    }\n                    valueColumns.grouped = function () { return seriesGroups_1; };\n                    categorical.values = valueColumns;\n                }\n                return categorical;\n            }\n            function applyRewritesToTable(prototype, columnRewrites, projectionOrdering) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                var table = inherit(prototype);\n                // Copy the rewritten columns into the table view\n                var override = function (metadata) { return findOverride(metadata, columnRewrites); };\n                var columns = powerbi.Prototype.overrideArray(prototype.columns, override);\n                if (columns)\n                    table.columns = columns;\n                if (!projectionOrdering)\n                    return table;\n                var newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\n                if (!newToOldPositions)\n                    return table;\n                // Reorder the columns\n                var columnsClone = columns.slice(0);\n                var keys = Object.keys(newToOldPositions);\n                for (var i = 0, len = keys.length; i < len; i++) {\n                    var sourceColumn = columnsClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === columns.length)\n                        columns.push(sourceColumn);\n                    else {\n                        debug.assert(i < columns.length, 'The column index is out of range for reordering.');\n                        columns[i] = sourceColumn;\n                    }\n                }\n                // Reorder the rows\n                var rows = powerbi.Prototype.overrideArray(table.rows, function (row) {\n                    var newRow = [];\n                    for (var i = 0, len = keys.length; i < len; ++i)\n                        newRow[i] = row[newToOldPositions[keys[i]]];\n                    return newRow;\n                });\n                if (rows)\n                    table.rows = rows;\n                return table;\n            }\n            /** Creates a mapping of new position to original position. */\n            function createTableColumnPositionMapping(projectionOrdering, columnRewrites) {\n                var roles = Object.keys(projectionOrdering);\n                // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\n                if (roles.length !== 1)\n                    return;\n                var role = roles[0], originalOrder = _.map(columnRewrites, function (rewrite) { return rewrite.from.index; }), newOrder = projectionOrdering[role];\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            function applyRewritesToMatrix(prototype, columnRewrites, roleMappings, projectionOrdering, context) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                debug.assertValue(roleMappings, 'roleMappings');\n                var firstRoleMappingWithMatrix = _.find(roleMappings, function (roleMapping) { return !!roleMapping.matrix; });\n                debug.assertValue(firstRoleMappingWithMatrix, 'roleMappings - at least one role mapping is expected to target DataViewMatrix');\n                var matrixMapping = firstRoleMappingWithMatrix.matrix;\n                var matrix = inherit(prototype);\n                function override(metadata) {\n                    return findOverride(metadata, columnRewrites);\n                }\n                function overrideHierarchy(hierarchy) {\n                    var rewrittenHierarchy = null;\n                    var newLevels = powerbi.Prototype.overrideArray(hierarchy.levels, function (level) {\n                        var newLevel = null;\n                        var levelSources = powerbi.Prototype.overrideArray(level.sources, override);\n                        if (levelSources)\n                            newLevel = ensureRewritten(newLevel, level, function (h) { return h.sources = levelSources; });\n                        return newLevel;\n                    });\n                    if (newLevels)\n                        rewrittenHierarchy = ensureRewritten(rewrittenHierarchy, hierarchy, function (r) { return r.levels = newLevels; });\n                    return rewrittenHierarchy;\n                }\n                var rows = overrideHierarchy(matrix.rows);\n                if (rows) {\n                    matrix.rows = rows;\n                    context.rowHierarchyRewritten = true;\n                }\n                var columns = overrideHierarchy(matrix.columns);\n                if (columns) {\n                    matrix.columns = columns;\n                    context.columnHierarchyRewritten = true;\n                }\n                var valueSources = powerbi.Prototype.overrideArray(matrix.valueSources, override);\n                if (valueSources) {\n                    matrix.valueSources = valueSources;\n                    // Only need to reorder if we have more than one value source, and they are all bound to the same role\n                    var matrixValues = matrixMapping.values;\n                    if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\n                        var columnLevels = columns.levels.length;\n                        if (columnLevels > 0) {\n                            var newToOldPositions_1 = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\n                            if (newToOldPositions_1) {\n                                var keys_1 = Object.keys(newToOldPositions_1);\n                                var numKeys_1 = keys_1.length;\n                                // Reorder the value columns\n                                columns.root = data.DataViewPivotMatrix.cloneTree(columns.root);\n                                if (columnLevels === 1)\n                                    reorderChildNodes(columns.root, newToOldPositions_1);\n                                else\n                                    forEachNodeAtLevel(columns.root, columnLevels - 2, function (node) { return reorderChildNodes(node, newToOldPositions_1); });\n                                // Reorder the value rows\n                                matrix.rows.root = data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, function (node) {\n                                    if (!node.values)\n                                        return;\n                                    var newValues = {};\n                                    var iterations = Object.keys(node.values).length / numKeys_1;\n                                    for (var i = 0, len = iterations; i < len; i++) {\n                                        var offset = i * numKeys_1;\n                                        for (var keysIndex = 0; keysIndex < numKeys_1; keysIndex++)\n                                            newValues[offset + keysIndex] = node.values[offset + newToOldPositions_1[keys_1[keysIndex]]];\n                                    }\n                                    node.values = newValues;\n                                });\n                                context.hierarchyTreesRewritten = true;\n                            }\n                        }\n                    }\n                }\n                reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\n                return matrix;\n            }\n            function reorderChildNodes(node, newToOldPositions) {\n                var keys = Object.keys(newToOldPositions);\n                var numKeys = keys.length;\n                var children = node.children;\n                var childrenClone = children.slice(0);\n                for (var i = 0, len = numKeys; i < len; i++) {\n                    var sourceColumn = childrenClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === children.length)\n                        children.push(sourceColumn);\n                    else {\n                        debug.assert(i < children.length, 'The column index is out of range for reordering.');\n                        children[i] = sourceColumn;\n                    }\n                }\n            }\n            /**\n             * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\n             * and values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified prototype is necessary.\n             */\n            function reorderMatrixCompositeGroups(prototype, supportedDataViewMapping, projection) {\n                var transformedDataView;\n                if (prototype && supportedDataViewMapping && projection) {\n                    // reorder levelValues in any composite groups in rows hierarchy\n                    var transformedRowsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\n                        visitRole: function (role, context) {\n                            transformedRowsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedRowsHierarchy_1 || prototype.rows, role, projection);\n                        }\n                    });\n                    // reorder levelValues in any composite groups in columns hierarchy\n                    var transformedColumnsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\n                        visitRole: function (role, context) {\n                            transformedColumnsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedColumnsHierarchy_1 || prototype.columns, role, projection);\n                        }\n                    });\n                    if (transformedRowsHierarchy_1 || transformedColumnsHierarchy_1) {\n                        transformedDataView = inheritSingle(prototype);\n                        transformedDataView.rows = transformedRowsHierarchy_1 || transformedDataView.rows;\n                        transformedDataView.columns = transformedColumnsHierarchy_1 || transformedDataView.columns;\n                    }\n                }\n                return transformedDataView;\n            }\n            /**\n             * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\n             * values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\n             */\n            function reorderMatrixHierarchyCompositeGroups(matrixHierarchy, hierarchyRole, projection) {\n                debug.assertValue(matrixHierarchy, 'matrixHierarchy');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                var transformedHierarchy;\n                var selectIndicesInProjectionOrder = projection[hierarchyRole];\n                // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\n                var hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\n                if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\n                    for (var i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\n                        var hierarchyLevel = matrixHierarchy.levels[i];\n                        // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\n                        var newToOldLevelSourceIndicesMapping = createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\n                        if (newToOldLevelSourceIndicesMapping) {\n                            if (_.isUndefined(transformedHierarchy)) {\n                                // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\n                                // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\n                                transformedHierarchy = inheritSingle(matrixHierarchy);\n                                transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\n                                // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\n                                // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\n                                // happen in other hierarchy levels in the later iterations of this for-loop.\n                                transformedHierarchy.root = data.utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\n                            }\n                            // reorder the metadata columns in the sources array at that level\n                            var transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\n                            transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\n                            // reorder the level values in the composite group nodes at the current hierarchy level\n                            reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\n                        }\n                    }\n                }\n                return transformedHierarchy;\n            }\n            /**\n             * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\n             * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\n             *\n             * The returned value maps level source indices from the new target order (calculated from projection order)\n             * back to the original order as they appear in the specified hierarchyLevel's sources.\n             * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\n             *\n             * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\n             *\n             * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\n             * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\n             * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\n             */\n            function createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\n                var newToOldLevelSourceIndicesMapping;\n                var levelSourceColumns = hierarchyLevel.sources;\n                if (levelSourceColumns && levelSourceColumns.length >= 2) {\n                    // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\n                    var columnsForHierarchyRoleOrderedByLevelSourceIndex = data.utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(levelSourceColumns, projection, hierarchyRole);\n                    if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\n                        // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\n                        var columnsForHierarchyRoleOrderedByProjection = _.sortBy(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.projectionOrderIndex; });\n                        newToOldLevelSourceIndicesMapping = createOrderMapping(_.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.sourceIndex; }), _.map(columnsForHierarchyRoleOrderedByProjection, function (columnInfo) { return columnInfo.sourceIndex; }));\n                    }\n                }\n                return newToOldLevelSourceIndicesMapping;\n            }\n            /**\n             * Applies re-ordering on the specified transformingHierarchyLevel's sources.\n             * Returns the same object as the specified transformingHierarchyLevel.\n             */\n            function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var originalLevelSources = transformingHierarchyLevel.sources;\n                transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\n                var newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\n                for (var i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\n                    var newLevelSourceIndex = newLevelSourceIndices[i];\n                    var oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\n                    debug.assert(oldLevelSourceIndex < originalLevelSources.length, 'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\n                    transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\n                }\n                return transformingHierarchyLevel;\n            }\n            /**\n             * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\n             * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\n             *\n             * Returns the same object as the specified transformingHierarchyRootNode.\n             */\n            function reorderMatrixHierarchyLevelValues(transformingHierarchyRootNode, transformingHierarchyLevelIndex, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var oldToNewLevelSourceIndicesMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\n                forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, function (transformingMatrixNode) {\n                    var originalLevelValues = transformingMatrixNode.levelValues;\n                    // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\n                    // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\n                    // The following code isn't correct in the special case where a column is projected twice in this composite group,\n                    // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\n                    // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\n                    if (!_.isEmpty(originalLevelValues)) {\n                        // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\n                        // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\n                        // because we don't want to accidentally modify the array AND its value references in Query DataView\n                        var newlyOrderedLevelValues = _.sortBy(originalLevelValues, function (levelValue) { return oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]; });\n                        for (var i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\n                            var transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\n                            transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\n                            newlyOrderedLevelValues[i] = transformingLevelValue;\n                        }\n                        transformingMatrixNode.levelValues = newlyOrderedLevelValues;\n                        // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\n                        // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\n                        var newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\n                        if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\n                            transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\n                        }\n                        if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\n                            transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\n                        }\n                    }\n                });\n                return transformingHierarchyRootNode;\n            }\n            /**\n             * Creates a mapping of new position to original position.\n             *\n             * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\n             * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\n             * - the value in the key-value pair is the index of the particular column in the original order\n             */\n            function createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites) {\n                var role = matrixValues.for.in;\n                var newOrder = projectionOrdering[role];\n                var originalOrder = _.chain(columnRewrites)\n                    .filter(function (rewrite) { return _.contains(valueSources, rewrite.to); })\n                    .map(function (rewrite) { return rewrite.from.index; })\n                    .value();\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            /**\n             * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\n             * originalOrder array.\n             * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\n             * under the context of the caller code), e.g. the Select Index in projection ordering array.\n             * Also, the specified originalOrder must contain every value that exists in newOrder.\n             *\n             * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\n             * key-value pair, each of which represents the new and old indices of a particular column:\n             * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\n             * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\n             *\n             * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\n             *\n             * If the specified originalOrder and newOrder are same, then this function returns undefined.\n             *\n             * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\n             * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\n             */\n            function createOrderMapping(originalOrder, newOrder) {\n                // Optimization: avoid rewriting if the current order is correct\n                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, function (x, y) { return x === y; }))\n                    return;\n                var mapping = {};\n                for (var i = 0, len = newOrder.length; i < len; ++i) {\n                    var newPosition = newOrder[i];\n                    mapping[i] = originalOrder.indexOf(newPosition);\n                }\n                return mapping;\n            }\n            function createReversedMapping(mapping) {\n                debug.assertValue(mapping, 'mapping');\n                var reversed = {};\n                for (var key in mapping) {\n                    // Note: key is a string after we get it out from mapping, thus we need to parse it\n                    // back into a number before putting it as the value in the reversed mapping\n                    var value = mapping[key];\n                    var keyAsNumber = parseInt(key, 10);\n                    reversed[value] = keyAsNumber;\n                }\n                debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length, 'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\n                return reversed;\n            }\n            function forEachNodeAtLevel(node, targetLevel, callback) {\n                debug.assertValue(node, 'node');\n                debug.assert(targetLevel >= 0, 'argetLevel >= 0');\n                debug.assertValue(callback, 'callback');\n                if (node.level === targetLevel) {\n                    callback(node);\n                    return;\n                }\n                var children = node.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachNodeAtLevel(children[i], targetLevel, callback);\n                }\n            }\n            DataViewTransform.forEachNodeAtLevel = forEachNodeAtLevel;\n            function findOverride(source, columnRewrites) {\n                for (var i = 0, len = columnRewrites.length; i < len; i++) {\n                    var columnRewrite = columnRewrites[i];\n                    if (columnRewrite.from === source)\n                        return columnRewrite.to;\n                }\n            }\n            function ensureRewritten(rewritten, prototype, callback) {\n                if (!rewritten)\n                    rewritten = inherit(prototype);\n                if (callback)\n                    callback(rewritten);\n                return rewritten;\n            }\n            function transformObjects(dataView, targetDataViewKinds, objectDescriptors, objectDefinitions, selectTransforms, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!objectDescriptors)\n                    return;\n                var objectsForAllSelectors = data.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\n                data.DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\n                var metadataOnce = objectsForAllSelectors.metadataOnce;\n                var dataObjects = objectsForAllSelectors.data;\n                if (metadataOnce)\n                    evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\n                var metadataObjects = objectsForAllSelectors.metadata;\n                if (metadataObjects) {\n                    for (var i = 0, len = metadataObjects.length; i < len; i++) {\n                        var metadataObject = metadataObjects[i];\n                        var objectDefns = metadataObject.objects;\n                        var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                        evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\n                    }\n                }\n                for (var i = 0, len = dataObjects.length; i < len; i++) {\n                    var dataObject = dataObjects[i];\n                    var objectDefns = dataObject.objects;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                    evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\n                }\n                var userDefined = objectsForAllSelectors.userDefined;\n                if (userDefined) {\n                    // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\n                    evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\n                }\n            }\n            DataViewTransform.transformObjects = transformObjects;\n            function evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var dataViewObjects = dataView.metadata.objects;\n                if (!dataViewObjects) {\n                    dataViewObjects = dataView.metadata.objects = {};\n                }\n                for (var _i = 0, objectDefns_1 = objectDefns; _i < objectDefns_1.length; _i++) {\n                    var objectDefn = objectDefns_1[_i];\n                    var id = objectDefn.selector.id;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\n                    var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                    var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\n                    for (var objectName in objects) {\n                        var object = objects[objectName];\n                        var map = dataViewObjects[objectName];\n                        if (!map)\n                            map = dataViewObjects[objectName] = [];\n                        debug.assert(powerbi.DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\n                        // NOTE: We do not check for duplicate ids.\n                        map.push({ id: id, object: object });\n                    }\n                }\n            }\n            /** Evaluates and sets properties on the DataView metadata. */\n            function evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, objectDefns, dataObjects, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(dataObjects, 'dataObjects');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                if (objects) {\n                    dataView.metadata.objects = objects;\n                    for (var objectName in objects) {\n                        var object = objects[objectName], objectDesc = objectDescriptors[objectName];\n                        for (var propertyName in object) {\n                            var propertyDesc = objectDesc.properties[propertyName], ruleDesc = propertyDesc.rule;\n                            if (!ruleDesc)\n                                continue;\n                            var definition = createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, object[propertyName], propertyDesc.type);\n                            if (!definition)\n                                continue;\n                            dataObjects.push(definition);\n                        }\n                    }\n                }\n            }\n            function createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, propertyValue, ruleType) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(propertyValue, 'propertyValue');\n                debug.assertValue(ruleType, 'ruleType');\n                var ruleOutput = ruleDesc.output;\n                if (!ruleOutput)\n                    return;\n                var selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\n                if (!selectorToCreate)\n                    return;\n                if (ruleType.fillRule) {\n                    return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue);\n                }\n            }\n            function createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(selectorToCreate, 'selectorToCreate');\n                debug.assertValue(propertyValue, 'propertyValue');\n                var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, 1 /* Role */, propertyValue);\n                if (!colorAllocator)\n                    return;\n                var rule = new data.ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\n                var fillRuleProperties = {};\n                fillRuleProperties[ruleDesc.output.property] = {\n                    solid: { color: rule }\n                };\n                return {\n                    selector: selectorToCreate,\n                    rules: [rule],\n                    objects: [{\n                            name: objectName,\n                            properties: fillRuleProperties,\n                        }]\n                };\n            }\n            function tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(propertyValue, 'propertyValue');\n                if (propertyValue.linearGradient2)\n                    return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\n                if (propertyValue.linearGradient3)\n                    return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\n            }\n            function createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient2) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient2, 'linearGradient2');\n                linearGradient2 = propertyValueFillRule.linearGradient2;\n                if (linearGradient2.min.value === undefined ||\n                    linearGradient2.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    if (linearGradient2.min.value === undefined)\n                        linearGradient2.min.value = inputRange.min;\n                    if (linearGradient2.max.value === undefined)\n                        linearGradient2.max.value = inputRange.max;\n                }\n                return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\n            }\n            function createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient3) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient3, 'linearGradient3');\n                var splitScales;\n                linearGradient3 = propertyValueFillRule.linearGradient3;\n                if (linearGradient3.min.value === undefined ||\n                    linearGradient3.mid.value === undefined ||\n                    linearGradient3.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    splitScales =\n                        linearGradient3.min.value === undefined &&\n                            linearGradient3.max.value === undefined &&\n                            linearGradient3.mid.value !== undefined;\n                    if (linearGradient3.min.value === undefined) {\n                        linearGradient3.min.value = inputRange.min;\n                    }\n                    if (linearGradient3.max.value === undefined) {\n                        linearGradient3.max.value = inputRange.max;\n                    }\n                    if (linearGradient3.mid.value === undefined) {\n                        var midValue = (linearGradient3.max.value + linearGradient3.min.value) / 2;\n                        linearGradient3.mid.value = midValue;\n                    }\n                }\n                return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\n            }\n            function populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var cache = data.createColorAllocatorCache();\n                var staticEvalContext = data.createStaticEvalContext();\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefnProperties = objectDefns[i].properties;\n                    for (var propertyName in objectDefnProperties) {\n                        var fillProperty = objectDefnProperties[propertyName];\n                        if (fillProperty &&\n                            fillProperty.solid &&\n                            fillProperty.solid.color &&\n                            fillProperty.solid.color.kind === 23 /* FillRule */) {\n                            var fillRuleExpr = fillProperty.solid.color;\n                            var inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\n                            if (!inputExprQueryName)\n                                continue;\n                            var fillRule = data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, fillRulePropertyDescriptor, fillRuleExpr.rule);\n                            var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, 0 /* QueryName */, fillRule);\n                            if (colorAllocator)\n                                cache.register(fillRuleExpr, colorAllocator);\n                        }\n                    }\n                }\n                return cache;\n            }\n            function evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, selector, rules, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\n                var containsWildcard = data.Selector.containsWildcard(selector);\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {\n                    // 1) Match against categories\n                    evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    // 2) Match against valueGrouping\n                    evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                }\n                var dataViewMatrix = dataView.matrix;\n                if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {\n                    var rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenMatrix) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.matrix = rewrittenMatrix;\n                    }\n                }\n                var dataViewTable = dataView.table;\n                if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {\n                    var rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\n                    var rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenTable) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.table = rewrittenTable;\n                    }\n                }\n            }\n            function rewriteTableRoleSelector(dataViewTable, selector) {\n                if (data.Selector.hasRoleWildcard(selector)) {\n                    selector = findSelectorForRoleWildcard(dataViewTable, selector);\n                }\n                return selector;\n            }\n            function findSelectorForRoleWildcard(dataViewTable, selector) {\n                var resultingSelector = {\n                    data: [],\n                    id: selector.id,\n                    metadata: selector.metadata\n                };\n                for (var _i = 0, _a = selector.data; _i < _a.length; _i++) {\n                    var dataSelector = _a[_i];\n                    if (data.Selector.isRoleWildcard(dataSelector)) {\n                        var selectorRoles = dataSelector.roles;\n                        var allColumnsBelongToSelectorRole = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\n                        var exprs = dataViewTable.identityFields;\n                        if (allColumnsBelongToSelectorRole && exprs) {\n                            resultingSelector.data.push(data.DataViewScopeWildcard.fromExprs(exprs));\n                            continue;\n                        }\n                    }\n                    if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\n                        resultingSelector.data.push(dataSelector);\n                    }\n                }\n                return resultingSelector;\n            }\n            function isUniqueDataSelector(dataSelectors, newSelector) {\n                if (_.isEmpty(dataSelectors))\n                    return true;\n                return !_.any(dataSelectors, function (dataSelector) { return dataSelector.key === newSelector.key; });\n            }\n            function allColumnsBelongToRole(columns, selectorRoles) {\n                for (var _i = 0, columns_6 = columns; _i < columns_6.length; _i++) {\n                    var column = columns_6[_i];\n                    var roles = column.roles;\n                    if (!roles || !_.any(selectorRoles, function (selectorRole) { return roles[selectorRole]; }))\n                        return false;\n                }\n                return true;\n            }\n            function evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\n                    return;\n                var targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\n                if (!targetColumn)\n                    return;\n                var identities = targetColumn.identities, foundMatch, evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                if (!identities)\n                    return;\n                debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\n                for (var i = 0, len = identities.length; i < len; i++) {\n                    var identity = identities[i];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(i);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (!targetColumn.column.objects) {\n                                targetColumn.column.objects = [];\n                                targetColumn.column.objects.length = len;\n                            }\n                            targetColumn.column.objects[i] = objects;\n                        }\n                        if (!containsWildcard)\n                            return true;\n                        foundMatch = true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var dataViewCategoricalValues = dataViewCategorical.values;\n                if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [dataViewCategoricalValues.identityFields]))\n                    return;\n                var valuesGrouped = dataViewCategoricalValues.grouped();\n                if (!valuesGrouped)\n                    return;\n                // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\n                // This should be enhanced in the future.\n                var evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                var foundMatch;\n                for (var i = 0, len = valuesGrouped.length; i < len; i++) {\n                    var valueGroup = valuesGrouped[i];\n                    var selectorMetadata = selector.metadata;\n                    var valuesInGroup = valueGroup.values;\n                    if (containsWildcard || data.Selector.matchesData(selector, [valueGroup.identity])) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (selectorMetadata) {\n                                for (var j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\n                                    var valueColumn = valuesInGroup[j], valueSource = valueColumn.source;\n                                    if (valueSource.queryName === selectorMetadata) {\n                                        var valueSourceOverwrite = powerbi.Prototype.inherit(valueSource);\n                                        valueSourceOverwrite.objects = objects;\n                                        valueColumn.source = valueSourceOverwrite;\n                                        foundMatch = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            else {\n                                valueGroup.objects = objects;\n                                setGrouped(dataViewCategoricalValues, valuesGrouped);\n                                foundMatch = true;\n                            }\n                        }\n                        if (!containsWildcard)\n                            return true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                var evalContext = data.createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\n                var rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                var rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows || rewrittenCols) {\n                    var rewrittenMatrix = inheritSingle(dataViewMatrix);\n                    if (rewrittenRows)\n                        rewrittenMatrix.rows = rewrittenRows;\n                    if (rewrittenCols)\n                        rewrittenMatrix.columns = rewrittenCols;\n                    return rewrittenMatrix;\n                }\n            }\n            function evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrixHierarchy, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (!dataViewMatrixHierarchy)\n                    return;\n                var root = dataViewMatrixHierarchy.root;\n                if (!root)\n                    return;\n                var rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRoot) {\n                    var rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\n                    rewrittenHierarchy.root = rewrittenRoot;\n                    return rewrittenHierarchy;\n                }\n            }\n            function evaluateDataRepetitionMatrixNode(evalContext, dataViewNode, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(dataViewNode, 'dataViewNode');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var childNodes = dataViewNode.children;\n                if (!childNodes)\n                    return;\n                var rewrittenNode;\n                var shouldSearchChildren;\n                var childIdentityFields = dataViewNode.childIdentityFields;\n                if (childIdentityFields) {\n                    // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\n                    shouldSearchChildren = data.Selector.matchesKeys(selector, [childIdentityFields]);\n                }\n                for (var i = 0, len = childNodes.length; i < len; i++) {\n                    var childNode = childNodes[i], identity = childNode.identity, rewrittenChildNode = null;\n                    if (shouldSearchChildren) {\n                        if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                            // TODO: Need to initialize context for rule-based properties.  Rule-based properties\n                            // (such as fillRule/gradients) are not currently implemented.\n                            var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                            if (objects) {\n                                rewrittenChildNode = inheritSingle(childNode);\n                                rewrittenChildNode.objects = objects;\n                            }\n                        }\n                    }\n                    else {\n                        rewrittenChildNode = evaluateDataRepetitionMatrixNode(evalContext, childNode, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                    }\n                    if (rewrittenChildNode) {\n                        if (!rewrittenNode)\n                            rewrittenNode = inheritNodeAndChildren(dataViewNode);\n                        rewrittenNode.children[i] = rewrittenChildNode;\n                        if (!containsWildcard) {\n                            // NOTE: once we find a match for a non-wildcard selector, stop looking.\n                            break;\n                        }\n                    }\n                }\n                return rewrittenNode;\n            }\n            function inheritNodeAndChildren(node) {\n                if (Object.getPrototypeOf(node) !== Object.prototype) {\n                    return node;\n                }\n                var inherited = inheritSingle(node);\n                inherited.children = inherit(node.children);\n                return inherited;\n            }\n            function evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewTable, 'dataViewTable');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var evalContext = data.createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\n                var rewrittenRows = evaluateDataRepetitionTableRows(evalContext, dataViewTable.columns, dataViewTable.rows, dataViewTable.identity, dataViewTable.identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows) {\n                    var rewrittenTable = inheritSingle(dataViewTable);\n                    rewrittenTable.rows = rewrittenRows;\n                    return rewrittenTable;\n                }\n            }\n            function evaluateDataRepetitionTableRows(evalContext, columns, rows, identities, identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(rows, 'rows');\n                debug.assertAnyValue(identities, 'identities');\n                debug.assertAnyValue(identityFields, 'identityFields');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (_.isEmpty(identities) || _.isEmpty(identityFields))\n                    return;\n                if (!selector.metadata ||\n                    !data.Selector.matchesKeys(selector, [identityFields]))\n                    return;\n                var colIdx = _.findIndex(columns, function (col) { return col.queryName === selector.metadata; });\n                if (colIdx < 0)\n                    return;\n                debug.assert(rows.length === identities.length, 'row length mismatch');\n                var colLen = columns.length;\n                var inheritedRows;\n                for (var rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\n                    var identity = identities[rowIdx];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(rowIdx);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            if (!inheritedRows)\n                                inheritedRows = inheritSingle(rows);\n                            var inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\n                            var objectsForColumns = inheritedRow.objects;\n                            if (!objectsForColumns)\n                                inheritedRow.objects = objectsForColumns = new Array(colLen);\n                            objectsForColumns[colIdx] = objects;\n                        }\n                        if (!containsWildcard)\n                            break;\n                    }\n                }\n                return inheritedRows;\n            }\n            function evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, selector, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                // revisit this, likely when we do lazy evaluation of DataView.\n                var columns = dataView.metadata.columns, metadataId = selector.metadata, evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                for (var i = 0, len = columns.length; i < len; i++) {\n                    var column = columns[i];\n                    if (column.queryName === metadataId) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects)\n                            column.objects = objects;\n                    }\n                }\n            }\n            /** Attempts to find a column that can possibly match the selector. */\n            function findSelectedCategoricalColumn(dataViewCategorical, selector) {\n                debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\n                var categoricalColumn = dataViewCategorical.categories[0];\n                if (!categoricalColumn.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [categoricalColumn.identityFields]))\n                    return;\n                var identities = categoricalColumn.identity, targetColumn = categoricalColumn;\n                var selectedMetadataId = selector.metadata;\n                if (selectedMetadataId) {\n                    var valueColumns = dataViewCategorical.values;\n                    if (valueColumns) {\n                        for (var i = 0, len = valueColumns.length; i < len; i++) {\n                            var valueColumn = valueColumns[i];\n                            if (valueColumn.source.queryName === selectedMetadataId) {\n                                targetColumn = valueColumn;\n                                break;\n                            }\n                        }\n                    }\n                }\n                return {\n                    column: targetColumn,\n                    identities: identities,\n                };\n            }\n            function findSelectorForRuleInput(dataView, selectorRoles) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectorRoles, 'selectorRoles');\n                if (selectorRoles.length !== 1)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical)\n                    return;\n                var categories = dataViewCategorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var categoryColumn = categories[0], categoryRoles = categoryColumn.source.roles, categoryIdentityFields = categoryColumn.identityFields;\n                if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\n                    return;\n                return { data: [data.DataViewScopeWildcard.fromExprs(categoryIdentityFields)] };\n            }\n            function findFirstQueryNameForExpr(selectTransforms, expr) {\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(expr, 'expr');\n                if (data.SQExpr.isSelectRef(expr))\n                    return expr.expressionName;\n                if (!selectTransforms)\n                    return;\n                for (var i = 0, len = selectTransforms.length; i < len; i++) {\n                    var select = selectTransforms[i], columnExpr = select.expr;\n                    if (!columnExpr || !data.SQExpr.equals(expr, select.expr))\n                        continue;\n                    return select.queryName;\n                }\n            }\n            /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\n            function findRuleInputColumnNumberRange(dataView, identifier, identifierKind) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                var columns = dataView.metadata.columns;\n                for (var i = 0, len = columns.length; i < len; i++) {\n                    var column = columns[i];\n                    if (identifierKind === 1 /* Role */) {\n                        var valueColRoles = column.roles;\n                        if (!valueColRoles || !valueColRoles[identifier])\n                            continue;\n                    }\n                    else {\n                        debug.assert(identifierKind === 0 /* QueryName */, 'identifierKind === ColumnIdentifierKind.QueryName');\n                        if (column.queryName !== identifier)\n                            continue;\n                    }\n                    var aggregates = column.aggregates;\n                    if (!aggregates)\n                        continue;\n                    var min = aggregates.min;\n                    if (min === undefined)\n                        min = aggregates.minLocal;\n                    if (min === undefined)\n                        continue;\n                    var max = aggregates.max;\n                    if (max === undefined)\n                        max = aggregates.maxLocal;\n                    if (max === undefined)\n                        continue;\n                    return { min: min, max: max };\n                }\n            }\n            // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\n            function createValueColumns(values, valueIdentityFields, source) {\n                if (values === void 0) { values = []; }\n                var result = values;\n                setGrouped(values);\n                if (valueIdentityFields)\n                    result.identityFields = valueIdentityFields;\n                if (source)\n                    result.source = source;\n                return result;\n            }\n            DataViewTransform.createValueColumns = createValueColumns;\n            function setGrouped(values, groupedResult) {\n                values.grouped = groupedResult\n                    ? function () { return groupedResult; }\n                    : function () { return groupValues(values); };\n            }\n            DataViewTransform.setGrouped = setGrouped;\n            /** Group together the values with a common identity. */\n            function groupValues(values) {\n                debug.assertValue(values, 'values');\n                var groups = [], currentGroup;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    if (!currentGroup || currentGroup.identity !== value.identity) {\n                        currentGroup = {\n                            values: []\n                        };\n                        if (value.identity) {\n                            currentGroup.identity = value.identity;\n                            var source = value.source;\n                            // allow null, which will be formatted as (Blank).\n                            if (source.groupName !== undefined)\n                                currentGroup.name = source.groupName;\n                            else if (source.displayName)\n                                currentGroup.name = source.displayName;\n                        }\n                        groups.push(currentGroup);\n                    }\n                    currentGroup.values.push(value);\n                }\n                return groups;\n            }\n            function pivotIfNecessary(dataView, dataViewMappings) {\n                debug.assertValue(dataView, 'dataView');\n                var transformedDataView;\n                switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\n                    case 1 /* Pivot */:\n                        transformedDataView = data.DataViewPivotCategorical.apply(dataView);\n                        break;\n                    case 2 /* SelfCrossJoin */:\n                        transformedDataView = data.DataViewSelfCrossJoin.apply(dataView);\n                        break;\n                }\n                return transformedDataView || dataView;\n            }\n            function determineCategoricalTransformation(categorical, dataViewMappings) {\n                if (!categorical || _.isEmpty(dataViewMappings))\n                    return;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var values = categorical.values;\n                if (_.isEmpty(values))\n                    return;\n                if (values.grouped().some(function (vg) { return !!vg.identity; }))\n                    return;\n                // If we made it here, the DataView has a single category and no valueGrouping.\n                var categoryRoles = categories[0].source.roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingCategorical = dataViewMappings[i].categorical;\n                    if (!roleMappingCategorical)\n                        continue;\n                    if (!hasRolesGrouped(categoryRoles, roleMappingCategorical.values))\n                        continue;\n                    // If we made it here, the DataView's single category has the value grouping role.\n                    var categoriesMapping = roleMappingCategorical.categories;\n                    var hasCategoryRole = hasRolesBind(categoryRoles, categoriesMapping) ||\n                        hasRolesFor(categoryRoles, categoriesMapping);\n                    if (hasCategoryRole)\n                        return 2 /* SelfCrossJoin */;\n                    return 1 /* Pivot */;\n                }\n            }\n            function shouldPivotMatrix(matrix, dataViewMappings) {\n                if (!matrix || _.isEmpty(dataViewMappings))\n                    return;\n                var rowLevels = matrix.rows.levels;\n                if (rowLevels.length < 1)\n                    return;\n                var rows = matrix.rows.root.children;\n                if (!rows || rows.length === 0)\n                    return;\n                var rowRoles = rowLevels[0].sources[0].roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingMatrix = dataViewMappings[i].matrix;\n                    if (!roleMappingMatrix)\n                        continue;\n                    if (!hasRolesFor(rowRoles, roleMappingMatrix.rows) &&\n                        hasRolesFor(rowRoles, roleMappingMatrix.columns)) {\n                        return true;\n                    }\n                }\n            }\n            function hasRolesBind(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.bind)\n                    return roles[roleMapping.bind.to];\n            }\n            function hasRolesFor(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.for)\n                    return roles[roleMapping.for.in];\n            }\n            function hasRolesGrouped(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.group)\n                    return roles[roleMapping.group.by];\n            }\n        })(DataViewTransform = data.DataViewTransform || (data.DataViewTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createDisplayNameGetter(displayNameKey) {\n            return function (resourceProvider) { return resourceProvider.get(displayNameKey); };\n        }\n        data.createDisplayNameGetter = createDisplayNameGetter;\n        function getDisplayName(displayNameGetter, resourceProvider) {\n            if (typeof displayNameGetter === 'function')\n                return displayNameGetter(resourceProvider);\n            if (typeof displayNameGetter === 'string')\n                return displayNameGetter;\n        }\n        data.getDisplayName = getDisplayName;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Enumeration of DateTimeUnits */\n    (function (DateTimeUnit) {\n        DateTimeUnit[DateTimeUnit[\"Year\"] = 0] = \"Year\";\n        DateTimeUnit[DateTimeUnit[\"Month\"] = 1] = \"Month\";\n        DateTimeUnit[DateTimeUnit[\"Week\"] = 2] = \"Week\";\n        DateTimeUnit[DateTimeUnit[\"Day\"] = 3] = \"Day\";\n        DateTimeUnit[DateTimeUnit[\"Hour\"] = 4] = \"Hour\";\n        DateTimeUnit[DateTimeUnit[\"Minute\"] = 5] = \"Minute\";\n        DateTimeUnit[DateTimeUnit[\"Second\"] = 6] = \"Second\";\n        DateTimeUnit[DateTimeUnit[\"Millisecond\"] = 7] = \"Millisecond\";\n    })(powerbi.DateTimeUnit || (powerbi.DateTimeUnit = {}));\n    var DateTimeUnit = powerbi.DateTimeUnit;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function fieldExpr(fieldExpr) {\n                var sqExpr = FieldExprPattern.visit(fieldExpr, FieldExprToSQExprVisitor.instance);\n                debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\n                return sqExpr;\n            }\n            SQExprBuilder.fieldExpr = fieldExpr;\n            function fromColumnAggr(columnAggr) {\n                return SQExprBuilder.aggregate(fromColumn(columnAggr), columnAggr.aggregate);\n            }\n            SQExprBuilder.fromColumnAggr = fromColumnAggr;\n            function fromColumn(column) {\n                return SQExprBuilder.columnRef(fromEntity(column), column.name);\n            }\n            SQExprBuilder.fromColumn = fromColumn;\n            function fromEntity(entityPattern) {\n                return SQExprBuilder.entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\n            }\n            SQExprBuilder.fromEntity = fromEntity;\n            function fromEntityAggr(entityAggr) {\n                return SQExprBuilder.aggregate(fromEntity(entityAggr), entityAggr.aggregate);\n            }\n            SQExprBuilder.fromEntityAggr = fromEntityAggr;\n            function fromHierarchyLevelAggr(hierarchyLevelAggr) {\n                return SQExprBuilder.aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\n            }\n            SQExprBuilder.fromHierarchyLevelAggr = fromHierarchyLevelAggr;\n            function fromHierarchyLevel(hierarchyLevelPattern) {\n                return SQExprBuilder.hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\n            }\n            SQExprBuilder.fromHierarchyLevel = fromHierarchyLevel;\n            function fromHierarchy(hierarchyPattern) {\n                return SQExprBuilder.hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\n            }\n            SQExprBuilder.fromHierarchy = fromHierarchy;\n            var FieldExprToSQExprVisitor = (function () {\n                function FieldExprToSQExprVisitor() {\n                }\n                FieldExprToSQExprVisitor.prototype.visitColumn = function (column) {\n                    return fromColumn(column);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return fromColumnAggr(columnAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariationPattern) {\n                    return SQExprBuilder.propertyVariationSource(this.visitEntity(columnHierarchyLevelVariationPattern.source), columnHierarchyLevelVariationPattern.source.name, columnHierarchyLevelVariationPattern.level.name);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntity = function (entityPattern) {\n                    return fromEntity(entityPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return fromEntityAggr(entityAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchy = function (hierarchyPattern) {\n                    return fromHierarchy(hierarchyPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevel = function (level) {\n                    return fromHierarchyLevel(level);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return fromHierarchyLevelAggr(hierarchyLevelAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitMeasure = function (measure) {\n                    return SQExprBuilder.measureRef(this.visitEntity(measure), measure.name);\n                };\n                FieldExprToSQExprVisitor.prototype.visitPercentile = function (percentile) {\n                    var arg = SQExprBuilder.fieldExpr(percentile.arg);\n                    return SQExprBuilder.percentile(arg, percentile.k, percentile.exclusive);\n                };\n                FieldExprToSQExprVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    var baseSQExpr = SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr);\n                    return SQExprBuilder.arithmetic(baseSQExpr, SQExprBuilder.scopedEval(baseSQExpr, []), 3 /* Divide */);\n                };\n                FieldExprToSQExprVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return SQExprBuilder.selectRef(selectRef.expressionName);\n                };\n                FieldExprToSQExprVisitor.instance = new FieldExprToSQExprVisitor();\n                return FieldExprToSQExprVisitor;\n            }());\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asFieldPattern(sqExpr) {\n                return sqExpr.accept(FieldExprPatternBuilder.instance);\n            }\n            SQExprConverter.asFieldPattern = asFieldPattern;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        var FieldExprPatternBuilder = (function (_super) {\n            __extends(FieldExprPatternBuilder, _super);\n            function FieldExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            FieldExprPatternBuilder.prototype.visitColumnRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var columnRef = sourceRef.entity;\n                    columnRef.name = expr.ref;\n                    return { column: columnRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitMeasureRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var measureRef = sourceRef.entity;\n                    measureRef.name = expr.ref;\n                    return { measure: measureRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            FieldExprPatternBuilder.prototype.visitAggr = function (expr) {\n                var fieldPattern = expr.arg.accept(this);\n                if (fieldPattern && fieldPattern.column) {\n                    var argAggr = fieldPattern.column;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.columnAggr) {\n                    var argAggr = fieldPattern.columnAggr;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.hierarchyLevel) {\n                    var argAggr = fieldPattern.hierarchyLevel;\n                    argAggr.aggregate = expr.func;\n                    return { hierarchyLevelAggr: argAggr };\n                }\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var argAggr = sourcePattern.entity;\n                    argAggr.aggregate = expr.func;\n                    return { entityAggr: argAggr };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitPercentile = function (expr) {\n                return {\n                    percentile: {\n                        arg: expr.arg.accept(this),\n                        k: expr.k,\n                        exclusive: expr.exclusive,\n                    }\n                };\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchy = function (expr) {\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var hierarchyRef = (sourcePattern.entity);\n                    hierarchyRef.name = expr.hierarchy;\n                    return { hierarchy: hierarchyRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchyLevel = function (expr) {\n                var hierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\n                if (!hierarchySourceExprPattern)\n                    return;\n                var hierarchyLevel;\n                if (hierarchySourceExprPattern.hierarchy) {\n                    hierarchyLevel = {\n                        entity: hierarchySourceExprPattern.hierarchy.entity,\n                        schema: hierarchySourceExprPattern.hierarchy.schema,\n                        name: hierarchySourceExprPattern.hierarchy.name,\n                        level: expr.level,\n                    };\n                }\n                if (hierarchySourceExprPattern.variation) {\n                    return {\n                        columnHierarchyLevelVariation: {\n                            source: {\n                                entity: hierarchySourceExprPattern.variation.column.entity,\n                                schema: hierarchySourceExprPattern.variation.column.schema,\n                                name: hierarchySourceExprPattern.variation.column.name,\n                            },\n                            level: hierarchyLevel,\n                            variationName: hierarchySourceExprPattern.variation.variationName,\n                        }\n                    };\n                }\n                return { hierarchyLevel: hierarchyLevel };\n            };\n            FieldExprPatternBuilder.prototype.visitArithmetic = function (expr) {\n                var percentOfGrandTotalPattern = {\n                    percentOfGrandTotal: {\n                        baseExpr: expr.left.accept(this)\n                    }\n                };\n                if (data.SQExpr.equals(expr, SQExprBuilder.fieldExpr(percentOfGrandTotalPattern))) {\n                    return percentOfGrandTotalPattern;\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitSelectRef = function (expr) {\n                return {\n                    selectRef: {\n                        expressionName: expr.expressionName,\n                    }\n                };\n            };\n            FieldExprPatternBuilder.instance = new FieldExprPatternBuilder();\n            return FieldExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var SourceExprPatternBuilder = (function (_super) {\n            __extends(SourceExprPatternBuilder, _super);\n            function SourceExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            SourceExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            SourceExprPatternBuilder.prototype.visitPropertyVariationSource = function (expr) {\n                var entityExpr = expr.arg;\n                if (entityExpr instanceof data.SQEntityExpr) {\n                    var propertyVariationSource = {\n                        schema: entityExpr.schema,\n                        entity: entityExpr.entity,\n                        name: expr.property,\n                    };\n                    if (entityExpr.variable)\n                        propertyVariationSource.entityVar = entityExpr.variable;\n                    return {\n                        variation: {\n                            column: propertyVariationSource,\n                            variationName: expr.name,\n                        }\n                    };\n                }\n            };\n            SourceExprPatternBuilder.instance = new SourceExprPatternBuilder();\n            return SourceExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var HierarchyExprPatternBuiler = (function (_super) {\n            __extends(HierarchyExprPatternBuiler, _super);\n            function HierarchyExprPatternBuiler() {\n                _super.apply(this, arguments);\n            }\n            HierarchyExprPatternBuiler.prototype.visitHierarchy = function (expr) {\n                var exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                var hierarchyRef;\n                var variationRef;\n                if (exprPattern.variation) {\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.variation.column.schema,\n                        entity: exprPattern.variation.column.entity,\n                    };\n                    variationRef = exprPattern.variation;\n                }\n                else\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.entity.schema,\n                        entity: exprPattern.entity.entity,\n                    };\n                return {\n                    hierarchy: hierarchyRef,\n                    variation: variationRef\n                };\n            };\n            HierarchyExprPatternBuiler.instance = new HierarchyExprPatternBuiler();\n            return HierarchyExprPatternBuiler;\n        }(data.DefaultSQExprVisitor));\n        var FieldExprPattern;\n        (function (FieldExprPattern) {\n            function visit(expr, visitor) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(visitor, 'visitor');\n                var fieldExprPattern = expr instanceof data.SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\n                debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\n                if (fieldExprPattern.column)\n                    return visitColumn(fieldExprPattern.column, visitor);\n                if (fieldExprPattern.columnAggr)\n                    return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\n                if (fieldExprPattern.columnHierarchyLevelVariation)\n                    return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\n                if (fieldExprPattern.entity)\n                    return visitEntity(fieldExprPattern.entity, visitor);\n                if (fieldExprPattern.entityAggr)\n                    return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\n                if (fieldExprPattern.hierarchy)\n                    return visitHierarchy(fieldExprPattern.hierarchy, visitor);\n                if (fieldExprPattern.hierarchyLevel)\n                    return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\n                if (fieldExprPattern.hierarchyLevelAggr)\n                    return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\n                if (fieldExprPattern.measure)\n                    return visitMeasure(fieldExprPattern.measure, visitor);\n                if (fieldExprPattern.percentile)\n                    return visitPercentile(fieldExprPattern.percentile, visitor);\n                if (fieldExprPattern.percentOfGrandTotal)\n                    return visitPercentOfGrandTotal(fieldExprPattern.percentOfGrandTotal, visitor);\n                if (fieldExprPattern.selectRef)\n                    return visitSelectRef(fieldExprPattern.selectRef, visitor);\n                debug.assertFail('failed to visit a fieldExprPattern.');\n                return;\n            }\n            FieldExprPattern.visit = visit;\n            function visitColumn(column, visitor) {\n                debug.assertValue(column, 'column');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumn(column);\n            }\n            function visitColumnAggr(columnAggr, visitor) {\n                debug.assertValue(columnAggr, 'columnAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnAggr(columnAggr);\n            }\n            function visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation, visitor) {\n                debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\n            }\n            function visitEntity(entity, visitor) {\n                debug.assertValue(entity, 'entity');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntity(entity);\n            }\n            function visitEntityAggr(entityAggr, visitor) {\n                debug.assertValue(entityAggr, 'entityAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntityAggr(entityAggr);\n            }\n            function visitHierarchy(hierarchy, visitor) {\n                debug.assertValue(hierarchy, 'hierarchy');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchy(hierarchy);\n            }\n            function visitHierarchyLevel(hierarchyLevel, visitor) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevel(hierarchyLevel);\n            }\n            function visitHierarchyLevelAggr(hierarchyLevelAggr, visitor) {\n                debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\n            }\n            function visitMeasure(measure, visitor) {\n                debug.assertValue(measure, 'measure');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitMeasure(measure);\n            }\n            function visitSelectRef(selectRef, visitor) {\n                debug.assertValue(selectRef, 'selectRef');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitSelectRef(selectRef);\n            }\n            function visitPercentile(percentile, visitor) {\n                debug.assertValue(percentile, 'percentile');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitPercentile(percentile);\n            }\n            function visitPercentOfGrandTotal(percentOfGrandTotal, visitor) {\n                debug.assertValue(percentOfGrandTotal, 'percentOfGrandTotal');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitPercentOfGrandTotal(percentOfGrandTotal);\n            }\n            function toColumnRefSQExpr(columnPattern) {\n                return SQExprBuilder.columnRef(SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar), columnPattern.name);\n            }\n            FieldExprPattern.toColumnRefSQExpr = toColumnRefSQExpr;\n            function getAggregate(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\n            }\n            FieldExprPattern.getAggregate = getAggregate;\n            function isAggregation(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                return visit(fieldExpr, FieldExprPatternIsAggregationVisitor.instance);\n            }\n            FieldExprPattern.isAggregation = isAggregation;\n            function hasFieldExprName(fieldExpr) {\n                return (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.measure) !== undefined;\n            }\n            FieldExprPattern.hasFieldExprName = hasFieldExprName;\n            function getPropertyName(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprPropertyNameVisitor.instance);\n            }\n            FieldExprPattern.getPropertyName = getPropertyName;\n            function getHierarchyName(fieldExpr) {\n                var hierarchy = fieldExpr.hierarchy;\n                if (hierarchy)\n                    return hierarchy.name;\n            }\n            FieldExprPattern.getHierarchyName = getHierarchyName;\n            function getColumnRef(fieldExpr) {\n                if (fieldExpr.columnHierarchyLevelVariation)\n                    return fieldExpr.columnHierarchyLevelVariation.source;\n                return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\n            }\n            FieldExprPattern.getColumnRef = getColumnRef;\n            function getFieldExprName(fieldExpr) {\n                var name = getPropertyName(fieldExpr);\n                if (name)\n                    return name;\n                // In case it is an entity\n                return toFieldExprEntityPattern(fieldExpr).entity;\n            }\n            FieldExprPattern.getFieldExprName = getFieldExprName;\n            function getSchema(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                var item = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                debug.assertAnyValue(item, 'expected fieldExpr to be an entity item');\n                return item.schema;\n            }\n            FieldExprPattern.getSchema = getSchema;\n            function toFieldExprEntityPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityPattern = toFieldExprEntityPattern;\n            function toFieldExprEntityItemPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityItemPattern = toFieldExprEntityItemPattern;\n            var FieldExprPatternAggregateVisitor = (function () {\n                function FieldExprPatternAggregateVisitor() {\n                }\n                FieldExprPatternAggregateVisitor.prototype.visitColumn = function (column) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return columnAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntity = function (entity) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return entityAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return hierarchyLevelAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitMeasure = function (measure) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitPercentile = function (percentile) {\n                    // NOTE: Percentile behaves like an aggregate (i.e., can be performed over numeric columns like a SUM), but\n                    // this function can't really convey that because percentile (intentionally) isn't in QueryAggregateFunction enum.\n                    // This should be revisited when we have UI support for the Percentile aggregate.\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return data.SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr));\n                };\n                FieldExprPatternAggregateVisitor.instance = new FieldExprPatternAggregateVisitor();\n                return FieldExprPatternAggregateVisitor;\n            }());\n            var FieldExprPatternIsAggregationVisitor = (function () {\n                function FieldExprPatternIsAggregationVisitor() {\n                }\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumn = function (column) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitEntity = function (entity) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitMeasure = function (measure) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitPercentile = function (percentile) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.instance = new FieldExprPatternIsAggregationVisitor();\n                return FieldExprPatternIsAggregationVisitor;\n            }());\n            var FieldExprToEntityExprPatternBuilder = (function () {\n                function FieldExprToEntityExprPatternBuilder() {\n                }\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumn = function (column) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnAggr = function (columnAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntity = function (entity) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntityAggr = function (entityAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchy = function (hierarchy) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitMeasure = function (measure) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitSelectRef = function (selectRef) {\n                    return;\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitPercentile = function (percentile) {\n                    return FieldExprPattern.visit(percentile.arg, this);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n                };\n                FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern = function (exprPattern) {\n                    debug.assertValue(exprPattern, 'exprPattern');\n                    var pattern = { schema: exprPattern.schema, entity: exprPattern.entity };\n                    if (exprPattern.entityVar) {\n                        pattern.entityVar = exprPattern.entityVar;\n                    }\n                    return pattern;\n                };\n                FieldExprToEntityExprPatternBuilder.instance = new FieldExprToEntityExprPatternBuilder();\n                return FieldExprToEntityExprPatternBuilder;\n            }());\n            var FieldExprPropertyNameVisitor = (function () {\n                function FieldExprPropertyNameVisitor() {\n                }\n                FieldExprPropertyNameVisitor.prototype.visitColumn = function (column) {\n                    return column.name;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return columnAggr.name;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitEntity = function (entity) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitMeasure = function (measure) {\n                    return measure.name;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitSelectRef = function (selectRef) {\n                    return;\n                };\n                FieldExprPropertyNameVisitor.prototype.visitPercentile = function (percentile) {\n                    return FieldExprPattern.visit(percentile.arg, this);\n                };\n                FieldExprPropertyNameVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n                };\n                FieldExprPropertyNameVisitor.instance = new FieldExprPropertyNameVisitor();\n                return FieldExprPropertyNameVisitor;\n            }());\n        })(FieldExprPattern = data.FieldExprPattern || (data.FieldExprPattern = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewAnalysis;\n    (function (DataViewAnalysis) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\n        (function (DataViewMappingMatchErrorCode) {\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooLarge\"] = 0] = \"conditionRangeTooLarge\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooSmall\"] = 1] = \"conditionRangeTooSmall\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedMeasure\"] = 2] = \"conditionKindExpectedMeasure\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGrouping\"] = 3] = \"conditionKindExpectedGrouping\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGroupingOrMeasure\"] = 4] = \"conditionKindExpectedGroupingOrMeasure\";\n        })(DataViewAnalysis.DataViewMappingMatchErrorCode || (DataViewAnalysis.DataViewMappingMatchErrorCode = {}));\n        var DataViewMappingMatchErrorCode = DataViewAnalysis.DataViewMappingMatchErrorCode;\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\n        function validateAndReshape(dataView, dataViewMappings) {\n            if (!dataViewMappings || dataViewMappings.length === 0)\n                return { dataView: dataView, isValid: true };\n            if (dataView) {\n                for (var _i = 0, dataViewMappings_3 = dataViewMappings; _i < dataViewMappings_3.length; _i++) {\n                    var dataViewMapping = dataViewMappings_3[_i];\n                    // Keep the original when possible.\n                    if (supports(dataView, dataViewMapping))\n                        return { dataView: dataView, isValid: true };\n                    if (dataViewMapping.categorical && dataView.categorical)\n                        return reshapeCategorical(dataView, dataViewMapping);\n                    if (dataViewMapping.tree && dataView.tree)\n                        return reshapeTree(dataView, dataViewMapping.tree);\n                    if (dataViewMapping.single && dataView.single)\n                        return reshapeSingle(dataView, dataViewMapping.single);\n                    if (dataViewMapping.table && dataView.table)\n                        return reshapeTable(dataView, dataViewMapping.table);\n                }\n            }\n            else if (powerbi.ScriptResultUtil.findScriptResult(dataViewMappings)) {\n                // Currently, PBI Service treats R Script Visuals as static images.\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\n                // to support the PBI Desktop scenario.\n                // This code will be removed once PBI Service fully supports R Script Visuals.\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\n                return { dataView: dataView, isValid: true };\n            }\n            return { isValid: false };\n        }\n        DataViewAnalysis.validateAndReshape = validateAndReshape;\n        function reshapeCategorical(dataView, dataViewMapping) {\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\n            var categoryRoleMapping = dataViewMapping.categorical;\n            var categorical = dataView.categorical;\n            if (!categorical)\n                return { isValid: false };\n            var rowCount;\n            if (categoryRoleMapping.rowCount) {\n                rowCount = categoryRoleMapping.rowCount.supported;\n                if (rowCount && rowCount.max) {\n                    var updated = void 0;\n                    var categories = categorical.categories;\n                    var maxRowCount = rowCount.max;\n                    var originalLength = undefined;\n                    if (categories) {\n                        for (var i = 0, len = categories.length; i < len; i++) {\n                            var category = categories[i];\n                            originalLength = category.values.length;\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                                // Row count too large: Trim it to fit.\n                                var updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\n                                updated = updated || { categories: [] };\n                                updated.categories.push({\n                                    source: category.source,\n                                    values: updatedCategories\n                                });\n                            }\n                        }\n                    }\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\n                        if (!originalLength)\n                            originalLength = categorical.values[0].values.length;\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                            updated = updated || {};\n                            updated.values = powerbi.data.DataViewTransform.createValueColumns();\n                            for (var i = 0, len = categorical.values.length; i < len; i++) {\n                                var column = categorical.values[i], updatedColumn = {\n                                    source: column.source,\n                                    values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\n                                };\n                                if (column.min !== undefined)\n                                    updatedColumn.min = column.min;\n                                if (column.max !== undefined)\n                                    updatedColumn.max = column.max;\n                                if (column.subtotal !== undefined)\n                                    updatedColumn.subtotal = column.subtotal;\n                                updated.values.push(updatedColumn);\n                            }\n                        }\n                    }\n                    if (updated) {\n                        dataView = {\n                            metadata: dataView.metadata,\n                            categorical: updated,\n                        };\n                    }\n                }\n            }\n            if (supportsCategorical(dataView, dataViewMapping))\n                return { dataView: dataView, isValid: true };\n            return null;\n        }\n        function reshapeSingle(dataView, singleRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (dataView.single)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTree(dataView, treeRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            // TODO: Need to implement the reshaping of Tree\n            var metadata = dataView.metadata;\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTable(dataView, tableRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (dataView.table)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function countGroups(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (!columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countGroups = countGroups;\n        function countMeasures(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countMeasures = countMeasures;\n        /** Indicates whether the dataView conforms to the specified schema. */\n        function supports(dataView, roleMapping, usePreferredDataViewSchema) {\n            if (!roleMapping || !dataView)\n                return false;\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\n                return false;\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\n                return false;\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\n                return false;\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\n                return false;\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\n                return false;\n            return true;\n        }\n        DataViewAnalysis.supports = supports;\n        function supportsCategorical(dataView, categoryRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\n            var dataViewCategorical = dataView.categorical;\n            if (!dataViewCategorical)\n                return false;\n            // TODO: Disabling this implementation isn't right.\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\n            //    return false;\n            if (categoryRoleMapping.rowCount) {\n                var rowCount = categoryRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\n                    rowCount = categoryRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\n                        len = dataViewCategorical.values[0].values.length;\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\n                        len = dataViewCategorical.categories[0].values.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsSingle(dataViewSingle, singleRoleMapping) {\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (!dataViewSingle)\n                return false;\n            return true;\n        }\n        function supportsTree(dataView, treeRoleMapping) {\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            var metadata = dataView.metadata;\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\n        }\n        function supportsTable(dataViewTable, tableRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (!dataViewTable)\n                return false;\n            if (tableRoleMapping.rowCount) {\n                var rowCount = tableRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\n                    rowCount = tableRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewTable.rows && dataViewTable.rows.length)\n                        len = dataViewTable.rows.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsScriptResult(dataView, scriptResultRoleMapping) {\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\n            if (!dataView)\n                return false;\n            if (!dataView.imageBase64)\n                return false;\n            return true;\n        }\n        /**\n         * Determines whether the value conforms to the range in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateRange(value, roleCondition, ignoreMin) {\n            debug.assertValue(value, 'value');\n            if (!roleCondition)\n                return;\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\n            if (roleCondition.max !== undefined && roleCondition.max < value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\n        }\n        DataViewAnalysis.validateRange = validateRange;\n        /**\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateKind(roleCondition, roleName, projections, roleKindByQueryRef) {\n            if (!roleCondition || roleCondition.kind === undefined) {\n                return;\n            }\n            var expectedKind = roleCondition.kind;\n            var roleCollection = projections[roleName];\n            if (roleCollection) {\n                var roleProjections = roleCollection.all();\n                for (var _i = 0, roleProjections_1 = roleProjections; _i < roleProjections_1.length; _i++) {\n                    var roleProjection = roleProjections_1[_i];\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\n                        switch (expectedKind) {\n                            case powerbi.VisualDataRoleKind.Measure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\n                            case powerbi.VisualDataRoleKind.Grouping:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\n                            case powerbi.VisualDataRoleKind.GroupingOrMeasure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\n                        }\n                    }\n                }\n            }\n        }\n        /** Determines the appropriate DataViewMappings for the projections. */\n        function chooseDataViewMappings(projections, mappings, roleKindByQueryRef, objectDescriptors, objectDefinitions) {\n            debug.assertValue(projections, 'projections');\n            debug.assertAnyValue(mappings, 'mappings');\n            var supportedMappings = [];\n            var errors = [];\n            if (!_.isEmpty(mappings)) {\n                for (var mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\n                    var mapping = mappings[mappingIndex], mappingConditions = mapping.conditions, requiredProperties = mapping.requiredProperties;\n                    var allPropertiesValid = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\n                    var conditionsMet = [];\n                    if (!_.isEmpty(mappingConditions)) {\n                        for (var conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\n                            var condition = mappingConditions[conditionIndex];\n                            var currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\n                            if (!_.isEmpty(currentConditionErrors)) {\n                                for (var _i = 0, currentConditionErrors_1 = currentConditionErrors; _i < currentConditionErrors_1.length; _i++) {\n                                    var error = currentConditionErrors_1[_i];\n                                    error.mappingIndex = mappingIndex;\n                                    error.conditionIndex = conditionIndex;\n                                    errors.push(error);\n                                }\n                            }\n                            else\n                                conditionsMet.push(condition);\n                        }\n                    }\n                    else {\n                        conditionsMet.push({});\n                    }\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\n                        var supportedMapping = _.cloneDeep(mapping);\n                        var updatedConditions = _.filter(conditionsMet, function (condition) { return Object.keys(condition).length > 0; });\n                        if (!_.isEmpty(updatedConditions))\n                            supportedMapping.conditions = updatedConditions;\n                        supportedMappings.push(supportedMapping);\n                    }\n                }\n            }\n            return {\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\n            };\n        }\n        DataViewAnalysis.chooseDataViewMappings = chooseDataViewMappings;\n        function checkForConditionErrors(projections, condition, roleKindByQueryRef) {\n            debug.assertValue(projections, 'projections');\n            debug.assertValue(condition, 'condition');\n            var conditionRoles = Object.keys(condition);\n            var errors = [];\n            for (var i = 0, len = conditionRoles.length; i < len; i++) {\n                var roleName = conditionRoles[i], isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs), roleCondition = condition[roleName];\n                var roleCount = getPropertyCount(roleName, projections, isDrillable);\n                var rangeError = validateRange(roleCount, roleCondition);\n                if (rangeError != null) {\n                    errors.push({\n                        code: rangeError,\n                        roleName: roleName,\n                    });\n                }\n                var kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\n                if (kindError != null) {\n                    errors.push({\n                        code: kindError,\n                        roleName: roleName,\n                    });\n                }\n            }\n            return errors;\n        }\n        function areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions) {\n            if (_.isEmpty(requiredProperties))\n                return true;\n            if (!objectDescriptors || !objectDefinitions)\n                return false;\n            var staticEvalContext = powerbi.data.createStaticEvalContext();\n            return _.every(requiredProperties, function (requiredProperty) {\n                var objectDescriptorValue = null;\n                var objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\n                if (objectDescriptorProperty)\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\n                var objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\n                if (!objectDescriptorValue || !objectDefinitionValue)\n                    return false;\n                return powerbi.data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\n            });\n        }\n        function getPropertyCount(roleName, projections, useActiveIfAvailable) {\n            debug.assertValue(roleName, 'roleName');\n            debug.assertValue(projections, 'projections');\n            var projectionsForRole = projections[roleName];\n            if (projectionsForRole) {\n                if (useActiveIfAvailable)\n                    return 1;\n                return projectionsForRole.all().length;\n            }\n            return 0;\n        }\n        DataViewAnalysis.getPropertyCount = getPropertyCount;\n        function hasSameCategoryIdentity(dataView1, dataView2) {\n            if (dataView1\n                && dataView2\n                && dataView1.categorical\n                && dataView2.categorical) {\n                var dv1Categories = dataView1.categorical.categories;\n                var dv2Categories = dataView2.categorical.categories;\n                if (dv1Categories\n                    && dv2Categories\n                    && dv1Categories.length === dv2Categories.length) {\n                    for (var i = 0, len = dv1Categories.length; i < len; i++) {\n                        var dv1Identity = dv1Categories[i].identity;\n                        var dv2Identity = dv2Categories[i].identity;\n                        var dv1Length = getLengthOptional(dv1Identity);\n                        if (dv1Length !== getLengthOptional(dv2Identity))\n                            return false;\n                        for (var j = 0; j < dv1Length; j++) {\n                            if (!powerbi.DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\n                                return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        DataViewAnalysis.hasSameCategoryIdentity = hasSameCategoryIdentity;\n        function getLengthOptional(identity) {\n            if (identity)\n                return identity.length;\n            return 0;\n        }\n        function areMetadataColumnsEquivalent(column1, column2) {\n            if (!column1 && !column2)\n                return true;\n            if (!column1 || !column2)\n                return false;\n            if (column1.displayName !== column2.displayName)\n                return false;\n            if (column1.queryName !== column2.queryName)\n                return false;\n            if (column1.isMeasure !== column2.isMeasure)\n                return false;\n            if (column1.type !== column2.type)\n                return false;\n            if (column1.sort !== column2.sort)\n                return false;\n            return true;\n        }\n        DataViewAnalysis.areMetadataColumnsEquivalent = areMetadataColumnsEquivalent;\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\n        function isMetadataEquivalent(metadata1, metadata2) {\n            if (!metadata1 && !metadata2)\n                return true;\n            if (!metadata1 || !metadata2)\n                return false;\n            var previousColumnsLength = metadata1.columns.length;\n            var newColumnsLength = metadata2.columns.length;\n            if (previousColumnsLength !== newColumnsLength)\n                return false;\n            for (var i = 0; i < newColumnsLength; i++) {\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\n                    return false;\n            }\n            return true;\n        }\n        DataViewAnalysis.isMetadataEquivalent = isMetadataEquivalent;\n    })(DataViewAnalysis = powerbi.DataViewAnalysis || (powerbi.DataViewAnalysis = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var Lazy = jsCommon.Lazy;\n        var DataViewRoleWildcard;\n        (function (DataViewRoleWildcard) {\n            function fromRoles(roles) {\n                return new DataViewRoleWildcardImpl(roles);\n            }\n            DataViewRoleWildcard.fromRoles = fromRoles;\n            function equals(firstRoleWildcard, secondRoleWildcard) {\n                return firstRoleWildcard.key &&\n                    secondRoleWildcard.key &&\n                    firstRoleWildcard.key === secondRoleWildcard.key &&\n                    ArrayExtensions.sequenceEqual(firstRoleWildcard.roles, secondRoleWildcard.roles, function (role1, role2) { return role1 === role2; });\n            }\n            DataViewRoleWildcard.equals = equals;\n            var DataViewRoleWildcardImpl = (function () {\n                function DataViewRoleWildcardImpl(roles) {\n                    var _this = this;\n                    debug.assertNonEmpty(roles, 'roles');\n                    this._roles = roles;\n                    this._key = new Lazy(function () { return JSON.stringify(_this.roles); });\n                }\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"roles\", {\n                    get: function () {\n                        return this._roles;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewRoleWildcardImpl;\n            }());\n        })(DataViewRoleWildcard = data.DataViewRoleWildcard || (data.DataViewRoleWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewScopeIdentity;\n    (function (DataViewScopeIdentity) {\n        /** Compares the two DataViewScopeIdentity values for equality. */\n        function equals(x, y, ignoreCase) {\n            // Normalize falsy to null\n            x = x || null;\n            y = y || null;\n            if (x === y)\n                return true;\n            if (!x !== !y)\n                return false;\n            debug.assertValue(x, 'x');\n            debug.assertValue(y, 'y');\n            return data.SQExpr.equals(x.expr, y.expr, ignoreCase);\n        }\n        DataViewScopeIdentity.equals = equals;\n        function filterFromIdentity(identities, isNot) {\n            if (_.isEmpty(identities))\n                return;\n            var exprs = [];\n            for (var _i = 0, identities_1 = identities; _i < identities_1.length; _i++) {\n                var identity = identities_1[_i];\n                exprs.push(identity.expr);\n            }\n            return filterFromExprs(exprs, isNot);\n        }\n        DataViewScopeIdentity.filterFromIdentity = filterFromIdentity;\n        function filterFromExprs(orExprs, isNot) {\n            if (_.isEmpty(orExprs))\n                return;\n            var resultExpr;\n            for (var _i = 0, orExprs_1 = orExprs; _i < orExprs_1.length; _i++) {\n                var orExpr = orExprs_1[_i];\n                var inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\n                if (resultExpr)\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\n                else\n                    resultExpr = inExpr || orExpr;\n            }\n            if (resultExpr) {\n                if (isNot)\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\n            }\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\n        }\n        DataViewScopeIdentity.filterFromExprs = filterFromExprs;\n    })(DataViewScopeIdentity = powerbi.DataViewScopeIdentity || (powerbi.DataViewScopeIdentity = {}));\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        function createDataViewScopeIdentity(expr) {\n            return new DataViewScopeIdentityImpl(expr);\n        }\n        data.createDataViewScopeIdentity = createDataViewScopeIdentity;\n        var DataViewScopeIdentityImpl = (function () {\n            function DataViewScopeIdentityImpl(expr) {\n                debug.assertValue(expr, 'expr');\n                this._expr = expr;\n                this._key = new Lazy(function () { return data.SQExprShortSerializer.serialize(expr); });\n            }\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"expr\", {\n                get: function () {\n                    return this._expr;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"key\", {\n                get: function () {\n                    return this._key.getValue();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return DataViewScopeIdentityImpl;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        var DataViewScopeWildcard;\n        (function (DataViewScopeWildcard) {\n            function matches(wildcard, instance) {\n                var instanceExprs = data.ScopeIdentityExtractor.getKeys(instance.expr);\n                if (!instanceExprs)\n                    return false;\n                return data.SQExprUtils.sequenceEqual(wildcard.exprs, instanceExprs);\n            }\n            DataViewScopeWildcard.matches = matches;\n            function equals(firstScopeWildcard, secondScopeWildcard) {\n                return firstScopeWildcard.key === secondScopeWildcard.key &&\n                    data.SQExprUtils.sequenceEqual(firstScopeWildcard.exprs, secondScopeWildcard.exprs);\n            }\n            DataViewScopeWildcard.equals = equals;\n            function fromExprs(exprs) {\n                return new DataViewScopeWildcardImpl(exprs);\n            }\n            DataViewScopeWildcard.fromExprs = fromExprs;\n            var DataViewScopeWildcardImpl = (function () {\n                function DataViewScopeWildcardImpl(exprs) {\n                    debug.assertValue(exprs, 'exprs');\n                    this._exprs = exprs;\n                    this._key = new Lazy(function () { return data.SQExprShortSerializer.serializeArray(exprs); });\n                }\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"exprs\", {\n                    get: function () {\n                        return this._exprs;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewScopeWildcardImpl;\n            }());\n        })(DataViewScopeWildcard = data.DataViewScopeWildcard || (data.DataViewScopeWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createColorAllocatorCache() {\n            return new ColorAllocatorProvider();\n        }\n        data.createColorAllocatorCache = createColorAllocatorCache;\n        var ColorAllocatorProvider = (function () {\n            function ColorAllocatorProvider() {\n                this.cache = [];\n            }\n            ColorAllocatorProvider.prototype.get = function (key) {\n                debug.assertValue(key, 'key');\n                for (var _i = 0, _a = this.cache; _i < _a.length; _i++) {\n                    var entry = _a[_i];\n                    if (entry.key === key)\n                        return entry.allocator;\n                }\n            };\n            ColorAllocatorProvider.prototype.register = function (key, colorAllocator) {\n                debug.assertValue(key, 'key');\n                debug.assertValue(colorAllocator, 'colorAllocator');\n                debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\n                this.cache.push({\n                    key: key,\n                    allocator: colorAllocator,\n                });\n                return this;\n            };\n            return ColorAllocatorProvider;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewRegression;\n        (function (DataViewRegression) {\n            // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\n            // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\n            var regressionXQueryName = 'RegressionX';\n            var regressionSeriesQueryName = 'RegressionSeries';\n            DataViewRegression.regressionYQueryName = 'RegressionY';\n            function run(options) {\n                debug.assertValue(options, 'options');\n                var dataViewMappings = options.dataViewMappings;\n                var visualDataViews = options.visualDataViews;\n                var dataRoles = options.dataRoles;\n                var objectDescriptors = options.objectDescriptors;\n                var objectDefinitions = options.objectDefinitions;\n                var colorAllocatorFactory = options.colorAllocatorFactory;\n                var transformSelects = options.transformSelects;\n                var projectionActiveItems = options.projectionActiveItems;\n                var metadata = options.metadata;\n                if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\n                    // compute linear regression line if applicable\n                    var roleKindByQueryRef = data.DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\n                    var projections = data.DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\n                    if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\n                        return visualDataViews;\n                    var applicableDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\n                    if (applicableDataViewMappings) {\n                        var regressionDataViewMapping = _.find(applicableDataViewMappings, function (dataViewMapping) {\n                            return dataViewMapping.usage && dataViewMapping.usage.regression;\n                        });\n                        if (regressionDataViewMapping) {\n                            var regressionDataViews = [];\n                            for (var _i = 0, visualDataViews_1 = visualDataViews; _i < visualDataViews_1.length; _i++) {\n                                var visualDataView = visualDataViews_1[_i];\n                                var regressionDataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                                if (regressionDataView)\n                                    regressionDataViews.push(regressionDataView);\n                            }\n                            if (!_.isEmpty(regressionDataViews))\n                                visualDataViews.push.apply(visualDataViews, regressionDataViews);\n                        }\n                    }\n                }\n                return visualDataViews;\n            }\n            DataViewRegression.run = run;\n            /**\n             * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\n             * It works on scalar axis only.\n             * The algorithm is as follows\n             *\n             * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\n             * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\n             * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\n             * If highlights values are present, repeat steps 2 & 3 using highlight values.\n             * 4. Create the new dataView using the points computed above\n             */\n            function linearRegressionTransform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\n                debug.assertValue(dataRoles, 'dataRoles');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!sourceDataView.categorical)\n                    return;\n                // Step 1\n                var xColumns = getColumnsForCartesianRoleKind(0 /* X */, sourceDataView.categorical, dataRoles);\n                var yColumns = getColumnsForCartesianRoleKind(1 /* Y */, sourceDataView.categorical, dataRoles);\n                if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\n                    return;\n                var xColumnSource = xColumns[0].source;\n                var yColumnSource = yColumns[0].source;\n                var combineSeries = true;\n                if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\n                    var regressionUsage = regressionDataViewMapping.usage.regression;\n                    var combineSeriesPropertyId = regressionUsage['combineSeries'];\n                    if (combineSeriesPropertyId) {\n                        combineSeries = powerbi.DataViewObjects.getValue(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\n                    }\n                }\n                // Step 2\n                var dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\n                var lineDefSet = calculateLineDefinitions(dataPointsBySeries);\n                if (!lineDefSet)\n                    return;\n                var xMin = lineDefSet.xMin;\n                var xMax = lineDefSet.xMax;\n                var shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\n                var highlightsLineDefSet;\n                if (shouldComputeHightlights) {\n                    var highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\n                    highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\n                    if (highlightsLineDefSet) {\n                        xMin = _.min([xMin, highlightsLineDefSet.xMin]);\n                        xMax = _.max([xMax, highlightsLineDefSet.xMax]);\n                    }\n                    else {\n                        shouldComputeHightlights = false;\n                    }\n                }\n                // Step 3\n                var valuesByTrend = [];\n                for (var _i = 0, _a = lineDefSet.lineDefs; _i < _a.length; _i++) {\n                    var trend = _a[_i];\n                    valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                }\n                var highlightsByTrend;\n                if (shouldComputeHightlights) {\n                    highlightsByTrend = [];\n                    for (var _b = 0, _c = highlightsLineDefSet.lineDefs; _b < _c.length; _b++) {\n                        var trend = _c[_b];\n                        highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                    }\n                }\n                // Step 4\n                var groupValues;\n                if (combineSeries) {\n                    groupValues = ['combinedRegressionSeries'];\n                }\n                else {\n                    // If we are producing a trend line per series we need to maintain the group identities so that we can map between the\n                    // trend line and the original series (to match the color for example).\n                    if (sourceDataView.categorical.values.source) {\n                        // Source data view has dynamic series.\n                        var groups = sourceDataView.categorical.values.grouped();\n                        groupValues = _.map(groups, function (group) { return group.name; });\n                    }\n                    else {\n                        // Source data view has static or no series.\n                        groupValues = _.map(yColumns, function (column) { return column.source.queryName; });\n                    }\n                }\n                // Step 5\n                var regressionDataView = createRegressionDataView(xColumnSource, yColumnSource, groupValues, [xMin, xMax], valuesByTrend, highlightsByTrend, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                return regressionDataView;\n            }\n            DataViewRegression.linearRegressionTransform = linearRegressionTransform;\n            function calculateLineDefinitions(dataPointsBySeries) {\n                var xMin;\n                var xMax;\n                var lineDefs = [];\n                for (var _i = 0, dataPointsBySeries_1 = dataPointsBySeries; _i < dataPointsBySeries_1.length; _i++) {\n                    var dataPointSet = dataPointsBySeries_1[_i];\n                    var unsortedXValues = dataPointSet.xValues;\n                    var unsortedYValues = dataPointSet.yValues;\n                    if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\n                        return;\n                    // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\n                    var xDataType = getDataType(unsortedXValues);\n                    if (!xDataType)\n                        return;\n                    var yDataType = getDataType(unsortedYValues);\n                    if (!yDataType)\n                        return;\n                    var sortedDataPointSet = sortValues(unsortedXValues, unsortedYValues);\n                    var minCategoryValue = sortedDataPointSet.xValues[0];\n                    var maxCategoryValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\n                    var lineDef = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\n                    xMin = _.min([xMin, minCategoryValue]);\n                    xMax = _.max([xMax, maxCategoryValue]);\n                    lineDefs.push(lineDef);\n                }\n                return {\n                    lineDefs: lineDefs,\n                    xMin: xMin,\n                    xMax: xMax,\n                };\n            }\n            function getColumnsForCartesianRoleKind(roleKind, categorical, roles) {\n                debug.assertValue(roleKind, 'roleKind');\n                debug.assertValue(categorical, 'categorical');\n                var columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n                var categories = categorical.categories;\n                if (_.isEmpty(categories))\n                    return;\n                debug.assert(categories.length === 1, 'composite category columns not supported');\n                var categoryColumn = categories[0];\n                columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n            }\n            function getColumnsWithRoleKind(roleKind, columns, roles) {\n                if (_.isEmpty(columns))\n                    return;\n                return _.filter(columns, function (column) {\n                    var _loop_1 = function(roleName) {\n                        if (!column.source.roles[roleName])\n                            return \"continue\";\n                        var role = _.find(roles, function (role) { return role.name === roleName; });\n                        if (role && role.cartesianKind === roleKind)\n                            return { value: true };\n                    };\n                    for (var roleName in column.source.roles) {\n                        var state_1 = _loop_1(roleName);\n                        if (typeof state_1 === \"object\") return state_1.value;\n                        if (state_1 === \"continue\") continue;\n                    }\n                    return false;\n                });\n            }\n            function getDataType(values) {\n                var firstNonNull = _.find(values, function (value) { return value != null; });\n                if (firstNonNull == null)\n                    return;\n                var dataType = typeof firstNonNull;\n                if (_.some(values, function (value) { return value != null && typeof value !== dataType; }))\n                    return;\n                return dataType;\n            }\n            function sortValues(unsortedXValues, unsortedYValues) {\n                debug.assertValue(unsortedXValues, 'unsortedXValues');\n                debug.assertValue(unsortedYValues, 'unsortedYValues');\n                var zippedValues = _.zip(unsortedXValues, unsortedYValues);\n                var _a = _.chain(zippedValues)\n                    .filter(function (valuePair) { return valuePair[0] != null && valuePair[1] != null; })\n                    .sortBy(function (valuePair) { return valuePair[0]; })\n                    .unzip()\n                    .value(), xValues = _a[0], yValues = _a[1];\n                return {\n                    xValues: xValues,\n                    yValues: yValues\n                };\n            }\n            /**\n             * Computes a line definition using linear regression.\n             *   xBar: average of X values, yBar: average of Y values\n             *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\n             *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\n             *   Slope: ssXY / ssXX\n             *   Intercept: yBar - xBar * slope\n             */\n            function computeRegressionLine(xValues, yValues) {\n                debug.assertValue(xValues, 'xValues');\n                debug.assertValue(yValues, 'yValues');\n                var xBar = _.sum(xValues) / xValues.length;\n                var yBar = _.sum(yValues) / yValues.length;\n                var ssXX = _.chain(xValues)\n                    .map(function (x) {\n                    return Math.pow((x - xBar), 2);\n                })\n                    .sum();\n                var ssXY = _.chain(xValues)\n                    .map(function (x, i) {\n                    return (x - xBar) * (yValues[i] - yBar);\n                })\n                    .sum();\n                var slope = ssXY / ssXX;\n                var intercept = yBar - (xBar * slope);\n                return {\n                    slope: slope,\n                    intercept: intercept\n                };\n            }\n            function computeLineYValues(lineDef, x1, x2) {\n                return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\n            }\n            function getValuesFromColumn(column, preferHighlights) {\n                if (preferHighlights) {\n                    // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\n                    var valueColumn = column;\n                    if (valueColumn.highlights) {\n                        return valueColumn.highlights;\n                    }\n                }\n                return column.values;\n            }\n            function getDataPointsBySeries(xColumns, yColumns, combineSeries, preferHighlights) {\n                var dataPointsBySeries = [];\n                var xValueArray = _.map(xColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var seriesYValues = _.map(yColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var multipleXValueColumns = xColumns.length > 1;\n                for (var i = 0; i < seriesYValues.length; i++) {\n                    var xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\n                    var yValues = seriesYValues[i];\n                    if (combineSeries && dataPointsBySeries.length > 0) {\n                        dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\n                        dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\n                    }\n                    else {\n                        dataPointsBySeries.push({\n                            xValues: xValues,\n                            yValues: yValues,\n                        });\n                    }\n                }\n                return dataPointsBySeries;\n            }\n            function createRegressionDataView(xColumnSource, yColumnSource, groupValues, categories, values, highlights, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(xColumnSource, 'xColumnSource');\n                debug.assertValue(yColumnSource, 'yColumnSource');\n                debug.assertValue(categories, 'categories');\n                debug.assertValue(values, 'values');\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertAnyValue(highlights, 'highlights');\n                debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\n                var xRole = regressionDataViewMapping.categorical.categories.for.in;\n                var grouped = regressionDataViewMapping.categorical.values.group;\n                var yRole;\n                var seriesRole;\n                if (grouped && !_.isEmpty(grouped.select)) {\n                    yRole = grouped.select[0].for ?\n                        grouped.select[0].for.in :\n                        grouped.select[0].bind.to;\n                    seriesRole = grouped.by;\n                }\n                if (!yRole || !seriesRole)\n                    return;\n                var categoricalRoles = (_a = {}, _a[xRole] = true, _a);\n                var valueRoles = (_b = {}, _b[yRole] = true, _b);\n                var seriesRoles = (_c = {}, _c[seriesRole] = true, _c);\n                var valuesBySeries = [];\n                for (var index in values) {\n                    var seriesData = {\n                        values: values[index],\n                    };\n                    if (highlights)\n                        seriesData.highlights = highlights[index];\n                    valuesBySeries.push([seriesData]);\n                }\n                var regressionDataView = data.createCategoricalDataViewBuilder()\n                    .withCategory({\n                    source: {\n                        displayName: xColumnSource.displayName,\n                        queryName: regressionXQueryName,\n                        type: xColumnSource.type,\n                        isMeasure: false,\n                        roles: categoricalRoles\n                    },\n                    values: categories,\n                    identityFrom: {\n                        fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\n                    },\n                })\n                    .withGroupedValues({\n                    groupColumn: {\n                        source: {\n                            displayName: yColumnSource.displayName + 'Regression',\n                            queryName: regressionSeriesQueryName,\n                            type: yColumnSource.type,\n                            isMeasure: yColumnSource.isMeasure,\n                            roles: seriesRoles\n                        },\n                        values: groupValues,\n                        identityFrom: {\n                            fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\n                        }\n                    },\n                    valueColumns: [{\n                            source: {\n                                displayName: yColumnSource.displayName,\n                                queryName: DataViewRegression.regressionYQueryName,\n                                type: yColumnSource.type,\n                                isMeasure: yColumnSource.isMeasure,\n                                roles: valueRoles\n                            },\n                        }],\n                    data: valuesBySeries\n                })\n                    .build();\n                data.DataViewTransform.transformObjects(regressionDataView, 1 /* Categorical */, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\n                return regressionDataView;\n                var _a, _b, _c;\n            }\n            function hasHighlightValues(columns) {\n                return _.any(columns, function (column) {\n                    var valueColumn = column;\n                    return valueColumn.highlights != null;\n                });\n            }\n        })(DataViewRegression = data.DataViewRegression || (data.DataViewRegression = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelectTransform;\n        (function (DataViewSelectTransform) {\n            /** Convert selection info to projections */\n            function projectionsFromSelects(selects, projectionActiveItems) {\n                debug.assertAnyValue(selects, \"selects\");\n                debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\n                var projections = {};\n                for (var _i = 0, selects_1 = selects; _i < selects_1.length; _i++) {\n                    var select = selects_1[_i];\n                    if (!select)\n                        continue;\n                    var roles = select.roles;\n                    if (!roles)\n                        continue;\n                    for (var roleName in roles) {\n                        if (roles[roleName]) {\n                            var qp = projections[roleName];\n                            if (!qp)\n                                qp = projections[roleName] = new data.QueryProjectionCollection([]);\n                            qp.all().push({ queryRef: select.queryName });\n                            if (projectionActiveItems && projectionActiveItems[roleName])\n                                qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], function (activeItem) { return activeItem.queryRef; });\n                        }\n                    }\n                }\n                return projections;\n            }\n            DataViewSelectTransform.projectionsFromSelects = projectionsFromSelects;\n            /** Use selections and metadata to fashion query role kinds */\n            function createRoleKindFromMetadata(selects, metadata) {\n                var roleKindByQueryRef = {};\n                for (var _i = 0, _a = metadata.columns; _i < _a.length; _i++) {\n                    var column = _a[_i];\n                    if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\n                        continue;\n                    var select = selects[column.index];\n                    if (select) {\n                        var queryRef = select.queryName;\n                        if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\n                            roleKindByQueryRef[queryRef] = column.isMeasure ? powerbi.VisualDataRoleKind.Measure : powerbi.VisualDataRoleKind.Grouping;\n                        }\n                    }\n                }\n                return roleKindByQueryRef;\n            }\n            DataViewSelectTransform.createRoleKindFromMetadata = createRoleKindFromMetadata;\n        })(DataViewSelectTransform = data.DataViewSelectTransform || (data.DataViewSelectTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createCategoricalEvalContext(colorAllocatorProvider, dataViewCategorical) {\n            return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\n        }\n        data.createCategoricalEvalContext = createCategoricalEvalContext;\n        var CategoricalEvalContext = (function () {\n            function CategoricalEvalContext(colorAllocatorProvider, dataView) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.columnsByRole = {};\n            }\n            CategoricalEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            CategoricalEvalContext.prototype.getExprValue = function (expr) {\n                return;\n            };\n            CategoricalEvalContext.prototype.getRoleValue = function (roleName) {\n                var columnsByRole = this.columnsByRole;\n                var column = columnsByRole[roleName];\n                if (!column)\n                    column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\n                if (!column)\n                    return;\n                var index = this.index;\n                if (index != null)\n                    return column.values[this.index];\n            };\n            CategoricalEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.index = index;\n            };\n            return CategoricalEvalContext;\n        }());\n        function findRuleInputColumn(dataViewCategorical, inputRole) {\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n            return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\n                findRuleInputInColumns(dataViewCategorical.categories, inputRole);\n        }\n        function findRuleInputInColumns(columns, inputRole) {\n            debug.assertAnyValue(columns, 'columns');\n            if (!columns)\n                return;\n            for (var _i = 0, columns_7 = columns; _i < columns_7.length; _i++) {\n                var column = columns_7[_i];\n                var roles = column.source.roles;\n                if (!roles || !roles[inputRole])\n                    continue;\n                return column;\n            }\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createTableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms) {\n            return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\n        }\n        data.createTableEvalContext = createTableEvalContext;\n        var TableEvalContext = (function () {\n            function TableEvalContext(colorAllocatorProvider, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            TableEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            TableEvalContext.prototype.getExprValue = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var rowIdx = this.rowIdx;\n                if (rowIdx == null)\n                    return;\n                return data.getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\n            };\n            TableEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            TableEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.rowIdx = index;\n            };\n            return TableEvalContext;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var RuleEvaluation = (function () {\n            function RuleEvaluation() {\n            }\n            // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\n            RuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\n            };\n            return RuleEvaluation;\n        }());\n        data.RuleEvaluation = RuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ColorRuleEvaluation = (function (_super) {\n            __extends(ColorRuleEvaluation, _super);\n            function ColorRuleEvaluation(inputRole, allocator) {\n                debug.assertValue(inputRole, 'inputRole');\n                debug.assertValue(allocator, 'allocator');\n                _super.call(this);\n                this.inputRole = inputRole;\n                this.allocator = allocator;\n            }\n            ColorRuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertValue(evalContext, 'evalContext');\n                var value = evalContext.getRoleValue(this.inputRole);\n                if (value !== undefined)\n                    return this.allocator.color(value);\n            };\n            return ColorRuleEvaluation;\n        }(data.RuleEvaluation));\n        data.ColorRuleEvaluation = ColorRuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var inherit = powerbi.Prototype.inherit;\n            var inheritSingle = powerbi.Prototype.inheritSingle;\n            var ArrayExtensions = jsCommon.ArrayExtensions;\n            var DataViewMatrixUtils;\n            (function (DataViewMatrixUtils) {\n                /**\n                 * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the\n                 * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the\n                 * particular leaf node in the context of this forEachLeafNode(...) invocation.\n                 *\n                 * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\n                 *\n                 * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified\n                 * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\n                 * then treePath will be an array of length 1 containing that very node.\n                 *\n                 * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\n                 * If your callback needs to retain a copy of the treePath, please clone the array before returning.\n                 */\n                function forEachLeafNode(rootNodes, callback) {\n                    debug.assertAnyValue(rootNodes, 'rootNodes');\n                    debug.assertValue(callback, 'callback');\n                    // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\n                    // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \n                    // for the fact that all the properties on DataViewMatrixNode are optional...\n                    if (rootNodes) {\n                        if (isNodeArray(rootNodes)) {\n                            var index = 0;\n                            for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {\n                                var rootNode = rootNodes_1[_i];\n                                if (rootNode) {\n                                    index = forEachLeafNodeRecursive(rootNode, index, [], callback);\n                                }\n                            }\n                        }\n                        else {\n                            forEachLeafNodeRecursive(rootNodes, 0, [], callback);\n                        }\n                    }\n                }\n                DataViewMatrixUtils.forEachLeafNode = forEachLeafNode;\n                function isNodeArray(nodeOrNodeArray) {\n                    return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\n                }\n                /**\n                 * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\n                 * Returns the index for the next node after the last node that this function invokes callback with.\n                 *\n                 * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\n                 */\n                function forEachLeafNodeRecursive(matrixNode, nextIndex, treePath, callback) {\n                    debug.assertValue(matrixNode, 'matrixNode');\n                    debug.assertValue(treePath, 'treePath');\n                    debug.assertValue(callback, 'callback');\n                    // If treePath already contains matrixNode, then either one of the following errors has happened:\n                    // 1. the caller code mistakenly added matrixNode to treePath, or\n                    // 2. the callback modified treePath by adding a node to it, or\n                    // 3. the matrix hierarchy contains a cyclical node reference.');\n                    debug.assert(!_.contains(treePath, matrixNode), 'pre-condition: treePath must not already contain matrixNode');\n                    treePath.push(matrixNode);\n                    if (_.isEmpty(matrixNode.children)) {\n                        callback(matrixNode, nextIndex, treePath);\n                        nextIndex++;\n                    }\n                    else {\n                        var children = matrixNode.children;\n                        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n                            var nextChild = children_1[_i];\n                            if (nextChild) {\n                                nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\n                            }\n                        }\n                    }\n                    debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\n                    treePath.pop();\n                    return nextIndex;\n                }\n                /**\n                 * Returned an object tree where each node and its children property are inherited from the specified node\n                 * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\n                 *\n                 * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array\n                 * property, i.e. its children property is the same array object referenced in the input node's object tree.\n                 *\n                 * @param node The input node with the hierarchy object tree.\n                 * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\n                 * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is\n                 * not already an inherited object. Same goes for the node's children property.  This is useful for creating\n                 * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for\n                 * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains\n                 * inherited objects.\n                 */\n                function inheritMatrixNodeHierarchy(node, deepestLevelToInherit, useInheritSingle) {\n                    debug.assertValue(node, 'node');\n                    debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\n                    debug.assertValue(useInheritSingle, 'useInheritSingle');\n                    var returnNode = node;\n                    // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\n                    // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\n                    // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\n                    //  {\n                    //    \"level\": 0,\n                    //    \"isSubtotal\": true,\n                    //    \"children\": [\n                    //      { \"level\": 2, \"isSubtotal\": true },\n                    //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\n                    //    ]\n                    //  }\n                    var isRootNode = _.isUndefined(node.level);\n                    var shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\n                    if (shouldInheritCurrentNode) {\n                        var inheritFunc = useInheritSingle ? inheritSingle : inherit;\n                        var inheritedNode = inheritFunc(node);\n                        var shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\n                        if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\n                            inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\n                            for (var i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\n                                inheritedNode.children[i] =\n                                    inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\n                            }\n                        }\n                        returnNode = inheritedNode;\n                    }\n                    return returnNode;\n                }\n                DataViewMatrixUtils.inheritMatrixNodeHierarchy = inheritMatrixNodeHierarchy;\n                /**\n                 * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\n                 * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\n                 * Year === 2016, Quarter === 'Qtr 1', Month === 1.\n                 *\n                 * Returns false if the specified matrixOrHierarchy does not contain any composite group,\n                 * or if matrixOrHierarchy is null or undefined.\n                 */\n                function containsCompositeGroup(matrixOrHierarchy) {\n                    debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\n                    var hasCompositeGroup = false;\n                    if (matrixOrHierarchy) {\n                        if (isMatrix(matrixOrHierarchy)) {\n                            hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\n                                containsCompositeGroup(matrixOrHierarchy.columns);\n                        }\n                        else {\n                            var hierarchyLevels = matrixOrHierarchy.levels;\n                            if (!_.isEmpty(hierarchyLevels)) {\n                                for (var _i = 0, hierarchyLevels_1 = hierarchyLevels; _i < hierarchyLevels_1.length; _i++) {\n                                    var level = hierarchyLevels_1[_i];\n                                    // it takes at least 2 columns at the same hierarchy level to form a composite group...\n                                    if (level.sources && (level.sources.length >= 2)) {\n                                        debug.assert(_.all(level.sources, function (sourceColumn) { return sourceColumn.isMeasure === level.sources[0].isMeasure; }), 'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\n                                        // Measure headers are not group\n                                        var isMeasureHeadersLevel = level.sources[0].isMeasure;\n                                        if (!isMeasureHeadersLevel) {\n                                            hasCompositeGroup = true;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return hasCompositeGroup;\n                }\n                DataViewMatrixUtils.containsCompositeGroup = containsCompositeGroup;\n                function isMatrix(matrixOrHierarchy) {\n                    return 'rows' in matrixOrHierarchy &&\n                        'columns' in matrixOrHierarchy &&\n                        'valueSources' in matrixOrHierarchy;\n                }\n            })(DataViewMatrixUtils = utils.DataViewMatrixUtils || (utils.DataViewMatrixUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var DataViewMetadataColumnUtils;\n            (function (DataViewMetadataColumnUtils) {\n                /**\n                 * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\n                 */\n                function isForRole(metadataColumn, targetRole) {\n                    debug.assertValue(metadataColumn, 'metadataColumn');\n                    debug.assertValue(targetRole, 'targetRole');\n                    var roles = metadataColumn.roles;\n                    return roles && roles[targetRole];\n                }\n                DataViewMetadataColumnUtils.isForRole = isForRole;\n                /**\n                 * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\n                 *\n                 * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the\n                 * specified columnSources must be a non-filtered array of column sources from the DataView, such as\n                 * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\n                 *\n                 * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\n                 * @param projection The projection ordering.  It must contain an ordering for the specified role.\n                 * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\n                 */\n                function joinMetadataColumnsAndProjectionOrder(columnSources, projection, role) {\n                    debug.assertAnyValue(columnSources, 'columnSources');\n                    debug.assert(_.all(columnSources, function (column) { return _.isNumber(column.index); }), 'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\n                    debug.assertNonEmpty(projection[role], 'projection[role]');\n                    debug.assert(_.all(columnSources, function (column) { return !isForRole(column, role) || _.contains(projection[role], column.index); }), 'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\n                    var jointResult = [];\n                    if (!_.isEmpty(columnSources)) {\n                        var projectionOrderSelectIndices = projection[role];\n                        var selectIndexToProjectionIndexMap = {};\n                        for (var i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\n                            var selectIndex = projectionOrderSelectIndices[i];\n                            selectIndexToProjectionIndexMap[selectIndex] = i;\n                        }\n                        for (var j = 0, jlen = columnSources.length; j < jlen; j++) {\n                            var column = columnSources[j];\n                            if (isForRole(column, role)) {\n                                var jointColumnInfo = {\n                                    metadataColumn: column,\n                                    sourceIndex: j,\n                                    projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\n                                };\n                                jointResult.push(jointColumnInfo);\n                            }\n                        }\n                    }\n                    return jointResult;\n                }\n                DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder = joinMetadataColumnsAndProjectionOrder;\n            })(DataViewMetadataColumnUtils = utils.DataViewMetadataColumnUtils || (utils.DataViewMetadataColumnUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ConceptualSchema = (function () {\n            function ConceptualSchema() {\n            }\n            ConceptualSchema.prototype.findProperty = function (entityName, propertyName) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                return entity.properties.withName(propertyName);\n            };\n            ConceptualSchema.prototype.findHierarchy = function (entityName, name) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.hierarchies))\n                    return;\n                return entity.hierarchies.withName(name);\n            };\n            ConceptualSchema.prototype.findHierarchyByVariation = function (variationEntityName, variationColumnName, variationName, hierarchyName) {\n                var variationEntity = this.entities.withName(variationEntityName);\n                if (!variationEntity || _.isEmpty(variationEntity.properties))\n                    return;\n                var variationProperty = variationEntity.properties.withName(variationColumnName);\n                if (!variationProperty)\n                    return;\n                var variationColumn = variationProperty.column;\n                if (!variationColumn || _.isEmpty(variationColumn.variations))\n                    return;\n                var variation = variationColumn.variations.withName(variationName);\n                if (variation) {\n                    var targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\n                    if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\n                        return;\n                    return targetEntity.hierarchies.withName(hierarchyName);\n                }\n            };\n            /**\n            * Returns the first property of the entity whose kpi is tied to kpiProperty\n            */\n            ConceptualSchema.prototype.findPropertyWithKpi = function (entityName, kpiProperty) {\n                debug.assertValue(kpiProperty, 'kpiProperty');\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                for (var _i = 0, _a = entity.properties; _i < _a.length; _i++) {\n                    var prop = _a[_i];\n                    if (prop &&\n                        prop.measure &&\n                        prop.measure.kpi &&\n                        (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\n                        return prop;\n                }\n                return;\n            };\n            return ConceptualSchema;\n        }());\n        data.ConceptualSchema = ConceptualSchema;\n        // TODO: Remove this (replaced by ValueType)\n        (function (ConceptualDataCategory) {\n            ConceptualDataCategory[ConceptualDataCategory[\"None\"] = 0] = \"None\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Address\"] = 1] = \"Address\";\n            ConceptualDataCategory[ConceptualDataCategory[\"City\"] = 2] = \"City\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Company\"] = 3] = \"Company\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Continent\"] = 4] = \"Continent\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Country\"] = 5] = \"Country\";\n            ConceptualDataCategory[ConceptualDataCategory[\"County\"] = 6] = \"County\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Date\"] = 7] = \"Date\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Image\"] = 8] = \"Image\";\n            ConceptualDataCategory[ConceptualDataCategory[\"ImageUrl\"] = 9] = \"ImageUrl\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Latitude\"] = 10] = \"Latitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Longitude\"] = 11] = \"Longitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Organization\"] = 12] = \"Organization\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Place\"] = 13] = \"Place\";\n            ConceptualDataCategory[ConceptualDataCategory[\"PostalCode\"] = 14] = \"PostalCode\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Product\"] = 15] = \"Product\";\n            ConceptualDataCategory[ConceptualDataCategory[\"StateOrProvince\"] = 16] = \"StateOrProvince\";\n            ConceptualDataCategory[ConceptualDataCategory[\"WebUrl\"] = 17] = \"WebUrl\";\n        })(data.ConceptualDataCategory || (data.ConceptualDataCategory = {}));\n        var ConceptualDataCategory = data.ConceptualDataCategory;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var FieldExprPattern = powerbi.data.FieldExprPattern;\n    var ScriptResultUtil;\n    (function (ScriptResultUtil) {\n        function findScriptResult(dataViewMappings) {\n            if (dataViewMappings && dataViewMappings.length === 1) {\n                return dataViewMappings[0].scriptResult;\n            }\n            return undefined;\n        }\n        ScriptResultUtil.findScriptResult = findScriptResult;\n        function extractScriptResult(dataViewMappings) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult) {\n                var objects = dataViewMappings[0].metadata.objects;\n                var source = powerbi.DataViewObjects.getValue(objects, scriptResult.script.source);\n                var provider = powerbi.DataViewObjects.getValue(objects, scriptResult.script.provider);\n                return {\n                    source: source,\n                    provider: provider\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResult = extractScriptResult;\n        function extractScriptResultFromVisualConfig(dataViewMappings, objects) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult && objects) {\n                var scriptSource = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\n                var provider = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\n                return {\n                    source: scriptSource ? scriptSource.value : null,\n                    provider: provider ? provider.value : null\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResultFromVisualConfig = extractScriptResultFromVisualConfig;\n        function getScriptInput(projections, selects, schema) {\n            var scriptInput = {\n                VariableName: \"dataset\",\n                Columns: []\n            };\n            // Go over all the projections, and create an input column according to the order\n            // of the projections (including duplicate expressions)\n            if (projections && selects && !_.isEmpty(selects)) {\n                var scriptInputColumnNames = [];\n                var scriptInputColumns = [];\n                for (var role in projections) {\n                    for (var _i = 0, _a = projections[role].all(); _i < _a.length; _i++) {\n                        var projection = _a[_i];\n                        var select = selects.withName(projection.queryRef);\n                        if (select) {\n                            var scriptInputColumn = {\n                                QueryName: select.name,\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\n                            };\n                            scriptInputColumns.push(scriptInputColumn);\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\n                        }\n                    }\n                }\n                // Make sure the names of the columns are unique\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\n                // Update the names of the columns\n                for (var i = 0; i < scriptInputColumnNames.length; i++) {\n                    var scriptInputColumn = scriptInputColumns[i];\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\n                }\n                scriptInput.Columns = scriptInputColumns;\n            }\n            return scriptInput;\n        }\n        ScriptResultUtil.getScriptInput = getScriptInput;\n        var ScriptInputColumnNameVisitor = (function () {\n            function ScriptInputColumnNameVisitor(federatedSchema) {\n                this.federatedSchema = federatedSchema;\n            }\n            ScriptInputColumnNameVisitor.prototype.visitColumn = function (column) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntity = function (entity) {\n                return entity.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                return entityAggr.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchy = function (hierarchy) {\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                /*Hierarchy levels are not supported yet*/\n                return;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitMeasure = function (measure) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitSelectRef = function (selectRef) {\n                return FieldExprPattern.visit(selectRef, this);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitPercentile = function (percentile) {\n                return FieldExprPattern.visit(percentile.arg, this);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n            };\n            ScriptInputColumnNameVisitor.getNameForHierarchy = function (pattern, federatedScheam) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedScheam.schema(pattern.schema), hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\n                if (hierarchy)\n                    return hierarchy.name;\n            };\n            ScriptInputColumnNameVisitor.getNameForProperty = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedSchema.schema(pattern.schema), property = schema.findProperty(pattern.entity, pattern.name);\n                if (property)\n                    return property.name;\n            };\n            ScriptInputColumnNameVisitor.getVariationLevelName = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var source = pattern.source;\n                var prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\n                if (!prop)\n                    return;\n                var variations = prop.column.variations;\n                for (var _i = 0, variations_1 = variations; _i < variations_1.length; _i++) {\n                    var variation = variations_1[_i];\n                    if (variation.name === pattern.variationName)\n                        for (var _a = 0, _b = variation.defaultHierarchy.levels; _a < _b.length; _a++) {\n                            var level = _b[_a];\n                            if (level.name === pattern.level.level)\n                                return level.column.name;\n                        }\n                }\n            };\n            return ScriptInputColumnNameVisitor;\n        }());\n    })(ScriptResultUtil = powerbi.ScriptResultUtil || (powerbi.ScriptResultUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var segmentation;\n        (function (segmentation) {\n            var DataViewMerger;\n            (function (DataViewMerger) {\n                function mergeDataViews(source, segment) {\n                    if (!powerbi.DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\n                        debug.assertFail(\"Cannot merge data views with different metadata columns\");\n                    }\n                    // The last segment is complete. We mark the source as complete.\n                    if (!segment.metadata.segment)\n                        delete source.metadata.segment;\n                    if (source.table && segment.table)\n                        mergeTables(source.table, segment.table);\n                    if (source.categorical && segment.categorical)\n                        mergeCategorical(source.categorical, segment.categorical);\n                    // Tree cannot support subtotals hence we can get into situations\n                    // where a node has no children in one segment and more than 1 child\n                    // in another segment.\n                    if (source.tree && segment.tree)\n                        mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\n                    if (source.matrix && segment.matrix)\n                        mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\n                }\n                DataViewMerger.mergeDataViews = mergeDataViews;\n                /** Note: Public for testability */\n                function mergeTables(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    if (_.isEmpty(segment.rows))\n                        return;\n                    var mergeIndex = segment.lastMergeIndex + 1;\n                    merge(source.rows, segment.rows, mergeIndex);\n                    debug.assert(!source.identity === !segment.identity, 'The existence of identity in the new segment is different than the source');\n                    if (segment.identity)\n                        merge(source.identity, segment.identity, mergeIndex);\n                }\n                DataViewMerger.mergeTables = mergeTables;\n                /**\n                 * Merge categories values and identities\n                 *\n                 * Note: Public for testability\n                 */\n                function mergeCategorical(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    // Merge categories values and identities\n                    if (source.categories && segment.categories) {\n                        var segmentCategoriesLength = segment.categories.length;\n                        debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\n                        for (var categoryIndex = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\n                            var segmentCategory = segment.categories[categoryIndex];\n                            var sourceCategory = source.categories[categoryIndex];\n                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\n                            debug.assert(_.isUndefined(sourceCategory.values) ? _.isUndefined(sourceCategory.identity) : true, 'Source category is missing values but has identities.');\n                            var mergeIndex = segment.lastMergeIndex + 1;\n                            if (segmentCategory.values) {\n                                merge(sourceCategory.values, segmentCategory.values, mergeIndex);\n                            }\n                            if (segmentCategory.identity) {\n                                merge(sourceCategory.identity, segmentCategory.identity, mergeIndex);\n                            }\n                        }\n                    }\n                    // Merge values for each value column\n                    if (source.values && segment.values) {\n                        var segmentValuesLength = segment.values.length;\n                        debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\n                        for (var valueIndex = 0; valueIndex < segmentValuesLength; valueIndex++) {\n                            var segmentValue = segment.values[valueIndex];\n                            var sourceValue = source.values[valueIndex];\n                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\n                            if (!sourceValue.values && segmentValue.values) {\n                                sourceValue.values = [];\n                            }\n                            var mergeIndex = segment.lastMergeIndex + 1;\n                            if (segmentValue.values) {\n                                merge(sourceValue.values, segmentValue.values, mergeIndex);\n                            }\n                            if (segmentValue.highlights) {\n                                merge(sourceValue.highlights, segmentValue.highlights, mergeIndex);\n                            }\n                        }\n                    }\n                }\n                DataViewMerger.mergeCategorical = mergeCategorical;\n                /**\n                 * Merges the segment array starting at the specified index into the source array\n                 * and returns the segment slice that wasn't merged.\n                 * The segment array is spliced up to specified index in the process.\n                 */\n                function merge(source, segment, index) {\n                    if (index >= segment.length)\n                        return segment;\n                    var result = [];\n                    if (index !== undefined)\n                        result = segment.splice(0, index);\n                    Array.prototype.push.apply(source, segment);\n                    return result;\n                }\n                /** Note: Public for testability */\n                function mergeTreeNodes(sourceRoot, segmentRoot, allowDifferentStructure) {\n                    debug.assertValue(sourceRoot, 'sourceRoot');\n                    debug.assertValue(segmentRoot, 'segmentRoot');\n                    if (!segmentRoot.children || segmentRoot.children.length === 0)\n                        return;\n                    if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\n                        sourceRoot.children = segmentRoot.children;\n                        return;\n                    }\n                    debug.assert(sourceRoot.children && sourceRoot.children.length >= 0, \"Source tree has different structure than segment.\");\n                    var firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\n                    var lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\n                    var mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\n                    if (mergedChildren.length > 0)\n                        mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\n                }\n                DataViewMerger.mergeTreeNodes = mergeTreeNodes;\n                function findFirstAppendIndex(children) {\n                    if (children.length === 0)\n                        return 0;\n                    var i = 0;\n                    for (; i < children.length; i++) {\n                        var childSegment = children[i];\n                        if (!childSegment.isMerge)\n                            break;\n                    }\n                    return i;\n                }\n            })(DataViewMerger = segmentation.DataViewMerger || (segmentation.DataViewMerger = {}));\n        })(segmentation = data.segmentation || (data.segmentation = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Rewrites an expression tree, including all descendant nodes. */\n        var SQExprRewriter = (function () {\n            function SQExprRewriter() {\n            }\n            SQExprRewriter.prototype.visitColumnRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQColumnRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitMeasureRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQMeasureRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitAggr = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQAggregationExpr(rewrittenArg, expr.func);\n            };\n            SQExprRewriter.prototype.visitSelectRef = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitPercentile = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPercentileExpr(rewrittenArg, expr.k, expr.exclusive);\n            };\n            SQExprRewriter.prototype.visitHierarchy = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyExpr(rewrittenArg, expr.hierarchy);\n            };\n            SQExprRewriter.prototype.visitHierarchyLevel = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyLevelExpr(rewrittenArg, expr.level);\n            };\n            SQExprRewriter.prototype.visitPropertyVariationSource = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\n            };\n            SQExprRewriter.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitAnd = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQAndExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitBetween = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this), origLower = orig.lower, rewrittenLower = origLower.accept(this), origUpper = orig.upper, rewrittenUpper = origUpper.accept(this);\n                if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\n                    return orig;\n                return new data.SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\n            };\n            SQExprRewriter.prototype.visitIn = function (orig) {\n                var origArgs = orig.args, rewrittenArgs = this.rewriteAll(origArgs), origValues = orig.values, rewrittenValues;\n                for (var i = 0, len = origValues.length; i < len; i++) {\n                    var origValueTuple = origValues[i], rewrittenValueTuple = this.rewriteAll(origValueTuple);\n                    if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\n                        rewrittenValues = ArrayExtensions.take(origValues, i);\n                    if (rewrittenValues)\n                        rewrittenValues.push(rewrittenValueTuple);\n                }\n                if (origArgs === rewrittenArgs && !rewrittenValues)\n                    return orig;\n                return new data.SQInExpr(rewrittenArgs, rewrittenValues || origValues);\n            };\n            SQExprRewriter.prototype.rewriteAll = function (origExprs) {\n                debug.assertValue(origExprs, 'origExprs');\n                var rewrittenResult;\n                for (var i = 0, len = origExprs.length; i < len; i++) {\n                    var origExpr = origExprs[i], rewrittenExpr = origExpr.accept(this);\n                    if (origExpr !== rewrittenExpr && !rewrittenResult)\n                        rewrittenResult = ArrayExtensions.take(origExprs, i);\n                    if (rewrittenResult)\n                        rewrittenResult.push(rewrittenExpr);\n                }\n                return rewrittenResult || origExprs;\n            };\n            SQExprRewriter.prototype.visitOr = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQOrExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitCompare = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitContains = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQContainsExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitExists = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQExistsExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNot = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQNotExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitStartsWith = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQStartsWithExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitConstant = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitDateSpan = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateSpanExpr(orig.unit, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitDateAdd = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNow = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitDefaultValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitAnyValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitArithmetic = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\n            };\n            SQExprRewriter.prototype.visitScopedEval = function (orig) {\n                var origExpression = orig.expression, rewrittenExpression = origExpression.accept(this), origScope = orig.scope, rewrittenScope = this.rewriteAll(origScope);\n                if (origExpression === rewrittenExpression && origScope === rewrittenScope)\n                    return orig;\n                return new data.SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\n            };\n            SQExprRewriter.prototype.visitFillRule = function (orig) {\n                var origInput = orig.input, rewrittenInput = origInput.accept(this);\n                var origRule = orig.rule;\n                var origGradient2 = origRule.linearGradient2, rewrittenGradient2 = origGradient2;\n                if (origGradient2) {\n                    rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\n                }\n                var origGradient3 = origRule.linearGradient3, rewrittenGradient3 = origGradient3;\n                if (origGradient3) {\n                    rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\n                }\n                if (origInput !== rewrittenInput ||\n                    origGradient2 !== rewrittenGradient2 ||\n                    origGradient3 !== rewrittenGradient3) {\n                    var rewrittenRule = {};\n                    if (rewrittenGradient2)\n                        rewrittenRule.linearGradient2 = rewrittenGradient2;\n                    if (rewrittenGradient3)\n                        rewrittenRule.linearGradient3 = rewrittenGradient3;\n                    return new data.SQFillRuleExpr(rewrittenInput, rewrittenRule);\n                }\n                return orig;\n            };\n            SQExprRewriter.prototype.visitLinearGradient2 = function (origGradient2) {\n                debug.assertValue(origGradient2, 'origGradient2');\n                var origMin = origGradient2.min, rewrittenMin = this.visitFillRuleStop(origMin), origMax = origGradient2.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient2;\n            };\n            SQExprRewriter.prototype.visitLinearGradient3 = function (origGradient3) {\n                debug.assertValue(origGradient3, 'origGradient3');\n                var origMin = origGradient3.min, rewrittenMin = this.visitFillRuleStop(origMin), origMid = origGradient3.mid, rewrittenMid = this.visitFillRuleStop(origMid), origMax = origGradient3.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        mid: rewrittenMid,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient3;\n            };\n            SQExprRewriter.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                var origColor = stop.color, rewrittenColor = stop.color.accept(this);\n                var origValue = stop.value, rewrittenValue = origValue;\n                if (origValue)\n                    rewrittenValue = origValue.accept(this);\n                if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\n                    var rewrittenStop = {\n                        color: rewrittenColor\n                    };\n                    if (rewrittenValue)\n                        rewrittenStop.value = rewrittenValue;\n                    return rewrittenStop;\n                }\n                return stop;\n            };\n            SQExprRewriter.prototype.visitResourcePackageItem = function (orig) {\n                return orig;\n            };\n            return SQExprRewriter;\n        }());\n        data.SQExprRewriter = SQExprRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for writing equality comparisons against a field to an SQInExpr. */\n        var EqualsToInRewriter;\n        (function (EqualsToInRewriter) {\n            function run(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(new Rewriter());\n            }\n            EqualsToInRewriter.run = run;\n            var Rewriter = (function (_super) {\n                __extends(Rewriter, _super);\n                function Rewriter() {\n                    _super.call(this);\n                }\n                Rewriter.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return this.visitUnsupported(expr);\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var leftIsComparand = this.isComparand(expr.left);\n                    var rightIsComparand = this.isComparand(expr.right);\n                    if (leftIsComparand === rightIsComparand)\n                        return this.visitUnsupported(expr);\n                    var operand = leftIsComparand\n                        ? expr.left\n                        : expr.right;\n                    var value = leftIsComparand\n                        ? expr.right\n                        : expr.left;\n                    var current = this.current;\n                    if (!current) {\n                        return data.SQExprBuilder.inExpr([operand], [[value]]);\n                    }\n                    current.add(operand, value);\n                    return expr;\n                };\n                Rewriter.prototype.visitOr = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current;\n                    if (!this.current) {\n                        current = this.current = new InBuilder();\n                    }\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                    if (current) {\n                        this.current = null;\n                        return current.complete() || expr;\n                    }\n                    return expr;\n                };\n                Rewriter.prototype.visitAnd = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current = this.current;\n                    if (current) {\n                        // NOTE: Composite keys are not supported by this algorithm.\n                        current.cancel();\n                        return expr;\n                    }\n                    return _super.prototype.visitAnd.call(this, expr);\n                };\n                Rewriter.prototype.visitUnsupported = function (expr) {\n                    var current = this.current;\n                    if (current)\n                        current.cancel();\n                    return expr;\n                };\n                Rewriter.prototype.isSupported = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return expr instanceof data.SQCompareExpr\n                        || expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQConstantExpr\n                        || expr instanceof data.SQHierarchyLevelExpr\n                        || expr instanceof data.SQOrExpr\n                        || expr instanceof data.SQAndExpr;\n                };\n                Rewriter.prototype.isComparand = function (expr) {\n                    return expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQHierarchyLevelExpr;\n                };\n                return Rewriter;\n            }(data.SQExprRewriter));\n            var InBuilder = (function () {\n                function InBuilder() {\n                }\n                InBuilder.prototype.add = function (operand, value) {\n                    debug.assertValue(operand, 'operand');\n                    debug.assertValue(value, 'value');\n                    if (this.cancelled)\n                        return;\n                    if (this.operand && !data.SQExpr.equals(operand, this.operand)) {\n                        this.cancel();\n                        return;\n                    }\n                    this.operand = operand;\n                    var values = this.values;\n                    if (!values)\n                        values = this.values = [];\n                    values.push(value);\n                };\n                InBuilder.prototype.cancel = function () {\n                    this.cancelled = true;\n                };\n                InBuilder.prototype.complete = function () {\n                    if (this.cancelled || !this.operand)\n                        return;\n                    return data.SQExprBuilder.inExpr([this.operand], _.map(this.values, function (v) { return [v]; }));\n                };\n                return InBuilder;\n            }());\n        })(EqualsToInRewriter = data.EqualsToInRewriter || (data.EqualsToInRewriter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asScopeIdsContainer(filter, fieldSQExprs) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\n                var filterItems = filter.conditions();\n                debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\n                var filterItem = filterItems[0];\n                if (filterItem) {\n                    var visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\n                    if (filterItem.accept(visitor))\n                        return visitor.getResult();\n                }\n            }\n            SQExprConverter.asScopeIdsContainer = asScopeIdsContainer;\n            /** Gets a comparand value from the given DataViewScopeIdentity. */\n            function getFirstComparandValue(identity) {\n                debug.assertValue(identity, 'identity');\n                var comparandExpr = identity.expr.accept(new FindComparandVisitor());\n                if (comparandExpr)\n                    return comparandExpr.value;\n            }\n            SQExprConverter.getFirstComparandValue = getFirstComparandValue;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\n        var FilterScopeIdsCollectorVisitor = (function (_super) {\n            __extends(FilterScopeIdsCollectorVisitor, _super);\n            function FilterScopeIdsCollectorVisitor(fieldSQExprs) {\n                _super.call(this);\n                this.isRoot = true;\n                this.isNot = false;\n                this.keyExprsCount = null;\n                this.valueExprs = [];\n                // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\n                // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\n                // need to drop it in order to use JsonComparer.\n                this.fieldExprs = [];\n                for (var _i = 0, fieldSQExprs_1 = fieldSQExprs; _i < fieldSQExprs_1.length; _i++) {\n                    var field = fieldSQExprs_1[_i];\n                    this.fieldExprs.push(data.SQExprBuilder.removeEntityVariables(field));\n                }\n            }\n            FilterScopeIdsCollectorVisitor.prototype.getResult = function () {\n                debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');\n                var valueExprs = this.valueExprs, scopeIds = [];\n                var valueCount = this.keyExprsCount || 1;\n                for (var startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\n                    var values = valueExprs.slice(startIndex, endIndex);\n                    var scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\n                    if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, powerbi.DataViewScopeIdentity.equals))\n                        scopeIds.push(scopeId);\n                    startIndex += valueCount;\n                    endIndex += valueCount;\n                }\n                return {\n                    isNot: this.isNot,\n                    scopeIds: scopeIds,\n                };\n            };\n            FilterScopeIdsCollectorVisitor.getScopeIdentity = function (fieldExprs, valueExprs) {\n                debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\n                debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\n                var compoundSQExpr;\n                for (var i = 0, len = fieldExprs.length; i < len; i++) {\n                    var equalsExpr = data.SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\n                    if (!compoundSQExpr)\n                        compoundSQExpr = equalsExpr;\n                    else\n                        compoundSQExpr = data.SQExprBuilder.and(compoundSQExpr, equalsExpr);\n                }\n                return data.createDataViewScopeIdentity(compoundSQExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitOr = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitNot = function (expr) {\n                if (!this.isRoot)\n                    return this.unsupportedSQExpr();\n                this.isNot = true;\n                return expr.arg.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitConstant = function (expr) {\n                if (this.isRoot && expr.type.primitiveType === powerbi.PrimitiveType.Null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitCompare = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                if (expr.comparison !== data.QueryComparisonKind.Equal)\n                    return this.unsupportedSQExpr();\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitIn = function (expr) {\n                this.keyExprsCount = 0;\n                var result;\n                this.isRoot = false;\n                for (var _i = 0, _a = expr.args; _i < _a.length; _i++) {\n                    var arg = _a[_i];\n                    result = arg.accept(this);\n                    if (!result)\n                        return this.unsupportedSQExpr();\n                    this.keyExprsCount++;\n                }\n                if (this.keyExprsCount !== this.fieldExprs.length)\n                    return this.unsupportedSQExpr();\n                var values = expr.values;\n                for (var _b = 0, values_1 = values; _b < values_1.length; _b++) {\n                    var valueTuple = values_1[_b];\n                    var jlen = valueTuple.length;\n                    debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\n                    for (var _c = 0, valueTuple_1 = valueTuple; _c < valueTuple_1.length; _c++) {\n                        var value = valueTuple_1[_c];\n                        result = value.accept(this);\n                        if (!result)\n                            return this.unsupportedSQExpr();\n                    }\n                }\n                return result;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitColumnRef = function (expr) {\n                if (this.isRoot)\n                    return this.unsupportedSQExpr();\n                var fixedExpr = data.SQExprBuilder.removeEntityVariables(expr);\n                if (this.keyExprsCount !== null)\n                    return data.SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\n                return data.SQExpr.equals(this.fieldExprs[0], fixedExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefaultValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitAnyValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefault = function (expr) {\n                return this.unsupportedSQExpr();\n            };\n            FilterScopeIdsCollectorVisitor.prototype.unsupportedSQExpr = function () {\n                return false;\n            };\n            return FilterScopeIdsCollectorVisitor;\n        }(data.DefaultSQExprVisitor));\n        var FindComparandVisitor = (function (_super) {\n            __extends(FindComparandVisitor, _super);\n            function FindComparandVisitor() {\n                _super.apply(this, arguments);\n            }\n            FindComparandVisitor.prototype.visitAnd = function (expr) {\n                return expr.left.accept(this) || expr.right.accept(this);\n            };\n            FindComparandVisitor.prototype.visitCompare = function (expr) {\n                if (expr.comparison === data.QueryComparisonKind.Equal) {\n                    if (expr.right instanceof data.SQConstantExpr)\n                        return expr.right;\n                    if (expr.left instanceof data.SQConstantExpr)\n                        return expr.left;\n                }\n            };\n            return FindComparandVisitor;\n        }(data.DefaultSQExprVisitor));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\n        var ScopeIdentityExtractor;\n        (function (ScopeIdentityExtractor) {\n            function getKeys(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return null;\n                return ArrayExtensions.emptyToNull(extractor.keys);\n            }\n            ScopeIdentityExtractor.getKeys = getKeys;\n            function getInExpr(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return;\n                var keys = ArrayExtensions.emptyToNull(extractor.keys);\n                var keyValues = ArrayExtensions.emptyToNull(extractor.values);\n                if (keys && keyValues)\n                    return data.SQExprBuilder.inExpr(keys, [keyValues]);\n            }\n            ScopeIdentityExtractor.getInExpr = getInExpr;\n            /**\n             * Recognizes expressions of the form:\n             * 1) Equals(ColRef, Constant)\n             * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\n             * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\n             */\n            var ScopeIdExtractorImpl = (function (_super) {\n                __extends(ScopeIdExtractorImpl, _super);\n                function ScopeIdExtractorImpl() {\n                    _super.apply(this, arguments);\n                    this.keys = [];\n                    this.values = [];\n                }\n                ScopeIdExtractorImpl.prototype.visitAnd = function (expr) {\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal) {\n                        this.visitDefault(expr);\n                        return;\n                    }\n                    debug.assert(expr.left instanceof data.SQExpr && expr.right instanceof data.SQConstantExpr, 'invalid compare expr operands');\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitColumnRef = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitHierarchyLevel = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitConstant = function (expr) {\n                    this.values.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitArithmetic = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitDefault = function (expr) {\n                    this.malformed = true;\n                };\n                return ScopeIdExtractorImpl;\n            }(data.DefaultSQExprVisitor));\n        })(ScopeIdentityExtractor = data.ScopeIdentityExtractor || (data.ScopeIdentityExtractor = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var PrimitiveValueEncoding;\n        (function (PrimitiveValueEncoding) {\n            var SingleQuoteRegex = /'/g;\n            function decimal(value) {\n                debug.assertValue(value, 'value');\n                return value + 'M';\n            }\n            PrimitiveValueEncoding.decimal = decimal;\n            function double(value) {\n                debug.assertValue(value, 'value');\n                return value + 'D';\n            }\n            PrimitiveValueEncoding.double = double;\n            function integer(value) {\n                debug.assertValue(value, 'value');\n                return value + 'L';\n            }\n            PrimitiveValueEncoding.integer = integer;\n            function dateTime(value) {\n                debug.assertValue(value, 'value');\n                // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\n                // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\n                // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\n                var date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\n                var dateTimeString = date.toISOString();\n                // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\n                // we will drop it.\n                // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\n                if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\n                    dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\n                return \"datetime'\" + dateTimeString + \"'\";\n            }\n            PrimitiveValueEncoding.dateTime = dateTime;\n            function text(value) {\n                debug.assertValue(value, 'value');\n                return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\n            }\n            PrimitiveValueEncoding.text = text;\n            function nullEncoding() {\n                return 'null';\n            }\n            PrimitiveValueEncoding.nullEncoding = nullEncoding;\n            function boolean(value) {\n                return value ? 'true' : 'false';\n            }\n            PrimitiveValueEncoding.boolean = boolean;\n        })(PrimitiveValueEncoding = data.PrimitiveValueEncoding || (data.PrimitiveValueEncoding = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Agg = powerbi.data.QueryAggregateFunction;\n        function createSQAggregationOperations(datetimeMinMaxSupported) {\n            return new SQAggregationOperations(datetimeMinMaxSupported);\n        }\n        data.createSQAggregationOperations = createSQAggregationOperations;\n        var SQAggregationOperations = (function () {\n            function SQAggregationOperations(datetimeMinMaxSupported) {\n                this.datetimeMinMaxSupported = datetimeMinMaxSupported;\n            }\n            SQAggregationOperations.prototype.getSupportedAggregates = function (expr, schema, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                debug.assertAnyValue(targetTypes, 'targetTypes');\n                var metadata = getMetadataForUnderlyingType(expr, schema);\n                // don't use expr.validate as validate will be using this function and we end up in a recursive loop\n                if (!metadata)\n                    return [];\n                var valueType = metadata.type, fieldKind = metadata.kind, isPropertyIdentity = metadata.idOnEntityKey;\n                if (!valueType)\n                    return [];\n                // Cannot aggregate on model measures\n                if (fieldKind === 1 /* Measure */)\n                    return [];\n                if (valueType.numeric || valueType.integer) {\n                    var aggregates_1 = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var currentSchema = schema.schema(fieldExprItem.schema);\n                    if (currentSchema.capabilities.supportsMedian)\n                        aggregates_1.push(Agg.Median);\n                    return aggregates_1;\n                }\n                var aggregates = [];\n                // Min/Max of DateTime\n                if (this.datetimeMinMaxSupported &&\n                    valueType.dateTime &&\n                    (_.isEmpty(targetTypes) || powerbi.ValueType.isCompatibleTo(valueType, targetTypes))) {\n                    aggregates.push(Agg.Min);\n                    aggregates.push(Agg.Max);\n                }\n                // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\n                // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\n                var distinctCountAggExists = data.SQExprInfo.getAggregate(expr) === Agg.Count;\n                if (!(isPropertyIdentity && !distinctCountAggExists))\n                    aggregates.push(Agg.Count);\n                aggregates.push(Agg.CountNonNull);\n                return aggregates;\n            };\n            SQAggregationOperations.prototype.isSupportedAggregate = function (expr, schema, aggregate, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\n                return _.contains(supportedAggregates, aggregate);\n            };\n            SQAggregationOperations.prototype.createExprWithAggregate = function (expr, schema, aggregateNonNumericFields, targetTypes, preferredAggregate) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var aggregate;\n                if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\n                    aggregate = preferredAggregate;\n                }\n                else {\n                    aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\n                }\n                if (aggregate !== undefined)\n                    expr = data.SQExprBuilder.aggregate(expr, aggregate);\n                return expr;\n            };\n            return SQAggregationOperations;\n        }());\n        function getMetadataForUnderlyingType(expr, schema) {\n            // Unwrap the aggregate (if the expr has one), and look at the underlying type.\n            var metadata = data.SQExprBuilder.removeAggregate(expr).getMetadata(schema);\n            if (!metadata)\n                metadata = expr.getMetadata(schema);\n            return metadata;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQHierarchyExprUtils;\n        (function (SQHierarchyExprUtils) {\n            function getConceptualHierarchyLevelFromExpr(conceptualSchema, fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                var hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\n                if (hierarchyLevel)\n                    return SQHierarchyExprUtils.getConceptualHierarchyLevel(conceptualSchema, fieldExprItem.schema, fieldExprItem.entity, hierarchyLevel.name, hierarchyLevel.level);\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr = getConceptualHierarchyLevelFromExpr;\n            function getConceptualHierarchyLevel(conceptualSchema, schemaName, entity, hierarchy, hierarchyLevel) {\n                var schema = conceptualSchema.schema(schemaName);\n                var conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\n                if (conceptualHierarchy) {\n                    return conceptualHierarchy.levels.withName(hierarchyLevel);\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevel = getConceptualHierarchyLevel;\n            function getConceptualHierarchy(sqExpr, federatedSchema) {\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchy = sqExpr;\n                    if (sqExpr.arg instanceof data.SQEntityExpr) {\n                        var entityExpr = sqExpr.arg;\n                        return federatedSchema\n                            .schema(entityExpr.schema)\n                            .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\n                    }\n                    else if (sqExpr.arg instanceof data.SQPropertyVariationSourceExpr) {\n                        var variationExpr = sqExpr.arg;\n                        var sourceEntityExpr = variationExpr.arg;\n                        return federatedSchema\n                            .schema(sourceEntityExpr.schema)\n                            .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\n                    }\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchy = getConceptualHierarchy;\n            function expandExpr(schema, expr, suppressHierarchyLevelExpansion) {\n                return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\n                    SQExprVariationConverter.expand(expr, schema) ||\n                    // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\n                    (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\n                    expr;\n            }\n            SQHierarchyExprUtils.expandExpr = expandExpr;\n            function isHierarchyOrVariation(schema, expr) {\n                if (expr instanceof data.SQHierarchyExpr || expr instanceof data.SQHierarchyLevelExpr)\n                    return true;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0)\n                        return true;\n                }\n                return false;\n            }\n            SQHierarchyExprUtils.isHierarchyOrVariation = isHierarchyOrVariation;\n            // Return column reference expression for hierarchy level expression.\n            function getSourceVariationExpr(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                if (fieldExprPattern.columnHierarchyLevelVariation) {\n                    var entity = data.SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\n                    return data.SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceVariationExpr = getSourceVariationExpr;\n            // Return hierarchy expression for hierarchy level expression.\n            function getSourceHierarchy(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                var hierarchyLevel = fieldExprPattern.hierarchyLevel;\n                if (hierarchyLevel) {\n                    var entity = data.SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\n                    return data.SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceHierarchy = getSourceHierarchy;\n            function getHierarchySourceAsVariationSource(hierarchyLevelExpr) {\n                // Make sure the hierarchy level source is a hierarchy\n                if (!(hierarchyLevelExpr.arg instanceof data.SQHierarchyExpr))\n                    return;\n                // Check if the hierarchy source if a variation\n                var hierarchyRef = hierarchyLevelExpr.arg;\n                if (hierarchyRef.arg instanceof data.SQPropertyVariationSourceExpr)\n                    return hierarchyRef.arg;\n            }\n            SQHierarchyExprUtils.getHierarchySourceAsVariationSource = getHierarchySourceAsVariationSource;\n            /**\n            * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\n            */\n            function areHierarchyLevelsOrdered(allLevels, firstExpr, secondExpr) {\n                // Validate that both items hierarchy levels\n                if (!(firstExpr instanceof data.SQHierarchyLevelExpr) || !(secondExpr instanceof data.SQHierarchyLevelExpr))\n                    return false;\n                var firstLevel = firstExpr;\n                var secondLevel = secondExpr;\n                // Validate that both items belong to the same hierarchy\n                if (!data.SQExpr.equals(firstLevel.arg, secondLevel.arg))\n                    return false;\n                // Determine the order\n                var firstIndex = data.SQExprUtils.indexOfExpr(allLevels, firstLevel);\n                var secondIndex = data.SQExprUtils.indexOfExpr(allLevels, secondLevel);\n                return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\n            }\n            SQHierarchyExprUtils.areHierarchyLevelsOrdered = areHierarchyLevelsOrdered;\n            /**\n             * Given an ordered set of levels and an ordered subset of those levels, returns the index where\n             * expr should be inserted into the subset to maintain the correct order.\n             */\n            function getInsertionIndex(allLevels, orderedSubsetOfLevels, expr) {\n                var insertIndex = 0;\n                // Loop through the supplied levels until the insertion would no longer be in the correct order\n                while (insertIndex < orderedSubsetOfLevels.length &&\n                    areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\n                    insertIndex++;\n                }\n                return insertIndex;\n            }\n            SQHierarchyExprUtils.getInsertionIndex = getInsertionIndex;\n        })(SQHierarchyExprUtils = data.SQHierarchyExprUtils || (data.SQHierarchyExprUtils = {}));\n        var SQExprHierarchyToHierarchyLevelConverter;\n        (function (SQExprHierarchyToHierarchyLevelConverter) {\n            function convert(sqExpr, federatedSchema) {\n                debug.assertValue(sqExpr, 'sqExpr');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchyExpr = sqExpr;\n                    var conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\n                    if (conceptualHierarchy)\n                        return _.map(conceptualHierarchy.levels, function (hierarchyLevel) { return data.SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name); });\n                }\n            }\n            SQExprHierarchyToHierarchyLevelConverter.convert = convert;\n        })(SQExprHierarchyToHierarchyLevelConverter = data.SQExprHierarchyToHierarchyLevelConverter || (data.SQExprHierarchyToHierarchyLevelConverter = {}));\n        var SQExprHierarchyLevelConverter;\n        (function (SQExprHierarchyLevelConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs = [];\n                if (expr instanceof data.SQHierarchyLevelExpr) {\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    if (fieldExpr.hierarchyLevel) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        var hierarchy = schema\n                            .schema(fieldExprItem.schema)\n                            .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\n                        if (hierarchy) {\n                            var hierarchyLevels = hierarchy.levels;\n                            for (var _i = 0, hierarchyLevels_2 = hierarchyLevels; _i < hierarchyLevels_2.length; _i++) {\n                                var hierarchyLevel = hierarchyLevels_2[_i];\n                                if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\n                                    exprs.push(expr);\n                                    break;\n                                }\n                                else\n                                    exprs.push(data.SQExprBuilder.hierarchyLevel(data.SQExprBuilder.hierarchy(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), hierarchy.name), hierarchyLevel.name));\n                            }\n                        }\n                    }\n                }\n                if (!_.isEmpty(exprs))\n                    return exprs;\n            }\n            SQExprHierarchyLevelConverter.expand = expand;\n        })(SQExprHierarchyLevelConverter || (SQExprHierarchyLevelConverter = {}));\n        var SQExprVariationConverter;\n        (function (SQExprVariationConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0) {\n                        var variations = column.variations;\n                        // for SU11, we support only one variation\n                        debug.assert(variations.length === 1, \"variations.length\");\n                        var variation = variations[0];\n                        var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        exprs = [];\n                        if (variation.defaultHierarchy) {\n                            var hierarchyExpr = data.SQExprBuilder.hierarchy(data.SQExprBuilder.propertyVariationSource(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), variation.name, conceptualProperty.name), variation.defaultHierarchy.name);\n                            for (var _i = 0, _a = variation.defaultHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                exprs.push(data.SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\n                            }\n                        }\n                    }\n                }\n                return exprs;\n            }\n            SQExprVariationConverter.expand = expand;\n        })(SQExprVariationConverter || (SQExprVariationConverter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        ;\n        var SQExprGroupUtils;\n        (function (SQExprGroupUtils) {\n            /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\n            function groupExprs(schema, exprs) {\n                var groups = [];\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i];\n                    debug.assertValue(expr, \"Expression not found\");\n                    if (!(expr instanceof data.SQHierarchyLevelExpr)) {\n                        groups.push({ expr: expr, children: null, selectQueryIndex: i });\n                    }\n                    else {\n                        addChildToGroup(schema, groups, expr, i);\n                    }\n                }\n                return groups;\n            }\n            SQExprGroupUtils.groupExprs = groupExprs;\n            function addChildToGroup(schema, groups, expr, selectQueryIndex) {\n                // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \n                // a new Group or to the last Group\n                var shouldAddExpressionToNewGroup = true;\n                var exprSource = data.SQHierarchyExprUtils.getSourceVariationExpr(expr) || data.SQHierarchyExprUtils.getSourceHierarchy(expr);\n                var lastGroup = _.last(groups);\n                // The relevant group is always the last added. If it has the same source hierarchy,\n                // and is properly ordered within that hierarchy, we will need to add to this group.\n                if (lastGroup && lastGroup.children && data.SQExpr.equals(lastGroup.expr, exprSource)) {\n                    var expandedExpr = data.SQHierarchyExprUtils.expandExpr(schema, expr.arg);\n                    if (expandedExpr instanceof Array) {\n                        var allHierarchyLevels = expandedExpr;\n                        shouldAddExpressionToNewGroup = !data.SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\n                    }\n                }\n                if (shouldAddExpressionToNewGroup)\n                    // Use the Sourcevariation as the expression for the group.\n                    groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\n                else {\n                    debug.assertValue(lastGroup, 'There should be a group to add the variation to');\n                    debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\n                    lastGroup.children.push(expr);\n                }\n            }\n        })(SQExprGroupUtils = data.SQExprGroupUtils || (data.SQExprGroupUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var StringExtensions = jsCommon.StringExtensions;\n        /** Represents an immutable expression within a SemanticQuery. */\n        var SQExpr = (function () {\n            function SQExpr(kind) {\n                debug.assertValue(kind, 'kind');\n                this._kind = kind;\n            }\n            SQExpr.equals = function (x, y, ignoreCase) {\n                return SQExprEqualityVisitor.run(x, y, ignoreCase);\n            };\n            SQExpr.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.accept(validator);\n                return validator.errors;\n            };\n            SQExpr.prototype.accept = function (visitor, arg) {\n                debug.assertFail('abstract method');\n                return;\n            };\n            Object.defineProperty(SQExpr.prototype, \"kind\", {\n                get: function () {\n                    return this._kind;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            SQExpr.isColumn = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 1 /* ColumnRef */;\n            };\n            SQExpr.isConstant = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 16 /* Constant */;\n            };\n            SQExpr.isEntity = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 0 /* Entity */;\n            };\n            SQExpr.isHierarchy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 5 /* Hierarchy */;\n            };\n            SQExpr.isHierarchyLevel = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 6 /* HierarchyLevel */;\n            };\n            SQExpr.isAggregation = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 3 /* Aggregation */;\n            };\n            SQExpr.isMeasure = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 2 /* MeasureRef */;\n            };\n            SQExpr.isSelectRef = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 28 /* SelectRef */;\n            };\n            SQExpr.isResourcePackageItem = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 24 /* ResourcePackageItem */;\n            };\n            SQExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                if (field.column || field.columnAggr || field.measure)\n                    return this.getMetadataForProperty(field, federatedSchema);\n                if (field.hierarchyLevel || field.hierarchyLevelAggr)\n                    return this.getMetadataForHierarchyLevel(field, federatedSchema);\n                if (field.columnHierarchyLevelVariation)\n                    return this.getMetadataForVariation(field, federatedSchema);\n                if (field.percentOfGrandTotal)\n                    return this.getMetadataForPercentOfGrandTotal();\n                return SQExpr.getMetadataForEntity(field, federatedSchema);\n            };\n            SQExpr.prototype.getDefaultAggregate = function (federatedSchema, forceAggregation) {\n                if (forceAggregation === void 0) { forceAggregation = false; }\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                var aggregate;\n                if (property && property.kind === 0 /* Column */) {\n                    var propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\n                    if ((property.type.integer || property.type.numeric) &&\n                        propertyDefaultAggregate !== 1 /* None */) {\n                        aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\n                        if (aggregate === undefined)\n                            aggregate = defaultAggregateForDataType(property.type);\n                    }\n                    // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \n                    // aggregate on CountNonNull.\n                    if (aggregate === undefined && forceAggregation) {\n                        aggregate = data.QueryAggregateFunction.CountNonNull;\n                    }\n                }\n                return aggregate;\n            };\n            /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\n            SQExpr.prototype.getKeyColumns = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keySQExprs = [];\n                var keys = this.getPropertyKeys(schema);\n                if (keys && keys.length > 0) {\n                    for (var i = 0, len = keys.length; i < len; i++) {\n                        keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\n                    }\n                }\n                else\n                    keySQExprs.push(columnRefExpr);\n                return keySQExprs;\n            };\n            /** Returns a value indicating whether the expression would group on keys other than itself.*/\n            SQExpr.prototype.hasGroupOnKeys = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keys = this.getPropertyKeys(schema);\n                if (!keys || keys.length < 1)\n                    return false;\n                if (keys.length > 1)\n                    return true;\n                var keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\n                return !SQExpr.equals(keySqExpr, this);\n            };\n            SQExpr.prototype.getPropertyKeys = function (schema) {\n                var property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\n                if (!property)\n                    return;\n                return property.column ? property.column.keys : undefined;\n            };\n            SQExpr.prototype.getConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var propertyName = data.FieldExprPattern.getPropertyName(field);\n                if (propertyName)\n                    return federatedSchema\n                        .schema(fieldExprItem.schema)\n                        .findProperty(fieldExprItem.entity, propertyName);\n            };\n            SQExpr.prototype.getTargetEntityForVariation = function (federatedSchema, variationName) {\n                var property = this.getConceptualProperty(federatedSchema);\n                if (property && property.column && !_.isEmpty(property.column.variations)) {\n                    var variations = property.column.variations;\n                    for (var _i = 0, variations_2 = variations; _i < variations_2.length; _i++) {\n                        var variation = variations_2[_i];\n                        if (variation.name === variationName)\n                            return variation.navigationProperty.targetEntity.name;\n                    }\n                }\n            };\n            SQExpr.prototype.getTargetEntity = function (federatedSchema) {\n                return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\n            };\n            SQExpr.prototype.getHierarchyLevelConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\n                if (fieldExprHierachyLevel) {\n                    var fieldExprEntity = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                    var hierarchy = federatedSchema\n                        .schema(fieldExprEntity.schema)\n                        .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\n                    if (hierarchy) {\n                        var hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\n                        if (hierarchyLevel)\n                            return hierarchyLevel.column;\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForVariation = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var sourceProperty = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\n                if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\n                    for (var _i = 0, _a = sourceProperty.column.variations; _i < _a.length; _i++) {\n                        var variation = _a[_i];\n                        if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\n                            for (var _b = 0, _c = variation.defaultHierarchy.levels; _b < _c.length; _b++) {\n                                var level = _c[_b];\n                                if (level.name === columnHierarchyLevelVariation.level.level) {\n                                    var property = level.column;\n                                    return {\n                                        kind: (property.kind === 1 /* Measure */) ? 1 /* Measure */ : 0 /* Column */,\n                                        type: property.type,\n                                        format: property.format,\n                                        idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                                        defaultAggregate: property.column ? property.column.defaultAggregate : null\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForHierarchyLevel = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.prototype.getMetadataForPercentOfGrandTotal = function () {\n                return {\n                    kind: 1 /* Measure */,\n                    format: '#,##0.##%',\n                    type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double)\n                };\n            };\n            SQExpr.prototype.getPropertyMetadata = function (field, property) {\n                var format = property.format;\n                var type = property.type;\n                var columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\n                if (columnAggregate) {\n                    switch (columnAggregate.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer);\n                            format = undefined;\n                            break;\n                        case data.QueryAggregateFunction.Avg:\n                            if (type.integer)\n                                type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double);\n                            break;\n                    }\n                }\n                return {\n                    kind: (property.kind === 1 /* Measure */ || (columnAggregate && columnAggregate.aggregate !== undefined)) ? 1 /* Measure */ : 0 /* Column */,\n                    type: type,\n                    format: format,\n                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                    aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\n                    defaultAggregate: property.column ? property.column.defaultAggregate : null\n                };\n            };\n            SQExpr.prototype.getMetadataForProperty = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.getMetadataForEntity = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var entity = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .entities\n                    .withName(fieldExprItem.entity);\n                if (!entity)\n                    return;\n                // We only support count and countnonnull for entity.\n                if (field.entityAggr) {\n                    switch (field.entityAggr.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            return {\n                                kind: 1 /* Measure */,\n                                type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer),\n                                format: undefined,\n                                idOnEntityKey: false,\n                                aggregate: field.entityAggr.aggregate\n                            };\n                    }\n                }\n            };\n            return SQExpr;\n        }());\n        data.SQExpr = SQExpr;\n        /** Note: Exported for testability */\n        function defaultAggregateForDataType(type) {\n            if (type.integer || type.numeric)\n                return data.QueryAggregateFunction.Sum;\n            return data.QueryAggregateFunction.Count;\n        }\n        data.defaultAggregateForDataType = defaultAggregateForDataType;\n        /** Note: Exported for testability */\n        function defaultAggregateToQueryAggregateFunction(aggregate) {\n            switch (aggregate) {\n                case 6 /* Average */:\n                    return data.QueryAggregateFunction.Avg;\n                case 3 /* Count */:\n                    return data.QueryAggregateFunction.CountNonNull;\n                case 7 /* DistinctCount */:\n                    return data.QueryAggregateFunction.Count;\n                case 5 /* Max */:\n                    return data.QueryAggregateFunction.Max;\n                case 4 /* Min */:\n                    return data.QueryAggregateFunction.Min;\n                case 2 /* Sum */:\n                    return data.QueryAggregateFunction.Sum;\n                default:\n                    return;\n            }\n        }\n        data.defaultAggregateToQueryAggregateFunction = defaultAggregateToQueryAggregateFunction;\n        var SQEntityExpr = (function (_super) {\n            __extends(SQEntityExpr, _super);\n            function SQEntityExpr(schema, entity, variable) {\n                debug.assertValue(entity, 'entity');\n                _super.call(this, 0 /* Entity */);\n                this.schema = schema;\n                this.entity = entity;\n                if (variable)\n                    this.variable = variable;\n            }\n            SQEntityExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitEntity(this, arg);\n            };\n            return SQEntityExpr;\n        }(SQExpr));\n        data.SQEntityExpr = SQEntityExpr;\n        var SQArithmeticExpr = (function (_super) {\n            __extends(SQArithmeticExpr, _super);\n            function SQArithmeticExpr(left, right, operator) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                debug.assertValue(operator, 'operator');\n                _super.call(this, 22 /* Arithmetic */);\n                this.left = left;\n                this.right = right;\n                this.operator = operator;\n            }\n            SQArithmeticExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitArithmetic(this, arg);\n            };\n            return SQArithmeticExpr;\n        }(SQExpr));\n        data.SQArithmeticExpr = SQArithmeticExpr;\n        var SQScopedEvalExpr = (function (_super) {\n            __extends(SQScopedEvalExpr, _super);\n            function SQScopedEvalExpr(expression, scope) {\n                debug.assertValue(expression, 'expression');\n                debug.assertValue(scope, 'scope');\n                _super.call(this, 25 /* ScopedEval */);\n                this.expression = expression;\n                this.scope = scope;\n            }\n            SQScopedEvalExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitScopedEval(this, arg);\n            };\n            SQScopedEvalExpr.prototype.getMetadata = function (federatedSchema) {\n                return this.expression.getMetadata(federatedSchema);\n            };\n            return SQScopedEvalExpr;\n        }(SQExpr));\n        data.SQScopedEvalExpr = SQScopedEvalExpr;\n        var SQPropRefExpr = (function (_super) {\n            __extends(SQPropRefExpr, _super);\n            function SQPropRefExpr(kind, source, ref) {\n                debug.assertValue(kind, 'kind');\n                debug.assertValue(source, 'source');\n                debug.assertValue(ref, 'ref');\n                _super.call(this, kind);\n                this.source = source;\n                this.ref = ref;\n            }\n            return SQPropRefExpr;\n        }(SQExpr));\n        data.SQPropRefExpr = SQPropRefExpr;\n        var SQColumnRefExpr = (function (_super) {\n            __extends(SQColumnRefExpr, _super);\n            function SQColumnRefExpr(source, ref) {\n                _super.call(this, 1 /* ColumnRef */, source, ref);\n            }\n            SQColumnRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitColumnRef(this, arg);\n            };\n            return SQColumnRefExpr;\n        }(SQPropRefExpr));\n        data.SQColumnRefExpr = SQColumnRefExpr;\n        var SQMeasureRefExpr = (function (_super) {\n            __extends(SQMeasureRefExpr, _super);\n            function SQMeasureRefExpr(source, ref) {\n                _super.call(this, 2 /* MeasureRef */, source, ref);\n            }\n            SQMeasureRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitMeasureRef(this, arg);\n            };\n            return SQMeasureRefExpr;\n        }(SQPropRefExpr));\n        data.SQMeasureRefExpr = SQMeasureRefExpr;\n        var SQAggregationExpr = (function (_super) {\n            __extends(SQAggregationExpr, _super);\n            function SQAggregationExpr(arg, func) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(func, 'func');\n                _super.call(this, 3 /* Aggregation */);\n                this.arg = arg;\n                this.func = func;\n            }\n            SQAggregationExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAggr(this, arg);\n            };\n            return SQAggregationExpr;\n        }(SQExpr));\n        data.SQAggregationExpr = SQAggregationExpr;\n        var SQPercentileExpr = (function (_super) {\n            __extends(SQPercentileExpr, _super);\n            function SQPercentileExpr(arg, k, exclusive) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(k, 'k');\n                debug.assert(0 <= k && k <= 1, '0 <= k && k <= 1');\n                debug.assertValue(exclusive, 'exclusive');\n                _super.call(this, 27 /* Percentile */);\n                this.arg = arg;\n                this.k = k;\n                this.exclusive = exclusive;\n            }\n            SQPercentileExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var argMetadata = this.arg.getMetadata(federatedSchema);\n                if (argMetadata) {\n                    return {\n                        kind: 1 /* Measure */,\n                        type: argMetadata.type,\n                    };\n                }\n            };\n            SQPercentileExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPercentile(this, arg);\n            };\n            return SQPercentileExpr;\n        }(SQExpr));\n        data.SQPercentileExpr = SQPercentileExpr;\n        var SQPropertyVariationSourceExpr = (function (_super) {\n            __extends(SQPropertyVariationSourceExpr, _super);\n            function SQPropertyVariationSourceExpr(arg, name, property) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(name, 'name');\n                debug.assertValue(property, 'property');\n                _super.call(this, 4 /* PropertyVariationSource */);\n                this.arg = arg;\n                this.name = name;\n                this.property = property;\n            }\n            SQPropertyVariationSourceExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPropertyVariationSource(this, arg);\n            };\n            return SQPropertyVariationSourceExpr;\n        }(SQExpr));\n        data.SQPropertyVariationSourceExpr = SQPropertyVariationSourceExpr;\n        var SQHierarchyExpr = (function (_super) {\n            __extends(SQHierarchyExpr, _super);\n            function SQHierarchyExpr(arg, hierarchy) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(hierarchy, 'hierarchy');\n                _super.call(this, 5 /* Hierarchy */);\n                this.arg = arg;\n                this.hierarchy = hierarchy;\n            }\n            SQHierarchyExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchy(this, arg);\n            };\n            return SQHierarchyExpr;\n        }(SQExpr));\n        data.SQHierarchyExpr = SQHierarchyExpr;\n        var SQHierarchyLevelExpr = (function (_super) {\n            __extends(SQHierarchyLevelExpr, _super);\n            function SQHierarchyLevelExpr(arg, level) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(level, 'level');\n                _super.call(this, 6 /* HierarchyLevel */);\n                this.arg = arg;\n                this.level = level;\n            }\n            SQHierarchyLevelExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchyLevel(this, arg);\n            };\n            return SQHierarchyLevelExpr;\n        }(SQExpr));\n        data.SQHierarchyLevelExpr = SQHierarchyLevelExpr;\n        var SQSelectRefExpr = (function (_super) {\n            __extends(SQSelectRefExpr, _super);\n            function SQSelectRefExpr(expressionName) {\n                debug.assertValue(expressionName, 'arg');\n                _super.call(this, 28 /* SelectRef */);\n                this.expressionName = expressionName;\n            }\n            SQSelectRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitSelectRef(this, arg);\n            };\n            return SQSelectRefExpr;\n        }(SQExpr));\n        data.SQSelectRefExpr = SQSelectRefExpr;\n        var SQAndExpr = (function (_super) {\n            __extends(SQAndExpr, _super);\n            function SQAndExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 7 /* And */);\n                this.left = left;\n                this.right = right;\n            }\n            SQAndExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnd(this, arg);\n            };\n            return SQAndExpr;\n        }(SQExpr));\n        data.SQAndExpr = SQAndExpr;\n        var SQBetweenExpr = (function (_super) {\n            __extends(SQBetweenExpr, _super);\n            function SQBetweenExpr(arg, lower, upper) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(lower, 'lower');\n                debug.assertValue(upper, 'upper');\n                _super.call(this, 8 /* Between */);\n                this.arg = arg;\n                this.lower = lower;\n                this.upper = upper;\n            }\n            SQBetweenExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitBetween(this, arg);\n            };\n            return SQBetweenExpr;\n        }(SQExpr));\n        data.SQBetweenExpr = SQBetweenExpr;\n        var SQInExpr = (function (_super) {\n            __extends(SQInExpr, _super);\n            function SQInExpr(args, values) {\n                debug.assertValue(args, 'args');\n                debug.assertValue(values, 'values');\n                _super.call(this, 9 /* In */);\n                this.args = args;\n                this.values = values;\n            }\n            SQInExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitIn(this, arg);\n            };\n            return SQInExpr;\n        }(SQExpr));\n        data.SQInExpr = SQInExpr;\n        var SQOrExpr = (function (_super) {\n            __extends(SQOrExpr, _super);\n            function SQOrExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 10 /* Or */);\n                this.left = left;\n                this.right = right;\n            }\n            SQOrExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitOr(this, arg);\n            };\n            return SQOrExpr;\n        }(SQExpr));\n        data.SQOrExpr = SQOrExpr;\n        var SQCompareExpr = (function (_super) {\n            __extends(SQCompareExpr, _super);\n            function SQCompareExpr(comparison, left, right) {\n                debug.assertValue(comparison, 'kind');\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 12 /* Compare */);\n                this.comparison = comparison;\n                this.left = left;\n                this.right = right;\n            }\n            SQCompareExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitCompare(this, arg);\n            };\n            return SQCompareExpr;\n        }(SQExpr));\n        data.SQCompareExpr = SQCompareExpr;\n        var SQContainsExpr = (function (_super) {\n            __extends(SQContainsExpr, _super);\n            function SQContainsExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 11 /* Contains */);\n                this.left = left;\n                this.right = right;\n            }\n            SQContainsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitContains(this, arg);\n            };\n            return SQContainsExpr;\n        }(SQExpr));\n        data.SQContainsExpr = SQContainsExpr;\n        var SQStartsWithExpr = (function (_super) {\n            __extends(SQStartsWithExpr, _super);\n            function SQStartsWithExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 13 /* StartsWith */);\n                this.left = left;\n                this.right = right;\n            }\n            SQStartsWithExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitStartsWith(this, arg);\n            };\n            return SQStartsWithExpr;\n        }(SQExpr));\n        data.SQStartsWithExpr = SQStartsWithExpr;\n        var SQExistsExpr = (function (_super) {\n            __extends(SQExistsExpr, _super);\n            function SQExistsExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 14 /* Exists */);\n                this.arg = arg;\n            }\n            SQExistsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitExists(this, arg);\n            };\n            return SQExistsExpr;\n        }(SQExpr));\n        data.SQExistsExpr = SQExistsExpr;\n        var SQNotExpr = (function (_super) {\n            __extends(SQNotExpr, _super);\n            function SQNotExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 15 /* Not */);\n                this.arg = arg;\n            }\n            SQNotExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNot(this, arg);\n            };\n            return SQNotExpr;\n        }(SQExpr));\n        data.SQNotExpr = SQNotExpr;\n        var SQConstantExpr = (function (_super) {\n            __extends(SQConstantExpr, _super);\n            function SQConstantExpr(type, value, valueEncoded) {\n                debug.assertValue(type, 'type');\n                _super.call(this, 16 /* Constant */);\n                this.type = type;\n                this.value = value;\n                this.valueEncoded = valueEncoded;\n            }\n            SQConstantExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitConstant(this, arg);\n            };\n            SQConstantExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                return {\n                    // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\n                    // A getType or similiar function in the future would be more appropriate. \n                    kind: 1 /* Measure */,\n                    type: this.type,\n                };\n            };\n            return SQConstantExpr;\n        }(SQExpr));\n        data.SQConstantExpr = SQConstantExpr;\n        var SQDateSpanExpr = (function (_super) {\n            __extends(SQDateSpanExpr, _super);\n            function SQDateSpanExpr(unit, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 17 /* DateSpan */);\n                this.unit = unit;\n                this.arg = arg;\n            }\n            SQDateSpanExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateSpan(this, arg);\n            };\n            return SQDateSpanExpr;\n        }(SQExpr));\n        data.SQDateSpanExpr = SQDateSpanExpr;\n        var SQDateAddExpr = (function (_super) {\n            __extends(SQDateAddExpr, _super);\n            function SQDateAddExpr(unit, amount, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(amount, 'amount');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 18 /* DateAdd */);\n                this.unit = unit;\n                this.arg = arg;\n                this.amount = amount;\n            }\n            SQDateAddExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateAdd(this, arg);\n            };\n            return SQDateAddExpr;\n        }(SQExpr));\n        data.SQDateAddExpr = SQDateAddExpr;\n        var SQNowExpr = (function (_super) {\n            __extends(SQNowExpr, _super);\n            function SQNowExpr() {\n                _super.call(this, 19 /* Now */);\n            }\n            SQNowExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNow(this, arg);\n            };\n            return SQNowExpr;\n        }(SQExpr));\n        data.SQNowExpr = SQNowExpr;\n        var SQDefaultValueExpr = (function (_super) {\n            __extends(SQDefaultValueExpr, _super);\n            function SQDefaultValueExpr() {\n                _super.call(this, 21 /* DefaultValue */);\n            }\n            SQDefaultValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDefaultValue(this, arg);\n            };\n            return SQDefaultValueExpr;\n        }(SQExpr));\n        data.SQDefaultValueExpr = SQDefaultValueExpr;\n        var SQAnyValueExpr = (function (_super) {\n            __extends(SQAnyValueExpr, _super);\n            function SQAnyValueExpr() {\n                _super.call(this, 20 /* AnyValue */);\n            }\n            SQAnyValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnyValue(this, arg);\n            };\n            return SQAnyValueExpr;\n        }(SQExpr));\n        data.SQAnyValueExpr = SQAnyValueExpr;\n        var SQFillRuleExpr = (function (_super) {\n            __extends(SQFillRuleExpr, _super);\n            function SQFillRuleExpr(input, fillRule) {\n                debug.assertValue(input, 'input');\n                debug.assertValue(fillRule, 'fillRule');\n                _super.call(this, 23 /* FillRule */);\n                this.input = input;\n                this.rule = fillRule;\n            }\n            SQFillRuleExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitFillRule(this, arg);\n            };\n            return SQFillRuleExpr;\n        }(SQExpr));\n        data.SQFillRuleExpr = SQFillRuleExpr;\n        var SQResourcePackageItemExpr = (function (_super) {\n            __extends(SQResourcePackageItemExpr, _super);\n            function SQResourcePackageItemExpr(packageName, packageType, itemName) {\n                debug.assertValue(packageName, 'packageName');\n                debug.assertValue(itemName, 'itemName');\n                _super.call(this, 24 /* ResourcePackageItem */);\n                this.packageName = packageName;\n                this.packageType = packageType;\n                this.itemName = itemName;\n            }\n            SQResourcePackageItemExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitResourcePackageItem(this, arg);\n            };\n            return SQResourcePackageItemExpr;\n        }(SQExpr));\n        data.SQResourcePackageItemExpr = SQResourcePackageItemExpr;\n        /** Provides utilities for creating & manipulating expressions. */\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function entity(schema, entity, variable) {\n                return new SQEntityExpr(schema, entity, variable);\n            }\n            SQExprBuilder.entity = entity;\n            function columnRef(source, prop) {\n                return new SQColumnRefExpr(source, prop);\n            }\n            SQExprBuilder.columnRef = columnRef;\n            function measureRef(source, prop) {\n                return new SQMeasureRefExpr(source, prop);\n            }\n            SQExprBuilder.measureRef = measureRef;\n            function aggregate(source, aggregate) {\n                return new SQAggregationExpr(source, aggregate);\n            }\n            SQExprBuilder.aggregate = aggregate;\n            function selectRef(expressionName) {\n                return new SQSelectRefExpr(expressionName);\n            }\n            SQExprBuilder.selectRef = selectRef;\n            function percentile(source, k, exclusive) {\n                return new SQPercentileExpr(source, k, exclusive);\n            }\n            SQExprBuilder.percentile = percentile;\n            function arithmetic(left, right, operator) {\n                return new SQArithmeticExpr(left, right, operator);\n            }\n            SQExprBuilder.arithmetic = arithmetic;\n            function scopedEval(expression, scope) {\n                return new SQScopedEvalExpr(expression, scope);\n            }\n            SQExprBuilder.scopedEval = scopedEval;\n            function hierarchy(source, hierarchy) {\n                return new SQHierarchyExpr(source, hierarchy);\n            }\n            SQExprBuilder.hierarchy = hierarchy;\n            function propertyVariationSource(source, name, property) {\n                return new SQPropertyVariationSourceExpr(source, name, property);\n            }\n            SQExprBuilder.propertyVariationSource = propertyVariationSource;\n            function hierarchyLevel(source, level) {\n                return new SQHierarchyLevelExpr(source, level);\n            }\n            SQExprBuilder.hierarchyLevel = hierarchyLevel;\n            function and(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                return new SQAndExpr(left, right);\n            }\n            SQExprBuilder.and = and;\n            function between(arg, lower, upper) {\n                return new SQBetweenExpr(arg, lower, upper);\n            }\n            SQExprBuilder.between = between;\n            function inExpr(args, values) {\n                return new SQInExpr(args, values);\n            }\n            SQExprBuilder.inExpr = inExpr;\n            function or(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                if (left instanceof SQInExpr && right instanceof SQInExpr) {\n                    var inExpr_1 = tryUseInExprs(left, right);\n                    if (inExpr_1)\n                        return inExpr_1;\n                }\n                return new SQOrExpr(left, right);\n            }\n            SQExprBuilder.or = or;\n            function tryUseInExprs(left, right) {\n                if (!left.args || !right.args)\n                    return;\n                var leftArgLen = left.args.length;\n                var rightArgLen = right.args.length;\n                if (leftArgLen !== rightArgLen)\n                    return;\n                for (var i = 0; i < leftArgLen; ++i) {\n                    if (!SQExpr.equals(left.args[i], right.args[i]))\n                        return;\n                }\n                var combinedValues = left.values.concat(right.values);\n                return SQExprBuilder.inExpr(left.args, combinedValues);\n            }\n            function compare(kind, left, right) {\n                return new SQCompareExpr(kind, left, right);\n            }\n            SQExprBuilder.compare = compare;\n            function contains(left, right) {\n                return new SQContainsExpr(left, right);\n            }\n            SQExprBuilder.contains = contains;\n            function exists(arg) {\n                return new SQExistsExpr(arg);\n            }\n            SQExprBuilder.exists = exists;\n            function equal(left, right) {\n                return compare(data.QueryComparisonKind.Equal, left, right);\n            }\n            SQExprBuilder.equal = equal;\n            function not(arg) {\n                return new SQNotExpr(arg);\n            }\n            SQExprBuilder.not = not;\n            function startsWith(left, right) {\n                return new SQStartsWithExpr(left, right);\n            }\n            SQExprBuilder.startsWith = startsWith;\n            function nullConstant() {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Null), null, data.PrimitiveValueEncoding.nullEncoding());\n            }\n            SQExprBuilder.nullConstant = nullConstant;\n            function now() {\n                return new SQNowExpr();\n            }\n            SQExprBuilder.now = now;\n            function defaultValue() {\n                return new SQDefaultValueExpr();\n            }\n            SQExprBuilder.defaultValue = defaultValue;\n            function anyValue() {\n                return new SQAnyValueExpr();\n            }\n            SQExprBuilder.anyValue = anyValue;\n            function boolean(value) {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Boolean), value, data.PrimitiveValueEncoding.boolean(value));\n            }\n            SQExprBuilder.boolean = boolean;\n            function dateAdd(unit, amount, arg) {\n                return new SQDateAddExpr(unit, amount, arg);\n            }\n            SQExprBuilder.dateAdd = dateAdd;\n            function dateTime(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.dateTime(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.DateTime), value, valueEncoded);\n            }\n            SQExprBuilder.dateTime = dateTime;\n            function dateSpan(unit, arg) {\n                return new SQDateSpanExpr(unit, arg);\n            }\n            SQExprBuilder.dateSpan = dateSpan;\n            function decimal(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.decimal(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Decimal), value, valueEncoded);\n            }\n            SQExprBuilder.decimal = decimal;\n            function double(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.double(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double), value, valueEncoded);\n            }\n            SQExprBuilder.double = double;\n            function integer(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.integer(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer), value, valueEncoded);\n            }\n            SQExprBuilder.integer = integer;\n            function text(value, valueEncoded) {\n                debug.assert(!valueEncoded || valueEncoded === data.PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Text), value, valueEncoded || data.PrimitiveValueEncoding.text(value));\n            }\n            SQExprBuilder.text = text;\n            /** Returns an SQExpr that evaluates to the constant value. */\n            function typedConstant(value, type) {\n                if (value == null)\n                    return nullConstant();\n                if (_.isBoolean(value)) {\n                    return boolean(value);\n                }\n                if (_.isString(value)) {\n                    return text(value);\n                }\n                if (_.isNumber(value)) {\n                    if (type.integer && powerbi.Double.isInteger(value))\n                        return integer(value);\n                    return double(value);\n                }\n                if (value instanceof Date) {\n                    return dateTime(value);\n                }\n            }\n            SQExprBuilder.typedConstant = typedConstant;\n            function setAggregate(expr, aggregate) {\n                return FieldExprChangeAggregateRewriter.rewrite(expr, aggregate);\n            }\n            SQExprBuilder.setAggregate = setAggregate;\n            function removeAggregate(expr) {\n                return FieldExprRemoveAggregateRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeAggregate = removeAggregate;\n            function setPercentOfGrandTotal(expr) {\n                return SQExprSetPercentOfGrandTotalRewriter.rewrite(expr);\n            }\n            SQExprBuilder.setPercentOfGrandTotal = setPercentOfGrandTotal;\n            function removePercentOfGrandTotal(expr) {\n                return SQExprRemovePercentOfGrandTotalRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removePercentOfGrandTotal = removePercentOfGrandTotal;\n            function removeEntityVariables(expr) {\n                return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeEntityVariables = removeEntityVariables;\n            function fillRule(expr, rule) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(rule, 'rule');\n                return new SQFillRuleExpr(expr, rule);\n            }\n            SQExprBuilder.fillRule = fillRule;\n            function resourcePackageItem(packageName, packageType, itemName) {\n                return new SQResourcePackageItemExpr(packageName, packageType, itemName);\n            }\n            SQExprBuilder.resourcePackageItem = resourcePackageItem;\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        /** Provides utilities for obtaining information about expressions. */\n        var SQExprInfo;\n        (function (SQExprInfo) {\n            function getAggregate(expr) {\n                return SQExprAggregateInfoVisitor.getAggregate(expr);\n            }\n            SQExprInfo.getAggregate = getAggregate;\n        })(SQExprInfo = data.SQExprInfo || (data.SQExprInfo = {}));\n        var SQExprEqualityVisitor = (function () {\n            function SQExprEqualityVisitor(ignoreCase) {\n                this.ignoreCase = ignoreCase;\n            }\n            SQExprEqualityVisitor.run = function (x, y, ignoreCase) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (ignoreCase)\n                    return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\n                return x.accept(SQExprEqualityVisitor.instance, y);\n            };\n            SQExprEqualityVisitor.prototype.visitColumnRef = function (expr, comparand) {\n                return comparand instanceof SQColumnRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitMeasureRef = function (expr, comparand) {\n                return comparand instanceof SQMeasureRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitAggr = function (expr, comparand) {\n                return comparand instanceof SQAggregationExpr &&\n                    expr.func === comparand.func &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPercentile = function (expr, comparand) {\n                return comparand instanceof SQPercentileExpr &&\n                    expr.exclusive === comparand.exclusive &&\n                    expr.k === comparand.k &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchy = function (expr, comparand) {\n                return comparand instanceof SQHierarchyExpr &&\n                    expr.hierarchy === comparand.hierarchy &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchyLevel = function (expr, comparand) {\n                return comparand instanceof SQHierarchyLevelExpr &&\n                    expr.level === comparand.level &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPropertyVariationSource = function (expr, comparand) {\n                return comparand instanceof SQPropertyVariationSourceExpr &&\n                    expr.name === comparand.name &&\n                    expr.property === comparand.property &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitSelectRef = function (expr, comparand) {\n                return comparand instanceof SQSelectRefExpr &&\n                    expr.expressionName === comparand.expressionName;\n            };\n            SQExprEqualityVisitor.prototype.visitBetween = function (expr, comparand) {\n                return comparand instanceof SQBetweenExpr &&\n                    this.equals(expr.arg, comparand.arg) &&\n                    this.equals(expr.lower, comparand.lower) &&\n                    this.equals(expr.upper, comparand.upper);\n            };\n            SQExprEqualityVisitor.prototype.visitIn = function (expr, comparand) {\n                if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, comparand.args))\n                    return false;\n                var values = expr.values, compareValues = comparand.values;\n                if (values.length !== compareValues.length)\n                    return false;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    if (!this.equalsAll(values[i], compareValues[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.visitEntity = function (expr, comparand) {\n                return comparand instanceof SQEntityExpr &&\n                    expr.schema === comparand.schema &&\n                    expr.entity === comparand.entity &&\n                    this.optionalEqual(expr.variable, comparand.variable);\n            };\n            SQExprEqualityVisitor.prototype.visitAnd = function (expr, comparand) {\n                return comparand instanceof SQAndExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitOr = function (expr, comparand) {\n                return comparand instanceof SQOrExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitCompare = function (expr, comparand) {\n                return comparand instanceof SQCompareExpr &&\n                    expr.comparison === comparand.comparison &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitContains = function (expr, comparand) {\n                return comparand instanceof SQContainsExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitDateSpan = function (expr, comparand) {\n                return comparand instanceof SQDateSpanExpr &&\n                    expr.unit === comparand.unit &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitDateAdd = function (expr, comparand) {\n                return comparand instanceof SQDateAddExpr &&\n                    expr.unit === comparand.unit &&\n                    expr.amount === comparand.amount &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitExists = function (expr, comparand) {\n                return comparand instanceof SQExistsExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNot = function (expr, comparand) {\n                return comparand instanceof SQNotExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNow = function (expr, comparand) {\n                return comparand instanceof SQNowExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitDefaultValue = function (expr, comparand) {\n                return comparand instanceof SQDefaultValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitAnyValue = function (expr, comparand) {\n                return comparand instanceof SQAnyValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitResourcePackageItem = function (expr, comparand) {\n                return comparand instanceof SQResourcePackageItemExpr &&\n                    expr.packageName === comparand.packageName &&\n                    expr.packageType === comparand.packageType &&\n                    expr.itemName === comparand.itemName;\n            };\n            SQExprEqualityVisitor.prototype.visitStartsWith = function (expr, comparand) {\n                return comparand instanceof SQStartsWithExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitConstant = function (expr, comparand) {\n                if (comparand instanceof SQConstantExpr && expr.type === comparand.type)\n                    return expr.type.text && this.ignoreCase ?\n                        StringExtensions.equalIgnoreCase(expr.valueEncoded, comparand.valueEncoded) :\n                        expr.valueEncoded === comparand.valueEncoded;\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitFillRule = function (expr, comparand) {\n                if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\n                    var leftRule = expr.rule, rightRule = comparand.rule;\n                    if (leftRule === rightRule)\n                        return true;\n                    var leftLinearGradient2 = leftRule.linearGradient2, rightLinearGradient2 = rightRule.linearGradient2;\n                    if (leftLinearGradient2 && rightLinearGradient2) {\n                        return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\n                    }\n                    var leftLinearGradient3 = leftRule.linearGradient3, rightLinearGradient3 = rightRule.linearGradient3;\n                    if (leftLinearGradient3 && rightLinearGradient3) {\n                        return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\n                    }\n                }\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient2 = function (left2, right2) {\n                debug.assertValue(left2, 'left2');\n                debug.assertValue(right2, 'right2');\n                return this.equalsFillRuleStop(left2.min, right2.min) &&\n                    this.equalsFillRuleStop(left2.max, right2.max);\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient3 = function (left3, right3) {\n                debug.assertValue(left3, 'left3');\n                debug.assertValue(right3, 'right3');\n                return this.equalsFillRuleStop(left3.min, right3.min) &&\n                    this.equalsFillRuleStop(left3.mid, right3.mid) &&\n                    this.equalsFillRuleStop(left3.max, right3.max);\n            };\n            SQExprEqualityVisitor.prototype.equalsFillRuleStop = function (stop1, stop2) {\n                debug.assertValue(stop1, 'stop1');\n                debug.assertValue(stop2, 'stop2');\n                if (!this.equals(stop1.color, stop2.color))\n                    return false;\n                if (!stop1.value)\n                    return stop1.value === stop2.value;\n                return this.equals(stop1.value, stop2.value);\n            };\n            SQExprEqualityVisitor.prototype.visitArithmetic = function (expr, comparand) {\n                return comparand instanceof SQArithmeticExpr &&\n                    expr.operator === comparand.operator &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitScopedEval = function (expr, comparand) {\n                return comparand instanceof SQScopedEvalExpr &&\n                    this.equals(expr.expression, comparand.expression) &&\n                    this.equalsAll(expr.scope, comparand.scope);\n            };\n            SQExprEqualityVisitor.prototype.optionalEqual = function (x, y) {\n                // Only check equality if both values are specified.\n                if (x && y)\n                    return x === y;\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.equals = function (x, y) {\n                return x.accept(this, y);\n            };\n            SQExprEqualityVisitor.prototype.equalsAll = function (x, y) {\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!this.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.instance = new SQExprEqualityVisitor(/* ignoreCase */ false);\n            SQExprEqualityVisitor.ignoreCaseInstance = new SQExprEqualityVisitor(true);\n            return SQExprEqualityVisitor;\n        }());\n        /** Rewrites a root-level expression. */\n        var SQExprRootRewriter = (function (_super) {\n            __extends(SQExprRootRewriter, _super);\n            function SQExprRootRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRootRewriter.prototype.visitDefault = function (expr) {\n                return expr;\n            };\n            return SQExprRootRewriter;\n        }(data.DefaultSQExprVisitor));\n        var SQExprValidationVisitor = (function (_super) {\n            __extends(SQExprValidationVisitor, _super);\n            function SQExprValidationVisitor(schema, aggrUtils, errors) {\n                debug.assertValue(schema, 'schema');\n                debug.assertValue(aggrUtils, 'aggrUtils');\n                _super.call(this);\n                this.schema = schema;\n                this.aggrUtils = aggrUtils;\n                if (errors)\n                    this.errors = errors;\n            }\n            SQExprValidationVisitor.prototype.visitIn = function (expr) {\n                var inExpr = _super.prototype.visitIn.call(this, expr);\n                var args = inExpr.args;\n                var values = inExpr.values;\n                for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n                    var valueTuple = values_2[_i];\n                    debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\n                    for (var i = 0, len = valueTuple.length; i < len; ++i)\n                        this.validateCompatibleType(args[i], valueTuple[i]);\n                }\n                return inExpr;\n            };\n            SQExprValidationVisitor.prototype.visitCompare = function (expr) {\n                var compareExpr = _super.prototype.visitCompare.call(this, expr);\n                this.validateCompatibleType(compareExpr.left, compareExpr.right);\n                return compareExpr;\n            };\n            SQExprValidationVisitor.prototype.visitColumnRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.column.name);\n                        if (!prop ||\n                            prop.kind !== 0 /* Column */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(3 /* invalidColumnReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitMeasureRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.measure.name);\n                        if (!prop ||\n                            prop.kind !== 1 /* Measure */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(4 /* invalidMeasureReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitAggr = function (expr) {\n                var aggregateExpr = _super.prototype.visitAggr.call(this, expr);\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\n                if (columnRefExpr) {\n                    if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/ null))\n                        this.register(0 /* invalidAggregateFunction */);\n                }\n                return aggregateExpr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchy = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = fieldExpr.hierarchy;\n                    if (fieldExprItem) {\n                        this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\n                    }\n                    else {\n                        this.register(5 /* invalidHierarchyReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var hierarchyLevelFieldExprItem = fieldExpr.hierarchyLevel;\n                    if (hierarchyLevelFieldExprItem) {\n                        this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\n                    }\n                    else if (!fieldExpr.columnHierarchyLevelVariation) {\n                        this.register(6 /* invalidHierarchyLevelReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitPercentile = function (expr) {\n                expr.arg.accept(this);\n                if (_.isEmpty(this.errors)) {\n                    var argMetadata = expr.arg.getMetadata(this.schema);\n                    if (!argMetadata ||\n                        argMetadata.kind !== 0 /* Column */ ||\n                        !(argMetadata.type && (argMetadata.type.integer || argMetadata.type.numeric))) {\n                        this.register(10 /* invalidPercentileArgument */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitEntity = function (expr) {\n                this.validateEntity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitContains = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitStartsWith = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitArithmetic = function (expr) {\n                this.validateArithmeticTypes(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitScopedEval = function (expr) {\n                // No validation necessary\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.validateOperandsAndTypeForStartOrContains = function (left, right) {\n                if (left instanceof SQColumnRefExpr) {\n                    this.visitColumnRef(left);\n                }\n                else if (left instanceof SQHierarchyLevelExpr) {\n                    this.visitHierarchyLevel(left);\n                }\n                else {\n                    this.register(7 /* invalidLeftOperandType */);\n                }\n                if (!(right instanceof SQConstantExpr) || !right.type.text)\n                    this.register(8 /* invalidRightOperandType */);\n                else\n                    this.validateCompatibleType(left, right);\n            };\n            SQExprValidationVisitor.prototype.validateArithmeticTypes = function (left, right) {\n                if (!data.SQExprUtils.supportsArithmetic(left, this.schema))\n                    this.register(7 /* invalidLeftOperandType */);\n                if (!data.SQExprUtils.supportsArithmetic(right, this.schema))\n                    this.register(8 /* invalidRightOperandType */);\n            };\n            SQExprValidationVisitor.prototype.validateCompatibleType = function (left, right) {\n                var leftMetadata = left.getMetadata(this.schema), leftType = leftMetadata && leftMetadata.type, rightMetadata = right.getMetadata(this.schema), rightType = rightMetadata && rightMetadata.type;\n                if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\n                    this.register(9 /* invalidValueType */);\n            };\n            SQExprValidationVisitor.prototype.validateEntity = function (schemaName, entityName) {\n                var schema = this.schema.schema(schemaName);\n                if (schema) {\n                    var entity = schema.entities.withName(entityName);\n                    if (entity)\n                        return entity;\n                    this.register(2 /* invalidEntityReference */);\n                }\n                else {\n                    this.register(1 /* invalidSchemaReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchy = function (schemaName, entityName, hierarchyName) {\n                var entity = this.validateEntity(schemaName, entityName);\n                if (entity) {\n                    var hierarchy = entity.hierarchies.withName(hierarchyName);\n                    if (hierarchy)\n                        return hierarchy;\n                    this.register(5 /* invalidHierarchyReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchyLevel = function (schemaName, entityName, hierarchyName, levelName) {\n                var hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\n                if (hierarchy) {\n                    var hierarchyLevel = hierarchy.levels.withName(levelName);\n                    if (hierarchyLevel)\n                        return hierarchyLevel;\n                    this.register(6 /* invalidHierarchyLevelReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.register = function (error) {\n                if (!this.errors)\n                    this.errors = [];\n                this.errors.push(error);\n            };\n            SQExprValidationVisitor.prototype.isQueryable = function (fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\n                    var hierarchyLevelConceptualProperty = data.SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\n                    return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== 1 /* Error */;\n                }\n                return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, data.FieldExprPattern.getPropertyName(fieldExpr)).queryable !== 1 /* Error */;\n            };\n            return SQExprValidationVisitor;\n        }(data.SQExprRewriter));\n        data.SQExprValidationVisitor = SQExprValidationVisitor;\n        /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\n        var SQExprAggregateInfoVisitor = (function (_super) {\n            __extends(SQExprAggregateInfoVisitor, _super);\n            function SQExprAggregateInfoVisitor() {\n                _super.apply(this, arguments);\n            }\n            SQExprAggregateInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.func;\n            };\n            SQExprAggregateInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprAggregateInfoVisitor.getAggregate = function (expr) {\n                var visitor = new SQExprAggregateInfoVisitor();\n                return expr.accept(visitor);\n            };\n            return SQExprAggregateInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQExprColumnRef expression or undefined.*/\n        var SQExprColumnRefInfoVisitor = (function (_super) {\n            __extends(SQExprColumnRefInfoVisitor, _super);\n            function SQExprColumnRefInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQExprColumnRefInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return expr;\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var ref = expr.level;\n                var hierarchy = (expr.arg);\n                var sourceExpr = hierarchy.accept(this);\n                if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\n                    var propertyVariationSource = hierarchy.arg;\n                    var targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\n                    if (sourceExpr && targetEntity) {\n                        var schemaName = (sourceExpr.source).schema;\n                        var targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\n                        var schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\n                        if (schemaHierarchy) {\n                            for (var _i = 0, _a = schemaHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                if (level.name === ref)\n                                    return new SQColumnRefExpr(targetEntityExpr, level.column.name);\n                            }\n                        }\n                    }\n                }\n                else {\n                    var entityExpr = (hierarchy.arg);\n                    var hierarchyLevelRef = data.SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema, entityExpr.schema, entityExpr.entity, hierarchy.hierarchy, expr.level);\n                    if (hierarchyLevelRef)\n                        return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\n                }\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var propertyName = expr.property;\n                return new SQColumnRefExpr(expr.arg, propertyName);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprColumnRefInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQExprColumnRefInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQEntityExpr expression or undefined.*/\n        var SQEntityExprInfoVisitor = (function (_super) {\n            __extends(SQEntityExprInfoVisitor, _super);\n            function SQEntityExprInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQEntityExprInfoVisitor.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQEntityExprInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return SQEntityExprInfoVisitor.getEntity(expr);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQEntityExprInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitAggr = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitMeasureRef = function (expr) {\n                return expr.source.accept(this);\n            };\n            SQEntityExprInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            SQEntityExprInfoVisitor.getEntity = function (columnRef) {\n                var field = data.SQExprConverter.asFieldPattern(columnRef);\n                var column = field.column;\n                return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\n            };\n            SQEntityExprInfoVisitor.getEntityExpr = function (schema, expr) {\n                var visitor = new SQEntityExprInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQEntityExprInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        var SQExprChangeAggregateRewriter = (function (_super) {\n            __extends(SQExprChangeAggregateRewriter, _super);\n            function SQExprChangeAggregateRewriter(func) {\n                debug.assertValue(func, 'func');\n                _super.call(this);\n                this.func = func;\n            }\n            SQExprChangeAggregateRewriter.prototype.visitAggr = function (expr) {\n                if (expr.func === this.func)\n                    return expr;\n                return new SQAggregationExpr(expr.arg, this.func);\n            };\n            SQExprChangeAggregateRewriter.prototype.visitColumnRef = function (expr) {\n                return new SQAggregationExpr(expr, this.func);\n            };\n            SQExprChangeAggregateRewriter.rewrite = function (expr, func) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(func, 'func');\n                var rewriter = new SQExprChangeAggregateRewriter(func);\n                return expr.accept(rewriter);\n            };\n            return SQExprChangeAggregateRewriter;\n        }(SQExprRootRewriter));\n        var FieldExprChangeAggregateRewriter = (function () {\n            function FieldExprChangeAggregateRewriter(sqExpr, aggregate) {\n                this.sqExpr = sqExpr;\n                this.aggregate = aggregate;\n            }\n            FieldExprChangeAggregateRewriter.rewrite = function (sqExpr, aggregate) {\n                return data.FieldExprPattern.visit(sqExpr, new FieldExprChangeAggregateRewriter(sqExpr, aggregate));\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitPercentOfGrandTotal = function (pattern) {\n                pattern.baseExpr = data.SQExprConverter.asFieldPattern(SQExprChangeAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr), this.aggregate));\n                return SQExprBuilder.fieldExpr({ percentOfGrandTotal: pattern });\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumn = function (column) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumnAggr = function (columnAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitSelectRef = function (selectRef) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitEntity = function (entity) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitEntityAggr = function (entityAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchy = function (hierarchy) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitMeasure = function (measure) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitPercentile = function (percentile) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.defaultRewrite = function () {\n                return SQExprChangeAggregateRewriter.rewrite(this.sqExpr, this.aggregate);\n            };\n            return FieldExprChangeAggregateRewriter;\n        }());\n        var FieldExprRemoveAggregateRewriter = (function () {\n            function FieldExprRemoveAggregateRewriter(sqExpr) {\n                this.sqExpr = sqExpr;\n            }\n            FieldExprRemoveAggregateRewriter.rewrite = function (sqExpr) {\n                return data.FieldExprPattern.visit(sqExpr, new FieldExprRemoveAggregateRewriter(sqExpr));\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitPercentOfGrandTotal = function (pattern) {\n                return FieldExprRemoveAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr));\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitColumn = function (column) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitColumnAggr = function (columnAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitSelectRef = function (selectRef) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitEntity = function (entity) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitEntityAggr = function (entityAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitHierarchy = function (hierarchy) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitMeasure = function (measure) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.visitPercentile = function (percentile) {\n                return this.defaultRewrite();\n            };\n            FieldExprRemoveAggregateRewriter.prototype.defaultRewrite = function () {\n                return SQExprRemoveAggregateRewriter.rewrite(this.sqExpr);\n            };\n            return FieldExprRemoveAggregateRewriter;\n        }());\n        var SQExprRemoveAggregateRewriter = (function (_super) {\n            __extends(SQExprRemoveAggregateRewriter, _super);\n            function SQExprRemoveAggregateRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveAggregateRewriter.prototype.visitAggr = function (expr) {\n                return expr.arg;\n            };\n            SQExprRemoveAggregateRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveAggregateRewriter.instance);\n            };\n            SQExprRemoveAggregateRewriter.instance = new SQExprRemoveAggregateRewriter();\n            return SQExprRemoveAggregateRewriter;\n        }(SQExprRootRewriter));\n        var SQExprRemoveEntityVariablesRewriter = (function (_super) {\n            __extends(SQExprRemoveEntityVariablesRewriter, _super);\n            function SQExprRemoveEntityVariablesRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveEntityVariablesRewriter.prototype.visitEntity = function (expr) {\n                if (expr.variable)\n                    return SQExprBuilder.entity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprRemoveEntityVariablesRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\n            };\n            SQExprRemoveEntityVariablesRewriter.instance = new SQExprRemoveEntityVariablesRewriter();\n            return SQExprRemoveEntityVariablesRewriter;\n        }(data.SQExprRewriter));\n        var SQExprRemovePercentOfGrandTotalRewriter = (function (_super) {\n            __extends(SQExprRemovePercentOfGrandTotalRewriter, _super);\n            function SQExprRemovePercentOfGrandTotalRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemovePercentOfGrandTotalRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemovePercentOfGrandTotalRewriter.instance);\n            };\n            SQExprRemovePercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr && fieldExpr.percentOfGrandTotal)\n                    expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfGrandTotal.baseExpr);\n                return expr;\n            };\n            SQExprRemovePercentOfGrandTotalRewriter.instance = new SQExprRemovePercentOfGrandTotalRewriter();\n            return SQExprRemovePercentOfGrandTotalRewriter;\n        }(SQExprRootRewriter));\n        var SQExprSetPercentOfGrandTotalRewriter = (function (_super) {\n            __extends(SQExprSetPercentOfGrandTotalRewriter, _super);\n            function SQExprSetPercentOfGrandTotalRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprSetPercentOfGrandTotalRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprSetPercentOfGrandTotalRewriter.instance);\n            };\n            SQExprSetPercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr && !fieldExpr.percentOfGrandTotal)\n                    expr = SQExprBuilder.fieldExpr({ percentOfGrandTotal: { baseExpr: data.SQExprConverter.asFieldPattern(expr) } });\n                return expr;\n            };\n            SQExprSetPercentOfGrandTotalRewriter.instance = new SQExprSetPercentOfGrandTotalRewriter();\n            return SQExprSetPercentOfGrandTotalRewriter;\n        }(SQExprRootRewriter));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var StringExtensions = jsCommon.StringExtensions;\n        var SQExprUtils;\n        (function (SQExprUtils) {\n            function supportsArithmetic(expr, schema) {\n                var metadata = expr.getMetadata(schema), type = metadata && metadata.type;\n                if (!metadata || !type) {\n                    return false;\n                }\n                return type.numeric || type.dateTime || type.duration;\n            }\n            SQExprUtils.supportsArithmetic = supportsArithmetic;\n            function indexOfExpr(items, searchElement) {\n                debug.assertValue(items, 'items');\n                debug.assertValue(searchElement, 'searchElement');\n                for (var i = 0, len = items.length; i < len; i++) {\n                    if (data.SQExpr.equals(items[i], searchElement))\n                        return i;\n                }\n                return -1;\n            }\n            SQExprUtils.indexOfExpr = indexOfExpr;\n            function sequenceEqual(x, y) {\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!data.SQExpr.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            SQExprUtils.sequenceEqual = sequenceEqual;\n            function uniqueName(namedItems, expr, exprDefaultName) {\n                debug.assertValue(namedItems, 'namedItems');\n                // Determine all names\n                var names = {};\n                for (var i = 0, len = namedItems.length; i < len; i++)\n                    names[namedItems[i].name] = true;\n                return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\n            }\n            SQExprUtils.uniqueName = uniqueName;\n            /** Generates a default expression name  */\n            function defaultName(expr, fallback) {\n                if (fallback === void 0) { fallback = 'select'; }\n                if (!expr)\n                    return fallback;\n                return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\n            }\n            SQExprUtils.defaultName = defaultName;\n            /** Gets a value indicating whether the expr is a model measure or an aggregate. */\n            function isMeasure(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsMeasureVisitor.instance);\n            }\n            SQExprUtils.isMeasure = isMeasure;\n            /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\n            function isAnyValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsAnyValueVisitor.instance);\n            }\n            SQExprUtils.isAnyValue = isAnyValue;\n            /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\n            function isDefaultValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsDefaultValueVisitor.instance);\n            }\n            SQExprUtils.isDefaultValue = isDefaultValue;\n            function discourageAggregation(expr, schema) {\n                var capabilities = getSchemaCapabilities(expr, schema);\n                return capabilities && capabilities.discourageQueryAggregateUsage;\n            }\n            SQExprUtils.discourageAggregation = discourageAggregation;\n            function getAggregateBehavior(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var column = getConceptualColumn(expr, schema);\n                if (column)\n                    return column.aggregateBehavior;\n            }\n            SQExprUtils.getAggregateBehavior = getAggregateBehavior;\n            function getSchemaCapabilities(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var field = data.SQExprConverter.asFieldPattern(expr);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var conceptualSchema = schema.schema(fieldExprItem.schema);\n                if (conceptualSchema)\n                    return conceptualSchema.capabilities;\n            }\n            SQExprUtils.getSchemaCapabilities = getSchemaCapabilities;\n            function getKpiMetadata(expr, schema) {\n                var kpiStatusProperty = getKpiStatusProperty(expr, schema);\n                if (kpiStatusProperty)\n                    return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\n                var kpiTrendProperty = getKpiTrendProperty(expr, schema);\n                if (kpiTrendProperty)\n                    return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\n            }\n            SQExprUtils.getKpiMetadata = getKpiMetadata;\n            function getConceptualEntity(entityExpr, schema) {\n                debug.assertValue(entityExpr, 'entityExpr');\n                var conceptualEntity = schema\n                    .schema(entityExpr.schema)\n                    .entities\n                    .withName(entityExpr.entity);\n                return conceptualEntity;\n            }\n            SQExprUtils.getConceptualEntity = getConceptualEntity;\n            function getKpiStatusProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.status === property)\n                    return property;\n            }\n            function getKpiTrendProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.trend === property)\n                    return property;\n            }\n            function getDefaultValue(fieldSQExpr, schema) {\n                var column = getConceptualColumn(fieldSQExpr, schema);\n                if (column)\n                    return column.defaultValue;\n            }\n            SQExprUtils.getDefaultValue = getDefaultValue;\n            function getConceptualColumn(fieldSQExpr, schema) {\n                if (!fieldSQExpr || !schema)\n                    return;\n                var sqField = data.SQExprConverter.asFieldPattern(fieldSQExpr);\n                if (!sqField)\n                    return;\n                var column = sqField.column;\n                if (column) {\n                    if (schema.schema(column.schema) && sqField.column.name) {\n                        var property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\n                        if (property)\n                            return property.column;\n                    }\n                }\n                else {\n                    var hierarchyLevelField = sqField.hierarchyLevel;\n                    if (hierarchyLevelField) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(sqField);\n                        var schemaName = fieldExprItem.schema;\n                        if (schema.schema(schemaName)) {\n                            var hierarchy = schema.schema(schemaName)\n                                .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\n                            if (hierarchy) {\n                                var hierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\n                                if (hierarchyLevel && hierarchyLevel.column)\n                                    return hierarchyLevel.column.column;\n                            }\n                        }\n                    }\n                }\n            }\n            function getDefaultValues(fieldSQExprs, schema) {\n                if (_.isEmpty(fieldSQExprs) || !schema)\n                    return;\n                var result = [];\n                for (var _i = 0, fieldSQExprs_2 = fieldSQExprs; _i < fieldSQExprs_2.length; _i++) {\n                    var sqExpr = fieldSQExprs_2[_i];\n                    var defaultValue = getDefaultValue(sqExpr, schema);\n                    if (defaultValue)\n                        result.push(defaultValue);\n                }\n                return result;\n            }\n            SQExprUtils.getDefaultValues = getDefaultValues;\n            /** Return compare or and expression for key value pairs. */\n            function getDataViewScopeIdentityComparisonExpr(fieldsExpr, values) {\n                debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\n                var compareExprs = [];\n                for (var i = 0; i < fieldsExpr.length; i++) {\n                    compareExprs.push(data.SQExprBuilder.compare(data.QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\n                }\n                if (_.isEmpty(compareExprs))\n                    return;\n                var resultExpr;\n                for (var _i = 0, compareExprs_1 = compareExprs; _i < compareExprs_1.length; _i++) {\n                    var compareExpr = compareExprs_1[_i];\n                    resultExpr = data.SQExprBuilder.and(resultExpr, compareExpr);\n                }\n                return resultExpr;\n            }\n            SQExprUtils.getDataViewScopeIdentityComparisonExpr = getDataViewScopeIdentityComparisonExpr;\n            function getActiveTablesNames(queryDefn) {\n                var tables = [];\n                if (queryDefn) {\n                    var selectedItems = queryDefn.from();\n                    if (selectedItems !== undefined) {\n                        for (var _i = 0, _a = selectedItems.keys(); _i < _a.length; _i++) {\n                            var key = _a[_i];\n                            var entityObj = selectedItems.entity(key);\n                            if (tables.indexOf(entityObj.entity) < 0)\n                                tables.push(entityObj.entity);\n                        }\n                    }\n                }\n                return tables;\n            }\n            SQExprUtils.getActiveTablesNames = getActiveTablesNames;\n            function isRelatedToMany(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 0 /* ZeroOrOne */, 2 /* Many */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 2 /* Many */, 0 /* ZeroOrOne */);\n            }\n            SQExprUtils.isRelatedToMany = isRelatedToMany;\n            function isRelatedToOne(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 2 /* Many */, 0 /* ZeroOrOne */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 0 /* ZeroOrOne */, 2 /* Many */);\n            }\n            SQExprUtils.isRelatedToOne = isRelatedToOne;\n            function isRelated(schema, sourceExpr, targetExpr, sourceMultiplicity, targetMultiplicity) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                if (_.isEmpty(source.navigationProperties))\n                    return false;\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var queue = [];\n                queue.push(source);\n                // walk the relationship path from source.\n                while (!_.isEmpty(queue)) {\n                    var current = queue.shift();\n                    var navProperties = current.navigationProperties;\n                    if (_.isEmpty(navProperties))\n                        continue;\n                    for (var _i = 0, navProperties_1 = navProperties; _i < navProperties_1.length; _i++) {\n                        var navProperty = navProperties_1[_i];\n                        if (!navProperty.isActive)\n                            continue;\n                        if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\n                            if (navProperty.targetEntity === target)\n                                return true;\n                            queue.push(navProperty.targetEntity);\n                        }\n                    }\n                }\n                return false;\n            }\n            function isRelatedOneToOne(schema, sourceExpr, targetExpr) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var sourceNavigations = source.navigationProperties;\n                var targetNavigations = target.navigationProperties;\n                if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\n                    return false;\n                return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\n            }\n            SQExprUtils.isRelatedOneToOne = isRelatedOneToOne;\n            function hasOneToOneNavigation(navigationProperties, targetEntity) {\n                if (_.isEmpty(navigationProperties))\n                    return false;\n                for (var _i = 0, navigationProperties_1 = navigationProperties; _i < navigationProperties_1.length; _i++) {\n                    var navigationProperty = navigationProperties_1[_i];\n                    if (!navigationProperty.isActive)\n                        continue;\n                    if (navigationProperty.targetEntity !== targetEntity)\n                        continue;\n                    if (navigationProperty.sourceMultiplicity === 0 /* ZeroOrOne */ &&\n                        navigationProperty.targetMultiplicity === 0 /* ZeroOrOne */) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\n                and returns a new array. When available, we should use _.unionWith from lodash. */\n            function concatUnique(leftExprs, rightExprs) {\n                debug.assertValue(leftExprs, 'leftExprs');\n                debug.assertValue(rightExprs, 'rightExprs');\n                var concatExprs = ArrayExtensions.copy(leftExprs);\n                for (var _i = 0, rightExprs_1 = rightExprs; _i < rightExprs_1.length; _i++) {\n                    var expr = rightExprs_1[_i];\n                    if (indexOfExpr(concatExprs, expr) === -1) {\n                        concatExprs.push(expr);\n                    }\n                }\n                return concatExprs;\n            }\n            SQExprUtils.concatUnique = concatUnique;\n            var SQExprDefaultNameGenerator = (function (_super) {\n                __extends(SQExprDefaultNameGenerator, _super);\n                function SQExprDefaultNameGenerator() {\n                    _super.apply(this, arguments);\n                }\n                SQExprDefaultNameGenerator.prototype.visitEntity = function (expr) {\n                    return expr.entity;\n                };\n                SQExprDefaultNameGenerator.prototype.visitColumnRef = function (expr) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitMeasureRef = function (expr, fallback) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitAggr = function (expr, fallback) {\n                    return data.QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitPercentile = function (expr, fallback) {\n                    var func = expr.exclusive\n                        ? 'Percentile.Exc('\n                        : 'Percentile.Inc(';\n                    return func + expr.arg.accept(this) + ', ' + expr.k + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitArithmetic = function (expr, fallback) {\n                    return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitConstant = function (expr) {\n                    return 'const';\n                };\n                SQExprDefaultNameGenerator.prototype.visitDefault = function (expr, fallback) {\n                    return fallback || 'expr';\n                };\n                SQExprDefaultNameGenerator.instance = new SQExprDefaultNameGenerator();\n                return SQExprDefaultNameGenerator;\n            }(data.DefaultSQExprVisitorWithArg));\n            var IsMeasureVisitor = (function (_super) {\n                __extends(IsMeasureVisitor, _super);\n                function IsMeasureVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsMeasureVisitor.prototype.visitMeasureRef = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitAggr = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitArithmetic = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsMeasureVisitor.instance = new IsMeasureVisitor();\n                return IsMeasureVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsDefaultValueVisitor = (function (_super) {\n                __extends(IsDefaultValueVisitor, _super);\n                function IsDefaultValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsDefaultValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitDefaultValue = function (expr) {\n                    return true;\n                };\n                IsDefaultValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsDefaultValueVisitor.instance = new IsDefaultValueVisitor();\n                return IsDefaultValueVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsAnyValueVisitor = (function (_super) {\n                __extends(IsAnyValueVisitor, _super);\n                function IsAnyValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsAnyValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnyValue = function (expr) {\n                    return true;\n                };\n                IsAnyValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsAnyValueVisitor.instance = new IsAnyValueVisitor();\n                return IsAnyValueVisitor;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprUtils = data.SQExprUtils || (data.SQExprUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SemanticQueryRewriter = (function () {\n            function SemanticQueryRewriter(exprRewriter) {\n                this.exprRewriter = exprRewriter;\n            }\n            SemanticQueryRewriter.prototype.rewriteFrom = function (fromValue) {\n                var fromContents = {};\n                var originalFrom = fromValue, originalFromKeys = originalFrom.keys();\n                for (var i = 0, len = originalFromKeys.length; i < len; i++) {\n                    var keyName = originalFromKeys[i], originalEntityRef = originalFrom.entity(keyName), originalEntityExpr = data.SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName), updatedEntityExpr = originalEntityExpr.accept(this.exprRewriter);\n                    fromContents[keyName] = {\n                        schema: updatedEntityExpr.schema,\n                        entity: updatedEntityExpr.entity,\n                    };\n                }\n                return new data.SQFrom(fromContents);\n            };\n            SemanticQueryRewriter.prototype.rewriteSelect = function (selectItems, from) {\n                debug.assertValue(selectItems, 'selectItems');\n                debug.assertValue(from, 'from');\n                return this.rewriteNamedSQExpressions(selectItems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteGroupBy = function (groupByitems, from) {\n                debug.assertAnyValue(groupByitems, 'groupByitems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(groupByitems))\n                    return;\n                return this.rewriteNamedSQExpressions(groupByitems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteNamedSQExpressions = function (expressions, from) {\n                var _this = this;\n                debug.assertValue(expressions, 'expressions');\n                return _.map(expressions, function (item) {\n                    return {\n                        name: item.name,\n                        expr: data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(_this.exprRewriter), from)\n                    };\n                });\n            };\n            SemanticQueryRewriter.prototype.rewriteOrderBy = function (orderByItems, from) {\n                debug.assertAnyValue(orderByItems, 'orderByItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(orderByItems))\n                    return;\n                var orderBy = [];\n                for (var i = 0, len = orderByItems.length; i < len; i++) {\n                    var item = orderByItems[i], updatedExpr = data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\n                    orderBy.push({\n                        direction: item.direction,\n                        expr: updatedExpr,\n                    });\n                }\n                return orderBy;\n            };\n            SemanticQueryRewriter.prototype.rewriteWhere = function (whereItems, from) {\n                var _this = this;\n                debug.assertAnyValue(whereItems, 'whereItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(whereItems))\n                    return;\n                var where = [];\n                for (var i = 0, len = whereItems.length; i < len; i++) {\n                    var originalWhere = whereItems[i];\n                    var updatedWhere = {\n                        condition: data.SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\n                    };\n                    if (originalWhere.target)\n                        updatedWhere.target = _.map(originalWhere.target, function (e) { return data.SQExprRewriterWithSourceRenames.rewrite(e.accept(_this.exprRewriter), from); });\n                    where.push(updatedWhere);\n                }\n                return where;\n            };\n            return SemanticQueryRewriter;\n        }());\n        data.SemanticQueryRewriter = SemanticQueryRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /**\n         * Represents a semantic query that is:\n         * 1) Round-trippable with a JSON QueryDefinition.\n         * 2) Immutable\n         * 3) Long-lived and does not have strong references to a conceptual model (only names).\n         */\n        var SemanticQuery = (function () {\n            function SemanticQuery(from, where, orderBy, select, groupBy) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(select, 'select');\n                this.fromValue = from;\n                this.whereItems = where;\n                this.orderByItems = orderBy;\n                this.selectItems = select;\n                this.groupByItems = groupBy;\n            }\n            SemanticQuery.create = function () {\n                if (!SemanticQuery.empty)\n                    SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\n                return SemanticQuery.empty;\n            };\n            SemanticQuery.createWithTrimmedFrom = function (from, where, orderBy, select, groupBy) {\n                var unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\n                // Where\n                if (where) {\n                    for (var i = 0, len = where.length; i < len; i++) {\n                        var filter = where[i];\n                        filter.condition.accept(unreferencedKeyFinder);\n                        var filterTarget = filter.target;\n                        if (filterTarget) {\n                            for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                                if (filterTarget[j])\n                                    filterTarget[j].accept(unreferencedKeyFinder);\n                        }\n                    }\n                }\n                // OrderBy\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++)\n                        orderBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                // Select\n                for (var i = 0, len = select.length; i < len; i++)\n                    select[i].expr.accept(unreferencedKeyFinder);\n                // GroupBy\n                if (groupBy) {\n                    for (var i = 0, len = groupBy.length; i < len; i++)\n                        groupBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                var unreferencedKeys = unreferencedKeyFinder.result();\n                for (var i = 0, len = unreferencedKeys.length; i < len; i++)\n                    from.remove(unreferencedKeys[i]);\n                return new SemanticQuery(from, where, orderBy, select, groupBy);\n            };\n            SemanticQuery.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticQuery.prototype.select = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getSelect();\n                return this.setSelect(values);\n            };\n            SemanticQuery.prototype.getSelect = function () {\n                return SemanticQuery.createNamedExpressionArray(this.selectItems);\n            };\n            SemanticQuery.createNamedExpressionArray = function (items) {\n                return ArrayExtensions.extendWithName(_.map(items, function (s) {\n                    return {\n                        name: s.name,\n                        expr: s.expr,\n                    };\n                }));\n            };\n            SemanticQuery.prototype.setSelect = function (values) {\n                var from = this.fromValue.clone();\n                var selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.rewriteExpressionsWithSourceRenames = function (values, from) {\n                var items = [];\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    items.push({\n                        name: value.name,\n                        expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\n                    });\n                }\n                return items;\n            };\n            /** Removes the given expression from the select. */\n            SemanticQuery.prototype.removeSelect = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var originalItems = this.selectItems, selectItems = [];\n                for (var i = 0, len = originalItems.length; i < len; i++) {\n                    var originalExpr = originalItems[i];\n                    if (data.SQExpr.equals(originalExpr.expr, expr))\n                        continue;\n                    selectItems.push(originalExpr);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            /** Removes the given expression from order by. */\n            SemanticQuery.prototype.removeOrderBy = function (expr) {\n                var sorts = this.orderBy();\n                for (var i = sorts.length - 1; i >= 0; i--) {\n                    if (data.SQExpr.equals(sorts[i].expr, expr))\n                        sorts.splice(i, 1);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.selectNameOf = function (expr) {\n                var index = data.SQExprUtils.indexOfExpr(_.map(this.selectItems, function (s) { return s.expr; }), expr);\n                if (index >= 0)\n                    return this.selectItems[index].name;\n            };\n            SemanticQuery.prototype.setSelectAt = function (index, expr) {\n                debug.assertValue(expr, 'expr');\n                if (index >= this.selectItems.length)\n                    return;\n                var select = this.select(), from = this.fromValue.clone(), originalName = select[index].name;\n                select[index] = {\n                    name: originalName,\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\n            };\n            /** Adds a the expression to the select clause. */\n            SemanticQuery.prototype.addSelect = function (expr, exprName) {\n                debug.assertValue(expr, 'expr');\n                var selectItems = this.select(), from = this.fromValue.clone();\n                selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.createNamedExpr = function (currentNames, from, expr, exprName) {\n                return {\n                    name: data.SQExprUtils.uniqueName(currentNames, expr, exprName),\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n            };\n            SemanticQuery.prototype.groupBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getGroupBy();\n                return this.setGroupBy(values);\n            };\n            SemanticQuery.prototype.getGroupBy = function () {\n                return SemanticQuery.createNamedExpressionArray(this.groupByItems);\n            };\n            SemanticQuery.prototype.setGroupBy = function (values) {\n                var from = this.fromValue.clone();\n                var groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.addGroupBy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var groupByItems = this.groupBy(), from = this.fromValue.clone();\n                groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.orderBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getOrderBy();\n                return this.setOrderBy(values);\n            };\n            SemanticQuery.prototype.getOrderBy = function () {\n                var result = [];\n                var orderBy = this.orderByItems;\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++) {\n                        var clause = orderBy[i];\n                        result.push({\n                            expr: clause.expr,\n                            direction: clause.direction,\n                        });\n                    }\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setOrderBy = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedOrderBy = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var clause = values[i];\n                    updatedOrderBy.push({\n                        expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\n                        direction: clause.direction,\n                    });\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.where = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getWhere();\n                return this.setWhere(values);\n            };\n            SemanticQuery.prototype.getWhere = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                if (whereItems) {\n                    for (var i = 0, len = whereItems.length; i < len; i++)\n                        result.push(whereItems[i]);\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setWhere = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedWhere = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var filter = values[i];\n                    var updatedFilter = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\n                    };\n                    var filterTarget = filter.target;\n                    if (filterTarget) {\n                        updatedFilter.target = [];\n                        for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                            if (filterTarget[j]) {\n                                var updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\n                                updatedFilter.target.push(updatedTarget);\n                            }\n                    }\n                    updatedWhere.push(updatedFilter);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.addWhere = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedWhere = this.where(), incomingWhere = filter.where(), from = this.fromValue.clone();\n                for (var i = 0, len = incomingWhere.length; i < len; i++) {\n                    var clause = incomingWhere[i];\n                    var updatedClause = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\n                    };\n                    if (clause.target)\n                        updatedClause.target = _.map(clause.target, function (t) { return SQExprRewriterWithSourceRenames.rewrite(t, from); });\n                    updatedWhere.push(updatedClause);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                var orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\n                var select = rewriter.rewriteSelect(this.selectItems, from);\n                var groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\n                return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\n            };\n            return SemanticQuery;\n        }());\n        data.SemanticQuery = SemanticQuery;\n        /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\n        var SemanticFilter = (function () {\n            function SemanticFilter(from, where) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                this.fromValue = from;\n                this.whereItems = where;\n            }\n            SemanticFilter.fromSQExpr = function (contract) {\n                debug.assertValue(contract, 'contract');\n                var from = new SQFrom();\n                var rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\n                // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\n                //         Thus not setting a target here.\n                var where = [{\n                        condition: rewrittenContract\n                    }];\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.getDefaultValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.defaultValue());\n            };\n            SemanticFilter.getAnyValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.anyValue());\n            };\n            SemanticFilter.getDataViewScopeIdentityComparisonFilters = function (fieldSQExprs, value) {\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assertValue(value, 'value');\n                if (fieldSQExprs instanceof Array) {\n                    var values = Array.apply(null, Array(fieldSQExprs.length)).map(function () { return value; });\n                    return SemanticFilter.fromSQExpr(data.SQExprUtils.getDataViewScopeIdentityComparisonExpr(fieldSQExprs, values));\n                }\n                return SemanticFilter.fromSQExpr(data.SQExprBuilder.equal(fieldSQExprs, value));\n            };\n            SemanticFilter.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticFilter.prototype.conditions = function () {\n                var expressions = [];\n                var where = this.whereItems;\n                for (var i = 0, len = where.length; i < len; i++) {\n                    var filter = where[i];\n                    expressions.push(filter.condition);\n                }\n                return expressions;\n            };\n            SemanticFilter.prototype.where = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                for (var i = 0, len = whereItems.length; i < len; i++)\n                    result.push(whereItems[i]);\n                return result;\n            };\n            SemanticFilter.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new data.SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.rewrite(validator);\n                return validator.errors;\n            };\n            /** Merges a list of SemanticFilters into one. */\n            SemanticFilter.merge = function (filters) {\n                if (_.isEmpty(filters))\n                    return null;\n                if (filters.length === 1)\n                    return filters[0];\n                var firstFilter = filters[0];\n                var from = firstFilter.from(), where = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\n                for (var i = 1, len = filters.length; i < len; i++)\n                    SemanticFilter.applyFilter(filters[i], from, where);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.isDefaultFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isDefaultValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isAnyFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isAnyValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isSameFilter = function (leftFilter, rightFilter) {\n                if (jsCommon.JsonComparer.equals(leftFilter, rightFilter)) {\n                    return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\n                        || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\n                }\n                return false;\n            };\n            SemanticFilter.applyFilter = function (filter, from, where) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                // Where\n                var filterWhereItems = filter.whereItems;\n                for (var i = 0; i < filterWhereItems.length; i++) {\n                    var filterWhereItem = filterWhereItems[i];\n                    var updatedWhereItem = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\n                    };\n                    if (filterWhereItem.target)\n                        updatedWhereItem.target = _.map(filterWhereItem.target, function (e) { return SQExprRewriterWithSourceRenames.rewrite(e, from); });\n                    where.push(updatedWhereItem);\n                }\n            };\n            return SemanticFilter;\n        }());\n        data.SemanticFilter = SemanticFilter;\n        /** Represents a SemanticQuery/SemanticFilter from clause. */\n        var SQFrom = (function () {\n            function SQFrom(items) {\n                this.items = items || {};\n            }\n            SQFrom.prototype.keys = function () {\n                return Object.keys(this.items);\n            };\n            SQFrom.prototype.entity = function (key) {\n                return this.items[key];\n            };\n            SQFrom.prototype.ensureEntity = function (entity, desiredVariableName) {\n                debug.assertValue(entity, 'entity');\n                // 1) Reuse a reference to the entity among the already referenced\n                var keys = this.keys();\n                for (var i_1 = 0, len = keys.length; i_1 < len; i_1++) {\n                    var key = keys[i_1], item = this.items[key];\n                    if (item && entity.entity === item.entity && entity.schema === item.schema)\n                        return { name: key };\n                }\n                // 2) Add a reference to the entity\n                var candidateName = desiredVariableName || this.candidateName(entity.entity), uniqueName = candidateName, i = 2;\n                while (this.items[uniqueName]) {\n                    uniqueName = candidateName + i++;\n                }\n                this.items[uniqueName] = entity;\n                return { name: uniqueName, new: true };\n            };\n            SQFrom.prototype.remove = function (key) {\n                delete this.items[key];\n            };\n            /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\n            SQFrom.prototype.candidateName = function (ref) {\n                debug.assertValue(ref, 'ref');\n                var idx = ref.lastIndexOf('.');\n                if (idx >= 0 && (idx !== ref.length - 1))\n                    ref = ref.substr(idx + 1);\n                return ref.substring(0, 1).toLowerCase();\n            };\n            SQFrom.prototype.clone = function () {\n                // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\n                var cloned = new SQFrom();\n                // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\n                $.extend(cloned.items, this.items);\n                return cloned;\n            };\n            return SQFrom;\n        }());\n        data.SQFrom = SQFrom;\n        var SQExprRewriterWithSourceRenames = (function (_super) {\n            __extends(SQExprRewriterWithSourceRenames, _super);\n            function SQExprRewriterWithSourceRenames(renames) {\n                debug.assertValue(renames, 'renames');\n                _super.call(this);\n                this.renames = renames;\n            }\n            SQExprRewriterWithSourceRenames.prototype.visitEntity = function (expr) {\n                var updatedName = this.renames[expr.entity];\n                if (updatedName)\n                    return new data.SQEntityExpr(expr.schema, expr.entity, updatedName);\n                return _super.prototype.visitEntity.call(this, expr);\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteFilter = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedTargets = undefined;\n                if (filter.target)\n                    updatedTargets = this.rewriteArray(filter.target);\n                var updatedCondition = filter.condition.accept(this);\n                if (filter.condition === updatedCondition && filter.target === updatedTargets)\n                    return filter;\n                var updatedFilter = {\n                    condition: updatedCondition,\n                };\n                if (updatedTargets)\n                    updatedFilter.target = updatedTargets;\n                return updatedFilter;\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteArray = function (exprs) {\n                debug.assertValue(exprs, 'exprs');\n                var updatedExprs;\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i], rewrittenExpr = expr.accept(this);\n                    if (expr !== rewrittenExpr && !updatedExprs)\n                        updatedExprs = ArrayExtensions.take(exprs, i);\n                    if (updatedExprs)\n                        updatedExprs.push(rewrittenExpr);\n                }\n                return updatedExprs || exprs;\n            };\n            SQExprRewriterWithSourceRenames.rewrite = function (expr, from) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(from, 'from');\n                var renames = QuerySourceRenameDetector.run(expr, from);\n                var rewriter = new SQExprRewriterWithSourceRenames(renames);\n                return expr.accept(rewriter);\n            };\n            return SQExprRewriterWithSourceRenames;\n        }(data.SQExprRewriter));\n        data.SQExprRewriterWithSourceRenames = SQExprRewriterWithSourceRenames;\n        /** Responsible for updating a QueryFrom based on SQExpr references. */\n        var QuerySourceRenameDetector = (function (_super) {\n            __extends(QuerySourceRenameDetector, _super);\n            function QuerySourceRenameDetector(from) {\n                debug.assertValue(from, 'from');\n                _super.call(this);\n                this.from = from;\n                this.renames = {};\n            }\n            QuerySourceRenameDetector.run = function (expr, from) {\n                var detector = new QuerySourceRenameDetector(from);\n                expr.accept(detector);\n                return detector.renames;\n            };\n            QuerySourceRenameDetector.prototype.visitEntity = function (expr) {\n                // TODO: Renames must take the schema into account, not just entity set name.\n                var existingEntity = this.from.entity(expr.variable);\n                if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\n                    return;\n                var actualEntity = this.from.ensureEntity({\n                    schema: expr.schema,\n                    entity: expr.entity,\n                }, expr.variable);\n                this.renames[expr.entity] = actualEntity.name;\n            };\n            return QuerySourceRenameDetector;\n        }(data.DefaultSQExprVisitorWithTraversal));\n        /** Visitor for finding unreferenced sources. */\n        var UnreferencedKeyFinder = (function (_super) {\n            __extends(UnreferencedKeyFinder, _super);\n            function UnreferencedKeyFinder(keys) {\n                debug.assertValue(keys, 'keys');\n                _super.call(this);\n                this.keys = keys;\n            }\n            UnreferencedKeyFinder.prototype.visitEntity = function (expr) {\n                var index = this.keys.indexOf(expr.variable);\n                if (index >= 0)\n                    this.keys.splice(index, 1);\n            };\n            UnreferencedKeyFinder.prototype.result = function () {\n                return this.keys;\n            };\n            return UnreferencedKeyFinder;\n        }(data.DefaultSQExprVisitorWithTraversal));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewTransform = powerbi.data.DataViewTransform;\n        var SQExprBuilder = powerbi.data.SQExprBuilder;\n        function createCategoricalDataViewBuilder() {\n            return new CategoricalDataViewBuilder();\n        }\n        data.createCategoricalDataViewBuilder = createCategoricalDataViewBuilder;\n        var CategoricalDataViewBuilder = (function () {\n            function CategoricalDataViewBuilder() {\n                this.categories = [];\n                this.staticMeasureColumns = [];\n                this.dynamicMeasureColumns = [];\n                this.columnIndex = 0;\n            }\n            CategoricalDataViewBuilder.prototype.withCategory = function (options) {\n                var categoryValues = options.values, identityFrom = options.identityFrom, type = options.source.type;\n                var categoryColumn = {\n                    source: options.source,\n                    identityFields: options.identityFrom.fields,\n                    identity: options.identityFrom.identities || [],\n                    values: categoryValues,\n                };\n                if (!options.identityFrom.identities) {\n                    for (var categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\n                        categoryColumn.identity.push(getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\n                    }\n                }\n                if (!this.categories)\n                    this.categories = [];\n                this.categories.push(categoryColumn);\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withCategories = function (categories) {\n                if (_.isEmpty(this.categories))\n                    this.categories = categories;\n                else\n                    Array.prototype.push.apply(this.categories, categories);\n                return this;\n            };\n            /**\n             * Adds static series columns.\n             *\n             * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in\n             * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\n             */\n            CategoricalDataViewBuilder.prototype.withValues = function (options) {\n                debug.assertValue(options, 'options');\n                var columns = options.columns;\n                debug.assertValue(columns, 'columns');\n                for (var _i = 0, columns_8 = columns; _i < columns_8.length; _i++) {\n                    var column = columns_8[_i];\n                    this.staticMeasureColumns.push(column.source);\n                }\n                this.staticSeriesValues = columns;\n                return this;\n            };\n            /**\n             * Adds dynamic series columns.\n             *\n             * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in\n             * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\n             */\n            CategoricalDataViewBuilder.prototype.withGroupedValues = function (options) {\n                debug.assertValue(options, 'options');\n                var groupColumn = options.groupColumn;\n                debug.assertValue(groupColumn, 'groupColumn');\n                this.dynamicSeriesMetadata = {\n                    column: groupColumn.source,\n                    identityFrom: groupColumn.identityFrom,\n                    values: groupColumn.values,\n                };\n                var valueColumns = options.valueColumns;\n                for (var _i = 0, valueColumns_1 = valueColumns; _i < valueColumns_1.length; _i++) {\n                    var valueColumn = valueColumns_1[_i];\n                    this.dynamicMeasureColumns.push(valueColumn.source);\n                }\n                this.dynamicSeriesValues = options.data;\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.fillData = function (dataViewValues) {\n                var categoryColumn = _.first(this.categories);\n                var categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 0;\n                if (this.hasDynamicSeries()) {\n                    for (var seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\n                        var seriesMeasures = this.dynamicSeriesValues[seriesIndex];\n                        debug.assert(seriesMeasures.length === this.dynamicMeasureColumns.length, 'seriesMeasures.length === this.dynamicMeasureColumns.length');\n                        for (var measureIndex = 0, measuresLen = this.dynamicMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                            var groupIndex = seriesIndex * measuresLen + measureIndex;\n                            applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\n                        }\n                    }\n                }\n                if (this.hasStaticSeries()) {\n                    // Note: when the target categorical has both dynamic and static series, append static measures at the end of the values array.\n                    var staticColumnsStartingIndex = this.hasDynamicSeries() ? (this.dynamicSeriesValues.length * this.dynamicMeasureColumns.length) : 0;\n                    for (var measureIndex = 0, measuresLen = this.staticMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                        applySeriesData(dataViewValues[staticColumnsStartingIndex + measureIndex], this.staticSeriesValues[measureIndex], categoryLength);\n                    }\n                }\n            };\n            /**\n             * Returns the DataView with metadata and DataViewCategorical.\n             * Returns undefined if the combination of parameters is illegal, such as having both dynamic series and static series when building a visual DataView.\n             */\n            CategoricalDataViewBuilder.prototype.build = function () {\n                var metadataColumns = [];\n                var categorical = {};\n                var categoryMetadata = this.categories;\n                var dynamicSeriesMetadata = this.dynamicSeriesMetadata;\n                // --- Build metadata columns and value groups ---\n                for (var _i = 0, categoryMetadata_1 = categoryMetadata; _i < categoryMetadata_1.length; _i++) {\n                    var columnMetadata = categoryMetadata_1[_i];\n                    pushIfNotExists(metadataColumns, columnMetadata.source);\n                }\n                if (this.hasDynamicSeries()) {\n                    // Dynamic series, or Dyanmic & Static series.\n                    pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\n                    categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\n                    // For each series value we will make one column per measure\n                    var seriesValues = dynamicSeriesMetadata.values;\n                    for (var seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\n                        var seriesValue = seriesValues[seriesIndex];\n                        var seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\n                        for (var _a = 0, _b = this.dynamicMeasureColumns; _a < _b.length; _a++) {\n                            var measure = _b[_a];\n                            var column = _.clone(measure);\n                            column.groupName = seriesValue;\n                            pushIfNotExists(metadataColumns, column);\n                            categorical.values.push({\n                                source: column,\n                                values: [],\n                                identity: seriesIdentity,\n                            });\n                        }\n                    }\n                    if (this.hasStaticSeries()) {\n                        // IMPORTANT: In the Dyanmic & Static series case, the groups array shall not include any static group. This is to match the behavior of production code that creates query DataView objects.\n                        // Get the current return value of grouped() before adding static measure columns, an use that as the return value of this categorical.\n                        // Otherwise, the default behavior of DataViewValueColumns.grouped() from DataViewTransform.createValueColumns() is to create series groups from all measure columns.\n                        var dynamicSeriesGroups_1 = categorical.values.grouped();\n                        categorical.values.grouped = function () { return dynamicSeriesGroups_1; };\n                        this.appendStaticMeasureColumns(metadataColumns, categorical.values);\n                    }\n                }\n                else {\n                    // Static series only / no series\n                    categorical.values = DataViewTransform.createValueColumns();\n                    this.appendStaticMeasureColumns(metadataColumns, categorical.values);\n                }\n                var categories = this.categories;\n                if (!_.isEmpty(categories))\n                    categorical.categories = categories;\n                // --- Fill in data point values ---\n                this.fillData(categorical.values);\n                var dataView = {\n                    metadata: {\n                        columns: metadataColumns,\n                    },\n                    categorical: categorical,\n                };\n                if (this.isLegalDataView(dataView)) {\n                    return dataView;\n                }\n            };\n            CategoricalDataViewBuilder.prototype.appendStaticMeasureColumns = function (metadataColumns, valueColumns) {\n                debug.assertValue(metadataColumns, 'metadataColumns');\n                debug.assertValue(valueColumns, 'valueColumns');\n                if (!_.isEmpty(this.staticMeasureColumns)) {\n                    for (var _i = 0, _a = this.staticMeasureColumns; _i < _a.length; _i++) {\n                        var column = _a[_i];\n                        pushIfNotExists(metadataColumns, column);\n                        valueColumns.push({\n                            source: column,\n                            values: [],\n                        });\n                    }\n                }\n            };\n            CategoricalDataViewBuilder.prototype.isLegalDataView = function (dataView) {\n                if (this.hasDynamicSeries() && this.hasStaticSeries() && CategoricalDataViewBuilder.isVisualDataView(dataView.metadata.columns)) {\n                    // It is illegal to have both dynamic series and static series in a visual DataViewCategorical,\n                    // because the DataViewValueColumns interface today cannot express that 100% (see its 'source' property and return value of its 'grouped()' function).\n                    return false;\n                }\n                return true;\n            };\n            /**\n             * This function infers that if any metadata column has 'queryName',\n             * then the user of this builder is building a visual DataView (as opposed to query DataView).\n             *\n             * @param metadataColumns The complete collection of metadata columns in the categorical.\n             */\n            CategoricalDataViewBuilder.isVisualDataView = function (metadataColumns) {\n                return !_.isEmpty(metadataColumns) &&\n                    _.any(metadataColumns, function (metadataColumn) { return !!metadataColumn.queryName; });\n            };\n            CategoricalDataViewBuilder.prototype.hasDynamicSeries = function () {\n                return !!this.dynamicSeriesMetadata; // In Map visual scenarios, you can have dynamic series without measure columns\n            };\n            CategoricalDataViewBuilder.prototype.hasStaticSeries = function () {\n                return !!this.staticSeriesValues;\n            };\n            return CategoricalDataViewBuilder;\n        }());\n        function getScopeIdentity(source, index, value, valueType) {\n            var identities = source.identities;\n            if (identities) {\n                return identities[index];\n            }\n            debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\n            return data.createDataViewScopeIdentity(SQExprBuilder.equal(source.fields[0], SQExprBuilder.typedConstant(value, valueType)));\n        }\n        function pushIfNotExists(items, itemToAdd) {\n            if (_.contains(items, itemToAdd))\n                return;\n            items.push(itemToAdd);\n        }\n        function applySeriesData(target, source, categoryLength) {\n            debug.assertValue(target, 'target');\n            debug.assertValue(source, 'source');\n            debug.assertValue(categoryLength, 'categoryLength');\n            var values = source.values;\n            debug.assert(categoryLength === values.length || categoryLength === 0, 'categoryLength === values.length || categoryLength === 0');\n            target.values = values;\n            var highlights = source.highlights;\n            if (highlights) {\n                debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\n                target.highlights = highlights;\n            }\n            var aggregates;\n            if (source.minLocal !== undefined) {\n                if (!aggregates)\n                    aggregates = {};\n                aggregates.minLocal = source.minLocal;\n            }\n            if (source.maxLocal !== undefined) {\n                if (!aggregates)\n                    aggregates = {};\n                aggregates.maxLocal = source.maxLocal;\n            }\n            if (aggregates) {\n                target.source.aggregates = aggregates;\n                _.extend(target, aggregates);\n            }\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExpr = powerbi.data.SQExpr;\n        function createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n            return new StaticEvalContext(colorAllocatorCache || data.createColorAllocatorCache(), dataView || { metadata: { columns: [] } }, selectTransforms);\n        }\n        data.createStaticEvalContext = createStaticEvalContext;\n        /**\n         * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\n         * are supported.\n         */\n        var StaticEvalContext = (function () {\n            function StaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorCache = colorAllocatorCache;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            StaticEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorCache.get(expr);\n            };\n            StaticEvalContext.prototype.getExprValue = function (expr) {\n                var dataView = this.dataView, selectTransforms = this.selectTransforms;\n                if (!dataView || !selectTransforms)\n                    return;\n                if (SQExpr.isAggregation(expr)) {\n                    var columnAggregate = findAggregateValue(expr, selectTransforms, dataView.metadata.columns);\n                    if (columnAggregate !== undefined) {\n                        return columnAggregate;\n                    }\n                }\n                if (dataView.table)\n                    return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\n            };\n            StaticEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            return StaticEvalContext;\n        }());\n        function getExprValueFromTable(expr, selectTransforms, table, rowIdx) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            debug.assertValue(table, 'table');\n            debug.assertValue(rowIdx, 'rowIdx');\n            var rows = table.rows;\n            if (_.isEmpty(rows) || rows.length <= rowIdx)\n                return;\n            var cols = table.columns;\n            var selectIdx = findSelectIndex(expr, selectTransforms);\n            if (selectIdx < 0)\n                return;\n            for (var colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\n                if (selectIdx !== cols[colIdx].index)\n                    continue;\n                return rows[rowIdx][colIdx];\n            }\n        }\n        data.getExprValueFromTable = getExprValueFromTable;\n        function findAggregateValue(expr, selectTransforms, columns) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            debug.assertValue(columns, 'columns');\n            var selectIdx = findSelectIndex(expr.arg, selectTransforms);\n            if (selectIdx < 0)\n                return;\n            for (var colIdx = 0, colLen = columns.length; colIdx < colLen; colIdx++) {\n                var column = columns[colIdx], columnAggr = column.aggregates;\n                if (selectIdx !== column.index || !columnAggr)\n                    continue;\n                var aggregateValue = findAggregates(columnAggr, expr.func);\n                if (aggregateValue !== undefined)\n                    return aggregateValue;\n            }\n        }\n        function findSelectIndex(expr, selectTransforms) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            var queryName;\n            if (SQExpr.isSelectRef(expr))\n                queryName = expr.expressionName;\n            for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                var selectTransform = selectTransforms[selectIdx];\n                if (!selectTransform || !selectTransform.queryName)\n                    continue;\n                if (queryName) {\n                    if (selectTransform.queryName === queryName)\n                        return selectIdx;\n                }\n                else {\n                    if (SQExpr.equals(selectTransform.expr, expr))\n                        return selectIdx;\n                }\n            }\n            return -1;\n        }\n        function findAggregates(aggregates, func) {\n            debug.assertValue(aggregates, 'aggregates');\n            debug.assertValue(func, 'func');\n            switch (func) {\n                case data.QueryAggregateFunction.Min:\n                    return getOptional(aggregates.min, aggregates.minLocal);\n                case data.QueryAggregateFunction.Max:\n                    return getOptional(aggregates.max, aggregates.maxLocal);\n            }\n        }\n        function getOptional(value1, value2) {\n            debug.assertAnyValue(value1, 'value1');\n            debug.assertAnyValue(value2, 'value2');\n            if (value1 !== undefined)\n                return value1;\n            return value2;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createMatrixEvalContext(colorAllocatorProvider, dataViewMatrix) {\n            // NOTE: Matrix context-sensitive evaluation is not yet implemented.\n            return data.createStaticEvalContext(colorAllocatorProvider);\n        }\n        data.createMatrixEvalContext = createMatrixEvalContext;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi_1) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var Formatting = jsCommon.Formatting;\n    var RegExpExtensions = jsCommon.RegExpExtensions;\n    /** Formatting Encoder */\n    var FormattingEncoder;\n    (function (FormattingEncoder) {\n        function preserveEscaped(format, specialChars) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = \"\\\\\" + specialChars[i];\n                var newText = String.fromCharCode(0xE000 + i);\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveEscaped = preserveEscaped;\n        function restoreEscaped(format, specialChars) {\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = String.fromCharCode(0xE000 + i);\n                var newText = specialChars[i];\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\n        }\n        FormattingEncoder.restoreEscaped = restoreEscaped;\n        function preserveLiterals(format, literals) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            for (var i = 0;; i++) {\n                var fromIndex = format.indexOf(\"'\");\n                if (fromIndex < 0) {\n                    break;\n                }\n                var toIndex = format.indexOf(\"'\", fromIndex + 1);\n                if (toIndex < 0) {\n                    break;\n                }\n                var literal = format.substring(fromIndex, toIndex + 1);\n                literals.push(literal.substring(1, toIndex - fromIndex));\n                var token = String.fromCharCode(0xE100 + i);\n                format = format.replace(literal, token);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveLiterals = preserveLiterals;\n        function restoreLiterals(format, literals) {\n            var count = literals.length;\n            for (var i = 0; i < count; i++) {\n                var token = String.fromCharCode(0xE100 + i);\n                var literal = literals[i];\n                format = format.replace(token, literal);\n            }\n            return format;\n        }\n        FormattingEncoder.restoreLiterals = restoreLiterals;\n    })(FormattingEncoder || (FormattingEncoder = {}));\n    var IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\n    var ZeroPlaceholder = '0';\n    var DigitPlaceholder = '#';\n    var ExponentialFormatChar = 'E';\n    var NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\n    var NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\n    /** Formatting Service */\n    var FormattingService = (function () {\n        function FormattingService() {\n        }\n        FormattingService.prototype.formatValue = function (value, format, culture) {\n            // Handle special cases\n            if (value === undefined || value === null) {\n                return '';\n            }\n            var gculture = this.getCulture(culture);\n            if (DateTimeFormat.canFormat(value)) {\n                // Dates\n                return DateTimeFormat.format(value, format, gculture);\n            }\n            else if (NumberFormat.canFormat(value)) {\n                // Numbers\n                return NumberFormat.format(value, format, gculture);\n            }\n            else {\n                // Other data types - return as string\n                return value.toString();\n            }\n        };\n        FormattingService.prototype.format = function (formatWithIndexedTokens, args, culture) {\n            var _this = this;\n            if (!formatWithIndexedTokens) {\n                return \"\";\n            }\n            var result = formatWithIndexedTokens.replace(IndexedTokensRegex, function (match, left, right, argToken) {\n                if (left) {\n                    return \"{\";\n                }\n                else if (right) {\n                    return \"}\";\n                }\n                else {\n                    var parts = argToken.split(\":\");\n                    var argIndex = parseInt(parts[0], 10);\n                    var argFormat = parts[1];\n                    return _this.formatValue(args[argIndex], argFormat, culture);\n                }\n            });\n            return result;\n        };\n        FormattingService.prototype.isStandardNumberFormat = function (format) {\n            return NumberFormat.isStandardFormat(format);\n        };\n        FormattingService.prototype.formatNumberWithCustomOverride = function (value, format, nonScientificOverrideFormat, culture) {\n            var gculture = this.getCulture(culture);\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\n        };\n        FormattingService.prototype.dateFormatString = function (unit) {\n            if (!this._dateTimeScaleFormatInfo)\n                this.initialize();\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\n        };\n        /**\n         * Sets the current localization culture\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         */\n        FormattingService.prototype.setCurrentCulture = function (cultureSelector) {\n            if (this._currentCultureSelector !== cultureSelector) {\n                this._currentCulture = this.getCulture(cultureSelector);\n                this._currentCultureSelector = cultureSelector;\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\n            }\n        };\n        /**\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         * Exposing this function for testability of unsupported cultures\n         */\n        FormattingService.prototype.getCulture = function (cultureSelector) {\n            if (cultureSelector == null) {\n                if (this._currentCulture == null) {\n                    this.initialize();\n                }\n                return this._currentCulture;\n            }\n            else {\n                var culture = Globalize.findClosestCulture(cultureSelector);\n                if (!culture)\n                    culture = Globalize.culture(\"en-US\");\n                return culture;\n            }\n        };\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\n        FormattingService.prototype.initialize = function () {\n            var cultureName = this.getCurrentCulture();\n            this.setCurrentCulture(cultureName);\n            var calendarName = this.getUrlParam(\"calendar\");\n            if (calendarName) {\n                var culture = this._currentCulture;\n                var c = culture.calendars[calendarName];\n                if (c) {\n                    culture.calendar = c;\n                }\n            }\n        };\n        /**\n         *  Exposing this function for testability\n         */\n        FormattingService.prototype.getCurrentCulture = function () {\n            var urlParam = this.getUrlParam(\"language\");\n            if (urlParam) {\n                return urlParam;\n            }\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\n                // Get cultureInfo set in powerbi\n                return powerbi.common.cultureInfo;\n            }\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\n        };\n        /**\n         *  Exposing this function for testability\n         *  @param name: queryString name\n         */\n        FormattingService.prototype.getUrlParam = function (name) {\n            var param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\n            return param ? param[1] : undefined;\n        };\n        return FormattingService;\n    }());\n    /**\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for dates.\n     */\n    var DateTimeFormat;\n    (function (DateTimeFormat) {\n        var _currentCachedFormat;\n        var _currentCachedProcessedFormat;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = value instanceof Date;\n            return result;\n        }\n        DateTimeFormat.canFormat = canFormat;\n        /** Formats the date using provided format and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            var isStandard = format.length === 1;\n            try {\n                if (isStandard) {\n                    return formatDateStandard(value, format, culture);\n                }\n                else {\n                    return formatDateCustom(value, format, culture);\n                }\n            }\n            catch (e) {\n                return formatDateStandard(value, \"G\", culture);\n            }\n        }\n        DateTimeFormat.format = format;\n        /** Formats the date using standard format expression */\n        function formatDateStandard(value, format, culture) {\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\n            var patterns = culture.calendar.patterns;\n            // Extend supported set of patterns\n            ensurePatterns(culture.calendar);\n            // Handle extended set of formats\n            var output = Formatting.findDateFormat(value, format, culture.name);\n            if (output.format.length === 1)\n                format = patterns[output.format];\n            else\n                format = output.format;\n            //need to revisit when globalization is enabled\n            culture = Globalize.culture(\"en-US\");\n            return Globalize.format(output.value, format, culture);\n        }\n        /** Formats the date using custom format expression */\n        function formatDateCustom(value, format, culture) {\n            var result;\n            var literals = [];\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            format = FormattingEncoder.preserveLiterals(format, literals);\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            if (format.indexOf(\"F\") > -1) {\n                // F is not supported so we need to replace the F with f based on the milliseconds\n                // Replace all sequences of F longer than 3 with \"FFF\"\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\n                // Based on milliseconds update the format to use fff\n                var milliseconds = value.getMilliseconds();\n                if (milliseconds % 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\n                if ((milliseconds % 100) / 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\n                if ((milliseconds % 1000) / 100 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\n                }\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\n                if (format === \"\" || format === \"%\")\n                    return \"\";\n            }\n            format = processCustomDateTimeFormat(format);\n            result = Globalize.format(value, format, culture);\n            result = localize(result, culture.calendar);\n            result = FormattingEncoder.restoreLiterals(result, literals);\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            return result;\n        }\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\n        function processCustomDateTimeFormat(format) {\n            if (format === _currentCachedFormat) {\n                return _currentCachedProcessedFormat;\n            }\n            _currentCachedFormat = format;\n            format = Formatting.fixDateTimeFormat(format);\n            _currentCachedProcessedFormat = format;\n            return format;\n        }\n        /** Localizes the time separator symbol */\n        function localize(value, dictionary) {\n            var timeSeparator = dictionary[\":\"];\n            if (timeSeparator === \":\") {\n                return value;\n            }\n            var result = \"\";\n            var count = value.length;\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \":\":\n                        result += timeSeparator;\n                        break;\n                    default:\n                        result += char;\n                        break;\n                }\n            }\n            return result;\n        }\n        function ensurePatterns(calendar) {\n            var patterns = calendar.patterns;\n            if (patterns[\"g\"] === undefined) {\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, short time\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, long time\n            }\n        }\n    })(DateTimeFormat || (DateTimeFormat = {}));\n    /**\n     * NumberFormat module contains the static methods for formatting the numbers.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for numeric types including custom formats.\n     */\n    var NumberFormat;\n    (function (NumberFormat) {\n        var NonScientificFormatRegex = /^\\{.+\\}.*/;\n        var NumericalPlaceHolderRegex = /\\{.+\\}/;\n        var ScientificFormatRegex = /e[+-]*[0#]+/i;\n        var StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\n        var TrailingZerosRegex = /0+$/;\n        var DecimalFormatRegex = /\\.([0#]*)/g;\n        var NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\n        var LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\n        var DecimalFormatCharacter = '.';\n        NumberFormat.NumberFormatComponentsDelimeter = ';';\n        function getNonScientificFormatWithPrecision(baseFormat, numericFormat) {\n            if (!numericFormat || baseFormat === undefined)\n                return baseFormat;\n            var newFormat = \"{0:\" + numericFormat + \"}\";\n            return baseFormat.replace(\"{0}\", newFormat);\n        }\n        function getNumericFormat(value, baseFormat) {\n            if (baseFormat == null)\n                return baseFormat;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                if (value > 0)\n                    return getNumericFormatFromComponent(value, positive);\n                else if (value === 0)\n                    return getNumericFormatFromComponent(value, zero);\n                return getNumericFormatFromComponent(value, negative);\n            }\n            return getNumericFormatFromComponent(value, baseFormat);\n        }\n        NumberFormat.getNumericFormat = getNumericFormat;\n        function getNumericFormatFromComponent(value, format) {\n            var match = RegExpExtensions.run(NumericFormatRegex, format);\n            if (match)\n                return match[0];\n            return format;\n        }\n        function addDecimalsToFormat(baseFormat, decimals, trailingZeros) {\n            if (decimals == null)\n                return baseFormat;\n            // Default format string\n            if (baseFormat == null)\n                baseFormat = ZeroPlaceholder;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                var formats = [positive, negative, zero];\n                for (var i = 0; i < formats.length; i++) {\n                    // Update format in formats array\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\n                }\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\n            }\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\n        }\n        NumberFormat.addDecimalsToFormat = addDecimalsToFormat;\n        function addDecimalsToFormatComponent(format, decimals, trailingZeros) {\n            decimals = Math.abs(decimals);\n            if (decimals >= 0) {\n                var placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\n                var decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\n                var match = RegExpExtensions.run(DecimalFormatRegex, format);\n                if (match) {\n                    var beforeDecimal = format.substr(0, match.index);\n                    var formatDecimal = format.substr(match.index + 1, match[1].length);\n                    var afterDecimal = format.substr(match.index + match[0].length);\n                    if (trailingZeros)\n                        // Use explicit decimals argument as placeholders\n                        formatDecimal = decimalPlaceholders;\n                    else {\n                        var decimalChange = decimalPlaceholders.length - formatDecimal.length;\n                        if (decimalChange > 0)\n                            // Append decimalPlaceholders to existing decimal portion of format string\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\n                        else if (decimalChange < 0)\n                            // Remove decimals from formatDecimal\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\n                    }\n                    if (formatDecimal.length > 0)\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\n                    return beforeDecimal + formatDecimal + afterDecimal;\n                }\n                else if (decimalPlaceholders.length > 0)\n                    // Replace last numeric placeholder with decimal portion\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\n            }\n            return format;\n        }\n        function hasFormatComponents(format) {\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\n        }\n        NumberFormat.hasFormatComponents = hasFormatComponents;\n        function getComponents(format) {\n            var signFormat = {\n                hasNegative: false,\n                positive: format,\n                negative: format,\n                zero: format,\n            };\n            var signSpecificFormats = format.split(NumberFormat.NumberFormatComponentsDelimeter);\n            var formatCount = signSpecificFormats.length;\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\n            if (formatCount > 1) {\n                signFormat.hasNegative = true;\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\n                signFormat.negative = signSpecificFormats[1];\n                if (formatCount > 2)\n                    signFormat.zero = signSpecificFormats[2];\n            }\n            return signFormat;\n        }\n        NumberFormat.getComponents = getComponents;\n        var _lastCustomFormatMeta;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = typeof (value) === \"number\";\n            return result;\n        }\n        NumberFormat.canFormat = canFormat;\n        function isStandardFormat(format) {\n            debug.assertValue(format, 'format');\n            return StandardFormatRegex.test(format);\n        }\n        NumberFormat.isStandardFormat = isStandardFormat;\n        /** Formats the number using specified format expression and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            try {\n                if (isStandardFormat(format))\n                    return formatNumberStandard(value, format, culture);\n                return formatNumberCustom(value, format, culture);\n            }\n            catch (e) {\n                return Globalize.format(value, undefined, culture);\n            }\n        }\n        NumberFormat.format = format;\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\n        function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {\n            debug.assertValue(value, 'value');\n            debug.assertValue(format, 'format');\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\n            debug.assertValue(culture, 'culture');\n            debug.assert(!isStandardFormat(format), 'Standard format');\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\n        }\n        NumberFormat.formatWithCustomOverride = formatWithCustomOverride;\n        /** Formats the number using standard format expression */\n        function formatNumberStandard(value, format, culture) {\n            var result;\n            var precision = (format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\n            var numberFormatInfo = culture.numberFormat;\n            var formatChar = format.charAt(0);\n            switch (formatChar) {\n                case \"e\":\n                case \"E\":\n                    if (precision === undefined) {\n                        precision = 6;\n                    }\n                    var mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\n                    result = formatNumberCustom(value, format, culture);\n                    break;\n                case \"f\":\n                case \"F\":\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"g\":\n                case \"G\":\n                    var abs = Math.abs(value);\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\n                    }\n                    else {\n                        // Otherwise use exponential\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\n                        result = result.replace(\"e\", \"E\");\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"r\":\n                case \"R\":\n                    result = value.toString();\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"x\":\n                case \"X\":\n                    result = value.toString(16);\n                    if (formatChar === \"X\") {\n                        result = result.toUpperCase();\n                    }\n                    if (precision !== undefined) {\n                        var actualPrecision = result.length;\n                        var isNegative = value < 0;\n                        if (isNegative) {\n                            actualPrecision--;\n                        }\n                        var paddingZerosCount = precision - actualPrecision;\n                        var paddingZeros = undefined;\n                        if (paddingZerosCount > 0) {\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\n                        }\n                        if (isNegative) {\n                            result = \"-\" + paddingZeros + result.substr(1);\n                        }\n                        else {\n                            result = paddingZeros + result;\n                        }\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                default:\n                    result = Globalize.format(value, format, culture);\n            }\n            return result;\n        }\n        /** Formats the number using custom format expression */\n        function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {\n            var result;\n            var numberFormatInfo = culture.numberFormat;\n            if (isFinite(value)) {\n                // Split format by positive[;negative;zero] pattern\n                var formatComponents = getComponents(format);\n                // Pick a format based on the sign of value\n                if (value > 0) {\n                    format = formatComponents.positive;\n                }\n                else if (value === 0) {\n                    format = formatComponents.zero;\n                }\n                else {\n                    format = formatComponents.negative;\n                }\n                // Normalize value if we have an explicit negative format\n                if (formatComponents.hasNegative)\n                    value = Math.abs(value);\n                // Get format metadata\n                var formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\n                // Preserve literals and escaped chars\n                if (formatMeta.hasEscapes) {\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%\");\n                }\n                var literals = [];\n                if (formatMeta.hasQuotes) {\n                    format = FormattingEncoder.preserveLiterals(format, literals);\n                }\n                // Scientific format\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\n                    var scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\n                    if (scientificMatch) {\n                        // Case 2.1. Scientific custom format\n                        var formatM = format.substr(0, scientificMatch.index);\n                        var formatE = format.substr(scientificMatch.index + 2); // E(+|-)\n                        var precision = getCustomFormatPrecision(formatM, formatMeta);\n                        var scale = getCustomFormatScale(formatM, formatMeta);\n                        if (scale !== 1) {\n                            value = value * scale;\n                        }\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        var s = value.toExponential(precision);\n                        var indexOfE = s.indexOf(\"e\");\n                        var mantissa = s.substr(0, indexOfE);\n                        var exp = s.substr(indexOfE + 1);\n                        var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\n                        var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\n                            resultE = resultE.substr(1);\n                        }\n                        var e = scientificMatch[0].charAt(0);\n                        result = resultM + e + resultE;\n                    }\n                }\n                // Non scientific format\n                if (result === undefined) {\n                    var valueFormatted = void 0;\n                    var isValueGlobalized = false;\n                    var precision = getCustomFormatPrecision(format, formatMeta);\n                    var scale = getCustomFormatScale(format, formatMeta);\n                    if (scale !== 1)\n                        value = value * scale;\n                    // Rounding\n                    value = parseFloat(toNonScientific(value, precision));\n                    if (nonScientificOverrideFormat) {\n                        // Get numeric format from format string\n                        var numericFormat = NumberFormat.getNumericFormat(value, format);\n                        // Add separators and decimalFormat to nonScientificFormat\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\n                        // Format the value\n                        valueFormatted = powerbi_1.formattingService.format(nonScientificOverrideFormat, [value], culture.name);\n                        isValueGlobalized = true;\n                    }\n                    else\n                        valueFormatted = toNonScientific(value, precision);\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\n                }\n                if (formatMeta.hasQuotes) {\n                    result = FormattingEncoder.restoreLiterals(result, literals);\n                }\n                if (formatMeta.hasEscapes) {\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%\");\n                }\n                _lastCustomFormatMeta = formatMeta;\n            }\n            else {\n                return Globalize.format(value, undefined);\n            }\n            return result;\n        }\n        /** Returns string with the fixed point respresentation of the number */\n        function toNonScientific(value, precision) {\n            var result = \"\";\n            var precisionZeros = 0;\n            // Double precision numbers support actual 15-16 decimal digits of precision.\n            if (precision > 16) {\n                precisionZeros = precision - 16;\n                precision = 16;\n            }\n            var digitsBeforeDecimalPoint = powerbi_1.Double.log10(Math.abs(value));\n            if (digitsBeforeDecimalPoint < 16) {\n                if (digitsBeforeDecimalPoint > 0) {\n                    var maxPrecision = 16 - digitsBeforeDecimalPoint;\n                    if (precision > maxPrecision) {\n                        precisionZeros += precision - maxPrecision;\n                        precision = maxPrecision;\n                    }\n                }\n                result = value.toFixed(precision);\n            }\n            else if (digitsBeforeDecimalPoint === 16) {\n                result = value.toFixed(0);\n                precisionZeros += precision;\n                if (precisionZeros > 0) {\n                    result += \".\";\n                }\n            }\n            else {\n                // Different browsers have different implementations of the toFixed().\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\n                // So we need to check for range and convert the to exponential with the max precision.\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\n                // Assert that value is a number and fall back on returning value if it is not\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                if (typeof (value) !== \"number\")\n                    return String(value);\n                result = value.toExponential(15);\n                var indexOfE = result.indexOf(\"e\");\n                if (indexOfE > 0) {\n                    var indexOfDot = result.indexOf(\".\");\n                    var mantissa = result.substr(0, indexOfE);\n                    var exp = result.substr(indexOfE + 1);\n                    var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\n                    if (precision > 0) {\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\n                    }\n                }\n            }\n            if (precisionZeros > 0) {\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\n            }\n            return result;\n        }\n        /**\n         * Returns the formatMetadata of the format\n         * When calculating precision and scale, if format string of\n         * positive[;negative;zero] => positive format will be used\n         * @param (required) format - format string\n         * @param (optional) calculatePrecision - calculate precision of positive format\n         * @param (optional) calculateScale - calculate scale of positive format\n         */\n        function getCustomFormatMetadata(format, calculatePrecision, calculateScale) {\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\n                return _lastCustomFormatMeta;\n            }\n            var result = {\n                format: format,\n                hasEscapes: false,\n                hasQuotes: false,\n                hasE: false,\n                hasCommas: false,\n                hasDots: false,\n                hasPercent: false,\n                hasPermile: false,\n                precision: undefined,\n                scale: undefined,\n            };\n            for (var i = 0, length_1 = format.length; i < length_1; i++) {\n                var c = format.charAt(i);\n                switch (c) {\n                    case \"\\\\\":\n                        result.hasEscapes = true;\n                        break;\n                    case \"'\":\n                    case \"\\\"\":\n                        result.hasQuotes = true;\n                        break;\n                    case \"e\":\n                    case \"E\":\n                        result.hasE = true;\n                        break;\n                    case \",\":\n                        result.hasCommas = true;\n                        break;\n                    case \".\":\n                        result.hasDots = true;\n                        break;\n                    case \"%\":\n                        result.hasPercent = true;\n                        break;\n                    case \"\":\n                        result.hasPermile = true;\n                        break;\n                }\n            }\n            // Use positive format for calculating these values\n            var formatComponents = getComponents(format);\n            if (calculatePrecision)\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\n            if (calculateScale)\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\n            return result;\n        }\n        NumberFormat.getCustomFormatMetadata = getCustomFormatMetadata;\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\n        function getCustomFormatPrecision(format, formatMeta) {\n            if (formatMeta.precision > -1) {\n                return formatMeta.precision;\n            }\n            var result = 0;\n            if (formatMeta.hasDots) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex > -1) {\n                    var count = format.length;\n                    for (var i = dotIndex; i < count; i++) {\n                        var char = format.charAt(i);\n                        if (char.match(NumericPlaceholderRegex))\n                            result++;\n                        // 0.00E+0 :: Break before counting 0 in\n                        // exponential portion of format string\n                        if (char === ExponentialFormatChar)\n                            break;\n                    }\n                    result = Math.min(19, result);\n                }\n            }\n            formatMeta.precision = result;\n            return result;\n        }\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\n        function getCustomFormatScale(format, formatMeta) {\n            if (formatMeta.scale > -1) {\n                return formatMeta.scale;\n            }\n            var result = 1;\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\n                result = result * 100;\n            }\n            if (formatMeta.hasPermile && format.indexOf(\"\") > -1) {\n                result = result * 1000;\n            }\n            if (formatMeta.hasCommas) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex === -1) {\n                    dotIndex = format.length;\n                }\n                for (var i = dotIndex - 1; i > -1; i--) {\n                    var char = format.charAt(i);\n                    if (char === \",\") {\n                        result = result / 1000;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            formatMeta.scale = result;\n            return result;\n        }\n        function fuseNumberWithCustomFormat(value, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized) {\n            var suppressModifyValue = !!nonScientificOverrideFormat;\n            var formatParts = format.split(\".\", 2);\n            if (formatParts.length === 2) {\n                var wholeFormat = formatParts[0];\n                var fractionFormat = formatParts[1];\n                var displayUnit = \"\";\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\n                if (nonScientificOverrideFormat) {\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\n                    value = value.replace(displayUnit, \"\");\n                }\n                var globalizedDecimalSeparator = numberFormatInfo[\".\"];\n                var decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\n                var valueParts = value.split(decimalSeparator, 2);\n                var wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\n                var fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\n                var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\n                var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\n                    return wholeFormattedValue + fractionFormattedValue.value;\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\n            }\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\n        }\n        function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {\n            var groupSymbolIndex = format.indexOf(\",\");\n            var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\n            var groupDigitCount = 0;\n            var groupIndex = 0;\n            var groupSizes = numberFormatInfo.groupSizes || [3];\n            var groupSize = groupSizes[0];\n            var groupSeparator = numberFormatInfo[\",\"];\n            var sign = \"\";\n            var firstChar = value.charAt(0);\n            if (firstChar === \"+\" || firstChar === \"-\") {\n                sign = numberFormatInfo[firstChar];\n                value = value.substr(1);\n            }\n            var isZero = value === \"0\";\n            var result = \"\";\n            var leftBuffer = \"\";\n            var vi = value.length - 1;\n            var fmtOnly = true;\n            // Iterate through format chars and replace 0 and # with the digits from the value string\n            for (var fi = format.length - 1; fi > -1; fi--) {\n                var formatChar = format.charAt(fi);\n                switch (formatChar) {\n                    case ZeroPlaceholder:\n                    case DigitPlaceholder:\n                        fmtOnly = false;\n                        if (leftBuffer !== \"\") {\n                            result = leftBuffer + result;\n                            leftBuffer = \"\";\n                        }\n                        if (!suppressModifyValue) {\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\n                                if (enableGroups) {\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\n                                    if (groupDigitCount === groupSize) {\n                                        result = groupSeparator + result;\n                                        groupIndex++;\n                                        if (groupIndex < groupSizes.length) {\n                                            groupSize = groupSizes[groupIndex];\n                                        }\n                                        groupDigitCount = 1;\n                                    }\n                                    else {\n                                        groupDigitCount++;\n                                    }\n                                }\n                            }\n                            if (vi > -1) {\n                                if (isZero && formatChar === DigitPlaceholder) {\n                                }\n                                else {\n                                    result = value.charAt(vi) + result;\n                                }\n                                vi--;\n                            }\n                            else if (formatChar !== DigitPlaceholder) {\n                                result = formatChar + result;\n                            }\n                        }\n                        break;\n                    case \",\":\n                        // We should skip all the , chars\n                        break;\n                    default:\n                        leftBuffer = formatChar + leftBuffer;\n                        break;\n                }\n            }\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\n            if (!suppressModifyValue) {\n                if (vi > -1 && result !== \"\") {\n                    if (enableGroups) {\n                        while (vi > -1) {\n                            if (groupDigitCount === groupSize) {\n                                result = groupSeparator + result;\n                                groupIndex++;\n                                if (groupIndex < groupSizes.length) {\n                                    groupSize = groupSizes[groupIndex];\n                                }\n                                groupDigitCount = 1;\n                            }\n                            else {\n                                groupDigitCount++;\n                            }\n                            result = value.charAt(vi) + result;\n                            vi--;\n                        }\n                    }\n                    else {\n                        result = value.substr(0, vi + 1) + result;\n                    }\n                }\n                // Insert sign in front of the leftBuffer and result\n                return sign + leftBuffer + result;\n            }\n            if (fmtOnly)\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\n                return sign + leftBuffer + result;\n            return sign + leftBuffer + value + result;\n        }\n        function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {\n            var vi = 0;\n            var fCount = format.length;\n            var vCount = value.length;\n            if (suppressModifyValue) {\n                debug.assert(fCount > 0, \"Empty formatting string\");\n                var lastChar = format.charAt(fCount - 1);\n                if (!lastChar.match(NumericPlaceholderRegex))\n                    return {\n                        value: value + lastChar,\n                        fmtOnly: value === \"\",\n                    };\n                return {\n                    value: value,\n                    fmtOnly: value === \"\",\n                };\n            }\n            var result = \"\", fmtOnly = true;\n            for (var fi = 0; fi < fCount; fi++) {\n                var formatChar = format.charAt(fi);\n                if (vi < vCount) {\n                    switch (formatChar) {\n                        case ZeroPlaceholder:\n                        case DigitPlaceholder:\n                            result += value[vi++];\n                            fmtOnly = false;\n                            break;\n                        default:\n                            result += formatChar;\n                    }\n                }\n                else {\n                    if (formatChar !== DigitPlaceholder) {\n                        result += formatChar;\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\n                    }\n                }\n            }\n            return {\n                value: result,\n                fmtOnly: fmtOnly,\n            };\n        }\n        function localize(value, dictionary) {\n            var plus = dictionary[\"+\"];\n            var minus = dictionary[\"-\"];\n            var dot = dictionary[\".\"];\n            var comma = dictionary[\",\"];\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\n                return value;\n            }\n            var count = value.length;\n            var result = \"\";\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \"+\":\n                        result = result + plus;\n                        break;\n                    case \"-\":\n                        result = result + minus;\n                        break;\n                    case \".\":\n                        result = result + dot;\n                        break;\n                    case \",\":\n                        result = result + comma;\n                        break;\n                    default:\n                        result = result + char;\n                        break;\n                }\n            }\n            return result;\n        }\n    })(NumberFormat = powerbi_1.NumberFormat || (powerbi_1.NumberFormat = {}));\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\n    var DateTimeScaleFormatInfo = (function () {\n        // Constructor\n        /**\n         * Creates new instance of the DateTimeScaleFormatInfo class.\n         * @param culture - culture which calendar info is going to be used to derive the formats.\n         */\n        function DateTimeScaleFormatInfo(culture) {\n            var calendar = culture.calendar;\n            var patterns = calendar.patterns;\n            var monthAbbreviations = calendar[\"months\"][\"namesAbbr\"];\n            var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];\n            var yearMonthPattern = patterns[\"Y\"];\n            var monthDayPattern = patterns[\"M\"];\n            var fullPattern = patterns[\"f\"];\n            var longTimePattern = patterns[\"T\"];\n            var shortTimePattern = patterns[\"t\"];\n            var separator = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\n            var hasYearSymbol = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\n            var yearPos = fullPattern.indexOf(\"yy\");\n            var monthPos = fullPattern.indexOf(\"MMMM\");\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\n            var minutePos = fullPattern.indexOf(\"mm\");\n            var pmPos = fullPattern.indexOf(\"tt\");\n            var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\n            this.MinutePattern = shortTimePattern;\n            this.SecondPattern = longTimePattern;\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\n            // Special cases\n            switch (culture.name) {\n                case \"fi-FI\":\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\n                    break;\n            }\n        }\n        // Methods\n        /**\n         * Returns the format string of the provided DateTimeUnit.\n         * @param unit - date or time unit\n         */\n        DateTimeScaleFormatInfo.prototype.getFormatString = function (unit) {\n            switch (unit) {\n                case powerbi_1.DateTimeUnit.Year:\n                    return this.YearPattern;\n                case powerbi_1.DateTimeUnit.Month:\n                    return this.MonthPattern;\n                case powerbi_1.DateTimeUnit.Week:\n                case powerbi_1.DateTimeUnit.Day:\n                    return this.DayPattern;\n                case powerbi_1.DateTimeUnit.Hour:\n                    return this.HourPattern;\n                case powerbi_1.DateTimeUnit.Minute:\n                    return this.MinutePattern;\n                case powerbi_1.DateTimeUnit.Second:\n                    return this.SecondPattern;\n                case powerbi_1.DateTimeUnit.Millisecond:\n                    return this.MillisecondPattern;\n            }\n            debug.assertFail('Unexpected unit: ' + unit);\n        };\n        return DateTimeScaleFormatInfo;\n    }());\n    powerbi_1.formattingService = new FormattingService();\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\n        var SQExprShortSerializer;\n        (function (SQExprShortSerializer) {\n            function serialize(expr) {\n                return JSON.stringify(expr.accept(SQExprSerializer.instance));\n            }\n            SQExprShortSerializer.serialize = serialize;\n            function serializeArray(exprs) {\n                var str = '[';\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    if (i > 0)\n                        str += ',';\n                    str += SQExprShortSerializer.serialize(exprs[i]);\n                }\n                return str + ']';\n            }\n            SQExprShortSerializer.serializeArray = serializeArray;\n            /** Responsible for serializing an SQExpr into a comparable string. */\n            var SQExprSerializer = (function (_super) {\n                __extends(SQExprSerializer, _super);\n                function SQExprSerializer() {\n                    _super.apply(this, arguments);\n                }\n                SQExprSerializer.prototype.visitColumnRef = function (expr) {\n                    return {\n                        col: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitMeasureRef = function (expr) {\n                    return {\n                        measure: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitAggr = function (expr) {\n                    return {\n                        agg: {\n                            a: expr.arg.accept(this),\n                            f: expr.func,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitEntity = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    debug.assertValue(expr.entity, 'expr.entity');\n                    return {\n                        e: expr.entity\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchyLevel = function (expr) {\n                    return {\n                        h: expr.arg.accept(this),\n                        l: expr.level,\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchy = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        h: expr.hierarchy,\n                    };\n                };\n                SQExprSerializer.prototype.visitPropertyVariationSource = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        n: expr.name,\n                        p: expr.property,\n                    };\n                };\n                SQExprSerializer.prototype.visitAnd = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        and: {\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitCompare = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        comp: {\n                            k: expr.comparison,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitConstant = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        const: {\n                            t: expr.type.primitiveType,\n                            v: expr.value,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitArithmetic = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        arithmetic: {\n                            o: expr.operator,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitScopedEval = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        scopedEval: {\n                            e: expr.expression.accept(this),\n                            s: serializeArray(expr.scope)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitDefault = function (expr) {\n                    debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\n                    return;\n                };\n                SQExprSerializer.instance = new SQExprSerializer();\n                return SQExprSerializer;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprShortSerializer = data.SQExprShortSerializer || (data.SQExprShortSerializer = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var Selector = powerbi.data.Selector;\n        /**\n         * A combination of identifiers used to uniquely identify\n         * data points and their bound geometry.\n         */\n        var SelectionId = (function () {\n            function SelectionId(selector, highlight) {\n                this.selector = selector;\n                this.highlight = highlight;\n                this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\n                this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\n            }\n            SelectionId.prototype.equals = function (other) {\n                if (!this.selector || !other.selector) {\n                    return (!this.selector === !other.selector) && this.highlight === other.highlight;\n                }\n                return this.highlight === other.highlight && Selector.equals(this.selector, other.selector);\n            };\n            /**\n             * Checks equality against other for all identifiers existing in this.\n             */\n            SelectionId.prototype.includes = function (other, ignoreHighlight) {\n                if (ignoreHighlight === void 0) { ignoreHighlight = false; }\n                var thisSelector = this.selector;\n                var otherSelector = other.selector;\n                if (!thisSelector || !otherSelector) {\n                    return false;\n                }\n                var thisData = thisSelector.data;\n                var otherData = otherSelector.data;\n                if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\n                    return false;\n                if (!ignoreHighlight && this.highlight !== other.highlight)\n                    return false;\n                if (thisData) {\n                    if (!otherData)\n                        return false;\n                    if (thisData.length > 0) {\n                        for (var i = 0, ilen = thisData.length; i < ilen; i++) {\n                            var thisValue = thisData[i];\n                            if (!otherData.some(function (otherValue) { return powerbi.DataViewScopeIdentity.equals(thisValue, otherValue); }))\n                                return false;\n                        }\n                    }\n                }\n                return true;\n            };\n            SelectionId.prototype.getKey = function () {\n                return this.key;\n            };\n            SelectionId.prototype.getKeyWithoutHighlight = function () {\n                return this.keyWithoutHighlight;\n            };\n            SelectionId.prototype.hasIdentity = function () {\n                return (this.selector && !!this.selector.data);\n            };\n            SelectionId.prototype.getSelector = function () {\n                return this.selector;\n            };\n            SelectionId.prototype.getSelectorsByColumn = function () {\n                return this.selectorsByColumn;\n            };\n            SelectionId.createNull = function (highlight) {\n                if (highlight === void 0) { highlight = false; }\n                return new SelectionId(null, highlight);\n            };\n            SelectionId.createWithId = function (id, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                if (id) {\n                    selector = {\n                        data: [id]\n                    };\n                }\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithMeasure = function (measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                debug.assertValue(measureId, 'measureId');\n                var selector = {\n                    metadata: measureId\n                };\n                var selectionId = new SelectionId(selector, highlight);\n                selectionId.selectorsByColumn = { metadata: measureId };\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasure = function (id, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                if (id) {\n                    selector.data = [id];\n                }\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id && !measureId)\n                    selector = null;\n                var selectionId = new SelectionId(selector, highlight);\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasureAndCategory = function (id, measureId, queryName, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\n                if (selectionId.selector) {\n                    selectionId.selectorsByColumn = {};\n                    if (id && queryName) {\n                        selectionId.selectorsByColumn.dataMap = {};\n                        selectionId.selectorsByColumn.dataMap[queryName] = id;\n                    }\n                    if (measureId)\n                        selectionId.selectorsByColumn.metadata = measureId;\n                }\n                return selectionId;\n            };\n            SelectionId.createWithIds = function (id1, id2, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector = { data: selectorData };\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithIdsAndMeasure = function (id1, id2, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector.data = selectorData;\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id1 && !id2 && !measureId)\n                    selector = null;\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithSelectorForColumnAndMeasure = function (dataMap, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId;\n                var keys = Object.keys(dataMap);\n                if (keys.length === 2) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], dataMap[keys[1]], measureId, highlight);\n                }\n                else if (keys.length === 1) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], null, measureId, highlight);\n                }\n                else {\n                    selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\n                }\n                var selectorsByColumn = {};\n                if (!_.isEmpty(dataMap))\n                    selectorsByColumn.dataMap = dataMap;\n                if (measureId)\n                    selectorsByColumn.metadata = measureId;\n                if (!dataMap && !measureId)\n                    selectorsByColumn = null;\n                selectionId.selectorsByColumn = selectorsByColumn;\n                return selectionId;\n            };\n            SelectionId.createWithHighlight = function (original) {\n                debug.assertValue(original, 'original');\n                debug.assert(!original.highlight, '!original.highlight');\n                var newId = new SelectionId(original.getSelector(), /*highlight*/ true);\n                newId.selectorsByColumn = original.selectorsByColumn;\n                return newId;\n            };\n            SelectionId.idArray = function (id1, id2) {\n                if (id1 || id2) {\n                    var data_4 = [];\n                    if (id1)\n                        data_4.push(id1);\n                    if (id2 && id2 !== id1)\n                        data_4.push(id2);\n                    return data_4;\n                }\n            };\n            return SelectionId;\n        }());\n        visuals.SelectionId = SelectionId;\n        /**\n         * This class is designed to simplify the creation of SelectionId objects\n         * It allows chaining to build up an object before calling 'create' to build a SelectionId\n         */\n        var SelectionIdBuilder = (function () {\n            function SelectionIdBuilder() {\n            }\n            SelectionIdBuilder.builder = function () {\n                return new SelectionIdBuilder();\n            };\n            SelectionIdBuilder.prototype.withCategory = function (categoryColumn, index) {\n                if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\n                    this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\n                return this;\n            };\n            SelectionIdBuilder.prototype.withSeries = function (seriesColumn, valueColumn) {\n                if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\n                    this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\n                return this;\n            };\n            SelectionIdBuilder.prototype.withMeasure = function (measureId) {\n                this.measure = measureId;\n                return this;\n            };\n            SelectionIdBuilder.prototype.createSelectionId = function () {\n                return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\n            };\n            SelectionIdBuilder.prototype.ensureDataMap = function () {\n                if (!this.dataMap)\n                    this.dataMap = {};\n                return this.dataMap;\n            };\n            return SelectionIdBuilder;\n        }());\n        visuals.SelectionIdBuilder = SelectionIdBuilder;\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n\n\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Allows generic traversal and type discovery for a SQExpr tree. */\r\n    export interface ISQExprVisitorWithArg<T, TArg> {\r\n        visitEntity(expr: SQEntityExpr, arg: TArg): T;\r\n        visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T;\r\n        visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T;\r\n        visitAggr(expr: SQAggregationExpr, arg: TArg): T;\r\n        visitPercentile(expr: SQPercentileExpr, arg: TArg): T;\r\n        visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T;\r\n        visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T;\r\n        visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T;\r\n        visitSelectRef(expr: SQSelectRefExpr, arg: TArg): T;\r\n        visitAnd(expr: SQAndExpr, arg: TArg): T;\r\n        visitBetween(expr: SQBetweenExpr, arg: TArg): T;\r\n        visitIn(expr: SQInExpr, arg: TArg): T;\r\n        visitOr(expr: SQOrExpr, arg: TArg): T;\r\n        visitCompare(expr: SQCompareExpr, arg: TArg): T;\r\n        visitContains(expr: SQContainsExpr, arg: TArg): T;\r\n        visitExists(expr: SQExistsExpr, arg: TArg): T;\r\n        visitNot(expr: SQNotExpr, arg: TArg): T;\r\n        visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T;\r\n        visitConstant(expr: SQConstantExpr, arg: TArg): T;\r\n        visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T;\r\n        visitDateAdd(expr: SQDateAddExpr, arg: TArg): T;\r\n        visitNow(expr: SQNowExpr, arg: TArg): T;\r\n        visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T;\r\n        visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T;\r\n        visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T;\r\n        visitFillRule(expr: SQFillRuleExpr, arg: TArg): T;\r\n        visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T;\r\n        visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T;\r\n    }\r\n\r\n    export interface ISQExprVisitor<T> extends ISQExprVisitorWithArg<T, void> {\r\n    }\r\n\r\n    /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\r\n    export class DefaultSQExprVisitorWithArg<T, TArg> implements ISQExprVisitorWithArg<T, TArg> {\r\n        public visitEntity(expr: SQEntityExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr, arg: TArg): T {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that others may derive from. */\r\n    export class DefaultSQExprVisitor<T> extends DefaultSQExprVisitorWithArg<T, void> implements ISQExprVisitor<T> {\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\r\n    export class DefaultSQExprVisitorWithTraversal implements ISQExprVisitor<void>, IFillRuleDefinitionVisitor<void, void> {\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): void {\r\n            expr.arg.accept(this);\r\n        } \r\n\r\n        public visitPercentile(expr: SQPercentileExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr): void {\r\n            expr.arg.accept(this);\r\n            expr.lower.accept(this);\r\n            expr.upper.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): void {\r\n            let args = expr.args;\r\n            for (let i = 0, len = args.length; i < len; i++)\r\n                args[i].accept(this);\r\n\r\n            let values = expr.values;\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let valueTuple = values[i];\r\n                for (let j = 0, jlen = valueTuple.length; j < jlen; j++)\r\n                    valueTuple[j].accept(this);\r\n            }\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr): void {\r\n            expr.input.accept(this);\r\n\r\n            let rule = expr.rule,\r\n                gradient2 = rule.linearGradient2,\r\n                gradient3 = rule.linearGradient3;\r\n\r\n            if (gradient2) {\r\n                this.visitLinearGradient2(gradient2);\r\n            }\r\n\r\n            if (gradient3) {\r\n                this.visitLinearGradient3(gradient3);\r\n            }\r\n        }\r\n\r\n        public visitLinearGradient2(gradient2: LinearGradient2Definition): void {\r\n            debug.assertValue(gradient2, 'gradient2');\r\n\r\n            this.visitFillRuleStop(gradient2.min);\r\n            this.visitFillRuleStop(gradient2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(gradient3: LinearGradient3Definition): void {\r\n            debug.assertValue(gradient3, 'gradient3');\r\n\r\n            this.visitFillRuleStop(gradient3.min);\r\n            this.visitFillRuleStop(gradient3.mid);\r\n            this.visitFillRuleStop(gradient3.max);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): void {\r\n            expr.expression.accept(this);\r\n\r\n            for (let scopeExpr of expr.scope) {\r\n                scopeExpr.accept(this);\r\n            }\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): void {\r\n            return;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): void {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            stop.color.accept(this);\r\n\r\n            let value = stop.value;\r\n            if (value)\r\n                value.accept(this);\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Defines a custom enumeration data type, and its values. */\r\n    export interface IEnumType {\r\n        /** Gets the members of the enumeration, limited to the validMembers, if appropriate. */\r\n        members(validMembers?: EnumMemberValue[]): IEnumMember[];\r\n    }\r\n\r\n    export function createEnumType(members: IEnumMember[]): IEnumType {\r\n        return new EnumType(members);\r\n    }\r\n\r\n    class EnumType implements IEnumType {\r\n        private allMembers: IEnumMember[];\r\n\r\n        constructor(allMembers: IEnumMember[]) {\r\n            debug.assertValue(allMembers, 'allMembers');\r\n\r\n            this.allMembers = allMembers;\r\n        }\r\n\r\n        public members(validMembers?: EnumMemberValue[]): IEnumMember[] {\r\n            let allMembers = this.allMembers;\r\n            if (!validMembers)\r\n                return allMembers;\r\n\r\n            let membersToReturn: IEnumMember[] = [];\r\n            for (let member of allMembers) {\r\n                if (_.contains(validMembers, member.value))\r\n                    membersToReturn.push(member);\r\n            }\r\n            return membersToReturn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface FillDefinition {\r\n        solid?: {\r\n            color?: SQExpr;\r\n        };\r\n        gradient?: {\r\n            startColor?: SQExpr;\r\n            endColor?: SQExpr;\r\n        };\r\n        pattern?: {\r\n            patternKind?: SQExpr;\r\n            color?: SQExpr;\r\n        };\r\n    }\r\n\r\n    export module FillSolidColorTypeDescriptor {\r\n        /** Gets a value indicating whether the descriptor is nullable or not. */\r\n        export function nullable(descriptor: FillSolidColorTypeDescriptor): boolean {\r\n            debug.assertValue(descriptor, 'descriptor');\r\n\r\n            if (descriptor === true)\r\n                return false;\r\n\r\n            let advancedDescriptor = <FillSolidColorAdvancedTypeDescriptor>descriptor;\r\n            return !!advancedDescriptor.nullable;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ImageTypeDescriptor {\r\n    }\r\n\r\n    export type ImageDefinition = ImageDefinitionGeneric<SQExpr>;\r\n\r\n    export module ImageDefinition {\r\n        export const urlType: ValueTypeDescriptor = { misc: { imageUrl: true } };\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SemanticFilter = powerbi.data.SemanticFilter;\r\n\r\n    export type StructuralObjectDefinition =\r\n        FillDefinition |\r\n        FillRuleDefinition |\r\n        SemanticFilter |\r\n        DefaultValueDefinition |\r\n        ImageDefinition |\r\n        ParagraphsDefinition;\r\n\r\n    export module StructuralTypeDescriptor {\r\n        export function isValid(type: StructuralTypeDescriptor): boolean {\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (type.fill ||\r\n                type.fillRule ||\r\n                type.filter ||\r\n                type.expression ||\r\n                type.image ||\r\n                type.paragraphs) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n\r\n    export interface ValueTypeDescriptor {\r\n        extendedType?: ExtendedType;\r\n    }\r\n    \r\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\r\n    export class ValueType implements ValueTypeDescriptor {\r\n        private static typeCache: { [id: string]: ValueType } = {};\r\n\r\n        private underlyingType: ExtendedType;\r\n        private category: string;\r\n\r\n        private temporalType: TemporalType;\r\n        private geographyType: GeographyType;\r\n        private miscType: MiscellaneousType;\r\n        private formattingType: FormattingType;\r\n        private enumType: IEnumType;\r\n        private scriptingType: ScriptType;\r\n\r\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\r\n        constructor(type: ExtendedType, category?: string, enumType?: IEnumType) {\r\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\r\n            debug.assert(!!category || category === null, 'category');\r\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\r\n\r\n            this.underlyingType = type;\r\n            this.category = category;\r\n\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\r\n                this.temporalType = new TemporalType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\r\n                this.geographyType = new GeographyType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\r\n                this.miscType = new MiscellaneousType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\r\n                this.formattingType = new FormattingType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\r\n                this.enumType = enumType;\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\r\n                this.scriptingType = new ScriptType(type);\r\n            }\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\r\n        public static fromDescriptor(descriptor: ValueTypeDescriptor): ValueType {\r\n            descriptor = descriptor || {};\r\n\r\n            // Simplified primitive types\r\n            if (descriptor.text) return ValueType.fromExtendedType(ExtendedType.Text);\r\n            if (descriptor.integer) return ValueType.fromExtendedType(ExtendedType.Integer);\r\n            if (descriptor.numeric) return ValueType.fromExtendedType(ExtendedType.Double);\r\n            if (descriptor.bool) return ValueType.fromExtendedType(ExtendedType.Boolean);\r\n            if (descriptor.dateTime) return ValueType.fromExtendedType(ExtendedType.DateTime);\r\n            if (descriptor.duration) return ValueType.fromExtendedType(ExtendedType.Duration);\r\n            if (descriptor.binary) return ValueType.fromExtendedType(ExtendedType.Binary);\r\n            if (descriptor.none) return ValueType.fromExtendedType(ExtendedType.None);\r\n\r\n            // Extended types\r\n            if (descriptor.scripting) {\r\n                if (descriptor.scripting.source) return ValueType.fromExtendedType(ExtendedType.ScriptSource);\r\n            }\r\n            if (descriptor.enumeration) return ValueType.fromEnum(descriptor.enumeration);\r\n            if (descriptor.temporal) {\r\n                if (descriptor.temporal.year) return ValueType.fromExtendedType(ExtendedType.Year_Integer);\r\n                if (descriptor.temporal.month) return ValueType.fromExtendedType(ExtendedType.Month_Integer);\r\n            }\r\n            if (descriptor.geography) {\r\n                if (descriptor.geography.address) return ValueType.fromExtendedType(ExtendedType.Address);\r\n                if (descriptor.geography.city) return ValueType.fromExtendedType(ExtendedType.City);\r\n                if (descriptor.geography.continent) return ValueType.fromExtendedType(ExtendedType.Continent);\r\n                if (descriptor.geography.country) return ValueType.fromExtendedType(ExtendedType.Country);\r\n                if (descriptor.geography.county) return ValueType.fromExtendedType(ExtendedType.County);\r\n                if (descriptor.geography.region) return ValueType.fromExtendedType(ExtendedType.Region);\r\n                if (descriptor.geography.postalCode) return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\r\n                if (descriptor.geography.stateOrProvince) return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\r\n                if (descriptor.geography.place) return ValueType.fromExtendedType(ExtendedType.Place);\r\n                if (descriptor.geography.latitude) return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\r\n                if (descriptor.geography.longitude) return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\r\n            }\r\n            if (descriptor.misc) {\r\n                if (descriptor.misc.image) return ValueType.fromExtendedType(ExtendedType.Image);\r\n                if (descriptor.misc.imageUrl) return ValueType.fromExtendedType(ExtendedType.ImageUrl);\r\n                if (descriptor.misc.webUrl) return ValueType.fromExtendedType(ExtendedType.WebUrl);\r\n                if (descriptor.misc.barcode) return ValueType.fromExtendedType(ExtendedType.Barcode_Text);\r\n            }\r\n            if (descriptor.formatting) {\r\n                if (descriptor.formatting.color) return ValueType.fromExtendedType(ExtendedType.Color);\r\n                if (descriptor.formatting.formatString) return ValueType.fromExtendedType(ExtendedType.FormatString);\r\n                if (descriptor.formatting.alignment) return ValueType.fromExtendedType(ExtendedType.Alignment);\r\n                if (descriptor.formatting.labelDisplayUnits) return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\r\n                if (descriptor.formatting.fontSize) return ValueType.fromExtendedType(ExtendedType.FontSize);\r\n                if (descriptor.formatting.labelDensity) return ValueType.fromExtendedType(ExtendedType.LabelDensity);\r\n            }\r\n            if (descriptor.extendedType) {\r\n                return ValueType.fromExtendedType(descriptor.extendedType);\r\n            }\r\n\r\n            return ValueType.fromExtendedType(ExtendedType.Null);\r\n        }\r\n\r\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\r\n        public static fromExtendedType(extendedType: ExtendedType): ValueType {\r\n            extendedType = extendedType || ExtendedType.Null;\r\n\r\n            let primitiveType = getPrimitiveType(extendedType),\r\n                category = getCategoryFromExtendedType(extendedType);\r\n            debug.assert(\r\n                primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null,\r\n                'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\r\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\r\n        public static fromPrimitiveTypeAndCategory(primitiveType: PrimitiveType, category?: string): ValueType {\r\n            primitiveType = primitiveType || PrimitiveType.Null;\r\n            category = category || null;\r\n\r\n            let id = primitiveType.toString();\r\n            if (category)\r\n                id += '|' + category;\r\n\r\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\r\n        }\r\n\r\n        /** Creates a ValueType to describe the given IEnumType. */\r\n        public static fromEnum(enumType: IEnumType): ValueType {\r\n            debug.assertValue(enumType, 'enumType');\r\n\r\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\r\n        }\r\n\r\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\r\n        public static isCompatibleTo(type: ValueTypeDescriptor, otherTypes: ValueTypeDescriptor[]): boolean {\r\n            debug.assertValue(type, 'type');\r\n            debug.assertValue(otherTypes, 'otherTypes');\r\n\r\n            let valueType = ValueType.fromDescriptor(type);\r\n            for (let otherType of otherTypes) {\r\n                let otherValueType = ValueType.fromDescriptor(otherType);\r\n\r\n                if (otherValueType.isCompatibleFrom(valueType))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\r\n        public isCompatibleFrom(other: ValueType): boolean {\r\n            debug.assertValue(other, 'other');\r\n\r\n            let otherPrimitiveType = other.primitiveType;\r\n            if (this === other ||\r\n                this.primitiveType === otherPrimitiveType ||\r\n                otherPrimitiveType === PrimitiveType.Null)\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines if the instance ValueType is equal to the 'other' ValueType\r\n         * @param {ValueType} other the other ValueType to check equality against\r\n         * @returns True if the instance ValueType is equal to the 'other' ValueType\r\n         */\r\n        public equals(other: ValueType): boolean {\r\n            return _.isEqual(this, other);\r\n        }\r\n\r\n        /** Gets the exact primitive type of this ValueType. */\r\n        public get primitiveType(): PrimitiveType {\r\n            return getPrimitiveType(this.underlyingType);\r\n        }\r\n\r\n        /** Gets the exact extended type of this ValueType. */\r\n        public get extendedType(): ExtendedType {\r\n            return this.underlyingType;\r\n        }\r\n\r\n        /** Gets the data category string (if any) for this ValueType. */\r\n        public get categoryString(): string {\r\n            return this.category;\r\n        }\r\n\r\n        // Simplified primitive types\r\n\r\n        /** Indicates whether the type represents text values. */\r\n        public get text(): boolean {\r\n            return this.primitiveType === PrimitiveType.Text;\r\n        }\r\n\r\n        /** Indicates whether the type represents any numeric value. */\r\n        public get numeric(): boolean {\r\n            return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\r\n        }\r\n\r\n        /** Indicates whether the type represents integer numeric values. */\r\n        public get integer(): boolean {\r\n            return this.primitiveType === PrimitiveType.Integer;\r\n        }\r\n\r\n        /** Indicates whether the type represents Boolean values. */\r\n        public get bool(): boolean {\r\n            return this.primitiveType === PrimitiveType.Boolean;\r\n        }\r\n\r\n        /** Indicates whether the type represents any date/time values. */\r\n        public get dateTime(): boolean {\r\n            return this.primitiveType === PrimitiveType.DateTime ||\r\n                this.primitiveType === PrimitiveType.Date ||\r\n                this.primitiveType === PrimitiveType.Time;\r\n        }\r\n\r\n        /** Indicates whether the type represents duration values. */\r\n        public get duration(): boolean {\r\n            return this.primitiveType === PrimitiveType.Duration;\r\n        }\r\n\r\n        /** Indicates whether the type represents binary values. */\r\n        public get binary(): boolean {\r\n            return this.primitiveType === PrimitiveType.Binary;\r\n        }\r\n\r\n        /** Indicates whether the type represents none values. */\r\n        public get none(): boolean {\r\n            return this.primitiveType === PrimitiveType.None;\r\n        }\r\n\r\n        // Extended types\r\n\r\n        /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\r\n        public get temporal(): TemporalType {\r\n            return this.temporalType;\r\n        }\r\n\r\n        /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\r\n        public get geography(): GeographyType {\r\n            return this.geographyType;\r\n        }\r\n\r\n        /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\r\n        public get misc(): MiscellaneousType {\r\n            return this.miscType;\r\n        }\r\n\r\n        /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\r\n        public get formatting(): FormattingType {\r\n            return this.formattingType;\r\n        }\r\n\r\n        /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\r\n        public get enum(): IEnumType {\r\n            return this.enumType;\r\n        }\r\n\r\n        public get scripting(): ScriptType {\r\n            return this.scriptingType;\r\n        }\r\n    }\r\n\r\n    export class ScriptType implements ScriptTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get source(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\r\n        }\r\n    }\r\n\r\n    export class TemporalType implements TemporalTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get year(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\r\n        }\r\n        public get month(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\r\n        }\r\n    }\r\n\r\n    export class GeographyType implements GeographyTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get address(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\r\n        }\r\n        public get city(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\r\n        }\r\n        public get continent(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\r\n        }\r\n        public get country(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\r\n        }\r\n        public get county(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\r\n        }\r\n        public get region(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\r\n        }\r\n        public get postalCode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\r\n        }\r\n        public get stateOrProvince(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\r\n        }\r\n        public get place(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\r\n        }\r\n        public get latitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\r\n        }\r\n        public get longitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\r\n        }\r\n    }\r\n\r\n    export class MiscellaneousType implements MiscellaneousTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get image(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\r\n        }\r\n        public get imageUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\r\n        }\r\n        public get webUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\r\n        }\r\n        public get barcode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Barcode);\r\n        }\r\n    }\r\n\r\n    export class FormattingType implements FormattingTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get color(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\r\n        }\r\n\r\n        public get formatString(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\r\n        }\r\n\r\n        public get alignment(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\r\n        }\r\n\r\n        public get labelDisplayUnits(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\r\n        }\r\n\r\n        public get fontSize(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\r\n        }\r\n\r\n        public get labelDensity(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\r\n        }\r\n    }\r\n\r\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\r\n    export enum PrimitiveType {\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = 2,\r\n        Double = 3,\r\n        Integer = 4,\r\n        Boolean = 5,\r\n        Date = 6,\r\n        DateTime = 7,\r\n        DateTimeZone = 8,\r\n        Time = 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n    }\r\n\r\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\r\n    export enum ExtendedType {\r\n        // Flags (1 << 8-15 range [0xFF00])\r\n        // Important: Enum members must be declared before they are used in TypeScript.\r\n        Numeric = 1 << 8,\r\n        Temporal = 1 << 9,\r\n        Geography = 1 << 10,\r\n        Miscellaneous = 1 << 11,\r\n        Formatting = 1 << 12,\r\n        Scripting = 1 << 13,        \r\n\r\n        // Primitive types (0-255 range [0xFF] | flags)\r\n        // The member names and base values must match those in PrimitiveType.\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = Numeric | 2,\r\n        Double = Numeric | 3,\r\n        Integer = Numeric | 4,\r\n        Boolean = 5,\r\n        Date = Temporal | 6,\r\n        DateTime = Temporal | 7,\r\n        DateTimeZone = Temporal | 8,\r\n        Time = Temporal | 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n\r\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\r\n        // Temporal\r\n        Year = Temporal | (1 << 16),\r\n        Year_Text = Year | Text,\r\n        Year_Integer = Year | Integer,\r\n        Year_Date = Year | Date,\r\n        Year_DateTime = Year | DateTime,\r\n        Month = Temporal | (2 << 16),\r\n        Month_Text = Month | Text,\r\n        Month_Integer = Month | Integer,\r\n        Month_Date = Month | Date,\r\n        Month_DateTime = Month | DateTime,\r\n        // Geography\r\n        Address = Text | Geography | (100 << 16),\r\n        City = Text | Geography | (101 << 16),\r\n        Continent = Text | Geography | (102 << 16),\r\n        Country = Text | Geography | (103 << 16),\r\n        County = Text | Geography | (104 << 16),\r\n        Region = Text | Geography | (105 << 16),\r\n        PostalCode = Geography | (106 << 16),\r\n        PostalCode_Text = PostalCode | Text,\r\n        PostalCode_Integer = PostalCode | Integer,\r\n        StateOrProvince = Text | Geography | (107 << 16),\r\n        Place = Text | Geography | (108 << 16),\r\n        Latitude = Geography | (109 << 16),\r\n        Latitude_Decimal = Latitude | Decimal,\r\n        Latitude_Double = Latitude | Double,\r\n        Longitude = Geography | (110 << 16),\r\n        Longitude_Decimal = Longitude | Decimal,\r\n        Longitude_Double = Longitude | Double,\r\n        // Miscellaneous\r\n        Image = Binary | Miscellaneous | (200 << 16),\r\n        ImageUrl = Text | Miscellaneous | (201 << 16),\r\n        WebUrl = Text | Miscellaneous | (202 << 16),\r\n        Barcode =  Miscellaneous | (203 << 16),\r\n        Barcode_Text = Barcode | Text,\r\n        Barcode_Integer = Barcode | Integer,\r\n\r\n        // Formatting\r\n        Color = Text | Formatting | (300 << 16),\r\n        FormatString = Text | Formatting | (301 << 16),\r\n        Alignment = Text | Formatting | (306 << 16),\r\n        LabelDisplayUnits = Text | Formatting | (307 << 16),\r\n        FontSize = Double | Formatting | (308 << 16),\r\n        LabelDensity = Double | Formatting | (309 << 16),\r\n        // Enumeration\r\n        Enumeration = Text | 400 << 16,\r\n        // Scripting\r\n        ScriptSource = Text | Scripting | (500 << 16),        \r\n        // NOTE: To avoid confusion, underscores should be used only to delimit primitive type variants of an extended type\r\n        // (e.g. Year_Integer or Latitude_Double above)\r\n    }\r\n\r\n    const PrimitiveTypeMask = 0xFF;\r\n    const PrimitiveTypeWithFlagsMask = 0xFFFF;\r\n    const PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\r\n\r\n    function getPrimitiveType(extendedType: ExtendedType): PrimitiveType {\r\n        return extendedType & PrimitiveTypeMask;\r\n    }\r\n\r\n    function isPrimitiveType(extendedType: ExtendedType): boolean {\r\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\r\n    }\r\n\r\n    function getCategoryFromExtendedType(extendedType: ExtendedType): string {\r\n        if (isPrimitiveType(extendedType))\r\n            return null;\r\n\r\n        let category = ExtendedType[extendedType];\r\n        if (category) {\r\n            // Check for ExtendedType declaration without a primitive type.\r\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\r\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\r\n            let delimIdx = category.lastIndexOf('_');\r\n            if (delimIdx > 0) {\r\n                let baseCategory = category.slice(0, delimIdx);\r\n                if (ExtendedType[baseCategory]) {\r\n                    debug.assert(\r\n                        (ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask),\r\n                        'Unexpected value for ExtendedType base member of ' + extendedType);\r\n                    category = baseCategory;\r\n                }\r\n            }\r\n        }\r\n        return category || null;\r\n    }\r\n\r\n    function toExtendedType(primitiveType: PrimitiveType, category?: string): ExtendedType {\r\n        let primitiveString = PrimitiveType[primitiveType];\r\n        let t = ExtendedType[primitiveString];\r\n        if (t == null) {\r\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\r\n            t = ExtendedType.Null;\r\n        }\r\n\r\n        if (primitiveType && category) {\r\n            let categoryType: ExtendedType = ExtendedType[category];\r\n            if (categoryType) {\r\n                let categoryPrimitiveType = getPrimitiveType(categoryType);\r\n                if (categoryPrimitiveType === PrimitiveType.Null) {\r\n                    // Category supports multiple primitive types, check if requested primitive type is supported\r\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\r\n                    categoryType = t | categoryType;\r\n                    if (ExtendedType[categoryType]) {\r\n                        debug.assert(\r\n                            ExtendedType[categoryType] === (category + '_' + primitiveString),\r\n                            'Unexpected name for ExtendedType member ' + categoryType);\r\n                        t = categoryType;\r\n                    }\r\n                }\r\n                else if (categoryPrimitiveType === primitiveType) {\r\n                    // Primitive type matches the single supported type for the category\r\n                    t = categoryType;\r\n                }\r\n            }\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    function matchesExtendedTypeWithAnyPrimitive(a: ExtendedType, b: ExtendedType): boolean {\r\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /**\r\n     * Represents the versions of the data shape binding structure.\r\n     * NOTE Keep this file in sync with the Sql\\InfoNav\\src\\Data\\Contracts\\DsqGeneration\\DataShapeBindingVersions.cs\r\n     * file in the TFS Dev branch.\r\n     */\r\n    export const enum DataShapeBindingVersions {\r\n        /** The initial version of data shape binding */\r\n        Version0 = 0,\r\n        /** Explicit subtotal support for axis groupings. */\r\n        Version1 = 1,\r\n    }\r\n\r\n    export interface DataShapeBindingLimitTarget {\r\n        Primary?: number;\r\n    }\r\n\r\n    export enum DataShapeBindingLimitType {\r\n        Top = 0,\r\n        First = 1,\r\n        Last = 2,\r\n        Sample = 3,\r\n        Bottom = 4,\r\n    }\r\n\r\n    export interface DataShapeBindingLimit {\r\n        Count?: number;\r\n        Target: DataShapeBindingLimitTarget;\r\n        Type: DataShapeBindingLimitType;\r\n    }\r\n\r\n    export interface DataShapeBinding {\r\n        Version?: number;\r\n        Primary: DataShapeBindingAxis;\r\n        Secondary?: DataShapeBindingAxis;\r\n        Aggregates?: DataShapeBindingAggregate[];\r\n        Projections?: number[];\r\n        Limits?: DataShapeBindingLimit[];\r\n        Highlights?: FilterDefinition[];\r\n        DataReduction?: DataShapeBindingDataReduction;\r\n        IncludeEmptyGroups?: boolean;\r\n        SuppressedJoinPredicates?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingDataReduction {\r\n        Primary?: DataShapeBindingDataReductionAlgorithm;\r\n        Secondary?: DataShapeBindingDataReductionAlgorithm;\r\n        DataVolume?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionAlgorithm {\r\n        Top?: DataShapeBindingDataReductionTopLimit;\r\n        Sample?: DataShapeBindingDataReductionSampleLimit;\r\n        Bottom?: DataShapeBindingDataReductionBottomLimit;\r\n        Window?: DataShapeBindingDataReductionDataWindow;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionTopLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionSampleLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionBottomLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionDataWindow {\r\n        Count?: number;\r\n        RestartTokens?: RestartToken;\r\n    }\r\n\r\n    export interface DataShapeBindingAxis {\r\n        Groupings: DataShapeBindingAxisGrouping[];\r\n    }\r\n\r\n    export enum SubtotalType {\r\n        None = 0,\r\n        Before = 1,\r\n        After = 2\r\n    }\r\n\r\n    export interface DataShapeBindingAxisGrouping {\r\n        Projections: number[];\r\n        GroupBy?: number[];\r\n        SuppressedProjections?: number[];\r\n        Subtotal?: SubtotalType;\r\n        ShowItemsWithNoData?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingAggregate {\r\n        Select: number;\r\n        Kind: DataShapeBindingAggregateKind;\r\n    }\r\n\r\n    export const enum DataShapeBindingAggregateKind {\r\n        None = 0,\r\n        Min = 1,\r\n        Max = 1 << 1,\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataShapeBindingDataReduction {\r\n\r\n        export function createFrom(reduction: ReductionAlgorithm): DataShapeBindingDataReductionAlgorithm {\r\n            if (!reduction)\r\n                return;\r\n\r\n            var result: DataShapeBindingDataReductionAlgorithm;\r\n            if (reduction.top) {\r\n                result = {\r\n                    Top: {}\r\n                };\r\n\r\n                if (reduction.top.count)\r\n                    result.Top.Count = reduction.top.count;\r\n            }\r\n\r\n            if (reduction.bottom) {\r\n                result = {\r\n                    Bottom: {}\r\n                };\r\n\r\n                if (reduction.bottom.count)\r\n                    result.Bottom.Count = reduction.bottom.count;\r\n            }\r\n\r\n            if (reduction.sample) {\r\n                result = {\r\n                    Sample: {}\r\n                };\r\n\r\n                if (reduction.sample.count)\r\n                    result.Sample.Count = reduction.sample.count;\r\n            }\r\n\r\n            if (reduction.window) {\r\n                result = {\r\n                    Window: {}\r\n                };\r\n\r\n                if (reduction.window.count)\r\n                    result.Window.Count = reduction.window.count;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface FederatedConceptualSchemaInitOptions {\r\n        schemas: { [name: string]: ConceptualSchema };\r\n        links?: ConceptualSchemaLink[];\r\n    }\r\n\r\n    /** Represents a federated conceptual schema. */\r\n    export class FederatedConceptualSchema {\r\n        private schemas: { [name: string]: ConceptualSchema };\r\n        private links: ConceptualSchemaLink[];\r\n\r\n        constructor(options: FederatedConceptualSchemaInitOptions) {\r\n            debug.assertValue(options, 'options');\r\n\r\n            this.schemas = options.schemas; \r\n            if (options.links)\r\n                this.links = options.links;\r\n        }\r\n\r\n        public schema(name: string): ConceptualSchema {\r\n            return this.schemas[name];\r\n        }\r\n    }\r\n\r\n    /** Describes a semantic relationship between ConceptualSchemas. */\r\n    export interface ConceptualSchemaLink {\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module Selector {\r\n        export function filterFromSelector(selectors: Selector[], isNot?: boolean): SemanticFilter {\r\n            if (_.isEmpty(selectors))\r\n                return;\r\n\r\n            let exprs: SQExpr[] = [];\r\n            for (let i = 0, ilen = selectors.length; i < ilen; i++) {\r\n                let identity = selectors[i];\r\n                let data = identity.data;\r\n                let exprToAdd: SQExpr = undefined;\r\n                if (data && data.length) {\r\n                    for (let j = 0, jlen = data.length; j < jlen; j++) {\r\n                        exprToAdd = SQExprBuilder.and(exprToAdd, <SQExpr>(<DataViewScopeIdentity>identity.data[j]).expr);\r\n                    }\r\n                }\r\n\r\n                if (exprToAdd)\r\n                    exprs.push(exprToAdd);\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return DataViewScopeIdentity.filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function matchesData(selector: Selector, identities: DataViewScopeIdentity[]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(identities, 'identities');\r\n\r\n            let selectorData = selector.data;\r\n            if (selectorData.length !== identities.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = selectorData.length; i < len; i++) {\r\n                let dataItem = selector.data[i];\r\n                let selectorDataItem = <DataViewScopeIdentity>dataItem;\r\n                if (selectorDataItem.expr) {\r\n                    if (!DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\r\n                        return false;\r\n                }\r\n                else {\r\n                    if (!DataViewScopeWildcard.matches(<DataViewScopeWildcard>dataItem, identities[i]))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function matchesKeys(selector: Selector, keysList: SQExpr[][]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(keysList, 'keysList');\r\n\r\n            let selectorData = selector.data,\r\n                selectorDataLength = selectorData.length;\r\n            if (selectorDataLength !== keysList.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < selectorDataLength; i++) {\r\n                let selectorDataItem = selector.data[i],\r\n                    selectorDataExprs: SQExpr[];\r\n\r\n                if ((<DataViewScopeIdentity>selectorDataItem).expr) {\r\n                    selectorDataExprs = ScopeIdentityExtractor.getKeys(<SQExpr>(<DataViewScopeIdentity>selectorDataItem).expr);\r\n                }\r\n                else if ((<DataViewScopeWildcard>selectorDataItem).exprs) {\r\n                    selectorDataExprs = <SQExpr[]>(<DataViewScopeWildcard>selectorDataItem).exprs;\r\n                } else { \r\n                    // In case DataViewRoleWildcard\r\n                    return false;\r\n                }\r\n\r\n                if (!selectorDataExprs)\r\n                    continue;\r\n                if (!SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /** Determines whether two selectors are equal. */\r\n        export function equals(x: Selector, y: Selector): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            if (x.id !== y.id)\r\n                return false;\r\n            if (x.metadata !== y.metadata)\r\n                return false;\r\n            if (!equalsDataArray(x.data, y.data))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsDataArray(x: DataRepetitionSelector[], y: DataRepetitionSelector[]): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            if (x.length !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = x.length; i < len; i++) {\r\n                if (!equalsData(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsData(x: DataRepetitionSelector, y: DataRepetitionSelector): boolean {\r\n            let selector1 = <DataViewScopeIdentity & DataViewRoleWildcard & DataViewScopeWildcard>x;\r\n            let selector2 = <DataViewScopeIdentity & DataViewRoleWildcard & DataViewScopeWildcard>y;\r\n            if (selector1.expr && selector2.expr)\r\n                return DataViewScopeIdentity.equals(selector1, selector2);\r\n\r\n            if (selector1.exprs && selector2.exprs)\r\n                return DataViewScopeWildcard.equals(selector1, selector2);\r\n\r\n            if (selector1.roles && selector2.roles)\r\n                return DataViewRoleWildcard.equals(selector1, selector2);\r\n\r\n            return false;\r\n        }\r\n\r\n        export function getKey(selector: Selector): string {\r\n            let toStringify: any = {};\r\n            if (selector.data) {\r\n                let data = [];\r\n                for (let i = 0, ilen = selector.data.length; i < ilen; i++) {\r\n                    data.push(selector.data[i].key);\r\n                }\r\n                toStringify.data = data;\r\n            }\r\n            if (selector.metadata)\r\n                toStringify.metadata = selector.metadata;\r\n            if (selector.id)\r\n                toStringify.id = selector.id;\r\n            return JSON.stringify(toStringify);\r\n        }\r\n\r\n        export function containsWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (!dataItems)\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                let wildCard = <DataViewScopeWildcard & DataViewRoleWildcard>dataItem;\r\n                if (wildCard.exprs || wildCard.roles)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function hasRoleWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (_.isEmpty(dataItems))\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                if (isRoleWildcard(dataItem))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRoleWildcard(dataItem: DataRepetitionSelector): dataItem is DataViewRoleWildcard {\r\n            return !_.isEmpty((<DataViewRoleWildcard>dataItem).roles);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface QueryDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where?: QueryFilter[];\r\n        OrderBy?: QuerySortClause[];\r\n        Select: QueryExpressionContainer[];\r\n        GroupBy?: QueryExpressionContainer[];\r\n    }\r\n\r\n    export interface FilterDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where: QueryFilter[];\r\n    }    \r\n\r\n    export enum EntitySourceType {\r\n        Table = 0,\r\n        Pod = 1,\r\n    }\r\n\r\n    export interface EntitySource {\r\n        Name: string;\r\n        EntitySet?: string; // TODO: Remove this when Q&A Silverlight is removed and make Entity required\r\n        Entity?: string;\r\n        Schema?: string;\r\n        Type?: EntitySourceType;\r\n    }\r\n\r\n    export interface QueryFilter {\r\n        Target?: QueryExpressionContainer[];\r\n        Condition: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QuerySortClause {\r\n        Expression: QueryExpressionContainer;\r\n        Direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryExpressionContainer {\r\n        Name?: string;\r\n\r\n        SourceRef?: QuerySourceRefExpression;\r\n        Column?: QueryColumnExpression;\r\n        Measure?: QueryMeasureExpression;\r\n        Aggregation?: QueryAggregationExpression;\r\n        Percentile?: QueryPercentileExpression;\r\n        Hierarchy?: QueryHierarchyExpression;\r\n        HierarchyLevel?: QueryHierarchyLevelExpression;\r\n        PropertyVariationSource?: QueryPropertyVariationSourceExpression;\r\n\r\n        // Logical\r\n        And?: QueryBinaryExpression;\r\n        Between?: QueryBetweenExpression;\r\n        In?: QueryInExpression;\r\n        Or?: QueryBinaryExpression;\r\n        Comparison?: QueryComparisonExpression;\r\n        Not?: QueryNotExpression;\r\n        Contains?: QueryContainsExpression;\r\n        StartsWith?: QueryStartsWithExpression;\r\n        Exists?: QueryExistsExpression;\r\n\r\n        // Constants\r\n        Boolean?: QueryBooleanExpression;\r\n        DateTime?: QueryDateTimeExpression;\r\n        DateTimeSecond?: QueryDateTimeSecondExpression;\r\n        Date?: QueryDateTimeExpression;\r\n        Decimal?: QueryDecimalExpression;\r\n        Integer?: QueryIntegerExpression;\r\n        Null?: QueryNullExpression;\r\n        Number?: QueryNumberExpression;\r\n        String?: QueryStringExpression;\r\n        Literal?: QueryLiteralExpression;\r\n\r\n        DateSpan?: QueryDateSpanExpression;\r\n        DateAdd?: QueryDateAddExpression;\r\n        Now?: QueryNowExpression;\r\n\r\n        // Default Values\r\n        DefaultValue?: QueryDefaultValueExpression;\r\n        AnyValue?: QueryAnyValueExpression;\r\n\r\n        Arithmetic?: QueryArithmeticExpression;\r\n\r\n        // Evaluation Expressions\r\n        ScopedEval?: QueryScopedEvalExpression;\r\n\r\n        // Client-only expressions\r\n        FillRule?: QueryFillRuleExpression;\r\n        ResourcePackageItem?: QueryResourcePackageItem;\r\n        SelectRef?: QuerySelectRefExpression;\r\n    }\r\n\r\n    export interface QueryPropertyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryColumnExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QueryMeasureExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QuerySourceRefExpression {\r\n        Source: string;\r\n    }\r\n\r\n    export interface QuerySelectRefExpression {\r\n        ExpressionName: string;\r\n    }\r\n\r\n    export interface QueryAggregationExpression {\r\n        Function: QueryAggregateFunction;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryPercentileExpression {\r\n        Expression: QueryExpressionContainer;\r\n        K: number;\r\n        Exclusive?: boolean;\r\n    }\r\n\r\n    export interface QueryHierarchyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Hierarchy: string;\r\n    }\r\n\r\n    export interface QueryHierarchyLevelExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Level: string;\r\n    }\r\n\r\n    export interface QueryPropertyVariationSourceExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Name: string;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryBinaryExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryBetweenExpression {\r\n        Expression: QueryExpressionContainer;\r\n        LowerBound: QueryExpressionContainer;\r\n        UpperBound: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryInExpression {\r\n        Expressions: QueryExpressionContainer[];\r\n        Values: QueryExpressionContainer[][];\r\n    }\r\n\r\n    export interface QueryComparisonExpression extends QueryBinaryExpression {\r\n        ComparisonKind: QueryComparisonKind;\r\n    }\r\n\r\n    export interface QueryContainsExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryNotExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryStartsWithExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryExistsExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryConstantExpression<T> {\r\n        Value: T;\r\n    }\r\n\r\n    export interface QueryLiteralExpression {\r\n        Value: string;\r\n    }\r\n\r\n    export interface QueryBooleanExpression extends QueryConstantExpression<boolean> { }\r\n    export interface QueryDateTimeExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDateTimeSecondExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDecimalExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryIntegerExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryNumberExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryNullExpression { }\r\n    export interface QueryStringExpression extends QueryConstantExpression<string> { }\r\n\r\n    export interface QueryDateSpanExpression {\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryDateAddExpression {\r\n        Amount: number;\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryNowExpression { }\r\n\r\n    export interface QueryDefaultValueExpression { }\r\n\r\n    export interface QueryAnyValueExpression { }\r\n\r\n    export interface QueryArithmeticExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n        Operator: ArithmeticOperatorKind;\r\n    }\r\n\r\n    export const enum ArithmeticOperatorKind {\r\n        Add = 0,\r\n        Subtract = 1,\r\n        Multiply = 2,\r\n        Divide = 3,\r\n    }\r\n\r\n    export function getArithmeticOperatorName(arithmeticOperatorKind: ArithmeticOperatorKind): string {\r\n        switch (arithmeticOperatorKind) {\r\n            case ArithmeticOperatorKind.Add:\r\n                return \"Add\";\r\n            case ArithmeticOperatorKind.Subtract:\r\n                return \"Subtract\";\r\n            case ArithmeticOperatorKind.Multiply:\r\n                return \"Multiply\";\r\n            case ArithmeticOperatorKind.Divide:\r\n                return \"Divide\";\r\n        }\r\n        throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\r\n    }\r\n\r\n    export interface QueryFillRuleExpression {\r\n        Input: QueryExpressionContainer;\r\n        FillRule: FillRuleGeneric<QueryExpressionContainer, QueryExpressionContainer>;\r\n    }\r\n\r\n    export interface QueryResourcePackageItem {\r\n        PackageName: string;\r\n        PackageType: number;\r\n        ItemName: string;\r\n    }\r\n\r\n    export interface QueryScopedEvalExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Scope: QueryExpressionContainer[];\r\n    }\r\n\r\n    export enum TimeUnit {\r\n        Day = 0,\r\n        Week = 1,\r\n        Month = 2,\r\n        Year = 3,\r\n        Decade = 4,\r\n        Second = 5,\r\n        Minute = 6,\r\n        Hour = 7,\r\n    }\r\n\r\n    export enum QueryAggregateFunction {\r\n        Sum = 0,\r\n        Avg = 1,\r\n        Count = 2,\r\n        Min = 3,\r\n        Max = 4,\r\n        CountNonNull = 5,\r\n        Median = 6,\r\n        StandardDeviation = 7,\r\n        Variance = 8,\r\n    }\r\n\r\n    export enum QueryComparisonKind {\r\n        Equal = 0,\r\n        GreaterThan = 1,\r\n        GreaterThanOrEqual = 2,\r\n        LessThan = 3,\r\n        LessThanOrEqual = 4,\r\n    }\r\n\r\n    /** Defines semantic data types. */\r\n    export enum SemanticType {\r\n        None = 0x0,\r\n        Number = 0x1,\r\n        Integer = Number + 0x2,\r\n        DateTime = 0x4,\r\n        Time = 0x08,\r\n        Date = DateTime + 0x10,\r\n        Month = Integer + 0x20,\r\n        Year = Integer + 0x40,\r\n        YearAndMonth = 0x80,\r\n        MonthAndDay = 0x100,\r\n        Decade = Integer + 0x200,\r\n        YearAndWeek = 0x400,\r\n        String = 0x800,\r\n        Boolean = 0x1000,\r\n        Table = 0x2000,\r\n        Range = 0x4000,\r\n    }\r\n\r\n    export interface QueryMetadata {\r\n        Select?: SelectMetadata[];\r\n        Filters?: FilterMetadata[];\r\n    }\r\n\r\n    // TODO: Stop using SemanticType and ConceptualDataCategory here (may need server contract changes)\r\n    export interface SelectMetadata {\r\n        Restatement: string;\r\n        \r\n        /* SemanticType or PrimitiveType. */\r\n        Type?: number; \r\n\r\n        Format?: string;\r\n        DataCategory?: ConceptualDataCategory;\r\n\r\n        /** The select projection name. */\r\n        Name?: string;\r\n\r\n        /* If defined, this indicates the KPI class*/\r\n        kpiStatusGraphic?: string; // old version of kpi data\r\n\r\n        /* If defined, this indicates the KPI metadata*/\r\n        kpi?: DataViewKpiColumnMetadata;\r\n    }\r\n\r\n    export interface FilterMetadata {\r\n        Restatement: string;\r\n        Kind?: FilterKind;\r\n        /** The expression being filtered.  This is reflected in the filter card UI. */\r\n        expression?: QueryExpressionContainer;\r\n    }\r\n\r\n    export enum FilterKind {\r\n        Default,\r\n        Period,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Represents a projection from a query result. */\r\n    export interface QueryProjection {\r\n        /** Name of item in the semantic query Select clause. */\r\n        queryRef: string;\r\n\r\n        /** Optional format string. */\r\n        format?: string; // TODO: Deprecate this, and populate format string through objects instead.\r\n    }\r\n\r\n    /** A set of QueryProjections, grouped by visualization property, and ordered within that property. */\r\n    export interface QueryProjectionsByRole {\r\n        [roleName: string]: QueryProjectionCollection;\r\n    }\r\n\r\n    export class QueryProjectionCollection {\r\n        private items: QueryProjection[];\r\n\r\n        /* The activeProjectionReference is an array that contains all the items that we are grouping on in case of a drillable\r\n           role. For example, if you have a drill role with [Country, State, City] and the user drilled to state, the active items\r\n           will include [Country and State]. This means that the query will group on both country and state and the state \"last item\"\r\n           is the item that the user drilled to.\r\n        */\r\n        private _activeProjectionRefs: string[];\r\n        private _showAll: boolean;\r\n\r\n        public constructor(items: QueryProjection[], activeProjectionRefs?: string[], showAll?: boolean) {\r\n            debug.assertValue(items, 'items');\r\n\r\n            this.items = items;\r\n            this._activeProjectionRefs = activeProjectionRefs;\r\n            this._showAll = showAll;\r\n        }\r\n\r\n        /** Returns all projections in a mutable array. */\r\n        public all(): QueryProjection[] {\r\n            return this.items;\r\n        }\r\n\r\n        public get activeProjectionRefs(): string[] {\r\n            return this._activeProjectionRefs;\r\n        }\r\n\r\n        public set activeProjectionRefs(queryReferences: string[]) {\r\n            if (!_.isEmpty(queryReferences)) {\r\n                let queryRefs = this.items.map(val => val.queryRef);\r\n\r\n                for (let queryReference of queryReferences) {\r\n                    if (!_.contains(queryRefs, queryReference))\r\n                        return;\r\n                }\r\n\r\n                this._activeProjectionRefs = queryReferences;\r\n            }\r\n        }\r\n\r\n        public get showAll(): boolean {\r\n            return this._showAll;\r\n        }\r\n\r\n        public set showAll(value: boolean) {\r\n            this._showAll = value;\r\n        }\r\n\r\n        public addActiveQueryReference(queryRef: string): void {\r\n            if (!this._activeProjectionRefs)\r\n                this._activeProjectionRefs = [queryRef];\r\n            else\r\n                this._activeProjectionRefs.push(queryRef);\r\n        }\r\n\r\n        public getLastActiveQueryReference(): string {\r\n            if (!_.isEmpty(this._activeProjectionRefs)) {\r\n                return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\r\n            }\r\n        }\r\n\r\n        /** Replaces the given oldQueryRef with newQueryRef in this QueryProjectionCollection. */\r\n        public replaceQueryRef(oldQueryRef: string, newQueryRef: string): void {\r\n            debug.assertValue(oldQueryRef, 'oldQueryRef');\r\n            debug.assertValue(newQueryRef, 'newQueryRef');\r\n            debug.assert(oldQueryRef !== newQueryRef, 'oldQueryRef !== newQueryRef');\r\n            debug.assert(_.isEmpty(this._activeProjectionRefs), 'replaceQueryRef(...) is not supported on the QueryProjectionCollection of a drillable role');\r\n\r\n            // Note: the same queryRef can get projected multiple times\r\n            for (let item of this.items) {\r\n                if (item.queryRef === oldQueryRef) {\r\n                    item.queryRef = newQueryRef;\r\n                }\r\n            }\r\n        }\r\n\r\n        public clone(): QueryProjectionCollection {\r\n            return new QueryProjectionCollection(_.cloneDeep(this.items), _.clone(this._activeProjectionRefs), this._showAll);\r\n        }\r\n    }\r\n\r\n    export module QueryProjectionsByRole {\r\n        /** Clones the QueryProjectionsByRole. */\r\n        export function clone(roles: QueryProjectionsByRole): QueryProjectionsByRole {\r\n            if (!roles)\r\n                return roles;\r\n\r\n            let clonedRoles: QueryProjectionsByRole = {};\r\n\r\n            for (let roleName in roles)\r\n                clonedRoles[roleName] = roles[roleName].clone();\r\n\r\n            return clonedRoles;\r\n        }\r\n\r\n        /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\r\n        export function getRole(roles: QueryProjectionsByRole, name: string): QueryProjectionCollection {\r\n            debug.assertAnyValue(roles, 'roles');\r\n            debug.assertValue(name, 'name');\r\n\r\n            if (!roles)\r\n                return;\r\n\r\n            return roles[name];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export interface VisualElement {\r\n        DataRoles?: DataRole[];\r\n        Settings?: VisualElementSettings;\r\n    }\r\n\r\n    /** Defines common settings for a visual element. */\r\n    export interface VisualElementSettings {\r\n        DisplayUnitSystemType?: DisplayUnitSystemType;\r\n    }\r\n\r\n    export interface DataRole {\r\n        Name: string;\r\n        Projection: number;\r\n        isActive?: boolean;\r\n    }\r\n\r\n    /** The system used to determine display units used during formatting */\r\n    export enum DisplayUnitSystemType {\r\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\r\n        Default,\r\n\r\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\r\n        Verbose,\r\n\r\n        /**\r\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\r\n         * Suitable for dashboard tile cards\r\n         */\r\n        WholeUnits,\r\n\r\n        /**A display unit system that also contains Auto and None units for data labels*/\r\n        DataLabels,\r\n    }\r\n}\r\n\r\nmodule powerbi.data.contracts {\r\n\r\n    export interface DataViewSource {\r\n        data: any;\r\n        type?: string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Repreasents the sequence of the dates/times */\r\n    export class DateTimeSequence {\r\n        // Constants\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;        \r\n\r\n        // Fields\r\n        public min: Date;\r\n        public max: Date;\r\n        public unit: DateTimeUnit;\r\n        public sequence: Date[];\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n\r\n        // Constructors\r\n        /** Creates new instance of the DateTimeSequence */\r\n        constructor(unit: DateTimeUnit) { \r\n            this.unit = unit;\r\n            this.sequence = [];\r\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\r\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Add a new Date to a sequence.\r\n         * @param date - date to add\r\n         */\r\n        public add(date: Date) { \r\n            if (date < this.min) { \r\n                this.min = date;\r\n            }\r\n            if (date > this.max) { \r\n                this.max = date;\r\n            }\r\n            this.sequence.push(date);\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Extends the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public extendToCover(min: Date, max: Date): void {\r\n            let x: Date = this.min;\r\n            while (min < x) {\r\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\r\n                this.sequence.splice(0, 0, x);\r\n            }\r\n            this.min = x;\r\n\r\n            x = this.max;\r\n            while (x < max) {\r\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\r\n                this.sequence.push(x);\r\n            }\r\n            this.max = x;\r\n        }\r\n\r\n        /** \r\n         * Move the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public moveToCover(min: Date, max: Date): void { \r\n            let delta: number = DateTimeSequence.getDelta(min, max, this.unit);\r\n            let count = Math.floor(delta / this.interval);\r\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\r\n\r\n            this.sequence = [];            \r\n            this.sequence.push(this.min);\r\n            this.max = this.min;\r\n            while (this.max < max) {\r\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\r\n                this.sequence.push(this.max);\r\n            }\r\n        }\r\n\r\n        // Static\r\n        /**\r\n         * Calculate a new DateTimeSequence\r\n         * @param dataMin - Date representing min of the data range\r\n         * @param dataMax - Date representing max of the data range\r\n         * @param expectedCount - expected number of intervals in the sequence\r\n         * @param unit - of the intervals in the sequence\r\n         */\r\n        public static calculate(dataMin: Date, dataMax: Date, expectedCount: number, unit?: DateTimeUnit): DateTimeSequence {\r\n            if (!unit) { \r\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\r\n            }\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Month:\r\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Week:\r\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Day:\r\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Hour:\r\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Minute:\r\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Second:\r\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\r\n                default:\r\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\r\n            }\r\n        }\r\n\r\n        public static calculateYears(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\r\n\r\n            // Calculate range and sequence\r\n            let yearsRange = NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\r\n\r\n            // Calculate year sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\r\n            let newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval; \r\n            let date = new Date(newMinYear, 0, 1);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Year);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMonths(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let minYear = dataMin.getFullYear();\r\n            let maxYear = dataMax.getFullYear();\r\n            let minMonth = dataMin.getMonth();\r\n            let maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\r\n            let date = new Date(minYear, 0, 1);\r\n            \r\n            // Calculate month sequence\r\n            let sequence = NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Month);\r\n            return result;\r\n        }\r\n\r\n        public static calculateWeeks(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            let firstDayOfWeek = 0;\r\n            let minDayOfWeek = dataMin.getDay();\r\n            let dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\r\n            let minDay = dataMin.getDate() - dayOffset;\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Week));\r\n\r\n            // Calculate week sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Week);\r\n            return result;\r\n        }\r\n\r\n        public static calculateDays(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, DateTimeUnit.Day));\r\n            \r\n            // Calculate day sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Day);\r\n            return result;\r\n        }\r\n\r\n        public static calculateHours(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Hour));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Hour));\r\n            \r\n            // Calculate hour sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Hour);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMinutes(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Minute));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Minute));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Minute);\r\n            return result;\r\n        }\r\n\r\n        public static calculateSeconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Second));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Second));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Second);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMilliseconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\r\n            let min = DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Millisecond);\r\n            let max = DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Millisecond);\r\n            \r\n            // Calculate milliseconds numeric sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(min, max), expectedCount, 0);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Millisecond);\r\n            return result;\r\n        }\r\n\r\n        public static addInterval(value: Date, interval: number, unit: DateTimeUnit): Date {\r\n            interval = Math.round(interval);\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return DateUtils.addYears(value, interval);\r\n                case DateTimeUnit.Month:\r\n                    return DateUtils.addMonths(value, interval);\r\n                case DateTimeUnit.Week:\r\n                    return DateUtils.addWeeks(value, interval);\r\n                case DateTimeUnit.Day:\r\n                    return DateUtils.addDays(value, interval);\r\n                case DateTimeUnit.Hour:\r\n                    return DateUtils.addHours(value, interval);\r\n                case DateTimeUnit.Minute:\r\n                    return DateUtils.addMinutes(value, interval);\r\n                case DateTimeUnit.Second:\r\n                    return DateUtils.addSeconds(value, interval);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateUtils.addMilliseconds(value, interval);\r\n            }\r\n        }\r\n\r\n        private static fromNumericSequence(date: Date, sequence: NumericSequence, unit: DateTimeUnit) { \r\n            let result = new DateTimeSequence(unit);\r\n            for (let i = 0; i < sequence.sequence.length; i++) { \r\n                let x: number = sequence.sequence[i];\r\n                let d: Date = DateTimeSequence.addInterval(date, x, unit);\r\n                result.add(d);\r\n            }\r\n            result.interval = sequence.interval;\r\n            result.intervalOffset = sequence.intervalOffset;\r\n            return result;\r\n        }\r\n\r\n        private static getDelta(min: Date, max: Date, unit: DateTimeUnit): number {\r\n            let delta: number = 0;\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    delta = max.getFullYear() - min.getFullYear();\r\n                    break;\r\n                case DateTimeUnit.Month:\r\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\r\n                    break;\r\n                case DateTimeUnit.Week:\r\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Day:\r\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Hour:\r\n                    delta = (max.getTime() - min.getTime()) / 3600000;\r\n                    break;\r\n                case DateTimeUnit.Minute:\r\n                    delta = (max.getTime() - min.getTime()) / 60000;\r\n                    break;\r\n                case DateTimeUnit.Second:\r\n                    delta = (max.getTime() - min.getTime()) / 1000;\r\n                    break;\r\n                case DateTimeUnit.Millisecond:\r\n                    delta = max.getTime() - min.getTime();\r\n                    break;\r\n            }\r\n            return delta;\r\n        }\r\n\r\n        public static getIntervalUnit(min:Date, max:Date, maxCount: number): DateTimeUnit {\r\n            maxCount = Math.max(maxCount, 2);\r\n            let totalDays = DateTimeSequence.getDelta(min, max, DateTimeUnit.Day);\r\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\r\n                return DateTimeUnit.Year;\r\n            if (totalDays > 60 && totalDays > 7 * maxCount)\r\n                return DateTimeUnit.Month;\r\n            if (totalDays > 14 && totalDays > 2 * maxCount)\r\n                return DateTimeUnit.Week;\r\n            let totalHours = DateTimeSequence.getDelta(min, max, DateTimeUnit.Hour);\r\n            if (totalDays > 2 && totalHours > 12 * maxCount)\r\n                return DateTimeUnit.Day;\r\n            if (totalHours >= 24 && totalHours >= maxCount)\r\n                return DateTimeUnit.Hour;\r\n            let totalMinutes = DateTimeSequence.getDelta(min, max, DateTimeUnit.Minute);\r\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\r\n                return DateTimeUnit.Minute;\r\n            let totalSeconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Second);\r\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\r\n                return DateTimeUnit.Second;\r\n            let totalMilliseconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Millisecond);\r\n            if (totalMilliseconds > 0)\r\n                return DateTimeUnit.Millisecond;\r\n  \r\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\r\n            let date = min;\r\n            if (date.getMilliseconds() !== 0)\r\n                return DateTimeUnit.Millisecond;\r\n            if (date.getSeconds() !== 0)\r\n                return DateTimeUnit.Second;\r\n            if (date.getMinutes() !== 0)\r\n                return DateTimeUnit.Minute;\r\n            if (date.getHours() !== 0)\r\n                return DateTimeUnit.Hour;\r\n            if (date.getDate() !== 1)\r\n                return DateTimeUnit.Day;\r\n            if (date.getMonth() !== 0)\r\n                return DateTimeUnit.Month;\r\n            \r\n            return DateTimeUnit.Year;\r\n        }\r\n    }\r\n\r\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\r\n    export module DateUtils { \r\n        let MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n        let MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n\r\n        /**\r\n         * Returns bool indicating weither the provided year is a leap year.\r\n         * @param year - year value\r\n         */\r\n        function isLeap(year: number): boolean { \r\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\r\n        }\r\n\r\n        /** \r\n         * Returns number of days in the provided year/month.\r\n         * @param year - year value\r\n         * @param month - month value\r\n         */\r\n        function getMonthDays(year: number, month: number) { \r\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of years to the provided date.\r\n         * @param date - date value\r\n         * @param yearDelta - number of years to add\r\n         */\r\n        export function addYears(date: Date, yearDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n            let isLeapDay = month === 2 && day === 29;\r\n\r\n            let result = new Date(date.getTime());\r\n            year = year + yearDelta;\r\n            if (isLeapDay && !isLeap(year)) {\r\n                day = 28;\r\n            } \r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of months to the provided date.\r\n         * @param date - date value\r\n         * @param monthDelta - number of months to add\r\n         */\r\n        export function addMonths(date: Date, monthDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n           \r\n            let result = new Date(date.getTime());\r\n            year += (monthDelta - (monthDelta % 12)) / 12;\r\n            month += monthDelta % 12;\r\n\r\n            // VSTS 1325771: Certain column charts don't display any data\r\n            // Wrap arround the month if is after december (value 11)\r\n            if (month > 11) {\r\n                month = month % 12;\r\n                year++;\r\n            }\r\n\r\n            day = Math.min(day, getMonthDays(year, month));\r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of weeks to the provided date.\r\n         * @param date - date value\r\n         * @param weeks - number of weeks to add\r\n         */\r\n        export function addWeeks(date: Date, weeks: number): Date { \r\n            return addDays(date, weeks * 7);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of days to the provided date.\r\n         * @param date - date value\r\n         * @param days - number of days to add\r\n         */\r\n        export function addDays(date: Date, days: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();           \r\n            let result = new Date(date.getTime());\r\n            result.setFullYear(year, month, day + days);\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of hours to the provided date.\r\n         * @param date - date value\r\n         * @param hours - number of hours to add\r\n         */\r\n        export function addHours(date: Date, hours: number): Date { \r\n            return new Date(date.getTime() + hours * 3600000);\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of minutes to the provided date.\r\n         * @param date - date value\r\n         * @param minutes - number of minutes to add\r\n         */\r\n        export function addMinutes(date: Date, minutes: number): Date { \r\n            return new Date(date.getTime() + minutes * 60000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of seconds to the provided date.\r\n         * @param date - date value\r\n         * @param seconds - number of seconds to add\r\n         */\r\n        export function addSeconds(date: Date, seconds: number): Date { \r\n            return new Date(date.getTime() + seconds * 1000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of milliseconds to the provided date.\r\n         * @param date - date value\r\n         * @param milliseconds - number of milliseconds to add\r\n         */\r\n        export function addMilliseconds(date: Date, milliseconds: number): Date { \r\n            return new Date(date.getTime() + milliseconds);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    // Constants\r\n    const maxExponent = 24;\r\n    const defaultScientificBigNumbersBoundary = 1E15;\r\n    const scientificSmallNumbersBoundary = 1E-4;\r\n    const PERCENTAGE_FORMAT = '%';\r\n    const SCIENTIFIC_FORMAT = 'E+0';\r\n    const DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\r\n\r\n    // Regular expressions\r\n    /**\r\n     * This regex looks for strings that match one of the following conditions:\r\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\r\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\r\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\r\n     * The entire string (start to end) must match, and the match is not case-sensitive.\r\n     */\r\n    const SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\r\n\r\n    export class DisplayUnit {\r\n        // Fields\r\n        public value: number;\r\n        public title: string;\r\n        public labelFormat: string;\r\n        public applicableRangeMin: number;\r\n        public applicableRangeMax: number;\r\n\r\n        // Methods\r\n        public project(value: number): number {\r\n            if (this.value) {\r\n                return Double.removeDecimalNoise(value / this.value);\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public reverseProject(value: number): number {\r\n            if (this.value) {\r\n                return value * this.value;\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public isApplicableTo(value: number): boolean {\r\n            value = Math.abs(value);\r\n            let precision = Double.getPrecision(value, 3);\r\n            return Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && Double.lessWithPrecision(value, this.applicableRangeMax, precision);\r\n        }\r\n\r\n        public isScaling(): boolean {\r\n            return this.value > 1;\r\n        }\r\n    }\r\n\r\n    export class DisplayUnitSystem {\r\n        // Fields\r\n        public units: DisplayUnit[];\r\n        public displayUnit: DisplayUnit;\r\n        private unitBaseValue: number;\r\n        protected static UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\r\n\r\n        // Constructor\r\n        constructor(units?: DisplayUnit[]) {\r\n            this.units = units ? units : [];\r\n        }\r\n\r\n        // Properties\r\n        public get title(): string {\r\n            return this.displayUnit ? this.displayUnit.title : undefined;\r\n        }\r\n\r\n        // Methods\r\n        public update(value: number): void {\r\n            if (value === undefined)\r\n                return;\r\n\r\n            this.unitBaseValue = value;\r\n            this.displayUnit = this.findApplicableDisplayUnit(value);\r\n        }\r\n\r\n        private findApplicableDisplayUnit(value: number): DisplayUnit {\r\n            for (let unit of this.units) {\r\n                if (unit.isApplicableTo(value))\r\n                    return unit;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        public format(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n            if (this.isFormatSupported(format)) {\r\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\r\n\r\n                if (this.hasScientitifcFormat(format)) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\r\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\r\n                }\r\n                if (decimals != null) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n            }\r\n            \r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        public isPercentageFormat(format: string): boolean {\r\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\r\n        }\r\n\r\n        public shouldRespectScalingUnit(format: string): boolean {\r\n            return !this.isPercentageFormat(format);\r\n        }\r\n\r\n        public getNumberOfDecimalsForFormatting(format: string, decimals?: number) {\r\n            return decimals;\r\n        }\r\n\r\n        public isScalingUnit(): boolean {\r\n            return this.displayUnit && this.displayUnit.isScaling();\r\n        }\r\n\r\n        private formatHelper(value: number, nonScientificFormat: string, format: string, decimals?: number, trailingZeros?: boolean) {\r\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\r\n            if ((format === 'g' || format === 'G') && decimals != null)\r\n                format = visuals.valueFormatter.DefaultNumericFormat;\r\n\r\n            format = NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\r\n\r\n            if (format && !formattingService.isStandardNumberFormat(format))\r\n                return formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\r\n\r\n            if (!format)\r\n                format = 'G';\r\n            if (!nonScientificFormat)\r\n                nonScientificFormat = '{0}';\r\n\r\n            let text = formattingService.formatValue(value, format);\r\n            return formattingService.format(nonScientificFormat, [text]);\r\n        }\r\n\r\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\r\n        public formatSingleValue(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            // Change unit base to a value appropriate for this value\r\n            this.update(this.shouldUseValuePrecision(value) ? Double.getPrecision(value, 8) : value);\r\n\r\n            return this.format(value, format, decimals, trailingZeros);\r\n        }\r\n\r\n        private shouldUseValuePrecision(value: number): boolean {\r\n            if (this.units.length === 0)\r\n                return true;\r\n\r\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\r\n            let applicableRangeMin: number = 0;\r\n            for (let i = 0; i < this.units.length; i++) {\r\n                if (this.units[i].isScaling()) {\r\n                    applicableRangeMin = this.units[i].applicableRangeMin;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return Math.abs(value) < applicableRangeMin;\r\n        }\r\n\r\n        protected isScientific(value: number): boolean {\r\n            return value < - defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\r\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\r\n        }\r\n\r\n        protected hasScientitifcFormat(format: string): boolean {\r\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\r\n        }\r\n\r\n        protected supportsScientificFormat(format: string): boolean {\r\n            if (format)\r\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\r\n\r\n            return true;\r\n        }\r\n\r\n        protected shouldFallbackToScientific(value: number, format: string): boolean {\r\n            return !this.hasScientitifcFormat(format)\r\n                && this.supportsScientificFormat(format)\r\n                && this.isScientific(value);\r\n        }\r\n\r\n        protected getScientificFormat(data: number, format: string, decimals: number, trailingZeros: boolean): string {\r\n            // Use scientific format outside of the range\r\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\r\n                let numericFormat = NumberFormat.getNumericFormat(data, format);\r\n                if (decimals)\r\n                    numericFormat = NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\r\n\r\n                if (numericFormat)\r\n                    return numericFormat + SCIENTIFIC_FORMAT;\r\n                else\r\n                    return DEFAULT_SCIENTIFIC_FORMAT;\r\n            }\r\n\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\r\n    export class NoDisplayUnitSystem extends DisplayUnitSystem {\r\n        // Constructor\r\n        constructor() {\r\n            super([]);\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\r\n        we are showing values (chart axes) and as such it is the default unit system. */\r\n    export class DefaultDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DefaultDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        // Methods\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n\r\n        public static reset(): void {\r\n            DefaultDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DefaultDisplayUnitSystem.units) {\r\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, (value: number, previousUnitValue: number, min: number) => {\r\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\r\n                    if (value - previousUnitValue >= 1000) {\r\n                        return value / 10;\r\n                    }\r\n\r\n                    return min;\r\n                });\r\n\r\n                // Ensure last unit has max of infinity\r\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DefaultDisplayUnitSystem.units;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\r\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\r\n        where we have restricted space but do not want to show partial units. */\r\n    export class WholeUnitsDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public static reset(): void {\r\n            WholeUnitsDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!WholeUnitsDisplayUnitSystem.units) {\r\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\r\n\r\n                // Ensure last unit has max of infinity\r\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n\r\n            return WholeUnitsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export class DataLabelsDisplayUnitSystem extends DisplayUnitSystem {\r\n\r\n        // Constants\r\n        private static AUTO_DISPLAYUNIT_VALUE = 0;\r\n        private static NONE_DISPLAYUNIT_VALUE = 1;\r\n        protected static UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\r\n\r\n        private static units: DisplayUnit[];\r\n\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DataLabelsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DataLabelsDisplayUnitSystem.units) {\r\n                let units = [];\r\n                let adjustMinBasedOnPreviousUnit = (value: number, previousUnitValue: number, min: number): number => {\r\n                    // Never returns true, we are always ignoring\r\n                    // We do not early switch (e.g. 100K instead of 0.1M)\r\n                    // Intended? If so, remove this function, otherwise, remove if statement\r\n                    if (value === -1)\r\n                        if (value - previousUnitValue >= 1000) {\r\n                            return value / 10;\r\n                        }\r\n                    return min;\r\n                };\r\n\r\n                // Add Auto & None\r\n                let names = unitLookup(-1);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                names = unitLookup(0);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                // Add normal units\r\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\r\n\r\n                // Ensure last unit has max of infinity\r\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DataLabelsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export interface DisplayUnitSystemNames {\r\n        title: string;\r\n        format: string;\r\n    }\r\n\r\n    function createDisplayUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames, adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number) {\r\n        let units = [];\r\n        for (let i = 3; i < maxExponent; i++) {\r\n            let names = unitLookup(i);\r\n            if (names)\r\n                addUnitIfNonEmpty(units, Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n        }\r\n\r\n        return units;\r\n    }\r\n\r\n    function addUnitIfNonEmpty(\r\n        units: DisplayUnit[],\r\n        value: number,\r\n        title: string,\r\n        labelFormat: string,\r\n        adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number): void {\r\n        if (title || labelFormat) {\r\n            let min = value;\r\n\r\n            if (units.length > 0) {\r\n                let previousUnit = units[units.length - 1];\r\n\r\n                if (adjustMinBasedOnPreviousUnit)\r\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\r\n\r\n                previousUnit.applicableRangeMax = min;\r\n            }\r\n            let unit = new DisplayUnit();\r\n            unit.value = value;\r\n            unit.applicableRangeMin = min;\r\n            unit.applicableRangeMax = min * 1000;\r\n            unit.title = title;\r\n            unit.labelFormat = labelFormat;\r\n            units.push(unit);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequence {\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;\r\n\r\n        private maxAllowedMargin: number;\r\n        private canExtendMin: boolean;\r\n        private canExtendMax: boolean;\r\n\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n        public min: number;\r\n        public max: number;\r\n        public precision: number;\r\n        public sequence: number[];\r\n\r\n        public static calculate (range: NumericSequenceRange, expectedCount: number, maxAllowedMargin?: number, minPower?: number, useZeroRefPoint?: boolean, steps?: number[]): NumericSequence {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\r\n            debug.assert(minPower === undefined|| (minPower >= Double.MIN_EXP && minPower <= Double.MAX_EXP), \"minPower\");\r\n            debug.assert(maxAllowedMargin === undefined|| (maxAllowedMargin >= 0), \"maxAllowedMargin\");\r\n\r\n            let result = new NumericSequence();\r\n\r\n            if (expectedCount === undefined)\r\n                expectedCount = 10;\r\n            else\r\n                expectedCount = Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (minPower === undefined)\r\n                minPower = Double.MIN_EXP;\r\n            if (useZeroRefPoint === undefined)\r\n                useZeroRefPoint = false;\r\n            if (maxAllowedMargin === undefined)\r\n                maxAllowedMargin = 1;\r\n            if (steps === undefined)\r\n                steps = [1, 2, 5];\r\n\r\n            // Handle single stop case\r\n            if (range.forcedSingleStop) {\r\n                result.interval = range.getSize();\r\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\r\n                result.min = range.min;\r\n                result.max = range.max;\r\n                result.sequence = [range.forcedSingleStop];\r\n                return result;\r\n            }\r\n\r\n            let interval = 0;\r\n            let min = 0;\r\n            let max = 9;\r\n            let canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\r\n            let canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\r\n\r\n            let size = range.getSize();\r\n            let exp = Double.log10(size);\r\n\r\n            // Account for Exp of steps\r\n            let stepExp = Double.log10(steps[0]);\r\n            exp = exp - stepExp;\r\n\r\n            // Account for MaxCount\r\n            let expectedCountExp = Double.log10(expectedCount);\r\n            exp = exp - expectedCountExp;\r\n\r\n            // Account for MinPower\r\n            exp = Math.max(exp, minPower - stepExp + 1);\r\n            let count = undefined;\r\n            // Create array of \"good looking\" numbers\r\n            if (interval !== 0) {\r\n                // If explicit interval is defined - use it instead of the steps array.\r\n                let power = Double.pow10(exp);\r\n                let roundMin = Double.floorToPrecision(range.min, power);\r\n                let roundMax = Double.ceilToPrecision(range.max, power);\r\n                let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\r\n\r\n                roundRange.shrinkByStep(range, interval);\r\n                min = roundRange.min;\r\n                max = roundRange.max;\r\n                count = Math.floor(roundRange.getSize() / interval);\r\n            }\r\n            else {\r\n                // No interval defined -> find optimal interval\r\n                let dexp;\r\n                for (dexp = 0; dexp < 3; dexp++) {\r\n                    let e = exp + dexp;\r\n                    let power = Double.pow10(e);\r\n\r\n                    let roundMin = Double.floorToPrecision(range.min, power);\r\n                    let roundMax = Double.ceilToPrecision(range.max, power);\r\n\r\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\r\n                    let stepsCount = steps.length;\r\n                    let stepPower = Double.pow10(e - 1);\r\n                    for (let i = 0; i < stepsCount; i++) {\r\n                        let step = steps[i] * stepPower;\r\n                        let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\r\n                        roundRange.shrinkByStep(range, step);\r\n\r\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\r\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\r\n                            roundRange.min -= step;\r\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\r\n                            roundRange.max += step;\r\n\r\n                        // Count the intervals\r\n                        count = Double.ceilWithPrecision(roundRange.getSize() / step);\r\n\r\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\r\n                            interval = step;\r\n                            min = roundRange.min;\r\n                            max = roundRange.max;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // Increase the scale power until the interval is found\r\n                    if (interval !== 0)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Avoid extreme count cases (>1000 ticks)\r\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\r\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\r\n                interval = (max - min) / count;\r\n            }\r\n\r\n            result.min = min;\r\n            result.max = max;\r\n            result.interval = interval;\r\n            result.intervalOffset = min - range.min;\r\n            result.maxAllowedMargin = maxAllowedMargin;\r\n            result.canExtendMin = canExtendMin;\r\n            result.canExtendMax = canExtendMax;\r\n\r\n            // Fill in the Sequence\r\n            let precision = Double.getPrecision(interval, 0);\r\n            result.precision = precision;\r\n\r\n            let sequence = [];\r\n\r\n            let x = Double.roundToPrecision(min, precision);\r\n            sequence.push(x);\r\n            for (let i = 0; i < count; i++) {\r\n                x = Double.roundToPrecision(x + interval, precision);\r\n                sequence.push(x);\r\n            }\r\n            \r\n            result.sequence = sequence;\r\n\r\n            result.trimMinMax(range.min, range.max);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid. \r\n         * @min - The minimum of the range.\r\n         * @max - The maximum of the range.\r\n         * @maxCount - The max count of intervals.\r\n         * @steps - array of intervals.\r\n         */\r\n        public static calculateUnits(min: number, max: number, maxCount: number, steps: number[]): NumericSequence {\r\n            // Initialization actions\r\n            maxCount = Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (min === max) {\r\n                max = min + 1;\r\n            }\r\n            let stepCount = 0;\r\n            let step = 0;\r\n\r\n            // Calculate step\r\n            for (let i = 0; i < steps.length; i++)\r\n            {\r\n                step = steps[i];\r\n                let maxStepCount = Double.ceilWithPrecision(max / step);\r\n                let minStepCount = Double.floorWithPrecision(min / step);\r\n                stepCount = maxStepCount - minStepCount;\r\n                    \r\n                if (stepCount <= maxCount) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Calculate the offset\r\n            let offset = -min;\r\n            offset = offset % step;\r\n\r\n            // Create sequence\r\n            let result = new NumericSequence();\r\n            result.sequence = [];\r\n            for (let x = min + offset; ; x += step)\r\n            {\r\n                result.sequence.push(x);\r\n                if (x >= max)\r\n                    break;\r\n            }\r\n            result.interval = step;\r\n            result.intervalOffset = offset;\r\n            result.min = result.sequence[0];\r\n            result.max = result.sequence[result.sequence.length - 1];\r\n            return result;\r\n        }\r\n\r\n        public trimMinMax(min: number, max: number): void {        \r\n            let minMargin = (min - this.min) / this.interval;\r\n            let maxMargin = (this.max - max) / this.interval;\r\n            let marginPrecision = 0.001;\r\n\r\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\r\n                this.min = min;\r\n            }\r\n\r\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\r\n                this.max = max;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequenceRange {\r\n        private static DEFAULT_MAX: number = 10;\r\n        private static MIN_SUPPORTED_DOUBLE = -1E307;\r\n        private static MAX_SUPPORTED_DOUBLE = 1E307;\r\n\r\n        public min: number;\r\n        public max: number;\r\n        public includeZero: boolean;\r\n        public forcedSingleStop: number;\r\n        public hasDataRange: boolean;\r\n        public hasFixedMin: boolean;\r\n        public hasFixedMax: boolean;\r\n\r\n        private _ensureIncludeZero(): void { \r\n            if (this.includeZero) {\r\n                // fixed min and max has higher priority than includeZero\r\n                if (this.min > 0 && !this.hasFixedMin) {\r\n                    this.min = 0;\r\n                }\r\n                if (this.max < 0 && !this.hasFixedMax) {\r\n                    this.max = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureNotEmpty(): void { \r\n            if (this.min === this.max) {\r\n                if (!this.min) {\r\n                    this.min = 0;\r\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\r\n                    this.hasFixedMin = true;\r\n                    this.hasFixedMax = true;\r\n                } else {\r\n                    // We are dealing with a single data value (includeZero is not set)\r\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\r\n                    // Interval is calculated based on the number:\r\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\r\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\r\n                    let value = this.min;\r\n                    let exp = Double.log10(Math.abs(value));\r\n                    let step: number;\r\n                    if (exp >= 0 && exp < 4) {\r\n                        step = 0.5;\r\n                        this.forcedSingleStop = value;\r\n                    } else {\r\n                        step = Double.pow10(exp) / 2;\r\n                        this.forcedSingleStop = null;\r\n                    }\r\n                    this.min = value - step;\r\n                    this.max = value + step;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureDirection() { \r\n            if (this.min > this.max) { \r\n                let temp = this.min;\r\n                this.min = this.max;\r\n                this.max = temp;\r\n            }\r\n        }\r\n\r\n        public getSize(): number {\r\n            return this.max - this.min;\r\n        }\r\n\r\n        public shrinkByStep(range: NumericSequenceRange, step: number) {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(step > 0, \"step\");\r\n\r\n            let oldCount = this.min / step;\r\n            let newCount = range.min / step;\r\n            let deltaCount = Math.floor(newCount - oldCount);\r\n            this.min += deltaCount * step;\r\n\r\n            oldCount = this.max / step;\r\n            newCount = range.max / step;\r\n            deltaCount = Math.ceil(newCount - oldCount);\r\n            this.max += deltaCount * step;\r\n        }\r\n\r\n        public static calculate(dataMin: number, dataMax: number, fixedMin?:number, fixedMax?:number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\r\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.includeZero = includeZero ? true : false;\r\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\r\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\r\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\r\n\r\n            dataMin = Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n            dataMax = Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n\r\n            // Calculate the range using the min, max, dataRange\r\n            if (result.hasFixedMin && result.hasFixedMax) {\r\n                result.min = fixedMin;\r\n                result.max = fixedMax;\r\n            } else if (result.hasFixedMin) {\r\n                result.min = fixedMin;\r\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\r\n            } else if (result.hasFixedMax) {\r\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\r\n                result.max = fixedMax;\r\n            } else if (result.hasDataRange) {\r\n                result.min = dataMin;\r\n                result.max = dataMax;\r\n            } else {\r\n                result.min = 0;\r\n                result.max = 0;\r\n            }\r\n\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            \r\n            if (result.min === 0) {\r\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\r\n            } else if (result.max === 0) {\r\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public static calculateDataRange(dataMin: number, dataMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\r\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\r\n            } else {\r\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\r\n            }\r\n        }\r\n\r\n        public static calculateFixedRange(fixedMin: number, fixedMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assertValue(fixedMin, \"fixedMin\");\r\n            debug.assertValue(fixedMax, \"fixedMax\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.hasDataRange = false;\r\n            result.includeZero = includeZero;\r\n            result.min = fixedMin;\r\n            result.max = fixedMax;\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            result.hasFixedMin = true;\r\n            result.hasFixedMax = true;\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export module ValueUtil {\r\n        export function hasValue(value: any): boolean {\r\n            return value !== undefined && value !== null;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n\r\n    /**\r\n     * Formats the value using provided format expression\r\n     * @param value - value to be formatted and converted to string.\r\n     * @param format - format to be applied if the number shouldn't be abbreviated.\r\n     * If the number should be abbreviated this string is checked for special characters like $ or % if any\r\n     */\r\n    export interface ICustomValueFormatter {\r\n        (value: any, format?: string): string;\r\n    }\r\n\r\n    export interface ICustomValueColumnFormatter {\r\n        (value: any,\r\n            column: DataViewMetadataColumn,\r\n            formatStringProp: DataViewObjectPropertyIdentifier,\r\n            nullsAreBlank?: boolean): string;\r\n    }\r\n\r\n    export interface ValueFormatterOptions {\r\n        /** The format string to use. */\r\n        format?: string;\r\n\r\n        /** The data value. */\r\n        value?: any;\r\n\r\n        /** The data value. */\r\n        value2?: any;\r\n\r\n        /** The number of ticks. */\r\n        tickCount?: any;\r\n\r\n        /** The display unit system to use */\r\n        displayUnitSystemType?: DisplayUnitSystemType;\r\n\r\n        /** True if we are formatting single values in isolation (e.g. card), as opposed to multiple values with a common base (e.g. chart axes) */\r\n        formatSingleValues?: boolean;\r\n\r\n        /** True if we want to trim off unnecessary zeroes after the decimal and remove a space before the % symbol */\r\n        allowFormatBeautification?: boolean;\r\n\r\n        /** Specifies the maximum number of decimal places to show*/\r\n        precision?: number;\r\n\r\n        /** Detect axis precision based on value */\r\n        detectAxisPrecision?: boolean;\r\n\r\n        /** Specifies the column type of the data value */\r\n        columnType?: ValueTypeDescriptor;\r\n    }\r\n\r\n    export interface IValueFormatter {\r\n        format(value: any): string;\r\n        displayUnit?: DisplayUnit;\r\n        options?: ValueFormatterOptions;\r\n    }\r\n\r\n    /** Captures all locale-specific options used by the valueFormatter. */\r\n    export interface ValueFormatterLocalizationOptions {\r\n        null: string;\r\n        true: string;\r\n        false: string;\r\n        NaN: string;\r\n        infinity: string;\r\n        negativeInfinity: string;\r\n\r\n        /** Returns a beautified form the given format string. */\r\n        beautify(format: string): string;\r\n\r\n        /** Returns an object describing the given exponent in the current language. */\r\n        describe(exponent: number): DisplayUnitSystemNames;\r\n        restatementComma: string;\r\n        restatementCompoundAnd: string;\r\n        restatementCompoundOr: string;\r\n    }\r\n\r\n    export module valueFormatter {\r\n        import StringExtensions = jsCommon.StringExtensions;\r\n        const BeautifiedFormat: { [x: string]: string } = {\r\n            '0.00 %;-0.00 %;0.00 %': 'Percentage',\r\n            '0.0 %;-0.0 %;0.0 %': 'Percentage1',\r\n        };\r\n\r\n        export const DefaultIntegerFormat = 'g';\r\n        export const DefaultNumericFormat = '#,0.00';\r\n        export const DefaultDateFormat = 'd';\r\n\r\n        const defaultLocalizedStrings = {\r\n            'NullValue': '(Blank)',\r\n            'BooleanTrue': 'True',\r\n            'BooleanFalse': 'False',\r\n            'NaNValue': 'NaN',\r\n            'InfinityValue': '+Infinity',\r\n            'NegativeInfinityValue': '-Infinity',\r\n            'RestatementComma': '{0}, {1}',\r\n            'RestatementCompoundAnd': '{0} and {1}',\r\n            'RestatementCompoundOr': '{0} or {1}',\r\n            'DisplayUnitSystem_EAuto_Title': 'Auto',\r\n            'DisplayUnitSystem_E0_Title': 'None',\r\n            'DisplayUnitSystem_E3_LabelFormat': '{0}K',\r\n            'DisplayUnitSystem_E3_Title': 'Thousands',\r\n            'DisplayUnitSystem_E6_LabelFormat': '{0}M',\r\n            'DisplayUnitSystem_E6_Title': 'Millions',\r\n            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\r\n            'DisplayUnitSystem_E9_Title': 'Billions',\r\n            'DisplayUnitSystem_E12_LabelFormat': '{0}T',\r\n            'DisplayUnitSystem_E12_Title': 'Trillions',\r\n            'Percentage': '#,0.##%',\r\n            'Percentage1': '#,0.#%',\r\n            'TableTotalLabel': 'Total',\r\n            'Tooltip_HighlightedValueDisplayName': 'Highlighted',\r\n            'Funnel_PercentOfFirst': 'Percent of first',\r\n            'Funnel_PercentOfPrevious': 'Percent of previous',\r\n            'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlighted)',\r\n            'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlighted)',\r\n            // Geotagging strings\r\n            'GeotaggingString_Continent': 'continent',\r\n            'GeotaggingString_Continents': 'continents',\r\n            'GeotaggingString_Country': 'country',\r\n            'GeotaggingString_Countries': 'countries',\r\n            'GeotaggingString_State': 'state',\r\n            'GeotaggingString_States': 'states',\r\n            'GeotaggingString_City': 'city',\r\n            'GeotaggingString_Cities': 'cities',\r\n            'GeotaggingString_Town': 'town',\r\n            'GeotaggingString_Towns': 'towns',\r\n            'GeotaggingString_Province': 'province',\r\n            'GeotaggingString_Provinces': 'provinces',\r\n            'GeotaggingString_County': 'county',\r\n            'GeotaggingString_Counties': 'counties',\r\n            'GeotaggingString_Village': 'village',\r\n            'GeotaggingString_Villages': 'villages',\r\n            'GeotaggingString_Post': 'post',\r\n            'GeotaggingString_Zip': 'zip',\r\n            'GeotaggingString_Code': 'code',\r\n            'GeotaggingString_Place': 'place',\r\n            'GeotaggingString_Places': 'places',\r\n            'GeotaggingString_Address': 'address',\r\n            'GeotaggingString_Addresses': 'addresses',\r\n            'GeotaggingString_Street': 'street',\r\n            'GeotaggingString_Streets': 'streets',\r\n            'GeotaggingString_Longitude': 'longitude',\r\n            'GeotaggingString_Longitude_Short': 'lon',\r\n            'GeotaggingString_Latitude': 'latitude',\r\n            'GeotaggingString_Latitude_Short': 'lat',\r\n            'GeotaggingString_PostalCode': 'postal code',\r\n            'GeotaggingString_PostalCodes': 'postal codes',\r\n            'GeotaggingString_ZipCode': 'zip code',\r\n            'GeotaggingString_ZipCodes': 'zip codes',\r\n            'GeotaggingString_Territory': 'territory',\r\n            'GeotaggingString_Territories': 'territories',\r\n        };\r\n\r\n        function beautify(format: string): string {\r\n            let key = BeautifiedFormat[format];\r\n            if (key)\r\n                return defaultLocalizedStrings[key] || format;\r\n            return format;\r\n        }\r\n\r\n        function describeUnit(exponent: number): DisplayUnitSystemNames {\r\n            let exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\r\n\r\n            let title: string = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\r\n            let format: string = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\r\n\r\n            if (title || format)\r\n                return { title: title, format: format };\r\n        }\r\n\r\n        export function getLocalizedString(stringId: string): string {\r\n            return defaultLocalizedStrings[stringId];\r\n        }\r\n\r\n        // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\r\n        let locale: ValueFormatterLocalizationOptions = {\r\n            null: defaultLocalizedStrings['NullValue'],\r\n            true: defaultLocalizedStrings['BooleanTrue'],\r\n            false: defaultLocalizedStrings['BooleanFalse'],\r\n            NaN: defaultLocalizedStrings['NaNValue'],\r\n            infinity: defaultLocalizedStrings['InfinityValue'],\r\n            negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\r\n            beautify: format => beautify(format),\r\n            describe: exponent => describeUnit(exponent),\r\n            restatementComma: defaultLocalizedStrings['RestatementComma'],\r\n            restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\r\n            restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\r\n        };\r\n\r\n        const MaxScaledDecimalPlaces = 2;\r\n        const MaxValueForDisplayUnitRounding = 1000;\r\n        const MinIntegerValueForDisplayUnits = 10000;\r\n        const MinPrecisionForDisplayUnits = 2;\r\n\r\n        const DateTimeMetadataColumn: DataViewMetadataColumn = {\r\n            displayName: '',\r\n            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),\r\n        };\r\n\r\n        export function getFormatMetadata(format: string): powerbi.NumberFormat.NumericFormatMetadata {\r\n            return powerbi.NumberFormat.getCustomFormatMetadata(format);\r\n        }\r\n\r\n        export function setLocaleOptions(options: ValueFormatterLocalizationOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            locale = options;\r\n\r\n            DefaultDisplayUnitSystem.reset();\r\n            WholeUnitsDisplayUnitSystem.reset();\r\n        }\r\n\r\n        export function createDefaultFormatter(formatString: string, allowFormatBeautification: boolean = false): IValueFormatter {\r\n            let formatBeaut: string = allowFormatBeautification ? locale.beautify(formatString) : formatString;\r\n            return {\r\n                format: function (value: any): string {\r\n                    if (value == null)\r\n                        return locale.null;\r\n\r\n                    return formatCore(value, formatBeaut);\r\n                }\r\n            };\r\n        }\r\n\r\n        /** Creates an IValueFormatter to be used for a range of values. */\r\n        export function create(options: ValueFormatterOptions): IValueFormatter {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\r\n\r\n            if (shouldUseNumericDisplayUnits(options)) {\r\n                let displayUnitSystem = createDisplayUnitSystem(options.displayUnitSystemType);\r\n\r\n                let singleValueFormattingMode = !!options.formatSingleValues;\r\n\r\n                displayUnitSystem.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\r\n\r\n                let forcePrecision = options.precision != null;\r\n\r\n                let decimals: number;\r\n\r\n                if (forcePrecision)\r\n                    decimals = -options.precision;\r\n                else if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 1)\r\n                    decimals = -MaxScaledDecimalPlaces;\r\n\r\n                // Detect axis precision\r\n                if (options.detectAxisPrecision) {\r\n                    // Trailing zeroes\r\n                    forcePrecision = true;\r\n\r\n                    let axisValue = options.value;\r\n                    if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 0)\r\n                        axisValue = axisValue / displayUnitSystem.displayUnit.value;\r\n\r\n                    if (Double.isInteger(axisValue))\r\n                        decimals = 0;\r\n                    else\r\n                        decimals = Double.log10(axisValue);\r\n                }\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        let formattedValue: string = getStringFormat(value, true /*nullsAreBlank*/);\r\n                        if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                            return formattedValue;\r\n\r\n                        // Round to Double.DEFAULT_PRECISION\r\n                        if (value && !displayUnitSystem.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision)\r\n                            value = Double.roundToPrecision(value);\r\n\r\n                        return singleValueFormattingMode ?\r\n                            displayUnitSystem.formatSingleValue(value, format, decimals, forcePrecision) :\r\n                            displayUnitSystem.format(value, format, decimals, forcePrecision);\r\n                    },\r\n                    displayUnit: displayUnitSystem.displayUnit,\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\r\n                let unit = DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        if (value == null)\r\n                            return locale.null;\r\n\r\n                        let formatString = formattingService.dateFormatString(unit);\r\n                        return formatCore(value, formatString);\r\n                    },\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            return createDefaultFormatter(format);\r\n        }\r\n\r\n        export function format(value: any, format?: string, allowFormatBeautification?: boolean): string {\r\n            if (value == null)\r\n                return locale.null;\r\n\r\n            return formatCore(\r\n                value,\r\n                !!allowFormatBeautification ? locale.beautify(format) : format);\r\n        }\r\n\r\n        /**\r\n         * Value formatting function to handle variant measures.\r\n         * For a Date/Time value within a non-date/time field, it's formatted with the default date/time formatString instead of as a number\r\n         * @param {any} value Value to be formatted\r\n         * @param {DataViewMetadataColumn} column Field which the value belongs to\r\n         * @param {DataViewObjectPropertyIdentifier} formatStringProp formatString Property ID\r\n         * @param {boolean} nullsAreBlank? Whether to show \"(Blank)\" instead of empty string for null values\r\n         * @returns Formatted value\r\n         */\r\n        export function formatVariantMeasureValue(value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier, nullsAreBlank?: boolean): string {\r\n            // If column type is not datetime, but the value is of time datetime,\r\n            // then use the default date format string\r\n            if (!(column && column.type && column.type.dateTime) && value instanceof Date) {\r\n                let valueFormat = getFormatString(DateTimeMetadataColumn, null, false);\r\n                return formatCore(value, valueFormat, nullsAreBlank);\r\n            }\r\n            else {\r\n                return formatCore(value, getFormatString(column, formatStringProp), nullsAreBlank);\r\n            }\r\n        }\r\n\r\n        function createDisplayUnitSystem(displayUnitSystemType?: DisplayUnitSystemType): DisplayUnitSystem {\r\n            if (displayUnitSystemType == null)\r\n                return new DefaultDisplayUnitSystem(locale.describe);\r\n\r\n            switch (displayUnitSystemType) {\r\n                case DisplayUnitSystemType.Default:\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.WholeUnits:\r\n                    return new WholeUnitsDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.Verbose:\r\n                    return new NoDisplayUnitSystem();\r\n                case DisplayUnitSystemType.DataLabels:\r\n                    return new DataLabelsDisplayUnitSystem(locale.describe);\r\n                default:\r\n                    debug.assertFail('Unknown display unit system type');\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n            }\r\n        }\r\n\r\n        function shouldUseNumericDisplayUnits(options: ValueFormatterOptions): boolean {\r\n            let value = options.value;\r\n            let value2 = options.value2;\r\n            let format = options.format;\r\n            // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\r\n            if (options.formatSingleValues && format) {\r\n\r\n                if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\r\n\r\n                    let isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\r\n\r\n                    if (isCustomFormat) {\r\n                        let precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\r\n\r\n                        if (precision < MinPrecisionForDisplayUnits)\r\n                            return false;\r\n                    }\r\n                    else if (Double.isInteger(value))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            if ((typeof value === 'number') || (typeof value2 === 'number')) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        function shouldUseDateUnits(value: any, value2?: any, tickCount?: number): boolean {\r\n            // must check both value and value2 because we'll need to get an interval for date units\r\n            return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\r\n        }\r\n\r\n        /*\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Column format\r\n         *  2. Default PowerView policy for column type\r\n         */\r\n        export function getFormatString(column: DataViewMetadataColumn, formatStringProperty: DataViewObjectPropertyIdentifier, suppressTypeFallback?: boolean): string {\r\n            if (column) {\r\n                if (formatStringProperty) {\r\n                    let propertyValue = DataViewObjects.getValue<string>(column.objects, formatStringProperty);\r\n                    if (propertyValue)\r\n                        return propertyValue;\r\n                }\r\n\r\n                if (!suppressTypeFallback) {\r\n                    let columnType = column.type;\r\n                    if (columnType) {\r\n                        if (columnType.dateTime)\r\n                            return DefaultDateFormat;\r\n                        if (columnType.integer)\r\n                            return DefaultIntegerFormat;\r\n                        if (columnType.numeric)\r\n                            return DefaultNumericFormat;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function formatListCompound(strings: string[], conjunction: string): string {\r\n            let result: string;\r\n\r\n            if (!strings) {\r\n                return null;\r\n            }\r\n\r\n            let length = strings.length;\r\n            if (length > 0) {\r\n                result = strings[0];\r\n                let lastIndex = length - 1;\r\n                for (let i = 1, len = lastIndex; i < len; i++) {\r\n                    let value = strings[i];\r\n                    result = StringExtensions.format(locale.restatementComma, result, value);\r\n                }\r\n\r\n                if (length > 1) {\r\n                    let value = strings[lastIndex];\r\n                    result = StringExtensions.format(conjunction, result, value);\r\n                }\r\n            }\r\n            else {\r\n                result = null;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., and C'  */\r\n        export function formatListAnd(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundAnd);\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., or C' */\r\n        export function formatListOr(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundOr);\r\n        }\r\n\r\n        function formatCore(value: any, format: string, nullsAreBlank?: boolean): string {\r\n            let formattedValue = getStringFormat(value, nullsAreBlank ? nullsAreBlank : false /*nullsAreBlank*/);\r\n\r\n            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                return formattedValue;\r\n\r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        function getStringFormat(value: any, nullsAreBlank: boolean): string {\r\n            if (value == null && nullsAreBlank)\r\n                return locale.null;\r\n\r\n            if (value === true)\r\n                return locale.true;\r\n\r\n            if (value === false)\r\n                return locale.false;\r\n\r\n            if (typeof value === 'number' && isNaN(value))\r\n                return locale.NaN;\r\n\r\n            if (value === Number.NEGATIVE_INFINITY)\r\n                return locale.negativeInfinity;\r\n\r\n            if (value === Number.POSITIVE_INFINITY)\r\n                return locale.infinity;\r\n\r\n            return '';\r\n        }\r\n\r\n        export function getDisplayUnits(displayUnitSystemType: DisplayUnitSystemType): DisplayUnit[] {\r\n            let displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\r\n            return displayUnitSystem.units;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataRoleHelper {\r\n        export function getMeasureIndexOfRole(grouped: DataViewValueColumnGroup[], roleName: string): number {\r\n            if (!_.isEmpty(grouped)) {\r\n                let firstGroup = grouped[0];\r\n                if (firstGroup.values && firstGroup.values.length > 0) {\r\n                    for (let i = 0, len = firstGroup.values.length; i < len; ++i) {\r\n                        let value = firstGroup.values[i];\r\n                        if (value && value.source) {\r\n                            if (hasRole(value.source, roleName))\r\n                                return i;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function getCategoryIndexOfRole(categories: DataViewCategoryColumn[], roleName: string): number {\r\n            if (!_.isEmpty(categories)) {\r\n                for (let i = 0, ilen = categories.length; i < ilen; i++) {\r\n                    if (hasRole(categories[i].source, roleName))\r\n                        return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function hasRole(column: DataViewMetadataColumn, name: string): boolean {\r\n            let roles = column.roles;\r\n            return roles && roles[name];\r\n        }\r\n\r\n        export function hasRoleInDataView(dataView: DataView, name: string): boolean {\r\n            return dataView != null\r\n                && dataView.metadata != null\r\n                && dataView.metadata.columns\r\n                && _.any(dataView.metadata.columns, c => c.roles && c.roles[name] !== undefined);\r\n        }\r\n        \r\n        export function hasRoleInValueColumn(valueColumn: DataViewValueColumn, name: string): boolean {\r\n            return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\r\n\r\n    export function createIDataViewCategoricalReader(dataView: DataView): IDataViewCategoricalReader {\r\n        return new DataViewCategoricalReader(dataView);\r\n    }\r\n\r\n    export interface IDataViewCategoricalReader {\r\n        // Category functions\r\n        hasCategories(): boolean;\r\n        getCategoryCount(): number;\r\n        getCategoryValues(roleName: string): any;\r\n        getCategoryValue(roleName: string, categoryIndex: number): any;\r\n        getCategoryColumn(roleName: string): DataViewCategoryColumn;\r\n        getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn;\r\n        getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[];\r\n        getCategoryDisplayName(roleName: string): string;\r\n        hasCompositeCategories(): boolean;\r\n        hasCategoryWithRole(roleName: string): boolean;\r\n        getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects;\r\n        // Value functions\r\n        hasValues(roleName: string): boolean;\r\n        hasHighlights(roleName: string): boolean;\r\n        /**\r\n         * Obtains the value for the given role name, category index, and series index.\r\n         *\r\n         * Note: in cases where have multiple values in a role where the multiple values\r\n         * are not being used to create a static series, the first is obtained. (this is\r\n         * a rare case)\r\n         */\r\n        getValue(roleName: string, categoryIndex: number, seriesIndex?: number): any;\r\n        /**\r\n         * Obtains the highlighted value for the given role name, category index, and series index.\r\n         *\r\n         * Note: in cases where have multiple values in a role where the multiple values\r\n         * are not being used to create a static series, the first is obtained. (this is\r\n         * a rare case)\r\n         */\r\n        getHighlight(roleName: string, categoryIndex: number, seriesIndex?: number): any;\r\n        /**\r\n         * Obtains all the values for the given role name, category index, and series index, drawing\r\n         * from each of the value columns at that intersection.  Used when you have multiple\r\n         * values in a role that are not conceptually a static series.\r\n         */\r\n        getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex?: number): any[];\r\n        /**\r\n        * Obtains all meta data for the given role name, category index, and series index, drawing\r\n        * from each of the value columns at that intersection.  Used when you have multiple\r\n        * values in a role that are not conceptually a static series.\r\n        */\r\n        getAllValueMetadataColumnsForRole(roleName: string, seriesIndex: number): DataViewMetadataColumn[];\r\n        /**\r\n         * Obtains all the highlight values for the given role name, category index, and series index, drawing\r\n         * from each of the value columns at that intersection.  Used when you have multiple\r\n         * values in a role that are not conceptually a static series.\r\n         */\r\n        getAllHighlightsForRole(roleName: string, categoryIndex: number, seriesIndex?: number): any[];\r\n        /**\r\n         * Obtains the first non-null value for the given role name and category index.\r\n         * It should mainly be used for values that are expected to be the same across\r\n         * series, but avoids false nulls when the data is sparse.\r\n         */\r\n        getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any;\r\n        getMeasureQueryName(roleName: string): string;\r\n        getValueColumn(roleName: string, seriesIndex?: number): DataViewValueColumn;\r\n        getValueMetadataColumn(roleName: string, seriesIndex?: number): DataViewMetadataColumn;\r\n        getAllValueMetadataColumnsForRole(roleName: string, seriesIndex: number): DataViewMetadataColumn[];\r\n        getValueDisplayName(roleName: string, seriesIndex?: number): string;\r\n        // Series Methods\r\n        hasDynamicSeries(): boolean;\r\n        /**\r\n         * Get the series count.  This requires a value role name for cases where you may\r\n         * have a static series, but is not required if the only series you expect are dynamic\r\n         * or single series. \r\n         * \r\n         * @param valueRoleName The role of the value for which a static series may exist\r\n         */\r\n        getSeriesCount(valueRoleName?: string): number;\r\n        getSeriesObjects(seriesIndex: number): DataViewObjects;\r\n        getSeriesValueColumns(): DataViewValueColumns;\r\n        getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup;\r\n        getSeriesMetadataColumn(): DataViewMetadataColumn;\r\n        getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[];\r\n        getSeriesName(seriesIndex: number): PrimitiveValue;\r\n        getSeriesDisplayName(): string;\r\n    }\r\n\r\n    /**\r\n     * A mapping used to map indeces within a specific roleName to an index into the values\r\n     * of a grouped.  This is used so that you can iterate over values within a role without\r\n     * expensive filtering or extra traversal.\r\n     */ \r\n    interface RoleIndexMapping {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    class DataViewCategoricalReader implements IDataViewCategoricalReader {\r\n        private dataView: DataView;\r\n        private categories: DataViewCategoryColumn[];\r\n        private grouped: DataViewValueColumnGroup[];\r\n        private dataHasDynamicSeries: boolean;\r\n        private valueRoleIndexMapping: RoleIndexMapping;\r\n        \r\n        // Validation variables\r\n        private hasValidCategories: boolean;\r\n        private hasAnyValidValues: boolean;\r\n\r\n        constructor(dataView: DataView) {\r\n            debug.assertValue(dataView, 'dataView');\r\n            this.dataView = dataView;\r\n            // Validate categories\r\n            let categorical: DataViewCategorical;\r\n            if (dataView)\r\n                categorical = dataView.categorical;\r\n            let categories: DataViewCategoryColumn[];\r\n            if (categorical)\r\n                categories = this.categories = categorical.categories;\r\n            this.hasValidCategories = !_.isEmpty(categories);\r\n\r\n            // Validate values\r\n            let values: DataViewValueColumns;\r\n            if (categorical)\r\n                values = categorical.values;\r\n            // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\r\n            // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\r\n            this.hasAnyValidValues = false;\r\n            if (values != null) {\r\n                let grouped = dataView.categorical.values.grouped();\r\n\r\n                if (grouped.length > 0) {\r\n                    this.hasAnyValidValues = true;\r\n                    this.grouped = grouped;\r\n\r\n                    // Iterate through the first group's values to populate the valueRoleIndexMapping\r\n                    let valueRoleIndexMapping: RoleIndexMapping = {};\r\n                    let firstGroupValues = grouped[0].values;\r\n                    for (let valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\r\n                        let valueRoles = firstGroupValues[valueIndex].source.roles;\r\n                        for (let role in valueRoles) {\r\n                            if (valueRoles[role]) {\r\n                                if (!valueRoleIndexMapping[role])\r\n                                    valueRoleIndexMapping[role] = [];\r\n                                valueRoleIndexMapping[role].push(valueIndex);\r\n                            }\r\n                        }\r\n                    }\r\n                    this.valueRoleIndexMapping = valueRoleIndexMapping;\r\n                }\r\n            }\r\n\r\n            if (this.hasAnyValidValues)\r\n                this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\r\n        }\r\n\r\n        // Category methods\r\n        \r\n        public hasCategories(): boolean {\r\n            return this.hasValidCategories;\r\n        }\r\n\r\n        public getCategoryCount(): number {\r\n            if (this.hasValidCategories)\r\n                return this.categories[0].values.length;\r\n            else\r\n                return 0;\r\n        }\r\n\r\n        public getCategoryValues(roleName: string): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryValue(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values[categoryIndex] : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumn(roleName: string): DataViewCategoryColumn {\r\n            if (this.hasValidCategories)\r\n                return this.getCategoryFromRole(roleName);\r\n        }\r\n\r\n        public getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.source : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[] {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.identityFields : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryDisplayName(roleName: string): string {\r\n            if (this.hasValidCategories) {\r\n                let targetColumn = this.getCategoryColumn(roleName);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        public hasCompositeCategories(): boolean {\r\n            if (this.hasValidCategories)\r\n                return this.categories.length > 1;\r\n        }\r\n\r\n        public hasCategoryWithRole(roleName: string): boolean {\r\n            return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\r\n        }\r\n\r\n        public getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects {\r\n            if (this.hasValidCategories) {\r\n                let category = this.getCategoryFromRole(roleName);\r\n                if (category && category.objects) {\r\n                    return category.objects[categoryIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        private getCategoryFromRole(roleName: string): DataViewCategoryColumn {\r\n            let categories = this.categories;\r\n            return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\r\n        }\r\n\r\n        // Value and measure methods\r\n\r\n        public hasValues(roleName: string): boolean {\r\n            return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\r\n        }\r\n\r\n        public hasHighlights(roleName: string): boolean {\r\n            if (this.hasValues(roleName)) {\r\n                return !_.isEmpty(this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].highlights);\r\n            }\r\n            return false;\r\n        }\r\n\r\n        public getValue(roleName: string, categoryIndex: number, seriesIndex: number = 0): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    // For dynamic series, we only ever obtain the first value column from a role\r\n                    return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, false /* getHighlight */);\r\n                }\r\n                else {\r\n                    // For static series or single series, we obtain value columns from the first series\r\n                    //    and use the seriesIndex to index into the value columns within the role\r\n                    return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, false /* getHighlight */);\r\n                }\r\n            }\r\n        }\r\n\r\n        public getHighlight(roleName: string, categoryIndex: number, seriesIndex: number = 0): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    // For dynamic series, we only ever obtain the first value column from a role\r\n                    return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0, true /* getHighlight */);\r\n                }\r\n                else {\r\n                    // For static series or single series, we obtain value columns from the first series\r\n                    //    and use the seriesIndex to index into the value columns within the role\r\n                    return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex, true /* getHighlight */);\r\n                }\r\n            }\r\n        }\r\n\r\n        public getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex: number = 0): any[] {\r\n            if (this.hasValues(roleName)) {\r\n                let valuesInRole = [];\r\n                for (let roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, false /* getHighlight */));\r\n                }\r\n                return valuesInRole;\r\n            }\r\n        }\r\n\r\n        public getAllHighlightsForRole(roleName: string, categoryIndex: number, seriesIndex: number = 0): any[] {\r\n            if (this.hasValues(roleName)) {\r\n                let valuesInRole = [];\r\n                for (let roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex, true /* getHighlight */));\r\n                }\r\n                return valuesInRole;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Obtains the value from grouped.\r\n         *\r\n         * Grouped:             [0] [1] [2] [3] (seriesIndex)\r\n         *                         /   \\\r\n         * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\r\n         *                    /    \\ \\  \\           \r\n         * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\r\n         * \r\n         *--------------------------------|\r\n         *                      |Category |\r\n         * Series|Value Columns |A B C D E|\r\n         *--------------------------------|\r\n         *      0|col0 (tooltip)|         |\r\n         *       |col1 (value)  |         |\r\n         *       |col2 (value)  |         |\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      1|col0 (tooltip)|         |\r\n         *       |col1 (value)  |0 1 2 3 4|\r\n         *       |col2 (value)  |5 6 7 8 9|\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      2|col0 (tooltip)|...      |\r\n         * \r\n         * valueColumnIndexInRole is for indexing into the values for a single role\r\n         * valueColumnIndex is for indexing into the entire value array including\r\n         * all roles\r\n         * \r\n         * The valueRoleIndexMapping converts roleValueIndex and role (value role\r\n         * with an index of 1) into groupedValueIndex (2)\r\n         *\r\n         * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\r\n         * the second value column with role \"value\" (which is converted to a\r\n         * groupedValueIndex of 2) and the fourth value within that value column.\r\n         */\r\n        private getValueInternal(roleName: string, categoryIndex: number, groupIndex: number, valueColumnIndexInRole: number, getHighlight: boolean): any {\r\n            if (this.hasValues(roleName)) {\r\n                let valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\r\n                let groupedValues = this.grouped[groupIndex].values[valueColumnIndex];\r\n                return getHighlight ? groupedValues.highlights[categoryIndex] : groupedValues.values[categoryIndex];\r\n            }\r\n        }\r\n\r\n        public getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (!this.dataHasDynamicSeries) {\r\n                    debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\r\n                    return this.getValue(roleName, categoryIndex);\r\n                }\r\n                for (let seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\r\n                    let value = this.getValue(roleName, categoryIndex, seriesIndex);\r\n                    if (value != null) {\r\n                        return value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public getMeasureQueryName(roleName: string): string {\r\n            if (this.hasValues(roleName))\r\n                return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\r\n        }\r\n\r\n        public getValueColumn(roleName: string, seriesIndex: number = 0): DataViewValueColumn {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\r\n                }\r\n                else {\r\n                    return this.grouped[0].values[this.valueRoleIndexMapping[roleName][seriesIndex]];\r\n                }\r\n            }\r\n        }\r\n        \r\n        public getValueMetadataColumn(roleName: string, seriesIndex: number = 0): DataViewMetadataColumn {\r\n            let valueColumn = this.getValueColumn(roleName, seriesIndex);\r\n            if (valueColumn) {\r\n                return valueColumn.source;\r\n            }\r\n        }\r\n\r\n        public getAllValueMetadataColumnsForRole(roleName: string, seriesIndex: number = 0): DataViewMetadataColumn[] {\r\n            if (this.hasValues(roleName)) {\r\n                let metadata = [];\r\n                for (let roleValueIndex = 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    let column = this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][roleValueIndex]].source;\r\n                    metadata.push(column);\r\n                }\r\n                return metadata;\r\n            }\r\n        }\r\n\r\n        public getValueDisplayName(roleName: string, seriesIndex?: number): string {\r\n            if (this.hasValues(roleName)) {\r\n                let targetColumn = this.getValueColumn(roleName, seriesIndex);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Series methods\r\n\r\n        public hasDynamicSeries(): boolean {\r\n            return this.dataHasDynamicSeries;\r\n        }\r\n\r\n        public getSeriesCount(valueRoleName?: string): number {\r\n            if (!this.hasAnyValidValues)\r\n                return;\r\n\r\n            if (this.dataHasDynamicSeries) {\r\n                return this.grouped.length;\r\n            }\r\n            else {\r\n                let roleIndexMap = valueRoleName && this.valueRoleIndexMapping[valueRoleName];\r\n\r\n                if (roleIndexMap)\r\n                    return roleIndexMap.length;\r\n\r\n                return 1;\r\n            }\r\n        }\r\n\r\n        public getSeriesObjects(seriesIndex: number): DataViewObjects {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].objects;\r\n        }\r\n\r\n        public getSeriesValueColumns(): DataViewValueColumns {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values;\r\n        }\r\n\r\n        public getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex];\r\n        }\r\n\r\n        public getSeriesMetadataColumn(): DataViewMetadataColumn {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.source;\r\n        }\r\n\r\n        public getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[] {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.identityFields;\r\n        }\r\n\r\n        public getSeriesName(seriesIndex: number): PrimitiveValue {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].name;\r\n        }\r\n\r\n        public getSeriesDisplayName(): string {\r\n            if (this.hasAnyValidValues && this.dataHasDynamicSeries)\r\n                return this.dataView.categorical.values.source.displayName;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n    import valueFormatter = powerbi.visuals.valueFormatter;\r\n\r\n    export module DataViewConcatenateCategoricalColumns {\r\n\r\n        /* Represents a collection of DataViewCategoryColumn that are tied to the same role. */\r\n        interface CategoryColumnsByRole {\r\n            /* The name of the role shared by all the objects in the categories property. */\r\n            roleName: string;\r\n\r\n            /**\r\n             * The list of columns that are tied to roleName, in the same order as they appear\r\n             * in the categories property of their owner DataViewCategorical object.\r\n             */\r\n            categories: DataViewCategoryColumn[];\r\n        }\r\n\r\n        export function detectAndApply(\r\n            dataView: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            selects: DataViewSelectTransform[],\r\n            projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n\r\n            let result = dataView;\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            if (dataViewCategorical) {\r\n                let concatenationSource: CategoryColumnsByRole = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\r\n\r\n                if (concatenationSource) {\r\n                    // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\r\n                    let columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\r\n                    if (columnsSortedByProjectionOrdering.length >= 2) {\r\n                        let activeItemsToIgnoreInConcatenation =\r\n                            _.chain(projectionActiveItems[concatenationSource.roleName])\r\n                                .filter((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.suppressConcat)\r\n                                .map((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.queryRef)\r\n                                .value();\r\n\r\n                        result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\r\n        export function applyToPlayChartCategorical(\r\n            metadata: DataViewMetadata,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            categoryRoleName: string,\r\n            categorical: DataViewCategorical): DataView {\r\n            debug.assertValue(metadata, 'metadata');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let result: DataView;\r\n            if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\r\n                // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\r\n                // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\r\n                // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\r\n                // use inherit() rather than inheritSingle() here.\r\n                let transformingColumns = inherit(metadata.columns);\r\n                let transformingMetadata = inherit(metadata, m => { m.columns = transformingColumns; });\r\n\r\n                let transformingDataView = { metadata: transformingMetadata, categorical: categorical };\r\n                result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\r\n            }\r\n            else {\r\n                result = { metadata: metadata, categorical: categorical };\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the role and its assocated category columns (from dataViewCategorical.categories)\r\n         * that should be concatenated for the case of hierarchical group.\r\n         *\r\n         * Note: In the future if we support sibling hierarchical groups in categorical,\r\n         * change the return type to CategoryColumnsByRole[] and update detection logic.\r\n         */\r\n        function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical: DataViewCategorical, metadata: DataViewMetadata, dataViewMappings: DataViewMapping[], selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): CategoryColumnsByRole {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\r\n\r\n            let result: CategoryColumnsByRole;\r\n\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\r\n            let projections = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let supportedRoleMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            // The following code will choose a role name only if all supportedRoleMappings share the same role for Categorical Category.\r\n            // Handling multiple supportedRoleMappings is necessary for TransformActions with splits, which can happen in scenarios such as:\r\n            // 1. combo chart with a field for both Line and Column values, and\r\n            // 2. chart with regression line enabled.\r\n            // In case 1, you can pretty much get exactly the one from supportedRoleMappings for which this code is currently processing for,\r\n            // by looking at the index of the current split in DataViewTransformActions.splits.\r\n            // In case 2, however, supportedRoleMappings.length will be different than DataViewTransformActions.splits.length, hence it is\r\n            // not straight forward to figure out for which one in supportedRoleMappings is this code currently processing.\r\n            // SO... This code will just choose the category role name if it is consistent across all supportedRoleMappings.\r\n\r\n            let isEveryRoleMappingForCategorical = !_.isEmpty(supportedRoleMappings) &&\r\n                _.every(supportedRoleMappings, (roleMapping) => !!roleMapping.categorical);\r\n\r\n            if (isEveryRoleMappingForCategorical) {\r\n                let targetRoleName = getSingleCategoryRoleNameInEveryRoleMapping(supportedRoleMappings);\r\n                if (targetRoleName &&\r\n                    isVisualExpectingMaxOneCategoryColumn(targetRoleName, supportedRoleMappings)) {\r\n\r\n                    let categoryColumnsForTargetRole: DataViewCategoryColumn[] = _.filter(\r\n                        dataViewCategorical.categories,\r\n                        (categoryColumn: DataViewCategoryColumn) => categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName]);\r\n\r\n                    // There is no need to concatenate columns unless there is actually more than one column\r\n                    if (categoryColumnsForTargetRole.length >= 2) {\r\n                        // At least for now, we expect all category columns for the same role to have the same number of value entries.\r\n                        // If that's not the case, we won't run the concatenate logic for that role at all...\r\n                        let areValuesCountsEqual: boolean = _.every(\r\n                            categoryColumnsForTargetRole,\r\n                            (categoryColumn: DataViewCategoryColumn) => categoryColumn.values.length === categoryColumnsForTargetRole[0].values.length);\r\n                        \r\n                        if (areValuesCountsEqual) {\r\n                            result = {\r\n                                roleName: targetRoleName,\r\n                                categories: categoryColumnsForTargetRole,\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** If all mappings in the specified roleMappings have the same single role name for their categorical category roles, return that role name, else returns undefined. */\r\n        function getSingleCategoryRoleNameInEveryRoleMapping(categoricalRoleMappings: DataViewMapping[]): string {\r\n            debug.assertNonEmpty(categoricalRoleMappings, 'categoricalRoleMappings');\r\n            debug.assert(_.every(categoricalRoleMappings, (roleMapping) => !!roleMapping.categorical), 'All mappings in categoricalRoleMappings must contain a DataViewCategoricalMapping');\r\n\r\n            let result: string;\r\n\r\n            // With \"list\" in role mapping, it is possible to have multiple role names for category.\r\n            // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\r\n            // We can change this if we want to support independent (sibling) group hierarchies in categorical.\r\n            let uniqueCategoryRoles: string[] = _.chain(categoricalRoleMappings)\r\n                .map((roleMapping) => {\r\n                    let categoryRoles = getAllRolesInCategories(roleMapping.categorical);\r\n                    return categoryRoles.length === 1 ? categoryRoles[0] : undefined;\r\n                })\r\n                .uniq() // Note: _.uniq() does not treat two arrays with same elements as equal\r\n                .value();\r\n            \r\n\r\n            let isSameCategoryRoleNameInAllRoleMappings = uniqueCategoryRoles.length === 1 && !_.isUndefined(uniqueCategoryRoles[0]);\r\n            if (isSameCategoryRoleNameInAllRoleMappings) {\r\n                result = uniqueCategoryRoles[0];\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        function isVisualExpectingMaxOneCategoryColumn(categoricalRoleName: string, roleMappings: DataViewMapping[]): boolean {\r\n            debug.assertValue(categoricalRoleName, 'categoricalRoleName');\r\n            debug.assertNonEmpty(roleMappings, 'roleMappings');\r\n\r\n            let isVisualExpectingMaxOneCategoryColumn = _.every(\r\n                roleMappings,\r\n                (roleMapping) => {\r\n                    return !_.isEmpty(roleMapping.conditions) &&\r\n                        _.every(roleMapping.conditions, condition => condition[categoricalRoleName] && condition[categoricalRoleName].max === 1);\r\n                });\r\n\r\n            return isVisualExpectingMaxOneCategoryColumn;\r\n        }\r\n\r\n        /**\r\n         * Returns the array of role names that are mapped to categorical categories.\r\n         * Returns an empty array if none exists.\r\n         */\r\n        function getAllRolesInCategories(categoricalRoleMapping: DataViewCategoricalMapping): string[] {\r\n            debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\r\n\r\n            let roleNames: string[] = [];\r\n            DataViewMapping.visitCategoricalCategories(\r\n                categoricalRoleMapping.categories,\r\n                {\r\n                    visitRole: (roleName: string) => {\r\n                        roleNames.push(roleName);\r\n                    }\r\n                });\r\n\r\n            return roleNames;\r\n        }\r\n\r\n        function applyConcatenation(dataView: DataView, objectDescriptors: DataViewObjectDescriptors, roleName: string, columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let formatStringPropId: DataViewObjectPropertyIdentifier = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            let concatenatedValues: string[] = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\r\n\r\n            let columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, categoryColumn => categoryColumn.source);\r\n            let concatenatedColumnMetadata: DataViewMetadataColumn = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\r\n            let transformedDataView = inheritSingle(dataView);\r\n            addToMetadata(transformedDataView, concatenatedColumnMetadata);\r\n\r\n            let concatenatedCategoryColumn: DataViewCategoryColumn = createConcatenatedCategoryColumn(\r\n                columnsSortedByProjectionOrdering,\r\n                concatenatedColumnMetadata,\r\n                concatenatedValues);\r\n\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            let transformedCategoricalCategories: DataViewCategoryColumn[] = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\r\n            transformedCategoricalCategories.push(concatenatedCategoryColumn);\r\n\r\n            let transformedCategorical: DataViewCategorical = inheritSingle(dataViewCategorical);\r\n            transformedCategorical.categories = transformedCategoricalCategories;\r\n            transformedDataView.categorical = transformedCategorical;\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        function concatenateValues(columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[], formatStringPropId: DataViewObjectPropertyIdentifier): string[] {\r\n            debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\r\n            debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\r\n            debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\r\n\r\n            let concatenatedValues: string[] = [];\r\n\r\n            // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\r\n            for (let categoryColumn of columnsSortedByProjectionOrdering) {\r\n                let formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\r\n\r\n                for (let i = 0, len = categoryColumn.values.length; i < len; i++) {\r\n                    if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\r\n                        let value = categoryColumn.values && categoryColumn.values[i];\r\n                        let formattedValue = valueFormatter.format(value, formatString);\r\n                        concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return concatenatedValues;\r\n        }\r\n\r\n        /**\r\n        * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\r\n        */\r\n        function sortColumnsByProjectionOrdering(projectionOrdering: DataViewProjectionOrdering, roleName: string, columns: DataViewCategoryColumn[]): DataViewCategoryColumn[] {\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            let columnsInProjectionOrdering: DataViewCategoryColumn[];\r\n\r\n            if (projectionOrdering) {\r\n                // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\r\n                let columnsByIndex: { [index: number]: DataViewCategoricalColumn } = {};\r\n                for (let column of columns) {\r\n                    if (column.source.roles[roleName]) {\r\n                        debug.assert(!columnsByIndex[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\r\n                        columnsByIndex[column.source.index] = column;\r\n                    }\r\n                }\r\n\r\n                let columnIndicesInProjectionOrdering: number[] = projectionOrdering[roleName];\r\n\r\n                columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\r\n                    .map(columnIndex => columnsByIndex[columnIndex])\r\n                    .filter((column: DataViewCategoricalColumn) => !!column)\r\n                    .value();\r\n            }\r\n            else {\r\n                // If projectionOrder is unspecified, just return the columns for the specified role in their current order\r\n                columnsInProjectionOrdering = _.filter(columns, column => column.source.roles[roleName]);\r\n            }\r\n\r\n            return columnsInProjectionOrdering;\r\n        }\r\n\r\n        /**\r\n         * Creates the column metadata that will back the column with the concatenated values. \r\n         */\r\n        function createConcatenatedColumnMetadata(roleName: string, sourceColumnsSortedByProjectionOrdering: DataViewMetadataColumn[], queryRefsToIgnore?: string[]): DataViewMetadataColumn {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\r\n            debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(c => c.isMeasure).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\r\n\r\n            let concatenatedDisplayName: string;\r\n\r\n            for (let columnSource of sourceColumnsSortedByProjectionOrdering) {\r\n                if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\r\n                    concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\r\n                }\r\n            }\r\n\r\n            let newRoles: { [name: string]: boolean } = {};\r\n            newRoles[roleName] = true;\r\n\r\n            let newColumnMetadata: DataViewMetadataColumn = {\r\n                displayName: concatenatedDisplayName,\r\n                roles: newRoles,\r\n                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)\r\n            };\r\n\r\n            let columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\r\n            if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\r\n                newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\r\n            }\r\n\r\n            // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\r\n            // If queryName is not set at all, the column chart visual will only render column for the first group instance.\r\n            // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\r\n            newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\r\n\r\n            return newColumnMetadata;\r\n        }\r\n\r\n        function addToMetadata(transformedDataView: DataView, newColumn: DataViewMetadataColumn): void {\r\n            debug.assertValue(transformedDataView, 'transformedDataView');\r\n            debug.assertValue(newColumn, 'newColumn');\r\n\r\n            let transformedColumns = inheritSingle(transformedDataView.metadata.columns);\r\n            transformedColumns.push(newColumn);\r\n\r\n            let transformedMetadata = inheritSingle(transformedDataView.metadata);\r\n            transformedMetadata.columns = transformedColumns;\r\n\r\n            transformedDataView.metadata = transformedMetadata;\r\n        }\r\n\r\n        function createConcatenatedCategoryColumn(\r\n            sourceColumnsSortedByProjectionOrdering: DataViewCategoryColumn[],\r\n            columnMetadata: DataViewMetadataColumn,\r\n            concatenatedValues: string[]): DataViewCategoryColumn {\r\n            debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let newCategoryColumn: DataViewCategoryColumn = {\r\n                source: columnMetadata,\r\n                values: concatenatedValues\r\n            };\r\n\r\n            // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\r\n            // So, we'll just take the identities and identityFields from the first column\r\n            let firstColumn = sourceColumnsSortedByProjectionOrdering[0];\r\n\r\n            if (firstColumn.identity) {\r\n                newCategoryColumn.identity = firstColumn.identity;\r\n            }\r\n\r\n            if (firstColumn.identityFields) {\r\n                newCategoryColumn.identityFields = firstColumn.identityFields;\r\n            }\r\n\r\n            // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\r\n            if (firstColumn.objects) {\r\n                newCategoryColumn.objects = firstColumn.objects;\r\n            }\r\n\r\n            return newCategoryColumn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export const enum RoleItemContext {\r\n        CategoricalValue,\r\n        CategoricalValueGroup,\r\n    }\r\n\r\n    export interface IDataViewMappingVisitor {\r\n        visitRole(role: string, context?: RoleItemContext): void;\r\n        visitReduction?(reductionAlgorithm?: ReductionAlgorithm): void;\r\n    }\r\n\r\n    export module DataViewMapping {\r\n        export function visitMapping(mapping: DataViewMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let categorical = mapping.categorical;\r\n            if (categorical)\r\n                visitCategorical(categorical, visitor);\r\n\r\n            let table = mapping.table;\r\n            if (table)\r\n                visitTable(table, visitor);\r\n\r\n            let matrix = mapping.matrix;\r\n            if (matrix)\r\n                visitMatrix(matrix, visitor);\r\n\r\n            let tree = mapping.tree;\r\n            if (tree)\r\n                visitTree(tree, visitor);\r\n            \r\n            let single = mapping.single;\r\n            if (single)\r\n                visitSingle(single, visitor);\r\n        }\r\n\r\n        export function visitCategorical(mapping: DataViewCategoricalMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitCategoricalCategories(mapping.categories, visitor);\r\n\r\n            visitCategoricalValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitCategoricalCategories(mapping: DataViewRoleMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitCategoricalValues(mapping: DataViewRoleMapping | DataViewGroupedRoleMapping | DataViewListRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n\r\n                let groupedRoleMapping = <DataViewGroupedRoleMapping>mapping;\r\n                visitGrouped(groupedRoleMapping, visitor);\r\n\r\n                let group = groupedRoleMapping.group;\r\n                if (group) {\r\n                    for (let item of group.select) {\r\n                        visitBind(<DataViewRoleBindMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                        visitFor(<DataViewRoleForMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitTable(mapping: DataViewTableMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let rows = mapping.rows;\r\n            visitBind(<DataViewRoleBindMapping>rows, visitor);\r\n            visitFor(<DataViewRoleForMapping>rows, visitor);\r\n            visitList(<DataViewListRoleMapping>rows, visitor);\r\n\r\n            visitReduction(rows, visitor);\r\n        }\r\n\r\n        function visitMatrix(mapping: DataViewMatrixMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitMatrixItems(mapping.rows, visitor);\r\n            visitMatrixItems(mapping.columns, visitor);\r\n            visitMatrixItems(mapping.values, visitor);\r\n        }\r\n\r\n        /**\r\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         *\r\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         * @param visitor The visitor.\r\n         */\r\n        export function visitMatrixItems(mapping: DataViewRoleForMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitTree(mapping: DataViewTreeMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitTreeNodes(mapping.nodes, visitor);\r\n            visitTreeValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitTreeNodes(mapping: DataViewRoleForMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitTreeValues(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitBind(mapping: DataViewRoleBindMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let bind = mapping.bind;\r\n            if (bind) {\r\n                if (context != null)\r\n                    visitor.visitRole(bind.to, context);\r\n                else\r\n                    visitor.visitRole(bind.to);\r\n            }\r\n        }\r\n\r\n        function visitFor(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let forValue = mapping.for;\r\n            if (forValue) {\r\n                if (context != null)\r\n                    visitor.visitRole(forValue.in, context);\r\n                else\r\n                    visitor.visitRole(forValue.in);\r\n            }\r\n        }\r\n\r\n        function visitList(mapping: DataViewListRoleMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let select = mapping.select;\r\n            if (select) {\r\n                for (let item of select) {\r\n                    visitBind(<DataViewRoleBindMapping>item, visitor, context);\r\n                    visitFor(<DataViewRoleForMapping>item, visitor, context);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitGrouped(mapping: DataViewGroupedRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (!mapping)\r\n                return;\r\n\r\n            let group = mapping.group;\r\n            if (group) {\r\n                visitor.visitRole(group.by);\r\n\r\n                visitReduction(group, visitor);\r\n            }\r\n        }\r\n\r\n        function visitReduction(mapping: HasReductionAlgorithm, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (visitor.visitReduction) {\r\n                let reductionAlgorithm = mapping.dataReductionAlgorithm;\r\n                if (reductionAlgorithm) {\r\n                    visitor.visitReduction(reductionAlgorithm);\r\n                }\r\n            }\r\n        }\r\n\r\n        function visitSingle(mapping: DataViewSingleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitor.visitRole(mapping.role);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inheritSingle = Prototype.inheritSingle;\r\n\r\n    export interface DataViewNormalizeValuesApplyOptions {\r\n        dataview: DataView;\r\n        dataViewMappings: DataViewMapping[];\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a column is tied to any role that has required type(s).\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns true iff the column in the specified columnIndex is tied to any role that has required type(s), i.e. if the value in that column potentially needs to get normalized.\r\n     */\r\n    export interface IMetadataColumnFilter {\r\n        (columnIndex: number): boolean;\r\n    }\r\n\r\n    /**\r\n     * Returns true iff the specified value is of matching type as required by the role assigned to the column associated with this filter object.\r\n     */\r\n    export interface IColumnValueFilter {\r\n        (value: any): boolean;\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns false iff the specified value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     */\r\n    export interface IValueFilter {\r\n        (columnIndex: number, value: any): boolean;\r\n    }\r\n\r\n    export module DataViewNormalizeValues {\r\n        export function apply(options: DataViewNormalizeValuesApplyOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let rolesToNormalize = _.filter(options.dataRoles, role => !_.isEmpty(role.requiredTypes));\r\n\r\n            filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\r\n        }\r\n\r\n        export function filterVariantMeasures(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[]): void {\r\n            debug.assertValue(dataview, 'dataview');\r\n\r\n            // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\r\n                return;\r\n\r\n            let columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\r\n            let valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\r\n\r\n            let usedMappings = {};\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                // Get dataview specified in mappings which are also in dataview\r\n                for (let dataViewMappingProp in dataViewMapping) {\r\n                    if (dataview[dataViewMappingProp] != null)\r\n                        usedMappings[dataViewMappingProp] = true;\r\n                }\r\n            }\r\n\r\n            if (usedMappings['categorical'])\r\n                filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\r\n            if (usedMappings['table'])\r\n                filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\r\n            if (usedMappings['tree'])\r\n                filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\r\n            if (usedMappings['matrix'])\r\n                filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\r\n            if (usedMappings['single'])\r\n                filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\r\n        }\r\n\r\n        export function generateMetadataColumnFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IMetadataColumnFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => false;\r\n\r\n            let columnsToNormalize = {};\r\n            for (let column of columns) {\r\n                let roles = column.roles;\r\n                if (!roles)\r\n                    continue;\r\n                for (let role of rolesToNormalize) {\r\n                    if (!roles[role.name])\r\n                        continue;\r\n                    columnsToNormalize[column.index] = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return (columnIndex: number) => {\r\n                if (isNaN(columnIndex))\r\n                    return false;\r\n\r\n                return !!columnsToNormalize[columnIndex];\r\n            };\r\n        }\r\n\r\n        export function generateValueFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IValueFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => true;\r\n\r\n            let columnValueFilters: IColumnValueFilter[] = [];\r\n\r\n            // Build columnValueFilters based on role requiredTypes\r\n            for (let column of columns) {\r\n                let columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\r\n\r\n                if (columnValueFilter)\r\n                    columnValueFilters[column.index] = columnValueFilter;\r\n            }\r\n\r\n            return <IValueFilter>(columnIndex: number, value: any) => {\r\n                if (columnValueFilters[columnIndex])\r\n                    return columnValueFilters[columnIndex](value);\r\n\r\n                return true;\r\n            };\r\n        }\r\n\r\n        function generateColumnValueFilter(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): IColumnValueFilter {\r\n            let requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\r\n\r\n            if (_.isEmpty(requiredTypes))\r\n                return;\r\n\r\n            return (value: any): boolean => {\r\n                return doesValueMatchTypes(value, requiredTypes);\r\n            };\r\n        }\r\n\r\n        export function getColumnRequiredTypes(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): ValueType[] {\r\n            let requiredTypes = [];\r\n            let columnRoles = column && column.roles;\r\n\r\n            if (!columnRoles)\r\n                return requiredTypes;\r\n\r\n            for (let role of rolesToNormalize) {\r\n                if (!columnRoles[role.name])\r\n                    continue;\r\n                for (let typeDescriptor of role.requiredTypes) {\r\n                    let type = ValueType.fromDescriptor(typeDescriptor);\r\n                    requiredTypes.push(type);\r\n                }\r\n            }\r\n\r\n            return requiredTypes;\r\n        }\r\n\r\n        function filterVariantMeasuresCategorical(dataview: DataViewCategorical, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let values = dataview && dataview.values;\r\n            if (!values)\r\n                return;\r\n\r\n            let valuesGrouped = values.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            for (let valueGroup of valuesGrouped) {\r\n                let valuesInGroup = valueGroup.values;\r\n                for (let valueColumn of valuesInGroup) {\r\n                    let columnIndex = valueColumn.source.index;\r\n                    if (!columnFilter(columnIndex))\r\n                        continue;\r\n\r\n                    for (let i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\r\n                        valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTable(dataview: DataViewTable, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let columns = dataview && dataview.columns;\r\n\r\n            if (!columns)\r\n                return;\r\n\r\n            let filteredColumns = [];\r\n            for (let column of columns) {\r\n                if (columnFilter(column.index))\r\n                    filteredColumns.push(column.index);\r\n            }\r\n\r\n            let rows = dataview.rows;\r\n            for (let i = 0, ilen = rows.length; i < ilen; i++) {\r\n                for (let index of filteredColumns) {\r\n                    rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTreeNode(node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let columnIndex in node.values) {\r\n                    // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\r\n                    if (columnFilter(<any>columnIndex)) {\r\n                        // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\r\n                        if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\r\n                            node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', <any>columnIndex, valueFilter);\r\n                        else // if node.values[columnIndex] is a primitive value\r\n                            node.values = normalizeVariant(node.values, columnIndex, <any>columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresMatrix(dataview: DataViewMatrix, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let root = dataview && dataview.rows && dataview.rows.root;\r\n\r\n            if (!root)\r\n                return;\r\n\r\n            // Recurse into rows.children\r\n            // e.g. rows.children -> .children -> .children.values\r\n            filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\r\n        }\r\n\r\n        function filterVariantMeasuresMatrixRecursive(dataviewMatrix: DataViewMatrix, node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let id in node.values) {\r\n                    // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\r\n                    let nodeValue: DataViewMatrixNodeValue = node.values[id];\r\n\r\n                    // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\r\n                    let valueSourceIndex: number = nodeValue.valueSourceIndex || 0;\r\n\r\n                    // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\r\n                    let columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\r\n\r\n                    if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\r\n                        node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresSingle(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[], valueFilter: IValueFilter): void {\r\n            if (!dataview.single)\r\n                return;\r\n\r\n            let roleNames: string[] = [];\r\n            for (let role of rolesToNormalize) {\r\n                if (role.name)\r\n                    roleNames.push(role.name);\r\n            }\r\n\r\n            let columns = dataview.metadata.columns;\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                let roleName = dataViewMapping.single.role;\r\n                if (roleNames.indexOf(roleName) !== -1) {\r\n                    let column = firstColumnByRoleName(columns, roleName);\r\n                    if (column)\r\n                        dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        export function normalizeVariant<T>(object: T, key: string|number, columnIndex: number, valueFilter: IValueFilter): T {\r\n            if (!object)\r\n                return;\r\n\r\n            let value = object[key];\r\n            if (value !== null && !valueFilter(columnIndex, value)) {\r\n                object = inheritSingle(object);\r\n                object[key] = null;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        function doesValueMatchTypes<T>(value: T, types: ValueType[]): boolean {\r\n            for (let type of types) {\r\n                if (type.numeric || type.integer)\r\n                    return typeof (value) === 'number';\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function firstColumnByRoleName(columns: DataViewMetadataColumn[], roleName: string): DataViewMetadataColumn {\r\n            for (let column of columns) {\r\n                let columnRoles = column && column.roles;\r\n                if (columnRoles && columnRoles[roleName])\r\n                    return column;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewObjects {\r\n        /** Gets the value of the given object/property pair. */\r\n        export function getValue<T>(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultValue?: T): T {\r\n            debug.assertAnyValue(objects, 'objects');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            if (!objects)\r\n                return defaultValue;\r\n\r\n            let objectOrMap = objects[propertyId.objectName];\r\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\r\n\r\n            let object = <DataViewObject>objectOrMap;\r\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\r\n        }\r\n\r\n        /** Gets an object from objects. */\r\n        export function getObject(objects: DataViewObjects, objectName: string, defaultValue?: DataViewObject): DataViewObject {\r\n            if (objects && objects[objectName]) {\r\n                let object = <DataViewObject>objects[objectName];\r\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\r\n                return object;\r\n            }\r\n            else {\r\n                return defaultValue;\r\n            }\r\n        }\r\n\r\n        /** Gets a map of user-defined objects. */\r\n        export function getUserDefinedObjects(objects: DataViewObjects, objectName: string): DataViewObjectMap {\r\n            if (objects && objects[objectName]) {\r\n                let map = <DataViewObjectMap>objects[objectName];\r\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\r\n                return map;\r\n            }\r\n        }\r\n\r\n        /** Gets the solid color from a fill property. */\r\n        export function getFillColor(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultColor?: string): string {\r\n            let value: Fill = getValue(objects, propertyId);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n\r\n        /** Returns true if the given object represents a collection of user-defined objects */\r\n        export function isUserDefined(objectOrMap: DataViewObject | DataViewObjectMap): boolean {\r\n            return _.isArray(objectOrMap);\r\n        }\r\n    }\r\n\r\n    export module DataViewObject {\r\n        export function getValue<T>(object: DataViewObject, propertyName: string, defaultValue?: T): T {\r\n            debug.assertAnyValue(object, 'object');\r\n            debug.assertValue(propertyName, 'propertyName');\r\n\r\n            if (!object)\r\n                return defaultValue;\r\n\r\n            let propertyValue = <T>object[propertyName];\r\n            if (propertyValue === undefined)\r\n                return defaultValue;\r\n\r\n            return propertyValue;\r\n        }\r\n\r\n        /** Gets the solid color from a fill property using only a propertyName */\r\n        export function getFillColorByPropertyName(objects: DataViewObjects, propertyName: string, defaultColor?: string): string {\r\n            let value: Fill = DataViewObject.getValue(objects, propertyName);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import JsonComparer = jsCommon.JsonComparer;\r\n\r\n    /** Defines the values for particular objects. */\r\n    export interface DataViewObjectDefinitions {\r\n        [objectName: string]: DataViewObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinition {\r\n        selector?: Selector;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export interface DataViewObjectPropertyDefinitions {\r\n        [name: string]: DataViewObjectPropertyDefinition;\r\n    }\r\n\r\n    export type DataViewObjectPropertyDefinition = SQExpr | StructuralObjectDefinition;\r\n\r\n    export module DataViewObjectDefinitions {\r\n\r\n        /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\r\n        export function ensure(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                defns[objectName] = defnsForObject = [];\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n\r\n            let newDefn: DataViewObjectDefinition = {\r\n                selector: selector,\r\n                properties: {},\r\n            };\r\n            defnsForObject.push(newDefn);\r\n\r\n            return newDefn;\r\n        }\r\n\r\n        export function deleteProperty(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector,\r\n            propertyName: string): void {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defn = getObjectDefinition(defns, objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\r\n        }\r\n        \r\n        export function setValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n            debug.assertValue(defns, 'defns');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        export function getValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinition {\r\n\r\n            let properties = getPropertyContainer(defns, propertyId, selector);\r\n            if (!properties)\r\n                return;\r\n\r\n            return properties[propertyId.propertyName];\r\n        }\r\n\r\n        export function getPropertyContainer(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinitions {\r\n\r\n            let defn = getObjectDefinition(defns, propertyId.objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            return defn.properties;\r\n        }\r\n\r\n        export function getObjectDefinition(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertAnyValue(defns, 'defns');\r\n            debug.assertValue(objectName, 'objectName');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!defns)\r\n                return;\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                return;\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n        }\r\n\r\n        export function propertiesAreEqual(a: DataViewObjectPropertyDefinition, b: DataViewObjectPropertyDefinition): boolean {\r\n            if (a instanceof SemanticFilter && b instanceof SemanticFilter) {\r\n                return SemanticFilter.isSameFilter(<SemanticFilter>a, <SemanticFilter>b);\r\n            }\r\n\r\n            return JsonComparer.equals(a, b);\r\n        }\r\n\r\n        export function allPropertiesAreEqual(a: DataViewObjectPropertyDefinitions, b: DataViewObjectPropertyDefinitions): boolean {\r\n            debug.assertValue(a, 'a');\r\n            debug.assertValue(b, 'b');\r\n\r\n            if (Object.keys(a).length !== Object.keys(b).length)\r\n                return false;\r\n\r\n            for (let property in a) {\r\n                if (!propertiesAreEqual(a[property], b[property]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function encodePropertyValue(value: DataViewPropertyValue, valueTypeDescriptor: ValueTypeDescriptor): DataViewObjectPropertyDefinition {\r\n            debug.assertAnyValue(value, 'value');\r\n            debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\r\n\r\n            if (valueTypeDescriptor.bool) {\r\n                if (typeof (value) !== 'boolean')\r\n                    value = false; // This is fallback, which doesn't really belong here.\r\n\r\n                return SQExprBuilder.boolean(<boolean>value);\r\n            }\r\n            else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\r\n                return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.numeric) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).fill) {\r\n                if (value) {\r\n                    return {\r\n                        solid: { color: SQExprBuilder.text(<string>value) }\r\n                    };\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.formatting) {\r\n                if (valueTypeDescriptor.formatting.labelDisplayUnits) {\r\n                    return SQExprBuilder.double(+value);\r\n                }\r\n                else {\r\n                    return SQExprBuilder.text(<string>value);\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.enumeration) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n                else\r\n                    return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.misc) {\r\n                if (value) {\r\n                    value = SQExprBuilder.text(<string>value);\r\n                } else {\r\n                    value = null;\r\n                }\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).image) {\r\n                if (value) {\r\n                    let imageValue = <ImageValue>value;\r\n                    let imageDefinition: ImageDefinition = {\r\n                        name: SQExprBuilder.text(imageValue.name),\r\n                        url: SQExprBuilder.text(imageValue.url),\r\n                    };\r\n\r\n                    if (imageValue.scaling)\r\n                        imageDefinition.scaling = SQExprBuilder.text(imageValue.scaling);\r\n\r\n                    return imageDefinition;\r\n                }\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        export function clone(original: DataViewObjectDefinitions): DataViewObjectDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            let cloned: DataViewObjectDefinitions = {};\r\n\r\n            for (let objectName in original) {\r\n                let originalDefns = original[objectName];\r\n                if (_.isEmpty(originalDefns))\r\n                    continue;\r\n\r\n                let clonedDefns: DataViewObjectDefinition[] = [];\r\n                for (let originalDefn of originalDefns) {\r\n                    clonedDefns.push({\r\n                        properties: cloneProperties(originalDefn.properties),\r\n                        selector: originalDefn.selector,\r\n                    });\r\n                }\r\n                cloned[objectName] = clonedDefns;\r\n            }\r\n\r\n            return cloned;\r\n        }\r\n\r\n        function cloneProperties(original: DataViewObjectPropertyDefinitions): DataViewObjectPropertyDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\r\n            return _.clone(original);\r\n        }\r\n    }\r\n\r\n    export module DataViewObjectDefinition {\r\n\r\n        export function deleteSingleProperty(\r\n            defn: DataViewObjectDefinition,\r\n            propertyName: string): void {\r\n\r\n            //note: We decided that delete is acceptable here and that we don't need optimization here\r\n            delete defn.properties[propertyName];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module DataViewObjectDescriptors {\r\n        /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\r\n        export function findFormatString(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let formattingTypeDesc = ValueType.fromDescriptor(propDesc.type).formatting;\r\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\r\n        export function findFilterOutput(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.filter;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\r\n        export function findDefaultValue(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.expression && propType.expression.defaultValue;\r\n                });\r\n        }\r\n\r\n        function findProperty(descriptors: DataViewObjectDescriptors, propPredicate: (propDesc: DataViewObjectPropertyDescriptor) => boolean): DataViewObjectPropertyIdentifier {\r\n            debug.assertAnyValue(descriptors, 'descriptors');\r\n            debug.assertAnyValue(propPredicate, 'propPredicate');\r\n\r\n            if (!descriptors)\r\n                return;\r\n\r\n            for (let objectName in descriptors) {\r\n                let objPropDescs = descriptors[objectName].properties;\r\n\r\n                for (let propertyName in objPropDescs) {\r\n                    if (propPredicate(objPropDescs[propertyName])) {\r\n                        return {\r\n                            objectName: objectName,\r\n                            propertyName: propertyName,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n*  Power BI Visualizations\r\n*\r\n*  Copyright (c) Microsoft Corporation\r\n*  All rights reserved. \r\n *  MIT License\r\n*\r\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n*  in the Software without restriction, including without limitation the rights\r\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*  copies of the Software, and to permit persons to whom the Software is\r\n*  furnished to do so, subject to the following conditions:\r\n*   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n*   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n*  THE SOFTWARE.\r\n*/\r\n\r\nmodule powerbi.data {\r\n    export interface DataViewObjectDefinitionsByRepetition {\r\n        metadataOnce?: DataViewObjectDefinitionsForSelector;\r\n        userDefined?: DataViewObjectDefinitionsForSelector[];\r\n        metadata?: DataViewObjectDefinitionsForSelector[];\r\n        data: DataViewObjectDefinitionsForSelectorWithRule[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelector {\r\n        selector?: Selector;\r\n        objects: DataViewNamedObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelectorWithRule extends DataViewObjectDefinitionsForSelector {\r\n        rules?: RuleEvaluation[];\r\n    }\r\n\r\n    export interface DataViewNamedObjectDefinition {\r\n        name: string;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export module DataViewObjectEvaluationUtils {\r\n        export function evaluateDataViewObjects(\r\n            evalContext: IEvalContext,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewObjects {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let objects: DataViewObjects;\r\n\r\n            for (let j = 0, jlen = objectDefns.length; j < jlen; j++) {\r\n                let objectDefinition = objectDefns[j],\r\n                    objectName = objectDefinition.name;\r\n\r\n                let evaluatedObject: DataViewObject = DataViewObjectEvaluator.run(\r\n                    evalContext,\r\n                    objectDescriptors[objectName],\r\n                    objectDefinition.properties);\r\n\r\n                if (!evaluatedObject)\r\n                    continue;\r\n\r\n                if (!objects)\r\n                    objects = {};\r\n\r\n                // NOTE: this currently has last-object-wins semantics.\r\n                objects[objectName] = evaluatedObject;\r\n            }\r\n\r\n            return objects;\r\n        }\r\n\r\n        export function groupObjectsBySelector(objectDefinitions: DataViewObjectDefinitions): DataViewObjectDefinitionsByRepetition {\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n\r\n            let grouped: DataViewObjectDefinitionsByRepetition = {\r\n                data: [],\r\n            };\r\n\r\n            if (objectDefinitions) {\r\n                for (let objectName in objectDefinitions) {\r\n                    let objectDefnList = objectDefinitions[objectName];\r\n\r\n                    for (let i = 0, len = objectDefnList.length; i < len; i++) {\r\n                        let objectDefn = objectDefnList[i];\r\n\r\n                        ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\r\n                            name: objectName,\r\n                            properties: objectDefn.properties,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return grouped;\r\n        }\r\n\r\n        function ensureDefinitionListForSelector(grouped: DataViewObjectDefinitionsByRepetition, selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(grouped, 'grouped');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!selector) {\r\n                if (!grouped.metadataOnce)\r\n                    grouped.metadataOnce = { objects: [] };\r\n                return grouped.metadataOnce;\r\n            }\r\n\r\n            let groupedObjects: DataViewObjectDefinitionsForSelector[];\r\n            if (selector.data) {\r\n                groupedObjects = grouped.data;\r\n            }\r\n            else if (selector.metadata) {\r\n                if (!grouped.metadata)\r\n                    grouped.metadata = [];\r\n                groupedObjects = grouped.metadata;\r\n            }\r\n            else if (selector.id) {\r\n                if (!grouped.userDefined)\r\n                    grouped.userDefined = [];\r\n                groupedObjects = grouped.userDefined;\r\n            }\r\n\r\n            debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\r\n\r\n            for (let item of groupedObjects) {\r\n                if (Selector.equals(selector, item.selector))\r\n                    return item;\r\n            }\r\n\r\n            let item: DataViewObjectDefinitionsForSelector = {\r\n                selector: selector,\r\n                objects: [],\r\n            };\r\n            groupedObjects.push(item);\r\n\r\n            return item;\r\n        }\r\n\r\n        export function addImplicitObjects(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            if (selectTransforms) {\r\n                addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n                addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n            }\r\n        }\r\n\r\n        function addDefaultFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let formatStringProp = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            if (!formatStringProp)\r\n                return;\r\n\r\n            for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n                let selectTransform = selectTransforms[selectIdx];\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyFormatString(\r\n                    objectsForAllSelectors,\r\n                    formatStringProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\r\n            }\r\n        }\r\n\r\n        /** Registers properties for default value, if the properties are not explicitly provided. */\r\n        function addDefaultValue (\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let defaultValueProp = DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\r\n            if (!defaultValueProp)\r\n                return;\r\n\r\n            for (let selectTransform of selectTransforms) {\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyDefaultValue(\r\n                    objectsForAllSelectors,\r\n                    defaultValueProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.defaultValue);\r\n            }\r\n        }\r\n\r\n        function getColumnFormatForIndex(columns: DataViewMetadataColumn[], selectIdx: number): string {\r\n            for (let columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\r\n                let column = columns[columnIdx];\r\n                if (!column || column.index !== selectIdx)\r\n                    continue;\r\n\r\n                return column.format;\r\n            }\r\n        }\r\n\r\n        function applyFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            formatStringProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            formatStringValue: string): void {\r\n            if (!formatStringValue)\r\n                return;\r\n\r\n            // There is a format string specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                formatStringProp,\r\n                { metadata: queryName },\r\n                SQExprBuilder.text(formatStringValue));\r\n        }\r\n\r\n        function applyDefaultValue(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            defaultValueProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            defaultValue: DefaultValueDefinition): void {\r\n            if (!defaultValue)\r\n                return;\r\n\r\n            // There is a default value specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                defaultValueProp,\r\n                { metadata: queryName },\r\n                defaultValue);\r\n        }\r\n\r\n        function applyMetadataProperty(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n\r\n            let objectDefns: DataViewObjectDefinitionsForSelector[];\r\n            if (selector) {\r\n                let metadataObjects = objectsForAllSelectors.metadata;\r\n                if (!metadataObjects)\r\n                    metadataObjects = objectsForAllSelectors.metadata = [];\r\n                objectDefns = metadataObjects;\r\n            }\r\n            else {\r\n                let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n                if (!metadataOnce)\r\n                    metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\r\n                objectDefns = [metadataOnce];\r\n            }\r\n\r\n            let targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\r\n            let targetObjectDefn: DataViewNamedObjectDefinition;\r\n            if (targetMetadataObject) {\r\n                let targetObjectDefns = targetMetadataObject.objects;\r\n                targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\r\n                if (targetObjectDefn) {\r\n                    if (targetObjectDefn.properties[propertyId.propertyName])\r\n                        return;\r\n                }\r\n                else {\r\n                    targetObjectDefn = {\r\n                        name: propertyId.objectName,\r\n                        properties: {},\r\n                    };\r\n                    targetObjectDefns.push(targetObjectDefn);\r\n                }\r\n            }\r\n            else {\r\n                targetObjectDefn = {\r\n                    name: propertyId.objectName,\r\n                    properties: {}\r\n                };\r\n\r\n                objectDefns.push({\r\n                    selector: selector,\r\n                    objects: [targetObjectDefn],\r\n                });\r\n            }\r\n\r\n            targetObjectDefn.properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        function findWithMatchingSelector(objects: DataViewObjectDefinitionsForSelector[], selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(objects, 'objects');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            for (let i = 0, len = objects.length; i < len; i++) {\r\n                let object = objects[i];\r\n                if (Selector.equals(object.selector, selector))\r\n                    return object;\r\n            }\r\n        }\r\n\r\n        function findExistingObject(objectDefns: DataViewNamedObjectDefinition[], objectName: string): DataViewNamedObjectDefinition {\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(objectName, 'objectName');\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefn = objectDefns[i];\r\n\r\n                if (objectDefn.name === objectName)\r\n                    return objectDefn;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n \r\n\r\nmodule powerbi.data {\r\n    /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\r\n    export module DataViewObjectEvaluator {\r\n        const colorValueType: ValueType = ValueType.fromDescriptor({ formatting: { color: true } });\r\n        const numericType: ValueType = ValueType.fromDescriptor({ numeric: true });\r\n        const textType: ValueType = ValueType.fromDescriptor({ text: true });\r\n\r\n        export function run(\r\n            evalContext: IEvalContext,\r\n            objectDescriptor: DataViewObjectDescriptor,\r\n            propertyDefinitions: DataViewObjectPropertyDefinitions): DataViewObject {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\r\n            debug.assertValue(propertyDefinitions, 'propertyDefinitions');\r\n\r\n            if (!objectDescriptor)\r\n                return;\r\n\r\n            let object: DataViewObject,\r\n                propertyDescriptors = objectDescriptor.properties;\r\n            for (let propertyName in propertyDefinitions) {\r\n                let propertyDefinition = propertyDefinitions[propertyName],\r\n                    propertyDescriptor = propertyDescriptors[propertyName];\r\n\r\n                if (!propertyDescriptor)\r\n                    continue;\r\n\r\n                let propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\r\n                if (propertyValue === undefined)\r\n                    continue;\r\n\r\n                if (!object)\r\n                    object = {};\r\n                object[propertyName] = propertyValue;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        /** Note: Exported for testability */\r\n        export function evaluateProperty(\r\n            evalContext: IEvalContext,\r\n            propertyDescriptor: DataViewObjectPropertyDescriptor,\r\n            propertyDefinition: DataViewObjectPropertyDefinition): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(propertyDescriptor, 'propertyDescriptor');\r\n            debug.assertValue(propertyDefinition, 'propertyDefinition');\r\n\r\n            let structuralType = <StructuralTypeDescriptor>propertyDescriptor.type;\r\n            if (structuralType && structuralType.expression)\r\n                return propertyDefinition;\r\n\r\n            let value = evaluateValue(evalContext, <any>propertyDefinition, ValueType.fromDescriptor(propertyDescriptor.type));\r\n            if (value !== undefined || (propertyDefinition instanceof RuleEvaluation))\r\n                return value;\r\n\r\n            return evaluateFill(evalContext, <FillDefinition>propertyDefinition, structuralType)\r\n                || evaluateFillRule(evalContext, <FillRuleDefinition>propertyDefinition, structuralType)\r\n                || evaluateImage(evalContext, <ImageDefinition>propertyDefinition, structuralType)\r\n                || evaluateParagraphs(evalContext, <ParagraphsDefinition>propertyDefinition, structuralType)\r\n                || propertyDefinition;\r\n        }\r\n\r\n        function evaluateFill(evalContext: IEvalContext, fillDefn: FillDefinition, type: StructuralTypeDescriptor): Fill {\r\n            let fillType = type.fill;\r\n            if (!fillType)\r\n                return;\r\n\r\n            if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\r\n                return {\r\n                    solid: {\r\n                        color: evaluateValue(evalContext, fillDefn.solid.color, ValueType.fromExtendedType(ExtendedType.Color)),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateFillRule(evalContext: IEvalContext, fillRuleDefn: FillRuleDefinition, type: StructuralTypeDescriptor): FillRule {\r\n            if (!type.fillRule)\r\n                return;\r\n\r\n            if (fillRuleDefn.linearGradient2) {\r\n                let linearGradient2 = fillRuleDefn.linearGradient2;\r\n                return {\r\n                    linearGradient2: {\r\n                        min: evaluateColorStop(evalContext, linearGradient2.min),\r\n                        max: evaluateColorStop(evalContext, linearGradient2.max),\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (fillRuleDefn.linearGradient3) {\r\n                let linearGradient3 = fillRuleDefn.linearGradient3;\r\n                return {\r\n                    linearGradient3: {\r\n                        min: evaluateColorStop(evalContext, linearGradient3.min),\r\n                        mid: evaluateColorStop(evalContext, linearGradient3.mid),\r\n                        max: evaluateColorStop(evalContext, linearGradient3.max),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateColorStop(evalContext: IEvalContext, colorStop: RuleColorStopDefinition): RuleColorStop {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(colorStop, 'colorStop');\r\n\r\n            let step: RuleColorStop = {\r\n                color: evaluateValue(evalContext, colorStop.color, colorValueType),\r\n            };\r\n\r\n            let value = evaluateValue(evalContext, colorStop.value, numericType);\r\n            if (value != null)\r\n                step.value = value;\r\n\r\n            return step;\r\n        }\r\n\r\n        function evaluateImage(evalContext: IEvalContext, definition: ImageDefinition, type: StructuralTypeDescriptor): ImageValue {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.image || !definition)\r\n                return;\r\n\r\n            let value: ImageValue = {\r\n                name: evaluateValue(evalContext, definition.name, textType),\r\n                url: evaluateValue(evalContext, definition.url, ValueType.fromDescriptor(ImageDefinition.urlType)),\r\n            };\r\n\r\n            if (definition.scaling)\r\n                value.scaling = evaluateValue(evalContext, definition.scaling, textType);\r\n\r\n            return value;\r\n        }\r\n\r\n        function evaluateParagraphs(evalContext: IEvalContext, definition: ParagraphsDefinition, type: StructuralTypeDescriptor): Paragraphs {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.paragraphs || !definition)\r\n                return;\r\n\r\n            return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\r\n        }\r\n\r\n        function evaluateParagraph(evalContext: IEvalContext, definition: ParagraphDefinition): Paragraph {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: Paragraph;\r\n\r\n            let definitionTextRuns = definition.textRuns;\r\n            let evaluatedTextRuns: TextRun[] = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\r\n            if (definitionTextRuns !== evaluatedTextRuns) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.textRuns = evaluatedTextRuns;\r\n            }\r\n\r\n            return evaluated || <Paragraph>definition;\r\n        }\r\n\r\n        function evaluateTextRun(evalContext: IEvalContext, definition: TextRunDefinition): TextRun {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: TextRun;\r\n\r\n            let definitionValue = definition.value;\r\n            let evaluatedValue = evaluateValue(evalContext, <any> definitionValue, textType);\r\n            if (evaluatedValue !== undefined) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.value = evaluatedValue;\r\n            }\r\n\r\n            return evaluated || <TextRun>definition;\r\n        }\r\n\r\n        /**\r\n         * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\r\n         * other than the input to it.\r\n         */\r\n        function evaluateArrayCopyOnChange<TDefinition, TEvaluated>(\r\n            evalContext: IEvalContext,\r\n            definitions: TDefinition[],\r\n            evaluator: (ctx: IEvalContext, defn: TDefinition) => TEvaluated): TEvaluated[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definitions, 'definitions');\r\n            debug.assertValue(evaluator, 'evaluator');\r\n\r\n            let evaluatedValues: TEvaluated[];\r\n\r\n            for (let i = 0, len = definitions.length; i < len; i++) {\r\n                let definition = definitions[i];\r\n                let evaluated: TEvaluated = evaluator(evalContext, definition);\r\n\r\n                // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\r\n                // between TEvaluated & TDefinition\r\n                if (!evaluatedValues && <any>definition !== evaluated) {\r\n                    evaluatedValues = _.take(<TEvaluated[]><any>definitions, i);\r\n                }\r\n\r\n                if (evaluatedValues) {\r\n                    evaluatedValues.push(evaluated);\r\n                }\r\n            }\r\n\r\n            return evaluatedValues || <TEvaluated[]><any>definitions;\r\n        }\r\n\r\n        function evaluateValue(evalContext: IEvalContext, definition: SQExpr | RuleEvaluation, valueType: ValueType): any {\r\n            if (definition instanceof SQExpr)\r\n                return ExpressionEvaluator.evaluate(definition, evalContext);\r\n\r\n            if (definition instanceof RuleEvaluation)\r\n                return definition.evaluate(evalContext);\r\n        }\r\n\r\n        /** Responsible for evaluating SQExprs into values. */\r\n        class ExpressionEvaluator extends DefaultSQExprVisitorWithArg<PrimitiveValue, IEvalContext> {\r\n            private static instance: ExpressionEvaluator = new ExpressionEvaluator();\r\n\r\n            public static evaluate(expr: SQExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                if (expr == null)\r\n                    return;\r\n\r\n                return expr.accept(ExpressionEvaluator.instance, evalContext);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return expr.value;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitFillRule(expr: SQFillRuleExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                let inputValue = expr.input.accept(this, evalContext);\r\n                if (inputValue !== undefined) {\r\n                    let colorAllocator = evalContext.getColorAllocator(expr);\r\n                    if (colorAllocator) {\r\n                        return colorAllocator.color(inputValue);\r\n                    }\r\n                }\r\n            }\r\n\r\n            public visitSelectRef(expr: SQSelectRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n        }\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n\r\n    export module DataViewPivotCategorical {\r\n        /**\r\n         * Pivots categories in a categorical DataView into valueGroupings.\r\n         * This is akin to a mathematical matrix transpose.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return null;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return null;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values) || values.source)\r\n                return null;\r\n\r\n            let category = categories[0],\r\n                categoryIdentities = category.identity,\r\n                categoryValues = category.values,\r\n                pivotedColumns: DataViewMetadataColumn[] = [],\r\n                pivotedValues: DataViewValueColumn[] = [];\r\n            for (let rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\r\n                let categoryValue = categoryValues[rowIdx],\r\n                    categoryIdentity = categoryIdentities[rowIdx];\r\n                for (let colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\r\n                    let value = values[colIdx],\r\n                        pivotedColumn = inherit(value.source);\r\n\r\n                    // A value has a series group, which is not implemented for pivoting -- just give up.\r\n                    if (value.identity)\r\n                        return null;\r\n\r\n                    pivotedColumn.groupName = categoryValue;\r\n                    let pivotedValue: DataViewValueColumn = {\r\n                        source: pivotedColumn,\r\n                        values: [value.values[rowIdx]],\r\n                        identity: categoryIdentity,\r\n                        min: value.min,\r\n                        max: value.max,\r\n                        subtotal: value.subtotal\r\n                    };\r\n\r\n                    let highlights = value.highlights;\r\n                    if (highlights) {\r\n                        pivotedValue.highlights = [highlights[rowIdx]];\r\n                    }\r\n\r\n                    pivotedColumns.push(pivotedColumn);\r\n                    pivotedValues.push(pivotedValue);\r\n                }\r\n            }\r\n\r\n            let pivotedMetadata = inherit(dataView.metadata);\r\n            pivotedMetadata.columns = pivotedColumns;\r\n\r\n            values = DataViewTransform.createValueColumns(pivotedValues, <SQExpr[]>category.identityFields, category.source);\r\n            return {\r\n                metadata: pivotedMetadata,\r\n                categorical: {\r\n                    values: values,\r\n                },\r\n                matrix: dataView.matrix\r\n            };\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewPivotMatrix {\r\n        /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\r\n        export function apply(dataViewMatrix: DataViewMatrix, context: MatrixTransformationContext): void {\r\n            debug.assertValue(dataViewMatrix, 'dataViewMatrix');\r\n\r\n            if (!context.columnHierarchyRewritten)\r\n                dataViewMatrix.columns = Prototype.inherit(dataViewMatrix.columns);\r\n            let columns = dataViewMatrix.columns;\r\n\r\n            if (!context.rowHierarchyRewritten)\r\n                dataViewMatrix.rows = Prototype.inherit(dataViewMatrix.rows);\r\n            let rows = dataViewMatrix.rows;\r\n\r\n            if (columns.levels.length > 1)\r\n                return;\r\n\r\n            let pivotedRowNode: DataViewMatrixNode = {\r\n                level: 0\r\n            };\r\n\r\n            let columnLeafNodes: DataViewMatrixNode[] = columns.root.children;\r\n            let measureCount = columnLeafNodes.length;\r\n\r\n            // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\r\n            // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\r\n            // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \r\n            // in a matrix with 2+ column fields and 2+ measure fields.\r\n            // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\r\n            // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\r\n            let pivotResultMeasureHeaderLevel = rows.levels.length;\r\n\r\n            if (measureCount > 0) {\r\n                let index = 0;\r\n                let callback = function (node: DataViewMatrixNode) {\r\n                    // Collect values and remove them from row leaves\r\n                    if (node.values) {\r\n                        if (!pivotedRowNode.values)\r\n                            pivotedRowNode.values = {};\r\n\r\n                        for (let i = 0; i < measureCount; i++)\r\n                            pivotedRowNode.values[index++] = node.values[i];\r\n\r\n                        delete node.values;\r\n                    }\r\n\r\n                    // Create measure headers if there are more than one measures\r\n                    if (measureCount > 1) {\r\n                        if (!node.children)\r\n                            node.children = [];\r\n\r\n                        for (let j = 0; j < measureCount; j++) {\r\n                            let measureHeaderLeaf: DataViewMatrixNode = { level: pivotResultMeasureHeaderLevel };\r\n\r\n                            // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\r\n                            let columnLeafNode = columnLeafNodes[j];\r\n                            measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\r\n\r\n                            if (node.isSubtotal)\r\n                                measureHeaderLeaf.isSubtotal = true;\r\n\r\n                            node.children.push(measureHeaderLeaf);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                if (context.hierarchyTreesRewritten) {\r\n                    forEachLeaf(rows.root, callback);\r\n                }\r\n                else {\r\n                    dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\r\n                }\r\n            }\r\n            else {\r\n                if (!context.hierarchyTreesRewritten) {\r\n                    dataViewMatrix.columns.root = cloneTree(rows.root);\r\n                }\r\n            }\r\n\r\n            if (measureCount > 1) {\r\n                // Keep measure headers, but move them to the innermost level\r\n                let level: DataViewHierarchyLevel = { sources: columns.levels[0].sources };\r\n                rows.levels.push(level);\r\n\r\n                columns.levels.length = 0;\r\n            }\r\n\r\n            if (context.hierarchyTreesRewritten) {\r\n                dataViewMatrix.columns.root = rows.root;\r\n                dataViewMatrix.rows.root = {\r\n                    children: [pivotedRowNode]\r\n                };\r\n            }\r\n            else {\r\n                let updatedRowRoot = Prototype.inherit(dataViewMatrix.rows.root);\r\n                updatedRowRoot.children = [pivotedRowNode];\r\n                dataViewMatrix.rows.root = updatedRowRoot;\r\n            }\r\n\r\n            dataViewMatrix.columns.levels = rows.levels;\r\n            dataViewMatrix.rows.levels = [];\r\n        }\r\n\r\n        function forEachLeaf(root: DataViewMatrixNode, callback: (node: DataViewMatrixNode) => void): void {\r\n            let children = root.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachLeaf(children[i], callback);\r\n\r\n                return;\r\n            }\r\n\r\n            callback(root);\r\n        }\r\n\r\n        export function cloneTree(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            return cloneTreeExecuteOnLeaf(node);\r\n        }\r\n\r\n        export function cloneTreeExecuteOnLeaf(node: DataViewMatrixNode, callback?: (node: DataViewMatrixNode) => void): DataViewMatrixNode {\r\n            let updatedNode = Prototype.inherit(node);\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                let newChildren: DataViewTreeNode[] = [];\r\n\r\n                for (let i = 0, ilen = children.length; i < ilen; i++) {\r\n                    let updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\r\n                    newChildren.push(updatedChild);\r\n                }\r\n                updatedNode.children = newChildren;\r\n            }\r\n            else {\r\n                if (callback)\r\n                    callback(updatedNode);\r\n            }\r\n\r\n            return updatedNode;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewSelfCrossJoin {\r\n        /**\r\n         * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\r\n         * to itself as a value grouping.\r\n         * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            if (!dataView.categorical)\r\n                return;\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\r\n                return;\r\n            if (dataViewCategorical.values && dataViewCategorical.values.source)\r\n                return;\r\n\r\n            return applyCategorical(dataView.metadata, dataViewCategorical);\r\n        }\r\n\r\n        function applyCategorical(dataViewMetadata: DataViewMetadata, dataViewCategorical: DataViewCategorical): DataView {\r\n            debug.assertValue(dataViewMetadata, 'dataViewMetadata');\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\r\n\r\n            let category = dataViewCategorical.categories[0],\r\n                categoryValues = category.values,\r\n                categoryLength = categoryValues.length;\r\n\r\n            if (categoryLength === 0)\r\n                return;\r\n\r\n            let valuesArray: DataViewValueColumn[] = dataViewCategorical.values\r\n                ? dataViewCategorical.values.grouped()[0].values\r\n                : [];\r\n            let transformedDataView = createCategoricalDataViewBuilder()\r\n                .withCategories(dataViewCategorical.categories)\r\n                .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\r\n                .build();\r\n\r\n            dataViewMetadata = Prototype.inherit(dataViewMetadata);\r\n            dataViewMetadata.columns = transformedDataView.metadata.columns;\r\n\r\n            return {\r\n                metadata: dataViewMetadata,\r\n                categorical: transformedDataView.categorical,\r\n            };\r\n        }\r\n\r\n        function createGroupedValues(\r\n            category: DataViewCategoryColumn,\r\n            categoryValues: any[],\r\n            categoryLength: number,\r\n            valuesArray: DataViewValueColumn[]): DataViewBuilderGroupedValuesOptions {\r\n            debug.assertValue(category, 'category');\r\n            debug.assertValue(categoryValues, 'categoryValues');\r\n            debug.assertValue(categoryLength, 'categoryLength');\r\n            debug.assertValue(valuesArray, 'valuesArray');\r\n\r\n            let nullValuesArray: any[] = createNullValues(categoryLength),\r\n                valuesArrayLen = valuesArray.length,\r\n                seriesData: DataViewBuilderSeriesData[][] = [];\r\n\r\n            for (let i = 0; i < categoryLength; i++) {\r\n                let seriesDataItem: DataViewBuilderSeriesData[] = [];\r\n\r\n                for (let j = 0; j < valuesArrayLen; j++) {\r\n                    let originalValueColumn = valuesArray[j],\r\n                        originalHighlightValues = originalValueColumn.highlights;\r\n\r\n                    let seriesDataItemCategory: DataViewBuilderSeriesData = {\r\n                        values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\r\n                    };\r\n                    if (originalHighlightValues)\r\n                        seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\r\n\r\n                    seriesDataItem.push(seriesDataItemCategory);\r\n                }\r\n\r\n                seriesData.push(seriesDataItem);\r\n            }\r\n\r\n            return {\r\n                groupColumn: {\r\n                    source: category.source,\r\n                    identityFrom: { fields: <SQExpr[]>category.identityFields, identities: category.identity },\r\n                    values: category.values,\r\n                },\r\n                valueColumns: _.map(valuesArray, v => <DataViewBuilderColumnOptions>{ source: v.source }),\r\n                data: seriesData,\r\n            };\r\n        }\r\n    }\r\n\r\n    function createNullValues(length: number): any[] {\r\n        debug.assertValue(length, 'length');\r\n\r\n        let array = new Array(length);\r\n        for (let i = 0; i < length; i++)\r\n            array[i] = null;\r\n        return array;\r\n    }\r\n\r\n    function inheritArrayWithValue(nullValues: any[], original: any[], index: number): any[] {\r\n        let inherited = Prototype.inherit(nullValues);\r\n        inherited[index] = original[index];\r\n\r\n        return inherited;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\r\n    import inheritSingle = powerbi.Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export module DataViewPivotCategoricalToPrimaryGroups {\r\n\r\n        /**\r\n         * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\r\n         * pivot the secondary before the primary.\r\n         */\r\n        export function pivotBinding(binding: DataShapeBinding, allMappings: CompiledDataViewMapping[], finalMapping: CompiledDataViewMapping, defaultDataVolume: number): void {\r\n            // unpivot is inferred from result in DataViewTransform.apply but it does not have the\r\n            // compiled mappings available, let alone the merged mapping, only the original\r\n            // DataViewMappings. to keep that inference easy, only apply pivot when there's\r\n            // only one matching mapping\r\n            if (!allMappings || allMappings.length !== 1)\r\n                return;\r\n\r\n            if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\r\n                return;\r\n\r\n            if (!binding)\r\n                return;\r\n\r\n            if (!canPivotCategorical(binding, finalMapping))\r\n                return;\r\n\r\n            // pivot secondary onto front of primary\r\n            binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\r\n\r\n            binding.Secondary = undefined;\r\n        \r\n            // set primary to pivot reduction\r\n            binding.DataReduction = {\r\n                Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\r\n                DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\r\n            };\r\n        }\r\n\r\n        /** narrowly targets scatter chart scenario for now to keep code simple */\r\n        function isPivotableAxis(axis: powerbi.data.DataShapeBindingAxis): boolean {\r\n            return axis\r\n                && axis.Groupings\r\n                && axis.Groupings.length === 1\r\n                && !_.isEmpty(axis.Groupings[0].Projections)\r\n                && !axis.Groupings[0].Subtotal\r\n                && _.isEmpty(axis.Groupings[0].SuppressedProjections);\r\n        }\r\n\r\n        function canPivotCategorical(binding: DataShapeBinding, mapping: CompiledDataViewMapping): boolean {\r\n            if (!isPivotableAxis(binding.Primary))\r\n                return false;\r\n            if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\r\n                return false;\r\n\r\n            // don't pivot if either axis has a data reduction\r\n            if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        export function unpivotResult(oldDataView: DataView, selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\r\n                return oldDataView;\r\n\r\n            // This returns a subsetted version of the DataView rather than using prototypal inheritance because\r\n            // any dataviews in the old one (including ones invented after this code is written) will correspond\r\n            // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\r\n            // querying code made.\r\n            let newDataView: DataView = {\r\n                metadata: {\r\n                    columns: ArrayExtensions.copy(oldDataView.metadata.columns),\r\n                },\r\n            };\r\n            \r\n            // preserve view types that aren't affected by pivoting\r\n            if (oldDataView.single)\r\n                newDataView.single = oldDataView.single;\r\n            if (oldDataView.table)\r\n                newDataView.table = oldDataView.table;\r\n\r\n            // other views are derived from matrix\r\n            if (oldDataView.matrix) {\r\n                let newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\r\n\r\n                // categorical only if there's data\r\n                if (!_.isEmpty(newDataViewMatrix.valueSources)) {\r\n                    // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \r\n                    // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\r\n                    // this.canPivotCategorical() would have returned false in the first place for this query.\r\n                    let hasCompositeGroupInSeries = utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\r\n                    if (!hasCompositeGroupInSeries) {\r\n                        newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return newDataView;\r\n        }\r\n\r\n        /**\r\n         * Infer from the query result and the visual mappings whether the query was pivoted.\r\n         * Narrowly targets scatter chart scenario for now to keep code simple\r\n         */\r\n        function inferUnpivotTransform(selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], dataView: DataView, projectionActiveItems: DataViewProjectionActiveItems): boolean {\r\n            if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\r\n                return false;\r\n\r\n            // select applicable mappings based on select roles\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\r\n            let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let supportedDataViewMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\r\n            if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\r\n                return false;\r\n\r\n            let categoricalMapping = supportedDataViewMappings[0].categorical;\r\n            if (!categoricalMapping)\r\n                return false;\r\n\r\n            // pivoted query will have produced a matrix\r\n            let matrixDataview = dataView.matrix;\r\n            if (!matrixDataview)\r\n                return false;\r\n\r\n            // matrix must have two levels of grouping\r\n            if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\r\n                return false;\r\n            \r\n            // get category and value grouping roles\r\n            let categoryGroups: string[] = [];\r\n            let valueGroups: string[] = [];\r\n\r\n            let addGroupingRole = (roleName: string, groups: string[]) => {\r\n                let roleProjections: QueryProjectionCollection = projections[roleName];\r\n                if (!roleProjections)\r\n                    return;\r\n\r\n                for (let roleProjection of roleProjections.all()) {\r\n                    if (roleKinds[roleProjection.queryRef] === VisualDataRoleKind.Grouping)\r\n                        groups.push(roleProjection.queryRef);\r\n                }\r\n            };\r\n\r\n            DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, categoryGroups); }\r\n            });\r\n\r\n            DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, valueGroups); }\r\n            });\r\n\r\n            // need both for pivot to have been done\r\n            if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\r\n                return false;\r\n\r\n            // if there was a pivot, there won't be any measures left in the columns\r\n            for (let level of matrixDataview.columns.levels) {\r\n                for (let source of level.sources) {\r\n                    if (!source.isMeasure)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        interface DataViewMatrixNodeValues {\r\n            [id: number]: DataViewMatrixNodeValue;\r\n        }\r\n\r\n        /**\r\n         * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\r\n         * this function changes that so that the categories become the rows and the series the columns.\r\n         */\r\n        function unpivotMatrix(oldMatrix: DataViewMatrix): DataViewMatrix {\r\n            let oldRows = oldMatrix.rows;\r\n            let oldRoot = oldRows.root;\r\n            let oldChildren = oldRoot.children;\r\n\r\n            // series are the outer grouping\r\n            let series: DataViewMatrixNode[] = [];\r\n            let seriesIdLevel = oldRows.levels[0];\r\n            let seriesIdFields = oldRoot.childIdentityFields;\r\n\r\n            // categories are the inner grouping. \r\n            let categoryIndex: _.Dictionary<number> = {};\r\n            let categories: DataViewMatrixNode[] = [];\r\n            let categoryIdLevel = oldRows.levels[1];\r\n            let categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\r\n\r\n            let measureCount = oldMatrix.valueSources.length;\r\n\r\n            // within each series value, the category list may not be complete so cannot simply use the inner loop index\r\n            // to reference it.\r\n            let findCategory = (identity: DataViewScopeIdentity) => {\r\n                let index = categoryIndex[identity.key];\r\n\r\n                debug.assert(index !== undefined, \"findcat() !== undefined\");\r\n\r\n                return index;\r\n            };\r\n\r\n            // collect series and categories from the row hierarchy\r\n            if (oldChildren) {\r\n                let addCategory = (categoryNode: DataViewMatrixNode) => {\r\n                    let key = categoryNode.identity.key;\r\n                    let index = categoryIndex[key];\r\n                    if (index === undefined) {\r\n                        index = categories.length;\r\n                        categoryIndex[key] = index;\r\n                        categories.push(categoryNode);\r\n                    }\r\n                };\r\n\r\n                for (let seriesNode of oldChildren) {\r\n                    series.push(seriesNode);\r\n\r\n                    for (let categoryNode of seriesNode.children) {\r\n                        addCategory(categoryNode);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // extract intersection values from pivoted matrix\r\n            // values will be indexed by categories then series\r\n            let matrixValues: DataViewMatrixNodeValues[][] = new Array<DataViewMatrixNodeValues[]>(categories.length);\r\n            for (let j = 0; j < series.length; ++j) { // outer is series\r\n                let seriesNode = oldChildren[j];\r\n                for (let categoryNode of seriesNode.children) { // inner is categories but maybe a subset\r\n                    let i = findCategory(categoryNode.identity); // must lookup actual category index\r\n\r\n                    if (!matrixValues[i])\r\n                        matrixValues[i] = new Array<DataViewMatrixNodeValues>(series.length);\r\n\r\n                    matrixValues[i][j] = categoryNode.values;\r\n                }\r\n            }\r\n\r\n            // columns of the unpivoted matrix are the series\r\n            let newColumns: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(series, s => {\r\n                        let inheritedNode = inheritSingle(s);\r\n                        inheritedNode.level = 0; // s.level should already be 0, but just in case...\r\n                        inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\r\n                        inheritedNode.childIdentityFields = undefined;\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: seriesIdFields,\r\n                },\r\n                levels: [\r\n                    seriesIdLevel,\r\n                    \r\n                ],\r\n            };\r\n\r\n            // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\r\n            if (measureCount > 0) {\r\n                let newColChildren: DataViewMatrixNode[] = _.map(oldMatrix.columns.root.children, (srcnode: DataViewMatrixNode) => {\r\n                    let dstnode: DataViewMatrixNode = { level: 1 };\r\n                    if (srcnode.levelSourceIndex)\r\n                        dstnode.levelSourceIndex = srcnode.levelSourceIndex;\r\n                    return dstnode;\r\n                });\r\n\r\n                for (let i = 0; i < newColumns.root.children.length; ++i)\r\n                    newColumns.root.children[i].children = newColChildren;\r\n\r\n                newColumns.levels.push(oldMatrix.columns.levels[0]);\r\n            }\r\n\r\n            // rows of the unpivoted matrix are the categories\r\n            let newRows: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(categories, c => {\r\n                        let inheritedNode = inheritSingle(c);\r\n                        inheritedNode.level = 0;\r\n                        inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\r\n                        inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: categoryIdFields,\r\n                },\r\n                levels: [\r\n                    categoryIdLevel,\r\n                ],\r\n            };\r\n\r\n            // put values into rows\r\n            if (measureCount > 0) {\r\n                for (let i = 0; i < categories.length; ++i) {\r\n                    let row = newRows.root.children[i];\r\n                    let rowValues: DataViewMatrixNodeValues = {};\r\n\r\n                    for (let j = 0; j < series.length; ++j) {\r\n                        let mvalues = matrixValues[i] && matrixValues[i][j];\r\n                        for (let k = 0; k < measureCount; ++k) {\r\n                            let l = j * measureCount + k;\r\n                            rowValues[l] = !mvalues\r\n                                ? ( k === 0 ? { value: null } : { value: null, valueSourceIndex: k } )\r\n                                : mvalues[k];\r\n                        }\r\n                    }\r\n\r\n                    row.values = rowValues;\r\n                }\r\n            }\r\n\r\n            let newMatrix: DataViewMatrix = {\r\n                rows: newRows,\r\n                columns: newColumns,\r\n                valueSources: oldMatrix.valueSources,\r\n            };\r\n\r\n            return newMatrix;\r\n        }\r\n\r\n        /** build a categorical data view from an unpivoted matrix. */\r\n        function categoricalFromUnpivotedMatrix(matrix: DataViewMatrix, columnMetadata: DataViewMetadataColumn[]): DataViewCategorical {\r\n            let seriesCount = matrix.columns.root.children.length;\r\n            let measureMetadata = matrix.valueSources;\r\n            let measureCount = measureMetadata.length;\r\n\r\n            let categories: DataViewCategoryColumn[] = createCategoryColumnsFromUnpivotedMatrix(matrix);\r\n\r\n            // create grouped values\r\n            let groups: DataViewValueColumnGroup[] = [];\r\n            for (let j = 0; j < seriesCount; ++j) {\r\n                let seriesColumn = matrix.columns.root.children[j];\r\n                let group: DataViewValueColumnGroup = {\r\n                    values: [],\r\n                    identity: seriesColumn.identity,\r\n                    name: seriesColumn.value || null,\r\n                };\r\n\r\n                groups.push(group);\r\n\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    let valueColumnMetadataSrc = measureMetadata[k];\r\n                    let valueColumnMetadataDst: DataViewMetadataColumn = <DataViewMetadataColumn>{};\r\n                    for (let key in valueColumnMetadataSrc)\r\n                        valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\r\n                    valueColumnMetadataDst.groupName = group.name;\r\n\r\n                    columnMetadata.push(valueColumnMetadataDst);\r\n\r\n                    let valueColumn: DataViewValueColumn = {\r\n                        source: valueColumnMetadataDst,\r\n                        values: [],\r\n                        identity: group.identity,\r\n                    };\r\n\r\n                    group.values.push(valueColumn);\r\n\r\n                    // grab measure values in the group from across rows of matrix\r\n                    let index = k + j * measureCount;\r\n\r\n                    for (let categoryNode of matrix.rows.root.children) {\r\n                        let value = categoryNode.values[index].value;\r\n\r\n                        valueColumn.values.push(value);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // and now ungrouped\r\n            let values: DataViewValueColumns = <DataViewValueColumns>[];\r\n            for (let group of groups) {\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    values.push(group.values[k]);\r\n                }\r\n            }\r\n\r\n            values.grouped = () => groups;\r\n            values.identityFields = matrix.columns.root.childIdentityFields;\r\n            values.source = matrix.columns.levels[0].sources[0];\r\n\r\n            // final assembly\r\n            let categorical: DataViewCategorical = {\r\n                categories: categories,\r\n                values: values,\r\n            };\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix: DataViewMatrix): DataViewCategoryColumn[] {\r\n            debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\r\n            debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1),\r\n                'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\r\n\r\n            // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \r\n            // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \r\n            // same amongst the resulting DataViewCategoryColumns.\r\n            let categoryIdentity = _.map(unpivotedMatrix.rows.root.children, x => x.identity);\r\n            let categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\r\n            let categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\r\n\r\n            let categories: DataViewCategoryColumn[] = [];\r\n            for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\r\n                let groupLevelValues = _.map(unpivotedMatrix.rows.root.children, (categoryNode: DataViewMatrixNode) => {\r\n                    let levelValues: DataViewMatrixGroupValue[] = categoryNode.levelValues;\r\n\r\n                    // Please refer to the interface comments on when this is undefined... But in today's code\r\n                    // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \r\n                    if (levelValues !== undefined) {\r\n                        debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i),\r\n                            'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\r\n                        return levelValues[i].value;\r\n                    }\r\n                });\r\n\r\n                categories.push({\r\n                    source: categorySourceColumns[i],\r\n                    values: groupLevelValues,\r\n                    identity: categoryIdentity,\r\n                    identityFields: categoryIdentityFields,\r\n                });\r\n            }\r\n\r\n            return categories;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n    import INumberDictionary = jsCommon.INumberDictionary;\r\n\r\n    export interface DataViewTransformApplyOptions {\r\n        prototype: DataView;\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        dataViewMappings?: DataViewMapping[];\r\n        transforms: DataViewTransformActions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /** Describes the Transform actions to be done to a prototype DataView. */\r\n    export interface DataViewTransformActions {\r\n        /** Describes transform metadata for each semantic query select item, as the arrays align, by index. */\r\n        selects?: DataViewSelectTransform[];\r\n\r\n        /** Describes the DataViewObject definitions. */\r\n        objects?: DataViewObjectDefinitions;\r\n\r\n        /** Describes the splitting of a single input DataView into multiple DataViews. */\r\n        splits?: DataViewSplitTransform[];\r\n\r\n        /** Describes the projection metadata which includes projection ordering and active items. */\r\n        roles?: DataViewRoleTransformMetadata;\r\n    }\r\n\r\n    export interface DataViewSplitTransform {\r\n        selects: INumberDictionary<boolean>;\r\n    }\r\n\r\n    export interface DataViewProjectionOrdering {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItemInfo {\r\n        queryRef: string;\r\n\r\n        /** Describes if the active item should be ignored in concatenation.\r\n            If the active item has a drill filter, it will not be used in concatenation.\r\n            If the value of suppressConcat is true, the activeItem will be ommitted from concatenation. */\r\n        suppressConcat?: boolean;\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItems {\r\n        [roleName: string]: DataViewProjectionActiveItemInfo[];\r\n    }\r\n\r\n    export interface DataViewRoleTransformMetadata {\r\n        /** Describes the order of selects (referenced by query index) in each role. */\r\n        ordering?: DataViewProjectionOrdering;\r\n\r\n        /** Describes the active items in each role. */\r\n        activeItems?: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export interface MatrixTransformationContext {\r\n        rowHierarchyRewritten: boolean;\r\n        columnHierarchyRewritten: boolean;\r\n        hierarchyTreesRewritten: boolean;\r\n    }\r\n\r\n    interface ValueRewrite<T> {\r\n        from: T;\r\n        to: T;\r\n    }\r\n\r\n    interface NumberToNumberMapping {\r\n        [position: number]: number;\r\n    }\r\n\r\n    const enum CategoricalDataViewTransformation {\r\n        None,\r\n        Pivot,\r\n        SelfCrossJoin,\r\n    }\r\n\r\n    export const enum StandardDataViewKinds {\r\n        None = 0,\r\n        Categorical = 1,\r\n        Matrix = 1 << 1,\r\n        Single = 1 << 2,\r\n        Table = 1 << 3,\r\n        Tree = 1 << 4,\r\n    }\r\n\r\n    // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\r\n    export module DataViewTransform {\r\n        const fillRulePropertyDescriptor: DataViewObjectPropertyDescriptor = { type: { fillRule: {} } };\r\n\r\n        const enum ColumnIdentifierKind {\r\n            QueryName,\r\n            Role,\r\n        }\r\n\r\n        export function apply(options: DataViewTransformApplyOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\r\n\r\n            let prototype = options.prototype,\r\n                objectDescriptors = options.objectDescriptors,\r\n                dataViewMappings = options.dataViewMappings,\r\n                transforms = options.transforms,\r\n                projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems,\r\n                colorAllocatorFactory = options.colorAllocatorFactory,\r\n                dataRoles = options.dataRoles;\r\n\r\n            if (!prototype)\r\n                return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\r\n\r\n            if (!transforms)\r\n                return [prototype];\r\n\r\n            // Transform Query DataView\r\n            prototype = DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\r\n            let visualDataViews: DataView[] = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\r\n\r\n            // Transform and generate derived visual DataViews\r\n            visualDataViews = DataViewRegression.run({\r\n                dataViewMappings: dataViewMappings,\r\n                visualDataViews: visualDataViews,\r\n                dataRoles: dataRoles,\r\n                objectDescriptors: objectDescriptors,\r\n                objectDefinitions: transforms.objects,\r\n                colorAllocatorFactory: colorAllocatorFactory,\r\n                transformSelects: transforms.selects,\r\n                metadata: prototype.metadata,\r\n                projectionActiveItems: projectionActiveItems,\r\n            });\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        function transformQueryToVisualDataView(\r\n            prototype: DataView,\r\n            transforms: DataViewTransformActions,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            dataViewMappings: DataViewMapping[],\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[]): DataView[] {\r\n            let transformedDataViews: DataView[] = [];\r\n            let splits = transforms.splits;\r\n            if (_.isEmpty(splits)) {\r\n                transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\r\n            } else {\r\n                for (let split of splits) {\r\n                    let transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\r\n                    transformedDataViews.push(transformed);\r\n                }\r\n            }\r\n            return transformedDataViews;\r\n        }\r\n\r\n        function transformEmptyDataView(objectDescriptors: DataViewObjectDescriptors, transforms: DataViewTransformActions, colorAllocatorFactory: IColorAllocatorFactory): DataView[] {\r\n            if (transforms && transforms.objects) {\r\n                let emptyDataView: DataView = {\r\n                    metadata: {\r\n                        columns: [],\r\n                    }\r\n                };\r\n\r\n                transformObjects(\r\n                    emptyDataView,\r\n                    StandardDataViewKinds.None,\r\n                    objectDescriptors,\r\n                    transforms.objects,\r\n                    transforms.selects,\r\n                    colorAllocatorFactory);\r\n\r\n                return [emptyDataView];\r\n            }\r\n\r\n            return [];\r\n        }\r\n\r\n        function transformDataView(\r\n            prototype: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            transforms: DataViewTransformActions,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[],\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(transforms, 'transforms');\r\n            debug.assert(!selectsToInclude ||\r\n                _.filter(\r\n                    Object.keys(selectsToInclude),\r\n                    (selectIndex) => selectsToInclude[selectIndex] && (!transforms.selects || !transforms.selects[selectIndex]))\r\n                    .length === 0, // asserts that the number of select indices in selectsToInclude without a corresponding Select Transform === 0\r\n                'If selectsToInclude is specified, every Select Index in it must have a corresponding Select Transform.');\r\n\r\n            let targetKinds = getTargetKinds(roleMappings);\r\n            let transformed = inherit(prototype);\r\n            transformed.metadata = inherit(prototype.metadata);\r\n\r\n            let projectionOrdering = transforms.roles && transforms.roles.ordering;\r\n            let projectionActiveItems = transforms.roles && transforms.roles.activeItems;\r\n            transformed = transformSelects(transformed, targetKinds, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\r\n            transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\r\n\r\n            // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\r\n            transformed = DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\r\n\r\n            DataViewNormalizeValues.apply({\r\n                dataview: transformed,\r\n                dataViewMappings: roleMappings,\r\n                dataRoles: dataRoles,\r\n            });\r\n\r\n            return transformed;\r\n        }\r\n\r\n        function getTargetKinds(roleMappings: DataViewMapping[]): StandardDataViewKinds {\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n\r\n            if (!roleMappings)\r\n                return StandardDataViewKinds.None;\r\n\r\n            let result = StandardDataViewKinds.None;\r\n            for (let roleMapping of roleMappings) {\r\n                if (roleMapping.categorical)\r\n                    result |= StandardDataViewKinds.Categorical;\r\n                if (roleMapping.matrix)\r\n                    result |= StandardDataViewKinds.Matrix;\r\n                if (roleMapping.single)\r\n                    result |= StandardDataViewKinds.Single;\r\n                if (roleMapping.table)\r\n                    result |= StandardDataViewKinds.Table;\r\n                if (roleMapping.tree)\r\n                    result |= StandardDataViewKinds.Tree;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function transformSelects(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            roleMappings: DataViewMapping[],\r\n            selectTransforms: DataViewSelectTransform[],\r\n            projectionOrdering?: DataViewProjectionOrdering,\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n\r\n            let columnRewrites: ValueRewrite<DataViewMetadataColumn>[] = [];\r\n            if (selectTransforms) {\r\n                dataView.metadata.columns = applyTransformsToColumns(\r\n                    dataView.metadata.columns,\r\n                    selectTransforms,\r\n                    columnRewrites);\r\n            }\r\n\r\n            // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\r\n\r\n            if (dataView.categorical && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Categorical)) {\r\n                dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                // NOTE: This is slightly DSR-specific.\r\n                dataView = pivotIfNecessary(dataView, roleMappings);\r\n            }\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a matrix.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (dataView.matrix && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Matrix)) {\r\n                let matrixTransformationContext: MatrixTransformationContext = {\r\n                    rowHierarchyRewritten: false,\r\n                    columnHierarchyRewritten: false,\r\n                    hierarchyTreesRewritten: false\r\n                };\r\n                dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                if (shouldPivotMatrix(dataView.matrix, roleMappings))\r\n                    DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\r\n            }\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a table.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (dataView.table && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Table)) {\r\n                dataView.table = applyRewritesToTable(dataView.table, columnRewrites, projectionOrdering);\r\n            }\r\n\r\n            return dataView;\r\n        }\r\n\r\n        function applyTransformsToColumns(\r\n            prototypeColumns: DataViewMetadataColumn[],\r\n            selects: DataViewSelectTransform[],\r\n            rewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn[] {\r\n            debug.assertValue(prototypeColumns, 'columns');\r\n\r\n            if (!selects)\r\n                return prototypeColumns;\r\n\r\n            //column may contain undefined entries\r\n            let columns = inherit(prototypeColumns);\r\n\r\n            for (let i = 0, len = prototypeColumns.length; i < len; i++) {\r\n                let prototypeColumn = prototypeColumns[i];\r\n                let select = selects[prototypeColumn.index];\r\n                if (!select)\r\n                    continue;\r\n\r\n                let column: DataViewMetadataColumn = columns[i] = inherit(prototypeColumn);\r\n\r\n                if (select.roles)\r\n                    column.roles = select.roles;\r\n                if (select.type)\r\n                    column.type = select.type;\r\n                column.format = getFormatForColumn(select, column);\r\n\r\n                if (select.displayName)\r\n                    column.displayName = select.displayName;\r\n                if (select.queryName)\r\n                    column.queryName = select.queryName;\r\n                if (select.kpi)\r\n                    column.kpi = select.kpi;\r\n                if (select.sort)\r\n                    column.sort = select.sort;\r\n                if (select.discourageAggregationAcrossGroups)\r\n                    column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\r\n\r\n                rewrites.push({\r\n                    from: prototypeColumn,\r\n                    to: column,\r\n                });\r\n            }\r\n\r\n            return columns;\r\n        }\r\n\r\n        /**\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Select format\r\n         *  2. Column format\r\n         */\r\n        function getFormatForColumn(select: DataViewSelectTransform, column: DataViewMetadataColumn): string {\r\n            // TODO: we already copied the select.Format to column.format, we probably don't need this check\r\n            return select.format || column.format;\r\n        }\r\n\r\n        function applyRewritesToCategorical(prototype: DataViewCategorical, columnRewrites: ValueRewrite<DataViewMetadataColumn>[], selectsToInclude?: INumberDictionary<boolean>): DataViewCategorical {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            let categorical = inherit(prototype);\r\n\r\n            function override(value: { source?: DataViewMetadataColumn }) {\r\n                let rewrittenSource = findOverride(value.source, columnRewrites);\r\n                if (rewrittenSource) {\r\n                    let rewritten = inherit(value);\r\n                    rewritten.source = rewrittenSource;\r\n                    return rewritten;\r\n                }\r\n            }\r\n\r\n            let categories = Prototype.overrideArray(prototype.categories, override);\r\n            if (categories)\r\n                categorical.categories = categories;\r\n\r\n            let valuesOverride = Prototype.overrideArray(prototype.values, override);\r\n            let valueColumns = valuesOverride || prototype.values;\r\n\r\n            if (valueColumns) {\r\n                if (valueColumns.source) {\r\n                    if (selectsToInclude && !selectsToInclude[valueColumns.source.index]) {\r\n                        // if processing a split and this is the split without series...\r\n                        valueColumns.source = undefined;\r\n                    }\r\n                    else {\r\n                        let rewrittenValuesSource = findOverride(valueColumns.source, columnRewrites);\r\n                        if (rewrittenValuesSource)\r\n                            valueColumns.source = rewrittenValuesSource;\r\n                    }\r\n                }\r\n\r\n                if (selectsToInclude) {\r\n                    // Apply selectsToInclude to values by removing value columns not included\r\n                    for (let i = valueColumns.length - 1; i >= 0; i--) {\r\n                        if (!selectsToInclude[valueColumns[i].source.index]) {\r\n                            valueColumns.splice(i, 1);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let isDynamicSeries = !!valueColumns.source;\r\n\r\n                debug.assert(_.every(valueColumns, (valueColumn) => isDynamicSeries === !!valueColumn.identity),\r\n                    'After applying selectsToInclude, all remaining DataViewValueColumn objects should have a consistent scope type (static vs. dynamic) with the parent DataViewValueColumns object.');\r\n                    \r\n                // Dynamic or not, always update the return values of grouped() to have the rewritten 'source' property\r\n                let seriesGroups: DataViewValueColumnGroup[];\r\n                if (isDynamicSeries) {\r\n                    // We have a dynamic series, so update the return value of grouped() to have the DataViewValueColumn objects with rewritten 'source'.\r\n                    // Also, exclude any column that belongs to a static series.\r\n                    seriesGroups = inherit(valueColumns.grouped());\r\n\r\n                    // The following assert is not a rule that's set in stone.  If it becomes false someday, update the code below to remove static series from seriesGroups.\r\n                    debug.assert(_.every(seriesGroups, (group) => !!group.identity), 'If the categorical has a dynamic series, query DataView is expected to have a grouped() function that returns only dynamic series groups, even when there is any column that belongs to a static group (in the case of combo chart and splits).  If this assertion becomes false someday, update the code below to remove static series from seriesGroups.');\r\n\r\n                    let nextSeriesGroupIndex = 0;\r\n                    let currentSeriesGroup: DataViewValueColumnGroup;\r\n                    for (let i = 0, ilen = valueColumns.length; i < ilen; i++) {\r\n                        let currentValueColumn = valueColumns[i];\r\n                        if (!currentSeriesGroup || (currentValueColumn.identity !== currentSeriesGroup.identity)) {\r\n                            currentSeriesGroup = inherit(seriesGroups[nextSeriesGroupIndex]);\r\n                            seriesGroups[nextSeriesGroupIndex] = currentSeriesGroup;\r\n                            currentSeriesGroup.values = [];\r\n                            nextSeriesGroupIndex++;\r\n                            debug.assert(currentValueColumn.identity === currentSeriesGroup.identity, 'expecting the value columns are sequenced by series groups');\r\n                        }\r\n                        currentSeriesGroup.values.push(currentValueColumn);\r\n                    }\r\n                }\r\n                else {\r\n                    // We are in a static series, so we should throw away the grouped and recreate it using the static values\r\n                    //   which have already been filtered\r\n                    seriesGroups = [{ values: valueColumns }];\r\n                }\r\n\r\n                valueColumns.grouped = () => seriesGroups;\r\n                categorical.values = valueColumns;\r\n            }\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function applyRewritesToTable(\r\n            prototype: DataViewTable,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            projectionOrdering: DataViewProjectionOrdering): DataViewTable {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            let table = inherit(prototype);\r\n\r\n            // Copy the rewritten columns into the table view\r\n            let override = (metadata: DataViewMetadataColumn) => findOverride(metadata, columnRewrites);\r\n            let columns = Prototype.overrideArray(prototype.columns, override);\r\n            if (columns)\r\n                table.columns = columns;\r\n\r\n            if (!projectionOrdering)\r\n                return table;\r\n\r\n            let newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\r\n            if (!newToOldPositions)\r\n                return table;\r\n\r\n            // Reorder the columns\r\n            let columnsClone = columns.slice(0);\r\n            let keys = Object.keys(newToOldPositions);\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let sourceColumn = columnsClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === columns.length)\r\n                    columns.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < columns.length, 'The column index is out of range for reordering.');\r\n                    columns[i] = sourceColumn;\r\n                }\r\n            }\r\n\r\n            // Reorder the rows\r\n            let rows = Prototype.overrideArray(table.rows,\r\n                (row: any[]) => {\r\n                    let newRow: any[] = [];\r\n                    for (let i = 0, len = keys.length; i < len; ++i)\r\n                        newRow[i] = row[newToOldPositions[keys[i]]];\r\n\r\n                    return newRow;\r\n                });\r\n\r\n            if (rows)\r\n                table.rows = rows;\r\n\r\n            return table;\r\n        }\r\n\r\n        /** Creates a mapping of new position to original position. */\r\n        function createTableColumnPositionMapping(\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n            let roles = Object.keys(projectionOrdering);\r\n\r\n            // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\r\n            if (roles.length !== 1)\r\n                return;\r\n\r\n            let role = roles[0],\r\n                originalOrder = _.map(columnRewrites, (rewrite: ValueRewrite<DataViewMetadataColumn>) => rewrite.from.index),\r\n                newOrder = projectionOrdering[role];\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        function applyRewritesToMatrix(\r\n            prototype: DataViewMatrix,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            context: MatrixTransformationContext): DataViewMatrix {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n            debug.assertValue(roleMappings, 'roleMappings');\r\n            \r\n            let firstRoleMappingWithMatrix = _.find(roleMappings, (roleMapping) => !!roleMapping.matrix);\r\n            debug.assertValue(firstRoleMappingWithMatrix, 'roleMappings - at least one role mapping is expected to target DataViewMatrix');\r\n\r\n            let matrixMapping = firstRoleMappingWithMatrix.matrix;\r\n            let matrix = inherit(prototype);\r\n\r\n            function override(metadata: DataViewMetadataColumn) {\r\n                return findOverride(metadata, columnRewrites);\r\n            }\r\n\r\n            function overrideHierarchy(hierarchy: DataViewHierarchy): DataViewHierarchy {\r\n                let rewrittenHierarchy: DataViewHierarchy = null;\r\n\r\n                let newLevels = Prototype.overrideArray(\r\n                    hierarchy.levels,\r\n                    (level: DataViewHierarchyLevel) => {\r\n                        let newLevel: DataViewHierarchyLevel = null;\r\n                        let levelSources = Prototype.overrideArray(level.sources, override);\r\n                        if (levelSources)\r\n                            newLevel = ensureRewritten<DataViewHierarchyLevel>(newLevel, level, h => h.sources = levelSources);\r\n\r\n                        return newLevel;\r\n                    });\r\n                if (newLevels)\r\n                    rewrittenHierarchy = ensureRewritten<DataViewHierarchy>(rewrittenHierarchy, hierarchy, r => r.levels = newLevels);\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n\r\n            let rows = overrideHierarchy(matrix.rows);\r\n            if (rows) {\r\n                matrix.rows = rows;\r\n                context.rowHierarchyRewritten = true;\r\n            }\r\n\r\n            let columns = overrideHierarchy(matrix.columns);\r\n            if (columns) {\r\n                matrix.columns = columns;\r\n                context.columnHierarchyRewritten = true;\r\n            }\r\n\r\n            let valueSources = Prototype.overrideArray(matrix.valueSources, override);\r\n            if (valueSources) {\r\n                matrix.valueSources = valueSources;\r\n\r\n                // Only need to reorder if we have more than one value source, and they are all bound to the same role\r\n                let matrixValues = <DataViewRoleForMapping>matrixMapping.values;\r\n                if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\r\n                    let columnLevels = columns.levels.length;\r\n                    if (columnLevels > 0) {\r\n                        let newToOldPositions = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\r\n                        if (newToOldPositions) {\r\n                            let keys = Object.keys(newToOldPositions);\r\n                            let numKeys = keys.length;\r\n\r\n                            // Reorder the value columns\r\n                            columns.root = DataViewPivotMatrix.cloneTree(columns.root);\r\n                            if (columnLevels === 1)\r\n                                reorderChildNodes(columns.root, newToOldPositions);\r\n                            else\r\n                                forEachNodeAtLevel(columns.root, columnLevels - 2, (node: DataViewMatrixNode) => reorderChildNodes(node, newToOldPositions));\r\n\r\n                            // Reorder the value rows\r\n                            matrix.rows.root = DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, (node: DataViewMatrixNode) => {\r\n\r\n                                if (!node.values)\r\n                                    return;\r\n\r\n                                let newValues: { [id: number]: DataViewTreeNodeValue } = {};\r\n\r\n                                let iterations = Object.keys(node.values).length / numKeys;\r\n                                for (let i = 0, len = iterations; i < len; i++) {\r\n                                    let offset = i * numKeys;\r\n                                    for (let keysIndex = 0; keysIndex < numKeys; keysIndex++)\r\n                                        newValues[offset + keysIndex] = node.values[offset + newToOldPositions[keys[keysIndex]]];\r\n                                }\r\n\r\n                                node.values = newValues;\r\n                            });\r\n\r\n                            context.hierarchyTreesRewritten = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\r\n\r\n            return matrix;\r\n        }\r\n\r\n        function reorderChildNodes(node: DataViewMatrixNode, newToOldPositions: NumberToNumberMapping): void {\r\n            let keys = Object.keys(newToOldPositions);\r\n            let numKeys = keys.length;\r\n            let children = node.children;\r\n\r\n            let childrenClone = children.slice(0);\r\n            for (let i = 0, len = numKeys; i < len; i++) {\r\n                let sourceColumn = childrenClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === children.length)\r\n                    children.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < children.length, 'The column index is out of range for reordering.');\r\n                    children[i] = sourceColumn;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\r\n         * and values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified prototype is necessary.\r\n         */\r\n        function reorderMatrixCompositeGroups(\r\n            prototype: DataViewMatrix,\r\n            supportedDataViewMapping: DataViewMatrixMapping,\r\n            projection: DataViewProjectionOrdering): DataViewMatrix {\r\n\r\n            let transformedDataView: DataViewMatrix;\r\n\r\n            if (prototype && supportedDataViewMapping && projection) {\r\n\r\n                // reorder levelValues in any composite groups in rows hierarchy\r\n                let transformedRowsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedRowsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedRowsHierarchy || prototype.rows,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                // reorder levelValues in any composite groups in columns hierarchy\r\n                let transformedColumnsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedColumnsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedColumnsHierarchy || prototype.columns,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                if (transformedRowsHierarchy || transformedColumnsHierarchy) {\r\n                    transformedDataView = inheritSingle(prototype);\r\n                    transformedDataView.rows = transformedRowsHierarchy || transformedDataView.rows;\r\n                    transformedDataView.columns = transformedColumnsHierarchy || transformedDataView.columns;\r\n                }\r\n            }\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\r\n         * values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\r\n         */\r\n        function reorderMatrixHierarchyCompositeGroups(\r\n            matrixHierarchy: DataViewHierarchy,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): DataViewHierarchy {\r\n            debug.assertValue(matrixHierarchy, 'matrixHierarchy');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n\r\n            let transformedHierarchy: DataViewHierarchy;\r\n            let selectIndicesInProjectionOrder: number[] = projection[hierarchyRole];\r\n\r\n            // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\r\n            let hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\r\n            if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\r\n                for (let i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\r\n                    var hierarchyLevel: DataViewHierarchyLevel = matrixHierarchy.levels[i];\r\n\r\n                    // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\r\n                    let newToOldLevelSourceIndicesMapping: NumberToNumberMapping =\r\n                        createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\r\n\r\n                    if (newToOldLevelSourceIndicesMapping) {\r\n                        if (_.isUndefined(transformedHierarchy)) {\r\n                            // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\r\n                            // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\r\n                            transformedHierarchy = inheritSingle(matrixHierarchy);\r\n                            transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\r\n\r\n                            // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\r\n                            // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\r\n                            // happen in other hierarchy levels in the later iterations of this for-loop.\r\n                            transformedHierarchy.root = utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\r\n                        }\r\n\r\n                        // reorder the metadata columns in the sources array at that level\r\n                        let transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\r\n                        transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\r\n\r\n                        // reorder the level values in the composite group nodes at the current hierarchy level\r\n                        reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return transformedHierarchy;\r\n        }\r\n\r\n        /**\r\n         * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\r\n         * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\r\n         *\r\n         * The returned value maps level source indices from the new target order (calculated from projection order)\r\n         * back to the original order as they appear in the specified hierarchyLevel's sources.\r\n         * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\r\n         *\r\n         * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\r\n         *\r\n         * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\r\n         * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\r\n         * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\r\n         */\r\n        function createMatrixHierarchyLevelSourcesPositionMapping(\r\n            hierarchyLevel: DataViewHierarchyLevel,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): NumberToNumberMapping {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n            debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\r\n\r\n            let newToOldLevelSourceIndicesMapping: NumberToNumberMapping;\r\n            let levelSourceColumns = hierarchyLevel.sources;\r\n\r\n            if (levelSourceColumns && levelSourceColumns.length >= 2) {\r\n                // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\r\n\r\n                let columnsForHierarchyRoleOrderedByLevelSourceIndex = utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(\r\n                    levelSourceColumns,\r\n                    projection,\r\n                    hierarchyRole);\r\n\r\n                if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\r\n                    // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\r\n                    let columnsForHierarchyRoleOrderedByProjection = _.sortBy(\r\n                        columnsForHierarchyRoleOrderedByLevelSourceIndex,\r\n                        columnInfo => columnInfo.projectionOrderIndex);\r\n\r\n                    newToOldLevelSourceIndicesMapping = createOrderMapping(\r\n                        _.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, columnInfo => columnInfo.sourceIndex),\r\n                        _.map(columnsForHierarchyRoleOrderedByProjection, columnInfo => columnInfo.sourceIndex));\r\n                }\r\n            }\r\n\r\n            return newToOldLevelSourceIndicesMapping;\r\n        }\r\n\r\n        /**\r\n         * Applies re-ordering on the specified transformingHierarchyLevel's sources.\r\n         * Returns the same object as the specified transformingHierarchyLevel.\r\n         */\r\n        function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel: DataViewHierarchyLevel, newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewHierarchyLevel {\r\n            debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let originalLevelSources = transformingHierarchyLevel.sources;\r\n\r\n            transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\r\n\r\n            let newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\r\n            for (let i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\r\n                let newLevelSourceIndex = newLevelSourceIndices[i];\r\n                let oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\r\n\r\n                debug.assert(oldLevelSourceIndex < originalLevelSources.length,\r\n                    'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\r\n\r\n                transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\r\n            }\r\n\r\n            return transformingHierarchyLevel;\r\n        }\r\n\r\n        /**\r\n         * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\r\n         * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\r\n         *\r\n         * Returns the same object as the specified transformingHierarchyRootNode.\r\n         */\r\n        function reorderMatrixHierarchyLevelValues(\r\n            transformingHierarchyRootNode: DataViewMatrixNode,\r\n            transformingHierarchyLevelIndex: number,\r\n            newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewMatrixNode {\r\n            debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let oldToNewLevelSourceIndicesMapping: NumberToNumberMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\r\n\r\n            forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, (transformingMatrixNode: DataViewMatrixNode) => {\r\n                let originalLevelValues = transformingMatrixNode.levelValues;\r\n\r\n                // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\r\n                // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\r\n                // The following code isn't correct in the special case where a column is projected twice in this composite group,\r\n                // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\r\n                // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\r\n\r\n                if (!_.isEmpty(originalLevelValues)) {\r\n                    // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\r\n                    // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\r\n                    // because we don't want to accidentally modify the array AND its value references in Query DataView\r\n                    let newlyOrderedLevelValues = _.sortBy(originalLevelValues, levelValue => oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]);\r\n\r\n                    for (let i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\r\n                        let transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\r\n                        transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\r\n                        newlyOrderedLevelValues[i] = transformingLevelValue;\r\n                    }\r\n\r\n                    transformingMatrixNode.levelValues = newlyOrderedLevelValues;\r\n\r\n                    // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\r\n                    // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\r\n                    let newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\r\n                    if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\r\n                        transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\r\n                    }\r\n                    if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\r\n                        transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return transformingHierarchyRootNode;\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of new position to original position.\r\n         *\r\n         * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\r\n         * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\r\n         * - the value in the key-value pair is the index of the particular column in the original order\r\n         */\r\n        function createMatrixValuesPositionMapping(\r\n            matrixValues: DataViewRoleForMapping,\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            valueSources: DataViewMetadataColumn[],\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n\r\n            let role = matrixValues.for.in;\r\n            let newOrder = projectionOrdering[role];\r\n\r\n            let originalOrder = _.chain(columnRewrites)\r\n                .filter(rewrite => _.contains(valueSources, rewrite.to))\r\n                .map(rewrite => rewrite.from.index)\r\n                .value();\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\r\n         * originalOrder array.\r\n         * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\r\n         * under the context of the caller code), e.g. the Select Index in projection ordering array.\r\n         * Also, the specified originalOrder must contain every value that exists in newOrder.\r\n         *\r\n         * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\r\n         * key-value pair, each of which represents the new and old indices of a particular column:\r\n         * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\r\n         * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\r\n         *\r\n         * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\r\n         *\r\n         * If the specified originalOrder and newOrder are same, then this function returns undefined.\r\n         *\r\n         * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\r\n         * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\r\n         */\r\n        function createOrderMapping(originalOrder: number[], newOrder: number[]): NumberToNumberMapping {\r\n            // Optimization: avoid rewriting if the current order is correct\r\n            if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, (x: number, y: number) => x === y))\r\n                return;\r\n\r\n            let mapping: NumberToNumberMapping = {};\r\n            for (let i = 0, len = newOrder.length; i < len; ++i) {\r\n                let newPosition = newOrder[i];\r\n                mapping[i] = originalOrder.indexOf(newPosition);\r\n            }\r\n\r\n            return mapping;\r\n        }\r\n\r\n        function createReversedMapping(mapping: NumberToNumberMapping): NumberToNumberMapping {\r\n            debug.assertValue(mapping, 'mapping');\r\n\r\n            let reversed: NumberToNumberMapping = {};\r\n\r\n            for (let key in mapping) {\r\n                // Note: key is a string after we get it out from mapping, thus we need to parse it\r\n                // back into a number before putting it as the value in the reversed mapping\r\n                let value = mapping[key];\r\n                let keyAsNumber = parseInt(key, 10);\r\n                reversed[value] = keyAsNumber;\r\n            }\r\n\r\n            debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length,\r\n                'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\r\n\r\n            return reversed;\r\n        }\r\n\r\n        export function forEachNodeAtLevel(node: DataViewMatrixNode, targetLevel: number, callback: (node: DataViewMatrixNode) => void): void {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(targetLevel >= 0, 'argetLevel >= 0');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            if (node.level === targetLevel) {\r\n                callback(node);\r\n                return;\r\n            }\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachNodeAtLevel(children[i], targetLevel, callback);\r\n            }\r\n        }\r\n\r\n        function findOverride(source: DataViewMetadataColumn, columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn {\r\n            for (let i = 0, len = columnRewrites.length; i < len; i++) {\r\n                let columnRewrite = columnRewrites[i];\r\n                if (columnRewrite.from === source)\r\n                    return columnRewrite.to;\r\n            }\r\n        }\r\n\r\n        function ensureRewritten<T>(rewritten: T, prototype: T, callback?: (rewritten: T) => void): T {\r\n            if (!rewritten)\r\n                rewritten = inherit(prototype);\r\n\r\n            if (callback)\r\n                callback(rewritten);\r\n\r\n            return rewritten;\r\n        }\r\n\r\n        export function transformObjects(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!objectDescriptors)\r\n                return;\r\n\r\n            let objectsForAllSelectors = DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\r\n            DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\r\n\r\n            let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n            let dataObjects = objectsForAllSelectors.data;\r\n            if (metadataOnce)\r\n                evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\r\n\r\n            let metadataObjects = objectsForAllSelectors.metadata;\r\n            if (metadataObjects) {\r\n                for (let i = 0, len = metadataObjects.length; i < len; i++) {\r\n                    let metadataObject = metadataObjects[i];\r\n                    let objectDefns = metadataObject.objects;\r\n                    let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                    evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\r\n                }\r\n            }\r\n\r\n            for (let i = 0, len = dataObjects.length; i < len; i++) {\r\n                let dataObject = dataObjects[i];\r\n                let objectDefns = dataObject.objects;\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\r\n            }\r\n\r\n            let userDefined = objectsForAllSelectors.userDefined;\r\n            if (userDefined) {\r\n                // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\r\n                evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\r\n            }\r\n        }\r\n\r\n        function evaluateUserDefinedObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewObjectDefinitionsForSelector[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let dataViewObjects: DataViewObjects = dataView.metadata.objects;\r\n            if (!dataViewObjects) {\r\n                dataViewObjects = dataView.metadata.objects = {};\r\n            }\r\n\r\n            for (let objectDefn of objectDefns) {\r\n                let id = objectDefn.selector.id;\r\n\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\r\n                let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n                let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName];\r\n\r\n                    let map = <DataViewObjectMap>dataViewObjects[objectName];\r\n                    if (!map)\r\n                        map = dataViewObjects[objectName] = [];\r\n                    debug.assert(DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\r\n\r\n                    // NOTE: We do not check for duplicate ids.\r\n                    map.push({ id: id, object: object });\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Evaluates and sets properties on the DataView metadata. */\r\n        function evaluateMetadataObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            dataObjects: DataViewObjectDefinitionsForSelectorWithRule[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(dataObjects, 'dataObjects');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n            let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n            if (objects) {\r\n                dataView.metadata.objects = objects;\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName],\r\n                        objectDesc = objectDescriptors[objectName];\r\n\r\n                    for (let propertyName in object) {\r\n                        let propertyDesc = objectDesc.properties[propertyName],\r\n                            ruleDesc = propertyDesc.rule;\r\n                        if (!ruleDesc)\r\n                            continue;\r\n\r\n                        let definition = createRuleEvaluationInstance(\r\n                            dataView,\r\n                            colorAllocatorFactory,\r\n                            ruleDesc,\r\n                            objectName,\r\n                            object[propertyName],\r\n                            propertyDesc.type);\r\n                        if (!definition)\r\n                            continue;\r\n\r\n                        dataObjects.push(definition);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstance(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            objectName: string,\r\n            propertyValue: DataViewPropertyValue,\r\n            ruleType: StructuralTypeDescriptor): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n            debug.assertValue(ruleType, 'ruleType');\r\n\r\n            let ruleOutput = ruleDesc.output;\r\n            if (!ruleOutput)\r\n                return;\r\n\r\n            let selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\r\n            if (!selectorToCreate)\r\n                return;\r\n\r\n            if (ruleType.fillRule) {\r\n                return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, <FillRule>propertyValue);\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstanceFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            selectorToCreate: Selector,\r\n            objectName: string,\r\n            propertyValue: FillRule): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(selectorToCreate, 'selectorToCreate');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, ColumnIdentifierKind.Role, propertyValue);\r\n\r\n            if (!colorAllocator)\r\n                return;\r\n\r\n            let rule = new ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\r\n            let fillRuleProperties: DataViewObjectPropertyDefinitions = {};\r\n            fillRuleProperties[ruleDesc.output.property] = {\r\n                solid: { color: rule }\r\n            };\r\n\r\n            return {\r\n                selector: selectorToCreate,\r\n                rules: [rule],\r\n                objects: [{\r\n                    name: objectName,\r\n                    properties: fillRuleProperties,\r\n                }]\r\n            };\r\n        }\r\n\r\n        function tryCreateColorAllocatorForFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValue: FillRule): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            if (propertyValue.linearGradient2)\r\n                return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\r\n\r\n            if (propertyValue.linearGradient3)\r\n                return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient2(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient2: LinearGradient2): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient2, 'linearGradient2');\r\n\r\n            linearGradient2 = propertyValueFillRule.linearGradient2;\r\n            if (linearGradient2.min.value === undefined ||\r\n                linearGradient2.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                if (linearGradient2.min.value === undefined)\r\n                    linearGradient2.min.value = inputRange.min;\r\n                if (linearGradient2.max.value === undefined)\r\n                    linearGradient2.max.value = inputRange.max;\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient3(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient3: LinearGradient3): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient3, 'linearGradient3');\r\n\r\n            let splitScales: boolean;\r\n            linearGradient3 = propertyValueFillRule.linearGradient3;\r\n            if (linearGradient3.min.value === undefined ||\r\n                linearGradient3.mid.value === undefined ||\r\n                linearGradient3.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                splitScales =\r\n                linearGradient3.min.value === undefined &&\r\n                linearGradient3.max.value === undefined &&\r\n                linearGradient3.mid.value !== undefined;\r\n\r\n                if (linearGradient3.min.value === undefined) {\r\n                    linearGradient3.min.value = inputRange.min;\r\n                }\r\n                if (linearGradient3.max.value === undefined) {\r\n                    linearGradient3.max.value = inputRange.max;\r\n                }\r\n                if (linearGradient3.mid.value === undefined) {\r\n                    let midValue: number = (linearGradient3.max.value + linearGradient3.min.value) / 2;\r\n                    linearGradient3.mid.value = midValue;\r\n                }\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\r\n        }\r\n\r\n        function populateColorAllocatorCache(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): IColorAllocatorCache {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let cache = createColorAllocatorCache();\r\n            let staticEvalContext = createStaticEvalContext();\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefnProperties = objectDefns[i].properties;\r\n\r\n                for (let propertyName in objectDefnProperties) {\r\n                    let fillProperty = <FillDefinition>objectDefnProperties[propertyName];\r\n                    if (fillProperty &&\r\n                        fillProperty.solid &&\r\n                        fillProperty.solid.color &&\r\n                        fillProperty.solid.color.kind === SQExprKind.FillRule) {\r\n\r\n                        let fillRuleExpr = <SQFillRuleExpr>fillProperty.solid.color;\r\n\r\n                        let inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\r\n                        if (!inputExprQueryName)\r\n                            continue;\r\n\r\n                        let fillRule = DataViewObjectEvaluator.evaluateProperty(\r\n                            staticEvalContext,\r\n                            fillRulePropertyDescriptor,\r\n                            fillRuleExpr.rule);\r\n\r\n                        let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, ColumnIdentifierKind.QueryName, fillRule);\r\n                        if (colorAllocator)\r\n                            cache.register(fillRuleExpr, colorAllocator);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return cache;\r\n        }\r\n\r\n        function evaluateDataRepetition(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\r\n\r\n            let containsWildcard = Selector.containsWildcard(selector);\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Categorical)) {\r\n                // 1) Match against categories\r\n                evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // 2) Match against valueGrouping\r\n                evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewMatrix = dataView.matrix;\r\n            if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Matrix)) {\r\n                let rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenMatrix) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.matrix = rewrittenMatrix;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewTable = dataView.table;\r\n            if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Table)) {\r\n                let rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\r\n                let rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenTable) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.table = rewrittenTable;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n        }\r\n\r\n        function rewriteTableRoleSelector(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            if (Selector.hasRoleWildcard(selector)) {\r\n                selector = findSelectorForRoleWildcard(dataViewTable, selector);\r\n            }\r\n\r\n            return selector;\r\n        }\r\n\r\n        function findSelectorForRoleWildcard(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            let resultingSelector: Selector = {\r\n                data: [],\r\n                id: selector.id,\r\n                metadata: selector.metadata\r\n            };\r\n\r\n            for (let dataSelector of selector.data) {\r\n                if (Selector.isRoleWildcard(dataSelector)) {\r\n                    let selectorRoles = dataSelector.roles;\r\n                    let allColumnsBelongToSelectorRole: boolean = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\r\n                    let exprs = dataViewTable.identityFields;\r\n                    if (allColumnsBelongToSelectorRole && exprs) {\r\n                        resultingSelector.data.push(DataViewScopeWildcard.fromExprs(<SQExpr[]>exprs));\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\r\n                    resultingSelector.data.push(dataSelector);\r\n                }\r\n            }\r\n\r\n            return resultingSelector;\r\n        }\r\n\r\n        function isUniqueDataSelector(dataSelectors: DataRepetitionSelector[], newSelector: DataRepetitionSelector): boolean {\r\n            if (_.isEmpty(dataSelectors))\r\n                return true;\r\n\r\n            return !_.any(dataSelectors, (dataSelector: DataRepetitionSelector) => dataSelector.key === newSelector.key);\r\n        }\r\n\r\n        function allColumnsBelongToRole(columns: DataViewMetadataColumn[], selectorRoles: string[]): boolean {\r\n            for (let column of columns) {\r\n                var roles = column.roles;\r\n                if (!roles || !_.any(selectorRoles, (selectorRole) => roles[selectorRole]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalCategory(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\r\n                return;\r\n\r\n            let targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\r\n            if (!targetColumn)\r\n                return;\r\n\r\n            let identities = targetColumn.identities,\r\n                foundMatch: boolean,\r\n                evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            if (!identities)\r\n                return;\r\n\r\n            debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\r\n\r\n            for (let i = 0, len = identities.length; i < len; i++) {\r\n                let identity = identities[i];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(i);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n                        if (!targetColumn.column.objects) {\r\n                            targetColumn.column.objects = [];\r\n                            targetColumn.column.objects.length = len;\r\n                        }\r\n                        targetColumn.column.objects[i] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n\r\n                    foundMatch = true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalValueGrouping(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let dataViewCategoricalValues = dataViewCategorical.values;\r\n            if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\r\n                return;\r\n\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[dataViewCategoricalValues.identityFields]))\r\n                return;\r\n\r\n            let valuesGrouped = dataViewCategoricalValues.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\r\n            // This should be enhanced in the future.\r\n            let evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            let foundMatch: boolean;\r\n            for (let i = 0, len = valuesGrouped.length; i < len; i++) {\r\n                let valueGroup = valuesGrouped[i];\r\n                let selectorMetadata = selector.metadata;\r\n                let valuesInGroup = valueGroup.values;\r\n                if (containsWildcard || Selector.matchesData(selector, [valueGroup.identity])) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n\r\n                        if (selectorMetadata) {\r\n                            for (let j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\r\n                                let valueColumn = valuesInGroup[j],\r\n                                    valueSource = valueColumn.source;\r\n                                if (valueSource.queryName === selectorMetadata) {\r\n                                    let valueSourceOverwrite = Prototype.inherit(valueSource);\r\n                                    valueSourceOverwrite.objects = objects;\r\n                                    valueColumn.source = valueSourceOverwrite;\r\n\r\n                                    foundMatch = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            valueGroup.objects = objects;\r\n                            setGrouped(dataViewCategoricalValues, valuesGrouped);\r\n\r\n                            foundMatch = true;\r\n                        }\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrix(\r\n            dataViewMatrix: DataViewMatrix,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewMatrix {\r\n\r\n            let evalContext = createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\r\n            let rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            let rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n\r\n            if (rewrittenRows || rewrittenCols) {\r\n                let rewrittenMatrix = inheritSingle(dataViewMatrix);\r\n\r\n                if (rewrittenRows)\r\n                    rewrittenMatrix.rows = rewrittenRows;\r\n                if (rewrittenCols)\r\n                    rewrittenMatrix.columns = rewrittenCols;\r\n\r\n                return rewrittenMatrix;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixHierarchy(\r\n            evalContext: IEvalContext,\r\n            dataViewMatrixHierarchy: DataViewHierarchy,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewHierarchy {\r\n            debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (!dataViewMatrixHierarchy)\r\n                return;\r\n\r\n            let root = dataViewMatrixHierarchy.root;\r\n            if (!root)\r\n                return;\r\n\r\n            let rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            if (rewrittenRoot) {\r\n                let rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\r\n                rewrittenHierarchy.root = rewrittenRoot;\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixNode(\r\n            evalContext: IEvalContext,\r\n            dataViewNode: DataViewMatrixNode,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewMatrixNode {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(dataViewNode, 'dataViewNode');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let childNodes = dataViewNode.children;\r\n            if (!childNodes)\r\n                return;\r\n\r\n            let rewrittenNode: DataViewMatrixNode;\r\n            let shouldSearchChildren: boolean;\r\n            let childIdentityFields = dataViewNode.childIdentityFields;\r\n            if (childIdentityFields) {\r\n                // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\r\n                shouldSearchChildren = Selector.matchesKeys(selector, <SQExpr[][]>[childIdentityFields]);\r\n            }\r\n\r\n            for (let i = 0, len = childNodes.length; i < len; i++) {\r\n                let childNode = childNodes[i],\r\n                    identity = childNode.identity,\r\n                    rewrittenChildNode: DataViewMatrixNode = null;\r\n\r\n                if (shouldSearchChildren) {\r\n                    if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                        // TODO: Need to initialize context for rule-based properties.  Rule-based properties\r\n                        // (such as fillRule/gradients) are not currently implemented.\r\n\r\n                        let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                        if (objects) {\r\n                            rewrittenChildNode = inheritSingle(childNode);\r\n                            rewrittenChildNode.objects = objects;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rewrittenChildNode = evaluateDataRepetitionMatrixNode(\r\n                        evalContext,\r\n                        childNode,\r\n                        objectDescriptors,\r\n                        selector,\r\n                        rules,\r\n                        containsWildcard,\r\n                        objectDefns);\r\n                }\r\n\r\n                if (rewrittenChildNode) {\r\n                    if (!rewrittenNode)\r\n                        rewrittenNode = inheritNodeAndChildren(dataViewNode);\r\n                    rewrittenNode.children[i] = rewrittenChildNode;\r\n\r\n                    if (!containsWildcard) {\r\n                        // NOTE: once we find a match for a non-wildcard selector, stop looking.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return rewrittenNode;\r\n        }\r\n\r\n        function inheritNodeAndChildren(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            if (Object.getPrototypeOf(node) !== Object.prototype) {\r\n                return node;\r\n            }\r\n\r\n            let inherited = inheritSingle(node);\r\n            inherited.children = inherit(node.children);\r\n            return inherited;\r\n        }\r\n\r\n        function evaluateDataRepetitionTable(\r\n            dataViewTable: DataViewTable,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewTable {\r\n            debug.assertValue(dataViewTable, 'dataViewTable');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let evalContext = createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\r\n            let rewrittenRows = evaluateDataRepetitionTableRows(\r\n                evalContext,\r\n                dataViewTable.columns,\r\n                dataViewTable.rows,\r\n                dataViewTable.identity,\r\n                dataViewTable.identityFields,\r\n                objectDescriptors,\r\n                selector,\r\n                rules,\r\n                containsWildcard,\r\n                objectDefns);\r\n\r\n            if (rewrittenRows) {\r\n                let rewrittenTable = inheritSingle(dataViewTable);\r\n                rewrittenTable.rows = rewrittenRows;\r\n\r\n                return rewrittenTable;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionTableRows(\r\n            evalContext: ITableEvalContext,\r\n            columns: DataViewMetadataColumn[],\r\n            rows: DataViewTableRow[],\r\n            identities: DataViewScopeIdentity[],\r\n            identityFields: ISQExpr[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewTableRow[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(rows, 'rows');\r\n            debug.assertAnyValue(identities, 'identities');\r\n            debug.assertAnyValue(identityFields, 'identityFields');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (_.isEmpty(identities) || _.isEmpty(identityFields))\r\n                return;\r\n\r\n            if (!selector.metadata ||\r\n                !Selector.matchesKeys(selector, <SQExpr[][]>[identityFields]))\r\n                return;\r\n\r\n            let colIdx = _.findIndex(columns, col => col.queryName === selector.metadata);\r\n            if (colIdx < 0)\r\n                return;\r\n\r\n            debug.assert(rows.length === identities.length, 'row length mismatch');\r\n            let colLen = columns.length;\r\n            let inheritedRows: DataViewTableRow[];\r\n\r\n            for (let rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\r\n                let identity = identities[rowIdx];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(rowIdx);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        if (!inheritedRows)\r\n                            inheritedRows = inheritSingle(rows);\r\n\r\n                        let inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\r\n                        let objectsForColumns = inheritedRow.objects;\r\n                        if (!objectsForColumns)\r\n                            inheritedRow.objects = objectsForColumns = new Array(colLen);\r\n\r\n                        objectsForColumns[colIdx] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return inheritedRows;\r\n        }\r\n\r\n        function evaluateMetadataRepetition(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n            // revisit this, likely when we do lazy evaluation of DataView.\r\n            let columns = dataView.metadata.columns,\r\n                metadataId = selector.metadata,\r\n                evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                let column = columns[i];\r\n                if (column.queryName === metadataId) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects)\r\n                        column.objects = objects;\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Attempts to find a column that can possibly match the selector. */\r\n        function findSelectedCategoricalColumn(dataViewCategorical: DataViewCategorical, selector: Selector) {\r\n            debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\r\n\r\n            let categoricalColumn = dataViewCategorical.categories[0];\r\n            if (!categoricalColumn.identityFields)\r\n                return;\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[categoricalColumn.identityFields]))\r\n                return;\r\n\r\n            let identities = categoricalColumn.identity,\r\n                targetColumn: DataViewCategoricalColumn = categoricalColumn;\r\n\r\n            let selectedMetadataId = selector.metadata;\r\n            if (selectedMetadataId) {\r\n                let valueColumns = dataViewCategorical.values;\r\n                if (valueColumns) {\r\n                    for (let i = 0, len = valueColumns.length; i < len; i++) {\r\n                        let valueColumn = valueColumns[i];\r\n                        if (valueColumn.source.queryName === selectedMetadataId) {\r\n                            targetColumn = valueColumn;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                column: targetColumn,\r\n                identities: identities,\r\n            };\r\n        }\r\n\r\n        function findSelectorForRuleInput(dataView: DataView, selectorRoles: string[]): Selector {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectorRoles, 'selectorRoles');\r\n\r\n            if (selectorRoles.length !== 1)\r\n                return;\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return;\r\n\r\n            let categories = dataViewCategorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let categoryColumn = categories[0],\r\n                categoryRoles = categoryColumn.source.roles,\r\n                categoryIdentityFields = categoryColumn.identityFields;\r\n            if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\r\n                return;\r\n\r\n            return { data: [DataViewScopeWildcard.fromExprs(<SQExpr[]>categoryIdentityFields)] };\r\n        }\r\n\r\n        function findFirstQueryNameForExpr(selectTransforms: DataViewSelectTransform[], expr: SQExpr): string {\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (SQExpr.isSelectRef(expr))\r\n                return expr.expressionName;\r\n\r\n            if (!selectTransforms)\r\n                return;\r\n\r\n            for (let i = 0, len = selectTransforms.length; i < len; i++) {\r\n                let select = selectTransforms[i],\r\n                    columnExpr = select.expr;\r\n\r\n                if (!columnExpr || !SQExpr.equals(expr, select.expr))\r\n                    continue;\r\n\r\n                return select.queryName;\r\n            }\r\n        }\r\n\r\n        /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\r\n        function findRuleInputColumnNumberRange(dataView: DataView, identifier: string, identifierKind: ColumnIdentifierKind): NumberRange {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n\r\n            let columns = dataView.metadata.columns;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                let column = columns[i];\r\n\r\n                if (identifierKind === ColumnIdentifierKind.Role) {\r\n                    let valueColRoles = column.roles;\r\n\r\n                    if (!valueColRoles || !valueColRoles[identifier])\r\n                        continue;\r\n                }\r\n                else {\r\n                    debug.assert(identifierKind === ColumnIdentifierKind.QueryName, 'identifierKind === ColumnIdentifierKind.QueryName');\r\n\r\n                    if (column.queryName !== identifier)\r\n                        continue;\r\n                }\r\n\r\n                let aggregates = column.aggregates;\r\n                if (!aggregates)\r\n                    continue;\r\n\r\n                let min = <number>aggregates.min;\r\n                if (min === undefined)\r\n                    min = <number>aggregates.minLocal;\r\n                if (min === undefined)\r\n                    continue;\r\n\r\n                let max = <number>aggregates.max;\r\n                if (max === undefined)\r\n                    max = <number>aggregates.maxLocal;\r\n                if (max === undefined)\r\n                    continue;\r\n\r\n                return { min: min, max: max };\r\n            }\r\n        }\r\n\r\n        // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\r\n        export function createValueColumns(\r\n            values: DataViewValueColumn[] = [],\r\n            valueIdentityFields?: SQExpr[],\r\n            source?: DataViewMetadataColumn): DataViewValueColumns {\r\n            let result = <DataViewValueColumns>values;\r\n            setGrouped(<DataViewValueColumns>values);\r\n\r\n            if (valueIdentityFields)\r\n                result.identityFields = valueIdentityFields;\r\n\r\n            if (source)\r\n                result.source = source;\r\n\r\n            return result;\r\n        }\r\n\r\n        export function setGrouped(values: DataViewValueColumns, groupedResult?: DataViewValueColumnGroup[]): void {\r\n            values.grouped = groupedResult\r\n                ? () => groupedResult\r\n                : () => groupValues(values);\r\n        }\r\n\r\n        /** Group together the values with a common identity. */\r\n        function groupValues(values: DataViewValueColumn[]): DataViewValueColumnGroup[] {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let groups: DataViewValueColumnGroup[] = [],\r\n                currentGroup: DataViewValueColumnGroup;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n\r\n                if (!currentGroup || currentGroup.identity !== value.identity) {\r\n                    currentGroup = {\r\n                        values: []\r\n                    };\r\n\r\n                    if (value.identity) {\r\n                        currentGroup.identity = value.identity;\r\n\r\n                        let source = value.source;\r\n\r\n                        // allow null, which will be formatted as (Blank).\r\n                        if (source.groupName !== undefined)\r\n                            currentGroup.name = source.groupName;\r\n                        else if (source.displayName)\r\n                            currentGroup.name = source.displayName;\r\n                    }\r\n\r\n                    groups.push(currentGroup);\r\n                }\r\n\r\n                currentGroup.values.push(value);\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function pivotIfNecessary(dataView: DataView, dataViewMappings: DataViewMapping[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let transformedDataView: DataView;\r\n            switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\r\n                case CategoricalDataViewTransformation.Pivot:\r\n                    transformedDataView = DataViewPivotCategorical.apply(dataView);\r\n                    break;\r\n\r\n                case CategoricalDataViewTransformation.SelfCrossJoin:\r\n                    transformedDataView = DataViewSelfCrossJoin.apply(dataView);\r\n                    break;\r\n            }\r\n\r\n            return transformedDataView || dataView;\r\n        }\r\n\r\n        function determineCategoricalTransformation(categorical: DataViewCategorical, dataViewMappings: DataViewMapping[]): CategoricalDataViewTransformation {\r\n            if (!categorical || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values))\r\n                return;\r\n\r\n            if (values.grouped().some(vg => !!vg.identity))\r\n                return;\r\n\r\n            // If we made it here, the DataView has a single category and no valueGrouping.\r\n            let categoryRoles = categories[0].source.roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingCategorical = dataViewMappings[i].categorical;\r\n                if (!roleMappingCategorical)\r\n                    continue;\r\n\r\n                if (!hasRolesGrouped(categoryRoles, <DataViewGroupedRoleMapping>roleMappingCategorical.values))\r\n                    continue;\r\n\r\n                // If we made it here, the DataView's single category has the value grouping role.\r\n                let categoriesMapping = roleMappingCategorical.categories;\r\n                let hasCategoryRole =\r\n                    hasRolesBind(categoryRoles, <DataViewRoleBindMappingWithReduction>categoriesMapping) ||\r\n                    hasRolesFor(categoryRoles, <DataViewRoleForMappingWithReduction>categoriesMapping);\r\n\r\n                if (hasCategoryRole)\r\n                    return CategoricalDataViewTransformation.SelfCrossJoin;\r\n\r\n                return CategoricalDataViewTransformation.Pivot;\r\n            }\r\n        }\r\n\r\n        function shouldPivotMatrix(matrix: DataViewMatrix, dataViewMappings: DataViewMapping[]): boolean {\r\n            if (!matrix || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let rowLevels = matrix.rows.levels;\r\n            if (rowLevels.length < 1)\r\n                return;\r\n\r\n            let rows = matrix.rows.root.children;\r\n            if (!rows || rows.length === 0)\r\n                return;\r\n\r\n            let rowRoles = rowLevels[0].sources[0].roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingMatrix = dataViewMappings[i].matrix;\r\n                if (!roleMappingMatrix)\r\n                    continue;\r\n\r\n                if (!hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.rows) &&\r\n                    hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.columns)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        function hasRolesBind(roles: { [name: string]: boolean }, roleMapping: DataViewRoleBindMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.bind)\r\n                return roles[roleMapping.bind.to];\r\n        }\r\n\r\n        function hasRolesFor(roles: { [name: string]: boolean }, roleMapping: DataViewRoleForMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.for)\r\n                return roles[roleMapping.for.in];\r\n        }\r\n\r\n        function hasRolesGrouped(roles: { [name: string]: boolean }, roleMapping: DataViewGroupedRoleMapping): boolean {\r\n            if (roles && roleMapping && roleMapping.group)\r\n                return roles[roleMapping.group.by];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\r\n\r\n    export function createDisplayNameGetter(displayNameKey: string): (IStringResourceProvider) => string {\r\n        return (resourceProvider: IStringResourceProvider) => resourceProvider.get(displayNameKey);\r\n    }\r\n\r\n    export function getDisplayName(displayNameGetter: data.DisplayNameGetter, resourceProvider: jsCommon.IStringResourceProvider): string {\r\n        if (typeof displayNameGetter === 'function')\r\n            return displayNameGetter(resourceProvider);\r\n\r\n        if (typeof displayNameGetter === 'string')\r\n            return displayNameGetter;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    /** Enumeration of DateTimeUnits */\r\n    export enum DateTimeUnit {\r\n        Year,\r\n        Month,\r\n        Week,\r\n        Day,\r\n        Hour,\r\n        Minute,\r\n        Second,\r\n        Millisecond,\r\n    }\r\n\r\n    export interface IFormattingService {\r\n        /** \r\n         * Formats the value using provided format expression and culture\r\n         * @param value - value to be formatted and converted to string.\r\n         * @param format - format to be applied. If undefined or empty then generic format is used.        \r\n         */\r\n        formatValue(value: any, format?: string): string;\r\n\r\n        /** \r\n         * Replaces the indexed format tokens (for example {0:c2}) in the format string with the localized formatted arguments.\r\n         * @param formatWithIndexedTokens - format string with a set of indexed format tokens.\r\n         * @param args - array of values which should replace the tokens in the format string.\r\n         * @param culture - localization culture. If undefined then the current culture is used.\r\n         */\r\n        format(formatWithIndexedTokens: string, args: any[], culture?: string): string;\r\n\r\n        /** Gets a value indicating whether the specified format a standard numeric format specifier. */\r\n        isStandardNumberFormat(format: string): boolean;\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string): string;\r\n\r\n        /** Gets the format string to use for dates in particular units. */\r\n        dateFormatString(unit: DateTimeUnit): string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Represents common expression patterns for 'field' expressions such as columns, column aggregates, measures, etc. */\r\n    export interface FieldExprPattern {\r\n        column?: FieldExprColumnPattern;\r\n        columnAggr?: FieldExprColumnAggrPattern;\r\n        columnHierarchyLevelVariation?: FieldExprColumnHierarchyLevelVariationPattern;\r\n        entity?: FieldExprEntityPattern;\r\n        entityAggr?: FieldExprEntityAggrPattern;\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        hierarchyLevel?: FieldExprHierarchyLevelPattern;\r\n        hierarchyLevelAggr?: FieldExprHierarchyLevelAggrPattern;\r\n        measure?: FieldExprMeasurePattern;\r\n        percentile?: FieldExprPercentilePattern;\r\n        percentOfGrandTotal?: FieldExprPercentOfGrandTotalPattern;\r\n        selectRef?: FieldExprSelectRefPattern;\r\n    }\r\n\r\n    /** By design there is no default, no-op visitor. Components concerned with patterns need to be aware of all patterns as they are added. */\r\n    export interface IFieldExprPatternVisitor<T> {\r\n        visitColumn(column: FieldExprColumnPattern): T;\r\n        visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): T;\r\n        visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): T;\r\n        visitEntity(entity: FieldExprEntityPattern): T;\r\n        visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): T;\r\n        visitHierarchy(hierarchy: FieldExprHierarchyPattern): T;\r\n        visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): T;\r\n        visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): T;\r\n        visitMeasure(measure: FieldExprMeasurePattern): T;\r\n        visitPercentile(percentile: FieldExprPercentilePattern): T;\r\n        visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): T;\r\n        visitSelectRef(selectRef: FieldExprSelectRefPattern): T;\r\n    }\r\n\r\n    export interface FieldExprEntityPattern {\r\n        schema: string;\r\n        entity: string;\r\n        entityVar?: string;\r\n    }\r\n\r\n    export interface FieldExprEntityItemPattern extends FieldExprEntityPattern {\r\n    }\r\n\r\n    export interface FieldExprEntityPropertyPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n    }\r\n\r\n    export type FieldExprColumnPattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprMeasurePattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprHierarchyPattern = FieldExprEntityPropertyPattern;\r\n\r\n    export type FieldExprPropertyPattern = FieldExprColumnPattern | FieldExprMeasurePattern | FieldExprHierarchyPattern;\r\n\r\n    export interface FieldExprEntityAggrPattern extends FieldExprEntityPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnAggrPattern extends FieldExprColumnPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n        level: string;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelAggrPattern extends FieldExprHierarchyLevelPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnHierarchyLevelVariationPattern {\r\n        source: FieldExprColumnPattern;\r\n        level: FieldExprHierarchyLevelPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    export interface FieldExprPercentilePattern {\r\n        arg: FieldExprPattern;\r\n        k: number;\r\n        exclusive: boolean;\r\n    }\r\n\r\n    export interface FieldExprPercentOfGrandTotalPattern {\r\n        baseExpr: FieldExprPattern;\r\n    }\r\n\r\n    export interface FieldExprSelectRefPattern {\r\n        expressionName: string;\r\n    }\r\n\r\n    export module SQExprBuilder {\r\n        export function fieldExpr(fieldExpr: FieldExprPattern): SQExpr {\r\n            let sqExpr = FieldExprPattern.visit<SQExpr>(fieldExpr, FieldExprToSQExprVisitor.instance);\r\n            debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\r\n            return sqExpr;\r\n        }\r\n\r\n        export function fromColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromColumn(columnAggr), columnAggr.aggregate);\r\n        }\r\n\r\n        export function fromColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return columnRef(fromEntity(column), column.name);\r\n        }\r\n\r\n        export function fromEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n            return entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\r\n        }\r\n\r\n        export function fromEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromEntity(entityAggr), entityAggr.aggregate);\r\n        }\r\n\r\n        export function fromHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\r\n        }\r\n\r\n        export function fromHierarchyLevel(hierarchyLevelPattern: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n            return hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\r\n        }\r\n\r\n        export function fromHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n            return hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\r\n        }\r\n\r\n        class FieldExprToSQExprVisitor implements IFieldExprPatternVisitor<SQExpr> {\r\n            public static instance: FieldExprToSQExprVisitor = new FieldExprToSQExprVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n                return fromColumn(column);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n                return fromColumnAggr(columnAggr);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariationPattern: FieldExprColumnHierarchyLevelVariationPattern): SQPropertyVariationSourceExpr {\r\n                return propertyVariationSource(\r\n                    this.visitEntity(columnHierarchyLevelVariationPattern.source),\r\n                    columnHierarchyLevelVariationPattern.source.name,\r\n                    columnHierarchyLevelVariationPattern.level.name);\r\n            }\r\n\r\n            public visitEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n                return fromEntity(entityPattern);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n                return fromEntityAggr(entityAggr);\r\n            }\r\n\r\n            public visitHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n                return fromHierarchy(hierarchyPattern);\r\n            }\r\n\r\n            public visitHierarchyLevel(level: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n                return fromHierarchyLevel(level);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n                return fromHierarchyLevelAggr(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): SQMeasureRefExpr {\r\n                return measureRef(this.visitEntity(measure), measure.name);\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): SQPercentileExpr {\r\n                let arg = SQExprBuilder.fieldExpr(percentile.arg);\r\n                return SQExprBuilder.percentile(arg, percentile.k, percentile.exclusive);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): SQArithmeticExpr {\r\n                let baseSQExpr = SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr);\r\n                return arithmetic(\r\n                    baseSQExpr,\r\n                    SQExprBuilder.scopedEval(baseSQExpr, []),\r\n                    ArithmeticOperatorKind.Divide);\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): SQSelectRefExpr {\r\n                return SQExprBuilder.selectRef(selectRef.expressionName);\r\n            }\r\n        }\r\n    }\r\n\r\n    export module SQExprConverter {\r\n        export function asFieldPattern(sqExpr: SQExpr): FieldExprPattern {\r\n            return sqExpr.accept(FieldExprPatternBuilder.instance);\r\n        }\r\n    }\r\n\r\n    interface FieldExprSourceVariationPattern {\r\n        column: FieldExprColumnPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    interface SourceExprPattern {\r\n        entity?: FieldExprEntityPattern;\r\n\r\n        // TODO: Change FieldExprHierarchyPattern to FieldExprHierarchyLevelPattern\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    interface HierarchySourceExprPattern {\r\n        hierarchy: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    class FieldExprPatternBuilder extends DefaultSQExprVisitor<FieldExprPattern> {\r\n        public static instance: FieldExprPatternBuilder = new FieldExprPatternBuilder();\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let columnRef = <FieldExprColumnPattern>sourceRef.entity;\r\n                columnRef.name = expr.ref;\r\n\r\n                return { column: columnRef };\r\n            }\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let measureRef = <FieldExprMeasurePattern>sourceRef.entity;\r\n                measureRef.name = expr.ref;\r\n\r\n                return { measure: measureRef };\r\n            }\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): FieldExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): FieldExprPattern {\r\n            let fieldPattern: FieldExprPattern = expr.arg.accept(this);\r\n            if (fieldPattern && fieldPattern.column) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.column;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.columnAggr) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.columnAggr;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.hierarchyLevel) {\r\n                let argAggr = <FieldExprHierarchyLevelAggrPattern>fieldPattern.hierarchyLevel;\r\n                argAggr.aggregate = expr.func;\r\n                return { hierarchyLevelAggr: argAggr };\r\n            }\r\n\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let argAggr = <FieldExprEntityAggrPattern>sourcePattern.entity;\r\n                argAggr.aggregate = expr.func;\r\n\r\n                return { entityAggr: argAggr };\r\n            }\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): FieldExprPattern {\r\n            return {\r\n                percentile: {\r\n                    arg: expr.arg.accept(this),\r\n                    k: expr.k,\r\n                    exclusive: expr.exclusive,\r\n                }\r\n            };\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): FieldExprPattern {\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let hierarchyRef = <FieldExprHierarchyPattern>(sourcePattern.entity);\r\n                hierarchyRef.name = expr.hierarchy;\r\n                return { hierarchy: hierarchyRef };\r\n            }\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): FieldExprPattern {\r\n            let hierarchySourceExprPattern: HierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\r\n            if (!hierarchySourceExprPattern)\r\n                return;\r\n\r\n            let hierarchyLevel: FieldExprHierarchyLevelPattern;\r\n            if (hierarchySourceExprPattern.hierarchy) {\r\n                hierarchyLevel = {\r\n                    entity: hierarchySourceExprPattern.hierarchy.entity,\r\n                    schema: hierarchySourceExprPattern.hierarchy.schema,\r\n                    name: hierarchySourceExprPattern.hierarchy.name,\r\n                    level: expr.level,\r\n                };\r\n            }\r\n\r\n            if (hierarchySourceExprPattern.variation) {\r\n                return {\r\n                    columnHierarchyLevelVariation: {\r\n                        source: {\r\n                            entity: hierarchySourceExprPattern.variation.column.entity,\r\n                            schema: hierarchySourceExprPattern.variation.column.schema,\r\n                            name: hierarchySourceExprPattern.variation.column.name,\r\n                        },\r\n                        level: hierarchyLevel,\r\n                        variationName: hierarchySourceExprPattern.variation.variationName,\r\n                    }\r\n                };\r\n            }\r\n\r\n            return { hierarchyLevel: hierarchyLevel };\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): FieldExprPattern {\r\n            let percentOfGrandTotalPattern: FieldExprPattern = {\r\n                percentOfGrandTotal: {\r\n                    baseExpr: expr.left.accept(this)\r\n                }\r\n            };\r\n\r\n            if (SQExpr.equals(expr, SQExprBuilder.fieldExpr(percentOfGrandTotalPattern))) {\r\n                return percentOfGrandTotalPattern;\r\n            }\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr): FieldExprPattern {\r\n            return {\r\n                selectRef: {\r\n                    expressionName: expr.expressionName,\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    class SourceExprPatternBuilder extends DefaultSQExprVisitor<SourceExprPattern> {\r\n        public static instance: SourceExprPatternBuilder = new SourceExprPatternBuilder();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SourceExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SourceExprPattern {\r\n            let entityExpr = <SQEntityExpr>expr.arg;\r\n\r\n            if (entityExpr instanceof SQEntityExpr) {\r\n                let propertyVariationSource: FieldExprColumnPattern = {\r\n                    schema: entityExpr.schema,\r\n                    entity: entityExpr.entity,\r\n                    name: expr.property,\r\n                };\r\n\r\n                if (entityExpr.variable)\r\n                    propertyVariationSource.entityVar = entityExpr.variable;\r\n\r\n                return {\r\n                    variation: {\r\n                        column: propertyVariationSource,\r\n                        variationName: expr.name,\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    class HierarchyExprPatternBuiler extends DefaultSQExprVisitor<HierarchySourceExprPattern> {\r\n        public static instance: HierarchyExprPatternBuiler = new HierarchyExprPatternBuiler();\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): HierarchySourceExprPattern {\r\n            let exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            let hierarchyRef: FieldExprHierarchyPattern;\r\n            let variationRef: FieldExprSourceVariationPattern;\r\n\r\n            if (exprPattern.variation) {\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.variation.column.schema,\r\n                    entity: exprPattern.variation.column.entity,\r\n                };\r\n                variationRef = exprPattern.variation;\r\n            }\r\n            else\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.entity.schema,\r\n                    entity: exprPattern.entity.entity,\r\n                };\r\n\r\n            return {\r\n                hierarchy: hierarchyRef,\r\n                variation: variationRef\r\n            };\r\n        }\r\n    }\r\n\r\n    export module FieldExprPattern {\r\n\r\n        export function visit<T>(expr: SQExpr | FieldExprPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let fieldExprPattern = expr instanceof SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\r\n            debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\r\n\r\n            if (fieldExprPattern.column)\r\n                return visitColumn(fieldExprPattern.column, visitor);\r\n            if (fieldExprPattern.columnAggr)\r\n                return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation)\r\n                return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\r\n            if (fieldExprPattern.entity)\r\n                return visitEntity(fieldExprPattern.entity, visitor);\r\n            if (fieldExprPattern.entityAggr)\r\n                return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\r\n            if (fieldExprPattern.hierarchy)\r\n                return visitHierarchy(fieldExprPattern.hierarchy, visitor);\r\n            if (fieldExprPattern.hierarchyLevel)\r\n                return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\r\n            if (fieldExprPattern.hierarchyLevelAggr)\r\n                return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\r\n            if (fieldExprPattern.measure)\r\n                return visitMeasure(fieldExprPattern.measure, visitor);\r\n            if (fieldExprPattern.percentile)\r\n                return visitPercentile(fieldExprPattern.percentile, visitor);\r\n            if (fieldExprPattern.percentOfGrandTotal)\r\n                return visitPercentOfGrandTotal(fieldExprPattern.percentOfGrandTotal, visitor);\r\n            if (fieldExprPattern.selectRef)\r\n                return visitSelectRef(fieldExprPattern.selectRef, visitor);\r\n\r\n            debug.assertFail('failed to visit a fieldExprPattern.');\r\n            return;\r\n        }\r\n\r\n        function visitColumn<T>(column: FieldExprColumnPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(column, 'column');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumn(column);\r\n        }\r\n\r\n        function visitColumnAggr<T>(columnAggr: FieldExprColumnAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(columnAggr, 'columnAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnAggr(columnAggr);\r\n        }\r\n\r\n        function visitColumnHierarchyLevelVariation<T>(\r\n            columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern,\r\n            visitor: IFieldExprPatternVisitor<T>): T {\r\n\r\n            debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\r\n        }\r\n\r\n        function visitEntity<T>(entity: FieldExprEntityPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(entity, 'entity');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntity(entity);\r\n        }\r\n\r\n        function visitEntityAggr<T>(entityAggr: FieldExprEntityAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(entityAggr, 'entityAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntityAggr(entityAggr);\r\n        }\r\n\r\n        function visitHierarchy<T>(hierarchy: FieldExprHierarchyPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchy(hierarchy);\r\n        }\r\n\r\n        function visitHierarchyLevel<T>(hierarchyLevel: FieldExprHierarchyLevelPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevel(hierarchyLevel);\r\n        }\r\n\r\n        function visitHierarchyLevelAggr<T>(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\r\n        }\r\n\r\n        function visitMeasure<T>(measure: FieldExprMeasurePattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(measure, 'measure');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitMeasure(measure);\r\n        }\r\n\r\n        function visitSelectRef<T>(selectRef: FieldExprSelectRefPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(selectRef, 'selectRef');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitSelectRef(selectRef);\r\n        }\r\n\r\n        function visitPercentile<T>(percentile: FieldExprPercentilePattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(percentile, 'percentile');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitPercentile(percentile);\r\n        }\r\n\r\n        function visitPercentOfGrandTotal<T>(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(percentOfGrandTotal, 'percentOfGrandTotal');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitPercentOfGrandTotal(percentOfGrandTotal);\r\n        }\r\n\r\n        export function toColumnRefSQExpr(columnPattern: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return SQExprBuilder.columnRef(\r\n                SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar),\r\n                columnPattern.name);\r\n        }\r\n\r\n        export function getAggregate(fieldExpr: FieldExprPattern): QueryAggregateFunction {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n\r\n            return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\r\n        }\r\n\r\n        export function isAggregation(fieldExpr: FieldExprPattern): boolean {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n\r\n            return visit(fieldExpr, FieldExprPatternIsAggregationVisitor.instance);\r\n        }\r\n\r\n        export function hasFieldExprName(fieldExpr: FieldExprPattern): boolean {\r\n            return (fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.measure) !== undefined;\r\n        }\r\n\r\n        export function getPropertyName(fieldExpr: FieldExprPattern): string {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprPropertyNameVisitor.instance);\r\n        }\r\n\r\n        export function getHierarchyName(fieldExpr: FieldExprPattern): string {\r\n            let hierarchy = fieldExpr.hierarchy;\r\n            if (hierarchy)\r\n                return hierarchy.name;\r\n        }\r\n\r\n        export function getColumnRef(fieldExpr: FieldExprPattern): FieldExprPropertyPattern {\r\n            if (fieldExpr.columnHierarchyLevelVariation)\r\n                return fieldExpr.columnHierarchyLevelVariation.source;\r\n\r\n            return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\r\n        }\r\n\r\n        export function getFieldExprName(fieldExpr: FieldExprPattern): string {\r\n            let name = getPropertyName(fieldExpr);\r\n\r\n            if (name)\r\n                return name;\r\n\r\n            // In case it is an entity\r\n            return toFieldExprEntityPattern(fieldExpr).entity;\r\n        }\r\n        \r\n        export function getSchema(fieldExpr: FieldExprPattern): string {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n            \r\n            let item = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            debug.assertAnyValue(item, 'expected fieldExpr to be an entity item');\r\n            \r\n            return item.schema;\r\n        }\r\n\r\n        export function toFieldExprEntityPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        export function toFieldExprEntityItemPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        class FieldExprPatternAggregateVisitor implements IFieldExprPatternVisitor<QueryAggregateFunction> {\r\n            public static instance: FieldExprPatternAggregateVisitor = new FieldExprPatternAggregateVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): QueryAggregateFunction {\r\n                return columnAggr.aggregate;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): QueryAggregateFunction {\r\n                return entityAggr.aggregate;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): QueryAggregateFunction {\r\n                return hierarchyLevelAggr.aggregate;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): QueryAggregateFunction {\r\n                // NOTE: Percentile behaves like an aggregate (i.e., can be performed over numeric columns like a SUM), but\r\n                // this function can't really convey that because percentile (intentionally) isn't in QueryAggregateFunction enum.\r\n                // This should be revisited when we have UI support for the Percentile aggregate.\r\n                return;\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): QueryAggregateFunction {\r\n                return SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr));\r\n            }\r\n        }\r\n\r\n        class FieldExprPatternIsAggregationVisitor implements IFieldExprPatternVisitor<boolean> {\r\n            public static instance: FieldExprPatternIsAggregationVisitor = new FieldExprPatternIsAggregationVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): boolean {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        class FieldExprToEntityExprPatternBuilder implements IFieldExprPatternVisitor<FieldExprEntityItemPattern> {\r\n            public static instance: FieldExprToEntityExprPatternBuilder = new FieldExprToEntityExprPatternBuilder();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): FieldExprEntityItemPattern {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): FieldExprEntityItemPattern {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): FieldExprEntityItemPattern {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n\r\n            private static toEntityItemExprPattern(exprPattern: FieldExprEntityItemPattern): FieldExprEntityItemPattern {\r\n                debug.assertValue(exprPattern, 'exprPattern');\r\n\r\n                let pattern: FieldExprEntityItemPattern = { schema: exprPattern.schema, entity: exprPattern.entity };\r\n\r\n                if (exprPattern.entityVar) {\r\n                    pattern.entityVar = exprPattern.entityVar;\r\n                }\r\n\r\n                return pattern;\r\n            }\r\n        }\r\n        \r\n        class FieldExprPropertyNameVisitor implements IFieldExprPatternVisitor<string> {\r\n            public static instance: FieldExprPropertyNameVisitor = new FieldExprPropertyNameVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): string {\r\n                return column.name;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): string {\r\n                return columnAggr.name;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): string {\r\n                return measure.name;\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): string {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): string {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): string {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export module DataViewAnalysis {\r\n        import ArrayExtensions = jsCommon.ArrayExtensions;\r\n        import QueryProjectionsByRole = powerbi.data.QueryProjectionsByRole;\r\n        import DataViewObjectDescriptors = powerbi.data.DataViewObjectDescriptors;\r\n        import DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\r\n\r\n        export interface ValidateAndReshapeResult {\r\n            dataView?: DataView;\r\n            isValid: boolean;\r\n        }\r\n\r\n        export interface RoleKindByQueryRef {\r\n            [queryRef: string]: VisualDataRoleKind;\r\n        }\r\n\r\n        export interface DataViewMappingResult {\r\n            supportedMappings: DataViewMapping[];\r\n\r\n            /** A set of mapping errors if there are no supported mappings */\r\n            mappingErrors: DataViewMappingMatchError[];\r\n        }\r\n\r\n        export enum DataViewMappingMatchErrorCode {\r\n            conditionRangeTooLarge,\r\n            conditionRangeTooSmall,\r\n            conditionKindExpectedMeasure,\r\n            conditionKindExpectedGrouping,\r\n            conditionKindExpectedGroupingOrMeasure,\r\n        }\r\n\r\n        export interface DataViewMappingMatchError {\r\n            code: DataViewMappingMatchErrorCode;\r\n            roleName: string;\r\n            mappingIndex?: number;\r\n            conditionIndex?: number;\r\n        }\r\n\r\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\r\n        export function validateAndReshape(dataView: DataView, dataViewMappings: DataViewMapping[]): ValidateAndReshapeResult {\r\n            if (!dataViewMappings || dataViewMappings.length === 0)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            if (dataView) {\r\n                for (let dataViewMapping of dataViewMappings) {\r\n                    // Keep the original when possible.\r\n                    if (supports(dataView, dataViewMapping))\r\n                        return { dataView: dataView, isValid: true };\r\n\r\n                    if (dataViewMapping.categorical && dataView.categorical)\r\n                        return reshapeCategorical(dataView, dataViewMapping);\r\n\r\n                    if (dataViewMapping.tree && dataView.tree)\r\n                        return reshapeTree(dataView, dataViewMapping.tree);\r\n\r\n                    if (dataViewMapping.single && dataView.single)\r\n                        return reshapeSingle(dataView, dataViewMapping.single);\r\n\r\n                    if (dataViewMapping.table && dataView.table)\r\n                        return reshapeTable(dataView, dataViewMapping.table);\r\n                }\r\n            }\r\n            else if (ScriptResultUtil.findScriptResult(dataViewMappings)) {\r\n                // Currently, PBI Service treats R Script Visuals as static images.\r\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\r\n                // to support the PBI Desktop scenario.\r\n                // This code will be removed once PBI Service fully supports R Script Visuals.\r\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\r\n                return { dataView: dataView, isValid: true };\r\n            }\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeCategorical(dataView: DataView, dataViewMapping: DataViewMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\r\n\r\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\r\n            let categoryRoleMapping = dataViewMapping.categorical;\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return { isValid: false };\r\n\r\n            let rowCount;\r\n            if (categoryRoleMapping.rowCount) {\r\n                rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (rowCount && rowCount.max) {\r\n                    let updated: DataViewCategorical;\r\n                    let categories = categorical.categories;\r\n                    let maxRowCount = rowCount.max;\r\n                    let originalLength = undefined;\r\n                    if (categories) {\r\n                        for (let i = 0, len = categories.length; i < len; i++) {\r\n                            let category = categories[i];\r\n                            originalLength = category.values.length;\r\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n\r\n                                // Row count too large: Trim it to fit.\r\n                                let updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\r\n\r\n                                updated = updated || { categories: [] };\r\n                                updated.categories.push({\r\n                                    source: category.source,\r\n                                    values: updatedCategories\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\r\n                        if (!originalLength)\r\n                            originalLength = categorical.values[0].values.length;\r\n\r\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n                            updated = updated || {};\r\n                            updated.values = data.DataViewTransform.createValueColumns();\r\n\r\n                            for (let i = 0, len = categorical.values.length; i < len; i++) {\r\n                                let column = categorical.values[i],\r\n                                    updatedColumn: DataViewValueColumn = {\r\n                                        source: column.source,\r\n                                        values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\r\n                                    };\r\n\r\n                                if (column.min !== undefined)\r\n                                    updatedColumn.min = column.min;\r\n                                if (column.max !== undefined)\r\n                                    updatedColumn.max = column.max;\r\n                                if (column.subtotal !== undefined)\r\n                                    updatedColumn.subtotal = column.subtotal;\r\n\r\n                                updated.values.push(updatedColumn);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (updated) {\r\n                        dataView = {\r\n                            metadata: dataView.metadata,\r\n                            categorical: updated,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (supportsCategorical(dataView, dataViewMapping))\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return null;\r\n        }\r\n\r\n        function reshapeSingle(dataView: DataView, singleRoleMapping: DataViewSingleMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (dataView.single)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            // TODO: Need to implement the reshaping of Tree\r\n            let metadata = dataView.metadata;\r\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTable(dataView: DataView, tableRoleMapping: DataViewTableMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (dataView.table)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        export function countGroups(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (!columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        export function countMeasures(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        /** Indicates whether the dataView conforms to the specified schema. */\r\n        export function supports(dataView: DataView, roleMapping: DataViewMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            if (!roleMapping || !dataView)\r\n                return false;\r\n\r\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\r\n                return false;\r\n\r\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\r\n                return false;\r\n\r\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\r\n                return false;\r\n\r\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsCategorical(dataView: DataView, categoryRoleMapping: DataViewCategoricalMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return false;\r\n\r\n            // TODO: Disabling this implementation isn't right.\r\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\r\n            //    return false;\r\n\r\n            if (categoryRoleMapping.rowCount) {\r\n                let rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\r\n                    rowCount = categoryRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\r\n                        len = dataViewCategorical.values[0].values.length;\r\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\r\n                        len = dataViewCategorical.categories[0].values.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsSingle(dataViewSingle: DataViewSingle, singleRoleMapping: DataViewSingleMapping): boolean {\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (!dataViewSingle)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): boolean {\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            let metadata = dataView.metadata;\r\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\r\n        }\r\n\r\n        function supportsTable(dataViewTable: DataViewTable, tableRoleMapping: DataViewTableMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (!dataViewTable)\r\n                return false;\r\n\r\n            if (tableRoleMapping.rowCount) {\r\n                let rowCount = tableRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\r\n                    rowCount = tableRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewTable.rows && dataViewTable.rows.length)\r\n                        len = dataViewTable.rows.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsScriptResult(dataView: DataViewScriptResultData, scriptResultRoleMapping: DataViewScriptResultMapping): boolean {\r\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\r\n\r\n            if (!dataView)\r\n                return false;\r\n\r\n            if (!dataView.imageBase64)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the range in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        export function validateRange(value: number, roleCondition: RoleCondition, ignoreMin?: boolean): DataViewMappingMatchErrorCode {\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (!roleCondition)\r\n                return;\r\n\r\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\r\n\r\n            if (roleCondition.max !== undefined && roleCondition.max < value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        function validateKind(roleCondition: RoleCondition, roleName: string, projections: QueryProjectionsByRole, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchErrorCode {\r\n            if (!roleCondition || roleCondition.kind === undefined) {\r\n                return;\r\n            }\r\n            let expectedKind = roleCondition.kind;\r\n            let roleCollection = projections[roleName];\r\n            if (roleCollection) {\r\n                let roleProjections = roleCollection.all();\r\n                for (let roleProjection of roleProjections) {\r\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\r\n                        switch (expectedKind) {\r\n                            case VisualDataRoleKind.Measure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\r\n                            case VisualDataRoleKind.Grouping:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\r\n                            case VisualDataRoleKind.GroupingOrMeasure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Determines the appropriate DataViewMappings for the projections. */\r\n        export function chooseDataViewMappings(\r\n            projections: QueryProjectionsByRole,\r\n            mappings: DataViewMapping[],\r\n            roleKindByQueryRef: RoleKindByQueryRef,\r\n            objectDescriptors?: DataViewObjectDescriptors,\r\n            objectDefinitions?: DataViewObjectDefinitions): DataViewMappingResult {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertAnyValue(mappings, 'mappings');\r\n\r\n            let supportedMappings: DataViewMapping[] = [];\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            if (!_.isEmpty(mappings)) {\r\n                for (let mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\r\n                    let mapping = mappings[mappingIndex],\r\n                        mappingConditions = mapping.conditions,\r\n                        requiredProperties = mapping.requiredProperties;\r\n                    let allPropertiesValid: boolean = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\r\n                    let conditionsMet: DataViewMappingCondition[] = [];\r\n\r\n                    if (!_.isEmpty(mappingConditions)) {\r\n                        for (let conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\r\n                            let condition = mappingConditions[conditionIndex];\r\n                            let currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\r\n                            if (!_.isEmpty(currentConditionErrors)) {\r\n                                for (let error of currentConditionErrors) {\r\n                                    error.mappingIndex = mappingIndex;\r\n                                    error.conditionIndex = conditionIndex;\r\n                                    errors.push(error);\r\n                                }\r\n                            }\r\n                            else\r\n                                conditionsMet.push(condition);\r\n                        }\r\n                    }\r\n                    else {\r\n                        conditionsMet.push({});\r\n                    }\r\n\r\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\r\n                        let supportedMapping = _.cloneDeep(mapping);\r\n\r\n                        let updatedConditions = _.filter(conditionsMet, (condition) => Object.keys(condition).length > 0);\r\n                        if (!_.isEmpty(updatedConditions))\r\n                            supportedMapping.conditions = updatedConditions;\r\n                        supportedMappings.push(supportedMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\r\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\r\n            };\r\n        }\r\n\r\n        function checkForConditionErrors(projections: QueryProjectionsByRole, condition: DataViewMappingCondition, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchError[] {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertValue(condition, 'condition');\r\n\r\n            let conditionRoles = Object.keys(condition);\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            for (let i = 0, len = conditionRoles.length; i < len; i++) {\r\n                let roleName: string = conditionRoles[i],\r\n                    isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs),\r\n                    roleCondition = condition[roleName];\r\n\r\n                let roleCount = getPropertyCount(roleName, projections, isDrillable);\r\n                let rangeError = validateRange(roleCount, roleCondition);\r\n                if (rangeError != null) {\r\n                    errors.push({\r\n                        code: rangeError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n                let kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\r\n                if (kindError != null) {\r\n                    errors.push({\r\n                        code: kindError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return errors;\r\n        }\r\n\r\n        function areAllPropertiesValid(requiredProperties: DataViewObjectPropertyIdentifier[], objectDescriptors: DataViewObjectDescriptors, objectDefinitions?: DataViewObjectDefinitions): boolean {\r\n            if (_.isEmpty(requiredProperties))\r\n                return true;\r\n\r\n            if (!objectDescriptors || !objectDefinitions)\r\n                return false;\r\n\r\n            let staticEvalContext: data.IEvalContext = data.createStaticEvalContext();\r\n\r\n            return _.every(requiredProperties, (requiredProperty) => {\r\n                let objectDescriptorValue = null;\r\n                let objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\r\n                if (objectDescriptorProperty)\r\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\r\n                let objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\r\n\r\n                if (!objectDescriptorValue || !objectDefinitionValue)\r\n                    return false;\r\n\r\n                return data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\r\n            });\r\n        }\r\n\r\n        export function getPropertyCount(roleName: string, projections: QueryProjectionsByRole, useActiveIfAvailable?: boolean): number {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(projections, 'projections');\r\n\r\n            let projectionsForRole = projections[roleName];\r\n            if (projectionsForRole) {\r\n                if (useActiveIfAvailable)\r\n                    return 1;\r\n                return projectionsForRole.all().length;\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function hasSameCategoryIdentity(dataView1: DataView, dataView2: DataView): boolean {\r\n            if (dataView1\r\n                && dataView2\r\n                && dataView1.categorical\r\n                && dataView2.categorical) {\r\n                let dv1Categories = dataView1.categorical.categories;\r\n                let dv2Categories = dataView2.categorical.categories;\r\n                if (dv1Categories\r\n                    && dv2Categories\r\n                    && dv1Categories.length === dv2Categories.length) {\r\n                    for (let i = 0, len = dv1Categories.length; i < len; i++) {\r\n                        let dv1Identity = dv1Categories[i].identity;\r\n                        let dv2Identity = dv2Categories[i].identity;\r\n\r\n                        let dv1Length = getLengthOptional(dv1Identity);\r\n                        if (dv1Length !== getLengthOptional(dv2Identity))\r\n                            return false;\r\n\r\n                        for (let j = 0; j < dv1Length; j++) {\r\n                            if (!DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\r\n                                return false;\r\n                        }\r\n                    }\r\n\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function getLengthOptional(identity: DataViewScopeIdentity[]): number {\r\n            if (identity)\r\n                return identity.length;\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function areMetadataColumnsEquivalent(column1: DataViewMetadataColumn, column2: DataViewMetadataColumn): boolean {\r\n            if (!column1 && !column2)\r\n                return true;\r\n\r\n            if (!column1 || !column2)\r\n                return false;\r\n\r\n            if (column1.displayName !== column2.displayName)\r\n                return false;\r\n\r\n            if (column1.queryName !== column2.queryName)\r\n                return false;\r\n\r\n            if (column1.isMeasure !== column2.isMeasure)\r\n                return false;\r\n\r\n            if (column1.type !== column2.type)\r\n                return false;\r\n\r\n            if (column1.sort !== column2.sort)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\r\n        export function isMetadataEquivalent(metadata1: DataViewMetadata, metadata2: DataViewMetadata): boolean {\r\n            if (!metadata1 && !metadata2)\r\n                return true;\r\n\r\n            if (!metadata1 || !metadata2)\r\n                return false;\r\n\r\n            let previousColumnsLength = metadata1.columns.length;\r\n            let newColumnsLength = metadata2.columns.length;\r\n\r\n            if (previousColumnsLength !== newColumnsLength)\r\n                return false;\r\n\r\n            for (let i: number = 0; i < newColumnsLength; i++) {\r\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewRoleWildcard {\r\n        export function fromRoles(roles: string[]): DataViewRoleWildcard {\r\n            return new DataViewRoleWildcardImpl(roles);\r\n        }\r\n\r\n        export function equals(firstRoleWildcard: DataViewRoleWildcard, secondRoleWildcard: DataViewRoleWildcard): boolean {\r\n            return firstRoleWildcard.key &&\r\n                secondRoleWildcard.key &&\r\n                firstRoleWildcard.key === secondRoleWildcard.key &&\r\n                ArrayExtensions.sequenceEqual<string>(\r\n                    firstRoleWildcard.roles,\r\n                    secondRoleWildcard.roles,\r\n                    (role1: string, role2: string) => role1 === role2);\r\n        }\r\n\r\n        class DataViewRoleWildcardImpl implements DataViewRoleWildcard {\r\n            private _roles: string[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(roles: string[]) {\r\n                debug.assertNonEmpty(roles, 'roles');\r\n\r\n                this._roles = roles;\r\n                this._key = new Lazy<string>(() => JSON.stringify(this.roles));\r\n            }\r\n\r\n            public get roles(): string[] {\r\n                return this._roles;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewScopeIdentity {\r\n        /** Compares the two DataViewScopeIdentity values for equality. */\r\n        export function equals(x: DataViewScopeIdentity, y: DataViewScopeIdentity, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            return data.SQExpr.equals(<data.SQExpr>x.expr, <data.SQExpr>y.expr, ignoreCase);\r\n        }\r\n\r\n        export function filterFromIdentity(identities: DataViewScopeIdentity[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(identities))\r\n                return;\r\n            \r\n            let exprs: data.SQExpr[] = [];\r\n            for (let identity of identities) {\r\n                exprs.push(<data.SQExpr>identity.expr);\r\n            }\r\n\r\n            return filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function filterFromExprs(orExprs: data.SQExpr[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(orExprs))\r\n                return;\r\n\r\n            let resultExpr: data.SQExpr;\r\n            for (let orExpr of orExprs) {\r\n                let inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\r\n                if (resultExpr)\r\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\r\n                else\r\n                    resultExpr = inExpr || orExpr;\r\n            }\r\n            \r\n            if (resultExpr) {\r\n                if (isNot)\r\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\r\n            }\r\n\r\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\r\n        }\r\n    }\r\n\r\n    export module data {\r\n        import Lazy = jsCommon.Lazy;\r\n\r\n        export function createDataViewScopeIdentity(expr: SQExpr): DataViewScopeIdentity {\r\n            return new DataViewScopeIdentityImpl(expr);\r\n        }\r\n\r\n        class DataViewScopeIdentityImpl implements DataViewScopeIdentity {\r\n            private _expr: SQExpr;\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(expr: SQExpr) {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                this._expr = expr;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serialize(expr));\r\n            }\r\n\r\n            public get expr(): SQExpr {\r\n                return this._expr;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewScopeWildcard {\r\n        export function matches(wildcard: DataViewScopeWildcard, instance: DataViewScopeIdentity): boolean {\r\n            let instanceExprs = ScopeIdentityExtractor.getKeys(<SQExpr>instance.expr);\r\n            if (!instanceExprs)\r\n                return false;\r\n\r\n            return SQExprUtils.sequenceEqual(<SQExpr[]>wildcard.exprs, instanceExprs);\r\n        }\r\n\r\n        export function equals(firstScopeWildcard: DataViewScopeWildcard, secondScopeWildcard: DataViewScopeWildcard): boolean {\r\n            return firstScopeWildcard.key === secondScopeWildcard.key &&\r\n                SQExprUtils.sequenceEqual(<SQExpr[]>firstScopeWildcard.exprs, <SQExpr[]>secondScopeWildcard.exprs);\r\n        }\r\n\r\n        export function fromExprs(exprs: SQExpr[]): DataViewScopeWildcard {\r\n            return new DataViewScopeWildcardImpl(exprs);\r\n        }\r\n\r\n        class DataViewScopeWildcardImpl implements DataViewScopeWildcard {\r\n            private _exprs: SQExpr[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(exprs: SQExpr[]) {\r\n                debug.assertValue(exprs, 'exprs');\r\n\r\n                this._exprs = exprs;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serializeArray(exprs));\r\n            }\r\n\r\n            public get exprs(): SQExpr[] {\r\n                return this._exprs;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface IColorAllocatorCache {\r\n        get(key: SQFillRuleExpr): IColorAllocator;\r\n        register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this;\r\n    }\r\n\r\n    export function createColorAllocatorCache(): IColorAllocatorCache {\r\n        return new ColorAllocatorProvider();\r\n    }\r\n\r\n    interface ColorAllocatorCacheEntry {\r\n        key: SQFillRuleExpr;\r\n        allocator: IColorAllocator;\r\n    }\r\n\r\n    class ColorAllocatorProvider implements IColorAllocatorCache {\r\n        private cache: ColorAllocatorCacheEntry[];\r\n\r\n        constructor() {\r\n            this.cache = [];\r\n        }\r\n\r\n        public get(key: SQFillRuleExpr): IColorAllocator {\r\n            debug.assertValue(key, 'key');\r\n\r\n            for (let entry of this.cache) {\r\n                if (entry.key === key)\r\n                    return entry.allocator;\r\n            }\r\n        }\r\n\r\n        public register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this {\r\n            debug.assertValue(key, 'key');\r\n            debug.assertValue(colorAllocator, 'colorAllocator');\r\n            debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\r\n\r\n            this.cache.push({\r\n                key: key,\r\n                allocator: colorAllocator,\r\n            });\r\n\r\n            return this;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewRegressionRunOptions {\r\n        dataViewMappings: DataViewMapping[];\r\n        visualDataViews: DataView[];\r\n        dataRoles: VisualDataRole[];\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        objectDefinitions: DataViewObjectDefinitions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        transformSelects: DataViewSelectTransform[];\r\n        metadata: DataViewMetadata;\r\n        projectionActiveItems: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export module DataViewRegression {\r\n        // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\r\n        // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\r\n        const regressionXQueryName: string = 'RegressionX';\r\n        const regressionSeriesQueryName: string = 'RegressionSeries';\r\n        export const regressionYQueryName: string = 'RegressionY';\r\n\r\n        export function run(options: DataViewRegressionRunOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let dataViewMappings: DataViewMapping[] = options.dataViewMappings;\r\n            let visualDataViews: DataView[] = options.visualDataViews;\r\n            let dataRoles: VisualDataRole[] = options.dataRoles;\r\n            let objectDescriptors: DataViewObjectDescriptors = options.objectDescriptors;\r\n            let objectDefinitions: DataViewObjectDefinitions = options.objectDefinitions;\r\n            let colorAllocatorFactory: IColorAllocatorFactory = options.colorAllocatorFactory;\r\n            let transformSelects: DataViewSelectTransform[] = options.transformSelects;\r\n            let projectionActiveItems = options.projectionActiveItems;\r\n            let metadata: DataViewMetadata = options.metadata;\r\n\r\n            if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\r\n                // compute linear regression line if applicable\r\n                let roleKindByQueryRef: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\r\n                let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\r\n                if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\r\n                    return visualDataViews;\r\n\r\n                let applicableDataViewMappings: DataViewMapping[] = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\r\n\r\n                if (applicableDataViewMappings) {\r\n                    let regressionDataViewMapping: DataViewMapping = _.find(applicableDataViewMappings, (dataViewMapping) => {\r\n                        return dataViewMapping.usage && dataViewMapping.usage.regression;\r\n                    });\r\n\r\n                    if (regressionDataViewMapping) {\r\n                        let regressionDataViews: DataView[] = [];\r\n                        for (let visualDataView of visualDataViews) {\r\n                            let regressionDataView: DataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\r\n\r\n                            if (regressionDataView)\r\n                                regressionDataViews.push(regressionDataView);\r\n                        }\r\n\r\n                        if (!_.isEmpty(regressionDataViews))\r\n                            visualDataViews.push(...regressionDataViews);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        /**\r\n         * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\r\n         * It works on scalar axis only.\r\n         * The algorithm is as follows\r\n         *\r\n         * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\r\n         * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\r\n         * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\r\n         * If highlights values are present, repeat steps 2 & 3 using highlight values.\r\n         * 4. Create the new dataView using the points computed above\r\n         */\r\n        export function linearRegressionTransform(\r\n            sourceDataView: DataView,\r\n            dataRoles: VisualDataRole[],\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\r\n            debug.assertValue(dataRoles, 'dataRoles');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!sourceDataView.categorical)\r\n                return;\r\n\r\n            // Step 1\r\n            let xColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.X, sourceDataView.categorical, dataRoles);\r\n            let yColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.Y, sourceDataView.categorical, dataRoles);\r\n\r\n            if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\r\n                return;\r\n\r\n            let xColumnSource = xColumns[0].source;\r\n            let yColumnSource = yColumns[0].source;\r\n\r\n            let combineSeries = true;\r\n            if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\r\n                let regressionUsage = regressionDataViewMapping.usage.regression;\r\n\r\n                let combineSeriesPropertyId = regressionUsage['combineSeries'];\r\n                if (combineSeriesPropertyId) {\r\n                    combineSeries = DataViewObjects.getValue<boolean>(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\r\n                }\r\n            }\r\n\r\n            // Step 2\r\n            let dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\r\n            let lineDefSet = calculateLineDefinitions(dataPointsBySeries);\r\n            if (!lineDefSet)\r\n                return;\r\n\r\n            let xMin = lineDefSet.xMin;\r\n            let xMax = lineDefSet.xMax;\r\n\r\n            let shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\r\n            let highlightsLineDefSet: LineDefinitionSet;\r\n            if (shouldComputeHightlights) {\r\n                let highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\r\n                highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\r\n                if (highlightsLineDefSet) {\r\n                    xMin = _.min([xMin, highlightsLineDefSet.xMin]);\r\n                    xMax = _.max([xMax, highlightsLineDefSet.xMax]);\r\n                }\r\n                else {\r\n                    shouldComputeHightlights = false;\r\n                }\r\n            }\r\n\r\n            // Step 3\r\n            let valuesByTrend: number[][] = [];\r\n            for (let trend of lineDefSet.lineDefs) {\r\n                valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n            }\r\n\r\n            let highlightsByTrend: number[][];\r\n            if (shouldComputeHightlights) {\r\n                highlightsByTrend = [];\r\n                for (let trend of highlightsLineDefSet.lineDefs) {\r\n                    highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n                }\r\n            }\r\n\r\n            // Step 4\r\n            let groupValues: PrimitiveValue[];\r\n            if (combineSeries) {\r\n                groupValues = ['combinedRegressionSeries'];\r\n            }\r\n            else {\r\n                // If we are producing a trend line per series we need to maintain the group identities so that we can map between the\r\n                // trend line and the original series (to match the color for example).\r\n                if (sourceDataView.categorical.values.source) {\r\n                    // Source data view has dynamic series.\r\n                    let groups = sourceDataView.categorical.values.grouped();\r\n                    groupValues = _.map(groups, (group) => group.name);\r\n                }\r\n                else {\r\n                    // Source data view has static or no series.\r\n                    groupValues = _.map(yColumns, (column) => column.source.queryName);\r\n                }\r\n            }\r\n\r\n            // Step 5\r\n            let regressionDataView: DataView = createRegressionDataView(\r\n                xColumnSource,\r\n                yColumnSource,\r\n                groupValues,\r\n                [xMin, xMax],\r\n                valuesByTrend,\r\n                highlightsByTrend,\r\n                sourceDataView,\r\n                regressionDataViewMapping,\r\n                objectDescriptors,\r\n                objectDefinitions,\r\n                colorAllocatorFactory);\r\n\r\n            return regressionDataView;\r\n        }\r\n\r\n        function calculateLineDefinitions(dataPointsBySeries: DataPointSet[]): LineDefinitionSet {\r\n            let xMin: PrimitiveValue;\r\n            let xMax: PrimitiveValue;\r\n            let lineDefs: LineDefinition[] = [];\r\n            for (let dataPointSet of dataPointsBySeries) {\r\n                let unsortedXValues: PrimitiveValue[] = dataPointSet.xValues;\r\n                let unsortedYValues: PrimitiveValue[] = dataPointSet.yValues;\r\n\r\n                if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\r\n                    return;\r\n\r\n                // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\r\n                let xDataType: string = getDataType(unsortedXValues);\r\n                if (!xDataType)\r\n                    return;\r\n                let yDataType: string = getDataType(unsortedYValues);\r\n                if (!yDataType)\r\n                    return;\r\n\r\n                let sortedDataPointSet: DataPointSet = sortValues(unsortedXValues, unsortedYValues);\r\n                let minCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[0];\r\n                let maxCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\r\n\r\n                let lineDef: LineDefinition = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\r\n\r\n                xMin = _.min([xMin, minCategoryValue]);\r\n                xMax = _.max([xMax, maxCategoryValue]);\r\n\r\n                lineDefs.push(lineDef);\r\n            }\r\n\r\n            return {\r\n                lineDefs: lineDefs,\r\n                xMin: xMin,\r\n                xMax: xMax,\r\n            };\r\n        }\r\n\r\n        function getColumnsForCartesianRoleKind(roleKind: CartesianRoleKind, categorical: DataViewCategorical, roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            debug.assertValue(roleKind, 'roleKind');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n\r\n            let categories = categorical.categories;\r\n            if (_.isEmpty(categories))\r\n                return;\r\n\r\n            debug.assert(categories.length === 1, 'composite category columns not supported');\r\n            let categoryColumn = categories[0];\r\n            columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n        }\r\n\r\n        function getColumnsWithRoleKind(roleKind: CartesianRoleKind, columns: DataViewCategoricalColumn[], roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            if (_.isEmpty(columns))\r\n                return;\r\n\r\n            return _.filter(columns, (column) => {\r\n                for (let roleName in column.source.roles) {\r\n                    if (!column.source.roles[roleName])\r\n                        continue;\r\n\r\n                    let role = _.find(roles, (role) => role.name === roleName);\r\n                    if (role && role.cartesianKind === roleKind)\r\n                        return true;\r\n                }\r\n\r\n                return false;\r\n            });\r\n        }\r\n\r\n        function getDataType(values: PrimitiveValue[]): string {\r\n            let firstNonNull: PrimitiveValue = _.find(values, (value) => value != null);\r\n            if (firstNonNull == null)\r\n                return;\r\n\r\n            let dataType: string = typeof firstNonNull;\r\n\r\n            if (_.some(values, (value) => value != null && typeof value !== dataType))\r\n                return;\r\n\r\n            return dataType;\r\n        }\r\n\r\n        function sortValues(unsortedXValues: PrimitiveValue[], unsortedYValues: PrimitiveValue[]): DataPointSet {\r\n            debug.assertValue(unsortedXValues, 'unsortedXValues');\r\n            debug.assertValue(unsortedYValues, 'unsortedYValues');\r\n\r\n            let zippedValues = _.zip(unsortedXValues, unsortedYValues);\r\n            let [xValues, yValues] = _.chain(zippedValues)\r\n                .filter((valuePair) => valuePair[0] != null && valuePair[1] != null)\r\n                .sortBy((valuePair) => valuePair[0])\r\n                .unzip()\r\n                .value();\r\n\r\n            return {\r\n                xValues: xValues,\r\n                yValues: yValues\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Computes a line definition using linear regression.\r\n         *   xBar: average of X values, yBar: average of Y values\r\n         *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\r\n         *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\r\n         *   Slope: ssXY / ssXX\r\n         *   Intercept: yBar - xBar * slope\r\n         */\r\n        function computeRegressionLine(xValues: number[], yValues: number[]): LineDefinition {\r\n            debug.assertValue(xValues, 'xValues');\r\n            debug.assertValue(yValues, 'yValues');\r\n\r\n            let xBar = _.sum(xValues) / xValues.length;\r\n            let yBar = _.sum(yValues) / yValues.length;\r\n\r\n            let ssXX = _.chain(xValues)\r\n                .map((x) => {\r\n                    return (x - xBar) ** 2;\r\n                })\r\n                .sum();\r\n\r\n            let ssXY = _.chain(xValues)\r\n                .map((x, i) => {\r\n                    return (x - xBar) * (yValues[i] - yBar);\r\n                })\r\n                .sum();\r\n\r\n            let slope = ssXY / ssXX;\r\n            let intercept = yBar - (xBar * slope);\r\n\r\n            return {\r\n                slope: slope,\r\n                intercept: intercept\r\n            };\r\n        }\r\n\r\n        function computeLineYValues(lineDef: LineDefinition, x1: number, x2: number): number[] {\r\n            return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\r\n        }\r\n\r\n        function getValuesFromColumn(column: DataViewCategoricalColumn, preferHighlights: boolean): PrimitiveValue[] {\r\n            if (preferHighlights) {\r\n                // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                if (valueColumn.highlights) {\r\n                    return valueColumn.highlights;\r\n                }\r\n            }\r\n\r\n            return column.values;\r\n        }\r\n\r\n        function getDataPointsBySeries(xColumns: DataViewCategoricalColumn[], yColumns: DataViewCategoricalColumn[], combineSeries: boolean, preferHighlights: boolean): DataPointSet[] {\r\n            let dataPointsBySeries: DataPointSet[] = [];\r\n            let xValueArray: PrimitiveValue[][] = _.map(xColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n            let seriesYValues: PrimitiveValue[][] = _.map(yColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n\r\n            let multipleXValueColumns: boolean = xColumns.length > 1;\r\n            for (let i = 0; i < seriesYValues.length; i++) {\r\n                let xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\r\n                let yValues = seriesYValues[i];\r\n\r\n                if (combineSeries && dataPointsBySeries.length > 0) {\r\n                    dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\r\n                    dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\r\n                }\r\n                else {\r\n                    dataPointsBySeries.push({\r\n                        xValues: xValues,\r\n                        yValues: yValues,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return dataPointsBySeries;\r\n        }\r\n\r\n        function createRegressionDataView(\r\n            xColumnSource: DataViewMetadataColumn,\r\n            yColumnSource: DataViewMetadataColumn,\r\n            groupValues: PrimitiveValue[],\r\n            categories: PrimitiveValue[],\r\n            values: PrimitiveValue[][],\r\n            highlights: PrimitiveValue[][],\r\n            sourceDataView: DataView,\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(xColumnSource, 'xColumnSource');\r\n            debug.assertValue(yColumnSource, 'yColumnSource');\r\n            debug.assertValue(categories, 'categories');\r\n            debug.assertValue(values, 'values');\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertAnyValue(highlights, 'highlights');\r\n            debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\r\n\r\n            let xRole: string = (<DataViewRoleForMapping>regressionDataViewMapping.categorical.categories).for.in;\r\n            let grouped = (<DataViewGroupedRoleMapping>regressionDataViewMapping.categorical.values).group;\r\n            let yRole: string;\r\n            let seriesRole: string;\r\n            if (grouped && !_.isEmpty(grouped.select)) {\r\n                yRole = (<DataViewRoleForMapping>grouped.select[0]).for ?\r\n                    (<DataViewRoleForMapping>grouped.select[0]).for.in :\r\n                    (<DataViewRoleBindMapping>grouped.select[0]).bind.to;\r\n                seriesRole = grouped.by;\r\n            }\r\n            if (!yRole || !seriesRole)\r\n                return;\r\n\r\n            let categoricalRoles: { [name: string]: boolean } = {[xRole]: true};\r\n            let valueRoles: { [name: string]: boolean } = {[yRole]: true};\r\n            let seriesRoles: { [name: string]: boolean } = {[seriesRole]: true};\r\n\r\n            let valuesBySeries: DataViewBuilderSeriesData[][] = [];\r\n            for (let index in values) {\r\n                let seriesData: DataViewBuilderSeriesData = {\r\n                    values: values[index],\r\n                };\r\n\r\n                if (highlights)\r\n                    seriesData.highlights = highlights[index];\r\n\r\n                valuesBySeries.push([seriesData]);\r\n            }\r\n\r\n            let regressionDataView: DataView = createCategoricalDataViewBuilder()\r\n                .withCategory({\r\n                    source: {\r\n                        displayName: xColumnSource.displayName,\r\n                        queryName: regressionXQueryName,\r\n                        type: xColumnSource.type,\r\n                        isMeasure: false,\r\n                        roles: categoricalRoles\r\n                    },\r\n                    values: categories,\r\n                    identityFrom: {\r\n                        fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\r\n                    },\r\n                })\r\n                .withGroupedValues({\r\n                    groupColumn: {\r\n                        source: {\r\n                            displayName: yColumnSource.displayName + 'Regression',\r\n                            queryName: regressionSeriesQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: seriesRoles\r\n                        },\r\n                        values: groupValues,\r\n                        identityFrom: {\r\n                            fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\r\n                        }\r\n                    },\r\n                    valueColumns: [{\r\n                        source: {\r\n                            displayName: yColumnSource.displayName,\r\n                            queryName: regressionYQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: valueRoles\r\n                        },\r\n                    }],\r\n                    data: valuesBySeries\r\n                })\r\n                .build();\r\n            DataViewTransform.transformObjects(regressionDataView, data.StandardDataViewKinds.Categorical, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\r\n            return regressionDataView;\r\n        }\r\n\r\n        function hasHighlightValues(columns: DataViewCategoricalColumn[]): boolean {\r\n            return _.any(columns, (column) => {\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                return valueColumn.highlights != null;\r\n            });\r\n        }\r\n    }\r\n\r\n    interface DataPointSet {\r\n        xValues: any[];\r\n        yValues: any[];\r\n    }\r\n\r\n    interface LineDefinition {\r\n        slope: number;\r\n        intercept: number;\r\n    }\r\n\r\n    interface LineDefinitionSet {\r\n        lineDefs: LineDefinition[];\r\n        xMin: PrimitiveValue;\r\n        xMax: PrimitiveValue;\r\n    }\r\n}\r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewSelectTransform {\r\n        displayName?: string;\r\n        queryName?: string;\r\n        format?: string;\r\n        type?: ValueType;\r\n        roles?: { [roleName: string]: boolean };\r\n        kpi?: DataViewKpiColumnMetadata;\r\n        sort?: SortDirection;\r\n        expr?: SQExpr;\r\n        discourageAggregationAcrossGroups?: boolean;\r\n\r\n        /** Describes the default value applied to a column, if any. */\r\n        defaultValue?: DefaultValueDefinition;\r\n    }\r\n\r\n    export module DataViewSelectTransform {\r\n        /** Convert selection info to projections */\r\n        export function projectionsFromSelects(selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): QueryProjectionsByRole {\r\n            debug.assertAnyValue(selects, \"selects\");\r\n            debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\r\n\r\n            let projections: QueryProjectionsByRole = {};\r\n            for (let select of selects) {\r\n                if (!select)\r\n                    continue;\r\n\r\n                let roles = select.roles;\r\n                if (!roles)\r\n                    continue;\r\n\r\n                for (let roleName in roles) {\r\n                    if (roles[roleName]) {\r\n                        let qp = projections[roleName];\r\n                        if (!qp)\r\n                            qp = projections[roleName] = new QueryProjectionCollection([]);\r\n                        qp.all().push({ queryRef: select.queryName });\r\n\r\n                        if (projectionActiveItems && projectionActiveItems[roleName])\r\n                            qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], (activeItem: DataViewProjectionActiveItemInfo) => activeItem.queryRef);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return projections;\r\n        }\r\n\r\n        /** Use selections and metadata to fashion query role kinds */\r\n        export function createRoleKindFromMetadata(selects: DataViewSelectTransform[], metadata: DataViewMetadata): RoleKindByQueryRef {\r\n            let roleKindByQueryRef: DataViewAnalysis.RoleKindByQueryRef = {};\r\n            for (let column of metadata.columns) {\r\n                if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\r\n                    continue;\r\n\r\n                let select = selects[column.index];\r\n                if (select) {\r\n                    let queryRef = select.queryName;\r\n                    if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\r\n                        roleKindByQueryRef[queryRef] = column.isMeasure ? VisualDataRoleKind.Measure : VisualDataRoleKind.Grouping;\r\n                    }\r\n                }\r\n            }\r\n            return roleKindByQueryRef;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface ICategoricalEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createCategoricalEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewCategorical: DataViewCategorical): ICategoricalEvalContext {\r\n        return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\r\n    }\r\n\r\n    class CategoricalEvalContext implements ICategoricalEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewCategorical;\r\n        private columnsByRole: { [name: string]: DataViewCategoricalColumn };\r\n        private index: number;\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewCategorical) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.columnsByRole = {};\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            let columnsByRole = this.columnsByRole;\r\n            let column = columnsByRole[roleName];\r\n            if (!column)\r\n                column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\r\n            \r\n            if (!column)\r\n                return;\r\n\r\n            let index = this.index;\r\n            if (index != null)\r\n                return column.values[this.index];\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.index = index;\r\n        }\r\n    }\r\n\r\n    function findRuleInputColumn(dataViewCategorical: DataViewCategorical, inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n\r\n        return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\r\n            findRuleInputInColumns(dataViewCategorical.categories, inputRole);\r\n    }\r\n\r\n    function findRuleInputInColumns(columns: DataViewCategoricalColumn[], inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertAnyValue(columns, 'columns');\r\n\r\n        if (!columns)\r\n            return;\r\n\r\n        for (let column of columns) {\r\n            let roles = column.source.roles;\r\n            if (!roles || !roles[inputRole])\r\n                continue;\r\n\r\n            return column;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ITableEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createTableEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewTable: DataViewTable, selectTransforms: DataViewSelectTransform[]): ITableEvalContext {\r\n        return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\r\n    }\r\n\r\n    class TableEvalContext implements ITableEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewTable;\r\n        private rowIdx: number;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewTable, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let rowIdx = this.rowIdx;\r\n            if (rowIdx == null)\r\n                return;\r\n\r\n            return getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.rowIdx = index;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class RuleEvaluation {\r\n        // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class ColorRuleEvaluation extends RuleEvaluation {\r\n        private inputRole: string;\r\n        private allocator: IColorAllocator;\r\n\r\n        constructor(inputRole: string, allocator: IColorAllocator) {\r\n            debug.assertValue(inputRole, 'inputRole');\r\n            debug.assertValue(allocator, 'allocator');\r\n\r\n            super();\r\n            this.inputRole = inputRole;\r\n            this.allocator = allocator;\r\n        }\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n\r\n            let value: any = evalContext.getRoleValue(this.inputRole);\r\n            if (value !== undefined)\r\n                return this.allocator.color(value);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    export module DataViewMatrixUtils {\r\n\r\n        /**\r\n         * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the \r\n         * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the \r\n         * particular leaf node in the context of this forEachLeafNode(...) invocation.\r\n         *\r\n         * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\r\n         *\r\n         * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified \r\n         * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\r\n         * then treePath will be an array of length 1 containing that very node.\r\n         *\r\n         * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\r\n         * If your callback needs to retain a copy of the treePath, please clone the array before returning.\r\n         */\r\n        export function forEachLeafNode(\r\n            rootNodes: DataViewMatrixNode | DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): void {\r\n            debug.assertAnyValue(rootNodes, 'rootNodes');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\r\n            // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \r\n            // for the fact that all the properties on DataViewMatrixNode are optional...\r\n            if (rootNodes) {\r\n                if (isNodeArray(rootNodes)) {\r\n                    let index = 0;\r\n                    for (let rootNode of rootNodes) {\r\n                        if (rootNode) {\r\n                            index = forEachLeafNodeRecursive(rootNode, index, [], callback);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    forEachLeafNodeRecursive(rootNodes, 0, [], callback);\r\n                }\r\n            }\r\n        }\r\n\r\n        function isNodeArray(nodeOrNodeArray: DataViewMatrixNode | DataViewMatrixNode[]): nodeOrNodeArray is DataViewMatrixNode[] {\r\n            return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\r\n        }\r\n\r\n        /**\r\n         * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\r\n         * Returns the index for the next node after the last node that this function invokes callback with.\r\n         *\r\n         * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\r\n         */\r\n        function forEachLeafNodeRecursive(\r\n            matrixNode: DataViewMatrixNode,\r\n            nextIndex: number,\r\n            treePath: DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): number {\r\n            debug.assertValue(matrixNode, 'matrixNode');\r\n            debug.assertValue(treePath, 'treePath');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // If treePath already contains matrixNode, then either one of the following errors has happened:\r\n            // 1. the caller code mistakenly added matrixNode to treePath, or\r\n            // 2. the callback modified treePath by adding a node to it, or\r\n            // 3. the matrix hierarchy contains a cyclical node reference.');\r\n            debug.assert(!_.contains(treePath, matrixNode),\r\n                'pre-condition: treePath must not already contain matrixNode');\r\n\r\n            treePath.push(matrixNode);\r\n\r\n            if (_.isEmpty(matrixNode.children)) { // if it is a leaf node\r\n                callback(matrixNode, nextIndex, treePath);\r\n                nextIndex++;\r\n            }\r\n            else {\r\n                let children = matrixNode.children;\r\n                for (let nextChild of children) {\r\n                    if (nextChild) {\r\n                        nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\r\n                    }\r\n                }\r\n            }\r\n\r\n            debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\r\n            treePath.pop();\r\n\r\n            return nextIndex;\r\n        }\r\n\r\n        /**\r\n         * Returned an object tree where each node and its children property are inherited from the specified node \r\n         * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\r\n         *\r\n         * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array \r\n         * property, i.e. its children property is the same array object referenced in the input node's object tree.\r\n         *\r\n         * @param node The input node with the hierarchy object tree.\r\n         * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\r\n         * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is \r\n         * not already an inherited object. Same goes for the node's children property.  This is useful for creating \r\n         * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for \r\n         * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains \r\n         * inherited objects.\r\n         */\r\n        export function inheritMatrixNodeHierarchy(\r\n            node: DataViewMatrixNode,\r\n            deepestLevelToInherit: number,\r\n            useInheritSingle: boolean): DataViewMatrixNode {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\r\n            debug.assertValue(useInheritSingle, 'useInheritSingle');\r\n\r\n            let returnNode = node;\r\n\r\n            // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\r\n            // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\r\n            // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\r\n            //  {\r\n            //    \"level\": 0,\r\n            //    \"isSubtotal\": true,\r\n            //    \"children\": [\r\n            //      { \"level\": 2, \"isSubtotal\": true },\r\n            //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\r\n            //    ]\r\n            //  }\r\n            let isRootNode = _.isUndefined(node.level);\r\n            let shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\r\n            if (shouldInheritCurrentNode) {\r\n                let inheritFunc = useInheritSingle ? inheritSingle : inherit;\r\n                let inheritedNode: DataViewMatrixNode = inheritFunc(node);\r\n\r\n                let shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\r\n                if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\r\n                    inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\r\n                    for (let i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\r\n                        inheritedNode.children[i] =\r\n                            inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\r\n                    }\r\n                }\r\n\r\n                returnNode = inheritedNode;\r\n            }\r\n\r\n            return returnNode;\r\n        }\r\n\r\n        /**\r\n         * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\r\n         * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\r\n         * Year === 2016, Quarter === 'Qtr 1', Month === 1.\r\n         *\r\n         * Returns false if the specified matrixOrHierarchy does not contain any composite group, \r\n         * or if matrixOrHierarchy is null or undefined.\r\n         */\r\n        export function containsCompositeGroup(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): boolean {\r\n            debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\r\n\r\n            let hasCompositeGroup = false;\r\n\r\n            if (matrixOrHierarchy) {\r\n                if (isMatrix(matrixOrHierarchy)) {\r\n                    hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\r\n                        containsCompositeGroup(matrixOrHierarchy.columns);\r\n                }\r\n                else {\r\n                    let hierarchyLevels = matrixOrHierarchy.levels;\r\n                    if (!_.isEmpty(hierarchyLevels)) {\r\n                        for (var level of hierarchyLevels) {\r\n                            // it takes at least 2 columns at the same hierarchy level to form a composite group...\r\n                            if (level.sources && (level.sources.length >= 2)) {\r\n\r\n                                debug.assert(_.all(level.sources, sourceColumn => sourceColumn.isMeasure === level.sources[0].isMeasure),\r\n                                    'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\r\n\r\n                                // Measure headers are not group\r\n                                let isMeasureHeadersLevel = level.sources[0].isMeasure;\r\n                                if (!isMeasureHeadersLevel) {\r\n                                    hasCompositeGroup = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return hasCompositeGroup;\r\n        }\r\n\r\n        function isMatrix(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): matrixOrHierarchy is DataViewMatrix {\r\n            return 'rows' in matrixOrHierarchy &&\r\n                'columns' in matrixOrHierarchy &&\r\n                'valueSources' in matrixOrHierarchy;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    export module DataViewMetadataColumnUtils {\r\n\r\n        export interface MetadataColumnAndProjectionIndex {\r\n            /**\r\n            * A metadata column taken from a source collection, e.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n            */\r\n            metadataColumn: DataViewMetadataColumn;\r\n\r\n            /**\r\n             * The index of this.metadataColumn in its sources collection.\r\n             *\r\n             * E.g.1 This can be the value of the property DataViewMatrixGroupValue.levelSourceIndex which is the index of this.metadataColumn in DataViewHierarchyLevel.sources.\r\n             * E.g.2 This can be the value of the property DataViewMatrixNodeValue.valueSourceIndex which refer to columns in DataViewMatrix.valueSources.\r\n             */\r\n            sourceIndex: number;\r\n\r\n            /**\r\n            * The index of this.metadataColumn in the projection ordering of a given role.\r\n            */\r\n            projectionOrderIndex: number;\r\n        }\r\n\r\n        /**\r\n         * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\r\n         */\r\n        export function isForRole(metadataColumn: DataViewMetadataColumn, targetRole: string): boolean {\r\n            debug.assertValue(metadataColumn, 'metadataColumn');\r\n            debug.assertValue(targetRole, 'targetRole');\r\n\r\n            let roles = metadataColumn.roles;\r\n            return roles && roles[targetRole];\r\n        }\r\n\r\n        /**\r\n         * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\r\n         *\r\n         * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the \r\n         * specified columnSources must be a non-filtered array of column sources from the DataView, such as\r\n         * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\r\n         *\r\n         * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n         * @param projection The projection ordering.  It must contain an ordering for the specified role.\r\n         * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\r\n         */\r\n        export function joinMetadataColumnsAndProjectionOrder(\r\n            columnSources: DataViewMetadataColumn[],\r\n            projection: DataViewProjectionOrdering,\r\n            role: string): MetadataColumnAndProjectionIndex[] {\r\n            debug.assertAnyValue(columnSources, 'columnSources');\r\n            debug.assert(_.all(columnSources, column => _.isNumber(column.index)),\r\n                'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\r\n            debug.assertNonEmpty(projection[role], 'projection[role]');\r\n            debug.assert(_.all(columnSources, column => !isForRole(column, role) || _.contains(projection[role], column.index)),\r\n                'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\r\n\r\n            let jointResult: MetadataColumnAndProjectionIndex[] = [];\r\n\r\n            if (!_.isEmpty(columnSources)) {\r\n                let projectionOrderSelectIndices = projection[role];\r\n                let selectIndexToProjectionIndexMap: { [selectIndex: number]: number } = {};\r\n                for (let i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\r\n                    let selectIndex = projectionOrderSelectIndices[i];\r\n                    selectIndexToProjectionIndexMap[selectIndex] = i;\r\n                }\r\n\r\n                for (let j = 0, jlen = columnSources.length; j < jlen; j++) {\r\n                    var column = columnSources[j];\r\n                    if (isForRole(column, role)) {\r\n                        let jointColumnInfo: MetadataColumnAndProjectionIndex = {\r\n                            metadataColumn: column,\r\n                            sourceIndex: j,\r\n                            projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\r\n                        };\r\n\r\n                        jointResult.push(jointColumnInfo);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return jointResult;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export class ConceptualSchema {\r\n        public entities: ArrayNamedItems<ConceptualEntity>;\r\n        public capabilities: ConceptualCapabilities;\r\n\r\n        /** Indicates whether the user can edit this ConceptualSchema.  This is used to enable/disable model authoring UX. */\r\n        public canEdit: boolean;\r\n\r\n        public findProperty(entityName: string, propertyName: string): ConceptualProperty {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            return entity.properties.withName(propertyName);\r\n        }\r\n\r\n        public findHierarchy(entityName: string, name: string): ConceptualHierarchy {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.hierarchies))\r\n                return;\r\n\r\n            return entity.hierarchies.withName(name);\r\n        }\r\n\r\n        public findHierarchyByVariation(\r\n            variationEntityName: string,\r\n            variationColumnName: string,\r\n            variationName: string,\r\n            hierarchyName: string): ConceptualHierarchy {\r\n\r\n            let variationEntity = this.entities.withName(variationEntityName);\r\n            if (!variationEntity || _.isEmpty(variationEntity.properties))\r\n                return;\r\n\r\n            let variationProperty = variationEntity.properties.withName(variationColumnName);\r\n            if (!variationProperty)\r\n                return;\r\n\r\n            let variationColumn = variationProperty.column;\r\n            if (!variationColumn || _.isEmpty(variationColumn.variations))\r\n                return;\r\n\r\n            let variation = variationColumn.variations.withName(variationName);\r\n            if (variation) {\r\n                let targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\r\n                if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\r\n                    return;\r\n\r\n                return targetEntity.hierarchies.withName(hierarchyName);\r\n            }\r\n        }\r\n\r\n        /**\r\n        * Returns the first property of the entity whose kpi is tied to kpiProperty\r\n        */\r\n        public findPropertyWithKpi(entityName: string, kpiProperty: ConceptualProperty): ConceptualProperty {\r\n            debug.assertValue(kpiProperty, 'kpiProperty');\r\n\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            for (let prop of entity.properties) {\r\n                if (prop &&\r\n                    prop.measure &&\r\n                    prop.measure.kpi &&\r\n                    (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\r\n                    return prop;\r\n            }\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    export interface ConceptualCapabilities {\r\n        discourageQueryAggregateUsage: boolean;\r\n        normalizedFiveStateKpiRange: boolean;\r\n        supportsMedian: boolean;\r\n        supportsPercentile: boolean;\r\n        supportsScopedEval: boolean;\r\n    }\r\n\r\n    export interface ConceptualPropertyItemContainer {\r\n        properties: ArrayNamedItems<ConceptualProperty>;\r\n        hierarchies?: ArrayNamedItems<ConceptualHierarchy>;\r\n        displayFolders?: ArrayNamedItems<ConceptualDisplayFolder>;\r\n    }\r\n\r\n    export interface ConceptualPropertyItem {\r\n        name: string;\r\n        displayName: string;\r\n        hidden?: boolean;\r\n    }\r\n\r\n    export interface ConceptualEntity extends ConceptualPropertyItemContainer {\r\n        name: string;\r\n        displayName: string;\r\n        visibility?: ConceptualVisibility;\r\n        calculated?: boolean;\r\n        queryable?: ConceptualQueryableState;\r\n        navigationProperties?: ArrayNamedItems<ConceptualNavigationProperty>;\r\n    }\r\n\r\n    export interface ConceptualDisplayFolder extends ConceptualPropertyItem, ConceptualPropertyItemContainer {\r\n    }\r\n\r\n    export interface ConceptualProperty extends ConceptualPropertyItem {\r\n        type: ValueType;\r\n        kind: ConceptualPropertyKind;\r\n        format?: string;\r\n        column?: ConceptualColumn;\r\n        queryable?: ConceptualQueryableState;\r\n        measure?: ConceptualMeasure;\r\n        kpiValue?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualHierarchy extends ConceptualPropertyItem {\r\n        levels: ArrayNamedItems<ConceptualHierarchyLevel>;\r\n    }\r\n\r\n    export interface ConceptualHierarchyLevel extends ConceptualPropertyItem {\r\n        column: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualNavigationProperty {\r\n        name: string;\r\n        isActive: boolean;\r\n        sourceColumn?: ConceptualColumn;\r\n        targetEntity: ConceptualEntity;\r\n        sourceMultiplicity: ConceptualMultiplicity;\r\n        targetMultiplicity: ConceptualMultiplicity;\r\n    }\r\n\r\n    export interface ConceptualVariationSource {\r\n        name: string;\r\n        isDefault: boolean;\r\n        navigationProperty?: ConceptualNavigationProperty;\r\n        defaultHierarchy?: ConceptualHierarchy;\r\n        defaultProperty?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualColumn {\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n        keys?: ArrayNamedItems<ConceptualProperty>;\r\n        idOnEntityKey?: boolean;\r\n        calculated?: boolean;\r\n        defaultValue?: SQConstantExpr;\r\n        variations?: ArrayNamedItems<ConceptualVariationSource>;\r\n        aggregateBehavior?: ConceptualAggregateBehavior;\r\n    }\r\n\r\n    export interface ConceptualMeasure {\r\n        kpi?: ConceptualPropertyKpi;\r\n    }\r\n\r\n    export interface ConceptualPropertyKpi {\r\n        statusMetadata: DataViewKpiColumnMetadata;\r\n        trendMetadata?: DataViewKpiColumnMetadata;\r\n        status?: ConceptualProperty;\r\n        goal?: ConceptualProperty;\r\n        trend?: ConceptualProperty;\r\n    }\r\n\r\n    export const enum ConceptualVisibility {\r\n        Visible = 0,\r\n        Hidden = 1,\r\n        ShowAsVariationsOnly = 2,\r\n        IsPrivate = 4,\r\n    }\r\n\r\n    export const enum ConceptualQueryableState {\r\n        Queryable = 0,\r\n        Error = 1,\r\n    }\r\n\r\n    export const enum ConceptualMultiplicity {\r\n        ZeroOrOne = 0,\r\n        One = 1,\r\n        Many = 2,\r\n    }\r\n\r\n    export const enum ConceptualPropertyKind {\r\n        Column,\r\n        Measure,\r\n        Kpi,\r\n    }\r\n\r\n    export const enum ConceptualDefaultAggregate {\r\n        Default,\r\n        None,\r\n        Sum,\r\n        Count,\r\n        Min,\r\n        Max,\r\n        Average,\r\n        DistinctCount,\r\n    }\r\n\r\n    // TODO: Remove this (replaced by ValueType)\r\n    export enum ConceptualDataCategory {\r\n        None,\r\n        Address,\r\n        City,\r\n        Company,\r\n        Continent,\r\n        Country,\r\n        County,\r\n        Date,\r\n        Image,\r\n        ImageUrl,\r\n        Latitude,\r\n        Longitude,\r\n        Organization,\r\n        Place,\r\n        PostalCode,\r\n        Product,\r\n        StateOrProvince,\r\n        WebUrl,\r\n    }\r\n\r\n    export const enum ConceptualAggregateBehavior {\r\n        Default,\r\n        DiscourageAcrossGroups,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import FederatedConceptualSchema = powerbi.data.FederatedConceptualSchema;\r\n    import FieldExprColumnPattern = powerbi.data.FieldExprColumnPattern;\r\n    import FieldExprColumnAggrPattern = powerbi.data.FieldExprColumnAggrPattern;\r\n    import FieldExprColumnHierarchyLevelVariationPattern = powerbi.data.FieldExprColumnHierarchyLevelVariationPattern;\r\n    import FieldExprEntityPattern = powerbi.data.FieldExprEntityPattern;\r\n    import FieldExprEntityAggrPattern = powerbi.data.FieldExprEntityAggrPattern;\r\n    import FieldExprHierarchyPattern = powerbi.data.FieldExprHierarchyPattern;\r\n    import FieldExprHierarchyLevelPattern = powerbi.data.FieldExprHierarchyLevelPattern;\r\n    import FieldExprHierarchyLevelAggrPattern = powerbi.data.FieldExprHierarchyLevelAggrPattern;\r\n    import FieldExprMeasurePattern = powerbi.data.FieldExprMeasurePattern;\r\n    import FieldExprPattern = powerbi.data.FieldExprPattern;\r\n    import FieldExprPercentilePattern = powerbi.data.FieldExprPercentilePattern;\r\n    import FieldExprSelectRefPattern = powerbi.data.FieldExprSelectRefPattern;\r\n    import FieldExprPercentOfGrandTotalPattern = powerbi.data.FieldExprPercentOfGrandTotalPattern;\r\n    import IFieldExprPatternVisitor = powerbi.data.IFieldExprPatternVisitor;\r\n    import QueryProjectionsByRole = data.QueryProjectionsByRole;\r\n\r\n    export interface ScriptResult {\r\n        source: string;\r\n        provider: string;\r\n    }\r\n\r\n    export module ScriptResultUtil {\r\n\r\n        export function findScriptResult(dataViewMappings: DataViewMapping[] | data.CompiledDataViewMapping[]): DataViewScriptResultMapping | data.CompiledDataViewScriptResultMapping {\r\n            if (dataViewMappings && dataViewMappings.length === 1) {\r\n                return dataViewMappings[0].scriptResult;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResult(dataViewMappings: data.CompiledDataViewMapping[]): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult) {\r\n                let objects = dataViewMappings[0].metadata.objects;\r\n                let source: string = DataViewObjects.getValue<string>(objects, scriptResult.script.source);\r\n                let provider: string = DataViewObjects.getValue<string>(objects, scriptResult.script.provider);\r\n                return {\r\n                    source: source,\r\n                    provider: provider\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResultFromVisualConfig(dataViewMappings: DataViewMapping[], objects: powerbi.data.DataViewObjectDefinitions): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult && objects) {\r\n                let scriptSource = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\r\n                let provider = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\r\n                return {\r\n                    source: scriptSource ? scriptSource.value : null,\r\n                    provider: provider ? provider.value : null\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function getScriptInput(projections: QueryProjectionsByRole, selects: ArrayNamedItems<data.NamedSQExpr>, schema: FederatedConceptualSchema): data.ScriptInput {\r\n            let scriptInput: data.ScriptInput = {\r\n                VariableName: \"dataset\",\r\n                Columns: []\r\n            };\r\n\r\n            // Go over all the projections, and create an input column according to the order\r\n            // of the projections (including duplicate expressions)\r\n            if (projections && selects && !_.isEmpty(selects)) {\r\n                let scriptInputColumnNames: string[] = [];\r\n                let scriptInputColumns: data.ScriptInputColumn[] = [];\r\n                for (let role in projections) {\r\n                    for (let projection of projections[role].all()) {\r\n                        let select = selects.withName(projection.queryRef);\r\n                        if (select) {\r\n                            let scriptInputColumn = <data.ScriptInputColumn>{\r\n                                QueryName: select.name,\r\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\r\n                            };\r\n\r\n                            scriptInputColumns.push(scriptInputColumn);\r\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Make sure the names of the columns are unique\r\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\r\n\r\n                // Update the names of the columns\r\n                for (let i = 0; i < scriptInputColumnNames.length; i++) {\r\n                    let scriptInputColumn = scriptInputColumns[i];\r\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\r\n                }\r\n\r\n                scriptInput.Columns = scriptInputColumns;\r\n            }\r\n\r\n            return scriptInput;\r\n        }\r\n\r\n        class ScriptInputColumnNameVisitor implements IFieldExprPatternVisitor<string>\r\n        {\r\n            private federatedSchema: FederatedConceptualSchema;\r\n\r\n            constructor(federatedSchema: FederatedConceptualSchema) {\r\n                this.federatedSchema = federatedSchema;\r\n            }\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): string {\r\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): string {\r\n                return entity.entity;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): string {\r\n                return entityAggr.entity;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): string {\r\n                /*Hierarchy levels are not supported yet*/\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\r\n            }\r\n\r\n            public visitSelectRef(selectRef: FieldExprSelectRefPattern): string {\r\n                return FieldExprPattern.visit(selectRef, this);\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): string {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): string {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n\r\n            private static getNameForHierarchy(pattern: FieldExprHierarchyPattern, federatedScheam: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedScheam.schema(pattern.schema),\r\n                    hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\r\n\r\n                if (hierarchy)\r\n                    return hierarchy.name;\r\n            }\r\n\r\n            private static getNameForProperty(pattern: data.FieldExprPropertyPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedSchema.schema(pattern.schema),\r\n                    property = schema.findProperty(pattern.entity, pattern.name);\r\n\r\n                if (property)\r\n                    return property.name;\r\n            }\r\n\r\n            private static getVariationLevelName(pattern: FieldExprColumnHierarchyLevelVariationPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let source = pattern.source;\r\n                let prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\r\n                if (!prop)\r\n                    return;\r\n\r\n                let variations = prop.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === pattern.variationName)\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            if (level.name === pattern.level.level)\r\n                                return level.column.name;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.segmentation {\r\n\r\n    export interface DataViewTableSegment extends DataViewTable {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewTreeSegmentNode extends DataViewTreeNode {\r\n        /** Indicates whether the node is a duplicate of a node from a previous segment. */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export interface DataViewCategoricalSegment extends DataViewCategorical {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewMatrixSegmentNode extends DataViewMatrixNode {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export module DataViewMerger {\r\n\r\n        export function mergeDataViews(source: DataView, segment: DataView): void {\r\n\r\n            if (!DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\r\n                debug.assertFail(\"Cannot merge data views with different metadata columns\");\r\n            }\r\n\r\n            // The last segment is complete. We mark the source as complete.\r\n            if (!segment.metadata.segment)\r\n                delete source.metadata.segment;\r\n\r\n            if (source.table && segment.table)\r\n                mergeTables(source.table, <DataViewTableSegment>segment.table);\r\n\r\n            if (source.categorical && segment.categorical)\r\n                mergeCategorical(source.categorical, <DataViewCategoricalSegment>segment.categorical);\r\n\r\n            // Tree cannot support subtotals hence we can get into situations\r\n            // where a node has no children in one segment and more than 1 child\r\n            // in another segment.\r\n            if (source.tree && segment.tree)\r\n                mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\r\n\r\n            if (source.matrix && segment.matrix)\r\n                mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTables(source: DataViewTable, segment: DataViewTableSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            if (_.isEmpty(segment.rows))\r\n                return;\r\n\r\n            let mergeIndex = segment.lastMergeIndex + 1;\r\n            merge(source.rows, segment.rows, mergeIndex);\r\n\r\n            debug.assert(!source.identity === !segment.identity, 'The existence of identity in the new segment is different than the source');\r\n            if (segment.identity)\r\n                merge(source.identity, segment.identity, mergeIndex);\r\n        }\r\n\r\n        /**\r\n         * Merge categories values and identities\r\n         *\r\n         * Note: Public for testability\r\n         */\r\n        export function mergeCategorical(source: DataViewCategorical, segment: DataViewCategoricalSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            // Merge categories values and identities\r\n            if (source.categories && segment.categories) {\r\n                let segmentCategoriesLength = segment.categories.length;\r\n                debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\r\n\r\n                for (let categoryIndex: number = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\r\n                    let segmentCategory = segment.categories[categoryIndex];\r\n                    let sourceCategory = source.categories[categoryIndex];\r\n\r\n                    debug.assert(DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\r\n                    debug.assert(_.isUndefined(sourceCategory.values) ? _.isUndefined(sourceCategory.identity) : true, 'Source category is missing values but has identities.');\r\n\r\n                    let mergeIndex = segment.lastMergeIndex + 1;\r\n                    if (segmentCategory.values) {\r\n                        merge(sourceCategory.values, segmentCategory.values, mergeIndex);\r\n                    }\r\n\r\n                    if (segmentCategory.identity) {\r\n                        merge(sourceCategory.identity, segmentCategory.identity, mergeIndex);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Merge values for each value column\r\n            if (source.values && segment.values) {\r\n                let segmentValuesLength = segment.values.length;\r\n                debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\r\n\r\n                for (let valueIndex: number = 0; valueIndex < segmentValuesLength; valueIndex++) {\r\n                    let segmentValue = segment.values[valueIndex];\r\n                    let sourceValue = source.values[valueIndex];\r\n\r\n                    debug.assert(DataViewAnalysis.areMetadataColumnsEquivalent(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\r\n\r\n                    if (!sourceValue.values && segmentValue.values) {\r\n                        sourceValue.values = [];\r\n                    }\r\n\r\n                    let mergeIndex = segment.lastMergeIndex + 1;\r\n                    if (segmentValue.values) {\r\n                        merge(sourceValue.values, segmentValue.values, mergeIndex);\r\n                    }\r\n\r\n                    if (segmentValue.highlights) {\r\n                        merge(sourceValue.highlights, segmentValue.highlights, mergeIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Merges the segment array starting at the specified index into the source array\r\n         * and returns the segment slice that wasn't merged.\r\n         * The segment array is spliced up to specified index in the process.\r\n         */\r\n        function merge(source: any[], segment: any[], index?: number): any[] {\r\n            if (index >= segment.length)\r\n                return segment;\r\n\r\n            let result: any[] = [];\r\n            if (index !== undefined)\r\n                result = segment.splice(0, index);\r\n\r\n            Array.prototype.push.apply(source, segment);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTreeNodes(sourceRoot: DataViewTreeNode, segmentRoot: DataViewTreeNode, allowDifferentStructure: boolean): void {\r\n            debug.assertValue(sourceRoot, 'sourceRoot');\r\n            debug.assertValue(segmentRoot, 'segmentRoot');\r\n\r\n            if (!segmentRoot.children || segmentRoot.children.length === 0)\r\n                return;\r\n\r\n            if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\r\n                sourceRoot.children = segmentRoot.children;\r\n                return;\r\n            }\r\n\r\n            debug.assert(sourceRoot.children && sourceRoot.children.length >= 0,\r\n                \"Source tree has different structure than segment.\");\r\n\r\n            let firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\r\n            let lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\r\n            let mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\r\n\r\n            if (mergedChildren.length > 0)\r\n                mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\r\n        }\r\n\r\n        function findFirstAppendIndex(children: DataViewTreeNode[]): number {\r\n            if (children.length === 0)\r\n                return 0;\r\n\r\n            let i: number = 0;\r\n            for (; i < children.length; i++) {\r\n                let childSegment: DataViewTreeSegmentNode = <DataViewTreeSegmentNode>children[i];\r\n                if (!childSegment.isMerge)\r\n                    break;\r\n            }\r\n\r\n            return i;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Rewrites an expression tree, including all descendant nodes. */\r\n    export class SQExprRewriter implements ISQExprVisitor<SQExpr>, IFillRuleDefinitionVisitor<LinearGradient2Definition, LinearGradient3Definition> {\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQColumnRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQMeasureRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(rewrittenArg, expr.func);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPercentileExpr(rewrittenArg, expr.k, expr.exclusive);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyExpr(rewrittenArg, expr.hierarchy);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyLevelExpr(rewrittenArg, expr.level);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitAnd(orig: SQAndExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQAndExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitBetween(orig: SQBetweenExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this),\r\n                origLower = orig.lower,\r\n                rewrittenLower = origLower.accept(this),\r\n                origUpper = orig.upper,\r\n                rewrittenUpper = origUpper.accept(this);\r\n\r\n            if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\r\n                return orig;\r\n\r\n            return new SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\r\n        }\r\n\r\n        public visitIn(orig: SQInExpr): SQExpr {\r\n            let origArgs = orig.args,\r\n                rewrittenArgs = this.rewriteAll(origArgs),\r\n                origValues: SQExpr[][] = orig.values,\r\n                rewrittenValues: SQExpr[][];\r\n\r\n            for (let i = 0, len = origValues.length; i < len; i++) {\r\n                let origValueTuple = origValues[i],\r\n                    rewrittenValueTuple = this.rewriteAll(origValueTuple);\r\n\r\n                if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\r\n                    rewrittenValues = ArrayExtensions.take(origValues, i);\r\n\r\n                if (rewrittenValues)\r\n                    rewrittenValues.push(rewrittenValueTuple);\r\n            }\r\n\r\n            if (origArgs === rewrittenArgs && !rewrittenValues)\r\n                return orig;\r\n\r\n            return new SQInExpr(rewrittenArgs, rewrittenValues || origValues);\r\n        }\r\n\r\n        private rewriteAll(origExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(origExprs, 'origExprs');\r\n\r\n            let rewrittenResult: SQExpr[];\r\n            for (let i = 0, len = origExprs.length; i < len; i++) {\r\n                let origExpr = origExprs[i],\r\n                    rewrittenExpr = origExpr.accept(this);\r\n\r\n                if (origExpr !== rewrittenExpr && !rewrittenResult)\r\n                    rewrittenResult = ArrayExtensions.take(origExprs, i);\r\n\r\n                if (rewrittenResult)\r\n                    rewrittenResult.push(rewrittenExpr);\r\n            }\r\n\r\n            return rewrittenResult || origExprs;\r\n        }\r\n\r\n        public visitOr(orig: SQOrExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQOrExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitCompare(orig: SQCompareExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitContains(orig: SQContainsExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQContainsExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitExists(orig: SQExistsExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQExistsExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitNot(orig: SQNotExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQNotExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitStartsWith(orig: SQStartsWithExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQStartsWithExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitDateSpan(orig: SQDateSpanExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateSpanExpr(orig.unit, rewrittenArg);\r\n        }\r\n\r\n        public visitDateAdd(orig: SQDateAddExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\r\n        }\r\n\r\n        public visitNow(orig: SQNowExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitDefaultValue(orig: SQDefaultValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitAnyValue(orig: SQAnyValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitArithmetic(orig: SQArithmeticExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\r\n        }\r\n\r\n        public visitScopedEval(orig: SQScopedEvalExpr): SQExpr {\r\n            let origExpression = orig.expression,\r\n                rewrittenExpression = origExpression.accept(this),\r\n                origScope = orig.scope,\r\n                rewrittenScope = this.rewriteAll(origScope);\r\n\r\n            if (origExpression === rewrittenExpression && origScope === rewrittenScope)\r\n                return orig;\r\n\r\n            return new SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\r\n        }\r\n\r\n        public visitFillRule(orig: SQFillRuleExpr): SQExpr {\r\n            let origInput = orig.input,\r\n                rewrittenInput = origInput.accept(this);\r\n\r\n            let origRule = orig.rule;\r\n\r\n            let origGradient2 = origRule.linearGradient2,\r\n                rewrittenGradient2 = origGradient2;\r\n            if (origGradient2) {\r\n                rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\r\n            }\r\n\r\n            let origGradient3 = origRule.linearGradient3,\r\n                rewrittenGradient3 = origGradient3;\r\n            if (origGradient3) {\r\n                rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\r\n            }\r\n\r\n            if (origInput !== rewrittenInput ||\r\n                origGradient2 !== rewrittenGradient2 ||\r\n                origGradient3 !== rewrittenGradient3) {\r\n                let rewrittenRule: FillRuleDefinition = {};\r\n                if (rewrittenGradient2)\r\n                    rewrittenRule.linearGradient2 = rewrittenGradient2;\r\n                if (rewrittenGradient3)\r\n                    rewrittenRule.linearGradient3 = rewrittenGradient3;\r\n\r\n                return new SQFillRuleExpr(rewrittenInput, rewrittenRule);\r\n            }\r\n\r\n            return orig;\r\n        }\r\n\r\n        public visitLinearGradient2(origGradient2: LinearGradient2Definition): LinearGradient2Definition {\r\n            debug.assertValue(origGradient2, 'origGradient2');\r\n\r\n            let origMin = origGradient2.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMax = origGradient2.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient2;\r\n        }\r\n\r\n        public visitLinearGradient3(origGradient3: LinearGradient3Definition): LinearGradient3Definition {\r\n            debug.assertValue(origGradient3, 'origGradient3');\r\n\r\n            let origMin = origGradient3.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMid = origGradient3.mid,\r\n                rewrittenMid = this.visitFillRuleStop(origMid),\r\n                origMax = origGradient3.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    mid: rewrittenMid,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient3;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): RuleColorStopDefinition {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            let origColor = stop.color,\r\n                rewrittenColor = stop.color.accept(this);\r\n\r\n            let origValue = stop.value,\r\n                rewrittenValue = origValue;\r\n            if (origValue)\r\n                rewrittenValue = origValue.accept(this);\r\n\r\n            if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\r\n                let rewrittenStop: RuleColorStopDefinition = {\r\n                    color: rewrittenColor\r\n                };\r\n\r\n                if (rewrittenValue)\r\n                    rewrittenStop.value = rewrittenValue;\r\n\r\n                return rewrittenStop;\r\n            }\r\n\r\n            return stop;\r\n        }\r\n\r\n        public visitResourcePackageItem(orig: SQResourcePackageItemExpr): SQExpr {\r\n            return orig;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Responsible for writing equality comparisons against a field to an SQInExpr. */\r\n    export module EqualsToInRewriter {\r\n        export function run(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(new Rewriter());\r\n        }\r\n\r\n        class Rewriter extends SQExprRewriter {\r\n            private current: InBuilder;\r\n\r\n            constructor() {\r\n                super();\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): SQExpr {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return this.visitUnsupported(expr);\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let leftIsComparand = this.isComparand(expr.left);\r\n                let rightIsComparand = this.isComparand(expr.right);\r\n                if (leftIsComparand === rightIsComparand)\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let operand: SQExpr = leftIsComparand\r\n                    ? expr.left\r\n                    : expr.right;\r\n                let value: SQExpr = leftIsComparand\r\n                    ? expr.right\r\n                    : expr.left;\r\n\r\n                let current = this.current;\r\n                if (!current) {\r\n                    return SQExprBuilder.inExpr([operand], [[value]]);\r\n                }\r\n\r\n                current.add(operand, value);\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitOr(expr: SQOrExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current: InBuilder;\r\n                if (!this.current) {\r\n                    current = this.current = new InBuilder();\r\n                }\r\n\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n\r\n                if (current) {\r\n                    this.current = null;\r\n                    return current.complete() || expr;\r\n                }\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current = this.current;\r\n                if (current) {\r\n                    // NOTE: Composite keys are not supported by this algorithm.\r\n                    current.cancel();\r\n                    return expr;\r\n                }\r\n\r\n                return super.visitAnd(expr);\r\n            }\r\n\r\n            private visitUnsupported(expr: SQExpr): SQExpr {\r\n                let current = this.current;\r\n                if (current)\r\n                    current.cancel();\r\n\r\n                return expr;\r\n            }\r\n\r\n            private isSupported(expr: SQExpr): boolean {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return expr instanceof SQCompareExpr\r\n                    || expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQConstantExpr\r\n                    || expr instanceof SQHierarchyLevelExpr\r\n                    || expr instanceof SQOrExpr\r\n                    || expr instanceof SQAndExpr;\r\n            }\r\n\r\n            private isComparand(expr: SQExpr): boolean {\r\n                return expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQHierarchyLevelExpr;\r\n            }\r\n        }\r\n\r\n        class InBuilder {\r\n            private operand: SQExpr;\r\n            private values: SQExpr[];\r\n            private cancelled: boolean;\r\n\r\n            public add(operand: SQExpr, value: SQExpr): void {\r\n                debug.assertValue(operand, 'operand');\r\n                debug.assertValue(value, 'value');\r\n\r\n                if (this.cancelled)\r\n                    return;\r\n\r\n                if (this.operand && !SQExpr.equals(operand, this.operand)) {\r\n                    this.cancel();\r\n                    return;\r\n                }\r\n\r\n                this.operand = operand;\r\n\r\n                let values = this.values;\r\n                if (!values)\r\n                    values = this.values = [];\r\n\r\n                values.push(value);\r\n            }\r\n\r\n            public cancel(): void {\r\n                this.cancelled = true;\r\n            }\r\n\r\n            public complete(): SQInExpr {\r\n                if (this.cancelled || !this.operand)\r\n                    return;\r\n\r\n                return SQExprBuilder.inExpr([this.operand], _.map(this.values, v => [v]));\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface FilterValueScopeIdsContainer {\r\n            isNot: boolean;\r\n            scopeIds: DataViewScopeIdentity[];\r\n        }\r\n\r\n    export module SQExprConverter {\r\n        export function asScopeIdsContainer(filter: SemanticFilter, fieldSQExprs: SQExpr[]): FilterValueScopeIdsContainer {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\r\n\r\n            let filterItems = filter.conditions();\r\n            debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\r\n            let filterItem = filterItems[0];\r\n            if (filterItem) {\r\n                let visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\r\n                if (filterItem.accept(visitor))\r\n                    return visitor.getResult();\r\n            }\r\n        }\r\n\r\n        /** Gets a comparand value from the given DataViewScopeIdentity. */\r\n        export function getFirstComparandValue(identity: DataViewScopeIdentity): any {\r\n            debug.assertValue(identity, 'identity');\r\n\r\n            let comparandExpr = (<SQExpr>identity.expr).accept(new FindComparandVisitor());\r\n            if (comparandExpr)\r\n                return comparandExpr.value;\r\n        }\r\n    }\r\n\r\n    /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\r\n    class FilterScopeIdsCollectorVisitor extends DefaultSQExprVisitor<boolean>{\r\n        private isRoot: boolean;\r\n        private isNot: boolean;\r\n        private keyExprsCount: number;\r\n        private valueExprs: SQExpr[];\r\n        private fieldExprs: SQExpr[];\r\n\r\n        constructor(fieldSQExprs:SQExpr[]) {\r\n            super();\r\n            this.isRoot = true;\r\n            this.isNot = false;\r\n            this.keyExprsCount = null;\r\n            this.valueExprs = [];\r\n\r\n            // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\r\n            // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\r\n            // need to drop it in order to use JsonComparer.\r\n            this.fieldExprs = [];\r\n            for (let field of fieldSQExprs) {\r\n                this.fieldExprs.push(SQExprBuilder.removeEntityVariables(field));\r\n            }\r\n        }\r\n\r\n        public getResult(): FilterValueScopeIdsContainer {\r\n            debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');            \r\n\r\n            let valueExprs = this.valueExprs,\r\n                scopeIds: DataViewScopeIdentity[] = [];\r\n            let valueCount: number = this.keyExprsCount || 1;\r\n\r\n            for (let startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\r\n                let values = valueExprs.slice(startIndex, endIndex);\r\n                let scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\r\n\r\n                if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, DataViewScopeIdentity.equals))\r\n                    scopeIds.push(scopeId);\r\n\r\n                startIndex += valueCount;\r\n                endIndex += valueCount;\r\n            }\r\n\r\n            return {\r\n                isNot: this.isNot,\r\n                scopeIds: scopeIds,\r\n            };\r\n        }\r\n\r\n        private static getScopeIdentity(fieldExprs: SQExpr[], valueExprs: SQExpr[]): DataViewScopeIdentity {\r\n            debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\r\n            debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\r\n\r\n            let compoundSQExpr: SQExpr;\r\n            for (let i = 0, len = fieldExprs.length; i < len; i++) {\r\n                let equalsExpr = SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\r\n                if (!compoundSQExpr)\r\n                    compoundSQExpr = equalsExpr;\r\n                else\r\n                    compoundSQExpr = SQExprBuilder.and(compoundSQExpr, equalsExpr);\r\n            }\r\n\r\n            return createDataViewScopeIdentity(compoundSQExpr);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): boolean {\r\n            if (!this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isNot = true;\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): boolean {\r\n            if (this.isRoot && expr.type.primitiveType === PrimitiveType.Null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);            \r\n            return true;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n\r\n            if (expr.comparison !== QueryComparisonKind.Equal)\r\n                return this.unsupportedSQExpr();\r\n\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): boolean {\r\n            this.keyExprsCount = 0;\r\n            let result: boolean;\r\n            this.isRoot = false;\r\n            for (let arg of expr.args) {\r\n                result = arg.accept(this);\r\n                if (!result)\r\n                    return this.unsupportedSQExpr();\r\n\r\n                this.keyExprsCount++;\r\n            }\r\n\r\n            if (this.keyExprsCount !== this.fieldExprs.length)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let values = expr.values;\r\n            for (let valueTuple of values) {\r\n                let jlen = valueTuple.length;\r\n                debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\r\n\r\n                for (let value of valueTuple) {\r\n                    result = value.accept(this);\r\n                    if (!result)\r\n                        return this.unsupportedSQExpr();\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): boolean {\r\n            if (this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let fixedExpr = SQExprBuilder.removeEntityVariables(expr);\r\n            if (this.keyExprsCount !== null)\r\n                return SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\r\n\r\n            return SQExpr.equals(this.fieldExprs[0], fixedExpr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): boolean {\r\n            return this.unsupportedSQExpr();\r\n        }\r\n\r\n        private unsupportedSQExpr(): boolean {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    class FindComparandVisitor extends DefaultSQExprVisitor<SQConstantExpr> {\r\n        public visitAnd(expr: SQAndExpr): SQConstantExpr {\r\n            return expr.left.accept(this) || expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQConstantExpr {\r\n            if (expr.comparison === QueryComparisonKind.Equal) {\r\n                if (expr.right instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.right;\r\n                if (expr.left instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.left;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\r\n    export module ScopeIdentityExtractor {\r\n        export function getKeys(expr: SQExpr): SQExpr[] {\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return null;\r\n\r\n            return ArrayExtensions.emptyToNull(extractor.keys);\r\n        }\r\n\r\n        export function getInExpr(expr: SQExpr): SQInExpr{\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return;\r\n            \r\n            let keys = ArrayExtensions.emptyToNull(extractor.keys);\r\n            let keyValues = ArrayExtensions.emptyToNull(extractor.values);\r\n\r\n            if (keys && keyValues)\r\n                return data.SQExprBuilder.inExpr(keys, [keyValues]);\r\n        }\r\n\r\n        /**\r\n         * Recognizes expressions of the form:\r\n         * 1) Equals(ColRef, Constant)\r\n         * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\r\n         * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\r\n         */\r\n        class ScopeIdExtractorImpl extends DefaultSQExprVisitor<void> {\r\n            public keys: SQExpr[] = [];\r\n            public values: SQConstantExpr[] = [];\r\n            public malformed: boolean;\r\n\r\n            public visitAnd(expr: SQAndExpr): void {\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): void {\r\n                if (expr.comparison !== QueryComparisonKind.Equal) {\r\n                    this.visitDefault(expr);\r\n                    return;\r\n                }\r\n                debug.assert(expr.left instanceof SQExpr && expr.right instanceof SQConstantExpr, 'invalid compare expr operands');\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): void {\r\n                this.values.push(expr);\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): void {\r\n                this.malformed = true;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module PrimitiveValueEncoding {\r\n        const SingleQuoteRegex = /'/g;\r\n\r\n        export function decimal(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'M';\r\n        }\r\n\r\n        export function double(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'D';\r\n        }\r\n\r\n        export function integer(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'L';\r\n        }\r\n\r\n        export function dateTime(value: Date): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\r\n            // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\r\n            // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\r\n            let date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\r\n            let dateTimeString = date.toISOString();\r\n\r\n            // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\r\n            // we will drop it.\r\n            // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\r\n            if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\r\n                dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\r\n            return \"datetime'\" + dateTimeString + \"'\";\r\n        }\r\n\r\n        export function text(value: string): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\r\n        }\r\n\r\n        export function nullEncoding(): string {\r\n            return 'null';\r\n        }\r\n\r\n        export function boolean(value: boolean): string {\r\n            return value ? 'true' : 'false';\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Agg = powerbi.data.QueryAggregateFunction;\r\n\r\n    export interface ISQAggregationOperations {\r\n        /** Returns an array of supported aggregates for a given expr and role type. */\r\n        getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[];\r\n\r\n        isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean;\r\n\r\n        createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr;\r\n    }\r\n\r\n    export function createSQAggregationOperations(datetimeMinMaxSupported: boolean): ISQAggregationOperations {\r\n        return new SQAggregationOperations(datetimeMinMaxSupported);\r\n    }\r\n\r\n    class SQAggregationOperations implements ISQAggregationOperations {\r\n        constructor(private datetimeMinMaxSupported: boolean) {\r\n        }\r\n\r\n        public getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[] {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertAnyValue(targetTypes, 'targetTypes');\r\n\r\n            let metadata = getMetadataForUnderlyingType(expr, schema);\r\n\r\n            // don't use expr.validate as validate will be using this function and we end up in a recursive loop\r\n            if (!metadata)\r\n                return [];\r\n\r\n            let valueType = metadata.type,\r\n                fieldKind = metadata.kind,\r\n                isPropertyIdentity = metadata.idOnEntityKey;\r\n\r\n            if (!valueType)\r\n                return [];\r\n\r\n            // Cannot aggregate on model measures\r\n            if (fieldKind === FieldKind.Measure)\r\n                return [];\r\n\r\n            if (valueType.numeric || valueType.integer) {\r\n                let aggregates = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                let currentSchema = schema.schema(fieldExprItem.schema);\r\n                if (currentSchema.capabilities.supportsMedian)\r\n                    aggregates.push(Agg.Median);\r\n\r\n                return aggregates;\r\n            }\r\n\r\n            let aggregates: QueryAggregateFunction[] = [];\r\n\r\n            // Min/Max of DateTime\r\n            if (this.datetimeMinMaxSupported &&\r\n                valueType.dateTime &&\r\n                (_.isEmpty(targetTypes) || ValueType.isCompatibleTo(valueType, targetTypes))) {\r\n                aggregates.push(Agg.Min);\r\n                aggregates.push(Agg.Max);\r\n            }\r\n\r\n            // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\r\n            // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\r\n            let distinctCountAggExists = SQExprInfo.getAggregate(expr) === Agg.Count;\r\n            if (!(isPropertyIdentity && !distinctCountAggExists))\r\n                aggregates.push(Agg.Count);\r\n\r\n            aggregates.push(Agg.CountNonNull);\r\n\r\n            return aggregates;\r\n        }\r\n\r\n        public isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\r\n            return _.contains(supportedAggregates, aggregate);\r\n        }\r\n\r\n        public createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n            if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\r\n                aggregate = preferredAggregate;\r\n            }\r\n            else {\r\n                aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\r\n            }\r\n            if (aggregate !== undefined)\r\n                expr = SQExprBuilder.aggregate(expr, aggregate);\r\n\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    function getMetadataForUnderlyingType(expr: SQExpr, schema: FederatedConceptualSchema): SQExprMetadata {\r\n        // Unwrap the aggregate (if the expr has one), and look at the underlying type.\r\n        let metadata = SQExprBuilder.removeAggregate(expr).getMetadata(schema);\r\n\r\n        if (!metadata)\r\n            metadata = expr.getMetadata(schema);\r\n\r\n        return metadata;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module SQHierarchyExprUtils {\r\n        export function getConceptualHierarchyLevelFromExpr(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            fieldExpr: FieldExprPattern): ConceptualHierarchyLevel {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            let hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\r\n            if (hierarchyLevel)\r\n                return SQHierarchyExprUtils.getConceptualHierarchyLevel(\r\n                    conceptualSchema,\r\n                    fieldExprItem.schema,\r\n                    fieldExprItem.entity,\r\n                    hierarchyLevel.name,\r\n                    hierarchyLevel.level);\r\n        }\r\n\r\n        export function getConceptualHierarchyLevel(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            schemaName: string,\r\n            entity: string,\r\n            hierarchy: string,\r\n            hierarchyLevel: string): ConceptualHierarchyLevel {\r\n\r\n            let schema = conceptualSchema.schema(schemaName);\r\n            let conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\r\n            if (conceptualHierarchy) {\r\n                return conceptualHierarchy.levels.withName(hierarchyLevel);\r\n            }\r\n        }\r\n\r\n        export function getConceptualHierarchy(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): ConceptualHierarchy {\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchy = <SQHierarchyExpr>sqExpr;\r\n\r\n                if (sqExpr.arg instanceof SQEntityExpr) {\r\n                    let entityExpr = <SQEntityExpr>sqExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(entityExpr.schema)\r\n                        .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\r\n                } else if (sqExpr.arg instanceof SQPropertyVariationSourceExpr) {\r\n                    let variationExpr = <SQPropertyVariationSourceExpr>sqExpr.arg;\r\n                    let sourceEntityExpr = <SQEntityExpr>variationExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(sourceEntityExpr.schema)\r\n                        .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function expandExpr(schema: FederatedConceptualSchema, expr: SQExpr, suppressHierarchyLevelExpansion?: boolean): SQExpr | SQExpr[] {\r\n            return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\r\n                SQExprVariationConverter.expand(expr, schema) ||\r\n                // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\r\n                (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\r\n                expr;\r\n        }\r\n\r\n        export function isHierarchyOrVariation(schema: FederatedConceptualSchema, expr: SQExpr): boolean {\r\n            if (expr instanceof SQHierarchyExpr || expr instanceof SQHierarchyLevelExpr)\r\n                return true;\r\n\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Return column reference expression for hierarchy level expression.\r\n        export function getSourceVariationExpr(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\r\n\r\n                return SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\r\n            }\r\n        }\r\n\r\n        // Return hierarchy expression for hierarchy level expression.\r\n        export function getSourceHierarchy(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQHierarchyExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            let hierarchyLevel = fieldExprPattern.hierarchyLevel;\r\n            if (hierarchyLevel) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\r\n                return SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\r\n            }\r\n        }\r\n\r\n        export function getHierarchySourceAsVariationSource(hierarchyLevelExpr: SQHierarchyLevelExpr): SQPropertyVariationSourceExpr {\r\n\r\n            // Make sure the hierarchy level source is a hierarchy\r\n            if (!(hierarchyLevelExpr.arg instanceof SQHierarchyExpr))\r\n                return;\r\n                        \r\n            // Check if the hierarchy source if a variation\r\n            let hierarchyRef = <SQHierarchyExpr>hierarchyLevelExpr.arg;\r\n            if (hierarchyRef.arg instanceof SQPropertyVariationSourceExpr)\r\n                return <SQPropertyVariationSourceExpr>hierarchyRef.arg;\r\n        }\r\n\r\n        /**\r\n        * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\r\n        */\r\n        export function areHierarchyLevelsOrdered(allLevels: SQHierarchyLevelExpr[], firstExpr: SQExpr, secondExpr: SQExpr): boolean {\r\n\r\n            // Validate that both items hierarchy levels\r\n            if (!(firstExpr instanceof SQHierarchyLevelExpr) || !(secondExpr instanceof SQHierarchyLevelExpr))\r\n                return false;\r\n\r\n            let firstLevel = <SQHierarchyLevelExpr>firstExpr;\r\n            let secondLevel = <SQHierarchyLevelExpr>secondExpr;\r\n\r\n            // Validate that both items belong to the same hierarchy\r\n            if (!SQExpr.equals(firstLevel.arg, secondLevel.arg))\r\n                return false;\r\n\r\n            // Determine the order\r\n            let firstIndex = SQExprUtils.indexOfExpr(allLevels, firstLevel);\r\n            let secondIndex = SQExprUtils.indexOfExpr(allLevels, secondLevel);\r\n\r\n            return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\r\n        }\r\n\r\n        /**\r\n         * Given an ordered set of levels and an ordered subset of those levels, returns the index where\r\n         * expr should be inserted into the subset to maintain the correct order.\r\n         */\r\n        export function getInsertionIndex(allLevels: SQHierarchyLevelExpr[], orderedSubsetOfLevels: SQHierarchyLevelExpr[], expr: SQHierarchyLevelExpr): number {\r\n\r\n            let insertIndex = 0;\r\n\r\n            // Loop through the supplied levels until the insertion would no longer be in the correct order\r\n            while (insertIndex < orderedSubsetOfLevels.length &&\r\n                areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\r\n                insertIndex++;\r\n            }\r\n\r\n            return insertIndex;\r\n        }\r\n    }\r\n\r\n    export module SQExprHierarchyToHierarchyLevelConverter {\r\n        export function convert(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(sqExpr, 'sqExpr');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchyExpr = <SQHierarchyExpr>sqExpr;\r\n\r\n                let conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\r\n                if (conceptualHierarchy)\r\n                    return _.map(conceptualHierarchy.levels, hierarchyLevel => SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name));\r\n            }\r\n        }\r\n    }\r\n\r\n    module SQExprHierarchyLevelConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n            let exprs: SQExpr[] = [];\r\n\r\n            if (expr instanceof SQHierarchyLevelExpr) {\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                if (fieldExpr.hierarchyLevel) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                    let hierarchy = schema\r\n                        .schema(fieldExprItem.schema)\r\n                        .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\r\n\r\n                    if (hierarchy) {\r\n                        let hierarchyLevels = hierarchy.levels;\r\n                        for (let hierarchyLevel of hierarchyLevels) {\r\n                            if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\r\n                                exprs.push(expr);\r\n                                break;\r\n                            }\r\n                            else\r\n                                exprs.push(\r\n                                    SQExprBuilder.hierarchyLevel(\r\n                                        SQExprBuilder.hierarchy(\r\n                                            SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                            hierarchy.name),\r\n                                        hierarchyLevel.name)\r\n                                );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return exprs;\r\n        }\r\n    }\r\n\r\n    module SQExprVariationConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n\r\n            let exprs: SQExpr[];\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0) {\r\n                    let variations = column.variations;\r\n\r\n                    // for SU11, we support only one variation\r\n                    debug.assert(variations.length === 1, \"variations.length\");\r\n                    let variation = variations[0];\r\n\r\n                    let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                    exprs = [];\r\n                    if (variation.defaultHierarchy) {\r\n                        let hierarchyExpr = SQExprBuilder.hierarchy(\r\n                            SQExprBuilder.propertyVariationSource(\r\n                                SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                variation.name, conceptualProperty.name),\r\n                            variation.defaultHierarchy.name);\r\n\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            exprs.push(SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\r\n                    }\r\n                }\r\n            }\r\n\r\n            return exprs;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    // A group can consist of either a single expression, or a collection of hierarchy expressions\r\n    export interface SQExprGroup {\r\n        expr: SQExpr;\r\n        children: SQHierarchyLevelExpr[];\r\n\r\n        /** Index of expression in the query. */\r\n        selectQueryIndex: number;\r\n    };\r\n\r\n    export module SQExprGroupUtils {\r\n        /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\r\n        export function groupExprs(schema: FederatedConceptualSchema, exprs: SQExpr[]): SQExprGroup[] {\r\n            let groups: SQExprGroup[] = [];\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i];\r\n                debug.assertValue(expr, \"Expression not found\");\r\n\r\n                if (!(expr instanceof SQHierarchyLevelExpr)) {\r\n                    groups.push({ expr: expr, children: null, selectQueryIndex: i });\r\n                }\r\n                else {\r\n                    addChildToGroup(schema, groups, expr, i);\r\n                }\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function addChildToGroup(\r\n            schema: FederatedConceptualSchema,\r\n            groups: SQExprGroup[],\r\n            expr: SQHierarchyLevelExpr,\r\n            selectQueryIndex: number): void {\r\n\r\n            // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \r\n            // a new Group or to the last Group\r\n            let shouldAddExpressionToNewGroup = true;\r\n            let exprSource = SQHierarchyExprUtils.getSourceVariationExpr(expr) || SQHierarchyExprUtils.getSourceHierarchy(expr);\r\n            let lastGroup = _.last(groups);\r\n\r\n            // The relevant group is always the last added. If it has the same source hierarchy,\r\n            // and is properly ordered within that hierarchy, we will need to add to this group.\r\n            if (lastGroup && lastGroup.children && SQExpr.equals(lastGroup.expr, exprSource)) {\r\n                let expandedExpr = SQHierarchyExprUtils.expandExpr(schema, expr.arg);\r\n                if (expandedExpr instanceof Array) {\r\n                    let allHierarchyLevels = <SQHierarchyLevelExpr[]>expandedExpr;\r\n                    shouldAddExpressionToNewGroup = !SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\r\n                }\r\n            }\r\n\r\n            if (shouldAddExpressionToNewGroup)\r\n                // Use the Sourcevariation as the expression for the group.\r\n                groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\r\n            else {\r\n                debug.assertValue(lastGroup, 'There should be a group to add the variation to');\r\n                debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\r\n                lastGroup.children.push(expr);\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    /** Represents an immutable expression within a SemanticQuery. */\r\n    export abstract class SQExpr implements ISQExpr {\r\n        private _kind: SQExprKind;\r\n\r\n        constructor(kind: SQExprKind) {\r\n            debug.assertValue(kind, 'kind');\r\n\r\n            this._kind = kind;\r\n        }\r\n\r\n        public static equals(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            return SQExprEqualityVisitor.run(x, y, ignoreCase);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.accept(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            debug.assertFail('abstract method');\r\n            return;\r\n        }\r\n\r\n        public get kind(): SQExprKind {\r\n            return this._kind;\r\n        }\r\n\r\n        public static isColumn(expr: SQExpr): expr is SQColumnRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ColumnRef;\r\n        }\r\n\r\n        public static isConstant(expr: SQExpr): expr is SQConstantExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Constant;\r\n        }\r\n\r\n        public static isEntity(expr: SQExpr): expr is SQEntityExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Entity;\r\n        }\r\n\r\n        public static isHierarchy(expr: SQExpr): expr is SQHierarchyExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Hierarchy;\r\n        }\r\n\r\n        public static isHierarchyLevel(expr: SQExpr): expr is SQHierarchyLevelExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.HierarchyLevel;\r\n        }\r\n\r\n        public static isAggregation(expr: SQExpr): expr is SQAggregationExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Aggregation;\r\n        }\r\n\r\n        public static isMeasure(expr: SQExpr): expr is SQMeasureRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.MeasureRef;\r\n        }\r\n\r\n        public static isSelectRef(expr: SQExpr): expr is SQSelectRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.SelectRef;\r\n        }\r\n\r\n        public static isResourcePackageItem(expr: SQExpr): expr is SQResourcePackageItemExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ResourcePackageItem;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            if (field.column || field.columnAggr || field.measure)\r\n                return this.getMetadataForProperty(field, federatedSchema);\r\n\r\n            if (field.hierarchyLevel || field.hierarchyLevelAggr)\r\n                return this.getMetadataForHierarchyLevel(field, federatedSchema);\r\n\r\n            if (field.columnHierarchyLevelVariation)\r\n                return this.getMetadataForVariation(field, federatedSchema);\r\n\r\n            if (field.percentOfGrandTotal)\r\n                return this.getMetadataForPercentOfGrandTotal();\r\n\r\n            return SQExpr.getMetadataForEntity(field, federatedSchema);\r\n        }\r\n\r\n        public getDefaultAggregate(federatedSchema: FederatedConceptualSchema, forceAggregation: boolean = false): QueryAggregateFunction {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n\r\n            if (property && property.kind === ConceptualPropertyKind.Column) {\r\n                let propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\r\n\r\n                if ((property.type.integer || property.type.numeric) &&\r\n                    propertyDefaultAggregate !== ConceptualDefaultAggregate.None) {\r\n                    aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\r\n                    if (aggregate === undefined)\r\n                        aggregate = defaultAggregateForDataType(property.type);\r\n                }\r\n\r\n                // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \r\n                // aggregate on CountNonNull.\r\n                if (aggregate === undefined && forceAggregation) {\r\n                    aggregate = QueryAggregateFunction.CountNonNull;\r\n                }\r\n            }\r\n\r\n            return aggregate;\r\n        }\r\n\r\n        /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\r\n        public getKeyColumns(schema: FederatedConceptualSchema): SQExpr[] {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n\r\n            let keySQExprs: SQExpr[] = [];\r\n            let keys = this.getPropertyKeys(schema);\r\n            if (keys && keys.length > 0) {\r\n                for (let i = 0, len = keys.length; i < len; i++) {\r\n                    keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\r\n                }\r\n            }\r\n            else\r\n                keySQExprs.push(columnRefExpr);\r\n\r\n            return keySQExprs;\r\n        }\r\n\r\n        /** Returns a value indicating whether the expression would group on keys other than itself.*/\r\n        public hasGroupOnKeys(schema: FederatedConceptualSchema): boolean {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n            let keys = this.getPropertyKeys(schema);\r\n\r\n            if (!keys || keys.length < 1)\r\n                return false;\r\n\r\n            if (keys.length > 1)\r\n                return true;\r\n\r\n            let keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\r\n            return !SQExpr.equals(keySqExpr, this);\r\n        }\r\n\r\n        private getPropertyKeys(schema: FederatedConceptualSchema): jsCommon.ArrayNamedItems<ConceptualProperty> {\r\n            let property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            return property.column ? property.column.keys : undefined;\r\n        }\r\n\r\n        public getConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let propertyName = FieldExprPattern.getPropertyName(field);\r\n\r\n            if (propertyName)\r\n                return federatedSchema\r\n                    .schema(fieldExprItem.schema)\r\n                    .findProperty(fieldExprItem.entity, propertyName);\r\n        }\r\n\r\n        public getTargetEntityForVariation(federatedSchema: FederatedConceptualSchema, variationName: string): string {\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (property && property.column && !_.isEmpty(property.column.variations)) {\r\n                let variations = property.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === variationName)\r\n                        return variation.navigationProperty.targetEntity.name;\r\n            }\r\n        }\r\n\r\n        public getTargetEntity(federatedSchema: FederatedConceptualSchema): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\r\n        }\r\n\r\n        private getHierarchyLevelConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\r\n            if (fieldExprHierachyLevel) {\r\n                let fieldExprEntity = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n\r\n                let hierarchy = federatedSchema\r\n                    .schema(fieldExprEntity.schema)\r\n                    .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\r\n\r\n                if (hierarchy) {\r\n                    let hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\r\n                    if (hierarchyLevel)\r\n                        return hierarchyLevel.column;\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForVariation(field: data.FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let sourceProperty = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\r\n\r\n            if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\r\n                for (let variation of sourceProperty.column.variations) {\r\n                    if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\r\n                        for (let level of variation.defaultHierarchy.levels) {\r\n                            if (level.name === columnHierarchyLevelVariation.level.level) {\r\n                                let property = level.column;\r\n                                return {\r\n                                    kind: (property.kind === ConceptualPropertyKind.Measure) ? FieldKind.Measure : FieldKind.Column,\r\n                                    type: property.type,\r\n                                    format: property.format,\r\n                                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                                    defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n                                };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForHierarchyLevel(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private getMetadataForPercentOfGrandTotal(): SQExprMetadata {\r\n            return {\r\n                kind: FieldKind.Measure,\r\n                format: '#,##0.##%',\r\n                type: ValueType.fromExtendedType(ExtendedType.Double)\r\n            };\r\n        }\r\n\r\n        private getPropertyMetadata(field: FieldExprPattern, property: ConceptualProperty): SQExprMetadata {\r\n            let format = property.format;\r\n            let type = property.type;\r\n            let columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\r\n\r\n            if (columnAggregate) {\r\n                switch (columnAggregate.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        type = ValueType.fromExtendedType(ExtendedType.Integer);\r\n                        format = undefined;\r\n                        break;\r\n                    case QueryAggregateFunction.Avg:\r\n                        if (type.integer)\r\n                            type = ValueType.fromExtendedType(ExtendedType.Double);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return {\r\n                kind: (property.kind === ConceptualPropertyKind.Measure || (columnAggregate && columnAggregate.aggregate !== undefined)) ? FieldKind.Measure : FieldKind.Column,\r\n                type: type,\r\n                format: format,\r\n                idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\r\n                defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n            };\r\n        }\r\n\r\n        private getMetadataForProperty(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private static getMetadataForEntity(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let entity = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .entities\r\n                .withName(fieldExprItem.entity);\r\n\r\n            if (!entity)\r\n                return;\r\n\r\n            // We only support count and countnonnull for entity.\r\n            if (field.entityAggr) {\r\n                switch (field.entityAggr.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        return {\r\n                            kind: FieldKind.Measure,\r\n                            type: ValueType.fromExtendedType(ExtendedType.Integer),\r\n                            format: undefined,\r\n                            idOnEntityKey: false,\r\n                            aggregate: field.entityAggr.aggregate\r\n                        };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export const enum SQExprKind {\r\n        Entity,\r\n        ColumnRef,\r\n        MeasureRef,\r\n        Aggregation,\r\n        PropertyVariationSource,\r\n        Hierarchy,\r\n        HierarchyLevel,\r\n        And,\r\n        Between,\r\n        In,\r\n        Or,\r\n        Contains,\r\n        Compare,\r\n        StartsWith,\r\n        Exists,\r\n        Not,\r\n        Constant,\r\n        DateSpan,\r\n        DateAdd,\r\n        Now,\r\n        AnyValue,\r\n        DefaultValue,\r\n        Arithmetic,\r\n        FillRule,\r\n        ResourcePackageItem,\r\n        ScopedEval,\r\n        Scope,\r\n        Percentile,\r\n        SelectRef,\r\n    }\r\n\r\n    export interface SQExprMetadata {\r\n        kind: FieldKind;\r\n        type: ValueType;\r\n        format?: string;\r\n        idOnEntityKey?: boolean;\r\n        aggregate?: QueryAggregateFunction;\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n    }\r\n\r\n    export const enum FieldKind {\r\n        /** Indicates the field references a column, which evaluates to a distinct set of values (e.g., Year, Name, SalesQuantity, etc.). */\r\n        Column,\r\n\r\n        /** Indicates the field references a measure, which evaluates to a single value (e.g., SalesYTD, Sum(Sales), etc.). */\r\n        Measure,\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateForDataType(type: ValueType): QueryAggregateFunction {\r\n        if (type.integer || type.numeric)\r\n            return QueryAggregateFunction.Sum;\r\n\r\n        return QueryAggregateFunction.Count;\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateToQueryAggregateFunction(aggregate: ConceptualDefaultAggregate): QueryAggregateFunction {\r\n        switch (aggregate) {\r\n            case ConceptualDefaultAggregate.Average:\r\n                return QueryAggregateFunction.Avg;\r\n            case ConceptualDefaultAggregate.Count:\r\n                return QueryAggregateFunction.CountNonNull;\r\n            case ConceptualDefaultAggregate.DistinctCount:\r\n                return QueryAggregateFunction.Count;\r\n            case ConceptualDefaultAggregate.Max:\r\n                return QueryAggregateFunction.Max;\r\n            case ConceptualDefaultAggregate.Min:\r\n                return QueryAggregateFunction.Min;\r\n            case ConceptualDefaultAggregate.Sum:\r\n                return QueryAggregateFunction.Sum;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    export class SQEntityExpr extends SQExpr {\r\n        public schema: string;\r\n        public entity: string;\r\n        public variable: string;\r\n\r\n        constructor(schema: string, entity: string, variable?: string) {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            super(SQExprKind.Entity);\r\n            this.schema = schema;\r\n            this.entity = entity;\r\n            if (variable)\r\n                this.variable = variable;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitEntity(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQArithmeticExpr extends SQExpr {\r\n        public left: SQExpr;\r\n        public right: SQExpr;\r\n        public operator: ArithmeticOperatorKind;\r\n\r\n        constructor(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n            debug.assertValue(operator, 'operator');\r\n\r\n            super(SQExprKind.Arithmetic);\r\n            this.left = left;\r\n            this.right = right;\r\n            this.operator = operator;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitArithmetic(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQScopedEvalExpr extends SQExpr {\r\n        public expression: SQExpr;\r\n        public scope: SQExpr[];\r\n\r\n        constructor(expression: SQExpr, scope: SQExpr[]) {\r\n            debug.assertValue(expression, 'expression');\r\n            debug.assertValue(scope, 'scope');\r\n\r\n            super(SQExprKind.ScopedEval);\r\n            this.expression = expression;\r\n            this.scope = scope;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitScopedEval(this, arg);\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            return this.expression.getMetadata(federatedSchema);\r\n        }\r\n    }\r\n\r\n    export abstract class SQPropRefExpr extends SQExpr {\r\n        public ref: string;\r\n        public source: SQExpr;\r\n\r\n        constructor(kind: SQExprKind, source: SQExpr, ref: string) {\r\n            debug.assertValue(kind, 'kind');\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            super(kind);\r\n            this.source = source;\r\n            this.ref = ref;\r\n        }\r\n    }\r\n\r\n    export class SQColumnRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.ColumnRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitColumnRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQMeasureRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.MeasureRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitMeasureRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAggregationExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public func: QueryAggregateFunction;\r\n\r\n        constructor(arg: SQExpr, func: QueryAggregateFunction) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(func, 'func');\r\n\r\n            super(SQExprKind.Aggregation);\r\n            this.arg = arg;\r\n            this.func = func;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAggr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPercentileExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public k: number;\r\n        public exclusive: boolean;\r\n\r\n        constructor(arg: SQExpr, k: number, exclusive: boolean) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(k, 'k');\r\n            debug.assert(0 <= k && k <= 1, '0 <= k && k <= 1');\r\n            debug.assertValue(exclusive, 'exclusive');\r\n\r\n            super(SQExprKind.Percentile);\r\n            this.arg = arg;\r\n            this.k = k;\r\n            this.exclusive = exclusive;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let argMetadata = this.arg.getMetadata(federatedSchema);\r\n            if (argMetadata) {\r\n                return {\r\n                    kind: FieldKind.Measure,\r\n                    type: argMetadata.type,\r\n                };\r\n            }\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPercentile(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPropertyVariationSourceExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public name: string;\r\n        public property: string;\r\n\r\n        constructor(arg: SQExpr, name: string, property: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(name, 'name');\r\n            debug.assertValue(property, 'property');\r\n\r\n            super(SQExprKind.PropertyVariationSource);\r\n            this.arg = arg;\r\n            this.name = name;\r\n            this.property = property;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPropertyVariationSource(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public hierarchy: string;\r\n\r\n        constructor(arg: SQExpr, hierarchy: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n\r\n            super(SQExprKind.Hierarchy);\r\n            this.arg = arg;\r\n            this.hierarchy = hierarchy;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchy(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyLevelExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public level: string;\r\n\r\n        constructor(arg: SQExpr, level: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(level, 'level');\r\n\r\n            super(SQExprKind.HierarchyLevel);\r\n            this.arg = arg;\r\n            this.level = level;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchyLevel(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQSelectRefExpr extends SQExpr {\r\n        public expressionName: string;\r\n\r\n        constructor(expressionName: string) {\r\n            debug.assertValue(expressionName, 'arg');\r\n\r\n            super(SQExprKind.SelectRef);\r\n            this.expressionName = expressionName;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitSelectRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAndExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.And);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQBetweenExpr extends SQExpr {\r\n        arg: SQExpr;\r\n        lower: SQExpr;\r\n        upper: SQExpr;\r\n\r\n        constructor(arg: SQExpr, lower: SQExpr, upper: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(lower, 'lower');\r\n            debug.assertValue(upper, 'upper');\r\n\r\n            super(SQExprKind.Between);\r\n            this.arg = arg;\r\n            this.lower = lower;\r\n            this.upper = upper;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitBetween(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQInExpr extends SQExpr {\r\n        args: SQExpr[];\r\n        values: SQExpr[][];\r\n\r\n        constructor(args: SQExpr[], values: SQExpr[][]) {\r\n            debug.assertValue(args, 'args');\r\n            debug.assertValue(values, 'values');\r\n\r\n            super(SQExprKind.In);\r\n            this.args = args;\r\n            this.values = values;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitIn(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQOrExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Or);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitOr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQCompareExpr extends SQExpr {\r\n        comparison: QueryComparisonKind;\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(comparison: QueryComparisonKind, left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(comparison, 'kind');\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Compare);\r\n            this.comparison = comparison;\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitCompare(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQContainsExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Contains);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitContains(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQStartsWithExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.StartsWith);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitStartsWith(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQExistsExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Exists);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitExists(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNotExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Not);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNot(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQConstantExpr extends SQExpr implements ISQConstantExpr {\r\n        public type: ValueType;\r\n\r\n        /** The native JavaScript representation of the value. */\r\n        public value: any;\r\n\r\n        /** The string encoded, lossless representation of the value. */\r\n        public valueEncoded: string;\r\n\r\n        constructor(type: ValueType, value: any, valueEncoded: string) {\r\n            debug.assertValue(type, 'type');\r\n\r\n            super(SQExprKind.Constant);\r\n            this.type = type;\r\n            this.value = value;\r\n            this.valueEncoded = valueEncoded;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitConstant(this, arg);\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            return {\r\n                // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\r\n                // A getType or similiar function in the future would be more appropriate. \r\n                kind: FieldKind.Measure,\r\n                type: this.type,\r\n            };\r\n        }\r\n    }\r\n\r\n    export class SQDateSpanExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateSpan);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateSpan(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDateAddExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public amount: number;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, amount: number, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(amount, 'amount');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateAdd);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n            this.amount = amount;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateAdd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNowExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.Now);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNow(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDefaultValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.DefaultValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDefaultValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAnyValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.AnyValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnyValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQFillRuleExpr extends SQExpr {\r\n        public input: SQExpr;\r\n        public rule: FillRuleDefinition;\r\n\r\n        constructor(\r\n            input: SQExpr,\r\n            fillRule: FillRuleDefinition) {\r\n            debug.assertValue(input, 'input');\r\n            debug.assertValue(fillRule, 'fillRule');\r\n\r\n            super(SQExprKind.FillRule);\r\n            this.input = input;\r\n            this.rule = fillRule;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitFillRule(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQResourcePackageItemExpr extends SQExpr {\r\n        public packageName: string;\r\n        public packageType: number;\r\n        public itemName: string;\r\n\r\n        constructor(packageName: string, packageType: number, itemName: string) {\r\n            debug.assertValue(packageName, 'packageName');\r\n            debug.assertValue(itemName, 'itemName');\r\n\r\n            super(SQExprKind.ResourcePackageItem);\r\n            this.packageName = packageName;\r\n            this.packageType = packageType;\r\n            this.itemName = itemName;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitResourcePackageItem(this, arg);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for creating & manipulating expressions. */\r\n    export module SQExprBuilder {\r\n        export function entity(schema: string, entity: string, variable?: string): SQEntityExpr {\r\n            return new SQEntityExpr(schema, entity, variable);\r\n        }\r\n\r\n        export function columnRef(source: SQExpr, prop: string): SQColumnRefExpr {\r\n            return new SQColumnRefExpr(source, prop);\r\n        }\r\n\r\n        export function measureRef(source: SQExpr, prop: string): SQMeasureRefExpr {\r\n            return new SQMeasureRefExpr(source, prop);\r\n        }\r\n\r\n        export function aggregate(source: SQExpr, aggregate: QueryAggregateFunction): SQAggregationExpr {\r\n            return new SQAggregationExpr(source, aggregate);\r\n        }\r\n\r\n        export function selectRef(expressionName: string): SQSelectRefExpr {\r\n            return new SQSelectRefExpr(expressionName);\r\n        }\r\n\r\n        export function percentile(source: SQExpr, k: number, exclusive: boolean): SQPercentileExpr {\r\n            return new SQPercentileExpr(source, k, exclusive);\r\n        }\r\n\r\n        export function arithmetic(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind): SQArithmeticExpr {\r\n            return new SQArithmeticExpr(left, right, operator);\r\n        }\r\n\r\n        export function scopedEval(expression: SQExpr, scope: SQExpr[]): SQScopedEvalExpr {\r\n            return new SQScopedEvalExpr(expression, scope);\r\n        }\r\n\r\n        export function hierarchy(source: SQExpr, hierarchy: string): SQHierarchyExpr {\r\n            return new SQHierarchyExpr(source, hierarchy);\r\n        }\r\n\r\n        export function propertyVariationSource(source: SQExpr, name: string, property: string): SQPropertyVariationSourceExpr {\r\n            return new SQPropertyVariationSourceExpr(source, name, property);\r\n        }\r\n\r\n        export function hierarchyLevel(source: SQExpr, level: string): SQHierarchyLevelExpr {\r\n            return new SQHierarchyLevelExpr(source, level);\r\n        }\r\n\r\n        export function and(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n\r\n            return new SQAndExpr(left, right);\r\n        }\r\n\r\n        export function between(arg: SQExpr, lower: SQExpr, upper: SQExpr): SQBetweenExpr {\r\n            return new SQBetweenExpr(arg, lower, upper);\r\n        }\r\n\r\n        export function inExpr(args: SQExpr[], values: SQExpr[][]): SQInExpr {\r\n            return new SQInExpr(args, values);\r\n        }\r\n\r\n        export function or(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n            if (left instanceof SQInExpr && right instanceof SQInExpr) {\r\n                let inExpr = tryUseInExprs(<SQInExpr>left, <SQInExpr>right);\r\n                if (inExpr)\r\n                    return inExpr;\r\n            }\r\n\r\n            return new SQOrExpr(left, right);\r\n        }\r\n\r\n        function tryUseInExprs(left: SQInExpr, right: SQInExpr): SQInExpr {\r\n            if (!left.args || !right.args)\r\n                return;\r\n\r\n            let leftArgLen = left.args.length;\r\n            let rightArgLen = right.args.length;\r\n            if (leftArgLen !== rightArgLen)\r\n                return;\r\n\r\n            for (let i = 0; i < leftArgLen; ++i) {\r\n                if (!SQExpr.equals(left.args[i], right.args[i]))\r\n                    return;\r\n            }\r\n\r\n            let combinedValues = left.values.concat(right.values);\r\n            return SQExprBuilder.inExpr(left.args, combinedValues);\r\n        }\r\n\r\n        export function compare(kind: QueryComparisonKind, left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return new SQCompareExpr(kind, left, right);\r\n        }\r\n\r\n        export function contains(left: SQExpr, right: SQExpr): SQContainsExpr {\r\n            return new SQContainsExpr(left, right);\r\n        }\r\n\r\n        export function exists(arg: SQExpr): SQExistsExpr {\r\n            return new SQExistsExpr(arg);\r\n        }\r\n\r\n        export function equal(left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return compare(QueryComparisonKind.Equal, left, right);\r\n        }\r\n\r\n        export function not(arg: SQExpr): SQNotExpr {\r\n            return new SQNotExpr(arg);\r\n        }\r\n\r\n        export function startsWith(left: SQExpr, right: SQExpr): SQStartsWithExpr {\r\n            return new SQStartsWithExpr(left, right);\r\n        }\r\n\r\n        export function nullConstant(): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Null),\r\n                null,\r\n                PrimitiveValueEncoding.nullEncoding());\r\n        }\r\n\r\n        export function now(): SQNowExpr {\r\n            return new SQNowExpr();\r\n        }\r\n\r\n        export function defaultValue(): SQDefaultValueExpr {\r\n            return new SQDefaultValueExpr();\r\n        }\r\n\r\n        export function anyValue(): SQAnyValueExpr {\r\n            return new SQAnyValueExpr();\r\n        }\r\n\r\n        export function boolean(value: boolean): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Boolean),\r\n                value,\r\n                PrimitiveValueEncoding.boolean(value));\r\n        }\r\n\r\n        export function dateAdd(unit: TimeUnit, amount: number, arg: SQExpr): SQDateAddExpr {\r\n            return new SQDateAddExpr(unit, amount, arg);\r\n        }\r\n\r\n        export function dateTime(value: Date, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.dateTime(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.DateTime), value, valueEncoded);\r\n        }\r\n\r\n        export function dateSpan(unit: TimeUnit, arg: SQExpr): SQDateSpanExpr {\r\n            return new SQDateSpanExpr(unit, arg);\r\n        }\r\n\r\n        export function decimal(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.decimal(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Decimal), value, valueEncoded);\r\n        }\r\n\r\n        export function double(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.double(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Double), value, valueEncoded);\r\n        }\r\n\r\n        export function integer(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.integer(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Integer), value, valueEncoded);\r\n        }\r\n\r\n        export function text(value: string, valueEncoded?: string): SQConstantExpr {\r\n            debug.assert(!valueEncoded || valueEncoded === PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\r\n\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Text),\r\n                value,\r\n                valueEncoded || PrimitiveValueEncoding.text(value));\r\n        }\r\n\r\n        /** Returns an SQExpr that evaluates to the constant value. */\r\n        export function typedConstant(value: PrimitiveValue, type: ValueTypeDescriptor): SQConstantExpr {\r\n            if (value == null)\r\n                return nullConstant();\r\n\r\n            if (_.isBoolean(value)) {\r\n                return boolean(<boolean>value);\r\n            }\r\n\r\n            if (_.isString(value)) {\r\n                return text(<string>value);\r\n            }\r\n\r\n            if (_.isNumber(value)) {\r\n                if (type.integer && Double.isInteger(<number>value))\r\n                    return integer(<number>value);\r\n\r\n                return double(<number>value);\r\n            }\r\n\r\n            if (value instanceof Date) {\r\n                return dateTime(value);\r\n            }\r\n        }\r\n\r\n        export function setAggregate(expr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return FieldExprChangeAggregateRewriter.rewrite(expr, aggregate);\r\n        }\r\n\r\n        export function removeAggregate(expr: SQExpr): SQExpr {\r\n            return FieldExprRemoveAggregateRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function setPercentOfGrandTotal(expr: SQExpr): SQExpr {\r\n            return SQExprSetPercentOfGrandTotalRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removePercentOfGrandTotal(expr: SQExpr): SQExpr {\r\n            return SQExprRemovePercentOfGrandTotalRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removeEntityVariables(expr: SQExpr): SQExpr {\r\n            return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function fillRule(expr: SQExpr, rule: FillRuleDefinition): SQFillRuleExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(rule, 'rule');\r\n\r\n            return new SQFillRuleExpr(expr, rule);\r\n        }\r\n\r\n        export function resourcePackageItem(packageName: string, packageType: number, itemName: string): SQResourcePackageItemExpr {\r\n            return new SQResourcePackageItemExpr(packageName, packageType, itemName);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for obtaining information about expressions. */\r\n    export module SQExprInfo {\r\n        export function getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            return SQExprAggregateInfoVisitor.getAggregate(expr);\r\n        }\r\n    }\r\n\r\n    class SQExprEqualityVisitor implements ISQExprVisitorWithArg<boolean, SQExpr>, IFillRuleDefinitionVisitor<boolean, boolean> {\r\n        private static instance: SQExprEqualityVisitor = new SQExprEqualityVisitor(/* ignoreCase */ false);\r\n        private static ignoreCaseInstance: SQExprEqualityVisitor = new SQExprEqualityVisitor(true);\r\n        private ignoreCase: boolean;\r\n\r\n        public static run(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n            if (ignoreCase)\r\n                return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\r\n\r\n            return x.accept(SQExprEqualityVisitor.instance, y);\r\n        }\r\n\r\n        constructor(ignoreCase: boolean) {\r\n            this.ignoreCase = ignoreCase;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, comparand: SQColumnRefExpr): boolean {\r\n            return comparand instanceof SQColumnRefExpr &&\r\n                expr.ref === (<SQColumnRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQColumnRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, comparand: SQMeasureRefExpr): boolean {\r\n            return comparand instanceof SQMeasureRefExpr &&\r\n                expr.ref === (<SQMeasureRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQMeasureRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAggregationExpr &&\r\n                expr.func === (<SQAggregationExpr>comparand).func &&\r\n                this.equals(expr.arg, (<SQAggregationExpr>comparand).arg);\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQPercentileExpr &&\r\n                expr.exclusive === comparand.exclusive &&\r\n                expr.k === comparand.k &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, comparand: SQHierarchyExpr): boolean {\r\n            return comparand instanceof SQHierarchyExpr &&\r\n                expr.hierarchy === comparand.hierarchy &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, comparand: SQHierarchyLevelExpr): boolean {\r\n            return comparand instanceof SQHierarchyLevelExpr &&\r\n                expr.level === comparand.level &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, comparand: SQPropertyVariationSourceExpr): boolean {\r\n            return comparand instanceof SQPropertyVariationSourceExpr &&\r\n                expr.name === comparand.name &&\r\n                expr.property === comparand.property &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitSelectRef(expr: SQSelectRefExpr, comparand: SQSelectRefExpr): boolean {\r\n            return comparand instanceof SQSelectRefExpr &&\r\n                expr.expressionName === comparand.expressionName;\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQBetweenExpr &&\r\n                this.equals(expr.arg, (<SQBetweenExpr>comparand).arg) &&\r\n                this.equals(expr.lower, (<SQBetweenExpr>comparand).lower) &&\r\n                this.equals(expr.upper, (<SQBetweenExpr>comparand).upper);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, comparand: SQExpr): boolean {\r\n            if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, (<SQInExpr>comparand).args))\r\n                return false;\r\n\r\n            let values = expr.values,\r\n                compareValues = (<SQInExpr>comparand).values;\r\n            if (values.length !== compareValues.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                if (!this.equalsAll(values[i], compareValues[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQEntityExpr &&\r\n                expr.schema === (<SQEntityExpr>comparand).schema &&\r\n                expr.entity === (<SQEntityExpr>comparand).entity &&\r\n                this.optionalEqual(expr.variable, (<SQEntityExpr>comparand).variable);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAndExpr &&\r\n                this.equals(expr.left, (<SQAndExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQAndExpr>comparand).right);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQOrExpr &&\r\n                this.equals(expr.left, (<SQOrExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQOrExpr>comparand).right);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQCompareExpr &&\r\n                expr.comparison === (<SQCompareExpr>comparand).comparison &&\r\n                this.equals(expr.left, (<SQCompareExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQCompareExpr>comparand).right);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQContainsExpr &&\r\n                this.equals(expr.left, (<SQContainsExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQContainsExpr>comparand).right);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateSpanExpr &&\r\n                expr.unit === (<SQDateSpanExpr>comparand).unit &&\r\n                this.equals(expr.arg, (<SQDateSpanExpr>comparand).arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateAddExpr &&\r\n                expr.unit === (<SQDateAddExpr>comparand).unit &&\r\n                expr.amount === (<SQDateAddExpr>comparand).amount &&\r\n                this.equals(expr.arg, (<SQDateAddExpr>comparand).arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQExistsExpr &&\r\n                this.equals(expr.arg, (<SQExistsExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNotExpr &&\r\n                this.equals(expr.arg, (<SQNotExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNowExpr;\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDefaultValueExpr;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAnyValueExpr;\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQResourcePackageItemExpr &&\r\n                expr.packageName === comparand.packageName &&\r\n                expr.packageType === comparand.packageType &&\r\n                expr.itemName === comparand.itemName;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQStartsWithExpr &&\r\n                this.equals(expr.left, (<SQStartsWithExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQStartsWithExpr>comparand).right);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQConstantExpr && expr.type === (<SQConstantExpr>comparand).type)\r\n                return expr.type.text && this.ignoreCase ?\r\n                    StringExtensions.equalIgnoreCase(expr.valueEncoded, (<SQConstantExpr>comparand).valueEncoded) :\r\n                    expr.valueEncoded === (<SQConstantExpr>comparand).valueEncoded;\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\r\n                let leftRule = expr.rule,\r\n                    rightRule = comparand.rule;\r\n\r\n                if (leftRule === rightRule)\r\n                    return true;\r\n\r\n                let leftLinearGradient2 = leftRule.linearGradient2,\r\n                    rightLinearGradient2 = rightRule.linearGradient2;\r\n                if (leftLinearGradient2 && rightLinearGradient2) {\r\n                    return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\r\n                }\r\n\r\n                let leftLinearGradient3 = leftRule.linearGradient3,\r\n                    rightLinearGradient3 = rightRule.linearGradient3;\r\n                if (leftLinearGradient3 && rightLinearGradient3) {\r\n                    return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitLinearGradient2(left2: LinearGradient2Definition, right2: LinearGradient2Definition): boolean {\r\n            debug.assertValue(left2, 'left2');\r\n            debug.assertValue(right2, 'right2');\r\n\r\n            return this.equalsFillRuleStop(left2.min, right2.min) &&\r\n                this.equalsFillRuleStop(left2.max, right2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(left3: LinearGradient3Definition, right3: LinearGradient3Definition): boolean {\r\n            debug.assertValue(left3, 'left3');\r\n            debug.assertValue(right3, 'right3');\r\n\r\n            return this.equalsFillRuleStop(left3.min, right3.min) &&\r\n                this.equalsFillRuleStop(left3.mid, right3.mid) &&\r\n                this.equalsFillRuleStop(left3.max, right3.max);\r\n        }\r\n\r\n        private equalsFillRuleStop(stop1: RuleColorStopDefinition, stop2: RuleColorStopDefinition): boolean {\r\n            debug.assertValue(stop1, 'stop1');\r\n            debug.assertValue(stop2, 'stop2');\r\n\r\n            if (!this.equals(stop1.color, stop2.color))\r\n                return false;\r\n\r\n            if (!stop1.value)\r\n                return stop1.value === stop2.value;\r\n\r\n            return this.equals(stop1.value, stop2.value);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQArithmeticExpr &&\r\n                expr.operator === (<SQArithmeticExpr>comparand).operator &&\r\n                this.equals(expr.left, (<SQArithmeticExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQArithmeticExpr>comparand).right);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQScopedEvalExpr &&\r\n                this.equals(expr.expression, comparand.expression) &&\r\n                this.equalsAll(expr.scope, comparand.scope);\r\n        }\r\n\r\n        private optionalEqual(x: string, y: string) {\r\n            // Only check equality if both values are specified.\r\n            if (x && y)\r\n                return x === y;\r\n\r\n            return true;\r\n        }\r\n\r\n        private equals(x: SQExpr, y: SQExpr): boolean {\r\n            return x.accept(this, y);\r\n        }\r\n\r\n        private equalsAll(x: SQExpr[], y: SQExpr[]): boolean {\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!this.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /** Rewrites a root-level expression. */\r\n    class SQExprRootRewriter extends DefaultSQExprVisitor<SQExpr> {\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    export const enum SQExprValidationError {\r\n        invalidAggregateFunction,\r\n        invalidSchemaReference,\r\n        invalidEntityReference,\r\n        invalidColumnReference,\r\n        invalidMeasureReference,\r\n        invalidHierarchyReference,\r\n        invalidHierarchyLevelReference,\r\n        invalidLeftOperandType,\r\n        invalidRightOperandType,\r\n        invalidValueType,\r\n        invalidPercentileArgument,\r\n    }\r\n\r\n    export class SQExprValidationVisitor extends SQExprRewriter {\r\n        public errors: SQExprValidationError[];\r\n        private schema: FederatedConceptualSchema;\r\n        private aggrUtils: ISQAggregationOperations;\r\n\r\n        constructor(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]) {\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertValue(aggrUtils, 'aggrUtils');\r\n\r\n            super();\r\n            this.schema = schema;\r\n            this.aggrUtils = aggrUtils;\r\n            if (errors)\r\n                this.errors = errors;\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): SQExpr {\r\n            let inExpr = <SQInExpr>super.visitIn(expr);\r\n            let args = inExpr.args;\r\n            let values = inExpr.values;\r\n            for (let valueTuple of values) {\r\n                debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\r\n                for (let i = 0, len = valueTuple.length; i < len; ++i)\r\n                    this.validateCompatibleType(args[i], valueTuple[i]);\r\n            }\r\n\r\n            return inExpr;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQExpr {\r\n            let compareExpr = <SQCompareExpr>super.visitCompare(expr);\r\n            this.validateCompatibleType(compareExpr.left, compareExpr.right);\r\n\r\n            return compareExpr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.column.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Column ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidColumnReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.measure.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Measure ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidMeasureReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let aggregateExpr = <SQAggregationExpr>super.visitAggr(expr);\r\n\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\r\n            if (columnRefExpr) {\r\n                if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/null))\r\n                    this.register(SQExprValidationError.invalidAggregateFunction);\r\n            }\r\n\r\n            return aggregateExpr;\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem: FieldExprHierarchyPattern = <FieldExprHierarchyPattern>fieldExpr.hierarchy;\r\n                if (fieldExprItem) {\r\n                    this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\r\n                } else {\r\n                    this.register(SQExprValidationError.invalidHierarchyReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let hierarchyLevelFieldExprItem: FieldExprHierarchyLevelPattern = <FieldExprHierarchyLevelPattern>fieldExpr.hierarchyLevel;\r\n                if (hierarchyLevelFieldExprItem) {\r\n                    this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\r\n                } else if (!fieldExpr.columnHierarchyLevelVariation) {\r\n                    this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): SQExpr {\r\n            expr.arg.accept(this);\r\n\r\n            if (_.isEmpty(this.errors)) {\r\n                let argMetadata = expr.arg.getMetadata(this.schema);\r\n                if (!argMetadata ||\r\n                    argMetadata.kind !== FieldKind.Column ||\r\n                    !(argMetadata.type && (argMetadata.type.integer || argMetadata.type.numeric))) {\r\n                    this.register(SQExprValidationError.invalidPercentileArgument);\r\n                }\r\n            }\r\n\r\n            return expr;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            this.validateEntity(expr.schema, expr.entity);\r\n            return expr;\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): SQExpr {\r\n            this.validateArithmeticTypes(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): SQExpr {\r\n            // No validation necessary\r\n            return expr;\r\n        }\r\n\r\n        private validateOperandsAndTypeForStartOrContains(left: SQExpr, right: SQExpr): void {\r\n            if (left instanceof SQColumnRefExpr) {\r\n                this.visitColumnRef(<SQColumnRefExpr>left);\r\n            } else if (left instanceof SQHierarchyLevelExpr) {\r\n                this.visitHierarchyLevel(<SQHierarchyLevelExpr>left);\r\n            } else {\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            }\r\n\r\n            if (!(right instanceof SQConstantExpr) || !(<SQConstantExpr>right).type.text)\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n            else\r\n                this.validateCompatibleType(left, right);\r\n        }\r\n\r\n        private validateArithmeticTypes(left: SQExpr, right: SQExpr): void {\r\n            if (!SQExprUtils.supportsArithmetic(left, this.schema))\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            if (!SQExprUtils.supportsArithmetic(right, this.schema))\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n        }\r\n\r\n        private validateCompatibleType(left: SQExpr, right: SQExpr): void {\r\n            let leftMetadata = left.getMetadata(this.schema),\r\n                leftType = leftMetadata && leftMetadata.type,\r\n                rightMetadata = right.getMetadata(this.schema),\r\n                rightType = rightMetadata && rightMetadata.type;\r\n\r\n            if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\r\n                this.register(SQExprValidationError.invalidValueType);\r\n        }\r\n\r\n        private validateEntity(schemaName: string, entityName: string): ConceptualEntity {\r\n            let schema = this.schema.schema(schemaName);\r\n            if (schema) {\r\n                let entity = schema.entities.withName(entityName);\r\n                if (entity)\r\n                    return entity;\r\n\r\n                this.register(SQExprValidationError.invalidEntityReference);\r\n            }\r\n            else {\r\n                this.register(SQExprValidationError.invalidSchemaReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchy(schemaName: string, entityName: string, hierarchyName: string): ConceptualHierarchy {\r\n            let entity = this.validateEntity(schemaName, entityName);\r\n            if (entity) {\r\n                let hierarchy = entity.hierarchies.withName(hierarchyName);\r\n                if (hierarchy)\r\n                    return hierarchy;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchyLevel(schemaName: string, entityName: string, hierarchyName: string, levelName: string): ConceptualHierarchyLevel {\r\n            let hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\r\n            if (hierarchy) {\r\n                let hierarchyLevel = hierarchy.levels.withName(levelName);\r\n                if (hierarchyLevel)\r\n                    return hierarchyLevel;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n            }\r\n        }\r\n\r\n        private register(error: SQExprValidationError) {\r\n            if (!this.errors)\r\n                this.errors = [];\r\n            this.errors.push(error);\r\n        }\r\n\r\n        private isQueryable(fieldExpr: FieldExprPattern): boolean {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\r\n                let hierarchyLevelConceptualProperty = SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\r\n                return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== ConceptualQueryableState.Error;\r\n            }\r\n\r\n            return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, FieldExprPattern.getPropertyName(fieldExpr)).queryable !== ConceptualQueryableState.Error;\r\n        }\r\n    }\r\n\r\n    /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\r\n    class SQExprAggregateInfoVisitor extends DefaultSQExprVisitor<QueryAggregateFunction> {\r\n        public visitAggr(expr: SQAggregationExpr): QueryAggregateFunction {\r\n            return expr.func;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): QueryAggregateFunction {\r\n            return;\r\n        }\r\n\r\n        public static getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            let visitor = new SQExprAggregateInfoVisitor();\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQExprColumnRef expression or undefined.*/\r\n    class SQExprColumnRefInfoVisitor extends DefaultSQExprVisitor<SQColumnRefExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQColumnRefExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let ref: string = expr.level;\r\n            let hierarchy = <SQHierarchyExpr>(expr.arg);\r\n            let sourceExpr: SQColumnRefExpr = hierarchy.accept(this);\r\n\r\n            if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\r\n                let propertyVariationSource = <SQPropertyVariationSourceExpr>hierarchy.arg;\r\n                let targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\r\n\r\n                if (sourceExpr && targetEntity) {\r\n                    let schemaName = (<SQEntityExpr>(sourceExpr.source)).schema;\r\n                    let targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\r\n                    let schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\r\n\r\n                    if (schemaHierarchy) {\r\n                        for (let level of schemaHierarchy.levels)\r\n                            if (level.name === ref)\r\n                                return new SQColumnRefExpr(targetEntityExpr, level.column.name);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let entityExpr = <SQEntityExpr>(hierarchy.arg);\r\n                let hierarchyLevelRef = SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema,\r\n                    entityExpr.schema,\r\n                    entityExpr.entity,\r\n                    hierarchy.hierarchy,\r\n                    expr.level);\r\n\r\n                if (hierarchyLevelRef)\r\n                    return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\r\n            }\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQColumnRefExpr {\r\n            let propertyName = expr.property;\r\n            return new SQColumnRefExpr(expr.arg, propertyName);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQColumnRefExpr {\r\n            return;\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQEntityExpr expression or undefined.*/\r\n    class SQEntityExprInfoVisitor extends DefaultSQExprVisitor<SQEntityExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQEntityExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntity(expr);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQEntityExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQEntityExpr {\r\n            return expr.source.accept(this);\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n\r\n        public static getEntity(columnRef: SQColumnRefExpr): SQEntityExpr {\r\n            let field = SQExprConverter.asFieldPattern(columnRef);\r\n            let column = field.column;\r\n            return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\r\n        }\r\n\r\n        public static getEntityExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQEntityExpr {\r\n            let visitor = new SQEntityExprInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    class SQExprChangeAggregateRewriter extends SQExprRootRewriter {\r\n        private func: QueryAggregateFunction;\r\n\r\n        constructor(func: QueryAggregateFunction) {\r\n            debug.assertValue(func, 'func');\r\n\r\n            super();\r\n            this.func = func;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            if (expr.func === this.func)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(expr.arg, this.func);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            return new SQAggregationExpr(expr, this.func);\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, func: QueryAggregateFunction): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(func, 'func');\r\n\r\n            let rewriter = new SQExprChangeAggregateRewriter(func);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    class FieldExprChangeAggregateRewriter implements IFieldExprPatternVisitor<SQExpr> {\r\n        private sqExpr: SQExpr;\r\n        private aggregate: QueryAggregateFunction;\r\n\r\n        constructor(sqExpr: SQExpr, aggregate: QueryAggregateFunction) {\r\n            this.sqExpr = sqExpr;\r\n            this.aggregate = aggregate;\r\n        }\r\n\r\n        public static rewrite(sqExpr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return FieldExprPattern.visit(sqExpr, new FieldExprChangeAggregateRewriter(sqExpr, aggregate));\r\n        }\r\n\r\n        public visitPercentOfGrandTotal(pattern: FieldExprPercentOfGrandTotalPattern): SQExpr {\r\n            pattern.baseExpr = SQExprConverter.asFieldPattern(\r\n                SQExprChangeAggregateRewriter.rewrite(\r\n                    SQExprBuilder.fieldExpr(pattern.baseExpr),\r\n                    this.aggregate));\r\n            return SQExprBuilder.fieldExpr({ percentOfGrandTotal: pattern });\r\n        }\r\n\r\n        public visitColumn(column: FieldExprColumnPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitSelectRef(selectRef: FieldExprSelectRefPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntity(entity: FieldExprEntityPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchy(hierarchy: FieldExprHierarchyPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitMeasure(measure: FieldExprMeasurePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitPercentile(percentile: FieldExprPercentilePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        private defaultRewrite(): SQExpr {\r\n            return SQExprChangeAggregateRewriter.rewrite(this.sqExpr, this.aggregate);\r\n        }\r\n    }\r\n\r\n    class FieldExprRemoveAggregateRewriter implements IFieldExprPatternVisitor<SQExpr> {\r\n\r\n        constructor(private sqExpr: SQExpr) {\r\n        }\r\n\r\n        public static rewrite(sqExpr: SQExpr): SQExpr {\r\n            return FieldExprPattern.visit(sqExpr, new FieldExprRemoveAggregateRewriter(sqExpr));\r\n        }\r\n\r\n        public visitPercentOfGrandTotal(pattern: FieldExprPercentOfGrandTotalPattern): SQExpr {\r\n            return FieldExprRemoveAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr));\r\n        }\r\n\r\n        public visitColumn(column: FieldExprColumnPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitSelectRef(selectRef: FieldExprSelectRefPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntity(entity: FieldExprEntityPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchy(hierarchy: FieldExprHierarchyPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitMeasure(measure: FieldExprMeasurePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitPercentile(percentile: FieldExprPercentilePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        private defaultRewrite(): SQExpr {\r\n            return SQExprRemoveAggregateRewriter.rewrite(this.sqExpr);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveAggregateRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemoveAggregateRewriter = new SQExprRemoveAggregateRewriter();\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            return expr.arg;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveAggregateRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveEntityVariablesRewriter extends SQExprRewriter {\r\n        private static instance: SQExprRemoveEntityVariablesRewriter = new SQExprRemoveEntityVariablesRewriter();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            if (expr.variable)\r\n                return SQExprBuilder.entity(expr.schema, expr.entity);\r\n\r\n            return expr;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemovePercentOfGrandTotalRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemovePercentOfGrandTotalRewriter = new SQExprRemovePercentOfGrandTotalRewriter();\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            return expr.accept(SQExprRemovePercentOfGrandTotalRewriter.instance);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr && fieldExpr.percentOfGrandTotal)\r\n                expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfGrandTotal.baseExpr);\r\n\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    class SQExprSetPercentOfGrandTotalRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprSetPercentOfGrandTotalRewriter = new SQExprSetPercentOfGrandTotalRewriter();\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            return expr.accept(SQExprSetPercentOfGrandTotalRewriter.instance);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr && !fieldExpr.percentOfGrandTotal)\r\n                expr = SQExprBuilder.fieldExpr({ percentOfGrandTotal: { baseExpr: SQExprConverter.asFieldPattern(expr) } });\r\n\r\n            return expr;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import ConceptualEntity = powerbi.data.ConceptualEntity;\r\n    import ConceptualMultiplicity = powerbi.data.ConceptualMultiplicity;\r\n    import SQEntityExpr = powerbi.data.SQEntityExpr;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    export module SQExprUtils {\r\n        export function supportsArithmetic(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let metadata = expr.getMetadata(schema),\r\n                type = metadata && metadata.type;\r\n\r\n            if (!metadata || !type) {\r\n                return false;\r\n            }\r\n            \r\n            return type.numeric || type.dateTime || type.duration;\r\n        }\r\n\r\n        export function indexOfExpr(items: SQExpr[], searchElement: SQExpr): number {\r\n            debug.assertValue(items, 'items');\r\n            debug.assertValue(searchElement, 'searchElement');\r\n\r\n            for (let i = 0, len = items.length; i < len; i++) {\r\n                if (SQExpr.equals(items[i], searchElement))\r\n                    return i;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function sequenceEqual(x: SQExpr[], y: SQExpr[]): boolean {\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!SQExpr.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n        \r\n        export function uniqueName(namedItems: NamedSQExpr[], expr: SQExpr, exprDefaultName?: string): string {\r\n            debug.assertValue(namedItems, 'namedItems');\r\n\r\n            // Determine all names\r\n            let names: { [name: string]: boolean } = {};\r\n            for (let i = 0, len = namedItems.length; i < len; i++)\r\n                names[namedItems[i].name] = true;\r\n\r\n            return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\r\n        }\r\n\r\n        /** Generates a default expression name  */\r\n        export function defaultName(expr: SQExpr, fallback: string = 'select'): string {\r\n            if (!expr)\r\n                return fallback;\r\n\r\n            return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a model measure or an aggregate. */\r\n        export function isMeasure(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsMeasureVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\r\n        export function isAnyValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsAnyValueVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\r\n        export function isDefaultValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsDefaultValueVisitor.instance);\r\n        }\r\n\r\n        export function discourageAggregation(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let capabilities = getSchemaCapabilities(expr, schema);\r\n            return capabilities && capabilities.discourageQueryAggregateUsage;\r\n        }\r\n\r\n        export function getAggregateBehavior(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualAggregateBehavior {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let column = getConceptualColumn(expr, schema);\r\n            if (column)\r\n                return column.aggregateBehavior;\r\n        }\r\n\r\n        export function getSchemaCapabilities(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualCapabilities {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(expr);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let conceptualSchema = schema.schema(fieldExprItem.schema);\r\n            if (conceptualSchema)\r\n                return conceptualSchema.capabilities;\r\n        }\r\n\r\n        export function getKpiMetadata(expr: SQExpr, schema: FederatedConceptualSchema): DataViewKpiColumnMetadata {\r\n            let kpiStatusProperty = getKpiStatusProperty(expr, schema);\r\n            if (kpiStatusProperty)\r\n                return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\r\n\r\n            let kpiTrendProperty = getKpiTrendProperty(expr, schema);\r\n            if (kpiTrendProperty)\r\n                return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\r\n        }\r\n\r\n        export function getConceptualEntity(entityExpr: SQEntityExpr, schema: FederatedConceptualSchema): ConceptualEntity {\r\n            debug.assertValue(entityExpr, 'entityExpr');\r\n\r\n            let conceptualEntity = schema\r\n                .schema(entityExpr.schema)\r\n                .entities\r\n                .withName(entityExpr.entity);\r\n            return conceptualEntity;\r\n        }\r\n\r\n        function getKpiStatusProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.status === property)\r\n                return property;\r\n        }\r\n\r\n        function getKpiTrendProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.trend === property)\r\n                return property;\r\n        }\r\n\r\n        export function getDefaultValue(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): SQConstantExpr {\r\n            let column = getConceptualColumn(fieldSQExpr, schema);\r\n            if (column)\r\n                return column.defaultValue;\r\n        }\r\n\r\n        function getConceptualColumn(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): ConceptualColumn {\r\n            if (!fieldSQExpr || !schema)\r\n                return;\r\n\r\n            let sqField = SQExprConverter.asFieldPattern(fieldSQExpr);\r\n            if (!sqField)\r\n                return;\r\n\r\n            let column: FieldExprPropertyPattern = sqField.column;\r\n\r\n            if (column) {\r\n                if (schema.schema(column.schema) && sqField.column.name) {\r\n                    let property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\r\n\r\n                    if (property)\r\n                        return property.column;\r\n                }\r\n            }\r\n            else {\r\n                let hierarchyLevelField: FieldExprHierarchyLevelPattern = sqField.hierarchyLevel;\r\n                if (hierarchyLevelField) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(sqField);\r\n                    let schemaName = fieldExprItem.schema;\r\n                    if (schema.schema(schemaName)) {\r\n                        let hierarchy = schema.schema(schemaName)\r\n                            .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\r\n\r\n                        if (hierarchy) {\r\n                            let hierarchyLevel: ConceptualHierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\r\n                            if (hierarchyLevel && hierarchyLevel.column)\r\n                                return hierarchyLevel.column.column;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function getDefaultValues(fieldSQExprs: SQExpr[], schema: FederatedConceptualSchema): SQConstantExpr[] {\r\n            if (_.isEmpty(fieldSQExprs) || !schema)\r\n                return;\r\n            let result: SQConstantExpr[] = [];\r\n            for (let sqExpr of fieldSQExprs) {\r\n                let defaultValue = getDefaultValue(sqExpr, schema);\r\n                if (defaultValue)\r\n                    result.push(defaultValue);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Return compare or and expression for key value pairs. */\r\n        export function getDataViewScopeIdentityComparisonExpr(fieldsExpr: SQExpr[], values: SQConstantExpr[]): SQExpr {\r\n            debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\r\n\r\n            let compareExprs: SQCompareExpr[] = [];\r\n            for (let i = 0; i < fieldsExpr.length; i++) {\r\n                compareExprs.push(SQExprBuilder.compare(QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\r\n            }\r\n\r\n            if (_.isEmpty(compareExprs))\r\n                return;\r\n\r\n            let resultExpr: SQExpr;\r\n            for (let compareExpr of compareExprs) {\r\n                resultExpr = SQExprBuilder.and(resultExpr, compareExpr);\r\n            }\r\n\r\n            return resultExpr;\r\n        }\r\n\r\n        export function getActiveTablesNames(queryDefn: data.SemanticQuery): string[] {\r\n            let tables: string[] = [];\r\n            if (queryDefn) {\r\n                let selectedItems = queryDefn.from();\r\n                if (selectedItems !== undefined) {\r\n                    for (let key of selectedItems.keys()) {\r\n                        let entityObj = selectedItems.entity(key);\r\n                        if (tables.indexOf(entityObj.entity) < 0)\r\n                            tables.push(entityObj.entity);\r\n                    }\r\n                }\r\n            }\r\n            return tables;\r\n        }\r\n\r\n        export function isRelatedToMany(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne);\r\n        }\r\n\r\n        export function isRelatedToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many);\r\n        }\r\n\r\n        function isRelated(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr,\r\n            sourceMultiplicity: ConceptualMultiplicity,\r\n            targetMultiplicity: ConceptualMultiplicity): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n\r\n            if (_.isEmpty(source.navigationProperties))\r\n                return false;\r\n\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let queue: ConceptualEntity[] = [];\r\n            queue.push(source);\r\n\r\n            // walk the relationship path from source.\r\n            while (!_.isEmpty(queue)) {\r\n                let current = queue.shift();\r\n\r\n                let navProperties = current.navigationProperties;\r\n                if (_.isEmpty(navProperties))\r\n                    continue;\r\n\r\n                for (let navProperty of navProperties) {\r\n                    if (!navProperty.isActive)\r\n                        continue;\r\n\r\n                    if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\r\n                        if (navProperty.targetEntity === target)\r\n                            return true;\r\n                        queue.push(navProperty.targetEntity);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRelatedOneToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let sourceNavigations = source.navigationProperties;\r\n            let targetNavigations = target.navigationProperties;\r\n\r\n            if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\r\n                return false;\r\n\r\n            return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\r\n        }\r\n\r\n        function hasOneToOneNavigation(navigationProperties: ArrayNamedItems<ConceptualNavigationProperty>, targetEntity: ConceptualEntity): boolean {\r\n            if (_.isEmpty(navigationProperties))\r\n                return false;\r\n\r\n            for (let navigationProperty of navigationProperties) {\r\n                if (!navigationProperty.isActive)\r\n                    continue;\r\n\r\n                if (navigationProperty.targetEntity !== targetEntity)\r\n                    continue;\r\n\r\n                if (navigationProperty.sourceMultiplicity === ConceptualMultiplicity.ZeroOrOne &&\r\n                    navigationProperty.targetMultiplicity === ConceptualMultiplicity.ZeroOrOne) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\r\n            and returns a new array. When available, we should use _.unionWith from lodash. */\r\n        export function concatUnique(leftExprs: SQExpr[], rightExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(leftExprs, 'leftExprs');\r\n            debug.assertValue(rightExprs, 'rightExprs');\r\n\r\n            let concatExprs = ArrayExtensions.copy(leftExprs);\r\n            for (let expr of rightExprs) {\r\n                if (indexOfExpr(concatExprs, expr) === -1) {\r\n                    concatExprs.push(expr);\r\n                }\r\n            }\r\n\r\n            return concatExprs;\r\n        }\r\n\r\n        class SQExprDefaultNameGenerator extends DefaultSQExprVisitorWithArg<string, string> {\r\n            public static instance: SQExprDefaultNameGenerator = new SQExprDefaultNameGenerator();\r\n\r\n            public visitEntity(expr: SQEntityExpr): string {\r\n                return expr.entity;\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, fallback: string): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, fallback: string): string {\r\n                return QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\r\n            }\r\n\r\n            public visitPercentile(expr: SQPercentileExpr, fallback: string): string {\r\n                let func = expr.exclusive\r\n                    ? 'Percentile.Exc('\r\n                    : 'Percentile.Inc(';\r\n\r\n                return func + expr.arg.accept(this) + ', ' + expr.k + ')';\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr, fallback: string): string {\r\n                return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): string {\r\n                return 'const';\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr, fallback: string): string {\r\n                return fallback || 'expr';\r\n            }\r\n        }\r\n\r\n        class IsMeasureVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsMeasureVisitor = new IsMeasureVisitor();\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsDefaultValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsDefaultValueVisitor = new IsDefaultValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsAnyValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsAnyValueVisitor = new IsAnyValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export class SemanticQueryRewriter {\r\n        private exprRewriter: ISQExprVisitor<SQExpr>;\r\n\r\n        constructor(exprRewriter: ISQExprVisitor<SQExpr>) {\r\n            this.exprRewriter = exprRewriter;\r\n        }\r\n\r\n        public rewriteFrom(fromValue: SQFrom): SQFrom {\r\n            let fromContents: { [name: string]: SQFromEntitySource } = {};\r\n            let originalFrom = fromValue,\r\n                originalFromKeys = originalFrom.keys();\r\n            for (let i = 0, len = originalFromKeys.length; i < len; i++) {\r\n                let keyName = originalFromKeys[i],\r\n                    originalEntityRef = originalFrom.entity(keyName),\r\n                    originalEntityExpr = SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName),\r\n                    updatedEntityExpr = <SQEntityExpr>originalEntityExpr.accept(this.exprRewriter);\r\n                \r\n                fromContents[keyName] = {\r\n                    schema: updatedEntityExpr.schema,\r\n                    entity: updatedEntityExpr.entity,\r\n                };\r\n            }\r\n            return new SQFrom(fromContents);\r\n        }\r\n\r\n        public rewriteSelect(selectItems: NamedSQExpr[], from: SQFrom): NamedSQExpr[]{\r\n            debug.assertValue(selectItems, 'selectItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            return this.rewriteNamedSQExpressions(selectItems, from);\r\n        }\r\n\r\n        public rewriteGroupBy(groupByitems: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertAnyValue(groupByitems, 'groupByitems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(groupByitems))\r\n                return;\r\n\r\n            return this.rewriteNamedSQExpressions(groupByitems, from);\r\n        }\r\n\r\n        private rewriteNamedSQExpressions(expressions: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertValue(expressions, 'expressions');\r\n\r\n            return _.map(expressions, item => {\r\n                return {\r\n                    name: item.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from)\r\n                };\r\n            });\r\n        }\r\n\r\n        public rewriteOrderBy(orderByItems: SQSortDefinition[], from: SQFrom): SQSortDefinition[]{\r\n            debug.assertAnyValue(orderByItems, 'orderByItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(orderByItems))\r\n                return;\r\n\r\n            let orderBy: SQSortDefinition[] = [];\r\n            for (let i = 0, len = orderByItems.length; i < len; i++) {\r\n                let item = orderByItems[i],\r\n                    updatedExpr = SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\r\n                orderBy.push({\r\n                        direction: item.direction,\r\n                        expr: updatedExpr,\r\n                    });\r\n            }\r\n\r\n            return orderBy;\r\n        }\r\n\r\n        public rewriteWhere(whereItems: SQFilter[], from: SQFrom): SQFilter[]{\r\n            debug.assertAnyValue(whereItems, 'whereItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(whereItems))\r\n                return;\r\n\r\n            let where: SQFilter[] = [];\r\n            for (let i = 0, len = whereItems.length; i < len; i++) {\r\n                let originalWhere = whereItems[i];\r\n\r\n                let updatedWhere: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\r\n                };\r\n\r\n                if (originalWhere.target)\r\n                    updatedWhere.target = _.map(originalWhere.target, e => SQExprRewriterWithSourceRenames.rewrite(e.accept(this.exprRewriter), from));\r\n\r\n                where.push(updatedWhere);\r\n            }\r\n\r\n            return where;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export interface NamedSQExpr {\r\n        name: string;\r\n        expr: SQExpr;\r\n    }\r\n\r\n    export interface SQFilter {\r\n        target?: SQExpr[];\r\n        condition: SQExpr;\r\n    }\r\n\r\n    /** Represents an entity reference in SemanticQuery from. */\r\n    export interface SQFromEntitySource {\r\n        entity: string;\r\n        schema: string;\r\n    }\r\n\r\n    /** Represents a sort over an expression. */\r\n    export interface SQSortDefinition {\r\n        expr: SQExpr;\r\n        direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryFromEnsureEntityResult {\r\n        name: string;\r\n        new?: boolean;\r\n    }\r\n\r\n    export interface SQSourceRenames {\r\n        [from: string]: string;\r\n    }\r\n\r\n    /**\r\n     * Represents a semantic query that is:\r\n     * 1) Round-trippable with a JSON QueryDefinition.\r\n     * 2) Immutable\r\n     * 3) Long-lived and does not have strong references to a conceptual model (only names).\r\n     */\r\n    export class SemanticQuery {\r\n        private static empty: SemanticQuery;\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n        private orderByItems: SQSortDefinition[];\r\n        private selectItems: NamedSQExpr[];\r\n        private groupByItems: NamedSQExpr[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[], orderBy: SQSortDefinition[], select: NamedSQExpr[], groupBy: NamedSQExpr[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(select, 'select');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n            this.orderByItems = orderBy;\r\n            this.selectItems = select;\r\n            this.groupByItems = groupBy;\r\n        }\r\n\r\n        public static create(): SemanticQuery {\r\n            if (!SemanticQuery.empty)\r\n                SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\r\n\r\n            return SemanticQuery.empty;\r\n        }\r\n\r\n        private static createWithTrimmedFrom(\r\n            from: SQFrom,\r\n            where: SQFilter[],\r\n            orderBy: SQSortDefinition[],\r\n            select: NamedSQExpr[],\r\n            groupBy: NamedSQExpr[]): SemanticQuery {\r\n\r\n            let unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\r\n\r\n            // Where\r\n            if (where) {\r\n                for (let i = 0, len = where.length; i < len; i++) {\r\n                    let filter = where[i];\r\n\r\n                    filter.condition.accept(unreferencedKeyFinder);\r\n\r\n                    let filterTarget = filter.target;\r\n                    if (filterTarget) {\r\n                        for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                            if (filterTarget[j])\r\n                                filterTarget[j].accept(unreferencedKeyFinder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // OrderBy\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++)\r\n                    orderBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            // Select\r\n            for (let i = 0, len = select.length; i < len; i++)\r\n                select[i].expr.accept(unreferencedKeyFinder);\r\n\r\n            // GroupBy\r\n            if (groupBy) {\r\n                for (let i = 0, len = groupBy.length; i < len; i++)\r\n                    groupBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            let unreferencedKeys = unreferencedKeyFinder.result();\r\n            for (let i = 0, len = unreferencedKeys.length; i < len; i++)\r\n                from.remove(unreferencedKeys[i]);\r\n\r\n            return new SemanticQuery(from, where, orderBy, select, groupBy);\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        /** Returns a query equivalent to this, with the specified selected items. */\r\n        select(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the items being selected in this query. */\r\n        select(): ArrayNamedItems<NamedSQExpr>;\r\n        public select(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getSelect();\r\n\r\n            return this.setSelect(values);\r\n        }\r\n\r\n        private getSelect(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.selectItems);\r\n        }\r\n\r\n        private static createNamedExpressionArray(items: NamedSQExpr[]): ArrayNamedItems<NamedSQExpr> {\r\n            return ArrayExtensions.extendWithName<NamedSQExpr>(_.map(items, s => {\r\n                return {\r\n                    name: s.name,\r\n                    expr: s.expr,\r\n                };\r\n            }));\r\n        }\r\n\r\n        private setSelect(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private static rewriteExpressionsWithSourceRenames(values: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            let items: NamedSQExpr[] = [];\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n                items.push({\r\n                    name: value.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\r\n                });\r\n            }\r\n\r\n            return items;\r\n        } \r\n\r\n        /** Removes the given expression from the select. */\r\n        public removeSelect(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let originalItems = this.selectItems,\r\n                selectItems: NamedSQExpr[] = [];\r\n            for (let i = 0, len = originalItems.length; i < len; i++) {\r\n                let originalExpr = originalItems[i];\r\n                if (SQExpr.equals(originalExpr.expr, expr))\r\n                    continue;\r\n\r\n                selectItems.push(originalExpr);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Removes the given expression from order by. */\r\n        public removeOrderBy(expr: SQExpr): SemanticQuery {\r\n            let sorts = this.orderBy();\r\n            for (let i = sorts.length - 1; i >= 0; i--) {\r\n                if (SQExpr.equals(sorts[i].expr, expr))\r\n                    sorts.splice(i, 1);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public selectNameOf(expr: SQExpr): string {\r\n            let index = SQExprUtils.indexOfExpr(_.map(this.selectItems, s => s.expr), expr);\r\n            if (index >= 0)\r\n                return this.selectItems[index].name;\r\n        }\r\n\r\n        public setSelectAt(index: number, expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (index >= this.selectItems.length)\r\n                return;\r\n\r\n            let select = this.select(),\r\n                from = this.fromValue.clone(),\r\n                originalName = select[index].name;\r\n            select[index] = {\r\n                name: originalName,\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\r\n        }\r\n\r\n        /** Adds a the expression to the select clause. */\r\n        public addSelect(expr: SQExpr, exprName?: string): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let selectItems = this.select(),\r\n                from = this.fromValue.clone();\r\n            selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private createNamedExpr(currentNames: ArrayNamedItems<NamedSQExpr>, from: SQFrom, expr: SQExpr, exprName?: string): NamedSQExpr{\r\n            return {\r\n                name: SQExprUtils.uniqueName(currentNames, expr, exprName),\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n        } \r\n\r\n        /** Returns a query equivalent to this, with the specified groupBy items. */\r\n        groupBy(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the groupby items in this query. */\r\n        groupBy(): ArrayNamedItems<NamedSQExpr>;\r\n        public groupBy(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getGroupBy();\r\n\r\n            return this.setGroupBy(values);\r\n        }\r\n\r\n        private getGroupBy(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.groupByItems);\r\n        }\r\n\r\n        private setGroupBy(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        public addGroupBy(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let groupByItems = this.groupBy(),\r\n                from = this.fromValue.clone();\r\n            groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the sorting for this query. */\r\n        orderBy(values: SQSortDefinition[]): SemanticQuery;\r\n        orderBy(): SQSortDefinition[];\r\n\r\n        public orderBy(values?: SQSortDefinition[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getOrderBy();\r\n\r\n            return this.setOrderBy(values);\r\n        }\r\n\r\n        private getOrderBy(): SQSortDefinition[] {\r\n            let result: SQSortDefinition[] = [];\r\n\r\n            let orderBy = this.orderByItems;\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++) {\r\n                    let clause = orderBy[i];\r\n\r\n                    result.push({\r\n                        expr: clause.expr,\r\n                        direction: clause.direction,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setOrderBy(values: SQSortDefinition[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedOrderBy: SQSortDefinition[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let clause = values[i];\r\n                updatedOrderBy.push({\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\r\n                    direction: clause.direction,\r\n                });\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the filters for this query. */\r\n        where(values: SQFilter[]): SemanticQuery;\r\n        where(): SQFilter[];\r\n\r\n        public where(values?: SQFilter[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getWhere();\r\n\r\n            return this.setWhere(values);\r\n        }\r\n\r\n        private getWhere(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            if (whereItems) {\r\n                for (let i = 0, len = whereItems.length; i < len; i++)\r\n                    result.push(whereItems[i]);\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setWhere(values: SQFilter[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedWhere: SQFilter[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let filter = values[i];\r\n                let updatedFilter: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\r\n                };\r\n\r\n                let filterTarget = filter.target;\r\n                if (filterTarget) {\r\n                    updatedFilter.target = [];\r\n                    for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                        if (filterTarget[j]) {\r\n                            let updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\r\n                            updatedFilter.target.push(updatedTarget);\r\n                        }\r\n                }\r\n\r\n                updatedWhere.push(updatedFilter);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public addWhere(filter: SemanticFilter): SemanticQuery {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedWhere: SQFilter[] = this.where(),\r\n                incomingWhere: SQFilter[] = filter.where(),\r\n                from = this.fromValue.clone();\r\n\r\n            for (let i = 0, len = incomingWhere.length; i < len; i++) {\r\n                let clause = incomingWhere[i];\r\n\r\n                let updatedClause: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\r\n                };\r\n\r\n                if (clause.target)\r\n                    updatedClause.target = _.map(clause.target, t => SQExprRewriterWithSourceRenames.rewrite(t, from));\r\n\r\n                updatedWhere.push(updatedClause);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticQuery {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n            let orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\r\n            let select = rewriter.rewriteSelect(this.selectItems, from);\r\n            let groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\r\n        }\r\n    }\r\n\r\n    /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\r\n    export class SemanticFilter implements ISemanticFilter {\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n        }\r\n\r\n        public static fromSQExpr(contract: SQExpr): SemanticFilter {\r\n            debug.assertValue(contract, 'contract');\r\n\r\n            let from = new SQFrom();\r\n\r\n            let rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\r\n            // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\r\n            //         Thus not setting a target here.\r\n            let where: SQFilter[] = [{\r\n                condition: rewrittenContract\r\n            }];\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static getDefaultValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.defaultValue());\r\n        }\r\n\r\n        public static getAnyValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.anyValue());\r\n        }\r\n\r\n        private static getDataViewScopeIdentityComparisonFilters(fieldSQExprs: SQExpr | SQExpr[], value: SQExpr): SemanticFilter {\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (fieldSQExprs instanceof Array) {\r\n                let values: SQConstantExpr[] = Array.apply(null, Array(fieldSQExprs.length)).map(() => { return value; });\r\n                return SemanticFilter.fromSQExpr(SQExprUtils.getDataViewScopeIdentityComparisonExpr(<SQExpr[]>fieldSQExprs, values));\r\n            }\r\n\r\n            return SemanticFilter.fromSQExpr(SQExprBuilder.equal(<SQExpr>fieldSQExprs, value));\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        public conditions(): SQExpr[] {\r\n            let expressions: SQExpr[] = [];\r\n\r\n            let where = this.whereItems;\r\n            for (let i = 0, len = where.length; i < len; i++) {\r\n                let filter = where[i];\r\n                expressions.push(filter.condition);\r\n            }\r\n            return expressions;\r\n        }\r\n\r\n        public where(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            for (let i = 0, len = whereItems.length; i < len; i++)\r\n                result.push(whereItems[i]);\r\n\r\n            return result;\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticFilter {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.rewrite(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        /** Merges a list of SemanticFilters into one. */\r\n        public static merge(filters: SemanticFilter[]): SemanticFilter {\r\n            if (_.isEmpty(filters))\r\n                return null;\r\n\r\n            if (filters.length === 1)\r\n                return filters[0];\r\n\r\n            let firstFilter = filters[0];\r\n            let from = firstFilter.from(),\r\n                where: SQFilter[] = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\r\n\r\n            for (let i = 1, len = filters.length; i < len; i++)\r\n                SemanticFilter.applyFilter(filters[i], from, where);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static isDefaultFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isDefaultValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isAnyFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isAnyValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isSameFilter(leftFilter: SemanticFilter, rightFilter: SemanticFilter): boolean {\r\n            if (jsCommon.JsonComparer.equals<SemanticFilter>(leftFilter, rightFilter)) {\r\n                return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\r\n                    || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private static applyFilter(filter: SemanticFilter, from: SQFrom, where: SQFilter[]): void {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            // Where\r\n            let filterWhereItems = filter.whereItems;\r\n            for (let i = 0; i < filterWhereItems.length; i++) {\r\n                let filterWhereItem = filterWhereItems[i];\r\n\r\n                let updatedWhereItem: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\r\n                };\r\n\r\n                if (filterWhereItem.target)\r\n                    updatedWhereItem.target = _.map(filterWhereItem.target, e => SQExprRewriterWithSourceRenames.rewrite(e, from));\r\n\r\n                where.push(updatedWhereItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Represents a SemanticQuery/SemanticFilter from clause. */\r\n    export class SQFrom {\r\n        private items: { [name: string]: SQFromEntitySource };\r\n\r\n        constructor(items?: { [name: string]: SQFromEntitySource }) {\r\n            this.items = items || {};\r\n        }\r\n\r\n        public keys(): string[] {\r\n            return Object.keys(this.items);\r\n        }\r\n\r\n        public entity(key: string): SQFromEntitySource {\r\n            return this.items[key];\r\n        }\r\n\r\n        public ensureEntity(entity: SQFromEntitySource, desiredVariableName?: string): QueryFromEnsureEntityResult {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            // 1) Reuse a reference to the entity among the already referenced\r\n            let keys = this.keys();\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let key = keys[i],\r\n                    item = this.items[key];\r\n                if (item && entity.entity === item.entity && entity.schema === item.schema)\r\n                    return { name: key };\r\n            }\r\n\r\n            // 2) Add a reference to the entity\r\n            let candidateName = desiredVariableName || this.candidateName(entity.entity),\r\n                uniqueName: string = candidateName,\r\n                i = 2;\r\n            while (this.items[uniqueName]) {\r\n                uniqueName = candidateName + i++;\r\n            }\r\n\r\n            this.items[uniqueName] = entity;\r\n            return { name: uniqueName, new: true };\r\n        }\r\n\r\n        public remove(key: string): void {\r\n            delete this.items[key];\r\n        }\r\n\r\n        /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\r\n        private candidateName(ref: string): string {\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            let idx = ref.lastIndexOf('.');\r\n            if (idx >= 0 && (idx !== ref.length - 1))\r\n                ref = ref.substr(idx + 1);\r\n\r\n            return ref.substring(0, 1).toLowerCase();\r\n        }\r\n\r\n        public clone(): SQFrom {\r\n            // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\r\n            let cloned = new SQFrom();\r\n\r\n            // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\r\n            $.extend(cloned.items, this.items);\r\n\r\n            return cloned;\r\n        }\r\n    }\r\n\r\n    export class SQExprRewriterWithSourceRenames extends SQExprRewriter {\r\n        private renames: SQSourceRenames;\r\n\r\n        constructor(renames: SQSourceRenames) {\r\n            debug.assertValue(renames, 'renames');\r\n\r\n            super();\r\n            this.renames = renames;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            let updatedName = this.renames[expr.entity];\r\n\r\n            if (updatedName)\r\n                return new SQEntityExpr(expr.schema, expr.entity, updatedName);\r\n\r\n            return super.visitEntity(expr);\r\n        }\r\n\r\n        public rewriteFilter(filter: SQFilter): SQFilter {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedTargets = undefined;\r\n            if (filter.target)\r\n                updatedTargets = this.rewriteArray(filter.target);\r\n\r\n            let updatedCondition = filter.condition.accept(this);\r\n\r\n            if (filter.condition === updatedCondition && filter.target === updatedTargets)\r\n                return filter;\r\n\r\n            let updatedFilter: SQFilter = {\r\n                condition: updatedCondition,\r\n            };\r\n\r\n            if (updatedTargets)\r\n                updatedFilter.target = updatedTargets;\r\n\r\n            return updatedFilter;\r\n        }\r\n\r\n        public rewriteArray(exprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(exprs, 'exprs');\r\n\r\n            let updatedExprs: SQExpr[];\r\n\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i],\r\n                    rewrittenExpr = expr.accept(this);\r\n\r\n                if (expr !== rewrittenExpr && !updatedExprs)\r\n                    updatedExprs = ArrayExtensions.take(exprs, i);\r\n\r\n                if (updatedExprs)\r\n                    updatedExprs.push(rewrittenExpr);\r\n            }\r\n\r\n            return updatedExprs || exprs;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, from: SQFrom): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(from, 'from');\r\n\r\n            let renames = QuerySourceRenameDetector.run(expr, from);\r\n            let rewriter = new SQExprRewriterWithSourceRenames(renames);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    /** Responsible for updating a QueryFrom based on SQExpr references. */\r\n    class QuerySourceRenameDetector extends DefaultSQExprVisitorWithTraversal {\r\n        private from: SQFrom;\r\n        private renames: SQSourceRenames;\r\n\r\n        public static run(expr: SQExpr, from: SQFrom): SQSourceRenames {\r\n            let detector = new QuerySourceRenameDetector(from);\r\n            expr.accept(detector);\r\n\r\n            return detector.renames;\r\n        }\r\n\r\n        constructor(from: SQFrom) {\r\n            debug.assertValue(from, 'from');\r\n            super();\r\n\r\n            this.from = from;\r\n            this.renames = {};\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            // TODO: Renames must take the schema into account, not just entity set name.\r\n            let existingEntity = this.from.entity(expr.variable);\r\n            if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\r\n                return;\r\n\r\n            let actualEntity = this.from.ensureEntity(\r\n                {\r\n                    schema: expr.schema,\r\n                    entity: expr.entity,\r\n                },\r\n                expr.variable);\r\n\r\n            this.renames[expr.entity] = actualEntity.name;\r\n        }\r\n    }\r\n\r\n    /** Visitor for finding unreferenced sources. */\r\n    class UnreferencedKeyFinder extends DefaultSQExprVisitorWithTraversal {\r\n        private keys: string[];\r\n\r\n        constructor(keys: string[]) {\r\n            debug.assertValue(keys, 'keys');\r\n\r\n            super();\r\n            this.keys = keys;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            let index = this.keys.indexOf(expr.variable);\r\n            if (index >= 0)\r\n                this.keys.splice(index, 1);\r\n        }\r\n\r\n        public result(): string[] {\r\n            return this.keys;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataViewTransform = powerbi.data.DataViewTransform;\r\n    import SQExprBuilder = powerbi.data.SQExprBuilder;\r\n\r\n    /** Utility for creating a DataView from columns of data. */\r\n    export interface IDataViewBuilderCategorical {\r\n        withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical;\r\n        withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical;\r\n        withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical;\r\n        withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical;\r\n\r\n        build(): DataView;\r\n    }\r\n\r\n    export interface DataViewBuilderColumnOptions {\r\n        source: DataViewMetadataColumn;\r\n    }\r\n\r\n    export interface DataViewBuilderCategoryColumnOptions extends DataViewBuilderColumnOptions {\r\n        values: PrimitiveValue[];\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n    }\r\n\r\n    export interface DataViewBuilderValuesOptions {\r\n        columns: DataViewBuilderValuesColumnOptions[];\r\n    }\r\n\r\n    export interface DataViewBuilderGroupedValuesOptions {\r\n        groupColumn: DataViewBuilderCategoryColumnOptions;\r\n        valueColumns: DataViewBuilderColumnOptions[];\r\n        data: DataViewBuilderSeriesData[][];\r\n    }\r\n\r\n    /** Indicates the source set of identities. */\r\n    export interface DataViewBuilderColumnIdentitySource {\r\n        fields: SQExpr[];\r\n        identities?: DataViewScopeIdentity[];\r\n    }\r\n\r\n    export interface DataViewBuilderValuesColumnOptions extends DataViewBuilderColumnOptions, DataViewBuilderSeriesData {\r\n    }\r\n\r\n    export interface DataViewBuilderSeriesData {\r\n        values: PrimitiveValue[];\r\n        highlights?: PrimitiveValue[];\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        maxLocal?: any;\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        minLocal?: any;\r\n    }\r\n\r\n    export function createCategoricalDataViewBuilder(): IDataViewBuilderCategorical {\r\n        return new CategoricalDataViewBuilder();\r\n    }\r\n\r\n    interface ColumnMetadata {\r\n        column: DataViewMetadataColumn;\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n        values: PrimitiveValue[];\r\n    }\r\n\r\n    class CategoricalDataViewBuilder implements IDataViewBuilderCategorical {\r\n        private categories: DataViewCategoryColumn[];\r\n        private staticMeasureColumns: DataViewMetadataColumn[];\r\n        private dynamicMeasureColumns: DataViewMetadataColumn[];\r\n        private dynamicSeriesMetadata: ColumnMetadata;\r\n        private columnIndex: number;\r\n        private staticSeriesValues: DataViewBuilderValuesColumnOptions[];\r\n        private dynamicSeriesValues: DataViewBuilderSeriesData[][];\r\n\r\n        constructor() {\r\n            this.categories = [];\r\n            this.staticMeasureColumns = [];\r\n            this.dynamicMeasureColumns = [];\r\n            this.columnIndex = 0;\r\n        }\r\n\r\n        public withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical {\r\n            let categoryValues = options.values,\r\n                identityFrom = options.identityFrom,\r\n                type = options.source.type;\r\n\r\n            let categoryColumn: DataViewCategoryColumn = {\r\n                source: options.source,\r\n                identityFields: options.identityFrom.fields,\r\n                identity: options.identityFrom.identities || [],\r\n                values: categoryValues,\r\n            };\r\n\r\n            if (!options.identityFrom.identities) {\r\n                for (let categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\r\n                    categoryColumn.identity.push(\r\n                        getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\r\n                }\r\n            }\r\n\r\n            if (!this.categories)\r\n                this.categories = [];\r\n\r\n            this.categories.push(categoryColumn);\r\n\r\n            return this;\r\n        }\r\n\r\n        public withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical {\r\n            if (_.isEmpty(this.categories))\r\n                this.categories = categories;\r\n            else\r\n                Array.prototype.push.apply(this.categories, categories);\r\n\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Adds static series columns.\r\n         *\r\n         * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in \r\n         * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\r\n         */\r\n        public withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let columns = options.columns;\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            for (let column of columns) {\r\n                this.staticMeasureColumns.push(column.source);\r\n            }\r\n\r\n            this.staticSeriesValues = columns;\r\n\r\n            return this;\r\n        }\r\n\r\n        /**\r\n         * Adds dynamic series columns.\r\n         *\r\n         * Note that it is illegal to have both dynamic series and static series in a visual DataViewCategorical.  It is only legal to have them both in \r\n         * a query DataViewCategorical, where DataViewTransform is expected to split them up into separate visual DataViewCategorical objects.\r\n         */\r\n        public withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let groupColumn = options.groupColumn;\r\n            debug.assertValue(groupColumn, 'groupColumn');\r\n\r\n            this.dynamicSeriesMetadata = {\r\n                column: groupColumn.source,\r\n                identityFrom: groupColumn.identityFrom,\r\n                values: groupColumn.values,\r\n            };\r\n\r\n            let valueColumns = options.valueColumns;\r\n            for (let valueColumn of valueColumns) {\r\n                this.dynamicMeasureColumns.push(valueColumn.source);\r\n            }\r\n\r\n            this.dynamicSeriesValues = options.data;\r\n\r\n            return this;\r\n        }\r\n\r\n        private fillData(dataViewValues: DataViewValueColumns) {\r\n            let categoryColumn = _.first(this.categories);\r\n            let categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 0;\r\n\r\n            if (this.hasDynamicSeries()) {\r\n                for (let seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\r\n                    let seriesMeasures = this.dynamicSeriesValues[seriesIndex];\r\n                    debug.assert(seriesMeasures.length === this.dynamicMeasureColumns.length, 'seriesMeasures.length === this.dynamicMeasureColumns.length');\r\n\r\n                    for (let measureIndex = 0, measuresLen = this.dynamicMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                        let groupIndex = seriesIndex * measuresLen + measureIndex;\r\n\r\n                        applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.hasStaticSeries()) {\r\n                // Note: when the target categorical has both dynamic and static series, append static measures at the end of the values array.\r\n                let staticColumnsStartingIndex = this.hasDynamicSeries() ? (this.dynamicSeriesValues.length * this.dynamicMeasureColumns.length) : 0;\r\n\r\n                for (let measureIndex = 0, measuresLen = this.staticMeasureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                    applySeriesData(dataViewValues[staticColumnsStartingIndex + measureIndex], this.staticSeriesValues[measureIndex], categoryLength);\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns the DataView with metadata and DataViewCategorical.\r\n         * Returns undefined if the combination of parameters is illegal, such as having both dynamic series and static series when building a visual DataView.\r\n         */\r\n        public build(): DataView {\r\n            let metadataColumns: DataViewMetadataColumn[] = [];\r\n            let categorical: DataViewCategorical = {};\r\n\r\n            let categoryMetadata = this.categories;\r\n            let dynamicSeriesMetadata = this.dynamicSeriesMetadata;\r\n\r\n            // --- Build metadata columns and value groups ---\r\n            for (let columnMetadata of categoryMetadata) {\r\n                pushIfNotExists(metadataColumns, columnMetadata.source);\r\n            }\r\n\r\n            if (this.hasDynamicSeries()) {\r\n                // Dynamic series, or Dyanmic & Static series.\r\n                pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\r\n\r\n                categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\r\n\r\n                // For each series value we will make one column per measure\r\n                let seriesValues = dynamicSeriesMetadata.values;\r\n                for (let seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\r\n                    let seriesValue = seriesValues[seriesIndex];\r\n                    let seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\r\n\r\n                    for (let measure of this.dynamicMeasureColumns) {\r\n                        let column = _.clone(measure);\r\n                        column.groupName = <string>seriesValue;\r\n\r\n                        pushIfNotExists(metadataColumns, column);\r\n                        categorical.values.push({\r\n                            source: column,\r\n                            values: [],\r\n                            identity: seriesIdentity,\r\n                        });\r\n                    }\r\n                }\r\n\r\n                if (this.hasStaticSeries()) {\r\n                    // IMPORTANT: In the Dyanmic & Static series case, the groups array shall not include any static group. This is to match the behavior of production code that creates query DataView objects.\r\n                    // Get the current return value of grouped() before adding static measure columns, an use that as the return value of this categorical.\r\n                    // Otherwise, the default behavior of DataViewValueColumns.grouped() from DataViewTransform.createValueColumns() is to create series groups from all measure columns.\r\n                    let dynamicSeriesGroups = categorical.values.grouped();\r\n                    categorical.values.grouped = () => dynamicSeriesGroups;\r\n\r\n                    this.appendStaticMeasureColumns(metadataColumns, categorical.values);\r\n                }\r\n            }\r\n            else {\r\n                // Static series only / no series\r\n                categorical.values = DataViewTransform.createValueColumns();\r\n                this.appendStaticMeasureColumns(metadataColumns, categorical.values);\r\n            }\r\n\r\n            let categories = this.categories;\r\n            if (!_.isEmpty(categories))\r\n                categorical.categories = categories;\r\n\r\n            // --- Fill in data point values ---\r\n            this.fillData(categorical.values);\r\n\r\n            let dataView: DataView = {\r\n                metadata: {\r\n                    columns: metadataColumns,\r\n                },\r\n                categorical: categorical,\r\n            };\r\n\r\n            if (this.isLegalDataView(dataView)) {\r\n                return dataView;\r\n            }\r\n        }\r\n\r\n        private appendStaticMeasureColumns(metadataColumns: DataViewMetadataColumn[], valueColumns: DataViewValueColumns): void {\r\n            debug.assertValue(metadataColumns, 'metadataColumns');\r\n            debug.assertValue(valueColumns, 'valueColumns');\r\n\r\n            if (!_.isEmpty(this.staticMeasureColumns)) {\r\n                for (let column of this.staticMeasureColumns) {\r\n                    pushIfNotExists(metadataColumns, column);\r\n                    valueColumns.push({\r\n                        source: column,\r\n                        values: [],\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        private isLegalDataView(dataView: DataView): boolean {\r\n            if (this.hasDynamicSeries() && this.hasStaticSeries() && CategoricalDataViewBuilder.isVisualDataView(dataView.metadata.columns)) {\r\n                // It is illegal to have both dynamic series and static series in a visual DataViewCategorical,\r\n                // because the DataViewValueColumns interface today cannot express that 100% (see its 'source' property and return value of its 'grouped()' function).\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /**\r\n         * This function infers that if any metadata column has 'queryName', \r\n         * then the user of this builder is building a visual DataView (as opposed to query DataView).\r\n         *\r\n         * @param metadataColumns The complete collection of metadata columns in the categorical.\r\n         */\r\n        private static isVisualDataView(metadataColumns: DataViewMetadataColumn[]): boolean {\r\n            return !_.isEmpty(metadataColumns) &&\r\n                _.any(metadataColumns, (metadataColumn) => !!metadataColumn.queryName);\r\n        }\r\n\r\n        private hasDynamicSeries(): boolean {\r\n            return !!this.dynamicSeriesMetadata; // In Map visual scenarios, you can have dynamic series without measure columns\r\n        }\r\n\r\n        private hasStaticSeries(): boolean {\r\n            return !!this.staticSeriesValues;\r\n        }\r\n    }\r\n\r\n    function getScopeIdentity(\r\n        source: DataViewBuilderColumnIdentitySource,\r\n        index: number,\r\n        value: PrimitiveValue,\r\n        valueType: ValueTypeDescriptor): DataViewScopeIdentity {\r\n        let identities = source.identities;\r\n        if (identities) {\r\n            return identities[index];\r\n        }\r\n\r\n        debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\r\n\r\n        return createDataViewScopeIdentity(\r\n            SQExprBuilder.equal(\r\n                source.fields[0],\r\n                SQExprBuilder.typedConstant(value, valueType)));\r\n    }\r\n\r\n    function pushIfNotExists(items: DataViewMetadataColumn[], itemToAdd: DataViewMetadataColumn): void {\r\n        if (_.contains(items, itemToAdd))\r\n            return;\r\n\r\n        items.push(itemToAdd);\r\n    }\r\n\r\n    function applySeriesData(target: DataViewValueColumn, source: DataViewBuilderSeriesData, categoryLength: number): void {\r\n        debug.assertValue(target, 'target');\r\n        debug.assertValue(source, 'source');\r\n        debug.assertValue(categoryLength, 'categoryLength');\r\n\r\n        let values = source.values;\r\n        debug.assert(categoryLength === values.length || categoryLength === 0, 'categoryLength === values.length || categoryLength === 0');\r\n\r\n        target.values = values;\r\n\r\n        let highlights = source.highlights;\r\n        if (highlights) {\r\n            debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\r\n\r\n            target.highlights = highlights;\r\n        }\r\n\r\n        let aggregates: DataViewColumnAggregates;\r\n        if (source.minLocal !== undefined) {\r\n            if (!aggregates)\r\n                aggregates = {};\r\n\r\n            aggregates.minLocal = source.minLocal;\r\n        }\r\n\r\n        if (source.maxLocal !== undefined) {\r\n            if (!aggregates)\r\n                aggregates = {};\r\n\r\n            aggregates.maxLocal = source.maxLocal;\r\n        }\r\n\r\n        if (aggregates) {\r\n            target.source.aggregates = aggregates;\r\n            _.extend(target, aggregates);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export function createStaticEvalContext(colorAllocatorCache?: IColorAllocatorCache): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView?: DataView, selectTransforms?: DataViewSelectTransform[]): IEvalContext {\r\n        return new StaticEvalContext(\r\n            colorAllocatorCache || createColorAllocatorCache(),\r\n            dataView || { metadata: { columns: [] } },\r\n            selectTransforms);\r\n    }\r\n\r\n    /**\r\n     * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\r\n     * are supported.\r\n     */\r\n    class StaticEvalContext implements IEvalContext {\r\n        private colorAllocatorCache: IColorAllocatorCache;\r\n        private dataView: DataView;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorCache = colorAllocatorCache;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorCache.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            let dataView = this.dataView,\r\n                selectTransforms = this.selectTransforms;\r\n\r\n            if (!dataView || !selectTransforms)\r\n                return;\r\n\r\n            if (SQExpr.isAggregation(expr)) {\r\n                let columnAggregate = findAggregateValue(expr, selectTransforms, dataView.metadata.columns);\r\n                if (columnAggregate !== undefined) {\r\n                    return columnAggregate;\r\n                }\r\n            }\r\n\r\n            if (dataView.table)\r\n                return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n    }\r\n\r\n    export function getExprValueFromTable(expr: SQExpr, selectTransforms: DataViewSelectTransform[], table: DataViewTable, rowIdx: number): PrimitiveValue {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n        debug.assertValue(table, 'table');\r\n        debug.assertValue(rowIdx, 'rowIdx');\r\n\r\n        let rows = table.rows;\r\n        if (_.isEmpty(rows) || rows.length <= rowIdx)\r\n            return;\r\n\r\n        let cols = table.columns;\r\n\r\n        let selectIdx = findSelectIndex(expr, selectTransforms);\r\n        if (selectIdx < 0)\r\n            return;\r\n\r\n        for (let colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\r\n            if (selectIdx !== cols[colIdx].index)\r\n                continue;\r\n\r\n            return rows[rowIdx][colIdx];\r\n        }\r\n    }\r\n\r\n    function findAggregateValue(expr: SQAggregationExpr, selectTransforms: DataViewSelectTransform[], columns: DataViewMetadataColumn[]): PrimitiveValue {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n        debug.assertValue(columns, 'columns');\r\n\r\n        let selectIdx = findSelectIndex(expr.arg, selectTransforms);\r\n        if (selectIdx < 0)\r\n            return;\r\n\r\n        for (let colIdx = 0, colLen = columns.length; colIdx < colLen; colIdx++) {\r\n            let column = columns[colIdx],\r\n                columnAggr = column.aggregates;\r\n\r\n            if (selectIdx !== column.index || !columnAggr)\r\n                continue;\r\n\r\n            let aggregateValue = findAggregates(columnAggr, expr.func);\r\n            if (aggregateValue !== undefined)\r\n                return aggregateValue;\r\n        }\r\n    }\r\n\r\n    function findSelectIndex(expr: SQExpr, selectTransforms: DataViewSelectTransform[]): number {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n        let queryName: string;\r\n        if (SQExpr.isSelectRef(expr))\r\n            queryName = expr.expressionName;\r\n\r\n        for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n            let selectTransform = selectTransforms[selectIdx];\r\n\r\n            if (!selectTransform || !selectTransform.queryName)\r\n                continue;\r\n\r\n            if (queryName) {\r\n                if (selectTransform.queryName === queryName)\r\n                    return selectIdx;\r\n            }\r\n            else {\r\n                if (SQExpr.equals(selectTransform.expr, expr))\r\n                    return selectIdx;\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    function findAggregates(aggregates: DataViewColumnAggregates, func: QueryAggregateFunction): PrimitiveValue {\r\n        debug.assertValue(aggregates, 'aggregates');\r\n        debug.assertValue(func, 'func');\r\n\r\n        switch (func) {\r\n            case QueryAggregateFunction.Min:\r\n                return getOptional(aggregates.min, aggregates.minLocal);\r\n            case QueryAggregateFunction.Max:\r\n                return getOptional(aggregates.max, aggregates.maxLocal);\r\n        }\r\n    }\r\n\r\n    function getOptional(value1: PrimitiveValue, value2: PrimitiveValue): PrimitiveValue {\r\n        debug.assertAnyValue(value1, 'value1');\r\n        debug.assertAnyValue(value2, 'value2');\r\n\r\n        if (value1 !== undefined)\r\n            return value1;\r\n\r\n        return value2;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export function createMatrixEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewMatrix: DataViewMatrix): IEvalContext {\r\n        // NOTE: Matrix context-sensitive evaluation is not yet implemented.\r\n        return createStaticEvalContext(colorAllocatorProvider);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import Formatting = jsCommon.Formatting;\r\n    import RegExpExtensions = jsCommon.RegExpExtensions;\r\n\r\n    /** Culture interfaces. These match the Globalize library interfaces intentionally. */\r\n    export interface Culture {\r\n        name: string;\r\n        calendar: Calendar;\r\n        calendars: CalendarDictionary;\r\n        numberFormat: NumberFormatInfo;\r\n    }\r\n\r\n    export interface Calendar {\r\n        patterns: any;\r\n        firstDay: number;\r\n    }\r\n\r\n    export interface CalendarDictionary {\r\n        [key: string]: Calendar;\r\n    }\r\n\r\n    export interface NumberFormatInfo {\r\n        decimals: number;\r\n        groupSizes: number[];\r\n        negativeInfinity: string;\r\n        positiveInfinity: string;\r\n    }\r\n\r\n    /**\r\n     *  Creating a dummy module to declare cultureInfo string, so we could do a strongly typed usage in Visuals\r\n     */\r\n    declare module powerbi.common {\r\n        let cultureInfo: string;\r\n    }\r\n\r\n    /** Formatting Encoder */\r\n    module FormattingEncoder {\r\n        export function preserveEscaped(format: string, specialChars: string): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = \"\\\\\" + specialChars[i];\r\n                let newText = String.fromCharCode(0xE000 + i);\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreEscaped(format: string, specialChars: string): string {\r\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = String.fromCharCode(0xE000 + i);\r\n                let newText = specialChars[i];\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\r\n        }\r\n\r\n        export function preserveLiterals(format: string, literals: string[]): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            for (let i = 0; ; i++) {\r\n                let fromIndex = format.indexOf(\"'\");\r\n                if (fromIndex < 0) {\r\n                    break;\r\n                }\r\n                let toIndex = format.indexOf(\"'\", fromIndex + 1);\r\n                if (toIndex < 0) {\r\n                    break;\r\n                }\r\n                let literal = format.substring(fromIndex, toIndex + 1);\r\n                literals.push(literal.substring(1, toIndex - fromIndex));\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                format = format.replace(literal, token);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreLiterals(format: string, literals: string[]): string {\r\n            let count = literals.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                let literal = literals[i];\r\n                format = format.replace(token, literal);\r\n            }\r\n            return format;\r\n        }\r\n    }\r\n\r\n    const IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\r\n    const ZeroPlaceholder = '0';\r\n    const DigitPlaceholder = '#';\r\n    const ExponentialFormatChar = 'E';\r\n    const NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\r\n    const NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\r\n\r\n    /** Formatting Service */\r\n    class FormattingService implements IFormattingService {\r\n\r\n        _currentCultureSelector: string;\r\n        _currentCulture: Culture;\r\n        _dateTimeScaleFormatInfo: DateTimeScaleFormatInfo;\r\n\r\n        public formatValue(value: any, format?: string, culture?: string): string {\r\n            // Handle special cases\r\n            if (value === undefined || value === null) {\r\n                return '';\r\n            }\r\n            let gculture = this.getCulture(culture);\r\n\r\n            if (DateTimeFormat.canFormat(value)) {\r\n                // Dates\r\n                return DateTimeFormat.format(value, format, gculture);\r\n            } else if (NumberFormat.canFormat(value)) {\r\n                // Numbers\r\n                return NumberFormat.format(value, format, gculture);\r\n            } else {\r\n                // Other data types - return as string\r\n                return value.toString();\r\n            }\r\n        }\r\n\r\n        public format(formatWithIndexedTokens: string, args: any[], culture?: string): string {\r\n            if (!formatWithIndexedTokens) {\r\n                return \"\";\r\n            }\r\n            let result = formatWithIndexedTokens.replace(IndexedTokensRegex, (match: string, left: string, right: string, argToken: string) => {\r\n                if (left) {\r\n                    return \"{\";\r\n                } else if (right) {\r\n                    return \"}\";\r\n                } else {\r\n                    let parts = argToken.split(\":\");\r\n                    let argIndex = parseInt(parts[0], 10);\r\n                    let argFormat = parts[1];\r\n                    return this.formatValue(args[argIndex], argFormat, culture);\r\n                }\r\n            });\r\n\r\n            return result;\r\n        }\r\n\r\n        public isStandardNumberFormat(format: string): boolean {\r\n            return NumberFormat.isStandardFormat(format);\r\n        }\r\n\r\n        public formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string, culture?: string): string {\r\n            let gculture = this.getCulture(culture);\r\n\r\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\r\n        }\r\n\r\n        public dateFormatString(unit: DateTimeUnit): string {\r\n            if (!this._dateTimeScaleFormatInfo)\r\n                this.initialize();\r\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\r\n        }\r\n\r\n        /**\r\n         * Sets the current localization culture\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         */\r\n        private setCurrentCulture(cultureSelector: string): void {\r\n            if (this._currentCultureSelector !== cultureSelector) {\r\n                this._currentCulture = this.getCulture(cultureSelector);\r\n                this._currentCultureSelector = cultureSelector;\r\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         * Exposing this function for testability of unsupported cultures\r\n         */\r\n        public getCulture(cultureSelector?: string): Culture {\r\n            if (cultureSelector == null) {\r\n                if (this._currentCulture == null) {\r\n                    this.initialize();\r\n                }\r\n                return this._currentCulture;\r\n            } else {\r\n                let culture = Globalize.findClosestCulture(cultureSelector);\r\n                if (!culture)\r\n                    culture = Globalize.culture(\"en-US\");\r\n                return culture;\r\n            }\r\n        }\r\n\r\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\r\n        private initialize() {\r\n            let cultureName = this.getCurrentCulture();\r\n            this.setCurrentCulture(cultureName);\r\n            let calendarName = this.getUrlParam(\"calendar\");\r\n            if (calendarName) {\r\n                let culture = this._currentCulture;\r\n                let c = culture.calendars[calendarName];\r\n                if (c) {\r\n                    culture.calendar = c;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability \r\n         */\r\n        public getCurrentCulture(): string {\r\n            let urlParam = this.getUrlParam(\"language\");\r\n\r\n            if (urlParam) {\r\n                return urlParam;\r\n            }\r\n\r\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\r\n                // Get cultureInfo set in powerbi\r\n                return powerbi.common.cultureInfo;\r\n            }\r\n\r\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability\r\n         *  @param name: queryString name\r\n         */\r\n        public getUrlParam(name: string): string {\r\n            let param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\r\n            return param ? param[1] : undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for dates.\r\n     */\r\n    module DateTimeFormat {\r\n\r\n        let _currentCachedFormat: string;\r\n        let _currentCachedProcessedFormat: string;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = value instanceof Date;\r\n            return result;\r\n        }\r\n\r\n        /** Formats the date using provided format and culture */\r\n        export function format(value: Date, format: string, culture: Culture): string {\r\n            format = format || \"G\";\r\n            let isStandard = format.length === 1;\r\n            try {\r\n                if (isStandard) {\r\n                    return formatDateStandard(value, format, culture);\r\n                } else {\r\n                    return formatDateCustom(value, format, culture);\r\n                }\r\n            } catch (e) {\r\n                return formatDateStandard(value, \"G\", culture);\r\n            }\r\n        }\r\n\r\n        /** Formats the date using standard format expression */\r\n        function formatDateStandard(value: Date, format: string, culture: Culture) {\r\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\r\n            let patterns = culture.calendar.patterns;\r\n            // Extend supported set of patterns\r\n            ensurePatterns(culture.calendar);\r\n            // Handle extended set of formats\r\n            let output = Formatting.findDateFormat(value, format, culture.name);\r\n            if (output.format.length === 1)\r\n                format = patterns[output.format];\r\n            else\r\n                format = output.format;\r\n            //need to revisit when globalization is enabled\r\n            culture = Globalize.culture(\"en-US\");\r\n            return Globalize.format(output.value, format, culture);\r\n        }\r\n\r\n        /** Formats the date using custom format expression */\r\n        function formatDateCustom(value: Date, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let literals: string[] = [];\r\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            format = FormattingEncoder.preserveLiterals(format, literals);\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            if (format.indexOf(\"F\") > -1) {\r\n                // F is not supported so we need to replace the F with f based on the milliseconds\r\n                // Replace all sequences of F longer than 3 with \"FFF\"\r\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\r\n                // Based on milliseconds update the format to use fff\r\n                let milliseconds = value.getMilliseconds();\r\n                if (milliseconds % 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\r\n                if ((milliseconds % 100) / 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\r\n                if ((milliseconds % 1000) / 100 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\r\n                if (format === \"\" || format === \"%\")\r\n                    return \"\";\r\n            }\r\n            format = processCustomDateTimeFormat(format);\r\n            result = Globalize.format(value, format, culture);\r\n            result = localize(result, culture.calendar);\r\n            result = FormattingEncoder.restoreLiterals(result, literals);\r\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            return result;\r\n        }\r\n\r\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\r\n        function processCustomDateTimeFormat(format: string): string {\r\n            if (format === _currentCachedFormat) {\r\n                return _currentCachedProcessedFormat;\r\n            }\r\n            _currentCachedFormat = format;\r\n            format = Formatting.fixDateTimeFormat(format);\r\n            _currentCachedProcessedFormat = format;\r\n            return format;\r\n        }\r\n\r\n        /** Localizes the time separator symbol */\r\n        function localize(value: string, dictionary: any): string {\r\n            let timeSeparator = dictionary[\":\"];\r\n            if (timeSeparator === \":\") {\r\n                return value;\r\n            }\r\n            let result = \"\";\r\n            let count = value.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \":\":\r\n                        result += timeSeparator;\r\n                        break;\r\n                    default:\r\n                        result += char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function ensurePatterns(calendar: GlobalizeCalendar) {\r\n            let patterns = calendar.patterns;\r\n            if (patterns[\"g\"] === undefined) {\r\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, short time\r\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, long time\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * NumberFormat module contains the static methods for formatting the numbers.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for numeric types including custom formats.\r\n     */\r\n    export module NumberFormat {\r\n\r\n        const NonScientificFormatRegex = /^\\{.+\\}.*/;\r\n        const NumericalPlaceHolderRegex = /\\{.+\\}/;\r\n        const ScientificFormatRegex = /e[+-]*[0#]+/i;\r\n        const StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\r\n        const TrailingZerosRegex = /0+$/;\r\n        const DecimalFormatRegex = /\\.([0#]*)/g;\r\n        const NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\r\n        const LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\r\n        const DecimalFormatCharacter = '.';\r\n\r\n        export const NumberFormatComponentsDelimeter = ';';\r\n\r\n        export interface NumericFormatMetadata {\r\n            format: string;\r\n            hasEscapes: boolean;\r\n            hasQuotes: boolean;\r\n            hasE: boolean;\r\n            hasCommas: boolean;\r\n            hasDots: boolean;\r\n            hasPercent: boolean;\r\n            hasPermile: boolean;\r\n            precision: number;\r\n            scale: number;\r\n        }\r\n\r\n        export interface NumberFormatComponents {\r\n            hasNegative: boolean;\r\n            positive: string;\r\n            negative: string;\r\n            zero: string;\r\n        }\r\n\r\n        function getNonScientificFormatWithPrecision(baseFormat: string, numericFormat: string): string {\r\n            if (!numericFormat || baseFormat === undefined)\r\n                return baseFormat;\r\n\r\n            let newFormat = \"{0:\" + numericFormat + \"}\";\r\n\r\n            return baseFormat.replace(\"{0}\", newFormat);\r\n        }\r\n\r\n        export function getNumericFormat(value: number, baseFormat: string): string {\r\n            if (baseFormat == null)\r\n                return baseFormat;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n\r\n                if (value > 0)\r\n                    return getNumericFormatFromComponent(value, positive);\r\n                else if (value === 0)\r\n                    return getNumericFormatFromComponent(value, zero);\r\n\r\n                return getNumericFormatFromComponent(value, negative);\r\n            }\r\n\r\n            return getNumericFormatFromComponent(value, baseFormat);\r\n        }\r\n\r\n        function getNumericFormatFromComponent(value: number, format: string): string {\r\n            let match = RegExpExtensions.run(NumericFormatRegex, format);\r\n            if (match)\r\n                return match[0];\r\n\r\n            return format;\r\n        }\r\n\r\n        export function addDecimalsToFormat(baseFormat: string, decimals: number, trailingZeros: boolean): string {\r\n            if (decimals == null)\r\n                return baseFormat;\r\n\r\n            // Default format string\r\n            if (baseFormat == null)\r\n                baseFormat = ZeroPlaceholder;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n                let formats = [positive, negative, zero];\r\n                for (let i = 0; i < formats.length; i++) {\r\n                    // Update format in formats array\r\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\r\n                }\r\n\r\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\r\n            }\r\n\r\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\r\n        }\r\n\r\n        function addDecimalsToFormatComponent(format: string, decimals: number, trailingZeros: boolean): string {\r\n            decimals = Math.abs(decimals);\r\n\r\n            if (decimals >= 0) {\r\n                let placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\r\n                let decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\r\n\r\n                let match = RegExpExtensions.run(DecimalFormatRegex, format);\r\n                if (match) {\r\n                    let beforeDecimal = format.substr(0, match.index);\r\n                    let formatDecimal = format.substr(match.index + 1, match[1].length);\r\n                    let afterDecimal = format.substr(match.index + match[0].length);\r\n\r\n                    if (trailingZeros)\r\n                        // Use explicit decimals argument as placeholders\r\n                        formatDecimal = decimalPlaceholders;\r\n                    else {\r\n                        let decimalChange = decimalPlaceholders.length - formatDecimal.length;\r\n                        if (decimalChange > 0)\r\n                            // Append decimalPlaceholders to existing decimal portion of format string\r\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\r\n                        else if (decimalChange < 0)\r\n                            // Remove decimals from formatDecimal\r\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\r\n                    }\r\n\r\n                    if (formatDecimal.length > 0)\r\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\r\n\r\n                    return beforeDecimal + formatDecimal + afterDecimal;\r\n                }\r\n                else if (decimalPlaceholders.length > 0)\r\n                    // Replace last numeric placeholder with decimal portion\r\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\r\n            }\r\n\r\n            return format;\r\n        }\r\n\r\n        export function hasFormatComponents(format: string): boolean {\r\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\r\n        }\r\n\r\n        export function getComponents(format: string): NumberFormatComponents {\r\n            let signFormat: NumberFormatComponents = {\r\n                hasNegative: false,\r\n                positive: format,\r\n                negative: format,\r\n                zero: format,\r\n            };\r\n\r\n            let signSpecificFormats = format.split(NumberFormatComponentsDelimeter);\r\n            let formatCount = signSpecificFormats.length;\r\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\r\n\r\n            if (formatCount > 1) {\r\n                signFormat.hasNegative = true;\r\n\r\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\r\n                signFormat.negative = signSpecificFormats[1];\r\n\r\n                if (formatCount > 2)\r\n                    signFormat.zero = signSpecificFormats[2];\r\n            }\r\n\r\n            return signFormat;\r\n        }\r\n\r\n        let _lastCustomFormatMeta: NumericFormatMetadata;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = typeof (value) === \"number\";\r\n            return result;\r\n        }\r\n\r\n        export function isStandardFormat(format: string): boolean {\r\n            debug.assertValue(format, 'format');\r\n            return StandardFormatRegex.test(format);\r\n        }\r\n\r\n        /** Formats the number using specified format expression and culture */\r\n        export function format(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture): string {\r\n            format = format || \"G\";\r\n            try {\r\n                if (isStandardFormat(format))\r\n                    return formatNumberStandard(value, format, culture);\r\n\r\n                return formatNumberCustom(value, format, culture);\r\n            } catch (e) {\r\n                return Globalize.format(value, undefined, culture);\r\n            }\r\n        }\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        export function formatWithCustomOverride(\r\n            value: number,\r\n            format: string,\r\n            nonScientificOverrideFormat: string,\r\n            culture: Culture): string {\r\n            debug.assertValue(value, 'value');\r\n            debug.assertValue(format, 'format');\r\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\r\n            debug.assertValue(culture, 'culture');\r\n            debug.assert(!isStandardFormat(format), 'Standard format');\r\n\r\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\r\n        }\r\n\r\n        /** Formats the number using standard format expression */\r\n        function formatNumberStandard(value: number, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let precision = <number>(format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\r\n            let numberFormatInfo = culture.numberFormat;\r\n            let formatChar = format.charAt(0);\r\n            switch (formatChar) {\r\n                case \"e\":\r\n                case \"E\":\r\n                    if (precision === undefined) {\r\n                        precision = 6;\r\n                    }\r\n                    let mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\r\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\r\n                    result = formatNumberCustom(value, format, culture);\r\n                    break;\r\n                case \"f\":\r\n                case \"F\":\r\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    let abs = Math.abs(value);\r\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\r\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\r\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\r\n                    } else {\r\n                        // Otherwise use exponential\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\r\n                        result = result.replace(\"e\", \"E\");\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"r\":\r\n                case \"R\":\r\n                    result = value.toString();\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"x\":\r\n                case \"X\":\r\n                    result = value.toString(16);\r\n                    if (formatChar === \"X\") {\r\n                        result = result.toUpperCase();\r\n                    }\r\n                    if (precision !== undefined) {\r\n                        let actualPrecision = result.length;\r\n                        let isNegative = value < 0;\r\n                        if (isNegative) {\r\n                            actualPrecision--;\r\n                        }\r\n                        let paddingZerosCount = precision - actualPrecision;\r\n                        let paddingZeros = undefined;\r\n                        if (paddingZerosCount > 0) {\r\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\r\n                        }\r\n                        if (isNegative) {\r\n                            result = \"-\" + paddingZeros + result.substr(1);\r\n                        } else {\r\n                            result = paddingZeros + result;\r\n                        }\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                default:\r\n                    result = Globalize.format(value, format, culture);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Formats the number using custom format expression */\r\n        function formatNumberCustom(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture,\r\n            nonScientificOverrideFormat?: string): string {\r\n            let result: string;\r\n            let numberFormatInfo = culture.numberFormat;\r\n            if (isFinite(value)) {\r\n                // Split format by positive[;negative;zero] pattern\r\n                let formatComponents = getComponents(format);\r\n\r\n                // Pick a format based on the sign of value\r\n                if (value > 0) {\r\n                    format = formatComponents.positive;\r\n                } else if (value === 0) {\r\n                    format = formatComponents.zero;\r\n                } else {\r\n                    format = formatComponents.negative;\r\n                }\r\n\r\n                // Normalize value if we have an explicit negative format\r\n                if (formatComponents.hasNegative)\r\n                    value = Math.abs(value);\r\n\r\n                // Get format metadata\r\n                let formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\r\n\r\n                // Preserve literals and escaped chars\r\n                if (formatMeta.hasEscapes) {\r\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%\");\r\n                }\r\n                let literals: string[] = [];\r\n                if (formatMeta.hasQuotes) {\r\n                    format = FormattingEncoder.preserveLiterals(format, literals);\r\n                }\r\n\r\n                // Scientific format\r\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\r\n                    let scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\r\n                    if (scientificMatch) {\r\n                        // Case 2.1. Scientific custom format\r\n                        let formatM = format.substr(0, scientificMatch.index);\r\n                        let formatE = format.substr(scientificMatch.index + 2); // E(+|-)\r\n                        let precision = getCustomFormatPrecision(formatM, formatMeta);\r\n                        let scale = getCustomFormatScale(formatM, formatMeta);\r\n                        if (scale !== 1) {\r\n                            value = value * scale;\r\n                        }\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        let s = value.toExponential(precision);\r\n                        let indexOfE = s.indexOf(\"e\");\r\n                        let mantissa = s.substr(0, indexOfE);\r\n                        let exp = s.substr(indexOfE + 1);\r\n                        let resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\r\n                        let resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\r\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\r\n                            resultE = resultE.substr(1);\r\n                        }\r\n                        let e = scientificMatch[0].charAt(0);\r\n                        result = resultM + e + resultE;\r\n                    }\r\n                }\r\n\r\n                // Non scientific format\r\n                if (result === undefined) {\r\n                    let valueFormatted: string;\r\n                    let isValueGlobalized: boolean = false;\r\n                    let precision = getCustomFormatPrecision(format, formatMeta);\r\n                    let scale = getCustomFormatScale(format, formatMeta);\r\n\r\n                    if (scale !== 1)\r\n                        value = value * scale;\r\n\r\n                    // Rounding\r\n                    value = parseFloat(toNonScientific(value, precision));\r\n\r\n                    if (nonScientificOverrideFormat) {\r\n                        // Get numeric format from format string\r\n                        let numericFormat = NumberFormat.getNumericFormat(value, format);\r\n\r\n                        // Add separators and decimalFormat to nonScientificFormat\r\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\r\n\r\n                        // Format the value\r\n                        valueFormatted = formattingService.format(nonScientificOverrideFormat, [value], culture.name);\r\n                        isValueGlobalized = true;\r\n                    }\r\n                    else\r\n                        valueFormatted = toNonScientific(value, precision);\r\n\r\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\r\n                }\r\n                if (formatMeta.hasQuotes) {\r\n                    result = FormattingEncoder.restoreLiterals(result, literals);\r\n                }\r\n                if (formatMeta.hasEscapes) {\r\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%\");\r\n                }\r\n\r\n                _lastCustomFormatMeta = formatMeta;\r\n            } else {\r\n                return Globalize.format(value, undefined);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Returns string with the fixed point respresentation of the number */\r\n        function toNonScientific(value: number, precision: number): string {\r\n            let result = \"\";\r\n            let precisionZeros = 0;\r\n            // Double precision numbers support actual 15-16 decimal digits of precision.\r\n            if (precision > 16) {\r\n                precisionZeros = precision - 16;\r\n                precision = 16;\r\n            }\r\n            let digitsBeforeDecimalPoint = Double.log10(Math.abs(value));\r\n            if (digitsBeforeDecimalPoint < 16) {\r\n                if (digitsBeforeDecimalPoint > 0) {\r\n                    let maxPrecision = 16 - digitsBeforeDecimalPoint;\r\n                    if (precision > maxPrecision) {\r\n                        precisionZeros += precision - maxPrecision;\r\n                        precision = maxPrecision;\r\n                    }\r\n                }\r\n                result = value.toFixed(precision);\r\n            } else if (digitsBeforeDecimalPoint === 16) {\r\n                result = value.toFixed(0);\r\n                precisionZeros += precision;\r\n                if (precisionZeros > 0) {\r\n                    result += \".\";\r\n                }\r\n            } else { // digitsBeforeDecimalPoint > 16\r\n                // Different browsers have different implementations of the toFixed().\r\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\r\n                // So we need to check for range and convert the to exponential with the max precision.\r\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\r\n                // Assert that value is a number and fall back on returning value if it is not\r\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                if (typeof (value) !== \"number\")\r\n                    return String(value);\r\n                result = value.toExponential(15);\r\n                let indexOfE = result.indexOf(\"e\");\r\n                if (indexOfE > 0) {\r\n                    let indexOfDot = result.indexOf(\".\");\r\n                    let mantissa = result.substr(0, indexOfE);\r\n                    let exp = result.substr(indexOfE + 1);\r\n                    let powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\r\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\r\n                    if (precision > 0) {\r\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\r\n                    }\r\n                }\r\n            }\r\n            if (precisionZeros > 0) {\r\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the formatMetadata of the format\r\n         * When calculating precision and scale, if format string of\r\n         * positive[;negative;zero] => positive format will be used\r\n         * @param (required) format - format string\r\n         * @param (optional) calculatePrecision - calculate precision of positive format\r\n         * @param (optional) calculateScale - calculate scale of positive format\r\n         */\r\n        export function getCustomFormatMetadata(format: string, calculatePrecision?: boolean, calculateScale?: boolean): NumericFormatMetadata {\r\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\r\n                return _lastCustomFormatMeta;\r\n            }\r\n\r\n            let result = {\r\n                format: format,\r\n                hasEscapes: false,\r\n                hasQuotes: false,\r\n                hasE: false,\r\n                hasCommas: false,\r\n                hasDots: false,\r\n                hasPercent: false,\r\n                hasPermile: false,\r\n                precision: undefined,\r\n                scale: undefined,\r\n            };\r\n\r\n            for (let i = 0, length = format.length; i < length; i++) {\r\n                let c = format.charAt(i);\r\n                switch (c) {\r\n                    case \"\\\\\":\r\n                        result.hasEscapes = true;\r\n                        break;\r\n                    case \"'\":\r\n                    case \"\\\"\":\r\n                        result.hasQuotes = true;\r\n                        break;\r\n                    case \"e\":\r\n                    case \"E\":\r\n                        result.hasE = true;\r\n                        break;\r\n                    case \",\":\r\n                        result.hasCommas = true;\r\n                        break;\r\n                    case \".\":\r\n                        result.hasDots = true;\r\n                        break;\r\n                    case \"%\":\r\n                        result.hasPercent = true;\r\n                        break;\r\n                    case \"\":\r\n                        result.hasPermile = true;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Use positive format for calculating these values\r\n            let formatComponents = getComponents(format);\r\n\r\n            if (calculatePrecision)\r\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\r\n            if (calculateScale)\r\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\r\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\r\n        function getCustomFormatPrecision(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.precision > -1) {\r\n                return formatMeta.precision;\r\n            }\r\n            let result = 0;\r\n            if (formatMeta.hasDots) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex > -1) {\r\n                    let count = format.length;\r\n                    for (let i = dotIndex; i < count; i++) {\r\n                        let char = format.charAt(i);\r\n                        if (char.match(NumericPlaceholderRegex))\r\n                            result++;\r\n                        // 0.00E+0 :: Break before counting 0 in\r\n                        // exponential portion of format string\r\n                        if (char === ExponentialFormatChar)\r\n                            break;\r\n                    }\r\n                    result = Math.min(19, result);\r\n                }\r\n            }\r\n\r\n            formatMeta.precision = result;\r\n            return result;\r\n        }\r\n\r\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\r\n        function getCustomFormatScale(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.scale > -1) {\r\n                return formatMeta.scale;\r\n            }\r\n            let result = 1;\r\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\r\n                result = result * 100;\r\n            }\r\n            if (formatMeta.hasPermile && format.indexOf(\"\") > -1) {\r\n                result = result * 1000;\r\n            }\r\n            if (formatMeta.hasCommas) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex === -1) {\r\n                    dotIndex = format.length;\r\n                }\r\n                for (let i = dotIndex - 1; i > -1; i--) {\r\n                    let char = format.charAt(i);\r\n                    if (char === \",\") {\r\n                        result = result / 1000;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            formatMeta.scale = result;\r\n            return result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormat(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, nonScientificOverrideFormat?: string, isValueGlobalized?: boolean): string {\r\n            let suppressModifyValue = !!nonScientificOverrideFormat;\r\n            let formatParts = format.split(\".\", 2);\r\n            if (formatParts.length === 2) {\r\n                let wholeFormat = formatParts[0];\r\n                let fractionFormat = formatParts[1];\r\n                let displayUnit = \"\";\r\n\r\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\r\n                if (nonScientificOverrideFormat) {\r\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\r\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\r\n                    value = value.replace(displayUnit, \"\");\r\n                }\r\n\r\n                let globalizedDecimalSeparator = numberFormatInfo[\".\"];\r\n                let decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\r\n                let valueParts = value.split(decimalSeparator, 2);\r\n                let wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\r\n                let fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\r\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\r\n\r\n                let wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\r\n                let fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\r\n\r\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\r\n                    return wholeFormattedValue + fractionFormattedValue.value;\r\n\r\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\r\n            }\r\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatLeft(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, suppressModifyValue?: boolean): string {\r\n            let groupSymbolIndex = format.indexOf(\",\");\r\n            let enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\r\n            let groupDigitCount = 0;\r\n            let groupIndex = 0;\r\n            let groupSizes = numberFormatInfo.groupSizes || [3];\r\n            let groupSize = groupSizes[0];\r\n            let groupSeparator = numberFormatInfo[\",\"];\r\n            let sign = \"\";\r\n            let firstChar = value.charAt(0);\r\n            if (firstChar === \"+\" || firstChar === \"-\") {\r\n                sign = numberFormatInfo[firstChar];\r\n                value = value.substr(1);\r\n            }\r\n            let isZero = value === \"0\";\r\n            let result = \"\";\r\n            let leftBuffer = \"\";\r\n            let vi = value.length - 1;\r\n            let fmtOnly = true;\r\n            // Iterate through format chars and replace 0 and # with the digits from the value string\r\n            for (let fi = format.length - 1; fi > -1; fi--) {\r\n                let formatChar = format.charAt(fi);\r\n                switch (formatChar) {\r\n                    case ZeroPlaceholder:\r\n                    case DigitPlaceholder:\r\n                        fmtOnly = false;\r\n                        if (leftBuffer !== \"\") {\r\n                            result = leftBuffer + result;\r\n                            leftBuffer = \"\";\r\n                        }\r\n                        if (!suppressModifyValue) {\r\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\r\n                                if (enableGroups) {\r\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\r\n                                    if (groupDigitCount === groupSize) {\r\n                                        result = groupSeparator + result;\r\n                                        groupIndex++;\r\n                                        if (groupIndex < groupSizes.length) {\r\n                                            groupSize = groupSizes[groupIndex];\r\n                                        }\r\n                                        groupDigitCount = 1;\r\n                                    } else {\r\n                                        groupDigitCount++;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (vi > -1) {\r\n                                if (isZero && formatChar === DigitPlaceholder) {\r\n                                    // Special case - if we need to format a zero value and the # symbol is used - we don't copy it into the result)\r\n                                } else {\r\n                                    result = value.charAt(vi) + result;\r\n                                }\r\n                                vi--;\r\n                            } else if (formatChar !== DigitPlaceholder) {\r\n                                result = formatChar + result;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \",\":\r\n                        // We should skip all the , chars\r\n                        break;\r\n                    default:\r\n                        leftBuffer = formatChar + leftBuffer;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\r\n            if (!suppressModifyValue) {\r\n                if (vi > -1 && result !== \"\") {\r\n                    if (enableGroups) {\r\n                        while (vi > -1) {\r\n                            if (groupDigitCount === groupSize) {\r\n                                result = groupSeparator + result;\r\n                                groupIndex++;\r\n                                if (groupIndex < groupSizes.length) {\r\n                                    groupSize = groupSizes[groupIndex];\r\n                                }\r\n                                groupDigitCount = 1;\r\n                            } else {\r\n                                groupDigitCount++;\r\n                            }\r\n                            result = value.charAt(vi) + result;\r\n                            vi--;\r\n                        }\r\n                    } else {\r\n                        result = value.substr(0, vi + 1) + result;\r\n                    }\r\n                }\r\n                // Insert sign in front of the leftBuffer and result\r\n                return sign + leftBuffer + result;\r\n            }\r\n\r\n            if (fmtOnly)\r\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\r\n                return sign + leftBuffer + result;\r\n\r\n            return sign + leftBuffer + value + result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatRight(value: string, format: string, suppressModifyValue?: boolean): { value: string; fmtOnly?: boolean } {\r\n            let vi = 0;\r\n            let fCount = format.length;\r\n            let vCount = value.length;\r\n\r\n            if (suppressModifyValue) {\r\n                debug.assert(fCount > 0, \"Empty formatting string\");\r\n\r\n                let lastChar = format.charAt(fCount - 1);\r\n                if (!lastChar.match(NumericPlaceholderRegex))\r\n                    return {\r\n                        value: value + lastChar,\r\n                        fmtOnly: value === \"\",\r\n                    };\r\n\r\n                return {\r\n                    value: value,\r\n                    fmtOnly: value === \"\",\r\n                };\r\n            }\r\n\r\n            let result = \"\",\r\n                fmtOnly: boolean = true;\r\n            for (let fi = 0; fi < fCount; fi++) {\r\n                let formatChar = format.charAt(fi);\r\n                if (vi < vCount) {\r\n                    switch (formatChar) {\r\n                        case ZeroPlaceholder:\r\n                        case DigitPlaceholder:\r\n                            result += value[vi++];\r\n                            fmtOnly = false;\r\n                            break;\r\n                        default:\r\n                            result += formatChar;\r\n                    }\r\n                } else {\r\n                    if (formatChar !== DigitPlaceholder) {\r\n                        result += formatChar;\r\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                value: result,\r\n                fmtOnly: fmtOnly,\r\n            };\r\n        }\r\n\r\n        function localize(value: string, dictionary: any): string {\r\n            let plus = dictionary[\"+\"];\r\n            let minus = dictionary[\"-\"];\r\n            let dot = dictionary[\".\"];\r\n            let comma = dictionary[\",\"];\r\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\r\n                return value;\r\n            }\r\n            let count = value.length;\r\n            let result = \"\";\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \"+\":\r\n                        result = result + plus;\r\n                        break;\r\n                    case \"-\":\r\n                        result = result + minus;\r\n                        break;\r\n                    case \".\":\r\n                        result = result + dot;\r\n                        break;\r\n                    case \",\":\r\n                        result = result + comma;\r\n                        break;\r\n                    default:\r\n                        result = result + char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n    }\r\n\r\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\r\n    class DateTimeScaleFormatInfo {\r\n\r\n        // Fields\r\n        public YearPattern: string;\r\n        public MonthPattern: string;\r\n        public DayPattern: string;\r\n        public HourPattern: string;\r\n        public MinutePattern: string;\r\n        public SecondPattern: string;\r\n        public MillisecondPattern: string;\r\n\r\n        // Constructor\r\n        /**\r\n         * Creates new instance of the DateTimeScaleFormatInfo class.\r\n         * @param culture - culture which calendar info is going to be used to derive the formats.\r\n         */\r\n        constructor(culture: Culture) {\r\n            let calendar: Calendar = culture.calendar;\r\n            let patterns: any = calendar.patterns;\r\n            let monthAbbreviations: any = calendar[\"months\"][\"namesAbbr\"];\r\n            let cultureHasMonthAbbr: boolean = monthAbbreviations && monthAbbreviations[0];\r\n            let yearMonthPattern: string = patterns[\"Y\"];\r\n            let monthDayPattern: string = patterns[\"M\"];\r\n            let fullPattern: string = patterns[\"f\"];\r\n            let longTimePattern: string = patterns[\"T\"];\r\n            let shortTimePattern: string = patterns[\"t\"];\r\n            let separator: string = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\r\n\r\n            let hasYearSymbol: boolean = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\r\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\r\n\r\n            let yearPos: number = fullPattern.indexOf(\"yy\");\r\n            let monthPos: number = fullPattern.indexOf(\"MMMM\");\r\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\r\n\r\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\r\n\r\n            let minutePos: number = fullPattern.indexOf(\"mm\");\r\n            let pmPos: number = fullPattern.indexOf(\"tt\");\r\n            let shortHourPattern: string = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\r\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\r\n\r\n            this.MinutePattern = shortTimePattern;\r\n\r\n            this.SecondPattern = longTimePattern;\r\n\r\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\r\n\r\n            // Special cases\r\n            switch (culture.name) {\r\n                case \"fi-FI\":\r\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\r\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Methods\r\n\r\n        /**\r\n         * Returns the format string of the provided DateTimeUnit.\r\n         * @param unit - date or time unit\r\n         */\r\n        public getFormatString(unit: DateTimeUnit): string {\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return this.YearPattern;\r\n                case DateTimeUnit.Month:\r\n                    return this.MonthPattern;\r\n                case DateTimeUnit.Week:\r\n                case DateTimeUnit.Day:\r\n                    return this.DayPattern;\r\n                case DateTimeUnit.Hour:\r\n                    return this.HourPattern;\r\n                case DateTimeUnit.Minute:\r\n                    return this.MinutePattern;\r\n                case DateTimeUnit.Second:\r\n                    return this.SecondPattern;\r\n                case DateTimeUnit.Millisecond:\r\n                    return this.MillisecondPattern;\r\n            }\r\n\r\n            debug.assertFail('Unexpected unit: ' + unit);\r\n        }\r\n    }\r\n\r\n    export var formattingService: IFormattingService = new FormattingService();\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\r\n    export module SQExprShortSerializer {\r\n        export function serialize(expr: SQExpr): string {\r\n            return JSON.stringify(expr.accept(SQExprSerializer.instance));\r\n        }\r\n\r\n        export function serializeArray(exprs: SQExpr[]): string {\r\n            let str = '[';\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                if (i > 0)\r\n                    str += ',';\r\n                str += SQExprShortSerializer.serialize(exprs[i]);\r\n            }\r\n            return str + ']';\r\n        }\r\n\r\n        /** Responsible for serializing an SQExpr into a comparable string. */\r\n        class SQExprSerializer extends DefaultSQExprVisitor<{}> {\r\n            public static instance: SQExprSerializer = new SQExprSerializer();\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): {} {\r\n                return {\r\n                    col: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): {} {\r\n                return {\r\n                    measure: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): {} {\r\n                return {\r\n                    agg: {\r\n                        a: expr.arg.accept(this),\r\n                        f: expr.func,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitEntity(expr: SQEntityExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n                debug.assertValue(expr.entity, 'expr.entity');\r\n\r\n                return {\r\n                    e: expr.entity\r\n                };\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): {} {\r\n                return {\r\n                    h: expr.arg.accept(this),\r\n                    l: expr.level,\r\n                };\r\n            }\r\n\r\n            public visitHierarchy(expr: SQHierarchyExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    h: expr.hierarchy,\r\n                };\r\n            }\r\n\r\n            public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    n: expr.name,\r\n                    p: expr.property,\r\n                };\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    and: {\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    comp: {\r\n                        k: expr.comparison,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    const: {\r\n                        t: expr.type.primitiveType,\r\n                        v: expr.value,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    arithmetic: {\r\n                        o: expr.operator,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitScopedEval(expr: SQScopedEvalExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    scopedEval: {\r\n                        e: expr.expression.accept(this),\r\n                        s: serializeArray(expr.scope)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): {} {\r\n                debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n    import Selector = powerbi.data.Selector;\r\n    import SelectorsByColumn = powerbi.SelectorsByColumn;\r\n    import SelectorForColumn = powerbi.SelectorForColumn;\r\n\r\n    /**\r\n     * A combination of identifiers used to uniquely identify\r\n     * data points and their bound geometry.\r\n     */\r\n    export class SelectionId implements ISelectionId {\r\n        private selector: Selector;\r\n        // This is a new data structure to support drilling -- in the long term it should replace the 'selector' field\r\n        private selectorsByColumn: SelectorsByColumn;\r\n        private key: string;\r\n        private keyWithoutHighlight: string;\r\n\r\n        public highlight: boolean;\r\n\r\n        constructor(selector: Selector, highlight: boolean) {\r\n            this.selector = selector;\r\n            this.highlight = highlight;\r\n            this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\r\n            this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\r\n        }\r\n\r\n        public equals(other: SelectionId): boolean {\r\n            if (!this.selector || !other.selector) {\r\n                return (!this.selector === !other.selector) && this.highlight === other.highlight;\r\n            }\r\n            return this.highlight === other.highlight &&  Selector.equals(this.selector, other.selector);\r\n        }\r\n        \r\n        /**\r\n         * Checks equality against other for all identifiers existing in this.\r\n         */\r\n        public includes(other: SelectionId, ignoreHighlight: boolean = false): boolean {\r\n            let thisSelector = this.selector;\r\n            let otherSelector = other.selector;\r\n            if (!thisSelector || !otherSelector) {\r\n                return false;\r\n            }\r\n            let thisData = thisSelector.data;\r\n            let otherData = otherSelector.data;\r\n            if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\r\n                return false;\r\n            if (!ignoreHighlight && this.highlight !== other.highlight)\r\n                return false;\r\n            if (thisData) {\r\n                if (!otherData)\r\n                    return false;\r\n                if (thisData.length > 0) {\r\n                    for (let i = 0, ilen = thisData.length; i < ilen; i++) {\r\n                        var thisValue = <DataViewScopeIdentity>thisData[i];\r\n                        if (!otherData.some((otherValue: DataViewScopeIdentity) => DataViewScopeIdentity.equals(thisValue, otherValue)))\r\n                            return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public getKey(): string {\r\n            return this.key;\r\n        }\r\n\r\n        public getKeyWithoutHighlight(): string {\r\n            return this.keyWithoutHighlight;\r\n        }\r\n        \r\n        public hasIdentity(): boolean {\r\n            return (this.selector && !!this.selector.data);\r\n        }\r\n\r\n        public getSelector(): Selector {\r\n            return this.selector;\r\n        }\r\n\r\n        public getSelectorsByColumn(): Selector {\r\n            return this.selectorsByColumn;\r\n        }\r\n\r\n        public static createNull(highlight: boolean = false): SelectionId {\r\n            return new SelectionId(null, highlight);\r\n        }\r\n\r\n        public static createWithId(id: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            if (id) {\r\n                selector = {\r\n                    data: [id]\r\n                };\r\n            }\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithMeasure(measureId: string, highlight: boolean = false): SelectionId {\r\n            debug.assertValue(measureId, 'measureId');\r\n\r\n            let selector: Selector = {\r\n                metadata: measureId\r\n            };\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n            selectionId.selectorsByColumn = { metadata: measureId };\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasure(id: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: powerbi.data.Selector = {};\r\n            if (id) {\r\n                selector.data = [id];\r\n            }\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id && !measureId)\r\n                selector = null;\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasureAndCategory(id: DataViewScopeIdentity, measureId: string, queryName: string, highlight: boolean = false): SelectionId {\r\n            let selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\r\n\r\n            if (selectionId.selector) {\r\n                selectionId.selectorsByColumn = {};\r\n                if (id && queryName) {\r\n                    selectionId.selectorsByColumn.dataMap = {};\r\n                    selectionId.selectorsByColumn.dataMap[queryName] = id;\r\n                }\r\n                if (measureId)\r\n                    selectionId.selectorsByColumn.metadata = measureId;\r\n            }\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIds(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector = { data: selectorData };\r\n            \r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithIdsAndMeasure(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = {};\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector.data = selectorData;\r\n\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id1 && !id2 && !measureId)\r\n                selector = null;\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithSelectorForColumnAndMeasure(dataMap: SelectorForColumn, measureId: string, highlight: boolean = false): SelectionId {\r\n\r\n            let selectionId: visuals.SelectionId;\r\n            let keys = Object.keys(dataMap);\r\n            if (keys.length === 2) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], <DataViewScopeIdentity>dataMap[keys[1]], measureId, highlight);\r\n            } else if (keys.length === 1) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], null, measureId, highlight);\r\n            } else {\r\n                selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\r\n            }\r\n\r\n            let selectorsByColumn: SelectorsByColumn = {};\r\n            if (!_.isEmpty(dataMap))\r\n                selectorsByColumn.dataMap = dataMap;\r\n            if (measureId)\r\n                selectorsByColumn.metadata = measureId;\r\n            if (!dataMap && !measureId)\r\n                selectorsByColumn = null;\r\n\r\n            selectionId.selectorsByColumn = selectorsByColumn;\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithHighlight(original: SelectionId): SelectionId {\r\n            debug.assertValue(original, 'original');\r\n            debug.assert(!original.highlight, '!original.highlight');\r\n\r\n            let newId = new SelectionId(original.getSelector(), /*highlight*/ true);\r\n            newId.selectorsByColumn = original.selectorsByColumn;\r\n\r\n            return newId;\r\n        }\r\n\r\n        private static idArray(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity): DataViewScopeIdentity[] {\r\n            if (id1 || id2) {\r\n                let data = [];\r\n                if (id1)\r\n                    data.push(id1);\r\n                if (id2 && id2 !== id1)\r\n                    data.push(id2);\r\n                return data;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This class is designed to simplify the creation of SelectionId objects\r\n     * It allows chaining to build up an object before calling 'create' to build a SelectionId\r\n     */\r\n    export class SelectionIdBuilder implements ISelectionIdBuilder {\r\n        private dataMap: SelectorForColumn;\r\n        private measure: string;\r\n\r\n        public static builder(): SelectionIdBuilder {\r\n            return new SelectionIdBuilder();\r\n        }\r\n\r\n        public withCategory(categoryColumn: DataViewCategoryColumn, index: number): this{\r\n            if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\r\n                this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\r\n            \r\n            return this;\r\n        }\r\n\r\n        public withSeries(seriesColumn: DataViewValueColumns, valueColumn: DataViewValueColumn | DataViewValueColumnGroup): this {\r\n            if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\r\n                this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\r\n\r\n            return this;\r\n        }\r\n\r\n        public withMeasure(measureId: string): this {\r\n            this.measure = measureId;\r\n\r\n            return this;\r\n        }\r\n\r\n        public createSelectionId(): SelectionId {\r\n            return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\r\n        }\r\n\r\n        private ensureDataMap(): SelectorForColumn {\r\n            if (!this.dataMap)\r\n                this.dataMap = {};\r\n\r\n            return this.dataMap;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"/source/"}