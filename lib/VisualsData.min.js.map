{"version":3,"sources":["VisualsData.js","../ts/visualsData/semanticQuery/sqExprVisitor.ts","../ts/visualsData/types/enumType.ts","../ts/visualsData/types/fill.ts","../ts/visualsData/types/image.ts","../ts/visualsData/types/structuralType.ts","../ts/visualsData/types/valueType.ts","../ts/visualsData/contracts/dataShapeBinding.ts","../ts/visualsData/contracts/dataShapeBindingDataReduction.ts","../ts/visualsData/contracts/federatedConceptualSchema.ts","../ts/visualsData/contracts/selector.ts","../ts/visualsData/contracts/query.ts","../ts/visualsData/contracts/queryProjection.ts","../ts/visualsData/contracts/visualData.ts","../ts/visualsData/formatting/dateTimeSequence.ts","../ts/visualsData/formatting/displayUnitSystem.ts","../ts/visualsData/formatting/numericSequence.ts","../ts/visualsData/formatting/numericSequenceRange.ts","../ts/visualsData/formatting/valueFormatter.ts","../ts/visualsData/dataView/dataRoleHelper.ts","../ts/visualsData/dataView/dataViewCategoricalReader.ts","../ts/visualsData/dataView/dataViewConcatenateCategoricalColumns.ts","../ts/visualsData/dataView/dataViewMappingVisitor.ts","../ts/visualsData/dataView/dataViewNormalizeValues.ts","../ts/visualsData/dataView/dataViewObject.ts","../ts/visualsData/dataView/dataViewObjectDefinition.ts","../ts/visualsData/dataView/dataViewObjectDescriptor.ts","../ts/visualsData/dataView/dataViewObjectEvaluationUtils.ts","../ts/visualsData/dataView/dataViewObjectEvaluator.ts","../ts/visualsData/dataView/dataViewPivotCategorical.ts","../ts/visualsData/dataView/dataViewPivotMatrix.ts","../ts/visualsData/dataView/dataViewSelfCrossJoin.ts","../ts/visualsData/dataView/dataViewPivotCategoricalToPrimaryGroups.ts","../ts/visualsData/dataView/dataViewTransform.ts","../ts/visualsData/displayNameGetter.ts","../ts/visualsData/iFormattingService.ts","../ts/visualsData/semanticQuery/exprPatterns/fieldExprPattern.ts","../ts/visualsData/dataView/dataViewAnalysis.ts","../ts/visualsData/dataView/dataViewRoleWildcard.ts","../ts/visualsData/dataView/dataViewScopeIdentity.ts","../ts/visualsData/dataView/dataViewScopeWildcard.ts","../ts/visualsData/dataView/rules/colorAllocatorCache.ts","../ts/visualsData/dataView/dataViewRegression.ts","../ts/visualsData/dataView/dataViewSelectTransform.ts","../ts/visualsData/dataView/rules/categoricalEvalContext.ts","../ts/visualsData/dataView/rules/tableEvalContext.ts","../ts/visualsData/dataView/rules/ruleEvaluation.ts","../ts/visualsData/dataView/rules/colorRuleEvaluation.ts","../ts/visualsData/dataView/utils/dataViewMatrixUtils.ts","../ts/visualsData/dataView/utils/dataViewMetadataColumnUtils.ts","../ts/visualsData/contracts/conceptualSchema.ts","../ts/visualsData/dataView/scriptResultUtil.ts","../ts/visualsData/segmentation/dataViewMerger.ts","../ts/visualsData/semanticQuery/sqExprRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/equalsToInRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/filterScopeIdsCollector.ts","../ts/visualsData/semanticQuery/exprPatterns/scopeIdentityExtractor.ts","../ts/visualsData/semanticQuery/primitiveValueEncoding.ts","../ts/visualsData/semanticQuery/sqAggregationOperations.ts","../ts/visualsData/semanticQuery/sqHierarchyExprUtils.ts","../ts/visualsData/semanticQuery/sqExprGroupUtils.ts","../ts/visualsData/semanticQuery/sqExpr.ts","../ts/visualsData/semanticQuery/sqExprUtils.ts","../ts/visualsData/semanticQuery/semanticQueryRewriter.ts","../ts/visualsData/semanticQuery/semanticQuery.ts","../ts/visualsData/dataView/dataViewBuilder.ts","../ts/visualsData/dataView/rules/staticEvalContext.ts","../ts/visualsData/dataView/rules/matrixEvalContext.ts","../ts/visualsData/services/formattingService.ts","../ts/visualsData/services/serialization/sqExprShortSerializer.ts","../ts/visualsData/selection/selectionId.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","powerbi","data","DefaultSQExprVisitorWithArg","visitEntity","expr","arg","visitDefault","visitColumnRef","visitMeasureRef","visitAggr","visitHierarchy","visitHierarchyLevel","visitPropertyVariationSource","visitBetween","visitIn","visitAnd","visitOr","visitCompare","visitContains","visitExists","visitNot","visitStartsWith","visitConstant","visitDateSpan","visitDateAdd","visitNow","visitDefaultValue","visitAnyValue","visitArithmetic","visitFillRule","visitResourcePackageItem","visitScopedEval","DefaultSQExprVisitor","_super","apply","arguments","DefaultSQExprVisitorWithTraversal","source","accept","lower","upper","args","i","len","length","values","valueTuple","j","jlen","left","right","input","rule","gradient2","linearGradient2","gradient3","linearGradient3","visitLinearGradient2","visitLinearGradient3","visitFillRuleStop","min","max","mid","expression","_i","_a","scope","scopeExpr","stop","color","value","createEnumType","members","EnumType","allMembers","validMembers","membersToReturn","allMembers_1","member","_","contains","push","FillSolidColorTypeDescriptor","nullable","descriptor","advancedDescriptor","ImageDefinition","urlType","misc","imageUrl","StructuralTypeDescriptor","isValid","type","fill","fillRule","filter","image","paragraphs","getPrimitiveType","extendedType","PrimitiveTypeMask","isPrimitiveType","PrimitiveTypeWithFlagsMask","getCategoryFromExtendedType","category","ExtendedType","delimIdx","lastIndexOf","baseCategory","slice","toExtendedType","primitiveType","primitiveString","PrimitiveType","t","Null","categoryType","categoryPrimitiveType","matchesExtendedTypeWithAnyPrimitive","a","PrimitiveTypeFlagsExcludedMask","EnumExtensions","jsCommon","ValueType","enumType","underlyingType","hasFlag","Temporal","temporalType","TemporalType","Geography","geographyType","GeographyType","Miscellaneous","miscType","MiscellaneousType","Formatting","formattingType","FormattingType","Enumeration","Scripting","scriptingType","ScriptType","fromDescriptor","text","fromExtendedType","Text","integer","Integer","numeric","Double","bool","Boolean","dateTime","DateTime","duration","Duration","binary","Binary","none","None","scripting","ScriptSource","enumeration","fromEnum","temporal","year","Year_Integer","month","Month_Integer","geography","address","Address","city","City","continent","Continent","country","Country","county","County","region","Region","postalCode","PostalCode_Text","stateOrProvince","StateOrProvince","place","Place","latitude","Latitude_Double","longitude","Longitude_Double","Image","ImageUrl","webUrl","WebUrl","formatting","Color","formatString","FormatString","alignment","Alignment","labelDisplayUnits","LabelDisplayUnits","fontSize","FontSize","labelDensity","LabelDensity","fromPrimitiveTypeAndCategory","id","toString","typeCache","isCompatibleTo","otherTypes","valueType","otherTypes_1","otherType","otherValueType","isCompatibleFrom","other","otherPrimitiveType","defineProperty","get","enumerable","configurable","Numeric","Date","Time","Year","Month","PostalCode","Latitude","Longitude","DataShapeBindingLimitType","SubtotalType","DataShapeBindingDataReduction","createFrom","reduction","result","top","Top","count","Count","bottom","Bottom","sample","Sample","window","Window","FederatedConceptualSchema","options","schemas","links","schema","name","data_1","Selector","filterFromSelector","selectors","isNot","isEmpty","exprs","ilen","identity","data_2","exprToAdd","undefined","SQExprBuilder","and","DataViewScopeIdentity","filterFromExprs","matchesData","selector","identities","selectorData","dataItem","selectorDataItem","equals","DataViewScopeWildcard","matches","matchesKeys","keysList","selectorDataLength","selectorDataExprs","ScopeIdentityExtractor","getKeys","SQExprUtils","sequenceEqual","x","y","metadata","equalsDataArray","equalsData","getKey","toStringify","data_3","key","JSON","stringify","containsWildcard","dataItems","dataItems_1","wildCard","roles","hasRoleWildcard","dataItems_2","isRoleWildcard","getArithmeticOperatorName","arithmeticOperatorKind","Error","EntitySourceType","TimeUnit","QueryAggregateFunction","QueryComparisonKind","SemanticType","FilterKind","QueryProjectionCollection","items","activeProjectionRefs","showAll","_activeProjectionRefs","_showAll","all","set","queryReferences","queryRefs","map","val","queryRef","queryReferences_1","queryReference","addActiveQueryReference","getLastActiveQueryReference","clone","QueryProjectionsByRole","clonedRoles","roleName","getRole","DisplayUnitSystemType","DateTimeSequence","unit","sequence","add","date","extendToCover","addInterval","interval","splice","moveToCover","delta","getDelta","Math","floor","calculate","dataMin","dataMax","expectedCount","getIntervalUnit","DateTimeUnit","calculateYears","calculateMonths","Week","calculateWeeks","Day","calculateDays","Hour","calculateHours","Minute","calculateMinutes","Second","calculateSeconds","Millisecond","calculateMilliseconds","yearsRange","NumericSequenceRange","calculateDataRange","getFullYear","NumericSequence","newMinYear","fromNumericSequence","minYear","maxYear","minMonth","getMonth","maxMonth","calculateUnits","firstDayOfWeek","minDayOfWeek","getDay","dayOffset","minDay","getDate","ceilWithPrecision","floorWithPrecision","getHours","getMinutes","getSeconds","intervalOffset","round","DateUtils","addYears","addMonths","addWeeks","addDays","addHours","addMinutes","addSeconds","addMilliseconds","getTime","maxCount","totalDays","totalHours","totalMinutes","totalSeconds","totalMilliseconds","getMilliseconds","MIN_COUNT","MAX_COUNT","isLeap","getMonthDays","MonthDaysLeap","MonthDays","yearDelta","day","isLeapDay","setFullYear","monthDelta","weeks","days","hours","minutes","seconds","milliseconds","createDisplayUnits","unitLookup","adjustMinBasedOnPreviousUnit","units","maxExponent","names","addUnitIfNonEmpty","pow10","title","format","labelFormat","previousUnit","applicableRangeMax","DisplayUnit","applicableRangeMin","defaultScientificBigNumbersBoundary","scientificSmallNumbersBoundary","PERCENTAGE_FORMAT","SCIENTIFIC_FORMAT","DEFAULT_SCIENTIFIC_FORMAT","SUPPORTED_SCIENTIFIC_FORMATS","project","removeDecimalNoise","reverseProject","isApplicableTo","abs","precision","getPrecision","greaterOrEqualWithPrecision","lessWithPrecision","isScaling","DisplayUnitSystem","displayUnit","update","unitBaseValue","findApplicableDisplayUnit","decimals","trailingZeros","isFormatSupported","getNumberOfDecimalsForFormatting","hasScientitifcFormat","formatHelper","isScalingUnit","shouldRespectScalingUnit","formattingService","formatValue","UNSUPPORTED_FORMATS","test","isPercentageFormat","indexOf","nonScientificFormat","visuals","valueFormatter","DefaultNumericFormat","NumberFormat","addDecimalsToFormat","isStandardNumberFormat","formatNumberWithCustomOverride","formatSingleValue","shouldUseValuePrecision","isScientific","toUpperCase","supportsScientificFormat","shouldFallbackToScientific","getScientificFormat","numericFormat","getNumericFormat","NoDisplayUnitSystem","call","DefaultDisplayUnitSystem","getUnits","reset","previousUnitValue","Infinity","WholeUnitsDisplayUnitSystem","DataLabelsDisplayUnitSystem","AUTO_DISPLAYUNIT_VALUE","NONE_DISPLAYUNIT_VALUE","concat","range","maxAllowedMargin","minPower","useZeroRefPoint","steps","ensureInRange","MIN_EXP","forcedSingleStop","getSize","canExtendMin","hasFixedMin","canExtendMax","hasFixedMax","size","exp","log10","stepExp","expectedCountExp","power","roundMin","floorToPrecision","roundMax","ceilToPrecision","roundRange","calculateFixedRange","shrinkByStep","dexp","e","stepsCount","stepPower","step","roundToPrecision","trimMinMax","stepCount","maxStepCount","minStepCount","offset","minMargin","maxMargin","marginPrecision","_ensureIncludeZero","includeZero","_ensureNotEmpty","DEFAULT_MAX","_ensureDirection","temp","oldCount","newCount","deltaCount","ceil","fixedMin","fixedMax","hasDataRange","ValueUtil","hasValue","MIN_SUPPORTED_DOUBLE","MAX_SUPPORTED_DOUBLE","beautify","BeautifiedFormat","defaultLocalizedStrings","describeUnit","exponent","exponentLookup","getLocalizedString","stringId","getFormatMetadata","getCustomFormatMetadata","setLocaleOptions","locale","createDefaultFormatter","allowFormatBeautification","formatBeaut","formatCore","shouldUseNumericDisplayUnits","displayUnitSystem_1","createDisplayUnitSystem","displayUnitSystemType","singleValueFormattingMode_1","formatSingleValues","value2","decimals_1","forcePrecision_1","MaxScaledDecimalPlaces","detectAxisPrecision","axisValue","isInteger","formattedValue","getStringFormat","StringExtensions","isNullOrUndefinedOrWhiteSpaceString","MaxValueForDisplayUnitRounding","shouldUseDateUnits","tickCount","unit_1","dateFormatString","getValueFormat","columnType","getFormatString","DateTimeMetadataColumn","formatValueColumn","column","formatStringProp","valueFormat","describe","Default","WholeUnits","Verbose","DataLabels","MinIntegerValueForDisplayUnits","isCustomFormat","isStandardFormat","MinPrecisionForDisplayUnits","formatStringProperty","suppressTypeFallback","propertyValue","DataViewObjects","getValue","objects","DefaultDateFormat","DefaultIntegerFormat","formatListCompound","strings","conjunction","lastIndex","restatementComma","formatListAnd","restatementCompoundAnd","formatListOr","restatementCompoundOr","nullsAreBlank","isNaN","NaN","Number","NEGATIVE_INFINITY","negativeInfinity","POSITIVE_INFINITY","infinity","getDisplayUnits","displayUnitSystem","0.00 %;-0.00 %;0.00 %","0.0 %;-0.0 %;0.0 %","NullValue","BooleanTrue","BooleanFalse","NaNValue","InfinityValue","NegativeInfinityValue","RestatementComma","RestatementCompoundAnd","RestatementCompoundOr","DisplayUnitSystem_EAuto_Title","DisplayUnitSystem_E0_Title","DisplayUnitSystem_E3_LabelFormat","DisplayUnitSystem_E3_Title","DisplayUnitSystem_E6_LabelFormat","DisplayUnitSystem_E6_Title","DisplayUnitSystem_E9_LabelFormat","DisplayUnitSystem_E9_Title","DisplayUnitSystem_E12_LabelFormat","DisplayUnitSystem_E12_Title","Percentage","Percentage1","TableTotalLabel","Tooltip_HighlightedValueDisplayName","Funnel_PercentOfFirst","Funnel_PercentOfPrevious","Funnel_PercentOfFirst_Highlight","Funnel_PercentOfPrevious_Highlight","GeotaggingString_Continent","GeotaggingString_Continents","GeotaggingString_Country","GeotaggingString_Countries","GeotaggingString_State","GeotaggingString_States","GeotaggingString_City","GeotaggingString_Cities","GeotaggingString_Town","GeotaggingString_Towns","GeotaggingString_Province","GeotaggingString_Provinces","GeotaggingString_County","GeotaggingString_Counties","GeotaggingString_Village","GeotaggingString_Villages","GeotaggingString_Post","GeotaggingString_Zip","GeotaggingString_Code","GeotaggingString_Place","GeotaggingString_Places","GeotaggingString_Address","GeotaggingString_Addresses","GeotaggingString_Street","GeotaggingString_Streets","GeotaggingString_Longitude","GeotaggingString_Longitude_Short","GeotaggingString_Latitude","GeotaggingString_Latitude_Short","GeotaggingString_PostalCode","GeotaggingString_PostalCodes","GeotaggingString_ZipCode","GeotaggingString_ZipCodes","GeotaggingString_Territory","GeotaggingString_Territories","null","true","false","displayName","DataRoleHelper","getMeasureIndexOfRole","grouped","firstGroup","hasRole","getCategoryIndexOfRole","categories","hasRoleInDataView","dataView","columns","any","c","hasRoleInValueColumn","valueColumn","createIDataViewCategoricalReader","DataViewCategoricalReader","categorical","hasValidCategories","hasAnyValidValues","valueRoleIndexMapping","firstGroupValues","valueIndex","valueCount","valueRoles","role","dataHasDynamicSeries","hasCategories","getCategoryCount","getCategoryValues","getCategoryFromRole","getCategoryValue","categoryIndex","getCategoryColumn","getCategoryMetadataColumn","getCategoryColumnIdentityFields","identityFields","getCategoryDisplayName","targetColumn","hasCompositeCategories","hasCategoryWithRole","getCategoryObjects","hasValues","seriesIndex","getValueInternal","getAllValuesForRole","valuesInRole","roleValueIndex","roleValueCount","groupIndex","valueColumnIndexInRole","valueColumnIndex","getFirstNonNullValueForCategory","seriesCount","getMeasureQueryName","queryName","getValueColumn","getValueMetadataColumn","getValueDisplayName","hasDynamicSeries","getSeriesCount","getSeriesObjects","getSeriesValueColumns","getSeriesValueColumnGroup","getSeriesMetadataColumn","getSeriesColumnIdentityFields","getSeriesName","getSeriesDisplayName","DataViewConcatenateCategoricalColumns","inherit","Prototype","inheritSingle","detectAndApply","objectDescriptors","roleMappings","projectionOrdering","selects","projectionActiveItems","dataViewCategorical","concatenationSource","detectCategoricalRoleForHierarchicalGroup","columnsSortedByProjectionOrdering","sortColumnsByProjectionOrdering","activeItemsToIgnoreInConcatenation","chain","activeItemInfo","suppressConcat","applyConcatenation","applyToPlayChartCategorical","categoryRoleName","transformingColumns_1","transformingMetadata","m","transformingDataView","dataViewMappings","roleKinds","DataViewSelectTransform","createRoleKindFromMetadata","projections","projectionsFromSelects","DataViewAnalysis","chooseDataViewMappings","supportedMappings","roleMappingForCategorical","roleNamesForCategory","getAllRolesInCategories","targetRoleName_1","isVisualExpectingMaxOneCategoryColumn","conditions","every","condition","categoriesForTargetRole_1","categoryColumn","areValuesCountsEqual","categoricalRoleMapping","roleNames","DataViewMapping","visitCategoricalCategories","visitRole","queryRefsToIgnore","formatStringPropId","DataViewObjectDescriptors","findFormatString","concatenatedValues","concatenateValues","columnsSourceSortedByProjectionOrdering","concatenatedColumnMetadata","createConcatenatedColumnMetadata","transformedDataView","addToMetadata","concatenatedCategoryColumn","createConcatenatedCategoryColumn","transformedCategoricalCategories","difference","transformedCategorical","columnsSortedByProjectionOrdering_1","columnsInProjectionOrdering","columnsByIndex_1","columns_1","index","columnIndicesInProjectionOrdering","columnIndex","sourceColumnsSortedByProjectionOrdering","concatenatedDisplayName","sourceColumnsSortedByProjectionOrdering_1","columnSource","newRoles","newColumnMetadata","columnSourceForCurrentDrillLevel","last","isMeasure","newColumn","transformedColumns","transformedMetadata","columnMetadata","newCategoryColumn","firstColumn","visitMapping","mapping","visitor","visitCategorical","table","visitTable","matrix","visitMatrix","tree","visitTree","single","visitSingle","visitCategoricalValues","visitBind","visitFor","visitList","visitReduction","groupedRoleMapping","visitGrouped","group","select","item","rows","visitMatrixItems","visitTreeNodes","nodes","visitTreeValues","context","bind","to","forValue","select_1","by","reductionAlgorithm","dataReductionAlgorithm","DataViewNormalizeValues","rolesToNormalize","dataRoles","requiredTypes","filterVariantMeasures","dataview","columnFilter","generateMetadataColumnFilter","valueFilter","generateValueFilter","usedMappings","dataViewMappings_1","dataViewMapping","dataViewMappingProp","filterVariantMeasuresCategorical","filterVariantMeasuresTable","filterVariantMeasuresTreeNode","root","filterVariantMeasuresMatrix","filterVariantMeasuresSingle","columnsToNormalize","columns_2","rolesToNormalize_1","columnValueFilters","columns_3","columnValueFilter","generateColumnValueFilter","getColumnRequiredTypes","doesValueMatchTypes","columnRoles","rolesToNormalize_2","_b","typeDescriptor","valuesGrouped","valuesGrouped_1","valueGroup","valuesInGroup","valuesInGroup_1","normalizeVariant","filteredColumns","columns_4","filteredColumns_1","node","children","child","filterVariantMeasuresMatrixRecursive","dataviewMatrix","nodeValue","valueSourceIndex","valueSources","isNumber","rolesToNormalize_3","dataViewMappings_2","firstColumnByRoleName","object","types","types_1","columns_5","propertyId","defaultValue","objectOrMap","objectName","DataViewObject","propertyName","getObject","getUserDefinedObjects","getFillColor","defaultColor","solid","isUserDefined","isArray","getFillColorByPropertyName","DataViewObjectDefinitions","JsonComparer","ensure","defns","defnsForObject","defn","newDefn","properties","deleteProperty","getObjectDefinition","DataViewObjectDefinition","deleteSingleProperty","setValue","getPropertyContainer","propertiesAreEqual","SemanticFilter","isSameFilter","allPropertiesAreEqual","keys","property","encodePropertyValue","valueTypeDescriptor","$","isNumeric","imageValue","imageDefinition","url","scaling","original","cloned","originalDefns","clonedDefns","originalDefns_1","originalDefn","cloneProperties","descriptors","findProperty","propDesc","formattingTypeDesc","findFilterOutput","propType","findDefaultValue","propPredicate","objPropDescs","DataViewObjectEvaluationUtils","evaluateDataViewObjects","evalContext","objectDefns","objectDefinition","evaluatedObject","DataViewObjectEvaluator","run","groupObjectsBySelector","objectDefinitions","objectDefnList","objectDefn","ensureDefinitionListForSelector","metadataOnce","groupedObjects","userDefined","groupedObjects_1","item_1","addImplicitObjects","objectsForAllSelectors","selectTransforms","addDefaultFormatString","addDefaultValue","selectIdx","selectLen","selectTransform","applyFormatString","getColumnFormatForIndex","defaultValueProp","selectTransforms_1","applyDefaultValue","columnIdx","columnLen","formatStringValue","applyMetadataProperty","metadataObjects","targetObjectDefn","targetMetadataObject","findWithMatchingSelector","targetObjectDefns","findExistingObject","objectDescriptor","propertyDefinitions","propertyDescriptors","propertyDefinition","propertyDescriptor","evaluateProperty","structuralType","evaluateValue","RuleEvaluation","evaluateFill","evaluateFillRule","evaluateImage","evaluateParagraphs","fillDefn","fillType","fillRuleDefn","evaluateColorStop","colorStop","colorValueType","numericType","definition","textType","evaluateArrayCopyOnChange","evaluateParagraph","evaluated","definitionTextRuns","textRuns","evaluatedTextRuns","evaluateTextRun","definitionValue","evaluatedValue","definitions","evaluator","evaluatedValues","take","SQExpr","ExpressionEvaluator","evaluate","instance","getExprValue","inputValue","colorAllocator","getColorAllocator","DataViewPivotCategorical","categoryIdentities","categoryValues","pivotedColumns","pivotedValues","rowIdx","rowCount","categoryValue","categoryIdentity","colIdx","colCount","pivotedColumn","groupName","pivotedValue","subtotal","highlights","pivotedMetadata","DataViewTransform","createValueColumns","DataViewPivotMatrix","dataViewMatrix","columnHierarchyRewritten","rowHierarchyRewritten","levels","pivotedRowNode","level","columnLeafNodes","measureCount","pivotResultMeasureHeaderLevel","index_1","callback","measureHeaderLeaf","columnLeafNode","levelSourceIndex","isSubtotal","hierarchyTreesRewritten","forEachLeaf","cloneTreeExecuteOnLeaf","cloneTree","sources","updatedRowRoot","updatedNode","newChildren","updatedChild","createNullValues","array","Array","inheritArrayWithValue","nullValues","inherited","DataViewSelfCrossJoin","applyCategorical","dataViewMetadata","categoryLength","valuesArray","createCategoricalDataViewBuilder","withCategories","withGroupedValues","createGroupedValues","build","nullValuesArray","valuesArrayLen","seriesData","seriesDataItem","originalValueColumn","originalHighlightValues","seriesDataItemCategory","groupColumn","identityFrom","fields","valueColumns","v","DataViewPivotCategoricalToPrimaryGroups","ArrayExtensions","pivotBinding","binding","allMappings","finalMapping","defaultDataVolume","canPivotCategorical","Primary","Groupings","Secondary","DataReduction","DataVolume","dataVolume","isPivotableAxis","axis","Projections","Subtotal","SuppressedProjections","unpivotResult","oldDataView","inferUnpivotTransform","newDataView","copy","newDataViewMatrix","unpivotMatrix","hasCompositeGroupInSeries","utils","DataViewMatrixUtils","containsCompositeGroup","categoricalFromUnpivotedMatrix","supportedDataViewMappings","categoricalMapping","matrixDataview","categoryGroups","valueGroups","addGroupingRole","groups","roleProjections","roleProjection","VisualDataRoleKind","Grouping","_c","oldMatrix","oldRows","oldRoot","oldChildren","series","seriesIdLevel","seriesIdFields","childIdentityFields","categoryIdLevel","categoryIdFields","findCategory","addCategory","categoryNode","oldChildren_1","seriesNode","matrixValues","_d","newColumns","s","inheritedNode","newColChildren","srcnode","dstnode","newRows","row","rowValues","mvalues","k","l","newMatrix","measureMetadata","createCategoryColumnsFromUnpivotedMatrix","seriesColumn","valueColumnMetadataSrc","valueColumnMetadataDst","groups_1","unpivotedMatrix","categoryIdentityFields","categorySourceColumns","groupLevelValues","levelValues","transforms","activeItems","colorAllocatorFactory","transformEmptyDataView","visualDataViews","transformQueryToVisualDataView","DataViewRegression","transformSelects","transformedDataViews","splits","transformDataView","splits_1","split","transformed","emptyDataView","transformObjects","selectsToInclude","targetKinds","getTargetKinds","ordering","roleMappings_1","roleMapping","columnRewrites","applyTransformsToColumns","applyRewritesToCategorical","pivotIfNecessary","matrixTransformationContext","applyRewritesToMatrix","shouldPivotMatrix","applyRewritesToTable","prototypeColumns","rewrites","prototypeColumn","getFormatForColumn","kpi","sort","discourageAggregationAcrossGroups","from","override","rewrittenSource","findOverride","rewritten","overrideArray","valuesOverride","currentGroupValues","rewrittenValuesSource","currentGroupIndex","currentValue","setGrouped","newToOldPositions","createTableColumnPositionMapping","columnsClone","sourceColumn","newRow","originalOrder","rewrite","newOrder","createOrderMapping","overrideHierarchy","hierarchy","rewrittenHierarchy","newLevels","newLevel","levelSources","ensureRewritten","h","r","matrixMapping","columnLevels","newToOldPositions_1","createMatrixValuesPositionMapping","keys_1","numKeys_1","reorderChildNodes","forEachNodeAtLevel","newValues","iterations","keysIndex","reorderMatrixCompositeGroups","numKeys","childrenClone","supportedDataViewMapping","projection","transformedRowsHierarchy_1","reorderMatrixHierarchyCompositeGroups","transformedColumnsHierarchy_1","matrixHierarchy","hierarchyRole","transformedHierarchy","selectIndicesInProjectionOrder","hasMultipleColumnsInProjection","hierarchyLevel","newToOldLevelSourceIndicesMapping","createMatrixHierarchyLevelSourcesPositionMapping","isUndefined","inheritMatrixNodeHierarchy","transformingHierarchyLevel","reorderMatrixHierarchyLevelColumnSources","reorderMatrixHierarchyLevelValues","levelSourceColumns","columnsForHierarchyRoleOrderedByLevelSourceIndex","DataViewMetadataColumnUtils","joinMetadataColumnsAndProjectionOrder","columnsForHierarchyRoleOrderedByProjection","sortBy","columnInfo","projectionOrderIndex","sourceIndex","originalLevelSources","newLevelSourceIndices","newLevelSourceIndex","oldLevelSourceIndex","transformingHierarchyRootNode","transformingHierarchyLevelIndex","oldToNewLevelSourceIndicesMapping","createReversedMapping","transformingMatrixNode","originalLevelValues","newlyOrderedLevelValues","levelValue","transformingLevelValue","newlyOrderedLastLevelValue","newPosition","reversed","keyAsNumber","parseInt","targetLevel","columnRewrite","targetDataViewKinds","dataObjects","evaluateMetadataObjects","metadataObject","colorAllocatorCache","populateColorAllocatorCache","evaluateMetadataRepetition","dataObject","evaluateDataRepetition","rules","evaluateUserDefinedObjects","dataViewObjects","objectDefns_1","createStaticEvalContext","objectDesc","propertyDesc","ruleDesc","createRuleEvaluationInstance","ruleType","ruleOutput","output","selectorToCreate","findSelectorForRuleInput","createRuleEvaluationInstanceFillRule","tryCreateColorAllocatorForFillRule","inputRole","ColorRuleEvaluation","fillRuleProperties","identifier","identifierKind","createColorAllocatorLinearGradient2","createColorAllocatorLinearGradient3","propertyValueFillRule","inputRange","findRuleInputColumnNumberRange","splitScales","midValue","cache","createColorAllocatorCache","staticEvalContext","objectDefnProperties","fillProperty","kind","fillRuleExpr","inputExprQueryName","findFirstQueryNameForExpr","fillRulePropertyDescriptor","register","evaluateDataRepetitionCategoricalCategory","evaluateDataRepetitionCategoricalValueGrouping","rewrittenMatrix","evaluateDataRepetitionMatrix","dataViewTable","rewrittenSelector","rewriteTableRoleSelector","rewrittenTable","evaluateDataRepetitionTable","findSelectorForRoleWildcard","resultingSelector","dataSelector","selectorRoles","allColumnsBelongToSelectorRole","allColumnsBelongToRole","fromExprs","isUniqueDataSelector","dataSelectors","newSelector","columns_6","selectorRole","findSelectedCategoricalColumn","foundMatch","createCategoricalEvalContext","setCurrentRowIndex","dataViewCategoricalValues","selectorMetadata","valueSource","valueSourceOverwrite","createMatrixEvalContext","rewrittenRows","evaluateDataRepetitionMatrixHierarchy","rewrittenCols","dataViewMatrixHierarchy","rewrittenRoot","evaluateDataRepetitionMatrixNode","dataViewNode","childNodes","rewrittenNode","shouldSearchChildren","childNode","rewrittenChildNode","inheritNodeAndChildren","getPrototypeOf","createTableEvalContext","evaluateDataRepetitionTableRows","findIndex","col","inheritedRows","colLen","rowLen","inheritedRow","objectsForColumns","metadataId","categoricalColumn","selectedMetadataId","categoryRoles","columnExpr","valueCol","valueColRoles","minLocal","maxLocal","valueIdentityFields","groupedResult","groupValues","currentGroup","determineCategoricalTransformation","some","vg","roleMappingCategorical","hasRolesGrouped","categoriesMapping","hasCategoryRole","hasRolesBind","hasRolesFor","rowLevels","rowRoles","roleMappingMatrix","createDisplayNameGetter","displayNameKey","resourceProvider","getDisplayName","displayNameGetter","fieldExpr","sqExpr","FieldExprPattern","visit","FieldExprToSQExprVisitor","fromColumnAggr","columnAggr","aggregate","fromColumn","columnRef","fromEntity","entityPattern","entity","entityVar","fromEntityAggr","entityAggr","fromHierarchyLevelAggr","hierarchyLevelAggr","fromHierarchyLevel","hierarchyLevelPattern","fromHierarchy","hierarchyPattern","visitColumn","visitColumnAggr","visitColumnHierarchyLevelVariation","columnHierarchyLevelVariationPattern","propertyVariationSource","visitEntityAggr","visitHierarchyLevelAggr","visitMeasure","measure","measureRef","SQExprConverter","asFieldPattern","FieldExprPatternBuilder","sourceRef","SourceExprPatternBuilder","ref","entityRef","variable","fieldPattern","argAggr","func","sourcePattern","hierarchyRef","hierarchySourceExprPattern","HierarchyExprPatternBuiler","variation","columnHierarchyLevelVariation","variationName","entityExpr","SQEntityExpr","variationRef","exprPattern","fieldExprPattern","toColumnRefSQExpr","columnPattern","getAggregate","FieldExprPatternAggregateVisitor","hasFieldExprName","getPropertyName","getHierarchyName","getColumnRef","getFieldExprName","toFieldExprEntityPattern","FieldExprToEntityExprPatternBuilder","toFieldExprEntityItemPattern","toEntityItemExprPattern","pattern","validateAndReshape","dataViewMappings_3","supports","reshapeCategorical","reshapeTree","reshapeSingle","reshapeTable","ScriptResultUtil","findScriptResult","categoryRoleMapping","supported","updated","maxRowCount","originalLength","updatedCategories","updatedColumn","supportsCategorical","singleRoleMapping","treeRoleMapping","validateRange","countGroups","depth","tableRoleMapping","countMeasures","usePreferredDataViewSchema","scriptResult","supportsScriptResult","supportsTree","supportsSingle","supportsTable","preferred","dataViewSingle","scriptResultRoleMapping","imageBase64","roleCondition","ignoreMin","DataViewMappingMatchErrorCode","conditionRangeTooSmall","conditionRangeTooLarge","validateKind","roleKindByQueryRef","expectedKind","roleCollection","roleProjections_1","Measure","conditionKindExpectedMeasure","conditionKindExpectedGrouping","GroupingOrMeasure","conditionKindExpectedGroupingOrMeasure","mappings","errors","mappingIndex","mappingCount","mappingConditions","requiredProperties","allPropertiesValid","areAllPropertiesValid","conditionsMet","conditionIndex","conditionCount","currentConditionErrors","checkForConditionErrors","currentConditionErrors_1","error","supportedMapping","cloneDeep","updatedConditions","emptyToNull","mappingErrors","conditionRoles","isDrillable","roleCount","getPropertyCount","rangeError","code","kindError","requiredProperty","objectDescriptorValue","objectDescriptorProperty","objectDefinitionValue","useActiveIfAvailable","projectionsForRole","hasSameCategoryIdentity","dataView1","dataView2","dv1Categories","dv2Categories","dv1Identity","dv2Identity","dv1Length","getLengthOptional","areMetadataColumnsEquivalent","column1","column2","isMetadataEquivalent","metadata1","metadata2","previousColumnsLength","newColumnsLength","DataViewRoleWildcard","Lazy","fromRoles","DataViewRoleWildcardImpl","firstRoleWildcard","secondRoleWildcard","role1","role2","_this","_roles","_key","ignoreCase","filterFromIdentity","identities_1","orExprs","resultExpr","orExprs_1","orExpr","inExpr","getInExpr","or","not","fromSQExpr","createDataViewScopeIdentity","DataViewScopeIdentityImpl","_expr","SQExprShortSerializer","serialize","wildcard","instanceExprs","firstScopeWildcard","secondScopeWildcard","DataViewScopeWildcardImpl","_exprs","serializeArray","ColorAllocatorProvider","entry","allocator","applicableDataViewMappings","regressionDataViewMapping","find","usage","regression","regressionDataViews","visualDataViews_1","visualDataView","regressionDataView","linearRegressionTransform","sourceDataView","xColumns","getColumnsForCartesianRoleKind","yColumns","xColumnSource","yColumnSource","combineSeries","regressionUsage","combineSeriesPropertyId","highlightsLineDefSet","dataPointsBySeries","getDataPointsBySeries","lineDefSet","calculateLineDefinitions","xMin","xMax","shouldComputeHightlights","hasHighlightValues","highlightDataPointsBySeries","valuesByTrend","lineDefs","trend","computeLineYValues","highlightsByTrend","createRegressionDataView","dataPointsBySeries_1","dataPointSet","unsortedXValues","xValues","unsortedYValues","yValues","xDataType","getDataType","yDataType","sortedDataPointSet","sortValues","minCategoryValue","maxCategoryValue","lineDef","computeRegressionLine","roleKind","getColumnsWithRoleKind","_loop_1","cartesianKind","state_1","firstNonNull","dataType","zippedValues","zip","valuePair","unzip","xBar","sum","yBar","ssXX","pow","ssXY","slope","intercept","x1","x2","getValuesFromColumn","preferHighlights","xValueArray","seriesYValues","multipleXValueColumns","yRole","seriesRole","xRole","categoricalRoles","seriesRoles","valuesBySeries","withCategory","regressionXQueryName","regressionSeriesQueryName","regressionYQueryName","selects_1","qp","activeItem","colorAllocatorProvider","CategoricalEvalContext","findRuleInputColumn","findRuleInputInColumns","columns_7","columnsByRole","getRoleValue","TableEvalContext","getExprValueFromTable","forEachLeafNode","rootNodes","isNodeArray","rootNodes_1","rootNode","forEachLeafNodeRecursive","nodeOrNodeArray","isArrayOrInheritedArray","matrixNode","nextIndex","treePath","children_1","nextChild","pop","deepestLevelToInherit","useInheritSingle","returnNode","isRootNode","shouldInheritCurrentNode","inheritFunc","shouldInheritChildNodes","matrixOrHierarchy","hasCompositeGroup","isMatrix","hierarchyLevels","hierarchyLevels_1","isMeasureHeadersLevel","isForRole","metadataColumn","targetRole","columnSources","jointResult","projectionOrderSelectIndices","selectIndexToProjectionIndexMap","selectIndex","jointColumnInfo","ConceptualSchema","entityName","entities","withName","findHierarchy","hierarchies","findHierarchyByVariation","variationEntityName","variationColumnName","hierarchyName","variationEntity","variationProperty","variationColumn","variations","targetEntity","navigationProperty","findPropertyWithKpi","kpiProperty","prop","status","goal","ConceptualDataCategory","extractScriptResult","script","provider","extractScriptResultFromVisualConfig","scriptSource","getScriptInput","scriptInput","VariableName","Columns","scriptInputColumnNames","scriptInputColumns","scriptInputColumn","QueryName","Name","ScriptInputColumnNameVisitor","ensureUniqueNames","federatedSchema","getNameForProperty","getVariationLevelName","getNameForHierarchy","federatedScheam","variations_1","defaultHierarchy","segmentation","DataViewMerger","mergeDataViews","segment","mergeTables","mergeCategorical","mergeTreeNodes","merge","lastMergeIndex","segmentCategoriesLength","segmentCategory","sourceCategory","segmentValuesLength","segmentValue","sourceValue","sourceRoot","segmentRoot","allowDifferentStructure","firstAppendIndex","findFirstAppendIndex","lastSourceChild","mergedChildren","childSegment","isMerge","SQExprRewriter","origArg","rewrittenArg","SQColumnRefExpr","SQMeasureRefExpr","SQAggregationExpr","SQHierarchyExpr","SQHierarchyLevelExpr","SQPropertyVariationSourceExpr","orig","origLeft","rewrittenLeft","origRight","rewrittenRight","SQAndExpr","origLower","rewrittenLower","origUpper","rewrittenUpper","SQBetweenExpr","rewrittenValues","origArgs","rewrittenArgs","rewriteAll","origValues","origValueTuple","rewrittenValueTuple","SQInExpr","origExprs","rewrittenResult","origExpr","rewrittenExpr","SQOrExpr","SQCompareExpr","comparison","SQContainsExpr","SQExistsExpr","SQNotExpr","SQStartsWithExpr","SQDateSpanExpr","SQDateAddExpr","amount","SQArithmeticExpr","operator","origExpression","rewrittenExpression","origScope","rewrittenScope","SQScopedEvalExpr","origInput","rewrittenInput","origRule","origGradient2","rewrittenGradient2","origGradient3","rewrittenGradient3","rewrittenRule","SQFillRuleExpr","origMin","rewrittenMin","origMax","rewrittenMax","origMid","rewrittenMid","origColor","rewrittenColor","origValue","rewrittenValue","rewrittenStop","EqualsToInRewriter","Rewriter","Equal","visitUnsupported","isSupported","leftIsComparand","isComparand","rightIsComparand","operand","current","InBuilder","complete","cancel","SQConstantExpr","cancelled","asScopeIdsContainer","fieldSQExprs","filterItems","filterItem","FilterScopeIdsCollectorVisitor","getResult","getFirstComparandValue","comparandExpr","FindComparandVisitor","isRoot","keyExprsCount","valueExprs","fieldExprs","fieldSQExprs_1","field","removeEntityVariables","scopeIds","startIndex","endIndex","scopeId","getScopeIdentity","isInArray","compoundSQExpr","equalsExpr","equal","unsupportedSQExpr","values_1","valueTuple_1","fixedExpr","extractor","ScopeIdExtractorImpl","malformed","keyValues","PrimitiveValueEncoding","decimal","double","getTimezoneOffset","dateTimeString","toISOString","endsWith","substr","replace","SingleQuoteRegex","nullEncoding","boolean","createSQAggregationOperations","datetimeMinMaxSupported","SQAggregationOperations","getMetadataForUnderlyingType","removeAggregate","getMetadata","Agg","getSupportedAggregates","targetTypes","fieldKind","isPropertyIdentity","idOnEntityKey","aggregates_1","Sum","Avg","Min","Max","CountNonNull","StandardDeviation","Variance","fieldExprItem","currentSchema","capabilities","supportsMedian","Median","aggregates","distinctCountAggExists","SQExprInfo","isSupportedAggregate","supportedAggregates","createExprWithAggregate","aggregateNonNumericFields","preferredAggregate","getDefaultAggregate","SQHierarchyExprUtils","getConceptualHierarchyLevelFromExpr","conceptualSchema","getConceptualHierarchyLevel","schemaName","conceptualHierarchy","getConceptualHierarchy","variationExpr","sourceEntityExpr","expandExpr","suppressHierarchyLevelExpansion","SQExprHierarchyToHierarchyLevelConverter","convert","SQExprVariationConverter","expand","SQExprHierarchyLevelConverter","isHierarchyOrVariation","conceptualProperty","getConceptualProperty","getSourceVariationExpr","hierarchyLevelExpr","getSourceHierarchy","getHierarchySourceAsVariationSource","areHierarchyLevelsOrdered","allLevels","firstExpr","secondExpr","firstLevel","secondLevel","firstIndex","indexOfExpr","secondIndex","getInsertionIndex","orderedSubsetOfLevels","insertIndex","hierarchyExpr","hierarchyLevels_2","SQExprGroupUtils","groupExprs","addChildToGroup","selectQueryIndex","shouldAddExpressionToNewGroup","exprSource","lastGroup","expandedExpr","allHierarchyLevels","defaultAggregateForDataType","defaultAggregateToQueryAggregateFunction","_kind","SQExprEqualityVisitor","validate","aggrUtils","validator","SQExprValidationVisitor","isColumn","isConstant","isEntity","isHierarchy","isHierarchyLevel","isAggregation","isResourcePackageItem","getMetadataForProperty","getMetadataForHierarchyLevel","getMetadataForVariation","getMetadataForEntity","forceAggregation","getHierarchyLevelConceptualProperty","propertyDefaultAggregate","defaultAggregate","getKeyColumns","columnRefExpr","SQExprColumnRefInfoVisitor","getColumnRefSQExpr","keySQExprs","getPropertyKeys","hasGroupOnKeys","keySqExpr","getTargetEntityForVariation","variations_2","getTargetEntity","SQEntityExprInfoVisitor","getEntityExpr","fieldExprHierachyLevel","fieldExprEntity","sourceProperty","getPropertyMetadata","columnAggregate","SQPropRefExpr","valueEncoded","SQNowExpr","SQDefaultValueExpr","SQAnyValueExpr","SQResourcePackageItemExpr","packageName","packageType","itemName","between","inExpr_1","tryUseInExprs","leftArgLen","rightArgLen","combinedValues","compare","exists","startsWith","nullConstant","now","anyValue","dateAdd","dateSpan","Decimal","typedConstant","isBoolean","isString","arithmetic","scopedEval","setAggregate","SQExprChangeAggregateRewriter","SQExprRemoveAggregateRewriter","SQExprRemoveEntityVariablesRewriter","resourcePackageItem","SQExprAggregateInfoVisitor","ignoreCaseInstance","comparand","equalsAll","compareValues","optionalEqual","equalIgnoreCase","leftRule","rightRule","leftLinearGradient2","rightLinearGradient2","leftLinearGradient3","rightLinearGradient3","left2","right2","equalsFillRuleStop","left3","right3","stop1","stop2","SQExprRootRewriter","values_2","validateCompatibleType","compareExpr","validateEntity","isQueryable","aggregateExpr","validateHierarchy","hierarchyLevelFieldExprItem","validateHierarchyLevel","validateOperandsAndTypeForStartOrContains","validateArithmeticTypes","supportsArithmetic","leftMetadata","leftType","rightMetadata","rightType","levelName","hierarchyLevelConceptualProperty","queryable","sourceExpr","targetEntityExpr","schemaHierarchy","hierarchyLevelRef","getEntity","rewriter","searchElement","uniqueName","namedItems","exprDefaultName","findUniqueName","defaultName","fallback","SQExprDefaultNameGenerator","IsMeasureVisitor","isAnyValue","IsAnyValueVisitor","isDefaultValue","IsDefaultValueVisitor","discourageAggregation","getSchemaCapabilities","discourageQueryAggregateUsage","getAggregateBehavior","getConceptualColumn","aggregateBehavior","getKpiMetadata","kpiStatusProperty","getKpiStatusProperty","kpiValue","statusMetadata","kpiTrendProperty","getKpiTrendProperty","trendMetadata","getConceptualEntity","conceptualEntity","getDefaultValue","fieldSQExpr","sqField","hierarchyLevelField","getDefaultValues","fieldSQExprs_2","getDataViewScopeIdentityComparisonExpr","fieldsExpr","compareExprs","compareExprs_1","getActiveTablesNames","queryDefn","tables","selectedItems","entityObj","isRelatedToMany","targetExpr","isRelated","isRelatedToOne","sourceMultiplicity","targetMultiplicity","navigationProperties","target","queue","shift","navProperties","navProperties_1","navProperty","isActive","isRelatedOneToOne","sourceNavigations","targetNavigations","hasOneToOneNavigation","navigationProperties_1","concatUnique","leftExprs","rightExprs","concatExprs","rightExprs_1","SemanticQueryRewriter","exprRewriter","rewriteFrom","fromValue","fromContents","originalFrom","originalFromKeys","keyName","originalEntityRef","originalEntityExpr","updatedEntityExpr","SQFrom","rewriteSelect","selectItems","rewriteNamedSQExpressions","rewriteGroupBy","groupByitems","expressions","SQExprRewriterWithSourceRenames","rewriteOrderBy","orderByItems","orderBy","updatedExpr","direction","rewriteWhere","whereItems","where","originalWhere","updatedWhere","SemanticQuery","groupBy","groupByItems","empty","createWithTrimmedFrom","unreferencedKeyFinder","UnreferencedKeyFinder","filterTarget","unreferencedKeys","remove","getSelect","setSelect","createNamedExpressionArray","extendWithName","rewriteExpressionsWithSourceRenames","removeSelect","originalItems","originalExpr","removeOrderBy","sorts","selectNameOf","setSelectAt","originalName","addSelect","exprName","createNamedExpr","currentNames","getGroupBy","setGroupBy","addGroupBy","getOrderBy","setOrderBy","clause","updatedOrderBy","getWhere","setWhere","updatedFilter","updatedTarget","addWhere","incomingWhere","updatedClause","contract","rewrittenContract","getDefaultValueFilter","getDataViewScopeIdentityComparisonFilters","getAnyValueFilter","filters","firstFilter","applyFilter","isDefaultFilter","isAnyFilter","leftFilter","rightFilter","filterWhereItems","filterWhereItem","updatedWhereItem","ensureEntity","desiredVariableName","i_1","candidateName","new","idx","substring","toLowerCase","extend","renames","updatedName","rewriteFilter","updatedTargets","rewriteArray","updatedCondition","updatedExprs","QuerySourceRenameDetector","detector","existingEntity","actualEntity","data_4","CategoricalDataViewBuilder","pushIfNotExists","itemToAdd","applySeriesData","measureColumns","withValues","columns_8","dynamicSeriesMetadata","valueColumns_1","fillData","dataViewValues","first","data_5","seriesMeasures","measureIndex","measuresLen","data_6","metadataColumns","categoryMetadata","categoryMetadata_1","measures","seriesValues","seriesValue","seriesIdentity","measures_1","groups_2","StaticEvalContext","cols","powerbi_1","FormattingEncoder","RegExpExtensions","preserveEscaped","specialChars","oldText","newText","String","fromCharCode","replaceAll","restoreEscaped","preserveLiterals","literals","fromIndex","toIndex","literal","token","restoreLiterals","DateTimeFormat","IndexedTokensRegex","ZeroPlaceholder","DigitPlaceholder","ExponentialFormatChar","NumericPlaceholders","NumericPlaceholderRegex","RegExp","join","FormattingService","culture","gculture","getCulture","canFormat","formatWithIndexedTokens","match","argToken","parts","argIndex","argFormat","nonScientificOverrideFormat","formatWithCustomOverride","_dateTimeScaleFormatInfo","initialize","setCurrentCulture","cultureSelector","_currentCultureSelector","_currentCulture","DateTimeScaleFormatInfo","Globalize","findClosestCulture","cultureName","getCurrentCulture","calendarName","getUrlParam","calendars","calendar","urlParam","common","cultureInfo","navigator","userLanguage","param","location","search","isStandard","formatDateStandard","formatDateCustom","patterns","ensurePatterns","findDateFormat","processCustomDateTimeFormat","localize","_currentCachedFormat","_currentCachedProcessedFormat","fixDateTimeFormat","dictionary","timeSeparator","char","charAt","getNonScientificFormatWithPrecision","baseFormat","newFormat","hasFormatComponents","getComponents","positive","negative","zero","getNumericFormatFromComponent","NumericFormatRegex","formats","addDecimalsToFormatComponent","NumberFormatComponentsDelimeter","placeholder","decimalPlaceholders","repeat","DecimalFormatRegex","beforeDecimal","formatDecimal","afterDecimal","decimalChange","DecimalFormatCharacter","LastNumericPlaceholderRegex","signFormat","hasNegative","signSpecificFormats","formatCount","StandardFormatRegex","formatNumberStandard","formatNumberCustom","numberFormatInfo","numberFormat","formatChar","mantissaDecimalDigits","toFixed","toPrecision","toExponential","actualPrecision","isNegative","paddingZerosCount","paddingZeros","isFinite","formatComponents","formatMeta","hasEscapes","hasQuotes","hasE","scientificMatch","ScientificFormatRegex","formatM","formatE","getCustomFormatPrecision","scale","getCustomFormatScale","indexOfE","mantissa","resultM","fuseNumberWithCustomFormat","resultE","valueFormatted","isValueGlobalized","parseFloat","toNonScientific","_lastCustomFormatMeta","precisionZeros","digitsBeforeDecimalPoint","maxPrecision","indexOfDot","powerZeros","calculatePrecision","calculateScale","hasCommas","hasDots","hasPercent","hasPermile","length_1","dotIndex","suppressModifyValue","formatParts","wholeFormat","fractionFormat","NumericalPlaceHolderRegex","globalizedDecimalSeparator","decimalSeparator","valueParts","wholeValue","fractionValue","TrailingZerosRegex","wholeFormattedValue","fuseNumberWithCustomFormatLeft","fractionFormattedValue","fuseNumberWithCustomFormatRight","fmtOnly","groupSymbolIndex","enableGroups","groupDigitCount","groupSizes","groupSize","groupSeparator","sign","firstChar","isZero","leftBuffer","vi","fi","fCount","vCount","lastChar","plus","minus","dot","comma","monthAbbreviations","cultureHasMonthAbbr","yearMonthPattern","monthDayPattern","fullPattern","longTimePattern","shortTimePattern","separator","hasYearSymbol","YearPattern","yearPos","monthPos","MonthPattern","DayPattern","minutePos","pmPos","shortHourPattern","HourPattern","MinutePattern","SecondPattern","MillisecondPattern","SQExprSerializer","str","agg","f","n","comp","const","o","SelectionId","highlight","keyWithoutHighlight","includes","ignoreHighlight","thisSelector","otherSelector","thisData","otherData","thisValue","otherValue","getKeyWithoutHighlight","hasIdentity","getSelector","getSelectorsByColumn","selectorsByColumn","createNull","createWithId","createWithMeasure","measureId","selectionId","createWithIdAndMeasure","createWithIdAndMeasureAndCategory","dataMap","createWithIds","id1","id2","idArray","createWithIdsAndMeasure","createWithSelectorForColumnAndMeasure","createWithHighlight","newId","data_7","SelectionIdBuilder","builder","ensureDataMap","withSeries","withMeasure","createSelectionId"],"mappings":"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","file":"VisualsData.min.js","sourcesContent":["var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n///<reference path=\"../../Typedefs/jquery/jquery.d.ts\"/>\n///<reference path=\"../../Typedefs/globalize/globalize.d.ts\"/>\n///<reference path=\"../../Typedefs/lodash/lodash.d.ts\"/>\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\n        var DefaultSQExprVisitorWithArg = (function () {\n            function DefaultSQExprVisitorWithArg() {\n            }\n            DefaultSQExprVisitorWithArg.prototype.visitEntity = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitColumnRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitMeasureRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAggr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchy = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchyLevel = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPropertyVariationSource = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitBetween = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitIn = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitOr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitCompare = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitContains = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitExists = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNot = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitStartsWith = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitConstant = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateSpan = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateAdd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNow = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefaultValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnyValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitArithmetic = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitFillRule = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitResourcePackageItem = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitScopedEval = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefault = function (expr, arg) {\n                return;\n            };\n            return DefaultSQExprVisitorWithArg;\n        }());\n        data.DefaultSQExprVisitorWithArg = DefaultSQExprVisitorWithArg;\n        /** Default ISQExprVisitor implementation that others may derive from. */\n        var DefaultSQExprVisitor = (function (_super) {\n            __extends(DefaultSQExprVisitor, _super);\n            function DefaultSQExprVisitor() {\n                _super.apply(this, arguments);\n            }\n            return DefaultSQExprVisitor;\n        }(DefaultSQExprVisitorWithArg));\n        data.DefaultSQExprVisitor = DefaultSQExprVisitor;\n        /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\n        var DefaultSQExprVisitorWithTraversal = (function () {\n            function DefaultSQExprVisitorWithTraversal() {\n            }\n            DefaultSQExprVisitorWithTraversal.prototype.visitEntity = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitColumnRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitMeasureRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAggr = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchy = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchyLevel = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPropertyVariationSource = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitBetween = function (expr) {\n                expr.arg.accept(this);\n                expr.lower.accept(this);\n                expr.upper.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitIn = function (expr) {\n                var args = expr.args;\n                for (var i = 0, len = args.length; i < len; i++)\n                    args[i].accept(this);\n                var values = expr.values;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var valueTuple = values[i];\n                    for (var j = 0, jlen = valueTuple.length; j < jlen; j++)\n                        valueTuple[j].accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnd = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitOr = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitCompare = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitContains = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitExists = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNot = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitStartsWith = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitConstant = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateSpan = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateAdd = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNow = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefaultValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnyValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitArithmetic = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRule = function (expr) {\n                expr.input.accept(this);\n                var rule = expr.rule, gradient2 = rule.linearGradient2, gradient3 = rule.linearGradient3;\n                if (gradient2) {\n                    this.visitLinearGradient2(gradient2);\n                }\n                if (gradient3) {\n                    this.visitLinearGradient3(gradient3);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient2 = function (gradient2) {\n                debug.assertValue(gradient2, 'gradient2');\n                this.visitFillRuleStop(gradient2.min);\n                this.visitFillRuleStop(gradient2.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient3 = function (gradient3) {\n                debug.assertValue(gradient3, 'gradient3');\n                this.visitFillRuleStop(gradient3.min);\n                this.visitFillRuleStop(gradient3.mid);\n                this.visitFillRuleStop(gradient3.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitResourcePackageItem = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitScopedEval = function (expr) {\n                expr.expression.accept(this);\n                for (var _i = 0, _a = expr.scope; _i < _a.length; _i++) {\n                    var scopeExpr = _a[_i];\n                    scopeExpr.accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefault = function (expr) {\n                return;\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                stop.color.accept(this);\n                var value = stop.value;\n                if (value)\n                    value.accept(this);\n            };\n            return DefaultSQExprVisitorWithTraversal;\n        }());\n        data.DefaultSQExprVisitorWithTraversal = DefaultSQExprVisitorWithTraversal;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    function createEnumType(members) {\n        return new EnumType(members);\n    }\n    powerbi.createEnumType = createEnumType;\n    var EnumType = (function () {\n        function EnumType(allMembers) {\n            debug.assertValue(allMembers, 'allMembers');\n            this.allMembers = allMembers;\n        }\n        EnumType.prototype.members = function (validMembers) {\n            var allMembers = this.allMembers;\n            if (!validMembers)\n                return allMembers;\n            var membersToReturn = [];\n            for (var _i = 0, allMembers_1 = allMembers; _i < allMembers_1.length; _i++) {\n                var member = allMembers_1[_i];\n                if (_.contains(validMembers, member.value))\n                    membersToReturn.push(member);\n            }\n            return membersToReturn;\n        };\n        return EnumType;\n    }());\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var FillSolidColorTypeDescriptor;\n    (function (FillSolidColorTypeDescriptor) {\n        /** Gets a value indicating whether the descriptor is nullable or not. */\n        function nullable(descriptor) {\n            debug.assertValue(descriptor, 'descriptor');\n            if (descriptor === true)\n                return false;\n            var advancedDescriptor = descriptor;\n            return !!advancedDescriptor.nullable;\n        }\n        FillSolidColorTypeDescriptor.nullable = nullable;\n    })(FillSolidColorTypeDescriptor = powerbi.FillSolidColorTypeDescriptor || (powerbi.FillSolidColorTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var ImageDefinition;\n    (function (ImageDefinition) {\n        ImageDefinition.urlType = { misc: { imageUrl: true } };\n    })(ImageDefinition = powerbi.ImageDefinition || (powerbi.ImageDefinition = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StructuralTypeDescriptor;\n    (function (StructuralTypeDescriptor) {\n        function isValid(type) {\n            debug.assertValue(type, 'type');\n            if (type.fill ||\n                type.fillRule ||\n                type.filter ||\n                type.expression ||\n                type.image ||\n                type.paragraphs) {\n                return true;\n            }\n            return false;\n        }\n        StructuralTypeDescriptor.isValid = isValid;\n    })(StructuralTypeDescriptor = powerbi.StructuralTypeDescriptor || (powerbi.StructuralTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var EnumExtensions = jsCommon.EnumExtensions;\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\n    var ValueType = (function () {\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\n        function ValueType(type, category, enumType) {\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\n            debug.assert(!!category || category === null, 'category');\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\n            this.underlyingType = type;\n            this.category = category;\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\n                this.temporalType = new TemporalType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\n                this.geographyType = new GeographyType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\n                this.miscType = new MiscellaneousType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\n                this.formattingType = new FormattingType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\n                this.enumType = enumType;\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\n                this.scriptingType = new ScriptType(type);\n            }\n        }\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\n        ValueType.fromDescriptor = function (descriptor) {\n            descriptor = descriptor || {};\n            // Simplified primitive types\n            if (descriptor.text)\n                return ValueType.fromExtendedType(ExtendedType.Text);\n            if (descriptor.integer)\n                return ValueType.fromExtendedType(ExtendedType.Integer);\n            if (descriptor.numeric)\n                return ValueType.fromExtendedType(ExtendedType.Double);\n            if (descriptor.bool)\n                return ValueType.fromExtendedType(ExtendedType.Boolean);\n            if (descriptor.dateTime)\n                return ValueType.fromExtendedType(ExtendedType.DateTime);\n            if (descriptor.duration)\n                return ValueType.fromExtendedType(ExtendedType.Duration);\n            if (descriptor.binary)\n                return ValueType.fromExtendedType(ExtendedType.Binary);\n            if (descriptor.none)\n                return ValueType.fromExtendedType(ExtendedType.None);\n            // Extended types\n            if (descriptor.scripting) {\n                if (descriptor.scripting.source)\n                    return ValueType.fromExtendedType(ExtendedType.ScriptSource);\n            }\n            if (descriptor.enumeration)\n                return ValueType.fromEnum(descriptor.enumeration);\n            if (descriptor.temporal) {\n                if (descriptor.temporal.year)\n                    return ValueType.fromExtendedType(ExtendedType.Year_Integer);\n                if (descriptor.temporal.month)\n                    return ValueType.fromExtendedType(ExtendedType.Month_Integer);\n            }\n            if (descriptor.geography) {\n                if (descriptor.geography.address)\n                    return ValueType.fromExtendedType(ExtendedType.Address);\n                if (descriptor.geography.city)\n                    return ValueType.fromExtendedType(ExtendedType.City);\n                if (descriptor.geography.continent)\n                    return ValueType.fromExtendedType(ExtendedType.Continent);\n                if (descriptor.geography.country)\n                    return ValueType.fromExtendedType(ExtendedType.Country);\n                if (descriptor.geography.county)\n                    return ValueType.fromExtendedType(ExtendedType.County);\n                if (descriptor.geography.region)\n                    return ValueType.fromExtendedType(ExtendedType.Region);\n                if (descriptor.geography.postalCode)\n                    return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\n                if (descriptor.geography.stateOrProvince)\n                    return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\n                if (descriptor.geography.place)\n                    return ValueType.fromExtendedType(ExtendedType.Place);\n                if (descriptor.geography.latitude)\n                    return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\n                if (descriptor.geography.longitude)\n                    return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\n            }\n            if (descriptor.misc) {\n                if (descriptor.misc.image)\n                    return ValueType.fromExtendedType(ExtendedType.Image);\n                if (descriptor.misc.imageUrl)\n                    return ValueType.fromExtendedType(ExtendedType.ImageUrl);\n                if (descriptor.misc.webUrl)\n                    return ValueType.fromExtendedType(ExtendedType.WebUrl);\n            }\n            if (descriptor.formatting) {\n                if (descriptor.formatting.color)\n                    return ValueType.fromExtendedType(ExtendedType.Color);\n                if (descriptor.formatting.formatString)\n                    return ValueType.fromExtendedType(ExtendedType.FormatString);\n                if (descriptor.formatting.alignment)\n                    return ValueType.fromExtendedType(ExtendedType.Alignment);\n                if (descriptor.formatting.labelDisplayUnits)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\n                if (descriptor.formatting.fontSize)\n                    return ValueType.fromExtendedType(ExtendedType.FontSize);\n                if (descriptor.formatting.labelDensity)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDensity);\n            }\n            if (descriptor.extendedType) {\n                return ValueType.fromExtendedType(descriptor.extendedType);\n            }\n            return ValueType.fromExtendedType(ExtendedType.Null);\n        };\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\n        ValueType.fromExtendedType = function (extendedType) {\n            extendedType = extendedType || ExtendedType.Null;\n            var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);\n            debug.assert(primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null, 'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\n        };\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\n        ValueType.fromPrimitiveTypeAndCategory = function (primitiveType, category) {\n            primitiveType = primitiveType || PrimitiveType.Null;\n            category = category || null;\n            var id = primitiveType.toString();\n            if (category)\n                id += '|' + category;\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\n        };\n        /** Creates a ValueType to describe the given IEnumType. */\n        ValueType.fromEnum = function (enumType) {\n            debug.assertValue(enumType, 'enumType');\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\n        };\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\n        ValueType.isCompatibleTo = function (type, otherTypes) {\n            debug.assertValue(type, 'type');\n            debug.assertValue(otherTypes, 'otherTypes');\n            var valueType = ValueType.fromDescriptor(type);\n            for (var _i = 0, otherTypes_1 = otherTypes; _i < otherTypes_1.length; _i++) {\n                var otherType = otherTypes_1[_i];\n                var otherValueType = ValueType.fromDescriptor(otherType);\n                if (otherValueType.isCompatibleFrom(valueType))\n                    return true;\n            }\n            return false;\n        };\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\n        ValueType.prototype.isCompatibleFrom = function (other) {\n            debug.assertValue(other, 'other');\n            var otherPrimitiveType = other.primitiveType;\n            if (this === other ||\n                this.primitiveType === otherPrimitiveType ||\n                otherPrimitiveType === PrimitiveType.Null)\n                return true;\n            return false;\n        };\n        Object.defineProperty(ValueType.prototype, \"primitiveType\", {\n            /** Gets the exact primitive type of this ValueType. */\n            get: function () {\n                return getPrimitiveType(this.underlyingType);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"extendedType\", {\n            /** Gets the exact extended type of this ValueType. */\n            get: function () {\n                return this.underlyingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"categoryString\", {\n            /** Gets the data category string (if any) for this ValueType. */\n            get: function () {\n                return this.category;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"text\", {\n            // Simplified primitive types\n            /** Indicates whether the type represents text values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Text;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"numeric\", {\n            /** Indicates whether the type represents any numeric value. */\n            get: function () {\n                return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"integer\", {\n            /** Indicates whether the type represents integer numeric values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Integer;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"bool\", {\n            /** Indicates whether the type represents Boolean values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Boolean;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"dateTime\", {\n            /** Indicates whether the type represents any date/time values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.DateTime ||\n                    this.primitiveType === PrimitiveType.Date ||\n                    this.primitiveType === PrimitiveType.Time;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"duration\", {\n            /** Indicates whether the type represents duration values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Duration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"binary\", {\n            /** Indicates whether the type represents binary values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Binary;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"none\", {\n            /** Indicates whether the type represents none values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.None;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"temporal\", {\n            // Extended types\n            /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\n            get: function () {\n                return this.temporalType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"geography\", {\n            /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\n            get: function () {\n                return this.geographyType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"misc\", {\n            /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\n            get: function () {\n                return this.miscType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"formatting\", {\n            /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\n            get: function () {\n                return this.formattingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"enum\", {\n            /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\n            get: function () {\n                return this.enumType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"scripting\", {\n            get: function () {\n                return this.scriptingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ValueType.typeCache = {};\n        return ValueType;\n    }());\n    powerbi.ValueType = ValueType;\n    var ScriptType = (function () {\n        function ScriptType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(ScriptType.prototype, \"source\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return ScriptType;\n    }());\n    powerbi.ScriptType = ScriptType;\n    var TemporalType = (function () {\n        function TemporalType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(TemporalType.prototype, \"year\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TemporalType.prototype, \"month\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return TemporalType;\n    }());\n    powerbi.TemporalType = TemporalType;\n    var GeographyType = (function () {\n        function GeographyType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(GeographyType.prototype, \"address\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"city\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"continent\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"country\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"county\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"region\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"postalCode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"stateOrProvince\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"place\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"latitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"longitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return GeographyType;\n    }());\n    powerbi.GeographyType = GeographyType;\n    var MiscellaneousType = (function () {\n        function MiscellaneousType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(MiscellaneousType.prototype, \"image\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"imageUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"webUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return MiscellaneousType;\n    }());\n    powerbi.MiscellaneousType = MiscellaneousType;\n    var FormattingType = (function () {\n        function FormattingType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(FormattingType.prototype, \"color\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"formatString\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"alignment\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDisplayUnits\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"fontSize\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDensity\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return FormattingType;\n    }());\n    powerbi.FormattingType = FormattingType;\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\n    (function (PrimitiveType) {\n        PrimitiveType[PrimitiveType[\"Null\"] = 0] = \"Null\";\n        PrimitiveType[PrimitiveType[\"Text\"] = 1] = \"Text\";\n        PrimitiveType[PrimitiveType[\"Decimal\"] = 2] = \"Decimal\";\n        PrimitiveType[PrimitiveType[\"Double\"] = 3] = \"Double\";\n        PrimitiveType[PrimitiveType[\"Integer\"] = 4] = \"Integer\";\n        PrimitiveType[PrimitiveType[\"Boolean\"] = 5] = \"Boolean\";\n        PrimitiveType[PrimitiveType[\"Date\"] = 6] = \"Date\";\n        PrimitiveType[PrimitiveType[\"DateTime\"] = 7] = \"DateTime\";\n        PrimitiveType[PrimitiveType[\"DateTimeZone\"] = 8] = \"DateTimeZone\";\n        PrimitiveType[PrimitiveType[\"Time\"] = 9] = \"Time\";\n        PrimitiveType[PrimitiveType[\"Duration\"] = 10] = \"Duration\";\n        PrimitiveType[PrimitiveType[\"Binary\"] = 11] = \"Binary\";\n        PrimitiveType[PrimitiveType[\"None\"] = 12] = \"None\";\n    })(powerbi.PrimitiveType || (powerbi.PrimitiveType = {}));\n    var PrimitiveType = powerbi.PrimitiveType;\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\n    (function (ExtendedType) {\n        // Flags (1 << 8-15 range [0xFF00])\n        // Important: Enum members must be declared before they are used in TypeScript.\n        ExtendedType[ExtendedType[\"Numeric\"] = 256] = \"Numeric\";\n        ExtendedType[ExtendedType[\"Temporal\"] = 512] = \"Temporal\";\n        ExtendedType[ExtendedType[\"Geography\"] = 1024] = \"Geography\";\n        ExtendedType[ExtendedType[\"Miscellaneous\"] = 2048] = \"Miscellaneous\";\n        ExtendedType[ExtendedType[\"Formatting\"] = 4096] = \"Formatting\";\n        ExtendedType[ExtendedType[\"Scripting\"] = 8192] = \"Scripting\";\n        // Primitive types (0-255 range [0xFF] | flags)\n        // The member names and base values must match those in PrimitiveType.\n        ExtendedType[ExtendedType[\"Null\"] = 0] = \"Null\";\n        ExtendedType[ExtendedType[\"Text\"] = 1] = \"Text\";\n        ExtendedType[ExtendedType[\"Decimal\"] = 258] = \"Decimal\";\n        ExtendedType[ExtendedType[\"Double\"] = 259] = \"Double\";\n        ExtendedType[ExtendedType[\"Integer\"] = 260] = \"Integer\";\n        ExtendedType[ExtendedType[\"Boolean\"] = 5] = \"Boolean\";\n        ExtendedType[ExtendedType[\"Date\"] = 518] = \"Date\";\n        ExtendedType[ExtendedType[\"DateTime\"] = 519] = \"DateTime\";\n        ExtendedType[ExtendedType[\"DateTimeZone\"] = 520] = \"DateTimeZone\";\n        ExtendedType[ExtendedType[\"Time\"] = 521] = \"Time\";\n        ExtendedType[ExtendedType[\"Duration\"] = 10] = \"Duration\";\n        ExtendedType[ExtendedType[\"Binary\"] = 11] = \"Binary\";\n        ExtendedType[ExtendedType[\"None\"] = 12] = \"None\";\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\n        // Temporal\n        ExtendedType[ExtendedType[\"Year\"] = 66048] = \"Year\";\n        ExtendedType[ExtendedType[\"Year_Text\"] = 66049] = \"Year_Text\";\n        ExtendedType[ExtendedType[\"Year_Integer\"] = 66308] = \"Year_Integer\";\n        ExtendedType[ExtendedType[\"Year_Date\"] = 66054] = \"Year_Date\";\n        ExtendedType[ExtendedType[\"Year_DateTime\"] = 66055] = \"Year_DateTime\";\n        ExtendedType[ExtendedType[\"Month\"] = 131584] = \"Month\";\n        ExtendedType[ExtendedType[\"Month_Text\"] = 131585] = \"Month_Text\";\n        ExtendedType[ExtendedType[\"Month_Integer\"] = 131844] = \"Month_Integer\";\n        ExtendedType[ExtendedType[\"Month_Date\"] = 131590] = \"Month_Date\";\n        ExtendedType[ExtendedType[\"Month_DateTime\"] = 131591] = \"Month_DateTime\";\n        // Geography\n        ExtendedType[ExtendedType[\"Address\"] = 6554625] = \"Address\";\n        ExtendedType[ExtendedType[\"City\"] = 6620161] = \"City\";\n        ExtendedType[ExtendedType[\"Continent\"] = 6685697] = \"Continent\";\n        ExtendedType[ExtendedType[\"Country\"] = 6751233] = \"Country\";\n        ExtendedType[ExtendedType[\"County\"] = 6816769] = \"County\";\n        ExtendedType[ExtendedType[\"Region\"] = 6882305] = \"Region\";\n        ExtendedType[ExtendedType[\"PostalCode\"] = 6947840] = \"PostalCode\";\n        ExtendedType[ExtendedType[\"PostalCode_Text\"] = 6947841] = \"PostalCode_Text\";\n        ExtendedType[ExtendedType[\"PostalCode_Integer\"] = 6948100] = \"PostalCode_Integer\";\n        ExtendedType[ExtendedType[\"StateOrProvince\"] = 7013377] = \"StateOrProvince\";\n        ExtendedType[ExtendedType[\"Place\"] = 7078913] = \"Place\";\n        ExtendedType[ExtendedType[\"Latitude\"] = 7144448] = \"Latitude\";\n        ExtendedType[ExtendedType[\"Latitude_Decimal\"] = 7144706] = \"Latitude_Decimal\";\n        ExtendedType[ExtendedType[\"Latitude_Double\"] = 7144707] = \"Latitude_Double\";\n        ExtendedType[ExtendedType[\"Longitude\"] = 7209984] = \"Longitude\";\n        ExtendedType[ExtendedType[\"Longitude_Decimal\"] = 7210242] = \"Longitude_Decimal\";\n        ExtendedType[ExtendedType[\"Longitude_Double\"] = 7210243] = \"Longitude_Double\";\n        // Miscellaneous\n        ExtendedType[ExtendedType[\"Image\"] = 13109259] = \"Image\";\n        ExtendedType[ExtendedType[\"ImageUrl\"] = 13174785] = \"ImageUrl\";\n        ExtendedType[ExtendedType[\"WebUrl\"] = 13240321] = \"WebUrl\";\n        // Formatting\n        ExtendedType[ExtendedType[\"Color\"] = 19664897] = \"Color\";\n        ExtendedType[ExtendedType[\"FormatString\"] = 19730433] = \"FormatString\";\n        ExtendedType[ExtendedType[\"Alignment\"] = 20058113] = \"Alignment\";\n        ExtendedType[ExtendedType[\"LabelDisplayUnits\"] = 20123649] = \"LabelDisplayUnits\";\n        ExtendedType[ExtendedType[\"FontSize\"] = 20189443] = \"FontSize\";\n        ExtendedType[ExtendedType[\"LabelDensity\"] = 20254979] = \"LabelDensity\";\n        // Enumeration\n        ExtendedType[ExtendedType[\"Enumeration\"] = 26214401] = \"Enumeration\";\n        // Scripting\n        ExtendedType[ExtendedType[\"ScriptSource\"] = 32776193] = \"ScriptSource\";\n    })(powerbi.ExtendedType || (powerbi.ExtendedType = {}));\n    var ExtendedType = powerbi.ExtendedType;\n    var PrimitiveTypeMask = 0xFF;\n    var PrimitiveTypeWithFlagsMask = 0xFFFF;\n    var PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\n    function getPrimitiveType(extendedType) {\n        return extendedType & PrimitiveTypeMask;\n    }\n    function isPrimitiveType(extendedType) {\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\n    }\n    function getCategoryFromExtendedType(extendedType) {\n        if (isPrimitiveType(extendedType))\n            return null;\n        var category = ExtendedType[extendedType];\n        if (category) {\n            // Check for ExtendedType declaration without a primitive type.\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\n            var delimIdx = category.lastIndexOf('_');\n            if (delimIdx > 0) {\n                var baseCategory = category.slice(0, delimIdx);\n                if (ExtendedType[baseCategory]) {\n                    debug.assert((ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask), 'Unexpected value for ExtendedType base member of ' + extendedType);\n                    category = baseCategory;\n                }\n            }\n        }\n        return category || null;\n    }\n    function toExtendedType(primitiveType, category) {\n        var primitiveString = PrimitiveType[primitiveType];\n        var t = ExtendedType[primitiveString];\n        if (t == null) {\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\n            t = ExtendedType.Null;\n        }\n        if (primitiveType && category) {\n            var categoryType = ExtendedType[category];\n            if (categoryType) {\n                var categoryPrimitiveType = getPrimitiveType(categoryType);\n                if (categoryPrimitiveType === PrimitiveType.Null) {\n                    // Category supports multiple primitive types, check if requested primitive type is supported\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\n                    categoryType = t | categoryType;\n                    if (ExtendedType[categoryType]) {\n                        debug.assert(ExtendedType[categoryType] === (category + '_' + primitiveString), 'Unexpected name for ExtendedType member ' + categoryType);\n                        t = categoryType;\n                    }\n                }\n                else if (categoryPrimitiveType === primitiveType) {\n                    // Primitive type matches the single supported type for the category\n                    t = categoryType;\n                }\n            }\n        }\n        return t;\n    }\n    function matchesExtendedTypeWithAnyPrimitive(a, b) {\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (DataShapeBindingLimitType) {\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Top\"] = 0] = \"Top\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"First\"] = 1] = \"First\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Last\"] = 2] = \"Last\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Sample\"] = 3] = \"Sample\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Bottom\"] = 4] = \"Bottom\";\n        })(data.DataShapeBindingLimitType || (data.DataShapeBindingLimitType = {}));\n        var DataShapeBindingLimitType = data.DataShapeBindingLimitType;\n        (function (SubtotalType) {\n            SubtotalType[SubtotalType[\"None\"] = 0] = \"None\";\n            SubtotalType[SubtotalType[\"Before\"] = 1] = \"Before\";\n            SubtotalType[SubtotalType[\"After\"] = 2] = \"After\";\n        })(data.SubtotalType || (data.SubtotalType = {}));\n        var SubtotalType = data.SubtotalType;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataShapeBindingDataReduction;\n        (function (DataShapeBindingDataReduction) {\n            function createFrom(reduction) {\n                if (!reduction)\n                    return;\n                var result;\n                if (reduction.top) {\n                    result = {\n                        Top: {}\n                    };\n                    if (reduction.top.count)\n                        result.Top.Count = reduction.top.count;\n                }\n                if (reduction.bottom) {\n                    result = {\n                        Bottom: {}\n                    };\n                    if (reduction.bottom.count)\n                        result.Bottom.Count = reduction.bottom.count;\n                }\n                if (reduction.sample) {\n                    result = {\n                        Sample: {}\n                    };\n                    if (reduction.sample.count)\n                        result.Sample.Count = reduction.sample.count;\n                }\n                if (reduction.window) {\n                    result = {\n                        Window: {}\n                    };\n                    if (reduction.window.count)\n                        result.Window.Count = reduction.window.count;\n                }\n                return result;\n            }\n            DataShapeBindingDataReduction.createFrom = createFrom;\n        })(DataShapeBindingDataReduction = data.DataShapeBindingDataReduction || (data.DataShapeBindingDataReduction = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Represents a federated conceptual schema. */\n        var FederatedConceptualSchema = (function () {\n            function FederatedConceptualSchema(options) {\n                debug.assertValue(options, 'options');\n                this.schemas = options.schemas;\n                if (options.links)\n                    this.links = options.links;\n            }\n            FederatedConceptualSchema.prototype.schema = function (name) {\n                return this.schemas[name];\n            };\n            return FederatedConceptualSchema;\n        }());\n        data.FederatedConceptualSchema = FederatedConceptualSchema;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data_1) {\n        var Selector;\n        (function (Selector) {\n            function filterFromSelector(selectors, isNot) {\n                if (_.isEmpty(selectors))\n                    return;\n                var exprs = [];\n                for (var i = 0, ilen = selectors.length; i < ilen; i++) {\n                    var identity = selectors[i];\n                    var data_2 = identity.data;\n                    var exprToAdd = undefined;\n                    if (data_2 && data_2.length) {\n                        for (var j = 0, jlen = data_2.length; j < jlen; j++) {\n                            exprToAdd = data_1.SQExprBuilder.and(exprToAdd, identity.data[j].expr);\n                        }\n                    }\n                    if (exprToAdd)\n                        exprs.push(exprToAdd);\n                }\n                if (!_.isEmpty(exprs))\n                    return powerbi.DataViewScopeIdentity.filterFromExprs(exprs, isNot);\n            }\n            Selector.filterFromSelector = filterFromSelector;\n            function matchesData(selector, identities) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(identities, 'identities');\n                var selectorData = selector.data;\n                if (selectorData.length !== identities.length)\n                    return false;\n                for (var i = 0, len = selectorData.length; i < len; i++) {\n                    var dataItem = selector.data[i];\n                    var selectorDataItem = dataItem;\n                    if (selectorDataItem.expr) {\n                        if (!powerbi.DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\n                            return false;\n                    }\n                    else {\n                        if (!data_1.DataViewScopeWildcard.matches(dataItem, identities[i]))\n                            return false;\n                    }\n                }\n                return true;\n            }\n            Selector.matchesData = matchesData;\n            function matchesKeys(selector, keysList) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(keysList, 'keysList');\n                var selectorData = selector.data, selectorDataLength = selectorData.length;\n                if (selectorDataLength !== keysList.length)\n                    return false;\n                for (var i = 0; i < selectorDataLength; i++) {\n                    var selectorDataItem = selector.data[i], selectorDataExprs = void 0;\n                    if (selectorDataItem.expr) {\n                        selectorDataExprs = data_1.ScopeIdentityExtractor.getKeys(selectorDataItem.expr);\n                    }\n                    else if (selectorDataItem.exprs) {\n                        selectorDataExprs = selectorDataItem.exprs;\n                    }\n                    else {\n                        // In case DataViewRoleWildcard\n                        return false;\n                    }\n                    if (!selectorDataExprs)\n                        continue;\n                    if (!data_1.SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\n                        return false;\n                }\n                return true;\n            }\n            Selector.matchesKeys = matchesKeys;\n            /** Determines whether two selectors are equal. */\n            function equals(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (x.id !== y.id)\n                    return false;\n                if (x.metadata !== y.metadata)\n                    return false;\n                if (!equalsDataArray(x.data, y.data))\n                    return false;\n                return true;\n            }\n            Selector.equals = equals;\n            function equalsDataArray(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                if (x.length !== y.length)\n                    return false;\n                for (var i = 0, len = x.length; i < len; i++) {\n                    if (!equalsData(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            function equalsData(x, y) {\n                if (!x.expr && y.expr) {\n                    // TODO: We need to also check wildcard selectors too (once that's supported/figured out).\n                    return false;\n                }\n                return powerbi.DataViewScopeIdentity.equals(x, y);\n            }\n            function getKey(selector) {\n                var toStringify = {};\n                if (selector.data) {\n                    var data_3 = [];\n                    for (var i = 0, ilen = selector.data.length; i < ilen; i++) {\n                        data_3.push(selector.data[i].key);\n                    }\n                    toStringify.data = data_3;\n                }\n                if (selector.metadata)\n                    toStringify.metadata = selector.metadata;\n                if (selector.id)\n                    toStringify.id = selector.id;\n                return JSON.stringify(toStringify);\n            }\n            Selector.getKey = getKey;\n            function containsWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (!dataItems)\n                    return false;\n                for (var _i = 0, dataItems_1 = dataItems; _i < dataItems_1.length; _i++) {\n                    var dataItem = dataItems_1[_i];\n                    var wildCard = dataItem;\n                    if (wildCard.exprs || wildCard.roles)\n                        return true;\n                }\n                return false;\n            }\n            Selector.containsWildcard = containsWildcard;\n            function hasRoleWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (_.isEmpty(dataItems))\n                    return false;\n                for (var _i = 0, dataItems_2 = dataItems; _i < dataItems_2.length; _i++) {\n                    var dataItem = dataItems_2[_i];\n                    if (isRoleWildcard(dataItem))\n                        return true;\n                }\n                return false;\n            }\n            Selector.hasRoleWildcard = hasRoleWildcard;\n            function isRoleWildcard(dataItem) {\n                return !_.isEmpty(dataItem.roles);\n            }\n            Selector.isRoleWildcard = isRoleWildcard;\n        })(Selector = data_1.Selector || (data_1.Selector = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (EntitySourceType) {\n            EntitySourceType[EntitySourceType[\"Table\"] = 0] = \"Table\";\n            EntitySourceType[EntitySourceType[\"Pod\"] = 1] = \"Pod\";\n        })(data.EntitySourceType || (data.EntitySourceType = {}));\n        var EntitySourceType = data.EntitySourceType;\n        function getArithmeticOperatorName(arithmeticOperatorKind) {\n            switch (arithmeticOperatorKind) {\n                case 0 /* Add */:\n                    return \"Add\";\n                case 1 /* Subtract */:\n                    return \"Subtract\";\n                case 2 /* Multiply */:\n                    return \"Multiply\";\n                case 3 /* Divide */:\n                    return \"Divide\";\n            }\n            throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\n        }\n        data.getArithmeticOperatorName = getArithmeticOperatorName;\n        (function (TimeUnit) {\n            TimeUnit[TimeUnit[\"Day\"] = 0] = \"Day\";\n            TimeUnit[TimeUnit[\"Week\"] = 1] = \"Week\";\n            TimeUnit[TimeUnit[\"Month\"] = 2] = \"Month\";\n            TimeUnit[TimeUnit[\"Year\"] = 3] = \"Year\";\n            TimeUnit[TimeUnit[\"Decade\"] = 4] = \"Decade\";\n            TimeUnit[TimeUnit[\"Second\"] = 5] = \"Second\";\n            TimeUnit[TimeUnit[\"Minute\"] = 6] = \"Minute\";\n            TimeUnit[TimeUnit[\"Hour\"] = 7] = \"Hour\";\n        })(data.TimeUnit || (data.TimeUnit = {}));\n        var TimeUnit = data.TimeUnit;\n        (function (QueryAggregateFunction) {\n            QueryAggregateFunction[QueryAggregateFunction[\"Sum\"] = 0] = \"Sum\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Avg\"] = 1] = \"Avg\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Count\"] = 2] = \"Count\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Min\"] = 3] = \"Min\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Max\"] = 4] = \"Max\";\n            QueryAggregateFunction[QueryAggregateFunction[\"CountNonNull\"] = 5] = \"CountNonNull\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Median\"] = 6] = \"Median\";\n            QueryAggregateFunction[QueryAggregateFunction[\"StandardDeviation\"] = 7] = \"StandardDeviation\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Variance\"] = 8] = \"Variance\";\n        })(data.QueryAggregateFunction || (data.QueryAggregateFunction = {}));\n        var QueryAggregateFunction = data.QueryAggregateFunction;\n        (function (QueryComparisonKind) {\n            QueryComparisonKind[QueryComparisonKind[\"Equal\"] = 0] = \"Equal\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThan\"] = 1] = \"GreaterThan\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThanOrEqual\"] = 2] = \"GreaterThanOrEqual\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThan\"] = 3] = \"LessThan\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThanOrEqual\"] = 4] = \"LessThanOrEqual\";\n        })(data.QueryComparisonKind || (data.QueryComparisonKind = {}));\n        var QueryComparisonKind = data.QueryComparisonKind;\n        /** Defines semantic data types. */\n        (function (SemanticType) {\n            SemanticType[SemanticType[\"None\"] = 0] = \"None\";\n            SemanticType[SemanticType[\"Number\"] = 1] = \"Number\";\n            SemanticType[SemanticType[\"Integer\"] = 3] = \"Integer\";\n            SemanticType[SemanticType[\"DateTime\"] = 4] = \"DateTime\";\n            SemanticType[SemanticType[\"Time\"] = 8] = \"Time\";\n            SemanticType[SemanticType[\"Date\"] = 20] = \"Date\";\n            SemanticType[SemanticType[\"Month\"] = 35] = \"Month\";\n            SemanticType[SemanticType[\"Year\"] = 67] = \"Year\";\n            SemanticType[SemanticType[\"YearAndMonth\"] = 128] = \"YearAndMonth\";\n            SemanticType[SemanticType[\"MonthAndDay\"] = 256] = \"MonthAndDay\";\n            SemanticType[SemanticType[\"Decade\"] = 515] = \"Decade\";\n            SemanticType[SemanticType[\"YearAndWeek\"] = 1024] = \"YearAndWeek\";\n            SemanticType[SemanticType[\"String\"] = 2048] = \"String\";\n            SemanticType[SemanticType[\"Boolean\"] = 4096] = \"Boolean\";\n            SemanticType[SemanticType[\"Table\"] = 8192] = \"Table\";\n            SemanticType[SemanticType[\"Range\"] = 16384] = \"Range\";\n        })(data.SemanticType || (data.SemanticType = {}));\n        var SemanticType = data.SemanticType;\n        (function (FilterKind) {\n            FilterKind[FilterKind[\"Default\"] = 0] = \"Default\";\n            FilterKind[FilterKind[\"Period\"] = 1] = \"Period\";\n        })(data.FilterKind || (data.FilterKind = {}));\n        var FilterKind = data.FilterKind;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var QueryProjectionCollection = (function () {\n            function QueryProjectionCollection(items, activeProjectionRefs, showAll) {\n                debug.assertValue(items, 'items');\n                this.items = items;\n                this._activeProjectionRefs = activeProjectionRefs;\n                this._showAll = showAll;\n            }\n            /** Returns all projections in a mutable array. */\n            QueryProjectionCollection.prototype.all = function () {\n                return this.items;\n            };\n            Object.defineProperty(QueryProjectionCollection.prototype, \"activeProjectionRefs\", {\n                get: function () {\n                    return this._activeProjectionRefs;\n                },\n                set: function (queryReferences) {\n                    if (!_.isEmpty(queryReferences)) {\n                        var queryRefs = this.items.map(function (val) { return val.queryRef; });\n                        for (var _i = 0, queryReferences_1 = queryReferences; _i < queryReferences_1.length; _i++) {\n                            var queryReference = queryReferences_1[_i];\n                            if (!_.contains(queryRefs, queryReference))\n                                return;\n                        }\n                        this._activeProjectionRefs = queryReferences;\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(QueryProjectionCollection.prototype, \"showAll\", {\n                get: function () {\n                    return this._showAll;\n                },\n                set: function (value) {\n                    this._showAll = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            QueryProjectionCollection.prototype.addActiveQueryReference = function (queryRef) {\n                if (!this._activeProjectionRefs)\n                    this._activeProjectionRefs = [queryRef];\n                else\n                    this._activeProjectionRefs.push(queryRef);\n            };\n            QueryProjectionCollection.prototype.getLastActiveQueryReference = function () {\n                if (!_.isEmpty(this._activeProjectionRefs)) {\n                    return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\n                }\n            };\n            QueryProjectionCollection.prototype.clone = function () {\n                return new QueryProjectionCollection(_.clone(this.items), _.clone(this._activeProjectionRefs), this._showAll);\n            };\n            return QueryProjectionCollection;\n        }());\n        data.QueryProjectionCollection = QueryProjectionCollection;\n        var QueryProjectionsByRole;\n        (function (QueryProjectionsByRole) {\n            /** Clones the QueryProjectionsByRole. */\n            function clone(roles) {\n                if (!roles)\n                    return roles;\n                var clonedRoles = {};\n                for (var roleName in roles)\n                    clonedRoles[roleName] = roles[roleName].clone();\n                return clonedRoles;\n            }\n            QueryProjectionsByRole.clone = clone;\n            /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\n            function getRole(roles, name) {\n                debug.assertAnyValue(roles, 'roles');\n                debug.assertValue(name, 'name');\n                if (!roles)\n                    return;\n                return roles[name];\n            }\n            QueryProjectionsByRole.getRole = getRole;\n        })(QueryProjectionsByRole = data.QueryProjectionsByRole || (data.QueryProjectionsByRole = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** The system used to determine display units used during formatting */\n    (function (DisplayUnitSystemType) {\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Default\"] = 0] = \"Default\";\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Verbose\"] = 1] = \"Verbose\";\n        /**\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\n         * Suitable for dashboard tile cards\n         */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"WholeUnits\"] = 2] = \"WholeUnits\";\n        /**A display unit system that also contains Auto and None units for data labels*/\n        DisplayUnitSystemType[DisplayUnitSystemType[\"DataLabels\"] = 3] = \"DataLabels\";\n    })(powerbi.DisplayUnitSystemType || (powerbi.DisplayUnitSystemType = {}));\n    var DisplayUnitSystemType = powerbi.DisplayUnitSystemType;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Repreasents the sequence of the dates/times */\n    var DateTimeSequence = (function () {\n        // Constructors\n        /** Creates new instance of the DateTimeSequence */\n        function DateTimeSequence(unit) {\n            this.unit = unit;\n            this.sequence = [];\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\n        }\n        // Methods\n        /**\n         * Add a new Date to a sequence.\n         * @param date - date to add\n         */\n        DateTimeSequence.prototype.add = function (date) {\n            if (date < this.min) {\n                this.min = date;\n            }\n            if (date > this.max) {\n                this.max = date;\n            }\n            this.sequence.push(date);\n        };\n        // Methods\n        /**\n         * Extends the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.extendToCover = function (min, max) {\n            var x = this.min;\n            while (min < x) {\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\n                this.sequence.splice(0, 0, x);\n            }\n            this.min = x;\n            x = this.max;\n            while (x < max) {\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\n                this.sequence.push(x);\n            }\n            this.max = x;\n        };\n        /**\n         * Move the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.moveToCover = function (min, max) {\n            var delta = DateTimeSequence.getDelta(min, max, this.unit);\n            var count = Math.floor(delta / this.interval);\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\n            this.sequence = [];\n            this.sequence.push(this.min);\n            this.max = this.min;\n            while (this.max < max) {\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\n                this.sequence.push(this.max);\n            }\n        };\n        // Static\n        /**\n         * Calculate a new DateTimeSequence\n         * @param dataMin - Date representing min of the data range\n         * @param dataMax - Date representing max of the data range\n         * @param expectedCount - expected number of intervals in the sequence\n         * @param unit - of the intervals in the sequence\n         */\n        DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {\n            if (!unit) {\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\n            }\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Month:\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Week:\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Day:\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Second:\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\n                default:\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\n            }\n        };\n        DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\n            // Calculate range and sequence\n            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\n            // Calculate year sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\n            var newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval;\n            var date = new Date(newMinYear, 0, 1);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Year);\n            return result;\n        };\n        DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var minYear = dataMin.getFullYear();\n            var maxYear = dataMax.getFullYear();\n            var minMonth = dataMin.getMonth();\n            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\n            var date = new Date(minYear, 0, 1);\n            // Calculate month sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Month);\n            return result;\n        };\n        DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            var firstDayOfWeek = 0;\n            var minDayOfWeek = dataMin.getDay();\n            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\n            var minDay = dataMin.getDate() - dayOffset;\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Week));\n            // Calculate week sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Week);\n            return result;\n        };\n        DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, powerbi.DateTimeUnit.Day));\n            // Calculate day sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Day);\n            return result;\n        };\n        DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Hour));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Hour));\n            // Calculate hour sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Hour);\n            return result;\n        };\n        DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Minute));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Minute));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Minute);\n            return result;\n        };\n        DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Second));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Second));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Second);\n            return result;\n        };\n        DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\n            var min = DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Millisecond);\n            var max = DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Millisecond);\n            // Calculate milliseconds numeric sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Millisecond);\n            return result;\n        };\n        DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {\n            var result = new DateTimeSequence(unit);\n            for (var i = 0; i < sequence.sequence.length; i++) {\n                var x = sequence.sequence[i];\n                var d = DateTimeSequence.addInterval(date, x, unit);\n                result.add(d);\n            }\n            result.interval = sequence.interval;\n            result.intervalOffset = sequence.intervalOffset;\n            return result;\n        };\n        DateTimeSequence.addInterval = function (value, interval, unit) {\n            interval = Math.round(interval);\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateUtils.addYears(value, interval);\n                case powerbi.DateTimeUnit.Month:\n                    return DateUtils.addMonths(value, interval);\n                case powerbi.DateTimeUnit.Week:\n                    return DateUtils.addWeeks(value, interval);\n                case powerbi.DateTimeUnit.Day:\n                    return DateUtils.addDays(value, interval);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateUtils.addHours(value, interval);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateUtils.addMinutes(value, interval);\n                case powerbi.DateTimeUnit.Second:\n                    return DateUtils.addSeconds(value, interval);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateUtils.addMilliseconds(value, interval);\n            }\n        };\n        DateTimeSequence.getDelta = function (min, max, unit) {\n            var delta = 0;\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    delta = max.getFullYear() - min.getFullYear();\n                    break;\n                case powerbi.DateTimeUnit.Month:\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\n                    break;\n                case powerbi.DateTimeUnit.Week:\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Day:\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Hour:\n                    delta = (max.getTime() - min.getTime()) / 3600000;\n                    break;\n                case powerbi.DateTimeUnit.Minute:\n                    delta = (max.getTime() - min.getTime()) / 60000;\n                    break;\n                case powerbi.DateTimeUnit.Second:\n                    delta = (max.getTime() - min.getTime()) / 1000;\n                    break;\n                case powerbi.DateTimeUnit.Millisecond:\n                    delta = max.getTime() - min.getTime();\n                    break;\n            }\n            return delta;\n        };\n        DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {\n            maxCount = Math.max(maxCount, 2);\n            var totalDays = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Day);\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\n                return powerbi.DateTimeUnit.Year;\n            if (totalDays > 60 && totalDays > 7 * maxCount)\n                return powerbi.DateTimeUnit.Month;\n            if (totalDays > 14 && totalDays > 2 * maxCount)\n                return powerbi.DateTimeUnit.Week;\n            var totalHours = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Hour);\n            if (totalDays > 2 && totalHours > 12 * maxCount)\n                return powerbi.DateTimeUnit.Day;\n            if (totalHours >= 24 && totalHours >= maxCount)\n                return powerbi.DateTimeUnit.Hour;\n            var totalMinutes = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Minute);\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\n                return powerbi.DateTimeUnit.Minute;\n            var totalSeconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Second);\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\n                return powerbi.DateTimeUnit.Second;\n            var totalMilliseconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Millisecond);\n            if (totalMilliseconds > 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\n            var date = min;\n            if (date.getMilliseconds() !== 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            if (date.getSeconds() !== 0)\n                return powerbi.DateTimeUnit.Second;\n            if (date.getMinutes() !== 0)\n                return powerbi.DateTimeUnit.Minute;\n            if (date.getHours() !== 0)\n                return powerbi.DateTimeUnit.Hour;\n            if (date.getDate() !== 1)\n                return powerbi.DateTimeUnit.Day;\n            if (date.getMonth() !== 0)\n                return powerbi.DateTimeUnit.Month;\n            return powerbi.DateTimeUnit.Year;\n        };\n        // Constants\n        DateTimeSequence.MIN_COUNT = 1;\n        DateTimeSequence.MAX_COUNT = 1000;\n        return DateTimeSequence;\n    }());\n    powerbi.DateTimeSequence = DateTimeSequence;\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\n    var DateUtils;\n    (function (DateUtils) {\n        var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        /**\n         * Returns bool indicating weither the provided year is a leap year.\n         * @param year - year value\n         */\n        function isLeap(year) {\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\n        }\n        /**\n         * Returns number of days in the provided year/month.\n         * @param year - year value\n         * @param month - month value\n         */\n        function getMonthDays(year, month) {\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\n        }\n        /**\n         * Adds a specified number of years to the provided date.\n         * @param date - date value\n         * @param yearDelta - number of years to add\n         */\n        function addYears(date, yearDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var isLeapDay = month === 2 && day === 29;\n            var result = new Date(date.getTime());\n            year = year + yearDelta;\n            if (isLeapDay && !isLeap(year)) {\n                day = 28;\n            }\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addYears = addYears;\n        /**\n         * Adds a specified number of months to the provided date.\n         * @param date - date value\n         * @param monthDelta - number of months to add\n         */\n        function addMonths(date, monthDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            year += (monthDelta - (monthDelta % 12)) / 12;\n            month += monthDelta % 12;\n            // VSTS 1325771: Certain column charts don't display any data\n            // Wrap arround the month if is after december (value 11)\n            if (month > 11) {\n                month = month % 12;\n                year++;\n            }\n            day = Math.min(day, getMonthDays(year, month));\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addMonths = addMonths;\n        /**\n         * Adds a specified number of weeks to the provided date.\n         * @param date - date value\n         * @param weeks - number of weeks to add\n         */\n        function addWeeks(date, weeks) {\n            return addDays(date, weeks * 7);\n        }\n        DateUtils.addWeeks = addWeeks;\n        /**\n         * Adds a specified number of days to the provided date.\n         * @param date - date value\n         * @param days - number of days to add\n         */\n        function addDays(date, days) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            result.setFullYear(year, month, day + days);\n            return result;\n        }\n        DateUtils.addDays = addDays;\n        /**\n         * Adds a specified number of hours to the provided date.\n         * @param date - date value\n         * @param hours - number of hours to add\n         */\n        function addHours(date, hours) {\n            return new Date(date.getTime() + hours * 3600000);\n        }\n        DateUtils.addHours = addHours;\n        /**\n         * Adds a specified number of minutes to the provided date.\n         * @param date - date value\n         * @param minutes - number of minutes to add\n         */\n        function addMinutes(date, minutes) {\n            return new Date(date.getTime() + minutes * 60000);\n        }\n        DateUtils.addMinutes = addMinutes;\n        /**\n         * Adds a specified number of seconds to the provided date.\n         * @param date - date value\n         * @param seconds - number of seconds to add\n         */\n        function addSeconds(date, seconds) {\n            return new Date(date.getTime() + seconds * 1000);\n        }\n        DateUtils.addSeconds = addSeconds;\n        /**\n         * Adds a specified number of milliseconds to the provided date.\n         * @param date - date value\n         * @param milliseconds - number of milliseconds to add\n         */\n        function addMilliseconds(date, milliseconds) {\n            return new Date(date.getTime() + milliseconds);\n        }\n        DateUtils.addMilliseconds = addMilliseconds;\n    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    // Constants\n    var maxExponent = 24;\n    var defaultScientificBigNumbersBoundary = 1E15;\n    var scientificSmallNumbersBoundary = 1E-4;\n    var PERCENTAGE_FORMAT = '%';\n    var SCIENTIFIC_FORMAT = 'E+0';\n    var DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\n    // Regular expressions\n    /**\n     * This regex looks for strings that match one of the following conditions:\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\n     * The entire string (start to end) must match, and the match is not case-sensitive.\n     */\n    var SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\n    var DisplayUnit = (function () {\n        function DisplayUnit() {\n        }\n        // Methods\n        DisplayUnit.prototype.project = function (value) {\n            if (this.value) {\n                return powerbi.Double.removeDecimalNoise(value / this.value);\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.reverseProject = function (value) {\n            if (this.value) {\n                return value * this.value;\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.isApplicableTo = function (value) {\n            value = Math.abs(value);\n            var precision = powerbi.Double.getPrecision(value, 3);\n            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);\n        };\n        DisplayUnit.prototype.isScaling = function () {\n            return this.value > 1;\n        };\n        return DisplayUnit;\n    }());\n    powerbi.DisplayUnit = DisplayUnit;\n    var DisplayUnitSystem = (function () {\n        // Constructor\n        function DisplayUnitSystem(units) {\n            this.units = units ? units : [];\n        }\n        Object.defineProperty(DisplayUnitSystem.prototype, \"title\", {\n            // Properties\n            get: function () {\n                return this.displayUnit ? this.displayUnit.title : undefined;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        DisplayUnitSystem.prototype.update = function (value) {\n            if (value === undefined)\n                return;\n            this.unitBaseValue = value;\n            this.displayUnit = this.findApplicableDisplayUnit(value);\n        };\n        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {\n            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {\n                var unit = _a[_i];\n                if (unit.isApplicableTo(value))\n                    return unit;\n            }\n            return undefined;\n        };\n        DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros) {\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\n            if (this.isFormatSupported(format)) {\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\n                if (this.hasScientitifcFormat(format)) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\n                }\n                if (decimals != null) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n            }\n            return powerbi.formattingService.formatValue(value, format);\n        };\n        DisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DisplayUnitSystem.prototype.isPercentageFormat = function (format) {\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\n        };\n        DisplayUnitSystem.prototype.shouldRespectScalingUnit = function (format) {\n            return !this.isPercentageFormat(format);\n        };\n        DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function (format, decimals) {\n            return decimals;\n        };\n        DisplayUnitSystem.prototype.isScalingUnit = function () {\n            return this.displayUnit && this.displayUnit.isScaling();\n        };\n        DisplayUnitSystem.prototype.formatHelper = function (value, nonScientificFormat, format, decimals, trailingZeros) {\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\n            if ((format === 'g' || format === 'G') && decimals != null)\n                format = powerbi.visuals.valueFormatter.DefaultNumericFormat;\n            format = powerbi.NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\n            if (format && !powerbi.formattingService.isStandardNumberFormat(format))\n                return powerbi.formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\n            if (!format)\n                format = 'G';\n            if (!nonScientificFormat)\n                nonScientificFormat = '{0}';\n            var text = powerbi.formattingService.formatValue(value, format);\n            return powerbi.formattingService.format(nonScientificFormat, [text]);\n        };\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\n        DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals, trailingZeros) {\n            // Change unit base to a value appropriate for this value\n            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);\n            return this.format(value, format, decimals, trailingZeros);\n        };\n        DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {\n            if (this.units.length === 0)\n                return true;\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\n            var applicableRangeMin = 0;\n            for (var i = 0; i < this.units.length; i++) {\n                if (this.units[i].isScaling()) {\n                    applicableRangeMin = this.units[i].applicableRangeMin;\n                    break;\n                }\n            }\n            return Math.abs(value) < applicableRangeMin;\n        };\n        DisplayUnitSystem.prototype.isScientific = function (value) {\n            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\n        };\n        DisplayUnitSystem.prototype.hasScientitifcFormat = function (format) {\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\n        };\n        DisplayUnitSystem.prototype.supportsScientificFormat = function (format) {\n            if (format)\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\n            return true;\n        };\n        DisplayUnitSystem.prototype.shouldFallbackToScientific = function (value, format) {\n            return !this.hasScientitifcFormat(format)\n                && this.supportsScientificFormat(format)\n                && this.isScientific(value);\n        };\n        DisplayUnitSystem.prototype.getScientificFormat = function (data, format, decimals, trailingZeros) {\n            // Use scientific format outside of the range\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\n                var numericFormat = powerbi.NumberFormat.getNumericFormat(data, format);\n                if (decimals)\n                    numericFormat = powerbi.NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\n                if (numericFormat)\n                    return numericFormat + SCIENTIFIC_FORMAT;\n                else\n                    return DEFAULT_SCIENTIFIC_FORMAT;\n            }\n            return format;\n        };\n        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\n        return DisplayUnitSystem;\n    }());\n    powerbi.DisplayUnitSystem = DisplayUnitSystem;\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\n    var NoDisplayUnitSystem = (function (_super) {\n        __extends(NoDisplayUnitSystem, _super);\n        // Constructor\n        function NoDisplayUnitSystem() {\n            _super.call(this, []);\n        }\n        return NoDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\n        we are showing values (chart axes) and as such it is the default unit system. */\n    var DefaultDisplayUnitSystem = (function (_super) {\n        __extends(DefaultDisplayUnitSystem, _super);\n        // Constructor\n        function DefaultDisplayUnitSystem(unitLookup) {\n            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));\n        }\n        // Methods\n        DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        DefaultDisplayUnitSystem.reset = function () {\n            DefaultDisplayUnitSystem.units = null;\n        };\n        DefaultDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DefaultDisplayUnitSystem.units) {\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, function (value, previousUnitValue, min) {\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\n                    if (value - previousUnitValue >= 1000) {\n                        return value / 10;\n                    }\n                    return min;\n                });\n                // Ensure last unit has max of infinity\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DefaultDisplayUnitSystem.units;\n        };\n        return DefaultDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\n        where we have restricted space but do not want to show partial units. */\n    var WholeUnitsDisplayUnitSystem = (function (_super) {\n        __extends(WholeUnitsDisplayUnitSystem, _super);\n        // Constructor\n        function WholeUnitsDisplayUnitSystem(unitLookup) {\n            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        WholeUnitsDisplayUnitSystem.reset = function () {\n            WholeUnitsDisplayUnitSystem.units = null;\n        };\n        WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!WholeUnitsDisplayUnitSystem.units) {\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\n                // Ensure last unit has max of infinity\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return WholeUnitsDisplayUnitSystem.units;\n        };\n        WholeUnitsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        return WholeUnitsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;\n    var DataLabelsDisplayUnitSystem = (function (_super) {\n        __extends(DataLabelsDisplayUnitSystem, _super);\n        function DataLabelsDisplayUnitSystem(unitLookup) {\n            _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DataLabelsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DataLabelsDisplayUnitSystem.units) {\n                var units = [];\n                var adjustMinBasedOnPreviousUnit = function (value, previousUnitValue, min) {\n                    // Never returns true, we are always ignoring\n                    // We do not early switch (e.g. 100K instead of 0.1M)\n                    // Intended? If so, remove this function, otherwise, remove if statement\n                    if (value === -1)\n                        if (value - previousUnitValue >= 1000) {\n                            return value / 10;\n                        }\n                    return min;\n                };\n                // Add Auto & None\n                var names = unitLookup(-1);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                names = unitLookup(0);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                // Add normal units\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\n                // Ensure last unit has max of infinity\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DataLabelsDisplayUnitSystem.units;\n        };\n        DataLabelsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        // Constants\n        DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0;\n        DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1;\n        DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\n        return DataLabelsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;\n    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {\n        var units = [];\n        for (var i = 3; i < maxExponent; i++) {\n            var names = unitLookup(i);\n            if (names)\n                addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\n        }\n        return units;\n    }\n    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {\n        if (title || labelFormat) {\n            var min = value;\n            if (units.length > 0) {\n                var previousUnit = units[units.length - 1];\n                if (adjustMinBasedOnPreviousUnit)\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\n                previousUnit.applicableRangeMax = min;\n            }\n            var unit = new DisplayUnit();\n            unit.value = value;\n            unit.applicableRangeMin = min;\n            unit.applicableRangeMax = min * 1000;\n            unit.title = title;\n            unit.labelFormat = labelFormat;\n            units.push(unit);\n        }\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequence = (function () {\n        function NumericSequence() {\n        }\n        NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {\n            debug.assertValue(range, \"range\");\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\n            debug.assert(minPower === undefined || (minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP), \"minPower\");\n            debug.assert(maxAllowedMargin === undefined || (maxAllowedMargin >= 0), \"maxAllowedMargin\");\n            var result = new NumericSequence();\n            if (expectedCount === undefined)\n                expectedCount = 10;\n            else\n                expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (minPower === undefined)\n                minPower = powerbi.Double.MIN_EXP;\n            if (useZeroRefPoint === undefined)\n                useZeroRefPoint = false;\n            if (maxAllowedMargin === undefined)\n                maxAllowedMargin = 1;\n            if (steps === undefined)\n                steps = [1, 2, 5];\n            // Handle single stop case\n            if (range.forcedSingleStop) {\n                result.interval = range.getSize();\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\n                result.min = range.min;\n                result.max = range.max;\n                result.sequence = [range.forcedSingleStop];\n                return result;\n            }\n            var interval = 0;\n            var min = 0;\n            var max = 9;\n            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\n            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\n            var size = range.getSize();\n            var exp = powerbi.Double.log10(size);\n            // Account for Exp of steps\n            var stepExp = powerbi.Double.log10(steps[0]);\n            exp = exp - stepExp;\n            // Account for MaxCount\n            var expectedCountExp = powerbi.Double.log10(expectedCount);\n            exp = exp - expectedCountExp;\n            // Account for MinPower\n            exp = Math.max(exp, minPower - stepExp + 1);\n            var count = undefined;\n            // Create array of \"good looking\" numbers\n            if (interval !== 0) {\n                // If explicit interval is defined - use it instead of the steps array.\n                var power = powerbi.Double.pow10(exp);\n                var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\n                roundRange.shrinkByStep(range, interval);\n                min = roundRange.min;\n                max = roundRange.max;\n                count = Math.floor(roundRange.getSize() / interval);\n            }\n            else {\n                // No interval defined -> find optimal interval\n                var dexp = void 0;\n                for (dexp = 0; dexp < 3; dexp++) {\n                    var e = exp + dexp;\n                    var power = powerbi.Double.pow10(e);\n                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\n                    var stepsCount = steps.length;\n                    var stepPower = powerbi.Double.pow10(e - 1);\n                    for (var i = 0; i < stepsCount; i++) {\n                        var step = steps[i] * stepPower;\n                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\n                        roundRange.shrinkByStep(range, step);\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\n                            roundRange.min -= step;\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\n                            roundRange.max += step;\n                        // Count the intervals\n                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step);\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\n                            interval = step;\n                            min = roundRange.min;\n                            max = roundRange.max;\n                            break;\n                        }\n                    }\n                    // Increase the scale power until the interval is found\n                    if (interval !== 0)\n                        break;\n                }\n            }\n            // Avoid extreme count cases (>1000 ticks)\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\n                interval = (max - min) / count;\n            }\n            result.min = min;\n            result.max = max;\n            result.interval = interval;\n            result.intervalOffset = min - range.min;\n            result.maxAllowedMargin = maxAllowedMargin;\n            result.canExtendMin = canExtendMin;\n            result.canExtendMax = canExtendMax;\n            // Fill in the Sequence\n            var precision = powerbi.Double.getPrecision(interval, 0);\n            result.precision = precision;\n            var sequence = [];\n            var x = powerbi.Double.roundToPrecision(min, precision);\n            sequence.push(x);\n            for (var i = 0; i < count; i++) {\n                x = powerbi.Double.roundToPrecision(x + interval, precision);\n                sequence.push(x);\n            }\n            result.sequence = sequence;\n            result.trimMinMax(range.min, range.max);\n            return result;\n        };\n        /**\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid.\n         * @min - The minimum of the range.\n         * @max - The maximum of the range.\n         * @maxCount - The max count of intervals.\n         * @steps - array of intervals.\n         */\n        NumericSequence.calculateUnits = function (min, max, maxCount, steps) {\n            // Initialization actions\n            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (min === max) {\n                max = min + 1;\n            }\n            var stepCount = 0;\n            var step = 0;\n            // Calculate step\n            for (var i = 0; i < steps.length; i++) {\n                step = steps[i];\n                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);\n                var minStepCount = powerbi.Double.floorWithPrecision(min / step);\n                stepCount = maxStepCount - minStepCount;\n                if (stepCount <= maxCount) {\n                    break;\n                }\n            }\n            // Calculate the offset\n            var offset = -min;\n            offset = offset % step;\n            // Create sequence\n            var result = new NumericSequence();\n            result.sequence = [];\n            for (var x = min + offset;; x += step) {\n                result.sequence.push(x);\n                if (x >= max)\n                    break;\n            }\n            result.interval = step;\n            result.intervalOffset = offset;\n            result.min = result.sequence[0];\n            result.max = result.sequence[result.sequence.length - 1];\n            return result;\n        };\n        NumericSequence.prototype.trimMinMax = function (min, max) {\n            var minMargin = (min - this.min) / this.interval;\n            var maxMargin = (this.max - max) / this.interval;\n            var marginPrecision = 0.001;\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\n                this.min = min;\n            }\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\n                this.max = max;\n            }\n        };\n        NumericSequence.MIN_COUNT = 1;\n        NumericSequence.MAX_COUNT = 1000;\n        return NumericSequence;\n    }());\n    powerbi.NumericSequence = NumericSequence;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequenceRange = (function () {\n        function NumericSequenceRange() {\n        }\n        NumericSequenceRange.prototype._ensureIncludeZero = function () {\n            if (this.includeZero) {\n                // fixed min and max has higher priority than includeZero\n                if (this.min > 0 && !this.hasFixedMin) {\n                    this.min = 0;\n                }\n                if (this.max < 0 && !this.hasFixedMax) {\n                    this.max = 0;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureNotEmpty = function () {\n            if (this.min === this.max) {\n                if (!this.min) {\n                    this.min = 0;\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\n                    this.hasFixedMin = true;\n                    this.hasFixedMax = true;\n                }\n                else {\n                    // We are dealing with a single data value (includeZero is not set)\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\n                    // Interval is calculated based on the number:\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\n                    var value = this.min;\n                    var exp = powerbi.Double.log10(Math.abs(value));\n                    var step = void 0;\n                    if (exp >= 0 && exp < 4) {\n                        step = 0.5;\n                        this.forcedSingleStop = value;\n                    }\n                    else {\n                        step = powerbi.Double.pow10(exp) / 2;\n                        this.forcedSingleStop = null;\n                    }\n                    this.min = value - step;\n                    this.max = value + step;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureDirection = function () {\n            if (this.min > this.max) {\n                var temp = this.min;\n                this.min = this.max;\n                this.max = temp;\n            }\n        };\n        NumericSequenceRange.prototype.getSize = function () {\n            return this.max - this.min;\n        };\n        NumericSequenceRange.prototype.shrinkByStep = function (range, step) {\n            debug.assertValue(range, \"range\");\n            debug.assert(step > 0, \"step\");\n            var oldCount = this.min / step;\n            var newCount = range.min / step;\n            var deltaCount = Math.floor(newCount - oldCount);\n            this.min += deltaCount * step;\n            oldCount = this.max / step;\n            newCount = range.max / step;\n            deltaCount = Math.ceil(newCount - oldCount);\n            this.max += deltaCount * step;\n        };\n        NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\n            var result = new NumericSequenceRange();\n            result.includeZero = includeZero ? true : false;\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\n            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            // Calculate the range using the min, max, dataRange\n            if (result.hasFixedMin && result.hasFixedMax) {\n                result.min = fixedMin;\n                result.max = fixedMax;\n            }\n            else if (result.hasFixedMin) {\n                result.min = fixedMin;\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\n            }\n            else if (result.hasFixedMax) {\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\n                result.max = fixedMax;\n            }\n            else if (result.hasDataRange) {\n                result.min = dataMin;\n                result.max = dataMax;\n            }\n            else {\n                result.min = 0;\n                result.max = 0;\n            }\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            if (result.min === 0) {\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\n            }\n            else if (result.max === 0) {\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\n            }\n            return result;\n        };\n        NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\n            }\n            else {\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\n            }\n        };\n        NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {\n            debug.assertValue(fixedMin, \"fixedMin\");\n            debug.assertValue(fixedMax, \"fixedMax\");\n            var result = new NumericSequenceRange();\n            result.hasDataRange = false;\n            result.includeZero = includeZero;\n            result.min = fixedMin;\n            result.max = fixedMax;\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            result.hasFixedMin = true;\n            result.hasFixedMax = true;\n            return result;\n        };\n        NumericSequenceRange.DEFAULT_MAX = 10;\n        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;\n        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;\n        return NumericSequenceRange;\n    }());\n    powerbi.NumericSequenceRange = NumericSequenceRange;\n    /** Note: Exported for testability */\n    var ValueUtil;\n    (function (ValueUtil) {\n        function hasValue(value) {\n            return value !== undefined && value !== null;\n        }\n        ValueUtil.hasValue = hasValue;\n    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var valueFormatter;\n        (function (valueFormatter) {\n            var StringExtensions = jsCommon.StringExtensions;\n            var BeautifiedFormat = {\n                '0.00 %;-0.00 %;0.00 %': 'Percentage',\n                '0.0 %;-0.0 %;0.0 %': 'Percentage1',\n            };\n            valueFormatter.DefaultIntegerFormat = 'g';\n            valueFormatter.DefaultNumericFormat = '#,0.00';\n            valueFormatter.DefaultDateFormat = 'd';\n            var defaultLocalizedStrings = {\n                'NullValue': '(Blank)',\n                'BooleanTrue': 'True',\n                'BooleanFalse': 'False',\n                'NaNValue': 'NaN',\n                'InfinityValue': '+Infinity',\n                'NegativeInfinityValue': '-Infinity',\n                'RestatementComma': '{0}, {1}',\n                'RestatementCompoundAnd': '{0} and {1}',\n                'RestatementCompoundOr': '{0} or {1}',\n                'DisplayUnitSystem_EAuto_Title': 'Auto',\n                'DisplayUnitSystem_E0_Title': 'None',\n                'DisplayUnitSystem_E3_LabelFormat': '{0}K',\n                'DisplayUnitSystem_E3_Title': 'Thousands',\n                'DisplayUnitSystem_E6_LabelFormat': '{0}M',\n                'DisplayUnitSystem_E6_Title': 'Millions',\n                'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\n                'DisplayUnitSystem_E9_Title': 'Billions',\n                'DisplayUnitSystem_E12_LabelFormat': '{0}T',\n                'DisplayUnitSystem_E12_Title': 'Trillions',\n                'Percentage': '#,0.##%',\n                'Percentage1': '#,0.#%',\n                'TableTotalLabel': 'Total',\n                'Tooltip_HighlightedValueDisplayName': 'Highlighted',\n                'Funnel_PercentOfFirst': 'Percent of first',\n                'Funnel_PercentOfPrevious': 'Percent of previous',\n                'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlight)',\n                'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlight)',\n                // Geotagging strings\n                'GeotaggingString_Continent': 'continent',\n                'GeotaggingString_Continents': 'continents',\n                'GeotaggingString_Country': 'country',\n                'GeotaggingString_Countries': 'countries',\n                'GeotaggingString_State': 'state',\n                'GeotaggingString_States': 'states',\n                'GeotaggingString_City': 'city',\n                'GeotaggingString_Cities': 'cities',\n                'GeotaggingString_Town': 'town',\n                'GeotaggingString_Towns': 'towns',\n                'GeotaggingString_Province': 'province',\n                'GeotaggingString_Provinces': 'provinces',\n                'GeotaggingString_County': 'county',\n                'GeotaggingString_Counties': 'counties',\n                'GeotaggingString_Village': 'village',\n                'GeotaggingString_Villages': 'villages',\n                'GeotaggingString_Post': 'post',\n                'GeotaggingString_Zip': 'zip',\n                'GeotaggingString_Code': 'code',\n                'GeotaggingString_Place': 'place',\n                'GeotaggingString_Places': 'places',\n                'GeotaggingString_Address': 'address',\n                'GeotaggingString_Addresses': 'addresses',\n                'GeotaggingString_Street': 'street',\n                'GeotaggingString_Streets': 'streets',\n                'GeotaggingString_Longitude': 'longitude',\n                'GeotaggingString_Longitude_Short': 'lon',\n                'GeotaggingString_Latitude': 'latitude',\n                'GeotaggingString_Latitude_Short': 'lat',\n                'GeotaggingString_PostalCode': 'postal code',\n                'GeotaggingString_PostalCodes': 'postal codes',\n                'GeotaggingString_ZipCode': 'zip code',\n                'GeotaggingString_ZipCodes': 'zip codes',\n                'GeotaggingString_Territory': 'territory',\n                'GeotaggingString_Territories': 'territories',\n            };\n            function beautify(format) {\n                var key = BeautifiedFormat[format];\n                if (key)\n                    return defaultLocalizedStrings[key] || format;\n                return format;\n            }\n            function describeUnit(exponent) {\n                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\n                var title = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\n                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\n                if (title || format)\n                    return { title: title, format: format };\n            }\n            function getLocalizedString(stringId) {\n                return defaultLocalizedStrings[stringId];\n            }\n            valueFormatter.getLocalizedString = getLocalizedString;\n            // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\n            var locale = {\n                null: defaultLocalizedStrings['NullValue'],\n                true: defaultLocalizedStrings['BooleanTrue'],\n                false: defaultLocalizedStrings['BooleanFalse'],\n                NaN: defaultLocalizedStrings['NaNValue'],\n                infinity: defaultLocalizedStrings['InfinityValue'],\n                negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\n                beautify: function (format) { return beautify(format); },\n                describe: function (exponent) { return describeUnit(exponent); },\n                restatementComma: defaultLocalizedStrings['RestatementComma'],\n                restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\n                restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\n            };\n            var MaxScaledDecimalPlaces = 2;\n            var MaxValueForDisplayUnitRounding = 1000;\n            var MinIntegerValueForDisplayUnits = 10000;\n            var MinPrecisionForDisplayUnits = 2;\n            var DateTimeMetadataColumn = {\n                displayName: '',\n                type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.DateTime),\n            };\n            function getFormatMetadata(format) {\n                return powerbi.NumberFormat.getCustomFormatMetadata(format);\n            }\n            valueFormatter.getFormatMetadata = getFormatMetadata;\n            function setLocaleOptions(options) {\n                debug.assertValue(options, 'options');\n                locale = options;\n                powerbi.DefaultDisplayUnitSystem.reset();\n                powerbi.WholeUnitsDisplayUnitSystem.reset();\n            }\n            valueFormatter.setLocaleOptions = setLocaleOptions;\n            function createDefaultFormatter(formatString, allowFormatBeautification) {\n                if (allowFormatBeautification === void 0) { allowFormatBeautification = false; }\n                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;\n                return {\n                    format: function (value) {\n                        if (value == null)\n                            return locale.null;\n                        return formatCore(value, formatBeaut);\n                    }\n                };\n            }\n            valueFormatter.createDefaultFormatter = createDefaultFormatter;\n            /** Creates an IValueFormatter to be used for a range of values. */\n            function create(options) {\n                debug.assertValue(options, 'options');\n                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\n                if (shouldUseNumericDisplayUnits(options)) {\n                    var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType);\n                    var singleValueFormattingMode_1 = !!options.formatSingleValues;\n                    displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\n                    var forcePrecision_1 = options.precision != null;\n                    var decimals_1;\n                    if (forcePrecision_1)\n                        decimals_1 = -options.precision;\n                    else if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1)\n                        decimals_1 = -MaxScaledDecimalPlaces;\n                    // Detect axis precision\n                    if (options.detectAxisPrecision) {\n                        // Trailing zeroes\n                        forcePrecision_1 = true;\n                        var axisValue = options.value;\n                        if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 0)\n                            axisValue = axisValue / displayUnitSystem_1.displayUnit.value;\n                        if (powerbi.Double.isInteger(axisValue))\n                            decimals_1 = 0;\n                        else\n                            decimals_1 = powerbi.Double.log10(axisValue);\n                    }\n                    return {\n                        format: function (value) {\n                            var formattedValue = getStringFormat(value, true /*nullsAreBlank*/);\n                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                                return formattedValue;\n                            // Round to Double.DEFAULT_PRECISION\n                            if (value && !displayUnitSystem_1.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision_1)\n                                value = powerbi.Double.roundToPrecision(value);\n                            return singleValueFormattingMode_1 ?\n                                displayUnitSystem_1.formatSingleValue(value, format, decimals_1, forcePrecision_1) :\n                                displayUnitSystem_1.format(value, format, decimals_1, forcePrecision_1);\n                        },\n                        displayUnit: displayUnitSystem_1.displayUnit,\n                        options: options\n                    };\n                }\n                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\n                    var unit_1 = powerbi.DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\n                    return {\n                        format: function (value) {\n                            if (value == null)\n                                return locale.null;\n                            var formatString = powerbi.formattingService.dateFormatString(unit_1);\n                            return formatCore(value, formatString);\n                        },\n                        options: options\n                    };\n                }\n                return createDefaultFormatter(format);\n            }\n            valueFormatter.create = create;\n            function format(value, format, allowFormatBeautification) {\n                if (value == null)\n                    return locale.null;\n                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);\n            }\n            valueFormatter.format = format;\n            function getValueFormat(value, columnType) {\n                // If column type not defined or is not datetime\n                // ...and the value is of time datetime,\n                // then use the default date format string\n                if ((!columnType || !columnType.dateTime) && value instanceof Date)\n                    return getFormatString(DateTimeMetadataColumn, null, false);\n            }\n            function formatValueColumn(value, column, formatStringProp) {\n                var valueFormat = getValueFormat(value, column.type);\n                if (valueFormat)\n                    return formatCore(value, valueFormat);\n                else\n                    return formatCore(value, getFormatString(column, formatStringProp));\n            }\n            valueFormatter.formatValueColumn = formatValueColumn;\n            function createDisplayUnitSystem(displayUnitSystemType) {\n                if (displayUnitSystemType == null)\n                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                switch (displayUnitSystemType) {\n                    case powerbi.DisplayUnitSystemType.Default:\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.WholeUnits:\n                        return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.Verbose:\n                        return new powerbi.NoDisplayUnitSystem();\n                    case powerbi.DisplayUnitSystemType.DataLabels:\n                        return new powerbi.DataLabelsDisplayUnitSystem(locale.describe);\n                    default:\n                        debug.assertFail('Unknown display unit system type');\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                }\n            }\n            function shouldUseNumericDisplayUnits(options) {\n                var value = options.value;\n                var value2 = options.value2;\n                var format = options.format;\n                // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\n                if (options.formatSingleValues && format) {\n                    if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\n                        var isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\n                        if (isCustomFormat) {\n                            var precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\n                            if (precision < MinPrecisionForDisplayUnits)\n                                return false;\n                        }\n                        else if (powerbi.Double.isInteger(value))\n                            return false;\n                    }\n                }\n                if ((typeof value === 'number') || (typeof value2 === 'number')) {\n                    return true;\n                }\n            }\n            function shouldUseDateUnits(value, value2, tickCount) {\n                // must check both value and value2 because we'll need to get an interval for date units\n                return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\n            }\n            /*\n             * Get the column format. Order of precendence is:\n             *  1. Column format\n             *  2. Default PowerView policy for column type\n             */\n            function getFormatString(column, formatStringProperty, suppressTypeFallback) {\n                if (column) {\n                    if (formatStringProperty) {\n                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);\n                        if (propertyValue)\n                            return propertyValue;\n                    }\n                    if (!suppressTypeFallback) {\n                        var columnType = column.type;\n                        if (columnType) {\n                            if (columnType.dateTime)\n                                return valueFormatter.DefaultDateFormat;\n                            if (columnType.integer)\n                                return valueFormatter.DefaultIntegerFormat;\n                            if (columnType.numeric)\n                                return valueFormatter.DefaultNumericFormat;\n                        }\n                    }\n                }\n            }\n            valueFormatter.getFormatString = getFormatString;\n            function formatListCompound(strings, conjunction) {\n                var result;\n                if (!strings) {\n                    return null;\n                }\n                var length = strings.length;\n                if (length > 0) {\n                    result = strings[0];\n                    var lastIndex = length - 1;\n                    for (var i = 1, len = lastIndex; i < len; i++) {\n                        var value = strings[i];\n                        result = StringExtensions.format(locale.restatementComma, result, value);\n                    }\n                    if (length > 1) {\n                        var value = strings[lastIndex];\n                        result = StringExtensions.format(conjunction, result, value);\n                    }\n                }\n                else {\n                    result = null;\n                }\n                return result;\n            }\n            /** The returned string will look like 'A, B, ..., and C'  */\n            function formatListAnd(strings) {\n                return formatListCompound(strings, locale.restatementCompoundAnd);\n            }\n            valueFormatter.formatListAnd = formatListAnd;\n            /** The returned string will look like 'A, B, ..., or C' */\n            function formatListOr(strings) {\n                return formatListCompound(strings, locale.restatementCompoundOr);\n            }\n            valueFormatter.formatListOr = formatListOr;\n            function formatCore(value, format) {\n                var formattedValue = getStringFormat(value, false /*nullsAreBlank*/);\n                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                    return formattedValue;\n                return powerbi.formattingService.formatValue(value, format);\n            }\n            function getStringFormat(value, nullsAreBlank) {\n                if (value == null && nullsAreBlank)\n                    return locale.null;\n                if (value === true)\n                    return locale.true;\n                if (value === false)\n                    return locale.false;\n                if (typeof value === 'number' && isNaN(value))\n                    return locale.NaN;\n                if (value === Number.NEGATIVE_INFINITY)\n                    return locale.negativeInfinity;\n                if (value === Number.POSITIVE_INFINITY)\n                    return locale.infinity;\n                return '';\n            }\n            function getDisplayUnits(displayUnitSystemType) {\n                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\n                return displayUnitSystem.units;\n            }\n            valueFormatter.getDisplayUnits = getDisplayUnits;\n        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper;\n        (function (DataRoleHelper) {\n            function getMeasureIndexOfRole(grouped, roleName) {\n                if (!_.isEmpty(grouped)) {\n                    var firstGroup = grouped[0];\n                    if (firstGroup.values && firstGroup.values.length > 0) {\n                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {\n                            var value = firstGroup.values[i];\n                            if (value && value.source) {\n                                if (hasRole(value.source, roleName))\n                                    return i;\n                            }\n                        }\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;\n            function getCategoryIndexOfRole(categories, roleName) {\n                if (!_.isEmpty(categories)) {\n                    for (var i = 0, ilen = categories.length; i < ilen; i++) {\n                        if (hasRole(categories[i].source, roleName))\n                            return i;\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;\n            function hasRole(column, name) {\n                var roles = column.roles;\n                return roles && roles[name];\n            }\n            DataRoleHelper.hasRole = hasRole;\n            function hasRoleInDataView(dataView, name) {\n                return dataView != null\n                    && dataView.metadata != null\n                    && dataView.metadata.columns\n                    && _.any(dataView.metadata.columns, function (c) { return c.roles && c.roles[name] !== undefined; });\n            }\n            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;\n            function hasRoleInValueColumn(valueColumn, name) {\n                return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\n            }\n            DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;\n        })(DataRoleHelper = data.DataRoleHelper || (data.DataRoleHelper = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper = powerbi.data.DataRoleHelper;\n        function createIDataViewCategoricalReader(dataView) {\n            return new DataViewCategoricalReader(dataView);\n        }\n        data.createIDataViewCategoricalReader = createIDataViewCategoricalReader;\n        var DataViewCategoricalReader = (function () {\n            function DataViewCategoricalReader(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                this.dataView = dataView;\n                // Validate categories\n                var categorical;\n                if (dataView)\n                    categorical = dataView.categorical;\n                var categories;\n                if (categorical)\n                    categories = this.categories = categorical.categories;\n                this.hasValidCategories = !_.isEmpty(categories);\n                // Validate values\n                var values;\n                if (categorical)\n                    values = categorical.values;\n                // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\n                // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\n                this.hasAnyValidValues = false;\n                if (values != null) {\n                    var grouped = dataView.categorical.values.grouped();\n                    if (grouped.length > 0) {\n                        this.hasAnyValidValues = true;\n                        this.grouped = grouped;\n                        // Iterate through the first group's values to populate the valueRoleIndexMapping\n                        var valueRoleIndexMapping = {};\n                        var firstGroupValues = grouped[0].values;\n                        for (var valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\n                            var valueRoles = firstGroupValues[valueIndex].source.roles;\n                            for (var role in valueRoles) {\n                                if (valueRoles[role]) {\n                                    if (!valueRoleIndexMapping[role])\n                                        valueRoleIndexMapping[role] = [];\n                                    valueRoleIndexMapping[role].push(valueIndex);\n                                }\n                            }\n                        }\n                        this.valueRoleIndexMapping = valueRoleIndexMapping;\n                    }\n                }\n                if (this.hasAnyValidValues)\n                    this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\n            }\n            // Category methods\n            DataViewCategoricalReader.prototype.hasCategories = function () {\n                return this.hasValidCategories;\n            };\n            DataViewCategoricalReader.prototype.getCategoryCount = function () {\n                if (this.hasValidCategories)\n                    return this.categories[0].values.length;\n                else\n                    return 0;\n            };\n            DataViewCategoricalReader.prototype.getCategoryValues = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryValue = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values[categoryIndex] : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumn = function (roleName) {\n                if (this.hasValidCategories)\n                    return this.getCategoryFromRole(roleName);\n            };\n            DataViewCategoricalReader.prototype.getCategoryMetadataColumn = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.source : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumnIdentityFields = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.identityFields : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryDisplayName = function (roleName) {\n                if (this.hasValidCategories) {\n                    var targetColumn = this.getCategoryColumn(roleName);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.hasCompositeCategories = function () {\n                if (this.hasValidCategories)\n                    return this.categories.length > 1;\n            };\n            DataViewCategoricalReader.prototype.hasCategoryWithRole = function (roleName) {\n                return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\n            };\n            DataViewCategoricalReader.prototype.getCategoryObjects = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var category = this.getCategoryFromRole(roleName);\n                    if (category && category.objects) {\n                        return category.objects[categoryIndex];\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryFromRole = function (roleName) {\n                var categories = this.categories;\n                return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\n            };\n            // Value and measure methods\n            DataViewCategoricalReader.prototype.hasValues = function (roleName) {\n                return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\n            };\n            DataViewCategoricalReader.prototype.getValue = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        // For dynamic series, we only ever obtain the first value column from a role\n                        return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0);\n                    }\n                    else {\n                        // For static series or single series, we obtain value columns from the first series\n                        //    and use the seriesIndex to index into the value columns within the role\n                        return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex);\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllValuesForRole = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var valuesInRole = [];\n                    for (var roleValueIndex = void 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex));\n                    }\n                    return valuesInRole;\n                }\n            };\n            /**\n             * Obtains the value from grouped.\n             *\n             * Grouped:             [0] [1] [2] [3] (seriesIndex)\n             *                         /   \\\n             * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\n             *                    /    \\ \\  \\\n             * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\n             *\n             *--------------------------------|\n             *                      |Category |\n             * Series|Value Columns |A B C D E|\n             *--------------------------------|\n             *      0|col0 (tooltip)|         |\n             *       |col1 (value)  |         |\n             *       |col2 (value)  |         |\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      1|col0 (tooltip)|         |\n             *       |col1 (value)  |0 1 2 3 4|\n             *       |col2 (value)  |5 6 7 8 9|\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      2|col0 (tooltip)|...      |\n             *\n             * valueColumnIndexInRole is for indexing into the values for a single role\n             * valueColumnIndex is for indexing into the entire value array including\n             * all roles\n             *\n             * The valueRoleIndexMapping converts roleValueIndex and role (value role\n             * with an index of 1) into groupedValueIndex (2)\n             *\n             * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\n             * the second value column with role \"value\" (which is converted to a\n             * groupedValueIndex of 2) and the fourth value within that value column.\n             */\n            DataViewCategoricalReader.prototype.getValueInternal = function (roleName, categoryIndex, groupIndex, valueColumnIndexInRole) {\n                if (this.hasValues(roleName)) {\n                    var valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\n                    return this.grouped[groupIndex].values[valueColumnIndex].values[categoryIndex];\n                }\n            };\n            DataViewCategoricalReader.prototype.getFirstNonNullValueForCategory = function (roleName, categoryIndex) {\n                if (this.hasValues(roleName)) {\n                    if (!this.dataHasDynamicSeries) {\n                        debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\n                        return this.getValue(roleName, categoryIndex);\n                    }\n                    for (var seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\n                        var value = this.getValue(roleName, categoryIndex, seriesIndex);\n                        if (value != null) {\n                            return value;\n                        }\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getMeasureQueryName = function (roleName) {\n                if (this.hasValues(roleName))\n                    return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\n            };\n            DataViewCategoricalReader.prototype.getValueColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName))\n                    return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\n            };\n            DataViewCategoricalReader.prototype.getValueMetadataColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName))\n                    return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]].source;\n            };\n            DataViewCategoricalReader.prototype.getValueDisplayName = function (roleName, seriesIndex) {\n                if (this.hasValues(roleName)) {\n                    var targetColumn = this.getValueColumn(roleName, seriesIndex);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            // Series methods\n            DataViewCategoricalReader.prototype.hasDynamicSeries = function () {\n                return this.dataHasDynamicSeries;\n            };\n            DataViewCategoricalReader.prototype.getSeriesCount = function () {\n                if (this.hasAnyValidValues)\n                    return this.grouped.length;\n            };\n            DataViewCategoricalReader.prototype.getSeriesObjects = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].objects;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumns = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumnGroup = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex];\n            };\n            DataViewCategoricalReader.prototype.getSeriesMetadataColumn = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.source;\n            };\n            DataViewCategoricalReader.prototype.getSeriesColumnIdentityFields = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.identityFields;\n            };\n            DataViewCategoricalReader.prototype.getSeriesName = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].name;\n            };\n            DataViewCategoricalReader.prototype.getSeriesDisplayName = function () {\n                if (this.hasAnyValidValues && this.dataHasDynamicSeries)\n                    return this.dataView.categorical.values.source.displayName;\n            };\n            return DataViewCategoricalReader;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var valueFormatter = powerbi.visuals.valueFormatter;\n        var DataViewConcatenateCategoricalColumns;\n        (function (DataViewConcatenateCategoricalColumns) {\n            function detectAndApply(dataView, objectDescriptors, roleMappings, projectionOrdering, selects, projectionActiveItems) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                var result = dataView;\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical) {\n                    var concatenationSource = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\n                    if (concatenationSource) {\n                        // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\n                        var columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\n                        if (columnsSortedByProjectionOrdering.length >= 2) {\n                            var activeItemsToIgnoreInConcatenation = _.chain(projectionActiveItems[concatenationSource.roleName])\n                                .filter(function (activeItemInfo) { return activeItemInfo.suppressConcat; })\n                                .map(function (activeItemInfo) { return activeItemInfo.queryRef; })\n                                .value();\n                            result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\n                        }\n                    }\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.detectAndApply = detectAndApply;\n            /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\n            function applyToPlayChartCategorical(metadata, objectDescriptors, categoryRoleName, categorical) {\n                debug.assertValue(metadata, 'metadata');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(categorical, 'categorical');\n                var result;\n                if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\n                    // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\n                    // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\n                    // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\n                    // use inherit() rather than inheritSingle() here.\n                    var transformingColumns_1 = inherit(metadata.columns);\n                    var transformingMetadata = inherit(metadata, function (m) { m.columns = transformingColumns_1; });\n                    var transformingDataView = { metadata: transformingMetadata, categorical: categorical };\n                    result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\n                }\n                else {\n                    result = { metadata: metadata, categorical: categorical };\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical = applyToPlayChartCategorical;\n            /**\n             * Returns the role and its assocated category columns (from dataViewCategorical.categories)\n             * that should be concatenated for the case of hierarchical group.\n             *\n             * Note: In the future if we support sibling hierarchical groups in categorical,\n             * change the return type to CategoryColumnsByRole[] and update detection logic.\n             */\n            function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, metadata, dataViewMappings, selects, projectionActiveItems) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\n                var result;\n                // For now, just handle the case where roleMappings.length === 1.\n                // In the future, if there is more than 1, we might want to proceed if, \n                // for example, all role mappings map category to the same role name and they all have { max: 1 } conditions.\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var roleMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                var roleMappingForCategorical = (roleMappings && roleMappings.length === 1 && !!roleMappings[0].categorical) ? roleMappings[0] : undefined;\n                if (roleMappingForCategorical) {\n                    var roleNamesForCategory = getAllRolesInCategories(roleMappingForCategorical.categorical);\n                    // With \"list\" in role mapping, is it possible to have multiple role names for category.\n                    // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\n                    // We can change this if we want to support independent (sibling) group hierarchies in categorical.\n                    if (roleNamesForCategory && roleNamesForCategory.length === 1) {\n                        var targetRoleName_1 = roleNamesForCategory[0];\n                        var isVisualExpectingMaxOneCategoryColumn = !_.isEmpty(roleMappingForCategorical.conditions) &&\n                            _.every(roleMappingForCategorical.conditions, function (condition) { return condition[targetRoleName_1] && condition[targetRoleName_1].max === 1; });\n                        if (isVisualExpectingMaxOneCategoryColumn) {\n                            var categoriesForTargetRole_1 = _.filter(dataViewCategorical.categories, function (categoryColumn) { return categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName_1]; });\n                            // At least for now, we expect all category columns for the same role to have the same number of value entries.\n                            // If that's not the case, we won't run the concatenate logic for that role at all...\n                            var areValuesCountsEqual = _.every(categoriesForTargetRole_1, function (categoryColumn) { return categoryColumn.values.length === categoriesForTargetRole_1[0].values.length; });\n                            // Also, there is no need to concatenate columns unless there is actually more than one column\n                            if (areValuesCountsEqual &&\n                                categoriesForTargetRole_1.length >= 2) {\n                                result = {\n                                    roleName: targetRoleName_1,\n                                    categories: categoriesForTargetRole_1\n                                };\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n            /**\n             * Returns the array of role names that are mapped to categorical categories.\n             * Returns an empty array if none exists.\n             */\n            function getAllRolesInCategories(categoricalRoleMapping) {\n                debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\n                var roleNames = [];\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalRoleMapping.categories, {\n                    visitRole: function (roleName) {\n                        roleNames.push(roleName);\n                    }\n                });\n                return roleNames;\n            }\n            function applyConcatenation(dataView, objectDescriptors, roleName, columnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(roleName, 'roleName');\n                debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\n                var formatStringPropId = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                var concatenatedValues = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\n                var columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, function (categoryColumn) { return categoryColumn.source; });\n                var concatenatedColumnMetadata = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\n                var transformedDataView = inheritSingle(dataView);\n                addToMetadata(transformedDataView, concatenatedColumnMetadata);\n                var concatenatedCategoryColumn = createConcatenatedCategoryColumn(columnsSortedByProjectionOrdering, concatenatedColumnMetadata, concatenatedValues);\n                var dataViewCategorical = dataView.categorical;\n                var transformedCategoricalCategories = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\n                transformedCategoricalCategories.push(concatenatedCategoryColumn);\n                var transformedCategorical = inheritSingle(dataViewCategorical);\n                transformedCategorical.categories = transformedCategoricalCategories;\n                transformedDataView.categorical = transformedCategorical;\n                return transformedDataView;\n            }\n            function concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId) {\n                debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\n                debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\n                debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\n                var concatenatedValues = [];\n                // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\n                for (var _i = 0, columnsSortedByProjectionOrdering_1 = columnsSortedByProjectionOrdering; _i < columnsSortedByProjectionOrdering_1.length; _i++) {\n                    var categoryColumn = columnsSortedByProjectionOrdering_1[_i];\n                    var formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\n                    for (var i = 0, len = categoryColumn.values.length; i < len; i++) {\n                        if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\n                            var value = categoryColumn.values && categoryColumn.values[i];\n                            var formattedValue = valueFormatter.format(value, formatString);\n                            concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\n                        }\n                    }\n                }\n                return concatenatedValues;\n            }\n            /**\n            * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\n            */\n            function sortColumnsByProjectionOrdering(projectionOrdering, roleName, columns) {\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                debug.assertValue(roleName, 'roleName');\n                debug.assertValue(columns, 'columns');\n                var columnsInProjectionOrdering;\n                if (projectionOrdering) {\n                    // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\n                    var columnsByIndex_1 = {};\n                    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n                        var column = columns_1[_i];\n                        if (column.source.roles[roleName]) {\n                            debug.assert(!columnsByIndex_1[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\n                            columnsByIndex_1[column.source.index] = column;\n                        }\n                    }\n                    var columnIndicesInProjectionOrdering = projectionOrdering[roleName];\n                    columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\n                        .map(function (columnIndex) { return columnsByIndex_1[columnIndex]; })\n                        .filter(function (column) { return !!column; })\n                        .value();\n                }\n                else {\n                    // If projectionOrder is unspecified, just return the columns for the specified role in their current order\n                    columnsInProjectionOrdering = _.filter(columns, function (column) { return column.source.roles[roleName]; });\n                }\n                return columnsInProjectionOrdering;\n            }\n            /**\n             * Creates the column metadata that will back the column with the concatenated values.\n             */\n            function createConcatenatedColumnMetadata(roleName, sourceColumnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(roleName, 'roleName');\n                debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\n                debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(function (c) { return c.isMeasure; }).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\n                var concatenatedDisplayName;\n                for (var _i = 0, sourceColumnsSortedByProjectionOrdering_1 = sourceColumnsSortedByProjectionOrdering; _i < sourceColumnsSortedByProjectionOrdering_1.length; _i++) {\n                    var columnSource = sourceColumnsSortedByProjectionOrdering_1[_i];\n                    if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\n                        concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\n                    }\n                }\n                var newRoles = {};\n                newRoles[roleName] = true;\n                var newColumnMetadata = {\n                    displayName: concatenatedDisplayName,\n                    roles: newRoles,\n                    type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Text)\n                };\n                var columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\n                if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\n                    newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\n                }\n                // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\n                // If queryName is not set at all, the column chart visual will only render column for the first group instance.\n                // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\n                newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\n                return newColumnMetadata;\n            }\n            function addToMetadata(transformedDataView, newColumn) {\n                debug.assertValue(transformedDataView, 'transformedDataView');\n                debug.assertValue(newColumn, 'newColumn');\n                var transformedColumns = inheritSingle(transformedDataView.metadata.columns);\n                transformedColumns.push(newColumn);\n                var transformedMetadata = inheritSingle(transformedDataView.metadata);\n                transformedMetadata.columns = transformedColumns;\n                transformedDataView.metadata = transformedMetadata;\n            }\n            function createConcatenatedCategoryColumn(sourceColumnsSortedByProjectionOrdering, columnMetadata, concatenatedValues) {\n                debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\n                var newCategoryColumn = {\n                    source: columnMetadata,\n                    values: concatenatedValues\n                };\n                // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\n                // So, we'll just take the identities and identityFields from the first column\n                var firstColumn = sourceColumnsSortedByProjectionOrdering[0];\n                if (firstColumn.identity) {\n                    newCategoryColumn.identity = firstColumn.identity;\n                }\n                if (firstColumn.identityFields) {\n                    newCategoryColumn.identityFields = firstColumn.identityFields;\n                }\n                // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\n                if (firstColumn.objects) {\n                    newCategoryColumn.objects = firstColumn.objects;\n                }\n                return newCategoryColumn;\n            }\n        })(DataViewConcatenateCategoricalColumns = data.DataViewConcatenateCategoricalColumns || (data.DataViewConcatenateCategoricalColumns = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewMapping;\n    (function (DataViewMapping) {\n        function visitMapping(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var categorical = mapping.categorical;\n            if (categorical)\n                visitCategorical(categorical, visitor);\n            var table = mapping.table;\n            if (table)\n                visitTable(table, visitor);\n            var matrix = mapping.matrix;\n            if (matrix)\n                visitMatrix(matrix, visitor);\n            var tree = mapping.tree;\n            if (tree)\n                visitTree(tree, visitor);\n            var single = mapping.single;\n            if (single)\n                visitSingle(single, visitor);\n        }\n        DataViewMapping.visitMapping = visitMapping;\n        function visitCategorical(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitCategoricalCategories(mapping.categories, visitor);\n            visitCategoricalValues(mapping.values, visitor);\n        }\n        DataViewMapping.visitCategorical = visitCategorical;\n        function visitCategoricalCategories(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor);\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitCategoricalCategories = visitCategoricalCategories;\n        function visitCategoricalValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor, 0 /* CategoricalValue */);\n                visitFor(mapping, visitor, 0 /* CategoricalValue */);\n                visitList(mapping, visitor, 0 /* CategoricalValue */);\n                var groupedRoleMapping = mapping;\n                visitGrouped(groupedRoleMapping, visitor);\n                var group = groupedRoleMapping.group;\n                if (group) {\n                    for (var _i = 0, _a = group.select; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        visitBind(item, visitor, 1 /* CategoricalValueGroup */);\n                        visitFor(item, visitor, 1 /* CategoricalValueGroup */);\n                    }\n                }\n            }\n        }\n        DataViewMapping.visitCategoricalValues = visitCategoricalValues;\n        function visitTable(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var rows = mapping.rows;\n            visitBind(rows, visitor);\n            visitFor(rows, visitor);\n            visitList(rows, visitor);\n            visitReduction(rows, visitor);\n        }\n        DataViewMapping.visitTable = visitTable;\n        function visitMatrix(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitMatrixItems(mapping.rows, visitor);\n            visitMatrixItems(mapping.columns, visitor);\n            visitMatrixItems(mapping.values, visitor);\n        }\n        /**\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         *\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         * @param visitor The visitor.\n         */\n        function visitMatrixItems(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitMatrixItems = visitMatrixItems;\n        function visitTree(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitTreeNodes(mapping.nodes, visitor);\n            visitTreeValues(mapping.values, visitor);\n        }\n        function visitTreeNodes(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeNodes = visitTreeNodes;\n        function visitTreeValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeValues = visitTreeValues;\n        function visitBind(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var bind = mapping.bind;\n            if (bind) {\n                if (context != null)\n                    visitor.visitRole(bind.to, context);\n                else\n                    visitor.visitRole(bind.to);\n            }\n        }\n        function visitFor(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var forValue = mapping.for;\n            if (forValue) {\n                if (context != null)\n                    visitor.visitRole(forValue.in, context);\n                else\n                    visitor.visitRole(forValue.in);\n            }\n        }\n        function visitList(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var select = mapping.select;\n            if (select) {\n                for (var _i = 0, select_1 = select; _i < select_1.length; _i++) {\n                    var item = select_1[_i];\n                    visitBind(item, visitor, context);\n                    visitFor(item, visitor, context);\n                }\n            }\n        }\n        function visitGrouped(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (!mapping)\n                return;\n            var group = mapping.group;\n            if (group) {\n                visitor.visitRole(group.by);\n                visitReduction(group, visitor);\n            }\n        }\n        DataViewMapping.visitGrouped = visitGrouped;\n        function visitReduction(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (visitor.visitReduction) {\n                var reductionAlgorithm = mapping.dataReductionAlgorithm;\n                if (reductionAlgorithm) {\n                    visitor.visitReduction(reductionAlgorithm);\n                }\n            }\n        }\n        function visitSingle(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitor.visitRole(mapping.role);\n        }\n    })(DataViewMapping = powerbi.DataViewMapping || (powerbi.DataViewMapping = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewNormalizeValues;\n        (function (DataViewNormalizeValues) {\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                var rolesToNormalize = _.filter(options.dataRoles, function (role) { return !_.isEmpty(role.requiredTypes); });\n                filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\n            }\n            DataViewNormalizeValues.apply = apply;\n            function filterVariantMeasures(dataview, dataViewMappings, rolesToNormalize) {\n                debug.assertValue(dataview, 'dataview');\n                // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\n                    return;\n                var columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\n                var valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\n                var usedMappings = {};\n                for (var _i = 0, dataViewMappings_1 = dataViewMappings; _i < dataViewMappings_1.length; _i++) {\n                    var dataViewMapping = dataViewMappings_1[_i];\n                    // Get dataview specified in mappings which are also in dataview\n                    for (var dataViewMappingProp in dataViewMapping) {\n                        if (dataview[dataViewMappingProp] != null)\n                            usedMappings[dataViewMappingProp] = true;\n                    }\n                }\n                if (usedMappings['categorical'])\n                    filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\n                if (usedMappings['table'])\n                    filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\n                if (usedMappings['tree'])\n                    filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\n                if (usedMappings['matrix'])\n                    filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\n                if (usedMappings['single'])\n                    filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\n            }\n            DataViewNormalizeValues.filterVariantMeasures = filterVariantMeasures;\n            function generateMetadataColumnFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return false; };\n                var columnsToNormalize = {};\n                for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {\n                    var column = columns_2[_i];\n                    var roles = column.roles;\n                    if (!roles)\n                        continue;\n                    for (var _a = 0, rolesToNormalize_1 = rolesToNormalize; _a < rolesToNormalize_1.length; _a++) {\n                        var role = rolesToNormalize_1[_a];\n                        if (!roles[role.name])\n                            continue;\n                        columnsToNormalize[column.index] = true;\n                        break;\n                    }\n                }\n                return function (columnIndex) {\n                    if (isNaN(columnIndex))\n                        return false;\n                    return !!columnsToNormalize[columnIndex];\n                };\n            }\n            DataViewNormalizeValues.generateMetadataColumnFilter = generateMetadataColumnFilter;\n            function generateValueFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return true; };\n                var columnValueFilters = [];\n                // Build columnValueFilters based on role requiredTypes\n                for (var _i = 0, columns_3 = columns; _i < columns_3.length; _i++) {\n                    var column = columns_3[_i];\n                    var columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\n                    if (columnValueFilter)\n                        columnValueFilters[column.index] = columnValueFilter;\n                }\n                return function (columnIndex, value) {\n                    if (columnValueFilters[columnIndex])\n                        return columnValueFilters[columnIndex](value);\n                    return true;\n                };\n            }\n            DataViewNormalizeValues.generateValueFilter = generateValueFilter;\n            function generateColumnValueFilter(column, rolesToNormalize) {\n                var requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\n                if (_.isEmpty(requiredTypes))\n                    return;\n                return function (value) {\n                    return doesValueMatchTypes(value, requiredTypes);\n                };\n            }\n            function getColumnRequiredTypes(column, rolesToNormalize) {\n                var requiredTypes = [];\n                var columnRoles = column && column.roles;\n                if (!columnRoles)\n                    return requiredTypes;\n                for (var _i = 0, rolesToNormalize_2 = rolesToNormalize; _i < rolesToNormalize_2.length; _i++) {\n                    var role = rolesToNormalize_2[_i];\n                    if (!columnRoles[role.name])\n                        continue;\n                    for (var _a = 0, _b = role.requiredTypes; _a < _b.length; _a++) {\n                        var typeDescriptor = _b[_a];\n                        var type = powerbi.ValueType.fromDescriptor(typeDescriptor);\n                        requiredTypes.push(type);\n                    }\n                }\n                return requiredTypes;\n            }\n            DataViewNormalizeValues.getColumnRequiredTypes = getColumnRequiredTypes;\n            function filterVariantMeasuresCategorical(dataview, columnFilter, valueFilter) {\n                var values = dataview && dataview.values;\n                if (!values)\n                    return;\n                var valuesGrouped = values.grouped();\n                if (!valuesGrouped)\n                    return;\n                for (var _i = 0, valuesGrouped_1 = valuesGrouped; _i < valuesGrouped_1.length; _i++) {\n                    var valueGroup = valuesGrouped_1[_i];\n                    var valuesInGroup = valueGroup.values;\n                    for (var _a = 0, valuesInGroup_1 = valuesInGroup; _a < valuesInGroup_1.length; _a++) {\n                        var valueColumn = valuesInGroup_1[_a];\n                        var columnIndex = valueColumn.source.index;\n                        if (!columnFilter(columnIndex))\n                            continue;\n                        for (var i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\n                            valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\n                        }\n                    }\n                }\n            }\n            function filterVariantMeasuresTable(dataview, columnFilter, valueFilter) {\n                var columns = dataview && dataview.columns;\n                if (!columns)\n                    return;\n                var filteredColumns = [];\n                for (var _i = 0, columns_4 = columns; _i < columns_4.length; _i++) {\n                    var column = columns_4[_i];\n                    if (columnFilter(column.index))\n                        filteredColumns.push(column.index);\n                }\n                var rows = dataview.rows;\n                for (var i = 0, ilen = rows.length; i < ilen; i++) {\n                    for (var _a = 0, filteredColumns_1 = filteredColumns; _a < filteredColumns_1.length; _a++) {\n                        var index = filteredColumns_1[_a];\n                        rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresTreeNode(node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var columnIndex in node.values) {\n                        // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\n                        if (columnFilter(columnIndex)) {\n                            // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\n                            if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\n                                node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', columnIndex, valueFilter);\n                            else\n                                node.values = normalizeVariant(node.values, columnIndex, columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresMatrix(dataview, columnFilter, valueFilter) {\n                var root = dataview && dataview.rows && dataview.rows.root;\n                if (!root)\n                    return;\n                // Recurse into rows.children\n                // e.g. rows.children -> .children -> .children.values\n                filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\n            }\n            function filterVariantMeasuresMatrixRecursive(dataviewMatrix, node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var id in node.values) {\n                        // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\n                        var nodeValue = node.values[id];\n                        // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\n                        var valueSourceIndex = nodeValue.valueSourceIndex || 0;\n                        // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\n                        var columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\n                        if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\n                            node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter) {\n                if (!dataview.single)\n                    return;\n                var roleNames = [];\n                for (var _i = 0, rolesToNormalize_3 = rolesToNormalize; _i < rolesToNormalize_3.length; _i++) {\n                    var role = rolesToNormalize_3[_i];\n                    if (role.name)\n                        roleNames.push(role.name);\n                }\n                var columns = dataview.metadata.columns;\n                for (var _a = 0, dataViewMappings_2 = dataViewMappings; _a < dataViewMappings_2.length; _a++) {\n                    var dataViewMapping = dataViewMappings_2[_a];\n                    var roleName = dataViewMapping.single.role;\n                    if (roleNames.indexOf(roleName) !== -1) {\n                        var column = firstColumnByRoleName(columns, roleName);\n                        if (column)\n                            dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\n                        return;\n                    }\n                }\n            }\n            function normalizeVariant(object, key, columnIndex, valueFilter) {\n                if (!object)\n                    return;\n                var value = object[key];\n                if (value !== null && !valueFilter(columnIndex, value)) {\n                    object = inheritSingle(object);\n                    object[key] = null;\n                }\n                return object;\n            }\n            DataViewNormalizeValues.normalizeVariant = normalizeVariant;\n            function doesValueMatchTypes(value, types) {\n                for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n                    var type = types_1[_i];\n                    if (type.numeric || type.integer)\n                        return typeof (value) === 'number';\n                }\n                return false;\n            }\n            function firstColumnByRoleName(columns, roleName) {\n                for (var _i = 0, columns_5 = columns; _i < columns_5.length; _i++) {\n                    var column = columns_5[_i];\n                    var columnRoles = column && column.roles;\n                    if (columnRoles && columnRoles[roleName])\n                        return column;\n                }\n            }\n        })(DataViewNormalizeValues = data.DataViewNormalizeValues || (data.DataViewNormalizeValues = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewObjects;\n    (function (DataViewObjects) {\n        /** Gets the value of the given object/property pair. */\n        function getValue(objects, propertyId, defaultValue) {\n            debug.assertAnyValue(objects, 'objects');\n            debug.assertValue(propertyId, 'propertyId');\n            if (!objects)\n                return defaultValue;\n            var objectOrMap = objects[propertyId.objectName];\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\n            var object = objectOrMap;\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\n        }\n        DataViewObjects.getValue = getValue;\n        /** Gets an object from objects. */\n        function getObject(objects, objectName, defaultValue) {\n            if (objects && objects[objectName]) {\n                var object = objects[objectName];\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\n                return object;\n            }\n            else {\n                return defaultValue;\n            }\n        }\n        DataViewObjects.getObject = getObject;\n        /** Gets a map of user-defined objects. */\n        function getUserDefinedObjects(objects, objectName) {\n            if (objects && objects[objectName]) {\n                var map = objects[objectName];\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\n                return map;\n            }\n        }\n        DataViewObjects.getUserDefinedObjects = getUserDefinedObjects;\n        /** Gets the solid color from a fill property. */\n        function getFillColor(objects, propertyId, defaultColor) {\n            var value = getValue(objects, propertyId);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObjects.getFillColor = getFillColor;\n        /** Returns true if the given object represents a collection of user-defined objects */\n        function isUserDefined(objectOrMap) {\n            return _.isArray(objectOrMap);\n        }\n        DataViewObjects.isUserDefined = isUserDefined;\n    })(DataViewObjects = powerbi.DataViewObjects || (powerbi.DataViewObjects = {}));\n    var DataViewObject;\n    (function (DataViewObject) {\n        function getValue(object, propertyName, defaultValue) {\n            debug.assertAnyValue(object, 'object');\n            debug.assertValue(propertyName, 'propertyName');\n            if (!object)\n                return defaultValue;\n            var propertyValue = object[propertyName];\n            if (propertyValue === undefined)\n                return defaultValue;\n            return propertyValue;\n        }\n        DataViewObject.getValue = getValue;\n        /** Gets the solid color from a fill property using only a propertyName */\n        function getFillColorByPropertyName(objects, propertyName, defaultColor) {\n            var value = DataViewObject.getValue(objects, propertyName);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;\n    })(DataViewObject = powerbi.DataViewObject || (powerbi.DataViewObject = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var JsonComparer = jsCommon.JsonComparer;\n        var DataViewObjectDefinitions;\n        (function (DataViewObjectDefinitions) {\n            /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\n            function ensure(defns, objectName, selector) {\n                debug.assertValue(defns, 'defns');\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    defns[objectName] = defnsForObject = [];\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n                var newDefn = {\n                    selector: selector,\n                    properties: {},\n                };\n                defnsForObject.push(newDefn);\n                return newDefn;\n            }\n            DataViewObjectDefinitions.ensure = ensure;\n            function deleteProperty(defns, objectName, selector, propertyName) {\n                debug.assertValue(defns, 'defns');\n                var defn = getObjectDefinition(defns, objectName, selector);\n                if (!defn)\n                    return;\n                DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\n            }\n            DataViewObjectDefinitions.deleteProperty = deleteProperty;\n            function setValue(defns, propertyId, selector, value) {\n                debug.assertValue(defns, 'defns');\n                debug.assertValue(propertyId, 'propertyId');\n                ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\n            }\n            DataViewObjectDefinitions.setValue = setValue;\n            function getValue(defns, propertyId, selector) {\n                var properties = getPropertyContainer(defns, propertyId, selector);\n                if (!properties)\n                    return;\n                return properties[propertyId.propertyName];\n            }\n            DataViewObjectDefinitions.getValue = getValue;\n            function getPropertyContainer(defns, propertyId, selector) {\n                var defn = getObjectDefinition(defns, propertyId.objectName, selector);\n                if (!defn)\n                    return;\n                return defn.properties;\n            }\n            DataViewObjectDefinitions.getPropertyContainer = getPropertyContainer;\n            function getObjectDefinition(defns, objectName, selector) {\n                debug.assertAnyValue(defns, 'defns');\n                debug.assertValue(objectName, 'objectName');\n                debug.assertAnyValue(selector, 'selector');\n                if (!defns)\n                    return;\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    return;\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n            }\n            DataViewObjectDefinitions.getObjectDefinition = getObjectDefinition;\n            function propertiesAreEqual(a, b) {\n                if (a instanceof data.SemanticFilter && b instanceof data.SemanticFilter) {\n                    return data.SemanticFilter.isSameFilter(a, b);\n                }\n                return JsonComparer.equals(a, b);\n            }\n            DataViewObjectDefinitions.propertiesAreEqual = propertiesAreEqual;\n            function allPropertiesAreEqual(a, b) {\n                debug.assertValue(a, 'a');\n                debug.assertValue(b, 'b');\n                if (Object.keys(a).length !== Object.keys(b).length)\n                    return false;\n                for (var property in a) {\n                    if (!propertiesAreEqual(a[property], b[property]))\n                        return false;\n                }\n                return true;\n            }\n            DataViewObjectDefinitions.allPropertiesAreEqual = allPropertiesAreEqual;\n            function encodePropertyValue(value, valueTypeDescriptor) {\n                debug.assertAnyValue(value, 'value');\n                debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\n                if (valueTypeDescriptor.bool) {\n                    if (typeof (value) !== 'boolean')\n                        value = false; // This is fallback, which doesn't really belong here.\n                    return data.SQExprBuilder.boolean(value);\n                }\n                else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\n                    return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.numeric) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                }\n                else if (valueTypeDescriptor.fill) {\n                    if (value) {\n                        return {\n                            solid: { color: data.SQExprBuilder.text(value) }\n                        };\n                    }\n                }\n                else if (valueTypeDescriptor.formatting) {\n                    if (valueTypeDescriptor.formatting.labelDisplayUnits) {\n                        return data.SQExprBuilder.double(+value);\n                    }\n                    else {\n                        return data.SQExprBuilder.text(value);\n                    }\n                }\n                else if (valueTypeDescriptor.enumeration) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                    else\n                        return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.misc) {\n                    if (value) {\n                        value = data.SQExprBuilder.text(value);\n                    }\n                    else {\n                        value = null;\n                    }\n                }\n                else if (valueTypeDescriptor.image) {\n                    if (value) {\n                        var imageValue = value;\n                        var imageDefinition = {\n                            name: data.SQExprBuilder.text(imageValue.name),\n                            url: data.SQExprBuilder.text(imageValue.url),\n                        };\n                        if (imageValue.scaling)\n                            imageDefinition.scaling = data.SQExprBuilder.text(imageValue.scaling);\n                        return imageDefinition;\n                    }\n                }\n                return value;\n            }\n            DataViewObjectDefinitions.encodePropertyValue = encodePropertyValue;\n            function clone(original) {\n                debug.assertValue(original, 'original');\n                var cloned = {};\n                for (var objectName in original) {\n                    var originalDefns = original[objectName];\n                    if (_.isEmpty(originalDefns))\n                        continue;\n                    var clonedDefns = [];\n                    for (var _i = 0, originalDefns_1 = originalDefns; _i < originalDefns_1.length; _i++) {\n                        var originalDefn = originalDefns_1[_i];\n                        clonedDefns.push({\n                            properties: cloneProperties(originalDefn.properties),\n                            selector: originalDefn.selector,\n                        });\n                    }\n                    cloned[objectName] = clonedDefns;\n                }\n                return cloned;\n            }\n            DataViewObjectDefinitions.clone = clone;\n            function cloneProperties(original) {\n                debug.assertValue(original, 'original');\n                // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\n                return _.clone(original);\n            }\n        })(DataViewObjectDefinitions = data.DataViewObjectDefinitions || (data.DataViewObjectDefinitions = {}));\n        var DataViewObjectDefinition;\n        (function (DataViewObjectDefinition) {\n            function deleteSingleProperty(defn, propertyName) {\n                //note: We decided that delete is acceptable here and that we don't need optimization here\n                delete defn.properties[propertyName];\n            }\n            DataViewObjectDefinition.deleteSingleProperty = deleteSingleProperty;\n        })(DataViewObjectDefinition = data.DataViewObjectDefinition || (data.DataViewObjectDefinition = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectDescriptors;\n        (function (DataViewObjectDescriptors) {\n            /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\n            function findFormatString(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var formattingTypeDesc = powerbi.ValueType.fromDescriptor(propDesc.type).formatting;\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\n                });\n            }\n            DataViewObjectDescriptors.findFormatString = findFormatString;\n            /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\n            function findFilterOutput(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.filter;\n                });\n            }\n            DataViewObjectDescriptors.findFilterOutput = findFilterOutput;\n            /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\n            function findDefaultValue(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.expression && propType.expression.defaultValue;\n                });\n            }\n            DataViewObjectDescriptors.findDefaultValue = findDefaultValue;\n            function findProperty(descriptors, propPredicate) {\n                debug.assertAnyValue(descriptors, 'descriptors');\n                debug.assertAnyValue(propPredicate, 'propPredicate');\n                if (!descriptors)\n                    return;\n                for (var objectName in descriptors) {\n                    var objPropDescs = descriptors[objectName].properties;\n                    for (var propertyName in objPropDescs) {\n                        if (propPredicate(objPropDescs[propertyName])) {\n                            return {\n                                objectName: objectName,\n                                propertyName: propertyName,\n                            };\n                        }\n                    }\n                }\n            }\n        })(DataViewObjectDescriptors = data.DataViewObjectDescriptors || (data.DataViewObjectDescriptors = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n*  Power BI Visualizations\n*\n*  Copyright (c) Microsoft Corporation\n*  All rights reserved.\n *  MIT License\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n*\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n*  THE SOFTWARE.\n*/\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectEvaluationUtils;\n        (function (DataViewObjectEvaluationUtils) {\n            function evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var objects;\n                for (var j = 0, jlen = objectDefns.length; j < jlen; j++) {\n                    var objectDefinition = objectDefns[j], objectName = objectDefinition.name;\n                    var evaluatedObject = data.DataViewObjectEvaluator.run(evalContext, objectDescriptors[objectName], objectDefinition.properties);\n                    if (!evaluatedObject)\n                        continue;\n                    if (!objects)\n                        objects = {};\n                    // NOTE: this currently has last-object-wins semantics.\n                    objects[objectName] = evaluatedObject;\n                }\n                return objects;\n            }\n            DataViewObjectEvaluationUtils.evaluateDataViewObjects = evaluateDataViewObjects;\n            function groupObjectsBySelector(objectDefinitions) {\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                var grouped = {\n                    data: [],\n                };\n                if (objectDefinitions) {\n                    for (var objectName in objectDefinitions) {\n                        var objectDefnList = objectDefinitions[objectName];\n                        for (var i = 0, len = objectDefnList.length; i < len; i++) {\n                            var objectDefn = objectDefnList[i];\n                            ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\n                                name: objectName,\n                                properties: objectDefn.properties,\n                            });\n                        }\n                    }\n                }\n                return grouped;\n            }\n            DataViewObjectEvaluationUtils.groupObjectsBySelector = groupObjectsBySelector;\n            function ensureDefinitionListForSelector(grouped, selector) {\n                debug.assertValue(grouped, 'grouped');\n                debug.assertAnyValue(selector, 'selector');\n                if (!selector) {\n                    if (!grouped.metadataOnce)\n                        grouped.metadataOnce = { objects: [] };\n                    return grouped.metadataOnce;\n                }\n                var groupedObjects;\n                if (selector.data) {\n                    groupedObjects = grouped.data;\n                }\n                else if (selector.metadata) {\n                    if (!grouped.metadata)\n                        grouped.metadata = [];\n                    groupedObjects = grouped.metadata;\n                }\n                else if (selector.id) {\n                    if (!grouped.userDefined)\n                        grouped.userDefined = [];\n                    groupedObjects = grouped.userDefined;\n                }\n                debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\n                for (var _i = 0, groupedObjects_1 = groupedObjects; _i < groupedObjects_1.length; _i++) {\n                    var item_1 = groupedObjects_1[_i];\n                    if (data.Selector.equals(selector, item_1.selector))\n                        return item_1;\n                }\n                var item = {\n                    selector: selector,\n                    objects: [],\n                };\n                groupedObjects.push(item);\n                return item;\n            }\n            function addImplicitObjects(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                if (selectTransforms) {\n                    addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                    addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                }\n            }\n            DataViewObjectEvaluationUtils.addImplicitObjects = addImplicitObjects;\n            function addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                if (!formatStringProp)\n                    return;\n                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                    var selectTransform = selectTransforms[selectIdx];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyFormatString(objectsForAllSelectors, formatStringProp, selectTransform.queryName, selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\n                }\n            }\n            /** Registers properties for default value, if the properties are not explicitly provided. */\n            function addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var defaultValueProp = data.DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\n                if (!defaultValueProp)\n                    return;\n                for (var _i = 0, selectTransforms_1 = selectTransforms; _i < selectTransforms_1.length; _i++) {\n                    var selectTransform = selectTransforms_1[_i];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyDefaultValue(objectsForAllSelectors, defaultValueProp, selectTransform.queryName, selectTransform.defaultValue);\n                }\n            }\n            function getColumnFormatForIndex(columns, selectIdx) {\n                for (var columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\n                    var column = columns[columnIdx];\n                    if (!column || column.index !== selectIdx)\n                        continue;\n                    return column.format;\n                }\n            }\n            function applyFormatString(objectsForAllSelectors, formatStringProp, queryName, formatStringValue) {\n                if (!formatStringValue)\n                    return;\n                // There is a format string specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, formatStringProp, { metadata: queryName }, data.SQExprBuilder.text(formatStringValue));\n            }\n            function applyDefaultValue(objectsForAllSelectors, defaultValueProp, queryName, defaultValue) {\n                if (!defaultValue)\n                    return;\n                // There is a default value specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, defaultValueProp, { metadata: queryName }, defaultValue);\n            }\n            function applyMetadataProperty(objectsForAllSelectors, propertyId, selector, value) {\n                var objectDefns;\n                if (selector) {\n                    var metadataObjects = objectsForAllSelectors.metadata;\n                    if (!metadataObjects)\n                        metadataObjects = objectsForAllSelectors.metadata = [];\n                    objectDefns = metadataObjects;\n                }\n                else {\n                    var metadataOnce = objectsForAllSelectors.metadataOnce;\n                    if (!metadataOnce)\n                        metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\n                    objectDefns = [metadataOnce];\n                }\n                var targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\n                var targetObjectDefn;\n                if (targetMetadataObject) {\n                    var targetObjectDefns = targetMetadataObject.objects;\n                    targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\n                    if (targetObjectDefn) {\n                        if (targetObjectDefn.properties[propertyId.propertyName])\n                            return;\n                    }\n                    else {\n                        targetObjectDefn = {\n                            name: propertyId.objectName,\n                            properties: {},\n                        };\n                        targetObjectDefns.push(targetObjectDefn);\n                    }\n                }\n                else {\n                    targetObjectDefn = {\n                        name: propertyId.objectName,\n                        properties: {}\n                    };\n                    objectDefns.push({\n                        selector: selector,\n                        objects: [targetObjectDefn],\n                    });\n                }\n                targetObjectDefn.properties[propertyId.propertyName] = value;\n            }\n            function findWithMatchingSelector(objects, selector) {\n                debug.assertValue(objects, 'objects');\n                debug.assertAnyValue(selector, 'selector');\n                for (var i = 0, len = objects.length; i < len; i++) {\n                    var object = objects[i];\n                    if (data.Selector.equals(object.selector, selector))\n                        return object;\n                }\n            }\n            function findExistingObject(objectDefns, objectName) {\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(objectName, 'objectName');\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefn = objectDefns[i];\n                    if (objectDefn.name === objectName)\n                        return objectDefn;\n                }\n            }\n        })(DataViewObjectEvaluationUtils = data.DataViewObjectEvaluationUtils || (data.DataViewObjectEvaluationUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\n        var DataViewObjectEvaluator;\n        (function (DataViewObjectEvaluator) {\n            var colorValueType = powerbi.ValueType.fromDescriptor({ formatting: { color: true } });\n            var numericType = powerbi.ValueType.fromDescriptor({ numeric: true });\n            var textType = powerbi.ValueType.fromDescriptor({ text: true });\n            function run(evalContext, objectDescriptor, propertyDefinitions) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\n                debug.assertValue(propertyDefinitions, 'propertyDefinitions');\n                if (!objectDescriptor)\n                    return;\n                var object, propertyDescriptors = objectDescriptor.properties;\n                for (var propertyName in propertyDefinitions) {\n                    var propertyDefinition = propertyDefinitions[propertyName], propertyDescriptor = propertyDescriptors[propertyName];\n                    if (!propertyDescriptor)\n                        continue;\n                    var propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\n                    if (propertyValue === undefined)\n                        continue;\n                    if (!object)\n                        object = {};\n                    object[propertyName] = propertyValue;\n                }\n                return object;\n            }\n            DataViewObjectEvaluator.run = run;\n            /** Note: Exported for testability */\n            function evaluateProperty(evalContext, propertyDescriptor, propertyDefinition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(propertyDescriptor, 'propertyDescriptor');\n                debug.assertValue(propertyDefinition, 'propertyDefinition');\n                var structuralType = propertyDescriptor.type;\n                if (structuralType && structuralType.expression)\n                    return propertyDefinition;\n                var value = evaluateValue(evalContext, propertyDefinition, powerbi.ValueType.fromDescriptor(propertyDescriptor.type));\n                if (value !== undefined || (propertyDefinition instanceof data.RuleEvaluation))\n                    return value;\n                return evaluateFill(evalContext, propertyDefinition, structuralType)\n                    || evaluateFillRule(evalContext, propertyDefinition, structuralType)\n                    || evaluateImage(evalContext, propertyDefinition, structuralType)\n                    || evaluateParagraphs(evalContext, propertyDefinition, structuralType)\n                    || propertyDefinition;\n            }\n            DataViewObjectEvaluator.evaluateProperty = evaluateProperty;\n            function evaluateFill(evalContext, fillDefn, type) {\n                var fillType = type.fill;\n                if (!fillType)\n                    return;\n                if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\n                    return {\n                        solid: {\n                            color: evaluateValue(evalContext, fillDefn.solid.color, powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Color)),\n                        }\n                    };\n                }\n            }\n            function evaluateFillRule(evalContext, fillRuleDefn, type) {\n                if (!type.fillRule)\n                    return;\n                if (fillRuleDefn.linearGradient2) {\n                    var linearGradient2 = fillRuleDefn.linearGradient2;\n                    return {\n                        linearGradient2: {\n                            min: evaluateColorStop(evalContext, linearGradient2.min),\n                            max: evaluateColorStop(evalContext, linearGradient2.max),\n                        }\n                    };\n                }\n                if (fillRuleDefn.linearGradient3) {\n                    var linearGradient3 = fillRuleDefn.linearGradient3;\n                    return {\n                        linearGradient3: {\n                            min: evaluateColorStop(evalContext, linearGradient3.min),\n                            mid: evaluateColorStop(evalContext, linearGradient3.mid),\n                            max: evaluateColorStop(evalContext, linearGradient3.max),\n                        }\n                    };\n                }\n            }\n            function evaluateColorStop(evalContext, colorStop) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(colorStop, 'colorStop');\n                var step = {\n                    color: evaluateValue(evalContext, colorStop.color, colorValueType),\n                };\n                var value = evaluateValue(evalContext, colorStop.value, numericType);\n                if (value != null)\n                    step.value = value;\n                return step;\n            }\n            function evaluateImage(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.image || !definition)\n                    return;\n                var value = {\n                    name: evaluateValue(evalContext, definition.name, textType),\n                    url: evaluateValue(evalContext, definition.url, powerbi.ValueType.fromDescriptor(powerbi.ImageDefinition.urlType)),\n                };\n                if (definition.scaling)\n                    value.scaling = evaluateValue(evalContext, definition.scaling, textType);\n                return value;\n            }\n            function evaluateParagraphs(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.paragraphs || !definition)\n                    return;\n                return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\n            }\n            function evaluateParagraph(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionTextRuns = definition.textRuns;\n                var evaluatedTextRuns = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\n                if (definitionTextRuns !== evaluatedTextRuns) {\n                    evaluated = _.clone(definition);\n                    evaluated.textRuns = evaluatedTextRuns;\n                }\n                return evaluated || definition;\n            }\n            function evaluateTextRun(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionValue = definition.value;\n                var evaluatedValue = evaluateValue(evalContext, definitionValue, textType);\n                if (evaluatedValue !== undefined) {\n                    evaluated = _.clone(definition);\n                    evaluated.value = evaluatedValue;\n                }\n                return evaluated || definition;\n            }\n            /**\n             * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\n             * other than the input to it.\n             */\n            function evaluateArrayCopyOnChange(evalContext, definitions, evaluator) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definitions, 'definitions');\n                debug.assertValue(evaluator, 'evaluator');\n                var evaluatedValues;\n                for (var i = 0, len = definitions.length; i < len; i++) {\n                    var definition = definitions[i];\n                    var evaluated = evaluator(evalContext, definition);\n                    // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\n                    // between TEvaluated & TDefinition\n                    if (!evaluatedValues && definition !== evaluated) {\n                        evaluatedValues = _.take(definitions, i);\n                    }\n                    if (evaluatedValues) {\n                        evaluatedValues.push(evaluated);\n                    }\n                }\n                return evaluatedValues || definitions;\n            }\n            function evaluateValue(evalContext, definition, valueType) {\n                if (definition instanceof data.SQExpr)\n                    return ExpressionEvaluator.evaluate(definition, evalContext);\n                if (definition instanceof data.RuleEvaluation)\n                    return definition.evaluate(evalContext);\n            }\n            /** Responsible for evaluating SQExprs into values. */\n            var ExpressionEvaluator = (function (_super) {\n                __extends(ExpressionEvaluator, _super);\n                function ExpressionEvaluator() {\n                    _super.apply(this, arguments);\n                }\n                ExpressionEvaluator.evaluate = function (expr, evalContext) {\n                    if (expr == null)\n                        return;\n                    return expr.accept(ExpressionEvaluator.instance, evalContext);\n                };\n                ExpressionEvaluator.prototype.visitColumnRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitConstant = function (expr, evalContext) {\n                    return expr.value;\n                };\n                ExpressionEvaluator.prototype.visitMeasureRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitAggr = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitFillRule = function (expr, evalContext) {\n                    var inputValue = expr.input.accept(this, evalContext);\n                    if (inputValue !== undefined) {\n                        var colorAllocator = evalContext.getColorAllocator(expr);\n                        if (colorAllocator) {\n                            return colorAllocator.color(inputValue);\n                        }\n                    }\n                };\n                ExpressionEvaluator.instance = new ExpressionEvaluator();\n                return ExpressionEvaluator;\n            }(data.DefaultSQExprVisitorWithArg));\n        })(DataViewObjectEvaluator = data.DataViewObjectEvaluator || (data.DataViewObjectEvaluator = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var DataViewPivotCategorical;\n        (function (DataViewPivotCategorical) {\n            /**\n             * Pivots categories in a categorical DataView into valueGroupings.\n             * This is akin to a mathematical matrix transpose.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                var categorical = dataView.categorical;\n                if (!categorical)\n                    return null;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return null;\n                var values = categorical.values;\n                if (_.isEmpty(values) || values.source)\n                    return null;\n                var category = categories[0], categoryIdentities = category.identity, categoryValues = category.values, pivotedColumns = [], pivotedValues = [];\n                for (var rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\n                    var categoryValue = categoryValues[rowIdx], categoryIdentity = categoryIdentities[rowIdx];\n                    for (var colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\n                        var value = values[colIdx], pivotedColumn = inherit(value.source);\n                        // A value has a series group, which is not implemented for pivoting -- just give up.\n                        if (value.identity)\n                            return null;\n                        pivotedColumn.groupName = categoryValue;\n                        var pivotedValue = {\n                            source: pivotedColumn,\n                            values: [value.values[rowIdx]],\n                            identity: categoryIdentity,\n                            min: value.min,\n                            max: value.max,\n                            subtotal: value.subtotal\n                        };\n                        var highlights = value.highlights;\n                        if (highlights) {\n                            pivotedValue.highlights = [highlights[rowIdx]];\n                        }\n                        pivotedColumns.push(pivotedColumn);\n                        pivotedValues.push(pivotedValue);\n                    }\n                }\n                var pivotedMetadata = inherit(dataView.metadata);\n                pivotedMetadata.columns = pivotedColumns;\n                values = data.DataViewTransform.createValueColumns(pivotedValues, category.identityFields, category.source);\n                return {\n                    metadata: pivotedMetadata,\n                    categorical: {\n                        values: values,\n                    },\n                    matrix: dataView.matrix\n                };\n            }\n            DataViewPivotCategorical.apply = apply;\n        })(DataViewPivotCategorical = data.DataViewPivotCategorical || (data.DataViewPivotCategorical = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewPivotMatrix;\n        (function (DataViewPivotMatrix) {\n            /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\n            function apply(dataViewMatrix, context) {\n                debug.assertValue(dataViewMatrix, 'dataViewMatrix');\n                if (!context.columnHierarchyRewritten)\n                    dataViewMatrix.columns = powerbi.Prototype.inherit(dataViewMatrix.columns);\n                var columns = dataViewMatrix.columns;\n                if (!context.rowHierarchyRewritten)\n                    dataViewMatrix.rows = powerbi.Prototype.inherit(dataViewMatrix.rows);\n                var rows = dataViewMatrix.rows;\n                if (columns.levels.length > 1)\n                    return;\n                var pivotedRowNode = {\n                    level: 0\n                };\n                var columnLeafNodes = columns.root.children;\n                var measureCount = columnLeafNodes.length;\n                // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\n                // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\n                // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \n                // in a matrix with 2+ column fields and 2+ measure fields.\n                // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\n                // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\n                var pivotResultMeasureHeaderLevel = rows.levels.length;\n                if (measureCount > 0) {\n                    var index_1 = 0;\n                    var callback = function (node) {\n                        // Collect values and remove them from row leaves\n                        if (node.values) {\n                            if (!pivotedRowNode.values)\n                                pivotedRowNode.values = {};\n                            for (var i = 0; i < measureCount; i++)\n                                pivotedRowNode.values[index_1++] = node.values[i];\n                            delete node.values;\n                        }\n                        // Create measure headers if there are more than one measures\n                        if (measureCount > 1) {\n                            if (!node.children)\n                                node.children = [];\n                            for (var j = 0; j < measureCount; j++) {\n                                var measureHeaderLeaf = { level: pivotResultMeasureHeaderLevel };\n                                // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\n                                var columnLeafNode = columnLeafNodes[j];\n                                measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\n                                if (node.isSubtotal)\n                                    measureHeaderLeaf.isSubtotal = true;\n                                node.children.push(measureHeaderLeaf);\n                            }\n                        }\n                    };\n                    if (context.hierarchyTreesRewritten) {\n                        forEachLeaf(rows.root, callback);\n                    }\n                    else {\n                        dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\n                    }\n                }\n                else {\n                    if (!context.hierarchyTreesRewritten) {\n                        dataViewMatrix.columns.root = cloneTree(rows.root);\n                    }\n                }\n                if (measureCount > 1) {\n                    // Keep measure headers, but move them to the innermost level\n                    var level = { sources: columns.levels[0].sources };\n                    rows.levels.push(level);\n                    columns.levels.length = 0;\n                }\n                if (context.hierarchyTreesRewritten) {\n                    dataViewMatrix.columns.root = rows.root;\n                    dataViewMatrix.rows.root = {\n                        children: [pivotedRowNode]\n                    };\n                }\n                else {\n                    var updatedRowRoot = powerbi.Prototype.inherit(dataViewMatrix.rows.root);\n                    updatedRowRoot.children = [pivotedRowNode];\n                    dataViewMatrix.rows.root = updatedRowRoot;\n                }\n                dataViewMatrix.columns.levels = rows.levels;\n                dataViewMatrix.rows.levels = [];\n            }\n            DataViewPivotMatrix.apply = apply;\n            function forEachLeaf(root, callback) {\n                var children = root.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachLeaf(children[i], callback);\n                    return;\n                }\n                callback(root);\n            }\n            function cloneTree(node) {\n                return cloneTreeExecuteOnLeaf(node);\n            }\n            DataViewPivotMatrix.cloneTree = cloneTree;\n            function cloneTreeExecuteOnLeaf(node, callback) {\n                var updatedNode = powerbi.Prototype.inherit(node);\n                var children = node.children;\n                if (children && children.length > 0) {\n                    var newChildren = [];\n                    for (var i = 0, ilen = children.length; i < ilen; i++) {\n                        var updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\n                        newChildren.push(updatedChild);\n                    }\n                    updatedNode.children = newChildren;\n                }\n                else {\n                    if (callback)\n                        callback(updatedNode);\n                }\n                return updatedNode;\n            }\n            DataViewPivotMatrix.cloneTreeExecuteOnLeaf = cloneTreeExecuteOnLeaf;\n        })(DataViewPivotMatrix = data.DataViewPivotMatrix || (data.DataViewPivotMatrix = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelfCrossJoin;\n        (function (DataViewSelfCrossJoin) {\n            /**\n             * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\n             * to itself as a value grouping.\n             * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                if (!dataView.categorical)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\n                    return;\n                if (dataViewCategorical.values && dataViewCategorical.values.source)\n                    return;\n                return applyCategorical(dataView.metadata, dataViewCategorical);\n            }\n            DataViewSelfCrossJoin.apply = apply;\n            function applyCategorical(dataViewMetadata, dataViewCategorical) {\n                debug.assertValue(dataViewMetadata, 'dataViewMetadata');\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\n                var category = dataViewCategorical.categories[0], categoryValues = category.values, categoryLength = categoryValues.length;\n                if (categoryLength === 0)\n                    return;\n                var valuesArray = dataViewCategorical.values\n                    ? dataViewCategorical.values.grouped()[0].values\n                    : [];\n                var transformedDataView = data.createCategoricalDataViewBuilder()\n                    .withCategories(dataViewCategorical.categories)\n                    .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\n                    .build();\n                dataViewMetadata = powerbi.Prototype.inherit(dataViewMetadata);\n                dataViewMetadata.columns = transformedDataView.metadata.columns;\n                return {\n                    metadata: dataViewMetadata,\n                    categorical: transformedDataView.categorical,\n                };\n            }\n            function createGroupedValues(category, categoryValues, categoryLength, valuesArray) {\n                debug.assertValue(category, 'category');\n                debug.assertValue(categoryValues, 'categoryValues');\n                debug.assertValue(categoryLength, 'categoryLength');\n                debug.assertValue(valuesArray, 'valuesArray');\n                var nullValuesArray = createNullValues(categoryLength), valuesArrayLen = valuesArray.length, seriesData = [];\n                for (var i = 0; i < categoryLength; i++) {\n                    var seriesDataItem = [];\n                    for (var j = 0; j < valuesArrayLen; j++) {\n                        var originalValueColumn = valuesArray[j], originalHighlightValues = originalValueColumn.highlights;\n                        var seriesDataItemCategory = {\n                            values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\n                        };\n                        if (originalHighlightValues)\n                            seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\n                        seriesDataItem.push(seriesDataItemCategory);\n                    }\n                    seriesData.push(seriesDataItem);\n                }\n                return {\n                    groupColumn: {\n                        source: category.source,\n                        identityFrom: { fields: category.identityFields, identities: category.identity },\n                        values: category.values,\n                    },\n                    valueColumns: _.map(valuesArray, function (v) { return { source: v.source }; }),\n                    data: seriesData,\n                };\n            }\n        })(DataViewSelfCrossJoin = data.DataViewSelfCrossJoin || (data.DataViewSelfCrossJoin = {}));\n        function createNullValues(length) {\n            debug.assertValue(length, 'length');\n            var array = new Array(length);\n            for (var i = 0; i < length; i++)\n                array[i] = null;\n            return array;\n        }\n        function inheritArrayWithValue(nullValues, original, index) {\n            var inherited = powerbi.Prototype.inherit(nullValues);\n            inherited[index] = original[index];\n            return inherited;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewPivotCategoricalToPrimaryGroups;\n        (function (DataViewPivotCategoricalToPrimaryGroups) {\n            /**\n             * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\n             * pivot the secondary before the primary.\n             */\n            function pivotBinding(binding, allMappings, finalMapping, defaultDataVolume) {\n                // unpivot is inferred from result in DataViewTransform.apply but it does not have the\n                // compiled mappings available, let alone the merged mapping, only the original\n                // DataViewMappings. to keep that inference easy, only apply pivot when there's\n                // only one matching mapping\n                if (!allMappings || allMappings.length !== 1)\n                    return;\n                if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\n                    return;\n                if (!binding)\n                    return;\n                if (!canPivotCategorical(binding, finalMapping))\n                    return;\n                // pivot secondary onto front of primary\n                binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\n                binding.Secondary = undefined;\n                // set primary to pivot reduction\n                binding.DataReduction = {\n                    Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\n                    DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\n                };\n            }\n            DataViewPivotCategoricalToPrimaryGroups.pivotBinding = pivotBinding;\n            /** narrowly targets scatter chart scenario for now to keep code simple */\n            function isPivotableAxis(axis) {\n                return axis\n                    && axis.Groupings\n                    && axis.Groupings.length === 1\n                    && !_.isEmpty(axis.Groupings[0].Projections)\n                    && !axis.Groupings[0].Subtotal\n                    && _.isEmpty(axis.Groupings[0].SuppressedProjections);\n            }\n            function canPivotCategorical(binding, mapping) {\n                if (!isPivotableAxis(binding.Primary))\n                    return false;\n                if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\n                    return false;\n                // don't pivot if either axis has a data reduction\n                if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\n                    return false;\n                return true;\n            }\n            function unpivotResult(oldDataView, selects, dataViewMappings, projectionActiveItems) {\n                if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\n                    return oldDataView;\n                // This returns a subsetted version of the DataView rather than using prototypal inheritance because\n                // any dataviews in the old one (including ones invented after this code is written) will correspond\n                // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\n                // querying code made.\n                var newDataView = {\n                    metadata: {\n                        columns: ArrayExtensions.copy(oldDataView.metadata.columns),\n                    },\n                };\n                // preserve view types that aren't affected by pivoting\n                if (oldDataView.single)\n                    newDataView.single = oldDataView.single;\n                if (oldDataView.table)\n                    newDataView.table = oldDataView.table;\n                // other views are derived from matrix\n                if (oldDataView.matrix) {\n                    var newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\n                    // categorical only if there's data\n                    if (!_.isEmpty(newDataViewMatrix.valueSources)) {\n                        // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \n                        // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\n                        // this.canPivotCategorical() would have returned false in the first place for this query.\n                        var hasCompositeGroupInSeries = data.utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\n                        if (!hasCompositeGroupInSeries) {\n                            newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\n                        }\n                    }\n                }\n                return newDataView;\n            }\n            DataViewPivotCategoricalToPrimaryGroups.unpivotResult = unpivotResult;\n            /**\n             * Infer from the query result and the visual mappings whether the query was pivoted.\n             * Narrowly targets scatter chart scenario for now to keep code simple\n             */\n            function inferUnpivotTransform(selects, dataViewMappings, dataView, projectionActiveItems) {\n                if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\n                    return false;\n                // select applicable mappings based on select roles\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var supportedDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\n                if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\n                    return false;\n                var categoricalMapping = supportedDataViewMappings[0].categorical;\n                if (!categoricalMapping)\n                    return false;\n                // pivoted query will have produced a matrix\n                var matrixDataview = dataView.matrix;\n                if (!matrixDataview)\n                    return false;\n                // matrix must have two levels of grouping\n                if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\n                    return false;\n                // get category and value grouping roles\n                var categoryGroups = [];\n                var valueGroups = [];\n                var addGroupingRole = function (roleName, groups) {\n                    var roleProjections = projections[roleName];\n                    if (!roleProjections)\n                        return;\n                    for (var _i = 0, _a = roleProjections.all(); _i < _a.length; _i++) {\n                        var roleProjection = _a[_i];\n                        if (roleKinds[roleProjection.queryRef] === powerbi.VisualDataRoleKind.Grouping)\n                            groups.push(roleProjection.queryRef);\n                    }\n                };\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, categoryGroups); }\n                });\n                powerbi.DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, valueGroups); }\n                });\n                // need both for pivot to have been done\n                if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\n                    return false;\n                // if there was a pivot, there won't be any measures left in the columns\n                for (var _i = 0, _a = matrixDataview.columns.levels; _i < _a.length; _i++) {\n                    var level = _a[_i];\n                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {\n                        var source = _c[_b];\n                        if (!source.isMeasure)\n                            return false;\n                    }\n                }\n                return true;\n            }\n            /**\n             * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\n             * this function changes that so that the categories become the rows and the series the columns.\n             */\n            function unpivotMatrix(oldMatrix) {\n                var oldRows = oldMatrix.rows;\n                var oldRoot = oldRows.root;\n                var oldChildren = oldRoot.children;\n                // series are the outer grouping\n                var series = [];\n                var seriesIdLevel = oldRows.levels[0];\n                var seriesIdFields = oldRoot.childIdentityFields;\n                // categories are the inner grouping. \n                var categoryIndex = {};\n                var categories = [];\n                var categoryIdLevel = oldRows.levels[1];\n                var categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\n                var measureCount = oldMatrix.valueSources.length;\n                // within each series value, the category list may not be complete so cannot simply use the inner loop index\n                // to reference it.\n                var findCategory = function (identity) {\n                    var index = categoryIndex[identity.key];\n                    debug.assert(index !== undefined, \"findcat() !== undefined\");\n                    return index;\n                };\n                // collect series and categories from the row hierarchy\n                if (oldChildren) {\n                    var addCategory = function (categoryNode) {\n                        var key = categoryNode.identity.key;\n                        var index = categoryIndex[key];\n                        if (index === undefined) {\n                            index = categories.length;\n                            categoryIndex[key] = index;\n                            categories.push(categoryNode);\n                        }\n                    };\n                    for (var _i = 0, oldChildren_1 = oldChildren; _i < oldChildren_1.length; _i++) {\n                        var seriesNode = oldChildren_1[_i];\n                        series.push(seriesNode);\n                        for (var _a = 0, _b = seriesNode.children; _a < _b.length; _a++) {\n                            var categoryNode = _b[_a];\n                            addCategory(categoryNode);\n                        }\n                    }\n                }\n                // extract intersection values from pivoted matrix\n                // values will be indexed by categories then series\n                var matrixValues = new Array(categories.length);\n                for (var j = 0; j < series.length; ++j) {\n                    var seriesNode = oldChildren[j];\n                    for (var _c = 0, _d = seriesNode.children; _c < _d.length; _c++) {\n                        var categoryNode = _d[_c];\n                        var i = findCategory(categoryNode.identity); // must lookup actual category index\n                        if (!matrixValues[i])\n                            matrixValues[i] = new Array(series.length);\n                        matrixValues[i][j] = categoryNode.values;\n                    }\n                }\n                // columns of the unpivoted matrix are the series\n                var newColumns = {\n                    root: {\n                        children: _.map(series, function (s) {\n                            var inheritedNode = inheritSingle(s);\n                            inheritedNode.level = 0; // s.level should already be 0, but just in case...\n                            inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\n                            inheritedNode.childIdentityFields = undefined;\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: seriesIdFields,\n                    },\n                    levels: [\n                        seriesIdLevel,\n                    ],\n                };\n                // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\n                if (measureCount > 0) {\n                    var newColChildren = _.map(oldMatrix.columns.root.children, function (srcnode) {\n                        var dstnode = { level: 1 };\n                        if (srcnode.levelSourceIndex)\n                            dstnode.levelSourceIndex = srcnode.levelSourceIndex;\n                        return dstnode;\n                    });\n                    for (var i = 0; i < newColumns.root.children.length; ++i)\n                        newColumns.root.children[i].children = newColChildren;\n                    newColumns.levels.push(oldMatrix.columns.levels[0]);\n                }\n                // rows of the unpivoted matrix are the categories\n                var newRows = {\n                    root: {\n                        children: _.map(categories, function (c) {\n                            var inheritedNode = inheritSingle(c);\n                            inheritedNode.level = 0;\n                            inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\n                            inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: categoryIdFields,\n                    },\n                    levels: [\n                        categoryIdLevel,\n                    ],\n                };\n                // put values into rows\n                if (measureCount > 0) {\n                    for (var i = 0; i < categories.length; ++i) {\n                        var row = newRows.root.children[i];\n                        var rowValues = {};\n                        for (var j = 0; j < series.length; ++j) {\n                            var mvalues = matrixValues[i] && matrixValues[i][j];\n                            for (var k = 0; k < measureCount; ++k) {\n                                var l = j * measureCount + k;\n                                rowValues[l] = !mvalues\n                                    ? (k === 0 ? { value: null } : { value: null, valueSourceIndex: k })\n                                    : mvalues[k];\n                            }\n                        }\n                        row.values = rowValues;\n                    }\n                }\n                var newMatrix = {\n                    rows: newRows,\n                    columns: newColumns,\n                    valueSources: oldMatrix.valueSources,\n                };\n                return newMatrix;\n            }\n            /** build a categorical data view from an unpivoted matrix. */\n            function categoricalFromUnpivotedMatrix(matrix, columnMetadata) {\n                var seriesCount = matrix.columns.root.children.length;\n                var measureMetadata = matrix.valueSources;\n                var measureCount = measureMetadata.length;\n                var categories = createCategoryColumnsFromUnpivotedMatrix(matrix);\n                // create grouped values\n                var groups = [];\n                for (var j = 0; j < seriesCount; ++j) {\n                    var seriesColumn = matrix.columns.root.children[j];\n                    var group = {\n                        values: [],\n                        identity: seriesColumn.identity,\n                        name: seriesColumn.value || null,\n                    };\n                    groups.push(group);\n                    for (var k = 0; k < measureCount; ++k) {\n                        var valueColumnMetadataSrc = measureMetadata[k];\n                        var valueColumnMetadataDst = {};\n                        for (var key in valueColumnMetadataSrc)\n                            valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\n                        valueColumnMetadataDst.groupName = group.name;\n                        columnMetadata.push(valueColumnMetadataDst);\n                        var valueColumn = {\n                            source: valueColumnMetadataDst,\n                            values: [],\n                            identity: group.identity,\n                        };\n                        group.values.push(valueColumn);\n                        // grab measure values in the group from across rows of matrix\n                        var index = k + j * measureCount;\n                        for (var _i = 0, _a = matrix.rows.root.children; _i < _a.length; _i++) {\n                            var categoryNode = _a[_i];\n                            var value = categoryNode.values[index].value;\n                            valueColumn.values.push(value);\n                        }\n                    }\n                }\n                // and now ungrouped\n                var values = [];\n                for (var _b = 0, groups_1 = groups; _b < groups_1.length; _b++) {\n                    var group = groups_1[_b];\n                    for (var k = 0; k < measureCount; ++k) {\n                        values.push(group.values[k]);\n                    }\n                }\n                values.grouped = function () { return groups; };\n                values.identityFields = matrix.columns.root.childIdentityFields;\n                values.source = matrix.columns.levels[0].sources[0];\n                // final assembly\n                var categorical = {\n                    categories: categories,\n                    values: values,\n                };\n                return categorical;\n            }\n            function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix) {\n                debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\n                debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1), 'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\n                // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \n                // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \n                // same amongst the resulting DataViewCategoryColumns.\n                var categoryIdentity = _.map(unpivotedMatrix.rows.root.children, function (x) { return x.identity; });\n                var categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\n                var categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\n                var categories = [];\n                for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\n                    var groupLevelValues = _.map(unpivotedMatrix.rows.root.children, function (categoryNode) {\n                        var levelValues = categoryNode.levelValues;\n                        // Please refer to the interface comments on when this is undefined... But in today's code\n                        // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \n                        if (levelValues !== undefined) {\n                            debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i), 'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\n                            return levelValues[i].value;\n                        }\n                    });\n                    categories.push({\n                        source: categorySourceColumns[i],\n                        values: groupLevelValues,\n                        identity: categoryIdentity,\n                        identityFields: categoryIdentityFields,\n                    });\n                }\n                return categories;\n            }\n        })(DataViewPivotCategoricalToPrimaryGroups = data.DataViewPivotCategoricalToPrimaryGroups || (data.DataViewPivotCategoricalToPrimaryGroups = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var EnumExtensions = jsCommon.EnumExtensions;\n        // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\n        var DataViewTransform;\n        (function (DataViewTransform) {\n            var fillRulePropertyDescriptor = { type: { fillRule: {} } };\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\n                var prototype = options.prototype, objectDescriptors = options.objectDescriptors, dataViewMappings = options.dataViewMappings, transforms = options.transforms, projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems, colorAllocatorFactory = options.colorAllocatorFactory, dataRoles = options.dataRoles;\n                if (!prototype)\n                    return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\n                if (!transforms)\n                    return [prototype];\n                // Transform Query DataView\n                prototype = data.DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\n                var visualDataViews = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\n                // Transform and generate derived visual DataViews\n                visualDataViews = data.DataViewRegression.run({\n                    dataViewMappings: dataViewMappings,\n                    visualDataViews: visualDataViews,\n                    dataRoles: dataRoles,\n                    objectDescriptors: objectDescriptors,\n                    objectDefinitions: transforms.objects,\n                    colorAllocatorFactory: colorAllocatorFactory,\n                    transformSelects: transforms.selects,\n                    metadata: prototype.metadata,\n                    projectionActiveItems: projectionActiveItems,\n                });\n                return visualDataViews;\n            }\n            DataViewTransform.apply = apply;\n            function transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles) {\n                var transformedDataViews = [];\n                var splits = transforms.splits;\n                if (_.isEmpty(splits)) {\n                    transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\n                }\n                else {\n                    for (var _i = 0, splits_1 = splits; _i < splits_1.length; _i++) {\n                        var split = splits_1[_i];\n                        var transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\n                        transformedDataViews.push(transformed);\n                    }\n                }\n                return transformedDataViews;\n            }\n            function transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory) {\n                if (transforms && transforms.objects) {\n                    var emptyDataView = {\n                        metadata: {\n                            columns: [],\n                        }\n                    };\n                    transformObjects(emptyDataView, 0 /* None */, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                    return [emptyDataView];\n                }\n                return [];\n            }\n            function transformDataView(prototype, objectDescriptors, roleMappings, transforms, colorAllocatorFactory, dataRoles, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                var targetKinds = getTargetKinds(roleMappings);\n                var transformed = inherit(prototype);\n                transformed.metadata = inherit(prototype.metadata);\n                var projectionOrdering = transforms.roles && transforms.roles.ordering;\n                var projectionActiveItems = transforms.roles && transforms.roles.activeItems;\n                transformed = transformSelects(transformed, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\n                transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\n                transformed = data.DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\n                data.DataViewNormalizeValues.apply({\n                    dataview: transformed,\n                    dataViewMappings: roleMappings,\n                    dataRoles: dataRoles,\n                });\n                return transformed;\n            }\n            function getTargetKinds(roleMappings) {\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                if (!roleMappings)\n                    return 0 /* None */;\n                var result = 0 /* None */;\n                for (var _i = 0, roleMappings_1 = roleMappings; _i < roleMappings_1.length; _i++) {\n                    var roleMapping = roleMappings_1[_i];\n                    if (roleMapping.categorical)\n                        result |= 1 /* Categorical */;\n                    if (roleMapping.matrix)\n                        result |= 2 /* Matrix */;\n                    if (roleMapping.single)\n                        result |= 4 /* Single */;\n                    if (roleMapping.table)\n                        result |= 8 /* Table */;\n                    if (roleMapping.tree)\n                        result |= 16 /* Tree */;\n                }\n                return result;\n            }\n            function transformSelects(dataView, roleMappings, selectTransforms, projectionOrdering, selectsToInclude) {\n                var columnRewrites = [];\n                if (selectTransforms) {\n                    dataView.metadata.columns = applyTransformsToColumns(dataView.metadata.columns, selectTransforms, columnRewrites);\n                }\n                // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\n                if (dataView.categorical) {\n                    dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    // NOTE: This is slightly DSR-specific.\n                    dataView = pivotIfNecessary(dataView, roleMappings);\n                }\n                if (dataView.matrix) {\n                    var matrixTransformationContext = {\n                        rowHierarchyRewritten: false,\n                        columnHierarchyRewritten: false,\n                        hierarchyTreesRewritten: false\n                    };\n                    dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    if (shouldPivotMatrix(dataView.matrix, roleMappings))\n                        data.DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\n                }\n                if (dataView.table)\n                    dataView.table = applyRewritesToTable(dataView.table, columnRewrites, roleMappings, projectionOrdering);\n                return dataView;\n            }\n            function applyTransformsToColumns(prototypeColumns, selects, rewrites) {\n                debug.assertValue(prototypeColumns, 'columns');\n                if (!selects)\n                    return prototypeColumns;\n                //column may contain undefined entries\n                var columns = inherit(prototypeColumns);\n                for (var i = 0, len = prototypeColumns.length; i < len; i++) {\n                    var prototypeColumn = prototypeColumns[i];\n                    var select = selects[prototypeColumn.index];\n                    if (!select)\n                        continue;\n                    var column = columns[i] = inherit(prototypeColumn);\n                    if (select.roles)\n                        column.roles = select.roles;\n                    if (select.type)\n                        column.type = select.type;\n                    column.format = getFormatForColumn(select, column);\n                    if (select.displayName)\n                        column.displayName = select.displayName;\n                    if (select.queryName)\n                        column.queryName = select.queryName;\n                    if (select.kpi)\n                        column.kpi = select.kpi;\n                    if (select.sort)\n                        column.sort = select.sort;\n                    if (select.discourageAggregationAcrossGroups)\n                        column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\n                    rewrites.push({\n                        from: prototypeColumn,\n                        to: column,\n                    });\n                }\n                return columns;\n            }\n            /**\n             * Get the column format. Order of precendence is:\n             *  1. Select format\n             *  2. Column format\n             */\n            function getFormatForColumn(select, column) {\n                // TODO: we already copied the select.Format to column.format, we probably don't need this check\n                return select.format || column.format;\n            }\n            function applyRewritesToCategorical(prototype, columnRewrites, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                var categorical = inherit(prototype);\n                function override(value) {\n                    var rewrittenSource = findOverride(value.source, columnRewrites);\n                    if (rewrittenSource) {\n                        var rewritten = inherit(value);\n                        rewritten.source = rewrittenSource;\n                        return rewritten;\n                    }\n                }\n                var categories = powerbi.Prototype.overrideArray(prototype.categories, override);\n                if (categories)\n                    categorical.categories = categories;\n                var valuesOverride = powerbi.Prototype.overrideArray(prototype.values, override);\n                var values = valuesOverride || prototype.values;\n                if (values) {\n                    var grouped = inherit(values.grouped());\n                    for (var i = 0, ilen = grouped.length; i < ilen; i++) {\n                        grouped[i] = inherit(grouped[i]);\n                    }\n                    if (selectsToInclude) {\n                        // Apply selectsToInclude to values by removing value columns not included\n                        for (var i = values.length - 1; i >= 0; i--) {\n                            if (!selectsToInclude[values[i].source.index]) {\n                                values.splice(i, 1);\n                            }\n                        }\n                        // Apply selectsToInclude to grouped()\n                        if (values.length > 0 && values[0].identity) {\n                            // We have a dynamic series, so we should remove any value columns not included in the split from each\n                            //    valueColumnGroup\n                            for (var i = 0, ilen = grouped.length; i < ilen; i++) {\n                                var currentGroupValues = grouped[i].values;\n                                for (var j = currentGroupValues.length - 1; j >= 0; j--) {\n                                    if (!selectsToInclude[currentGroupValues[j].source.index])\n                                        currentGroupValues.splice(i, 1);\n                                }\n                            }\n                        }\n                        else {\n                            // We are in a static series, so we should throw away the grouped and recreate it using the static values\n                            //   which have already been filtered\n                            grouped = [];\n                            grouped[0] = {\n                                values: values,\n                            };\n                        }\n                    }\n                    if (values.source) {\n                        if (selectsToInclude && !selectsToInclude[values.source.index]) {\n                            values.source = undefined;\n                        }\n                        else {\n                            var rewrittenValuesSource = findOverride(values.source, columnRewrites);\n                            if (rewrittenValuesSource)\n                                values.source = rewrittenValuesSource;\n                        }\n                    }\n                    var currentGroupIndex = 0;\n                    var group = void 0;\n                    for (var i = 0, ilen = values.length; i < ilen; i++) {\n                        var currentValue = values[i];\n                        if (!group || (currentValue.identity !== group.identity)) {\n                            group = inherit(grouped[currentGroupIndex]);\n                            grouped[currentGroupIndex] = group;\n                            group.values = [];\n                            currentGroupIndex++;\n                        }\n                        group.values.push(currentValue);\n                    }\n                    categorical.values = values;\n                    setGrouped(values, grouped);\n                }\n                return categorical;\n            }\n            function applyRewritesToTable(prototype, columnRewrites, roleMappings, projectionOrdering) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                // Don't perform this potentially expensive transform unless we actually have a table.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (!roleMappings || roleMappings.length !== 1 || !roleMappings[0].table)\n                    return prototype;\n                var table = inherit(prototype);\n                // Copy the rewritten columns into the table view\n                var override = function (metadata) { return findOverride(metadata, columnRewrites); };\n                var columns = powerbi.Prototype.overrideArray(prototype.columns, override);\n                if (columns)\n                    table.columns = columns;\n                if (!projectionOrdering)\n                    return table;\n                var newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\n                if (!newToOldPositions)\n                    return table;\n                // Reorder the columns\n                var columnsClone = columns.slice(0);\n                var keys = Object.keys(newToOldPositions);\n                for (var i = 0, len = keys.length; i < len; i++) {\n                    var sourceColumn = columnsClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === columns.length)\n                        columns.push(sourceColumn);\n                    else {\n                        debug.assert(i < columns.length, 'The column index is out of range for reordering.');\n                        columns[i] = sourceColumn;\n                    }\n                }\n                // Reorder the rows\n                var rows = powerbi.Prototype.overrideArray(table.rows, function (row) {\n                    var newRow = [];\n                    for (var i = 0, len = keys.length; i < len; ++i)\n                        newRow[i] = row[newToOldPositions[keys[i]]];\n                    return newRow;\n                });\n                if (rows)\n                    table.rows = rows;\n                return table;\n            }\n            /** Creates a mapping of new position to original position. */\n            function createTableColumnPositionMapping(projectionOrdering, columnRewrites) {\n                var roles = Object.keys(projectionOrdering);\n                // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\n                if (roles.length !== 1)\n                    return;\n                var role = roles[0], originalOrder = _.map(columnRewrites, function (rewrite) { return rewrite.from.index; }), newOrder = projectionOrdering[role];\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            function applyRewritesToMatrix(prototype, columnRewrites, roleMappings, projectionOrdering, context) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                // Don't perform this potentially expensive transform unless we actually have a matrix.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (!roleMappings || roleMappings.length < 1 || !(roleMappings[0].matrix || (roleMappings[1] && roleMappings[1].matrix)))\n                    return prototype;\n                var matrixMapping = roleMappings[0].matrix || roleMappings[1].matrix;\n                var matrix = inherit(prototype);\n                function override(metadata) {\n                    return findOverride(metadata, columnRewrites);\n                }\n                function overrideHierarchy(hierarchy) {\n                    var rewrittenHierarchy = null;\n                    var newLevels = powerbi.Prototype.overrideArray(hierarchy.levels, function (level) {\n                        var newLevel = null;\n                        var levelSources = powerbi.Prototype.overrideArray(level.sources, override);\n                        if (levelSources)\n                            newLevel = ensureRewritten(newLevel, level, function (h) { return h.sources = levelSources; });\n                        return newLevel;\n                    });\n                    if (newLevels)\n                        rewrittenHierarchy = ensureRewritten(rewrittenHierarchy, hierarchy, function (r) { return r.levels = newLevels; });\n                    return rewrittenHierarchy;\n                }\n                var rows = overrideHierarchy(matrix.rows);\n                if (rows) {\n                    matrix.rows = rows;\n                    context.rowHierarchyRewritten = true;\n                }\n                var columns = overrideHierarchy(matrix.columns);\n                if (columns) {\n                    matrix.columns = columns;\n                    context.columnHierarchyRewritten = true;\n                }\n                var valueSources = powerbi.Prototype.overrideArray(matrix.valueSources, override);\n                if (valueSources) {\n                    matrix.valueSources = valueSources;\n                    // Only need to reorder if we have more than one value source, and they are all bound to the same role\n                    var matrixValues = matrixMapping.values;\n                    if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\n                        var columnLevels = columns.levels.length;\n                        if (columnLevels > 0) {\n                            var newToOldPositions_1 = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\n                            if (newToOldPositions_1) {\n                                var keys_1 = Object.keys(newToOldPositions_1);\n                                var numKeys_1 = keys_1.length;\n                                // Reorder the value columns\n                                columns.root = data.DataViewPivotMatrix.cloneTree(columns.root);\n                                if (columnLevels === 1)\n                                    reorderChildNodes(columns.root, newToOldPositions_1);\n                                else\n                                    forEachNodeAtLevel(columns.root, columnLevels - 2, function (node) { return reorderChildNodes(node, newToOldPositions_1); });\n                                // Reorder the value rows\n                                matrix.rows.root = data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, function (node) {\n                                    if (!node.values)\n                                        return;\n                                    var newValues = {};\n                                    var iterations = Object.keys(node.values).length / numKeys_1;\n                                    for (var i = 0, len = iterations; i < len; i++) {\n                                        var offset = i * numKeys_1;\n                                        for (var keysIndex = 0; keysIndex < numKeys_1; keysIndex++)\n                                            newValues[offset + keysIndex] = node.values[offset + newToOldPositions_1[keys_1[keysIndex]]];\n                                    }\n                                    node.values = newValues;\n                                });\n                                context.hierarchyTreesRewritten = true;\n                            }\n                        }\n                    }\n                }\n                reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\n                return matrix;\n            }\n            function reorderChildNodes(node, newToOldPositions) {\n                var keys = Object.keys(newToOldPositions);\n                var numKeys = keys.length;\n                var children = node.children;\n                var childrenClone = children.slice(0);\n                for (var i = 0, len = numKeys; i < len; i++) {\n                    var sourceColumn = childrenClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === children.length)\n                        children.push(sourceColumn);\n                    else {\n                        debug.assert(i < children.length, 'The column index is out of range for reordering.');\n                        children[i] = sourceColumn;\n                    }\n                }\n            }\n            /**\n             * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\n             * and values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified prototype is necessary.\n             */\n            function reorderMatrixCompositeGroups(prototype, supportedDataViewMapping, projection) {\n                var transformedDataView;\n                if (prototype && supportedDataViewMapping && projection) {\n                    // reorder levelValues in any composite groups in rows hierarchy\n                    var transformedRowsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\n                        visitRole: function (role, context) {\n                            transformedRowsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedRowsHierarchy_1 || prototype.rows, role, projection);\n                        }\n                    });\n                    // reorder levelValues in any composite groups in columns hierarchy\n                    var transformedColumnsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\n                        visitRole: function (role, context) {\n                            transformedColumnsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedColumnsHierarchy_1 || prototype.columns, role, projection);\n                        }\n                    });\n                    if (transformedRowsHierarchy_1 || transformedColumnsHierarchy_1) {\n                        transformedDataView = inheritSingle(prototype);\n                        transformedDataView.rows = transformedRowsHierarchy_1 || transformedDataView.rows;\n                        transformedDataView.columns = transformedColumnsHierarchy_1 || transformedDataView.columns;\n                    }\n                }\n                return transformedDataView;\n            }\n            /**\n             * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\n             * values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\n             */\n            function reorderMatrixHierarchyCompositeGroups(matrixHierarchy, hierarchyRole, projection) {\n                debug.assertValue(matrixHierarchy, 'matrixHierarchy');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                var transformedHierarchy;\n                var selectIndicesInProjectionOrder = projection[hierarchyRole];\n                // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\n                var hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\n                if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\n                    for (var i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\n                        var hierarchyLevel = matrixHierarchy.levels[i];\n                        // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\n                        var newToOldLevelSourceIndicesMapping = createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\n                        if (newToOldLevelSourceIndicesMapping) {\n                            if (_.isUndefined(transformedHierarchy)) {\n                                // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\n                                // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\n                                transformedHierarchy = inheritSingle(matrixHierarchy);\n                                transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\n                                // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\n                                // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\n                                // happen in other hierarchy levels in the later iterations of this for-loop.\n                                transformedHierarchy.root = data.utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\n                            }\n                            // reorder the metadata columns in the sources array at that level\n                            var transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\n                            transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\n                            // reorder the level values in the composite group nodes at the current hierarchy level\n                            reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\n                        }\n                    }\n                }\n                return transformedHierarchy;\n            }\n            /**\n             * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\n             * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\n             *\n             * The returned value maps level source indices from the new target order (calculated from projection order)\n             * back to the original order as they appear in the specified hierarchyLevel's sources.\n             * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\n             *\n             * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\n             *\n             * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\n             * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\n             * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\n             */\n            function createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\n                var newToOldLevelSourceIndicesMapping;\n                var levelSourceColumns = hierarchyLevel.sources;\n                if (levelSourceColumns && levelSourceColumns.length >= 2) {\n                    // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\n                    var columnsForHierarchyRoleOrderedByLevelSourceIndex = data.utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(levelSourceColumns, projection, hierarchyRole);\n                    if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\n                        // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\n                        var columnsForHierarchyRoleOrderedByProjection = _.sortBy(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.projectionOrderIndex; });\n                        newToOldLevelSourceIndicesMapping = createOrderMapping(_.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.sourceIndex; }), _.map(columnsForHierarchyRoleOrderedByProjection, function (columnInfo) { return columnInfo.sourceIndex; }));\n                    }\n                }\n                return newToOldLevelSourceIndicesMapping;\n            }\n            /**\n             * Applies re-ordering on the specified transformingHierarchyLevel's sources.\n             * Returns the same object as the specified transformingHierarchyLevel.\n             */\n            function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var originalLevelSources = transformingHierarchyLevel.sources;\n                transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\n                var newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\n                for (var i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\n                    var newLevelSourceIndex = newLevelSourceIndices[i];\n                    var oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\n                    debug.assert(oldLevelSourceIndex < originalLevelSources.length, 'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\n                    transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\n                }\n                return transformingHierarchyLevel;\n            }\n            /**\n             * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\n             * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\n             *\n             * Returns the same object as the specified transformingHierarchyRootNode.\n             */\n            function reorderMatrixHierarchyLevelValues(transformingHierarchyRootNode, transformingHierarchyLevelIndex, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var oldToNewLevelSourceIndicesMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\n                forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, function (transformingMatrixNode) {\n                    var originalLevelValues = transformingMatrixNode.levelValues;\n                    // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\n                    // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\n                    // The following code isn't correct in the special case where a column is projected twice in this composite group,\n                    // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\n                    // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\n                    if (!_.isEmpty(originalLevelValues)) {\n                        // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\n                        // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\n                        // because we don't want to accidentally modify the array AND its value references in Query DataView\n                        var newlyOrderedLevelValues = _.sortBy(originalLevelValues, function (levelValue) { return oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]; });\n                        for (var i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\n                            var transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\n                            transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\n                            newlyOrderedLevelValues[i] = transformingLevelValue;\n                        }\n                        transformingMatrixNode.levelValues = newlyOrderedLevelValues;\n                        // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\n                        // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\n                        var newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\n                        if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\n                            transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\n                        }\n                        if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\n                            transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\n                        }\n                    }\n                });\n                return transformingHierarchyRootNode;\n            }\n            /**\n             * Creates a mapping of new position to original position.\n             *\n             * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\n             * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\n             * - the value in the key-value pair is the index of the particular column in the original order\n             */\n            function createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites) {\n                var role = matrixValues.for.in;\n                var newOrder = projectionOrdering[role];\n                var originalOrder = _.chain(columnRewrites)\n                    .filter(function (rewrite) { return _.contains(valueSources, rewrite.to); })\n                    .map(function (rewrite) { return rewrite.from.index; })\n                    .value();\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            /**\n             * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\n             * originalOrder array.\n             * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\n             * under the context of the caller code), e.g. the Select Index in projection ordering array.\n             * Also, the specified originalOrder must contain every value that exists in newOrder.\n             *\n             * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\n             * key-value pair, each of which represents the new and old indices of a particular column:\n             * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\n             * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\n             *\n             * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\n             *\n             * If the specified originalOrder and newOrder are same, then this function returns undefined.\n             *\n             * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\n             * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\n             */\n            function createOrderMapping(originalOrder, newOrder) {\n                // Optimization: avoid rewriting if the current order is correct\n                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, function (x, y) { return x === y; }))\n                    return;\n                var mapping = {};\n                for (var i = 0, len = newOrder.length; i < len; ++i) {\n                    var newPosition = newOrder[i];\n                    mapping[i] = originalOrder.indexOf(newPosition);\n                }\n                return mapping;\n            }\n            function createReversedMapping(mapping) {\n                debug.assertValue(mapping, 'mapping');\n                var reversed = {};\n                for (var key in mapping) {\n                    // Note: key is a string after we get it out from mapping, thus we need to parse it\n                    // back into a number before putting it as the value in the reversed mapping\n                    var value = mapping[key];\n                    var keyAsNumber = parseInt(key, 10);\n                    reversed[value] = keyAsNumber;\n                }\n                debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length, 'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\n                return reversed;\n            }\n            function forEachNodeAtLevel(node, targetLevel, callback) {\n                debug.assertValue(node, 'node');\n                debug.assert(targetLevel >= 0, 'argetLevel >= 0');\n                debug.assertValue(callback, 'callback');\n                if (node.level === targetLevel) {\n                    callback(node);\n                    return;\n                }\n                var children = node.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachNodeAtLevel(children[i], targetLevel, callback);\n                }\n            }\n            DataViewTransform.forEachNodeAtLevel = forEachNodeAtLevel;\n            function findOverride(source, columnRewrites) {\n                for (var i = 0, len = columnRewrites.length; i < len; i++) {\n                    var columnRewrite = columnRewrites[i];\n                    if (columnRewrite.from === source)\n                        return columnRewrite.to;\n                }\n            }\n            function ensureRewritten(rewritten, prototype, callback) {\n                if (!rewritten)\n                    rewritten = inherit(prototype);\n                if (callback)\n                    callback(rewritten);\n                return rewritten;\n            }\n            function transformObjects(dataView, targetDataViewKinds, objectDescriptors, objectDefinitions, selectTransforms, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!objectDescriptors)\n                    return;\n                var objectsForAllSelectors = data.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\n                data.DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\n                var metadataOnce = objectsForAllSelectors.metadataOnce;\n                var dataObjects = objectsForAllSelectors.data;\n                if (metadataOnce)\n                    evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\n                var metadataObjects = objectsForAllSelectors.metadata;\n                if (metadataObjects) {\n                    for (var i = 0, len = metadataObjects.length; i < len; i++) {\n                        var metadataObject = metadataObjects[i];\n                        var objectDefns = metadataObject.objects;\n                        var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                        evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\n                    }\n                }\n                for (var i = 0, len = dataObjects.length; i < len; i++) {\n                    var dataObject = dataObjects[i];\n                    var objectDefns = dataObject.objects;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                    evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\n                }\n                var userDefined = objectsForAllSelectors.userDefined;\n                if (userDefined) {\n                    // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\n                    evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\n                }\n            }\n            DataViewTransform.transformObjects = transformObjects;\n            function evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var dataViewObjects = dataView.metadata.objects;\n                if (!dataViewObjects) {\n                    dataViewObjects = dataView.metadata.objects = {};\n                }\n                for (var _i = 0, objectDefns_1 = objectDefns; _i < objectDefns_1.length; _i++) {\n                    var objectDefn = objectDefns_1[_i];\n                    var id = objectDefn.selector.id;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\n                    var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                    var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\n                    for (var objectName in objects) {\n                        var object = objects[objectName];\n                        var map = dataViewObjects[objectName];\n                        if (!map)\n                            map = dataViewObjects[objectName] = [];\n                        debug.assert(powerbi.DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\n                        // NOTE: We do not check for duplicate ids.\n                        map.push({ id: id, object: object });\n                    }\n                }\n            }\n            /** Evaluates and sets properties on the DataView metadata. */\n            function evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, objectDefns, dataObjects, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(dataObjects, 'dataObjects');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                if (objects) {\n                    dataView.metadata.objects = objects;\n                    for (var objectName in objects) {\n                        var object = objects[objectName], objectDesc = objectDescriptors[objectName];\n                        for (var propertyName in object) {\n                            var propertyDesc = objectDesc.properties[propertyName], ruleDesc = propertyDesc.rule;\n                            if (!ruleDesc)\n                                continue;\n                            var definition = createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, object[propertyName], propertyDesc.type);\n                            if (!definition)\n                                continue;\n                            dataObjects.push(definition);\n                        }\n                    }\n                }\n            }\n            function createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, propertyValue, ruleType) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(propertyValue, 'propertyValue');\n                debug.assertValue(ruleType, 'ruleType');\n                var ruleOutput = ruleDesc.output;\n                if (!ruleOutput)\n                    return;\n                var selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\n                if (!selectorToCreate)\n                    return;\n                if (ruleType.fillRule) {\n                    return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue);\n                }\n            }\n            function createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(selectorToCreate, 'selectorToCreate');\n                debug.assertValue(propertyValue, 'propertyValue');\n                var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, 1 /* Role */, propertyValue);\n                if (!colorAllocator)\n                    return;\n                var rule = new data.ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\n                var fillRuleProperties = {};\n                fillRuleProperties[ruleDesc.output.property] = {\n                    solid: { color: rule }\n                };\n                return {\n                    selector: selectorToCreate,\n                    rules: [rule],\n                    objects: [{\n                            name: objectName,\n                            properties: fillRuleProperties,\n                        }]\n                };\n            }\n            function tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(propertyValue, 'propertyValue');\n                if (propertyValue.linearGradient2)\n                    return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\n                if (propertyValue.linearGradient3)\n                    return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\n            }\n            function createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient2) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient2, 'linearGradient2');\n                linearGradient2 = propertyValueFillRule.linearGradient2;\n                if (linearGradient2.min.value === undefined ||\n                    linearGradient2.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    if (linearGradient2.min.value === undefined)\n                        linearGradient2.min.value = inputRange.min;\n                    if (linearGradient2.max.value === undefined)\n                        linearGradient2.max.value = inputRange.max;\n                }\n                return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\n            }\n            function createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient3) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient3, 'linearGradient3');\n                var splitScales;\n                linearGradient3 = propertyValueFillRule.linearGradient3;\n                if (linearGradient3.min.value === undefined ||\n                    linearGradient3.mid.value === undefined ||\n                    linearGradient3.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    splitScales =\n                        linearGradient3.min.value === undefined &&\n                            linearGradient3.max.value === undefined &&\n                            linearGradient3.mid.value !== undefined;\n                    if (linearGradient3.min.value === undefined) {\n                        linearGradient3.min.value = inputRange.min;\n                    }\n                    if (linearGradient3.max.value === undefined) {\n                        linearGradient3.max.value = inputRange.max;\n                    }\n                    if (linearGradient3.mid.value === undefined) {\n                        var midValue = (linearGradient3.max.value + linearGradient3.min.value) / 2;\n                        linearGradient3.mid.value = midValue;\n                    }\n                }\n                return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\n            }\n            function populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var cache = data.createColorAllocatorCache();\n                var staticEvalContext = data.createStaticEvalContext();\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefnProperties = objectDefns[i].properties;\n                    for (var propertyName in objectDefnProperties) {\n                        var fillProperty = objectDefnProperties[propertyName];\n                        if (fillProperty &&\n                            fillProperty.solid &&\n                            fillProperty.solid.color &&\n                            fillProperty.solid.color.kind === 23 /* FillRule */) {\n                            var fillRuleExpr = fillProperty.solid.color;\n                            var inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\n                            if (!inputExprQueryName)\n                                continue;\n                            var fillRule = data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, fillRulePropertyDescriptor, fillRuleExpr.rule);\n                            var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, 0 /* QueryName */, fillRule);\n                            if (colorAllocator)\n                                cache.register(fillRuleExpr, colorAllocator);\n                        }\n                    }\n                }\n                return cache;\n            }\n            function evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, selector, rules, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\n                var containsWildcard = data.Selector.containsWildcard(selector);\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {\n                    // 1) Match against categories\n                    evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    // 2) Match against valueGrouping\n                    evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                }\n                var dataViewMatrix = dataView.matrix;\n                if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {\n                    var rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenMatrix) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.matrix = rewrittenMatrix;\n                    }\n                }\n                var dataViewTable = dataView.table;\n                if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {\n                    var rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\n                    var rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenTable) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.table = rewrittenTable;\n                    }\n                }\n            }\n            function rewriteTableRoleSelector(dataViewTable, selector) {\n                if (data.Selector.hasRoleWildcard(selector)) {\n                    selector = findSelectorForRoleWildcard(dataViewTable, selector);\n                }\n                return selector;\n            }\n            function findSelectorForRoleWildcard(dataViewTable, selector) {\n                var resultingSelector = {\n                    data: [],\n                    id: selector.id,\n                    metadata: selector.metadata\n                };\n                for (var _i = 0, _a = selector.data; _i < _a.length; _i++) {\n                    var dataSelector = _a[_i];\n                    if (data.Selector.isRoleWildcard(dataSelector)) {\n                        var selectorRoles = dataSelector.roles;\n                        var allColumnsBelongToSelectorRole = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\n                        var exprs = dataViewTable.identityFields;\n                        if (allColumnsBelongToSelectorRole && exprs) {\n                            resultingSelector.data.push(data.DataViewScopeWildcard.fromExprs(exprs));\n                            continue;\n                        }\n                    }\n                    if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\n                        resultingSelector.data.push(dataSelector);\n                    }\n                }\n                return resultingSelector;\n            }\n            function isUniqueDataSelector(dataSelectors, newSelector) {\n                if (_.isEmpty(dataSelectors))\n                    return true;\n                return !_.any(dataSelectors, function (dataSelector) { return dataSelector.key === newSelector.key; });\n            }\n            function allColumnsBelongToRole(columns, selectorRoles) {\n                for (var _i = 0, columns_6 = columns; _i < columns_6.length; _i++) {\n                    var column = columns_6[_i];\n                    var roles = column.roles;\n                    if (!roles || !_.any(selectorRoles, function (selectorRole) { return roles[selectorRole]; }))\n                        return false;\n                }\n                return true;\n            }\n            function evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\n                    return;\n                var targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\n                if (!targetColumn)\n                    return;\n                var identities = targetColumn.identities, foundMatch, evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                if (!identities)\n                    return;\n                debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\n                for (var i = 0, len = identities.length; i < len; i++) {\n                    var identity = identities[i];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(i);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (!targetColumn.column.objects) {\n                                targetColumn.column.objects = [];\n                                targetColumn.column.objects.length = len;\n                            }\n                            targetColumn.column.objects[i] = objects;\n                        }\n                        if (!containsWildcard)\n                            return true;\n                        foundMatch = true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var dataViewCategoricalValues = dataViewCategorical.values;\n                if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [dataViewCategoricalValues.identityFields]))\n                    return;\n                var valuesGrouped = dataViewCategoricalValues.grouped();\n                if (!valuesGrouped)\n                    return;\n                // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\n                // This should be enhanced in the future.\n                var evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                var foundMatch;\n                for (var i = 0, len = valuesGrouped.length; i < len; i++) {\n                    var valueGroup = valuesGrouped[i];\n                    var selectorMetadata = selector.metadata;\n                    var valuesInGroup = valueGroup.values;\n                    if (containsWildcard || data.Selector.matchesData(selector, [valueGroup.identity])) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (selectorMetadata) {\n                                for (var j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\n                                    var valueColumn = valuesInGroup[j], valueSource = valueColumn.source;\n                                    if (valueSource.queryName === selectorMetadata) {\n                                        var valueSourceOverwrite = powerbi.Prototype.inherit(valueSource);\n                                        valueSourceOverwrite.objects = objects;\n                                        valueColumn.source = valueSourceOverwrite;\n                                        foundMatch = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            else {\n                                valueGroup.objects = objects;\n                                setGrouped(dataViewCategoricalValues, valuesGrouped);\n                                foundMatch = true;\n                            }\n                        }\n                        if (!containsWildcard)\n                            return true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                var evalContext = data.createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\n                var rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                var rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows || rewrittenCols) {\n                    var rewrittenMatrix = inheritSingle(dataViewMatrix);\n                    if (rewrittenRows)\n                        rewrittenMatrix.rows = rewrittenRows;\n                    if (rewrittenCols)\n                        rewrittenMatrix.columns = rewrittenCols;\n                    return rewrittenMatrix;\n                }\n            }\n            function evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrixHierarchy, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (!dataViewMatrixHierarchy)\n                    return;\n                var root = dataViewMatrixHierarchy.root;\n                if (!root)\n                    return;\n                var rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRoot) {\n                    var rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\n                    rewrittenHierarchy.root = rewrittenRoot;\n                    return rewrittenHierarchy;\n                }\n            }\n            function evaluateDataRepetitionMatrixNode(evalContext, dataViewNode, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(dataViewNode, 'dataViewNode');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var childNodes = dataViewNode.children;\n                if (!childNodes)\n                    return;\n                var rewrittenNode;\n                var shouldSearchChildren;\n                var childIdentityFields = dataViewNode.childIdentityFields;\n                if (childIdentityFields) {\n                    // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\n                    shouldSearchChildren = data.Selector.matchesKeys(selector, [childIdentityFields]);\n                }\n                for (var i = 0, len = childNodes.length; i < len; i++) {\n                    var childNode = childNodes[i], identity = childNode.identity, rewrittenChildNode = null;\n                    if (shouldSearchChildren) {\n                        if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                            // TODO: Need to initialize context for rule-based properties.  Rule-based properties\n                            // (such as fillRule/gradients) are not currently implemented.\n                            var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                            if (objects) {\n                                rewrittenChildNode = inheritSingle(childNode);\n                                rewrittenChildNode.objects = objects;\n                            }\n                        }\n                    }\n                    else {\n                        rewrittenChildNode = evaluateDataRepetitionMatrixNode(evalContext, childNode, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                    }\n                    if (rewrittenChildNode) {\n                        if (!rewrittenNode)\n                            rewrittenNode = inheritNodeAndChildren(dataViewNode);\n                        rewrittenNode.children[i] = rewrittenChildNode;\n                        if (!containsWildcard) {\n                            // NOTE: once we find a match for a non-wildcard selector, stop looking.\n                            break;\n                        }\n                    }\n                }\n                return rewrittenNode;\n            }\n            function inheritNodeAndChildren(node) {\n                if (Object.getPrototypeOf(node) !== Object.prototype) {\n                    return node;\n                }\n                var inherited = inheritSingle(node);\n                inherited.children = inherit(node.children);\n                return inherited;\n            }\n            function evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewTable, 'dataViewTable');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var evalContext = data.createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\n                var rewrittenRows = evaluateDataRepetitionTableRows(evalContext, dataViewTable.columns, dataViewTable.rows, dataViewTable.identity, dataViewTable.identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows) {\n                    var rewrittenTable = inheritSingle(dataViewTable);\n                    rewrittenTable.rows = rewrittenRows;\n                    return rewrittenTable;\n                }\n            }\n            function evaluateDataRepetitionTableRows(evalContext, columns, rows, identities, identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(rows, 'rows');\n                debug.assertAnyValue(identities, 'identities');\n                debug.assertAnyValue(identityFields, 'identityFields');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (_.isEmpty(identities) || _.isEmpty(identityFields))\n                    return;\n                if (!selector.metadata ||\n                    !data.Selector.matchesKeys(selector, [identityFields]))\n                    return;\n                var colIdx = _.findIndex(columns, function (col) { return col.queryName === selector.metadata; });\n                if (colIdx < 0)\n                    return;\n                debug.assert(rows.length === identities.length, 'row length mismatch');\n                var colLen = columns.length;\n                var inheritedRows;\n                for (var rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\n                    var identity = identities[rowIdx];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(rowIdx);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            if (!inheritedRows)\n                                inheritedRows = inheritSingle(rows);\n                            var inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\n                            var objectsForColumns = inheritedRow.objects;\n                            if (!objectsForColumns)\n                                inheritedRow.objects = objectsForColumns = new Array(colLen);\n                            objectsForColumns[colIdx] = objects;\n                        }\n                        if (!containsWildcard)\n                            break;\n                    }\n                }\n                return inheritedRows;\n            }\n            function evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, selector, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                // revisit this, likely when we do lazy evaluation of DataView.\n                var columns = dataView.metadata.columns, metadataId = selector.metadata, evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                for (var i = 0, len = columns.length; i < len; i++) {\n                    var column = columns[i];\n                    if (column.queryName === metadataId) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects)\n                            column.objects = objects;\n                    }\n                }\n            }\n            /** Attempts to find a column that can possibly match the selector. */\n            function findSelectedCategoricalColumn(dataViewCategorical, selector) {\n                debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\n                var categoricalColumn = dataViewCategorical.categories[0];\n                if (!categoricalColumn.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [categoricalColumn.identityFields]))\n                    return;\n                var identities = categoricalColumn.identity, targetColumn = categoricalColumn;\n                var selectedMetadataId = selector.metadata;\n                if (selectedMetadataId) {\n                    var valueColumns = dataViewCategorical.values;\n                    if (valueColumns) {\n                        for (var i = 0, len = valueColumns.length; i < len; i++) {\n                            var valueColumn = valueColumns[i];\n                            if (valueColumn.source.queryName === selectedMetadataId) {\n                                targetColumn = valueColumn;\n                                break;\n                            }\n                        }\n                    }\n                }\n                return {\n                    column: targetColumn,\n                    identities: identities,\n                };\n            }\n            function findSelectorForRuleInput(dataView, selectorRoles) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectorRoles, 'selectorRoles');\n                if (selectorRoles.length !== 1)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical)\n                    return;\n                var categories = dataViewCategorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var categoryColumn = categories[0], categoryRoles = categoryColumn.source.roles, categoryIdentityFields = categoryColumn.identityFields;\n                if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\n                    return;\n                return { data: [data.DataViewScopeWildcard.fromExprs(categoryIdentityFields)] };\n            }\n            function findFirstQueryNameForExpr(selectTransforms, expr) {\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(expr, 'expr');\n                if (!selectTransforms)\n                    return;\n                for (var i = 0, len = selectTransforms.length; i < len; i++) {\n                    var select = selectTransforms[i], columnExpr = select.expr;\n                    if (!columnExpr || !data.SQExpr.equals(expr, select.expr))\n                        continue;\n                    return select.queryName;\n                }\n            }\n            /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\n            function findRuleInputColumnNumberRange(dataView, identifier, identifierKind) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                // NOTE: This implementation currently only supports categorical DataView, becuase that's the\n                // only scenario that has custom colors, as of this writing.  This would be rewritten to be more generic\n                // as required, when needed.\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical)\n                    return;\n                var values = dataViewCategorical.values;\n                if (!values)\n                    return;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var valueCol = values[i];\n                    if (identifierKind === 1 /* Role */) {\n                        var valueColRoles = valueCol.source.roles;\n                        if (!valueColRoles || !valueColRoles[identifier])\n                            continue;\n                    }\n                    else {\n                        debug.assert(identifierKind === 0 /* QueryName */, 'identifierKind === ColumnIdentifierKind.QueryName');\n                        if (valueCol.source.queryName !== identifier)\n                            continue;\n                    }\n                    var min = valueCol.min;\n                    if (min === undefined)\n                        min = valueCol.minLocal;\n                    if (min === undefined)\n                        continue;\n                    var max = valueCol.max;\n                    if (max === undefined)\n                        max = valueCol.maxLocal;\n                    if (max === undefined)\n                        continue;\n                    return { min: min, max: max };\n                }\n            }\n            // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\n            function createValueColumns(values, valueIdentityFields, source) {\n                if (values === void 0) { values = []; }\n                var result = values;\n                setGrouped(values);\n                if (valueIdentityFields)\n                    result.identityFields = valueIdentityFields;\n                if (source)\n                    result.source = source;\n                return result;\n            }\n            DataViewTransform.createValueColumns = createValueColumns;\n            function setGrouped(values, groupedResult) {\n                values.grouped = groupedResult\n                    ? function () { return groupedResult; }\n                    : function () { return groupValues(values); };\n            }\n            DataViewTransform.setGrouped = setGrouped;\n            /** Group together the values with a common identity. */\n            function groupValues(values) {\n                debug.assertValue(values, 'values');\n                var groups = [], currentGroup;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    if (!currentGroup || currentGroup.identity !== value.identity) {\n                        currentGroup = {\n                            values: []\n                        };\n                        if (value.identity) {\n                            currentGroup.identity = value.identity;\n                            var source = value.source;\n                            // allow null, which will be formatted as (Blank).\n                            if (source.groupName !== undefined)\n                                currentGroup.name = source.groupName;\n                            else if (source.displayName)\n                                currentGroup.name = source.displayName;\n                        }\n                        groups.push(currentGroup);\n                    }\n                    currentGroup.values.push(value);\n                }\n                return groups;\n            }\n            function pivotIfNecessary(dataView, dataViewMappings) {\n                debug.assertValue(dataView, 'dataView');\n                var transformedDataView;\n                switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\n                    case 1 /* Pivot */:\n                        transformedDataView = data.DataViewPivotCategorical.apply(dataView);\n                        break;\n                    case 2 /* SelfCrossJoin */:\n                        transformedDataView = data.DataViewSelfCrossJoin.apply(dataView);\n                        break;\n                }\n                return transformedDataView || dataView;\n            }\n            function determineCategoricalTransformation(categorical, dataViewMappings) {\n                if (!categorical || _.isEmpty(dataViewMappings))\n                    return;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var values = categorical.values;\n                if (_.isEmpty(values))\n                    return;\n                if (values.grouped().some(function (vg) { return !!vg.identity; }))\n                    return;\n                // If we made it here, the DataView has a single category and no valueGrouping.\n                var categoryRoles = categories[0].source.roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingCategorical = dataViewMappings[i].categorical;\n                    if (!roleMappingCategorical)\n                        continue;\n                    if (!hasRolesGrouped(categoryRoles, roleMappingCategorical.values))\n                        continue;\n                    // If we made it here, the DataView's single category has the value grouping role.\n                    var categoriesMapping = roleMappingCategorical.categories;\n                    var hasCategoryRole = hasRolesBind(categoryRoles, categoriesMapping) ||\n                        hasRolesFor(categoryRoles, categoriesMapping);\n                    if (hasCategoryRole)\n                        return 2 /* SelfCrossJoin */;\n                    return 1 /* Pivot */;\n                }\n            }\n            function shouldPivotMatrix(matrix, dataViewMappings) {\n                if (!matrix || _.isEmpty(dataViewMappings))\n                    return;\n                var rowLevels = matrix.rows.levels;\n                if (rowLevels.length < 1)\n                    return;\n                var rows = matrix.rows.root.children;\n                if (!rows || rows.length === 0)\n                    return;\n                var rowRoles = rowLevels[0].sources[0].roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingMatrix = dataViewMappings[i].matrix;\n                    if (!roleMappingMatrix)\n                        continue;\n                    if (!hasRolesFor(rowRoles, roleMappingMatrix.rows) &&\n                        hasRolesFor(rowRoles, roleMappingMatrix.columns)) {\n                        return true;\n                    }\n                }\n            }\n            function hasRolesBind(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.bind)\n                    return roles[roleMapping.bind.to];\n            }\n            function hasRolesFor(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.for)\n                    return roles[roleMapping.for.in];\n            }\n            function hasRolesGrouped(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.group)\n                    return roles[roleMapping.group.by];\n            }\n        })(DataViewTransform = data.DataViewTransform || (data.DataViewTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createDisplayNameGetter(displayNameKey) {\n            return function (resourceProvider) { return resourceProvider.get(displayNameKey); };\n        }\n        data.createDisplayNameGetter = createDisplayNameGetter;\n        function getDisplayName(displayNameGetter, resourceProvider) {\n            if (typeof displayNameGetter === 'function')\n                return displayNameGetter(resourceProvider);\n            if (typeof displayNameGetter === 'string')\n                return displayNameGetter;\n        }\n        data.getDisplayName = getDisplayName;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Enumeration of DateTimeUnits */\n    (function (DateTimeUnit) {\n        DateTimeUnit[DateTimeUnit[\"Year\"] = 0] = \"Year\";\n        DateTimeUnit[DateTimeUnit[\"Month\"] = 1] = \"Month\";\n        DateTimeUnit[DateTimeUnit[\"Week\"] = 2] = \"Week\";\n        DateTimeUnit[DateTimeUnit[\"Day\"] = 3] = \"Day\";\n        DateTimeUnit[DateTimeUnit[\"Hour\"] = 4] = \"Hour\";\n        DateTimeUnit[DateTimeUnit[\"Minute\"] = 5] = \"Minute\";\n        DateTimeUnit[DateTimeUnit[\"Second\"] = 6] = \"Second\";\n        DateTimeUnit[DateTimeUnit[\"Millisecond\"] = 7] = \"Millisecond\";\n    })(powerbi.DateTimeUnit || (powerbi.DateTimeUnit = {}));\n    var DateTimeUnit = powerbi.DateTimeUnit;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function fieldExpr(fieldExpr) {\n                var sqExpr = FieldExprPattern.visit(fieldExpr, FieldExprToSQExprVisitor.instance);\n                debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\n                return sqExpr;\n            }\n            SQExprBuilder.fieldExpr = fieldExpr;\n            function fromColumnAggr(columnAggr) {\n                return SQExprBuilder.aggregate(fromColumn(columnAggr), columnAggr.aggregate);\n            }\n            SQExprBuilder.fromColumnAggr = fromColumnAggr;\n            function fromColumn(column) {\n                return SQExprBuilder.columnRef(fromEntity(column), column.name);\n            }\n            SQExprBuilder.fromColumn = fromColumn;\n            function fromEntity(entityPattern) {\n                return SQExprBuilder.entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\n            }\n            SQExprBuilder.fromEntity = fromEntity;\n            function fromEntityAggr(entityAggr) {\n                return SQExprBuilder.aggregate(fromEntity(entityAggr), entityAggr.aggregate);\n            }\n            SQExprBuilder.fromEntityAggr = fromEntityAggr;\n            function fromHierarchyLevelAggr(hierarchyLevelAggr) {\n                return SQExprBuilder.aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\n            }\n            SQExprBuilder.fromHierarchyLevelAggr = fromHierarchyLevelAggr;\n            function fromHierarchyLevel(hierarchyLevelPattern) {\n                return SQExprBuilder.hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\n            }\n            SQExprBuilder.fromHierarchyLevel = fromHierarchyLevel;\n            function fromHierarchy(hierarchyPattern) {\n                return SQExprBuilder.hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\n            }\n            SQExprBuilder.fromHierarchy = fromHierarchy;\n            var FieldExprToSQExprVisitor = (function () {\n                function FieldExprToSQExprVisitor() {\n                }\n                FieldExprToSQExprVisitor.prototype.visitColumn = function (column) {\n                    return fromColumn(column);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return fromColumnAggr(columnAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariationPattern) {\n                    return SQExprBuilder.propertyVariationSource(this.visitEntity(columnHierarchyLevelVariationPattern.source), columnHierarchyLevelVariationPattern.source.name, columnHierarchyLevelVariationPattern.level.name);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntity = function (entityPattern) {\n                    return fromEntity(entityPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return fromEntityAggr(entityAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchy = function (hierarchyPattern) {\n                    return fromHierarchy(hierarchyPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevel = function (level) {\n                    return fromHierarchyLevel(level);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return fromHierarchyLevelAggr(hierarchyLevelAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitMeasure = function (measure) {\n                    return SQExprBuilder.measureRef(this.visitEntity(measure), measure.name);\n                };\n                FieldExprToSQExprVisitor.instance = new FieldExprToSQExprVisitor();\n                return FieldExprToSQExprVisitor;\n            }());\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asFieldPattern(sqExpr) {\n                return sqExpr.accept(FieldExprPatternBuilder.instance);\n            }\n            SQExprConverter.asFieldPattern = asFieldPattern;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        var FieldExprPatternBuilder = (function (_super) {\n            __extends(FieldExprPatternBuilder, _super);\n            function FieldExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            FieldExprPatternBuilder.prototype.visitColumnRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var columnRef = sourceRef.entity;\n                    columnRef.name = expr.ref;\n                    return { column: columnRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitMeasureRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var measureRef = sourceRef.entity;\n                    measureRef.name = expr.ref;\n                    return { measure: measureRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            FieldExprPatternBuilder.prototype.visitAggr = function (expr) {\n                var fieldPattern = expr.arg.accept(this);\n                if (fieldPattern && fieldPattern.column) {\n                    var argAggr = fieldPattern.column;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.columnAggr) {\n                    var argAggr = fieldPattern.columnAggr;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.hierarchyLevel) {\n                    var argAggr = fieldPattern.hierarchyLevel;\n                    argAggr.aggregate = expr.func;\n                    return { hierarchyLevelAggr: argAggr };\n                }\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var argAggr = sourcePattern.entity;\n                    argAggr.aggregate = expr.func;\n                    return { entityAggr: argAggr };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchy = function (expr) {\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var hierarchyRef = (sourcePattern.entity);\n                    hierarchyRef.name = expr.hierarchy;\n                    return { hierarchy: hierarchyRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchyLevel = function (expr) {\n                var hierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\n                if (!hierarchySourceExprPattern)\n                    return;\n                var hierarchyLevel;\n                if (hierarchySourceExprPattern.hierarchy) {\n                    hierarchyLevel = {\n                        entity: hierarchySourceExprPattern.hierarchy.entity,\n                        schema: hierarchySourceExprPattern.hierarchy.schema,\n                        name: hierarchySourceExprPattern.hierarchy.name,\n                        level: expr.level,\n                    };\n                }\n                if (hierarchySourceExprPattern.variation) {\n                    return {\n                        columnHierarchyLevelVariation: {\n                            source: {\n                                entity: hierarchySourceExprPattern.variation.column.entity,\n                                schema: hierarchySourceExprPattern.variation.column.schema,\n                                name: hierarchySourceExprPattern.variation.column.name,\n                            },\n                            level: hierarchyLevel,\n                            variationName: hierarchySourceExprPattern.variation.variationName,\n                        }\n                    };\n                }\n                return { hierarchyLevel: hierarchyLevel };\n            };\n            FieldExprPatternBuilder.instance = new FieldExprPatternBuilder();\n            return FieldExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var SourceExprPatternBuilder = (function (_super) {\n            __extends(SourceExprPatternBuilder, _super);\n            function SourceExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            SourceExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            SourceExprPatternBuilder.prototype.visitPropertyVariationSource = function (expr) {\n                var entityExpr = expr.arg;\n                if (entityExpr instanceof data.SQEntityExpr) {\n                    var propertyVariationSource = {\n                        schema: entityExpr.schema,\n                        entity: entityExpr.entity,\n                        name: expr.property,\n                    };\n                    if (entityExpr.variable)\n                        propertyVariationSource.entityVar = entityExpr.variable;\n                    return {\n                        variation: {\n                            column: propertyVariationSource,\n                            variationName: expr.name,\n                        }\n                    };\n                }\n            };\n            SourceExprPatternBuilder.instance = new SourceExprPatternBuilder();\n            return SourceExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var HierarchyExprPatternBuiler = (function (_super) {\n            __extends(HierarchyExprPatternBuiler, _super);\n            function HierarchyExprPatternBuiler() {\n                _super.apply(this, arguments);\n            }\n            HierarchyExprPatternBuiler.prototype.visitHierarchy = function (expr) {\n                var exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                var hierarchyRef;\n                var variationRef;\n                if (exprPattern.variation) {\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.variation.column.schema,\n                        entity: exprPattern.variation.column.entity,\n                    };\n                    variationRef = exprPattern.variation;\n                }\n                else\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.entity.schema,\n                        entity: exprPattern.entity.entity,\n                    };\n                return {\n                    hierarchy: hierarchyRef,\n                    variation: variationRef\n                };\n            };\n            HierarchyExprPatternBuiler.instance = new HierarchyExprPatternBuiler();\n            return HierarchyExprPatternBuiler;\n        }(data.DefaultSQExprVisitor));\n        var FieldExprPattern;\n        (function (FieldExprPattern) {\n            function visit(expr, visitor) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(visitor, 'visitor');\n                var fieldExprPattern = expr instanceof data.SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\n                debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\n                if (fieldExprPattern.column)\n                    return visitColumn(fieldExprPattern.column, visitor);\n                if (fieldExprPattern.columnAggr)\n                    return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\n                if (fieldExprPattern.columnHierarchyLevelVariation)\n                    return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\n                if (fieldExprPattern.entity)\n                    return visitEntity(fieldExprPattern.entity, visitor);\n                if (fieldExprPattern.entityAggr)\n                    return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\n                if (fieldExprPattern.hierarchy)\n                    return visitHierarchy(fieldExprPattern.hierarchy, visitor);\n                if (fieldExprPattern.hierarchyLevel)\n                    return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\n                if (fieldExprPattern.hierarchyLevelAggr)\n                    return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\n                if (fieldExprPattern.measure)\n                    return visitMeasure(fieldExprPattern.measure, visitor);\n                debug.assertFail('failed to visit a fieldExprPattern.');\n                return;\n            }\n            FieldExprPattern.visit = visit;\n            function visitColumn(column, visitor) {\n                debug.assertValue(column, 'column');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumn(column);\n            }\n            function visitColumnAggr(columnAggr, visitor) {\n                debug.assertValue(columnAggr, 'columnAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnAggr(columnAggr);\n            }\n            function visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation, visitor) {\n                debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\n            }\n            function visitEntity(entity, visitor) {\n                debug.assertValue(entity, 'entity');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntity(entity);\n            }\n            function visitEntityAggr(entityAggr, visitor) {\n                debug.assertValue(entityAggr, 'entityAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntityAggr(entityAggr);\n            }\n            function visitHierarchy(hierarchy, visitor) {\n                debug.assertValue(hierarchy, 'hierarchy');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchy(hierarchy);\n            }\n            function visitHierarchyLevel(hierarchyLevel, visitor) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevel(hierarchyLevel);\n            }\n            function visitHierarchyLevelAggr(hierarchyLevelAggr, visitor) {\n                debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\n            }\n            function visitMeasure(measure, visitor) {\n                debug.assertValue(measure, 'measure');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitMeasure(measure);\n            }\n            function toColumnRefSQExpr(columnPattern) {\n                return SQExprBuilder.columnRef(SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar), columnPattern.name);\n            }\n            FieldExprPattern.toColumnRefSQExpr = toColumnRefSQExpr;\n            function getAggregate(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\n            }\n            FieldExprPattern.getAggregate = getAggregate;\n            function hasFieldExprName(fieldExpr) {\n                return (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.measure) !== undefined;\n            }\n            FieldExprPattern.hasFieldExprName = hasFieldExprName;\n            function getPropertyName(fieldExpr) {\n                var column = (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.measure);\n                if (column)\n                    return column.name;\n            }\n            FieldExprPattern.getPropertyName = getPropertyName;\n            function getHierarchyName(fieldExpr) {\n                var hierarchy = fieldExpr.hierarchy;\n                if (hierarchy)\n                    return hierarchy.name;\n            }\n            FieldExprPattern.getHierarchyName = getHierarchyName;\n            function getColumnRef(fieldExpr) {\n                if (fieldExpr.columnHierarchyLevelVariation)\n                    return fieldExpr.columnHierarchyLevelVariation.source;\n                return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\n            }\n            FieldExprPattern.getColumnRef = getColumnRef;\n            function getFieldExprName(fieldExpr) {\n                var name = getPropertyName(fieldExpr);\n                if (name)\n                    return name;\n                // In case it is an entity\n                return toFieldExprEntityPattern(fieldExpr).entity;\n            }\n            FieldExprPattern.getFieldExprName = getFieldExprName;\n            function toFieldExprEntityPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityPattern = toFieldExprEntityPattern;\n            function toFieldExprEntityItemPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityItemPattern = toFieldExprEntityItemPattern;\n            var FieldExprPatternAggregateVisitor = (function () {\n                function FieldExprPatternAggregateVisitor() {\n                }\n                FieldExprPatternAggregateVisitor.prototype.visitColumn = function (column) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return columnAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntity = function (entity) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return entityAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return hierarchyLevelAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitMeasure = function (measure) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.instance = new FieldExprPatternAggregateVisitor();\n                return FieldExprPatternAggregateVisitor;\n            }());\n            var FieldExprToEntityExprPatternBuilder = (function () {\n                function FieldExprToEntityExprPatternBuilder() {\n                }\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumn = function (column) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnAggr = function (columnAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntity = function (entity) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntityAggr = function (entityAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchy = function (hierarchy) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitMeasure = function (measure) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\n                };\n                FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern = function (exprPattern) {\n                    debug.assertValue(exprPattern, 'exprPattern');\n                    var pattern = { schema: exprPattern.schema, entity: exprPattern.entity };\n                    if (exprPattern.entityVar) {\n                        pattern.entityVar = exprPattern.entityVar;\n                    }\n                    return pattern;\n                };\n                FieldExprToEntityExprPatternBuilder.instance = new FieldExprToEntityExprPatternBuilder();\n                return FieldExprToEntityExprPatternBuilder;\n            }());\n        })(FieldExprPattern = data.FieldExprPattern || (data.FieldExprPattern = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewAnalysis;\n    (function (DataViewAnalysis) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\n        (function (DataViewMappingMatchErrorCode) {\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooLarge\"] = 0] = \"conditionRangeTooLarge\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooSmall\"] = 1] = \"conditionRangeTooSmall\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedMeasure\"] = 2] = \"conditionKindExpectedMeasure\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGrouping\"] = 3] = \"conditionKindExpectedGrouping\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGroupingOrMeasure\"] = 4] = \"conditionKindExpectedGroupingOrMeasure\";\n        })(DataViewAnalysis.DataViewMappingMatchErrorCode || (DataViewAnalysis.DataViewMappingMatchErrorCode = {}));\n        var DataViewMappingMatchErrorCode = DataViewAnalysis.DataViewMappingMatchErrorCode;\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\n        function validateAndReshape(dataView, dataViewMappings) {\n            if (!dataViewMappings || dataViewMappings.length === 0)\n                return { dataView: dataView, isValid: true };\n            if (dataView) {\n                for (var _i = 0, dataViewMappings_3 = dataViewMappings; _i < dataViewMappings_3.length; _i++) {\n                    var dataViewMapping = dataViewMappings_3[_i];\n                    // Keep the original when possible.\n                    if (supports(dataView, dataViewMapping))\n                        return { dataView: dataView, isValid: true };\n                    if (dataViewMapping.categorical && dataView.categorical)\n                        return reshapeCategorical(dataView, dataViewMapping);\n                    if (dataViewMapping.tree && dataView.tree)\n                        return reshapeTree(dataView, dataViewMapping.tree);\n                    if (dataViewMapping.single && dataView.single)\n                        return reshapeSingle(dataView, dataViewMapping.single);\n                    if (dataViewMapping.table && dataView.table)\n                        return reshapeTable(dataView, dataViewMapping.table);\n                }\n            }\n            else if (powerbi.ScriptResultUtil.findScriptResult(dataViewMappings)) {\n                // Currently, PBI Service treats R Script Visuals as static images.\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\n                // to support the PBI Desktop scenario.\n                // This code will be removed once PBI Service fully supports R Script Visuals.\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\n                return { dataView: dataView, isValid: true };\n            }\n            return { isValid: false };\n        }\n        DataViewAnalysis.validateAndReshape = validateAndReshape;\n        function reshapeCategorical(dataView, dataViewMapping) {\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\n            var categoryRoleMapping = dataViewMapping.categorical;\n            var categorical = dataView.categorical;\n            if (!categorical)\n                return { isValid: false };\n            var rowCount;\n            if (categoryRoleMapping.rowCount) {\n                rowCount = categoryRoleMapping.rowCount.supported;\n                if (rowCount && rowCount.max) {\n                    var updated = void 0;\n                    var categories = categorical.categories;\n                    var maxRowCount = rowCount.max;\n                    var originalLength = undefined;\n                    if (categories) {\n                        for (var i = 0, len = categories.length; i < len; i++) {\n                            var category = categories[i];\n                            originalLength = category.values.length;\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                                // Row count too large: Trim it to fit.\n                                var updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\n                                updated = updated || { categories: [] };\n                                updated.categories.push({\n                                    source: category.source,\n                                    values: updatedCategories\n                                });\n                            }\n                        }\n                    }\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\n                        if (!originalLength)\n                            originalLength = categorical.values[0].values.length;\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                            updated = updated || {};\n                            updated.values = powerbi.data.DataViewTransform.createValueColumns();\n                            for (var i = 0, len = categorical.values.length; i < len; i++) {\n                                var column = categorical.values[i], updatedColumn = {\n                                    source: column.source,\n                                    values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\n                                };\n                                if (column.min !== undefined)\n                                    updatedColumn.min = column.min;\n                                if (column.max !== undefined)\n                                    updatedColumn.max = column.max;\n                                if (column.subtotal !== undefined)\n                                    updatedColumn.subtotal = column.subtotal;\n                                updated.values.push(updatedColumn);\n                            }\n                        }\n                    }\n                    if (updated) {\n                        dataView = {\n                            metadata: dataView.metadata,\n                            categorical: updated,\n                        };\n                    }\n                }\n            }\n            if (supportsCategorical(dataView, dataViewMapping))\n                return { dataView: dataView, isValid: true };\n            return null;\n        }\n        function reshapeSingle(dataView, singleRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (dataView.single)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTree(dataView, treeRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            // TODO: Need to implement the reshaping of Tree\n            var metadata = dataView.metadata;\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTable(dataView, tableRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (dataView.table)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function countGroups(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (!columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countGroups = countGroups;\n        function countMeasures(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countMeasures = countMeasures;\n        /** Indicates whether the dataView conforms to the specified schema. */\n        function supports(dataView, roleMapping, usePreferredDataViewSchema) {\n            if (!roleMapping || !dataView)\n                return false;\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\n                return false;\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\n                return false;\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\n                return false;\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\n                return false;\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\n                return false;\n            return true;\n        }\n        DataViewAnalysis.supports = supports;\n        function supportsCategorical(dataView, categoryRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\n            var dataViewCategorical = dataView.categorical;\n            if (!dataViewCategorical)\n                return false;\n            // TODO: Disabling this implementation isn't right.\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\n            //    return false;\n            if (categoryRoleMapping.rowCount) {\n                var rowCount = categoryRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\n                    rowCount = categoryRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\n                        len = dataViewCategorical.values[0].values.length;\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\n                        len = dataViewCategorical.categories[0].values.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsSingle(dataViewSingle, singleRoleMapping) {\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (!dataViewSingle)\n                return false;\n            return true;\n        }\n        function supportsTree(dataView, treeRoleMapping) {\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            var metadata = dataView.metadata;\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\n        }\n        function supportsTable(dataViewTable, tableRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (!dataViewTable)\n                return false;\n            if (tableRoleMapping.rowCount) {\n                var rowCount = tableRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\n                    rowCount = tableRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewTable.rows && dataViewTable.rows.length)\n                        len = dataViewTable.rows.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsScriptResult(dataView, scriptResultRoleMapping) {\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\n            if (!dataView)\n                return false;\n            if (!dataView.imageBase64)\n                return false;\n            return true;\n        }\n        /**\n         * Determines whether the value conforms to the range in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateRange(value, roleCondition, ignoreMin) {\n            debug.assertValue(value, 'value');\n            if (!roleCondition)\n                return;\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\n            if (roleCondition.max !== undefined && roleCondition.max < value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\n        }\n        DataViewAnalysis.validateRange = validateRange;\n        /**\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateKind(roleCondition, roleName, projections, roleKindByQueryRef) {\n            if (!roleCondition || roleCondition.kind === undefined) {\n                return;\n            }\n            var expectedKind = roleCondition.kind;\n            var roleCollection = projections[roleName];\n            if (roleCollection) {\n                var roleProjections = roleCollection.all();\n                for (var _i = 0, roleProjections_1 = roleProjections; _i < roleProjections_1.length; _i++) {\n                    var roleProjection = roleProjections_1[_i];\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\n                        switch (expectedKind) {\n                            case powerbi.VisualDataRoleKind.Measure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\n                            case powerbi.VisualDataRoleKind.Grouping:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\n                            case powerbi.VisualDataRoleKind.GroupingOrMeasure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\n                        }\n                    }\n                }\n            }\n        }\n        /** Determines the appropriate DataViewMappings for the projections. */\n        function chooseDataViewMappings(projections, mappings, roleKindByQueryRef, objectDescriptors, objectDefinitions) {\n            debug.assertValue(projections, 'projections');\n            debug.assertAnyValue(mappings, 'mappings');\n            var supportedMappings = [];\n            var errors = [];\n            if (!_.isEmpty(mappings)) {\n                for (var mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\n                    var mapping = mappings[mappingIndex], mappingConditions = mapping.conditions, requiredProperties = mapping.requiredProperties;\n                    var allPropertiesValid = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\n                    var conditionsMet = [];\n                    if (!_.isEmpty(mappingConditions)) {\n                        for (var conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\n                            var condition = mappingConditions[conditionIndex];\n                            var currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\n                            if (!_.isEmpty(currentConditionErrors)) {\n                                for (var _i = 0, currentConditionErrors_1 = currentConditionErrors; _i < currentConditionErrors_1.length; _i++) {\n                                    var error = currentConditionErrors_1[_i];\n                                    error.mappingIndex = mappingIndex;\n                                    error.conditionIndex = conditionIndex;\n                                    errors.push(error);\n                                }\n                            }\n                            else\n                                conditionsMet.push(condition);\n                        }\n                    }\n                    else {\n                        conditionsMet.push({});\n                    }\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\n                        var supportedMapping = _.cloneDeep(mapping);\n                        var updatedConditions = _.filter(conditionsMet, function (condition) { return Object.keys(condition).length > 0; });\n                        if (!_.isEmpty(updatedConditions))\n                            supportedMapping.conditions = updatedConditions;\n                        supportedMappings.push(supportedMapping);\n                    }\n                }\n            }\n            return {\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\n            };\n        }\n        DataViewAnalysis.chooseDataViewMappings = chooseDataViewMappings;\n        function checkForConditionErrors(projections, condition, roleKindByQueryRef) {\n            debug.assertValue(projections, 'projections');\n            debug.assertValue(condition, 'condition');\n            var conditionRoles = Object.keys(condition);\n            var errors = [];\n            for (var i = 0, len = conditionRoles.length; i < len; i++) {\n                var roleName = conditionRoles[i], isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs), roleCondition = condition[roleName];\n                var roleCount = getPropertyCount(roleName, projections, isDrillable);\n                var rangeError = validateRange(roleCount, roleCondition);\n                if (rangeError != null) {\n                    errors.push({\n                        code: rangeError,\n                        roleName: roleName,\n                    });\n                }\n                var kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\n                if (kindError != null) {\n                    errors.push({\n                        code: kindError,\n                        roleName: roleName,\n                    });\n                }\n            }\n            return errors;\n        }\n        function areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions) {\n            if (_.isEmpty(requiredProperties))\n                return true;\n            if (!objectDescriptors || !objectDefinitions)\n                return false;\n            var staticEvalContext = powerbi.data.createStaticEvalContext();\n            return _.every(requiredProperties, function (requiredProperty) {\n                var objectDescriptorValue = null;\n                var objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\n                if (objectDescriptorProperty)\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\n                var objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\n                if (!objectDescriptorValue || !objectDefinitionValue)\n                    return false;\n                return powerbi.data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\n            });\n        }\n        function getPropertyCount(roleName, projections, useActiveIfAvailable) {\n            debug.assertValue(roleName, 'roleName');\n            debug.assertValue(projections, 'projections');\n            var projectionsForRole = projections[roleName];\n            if (projectionsForRole) {\n                if (useActiveIfAvailable)\n                    return 1;\n                return projectionsForRole.all().length;\n            }\n            return 0;\n        }\n        DataViewAnalysis.getPropertyCount = getPropertyCount;\n        function hasSameCategoryIdentity(dataView1, dataView2) {\n            if (dataView1\n                && dataView2\n                && dataView1.categorical\n                && dataView2.categorical) {\n                var dv1Categories = dataView1.categorical.categories;\n                var dv2Categories = dataView2.categorical.categories;\n                if (dv1Categories\n                    && dv2Categories\n                    && dv1Categories.length === dv2Categories.length) {\n                    for (var i = 0, len = dv1Categories.length; i < len; i++) {\n                        var dv1Identity = dv1Categories[i].identity;\n                        var dv2Identity = dv2Categories[i].identity;\n                        var dv1Length = getLengthOptional(dv1Identity);\n                        if (dv1Length !== getLengthOptional(dv2Identity))\n                            return false;\n                        for (var j = 0; j < dv1Length; j++) {\n                            if (!powerbi.DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\n                                return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        DataViewAnalysis.hasSameCategoryIdentity = hasSameCategoryIdentity;\n        function getLengthOptional(identity) {\n            if (identity)\n                return identity.length;\n            return 0;\n        }\n        function areMetadataColumnsEquivalent(column1, column2) {\n            if (!column1 && !column2)\n                return true;\n            if (!column1 || !column2)\n                return false;\n            if (column1.displayName !== column2.displayName)\n                return false;\n            if (column1.queryName !== column2.queryName)\n                return false;\n            if (column1.isMeasure !== column2.isMeasure)\n                return false;\n            if (column1.type !== column2.type)\n                return false;\n            if (column1.sort !== column2.sort)\n                return false;\n            return true;\n        }\n        DataViewAnalysis.areMetadataColumnsEquivalent = areMetadataColumnsEquivalent;\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\n        function isMetadataEquivalent(metadata1, metadata2) {\n            if (!metadata1 && !metadata2)\n                return true;\n            if (!metadata1 || !metadata2)\n                return false;\n            var previousColumnsLength = metadata1.columns.length;\n            var newColumnsLength = metadata2.columns.length;\n            if (previousColumnsLength !== newColumnsLength)\n                return false;\n            for (var i = 0; i < newColumnsLength; i++) {\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\n                    return false;\n            }\n            return true;\n        }\n        DataViewAnalysis.isMetadataEquivalent = isMetadataEquivalent;\n    })(DataViewAnalysis = powerbi.DataViewAnalysis || (powerbi.DataViewAnalysis = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var Lazy = jsCommon.Lazy;\n        var DataViewRoleWildcard;\n        (function (DataViewRoleWildcard) {\n            function fromRoles(roles) {\n                return new DataViewRoleWildcardImpl(roles);\n            }\n            DataViewRoleWildcard.fromRoles = fromRoles;\n            function equals(firstRoleWildcard, secondRoleWildcard) {\n                return firstRoleWildcard.key &&\n                    secondRoleWildcard.key &&\n                    firstRoleWildcard.key === secondRoleWildcard.key &&\n                    ArrayExtensions.sequenceEqual(firstRoleWildcard.roles, secondRoleWildcard.roles, function (role1, role2) { return role1 === role2; });\n            }\n            DataViewRoleWildcard.equals = equals;\n            var DataViewRoleWildcardImpl = (function () {\n                function DataViewRoleWildcardImpl(roles) {\n                    var _this = this;\n                    debug.assertNonEmpty(roles, 'roles');\n                    this._roles = roles;\n                    this._key = new Lazy(function () { return JSON.stringify(_this.roles); });\n                }\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"roles\", {\n                    get: function () {\n                        return this._roles;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewRoleWildcardImpl;\n            }());\n        })(DataViewRoleWildcard = data.DataViewRoleWildcard || (data.DataViewRoleWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewScopeIdentity;\n    (function (DataViewScopeIdentity) {\n        /** Compares the two DataViewScopeIdentity values for equality. */\n        function equals(x, y, ignoreCase) {\n            // Normalize falsy to null\n            x = x || null;\n            y = y || null;\n            if (x === y)\n                return true;\n            if (!x !== !y)\n                return false;\n            debug.assertValue(x, 'x');\n            debug.assertValue(y, 'y');\n            return data.SQExpr.equals(x.expr, y.expr, ignoreCase);\n        }\n        DataViewScopeIdentity.equals = equals;\n        function filterFromIdentity(identities, isNot) {\n            if (_.isEmpty(identities))\n                return;\n            var exprs = [];\n            for (var _i = 0, identities_1 = identities; _i < identities_1.length; _i++) {\n                var identity = identities_1[_i];\n                exprs.push(identity.expr);\n            }\n            return filterFromExprs(exprs, isNot);\n        }\n        DataViewScopeIdentity.filterFromIdentity = filterFromIdentity;\n        function filterFromExprs(orExprs, isNot) {\n            if (_.isEmpty(orExprs))\n                return;\n            var resultExpr;\n            for (var _i = 0, orExprs_1 = orExprs; _i < orExprs_1.length; _i++) {\n                var orExpr = orExprs_1[_i];\n                var inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\n                if (resultExpr)\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\n                else\n                    resultExpr = inExpr || orExpr;\n            }\n            if (resultExpr) {\n                if (isNot)\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\n            }\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\n        }\n        DataViewScopeIdentity.filterFromExprs = filterFromExprs;\n    })(DataViewScopeIdentity = powerbi.DataViewScopeIdentity || (powerbi.DataViewScopeIdentity = {}));\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        function createDataViewScopeIdentity(expr) {\n            return new DataViewScopeIdentityImpl(expr);\n        }\n        data.createDataViewScopeIdentity = createDataViewScopeIdentity;\n        var DataViewScopeIdentityImpl = (function () {\n            function DataViewScopeIdentityImpl(expr) {\n                debug.assertValue(expr, 'expr');\n                this._expr = expr;\n                this._key = new Lazy(function () { return data.SQExprShortSerializer.serialize(expr); });\n            }\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"expr\", {\n                get: function () {\n                    return this._expr;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"key\", {\n                get: function () {\n                    return this._key.getValue();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return DataViewScopeIdentityImpl;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        var DataViewScopeWildcard;\n        (function (DataViewScopeWildcard) {\n            function matches(wildcard, instance) {\n                var instanceExprs = data.ScopeIdentityExtractor.getKeys(instance.expr);\n                if (!instanceExprs)\n                    return false;\n                return data.SQExprUtils.sequenceEqual(wildcard.exprs, instanceExprs);\n            }\n            DataViewScopeWildcard.matches = matches;\n            function equals(firstScopeWildcard, secondScopeWildcard) {\n                return firstScopeWildcard.key === secondScopeWildcard.key &&\n                    data.SQExprUtils.sequenceEqual(firstScopeWildcard.exprs, secondScopeWildcard.exprs);\n            }\n            DataViewScopeWildcard.equals = equals;\n            function fromExprs(exprs) {\n                return new DataViewScopeWildcardImpl(exprs);\n            }\n            DataViewScopeWildcard.fromExprs = fromExprs;\n            var DataViewScopeWildcardImpl = (function () {\n                function DataViewScopeWildcardImpl(exprs) {\n                    debug.assertValue(exprs, 'exprs');\n                    this._exprs = exprs;\n                    this._key = new Lazy(function () { return data.SQExprShortSerializer.serializeArray(exprs); });\n                }\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"exprs\", {\n                    get: function () {\n                        return this._exprs;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewScopeWildcardImpl;\n            }());\n        })(DataViewScopeWildcard = data.DataViewScopeWildcard || (data.DataViewScopeWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createColorAllocatorCache() {\n            return new ColorAllocatorProvider();\n        }\n        data.createColorAllocatorCache = createColorAllocatorCache;\n        var ColorAllocatorProvider = (function () {\n            function ColorAllocatorProvider() {\n                this.cache = [];\n            }\n            ColorAllocatorProvider.prototype.get = function (key) {\n                debug.assertValue(key, 'key');\n                for (var _i = 0, _a = this.cache; _i < _a.length; _i++) {\n                    var entry = _a[_i];\n                    if (entry.key === key)\n                        return entry.allocator;\n                }\n            };\n            ColorAllocatorProvider.prototype.register = function (key, colorAllocator) {\n                debug.assertValue(key, 'key');\n                debug.assertValue(colorAllocator, 'colorAllocator');\n                debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\n                this.cache.push({\n                    key: key,\n                    allocator: colorAllocator,\n                });\n                return this;\n            };\n            return ColorAllocatorProvider;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewRegression;\n        (function (DataViewRegression) {\n            // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\n            // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\n            var regressionXQueryName = 'RegressionX';\n            var regressionSeriesQueryName = 'RegressionSeries';\n            DataViewRegression.regressionYQueryName = 'RegressionY';\n            function run(options) {\n                debug.assertValue(options, 'options');\n                var dataViewMappings = options.dataViewMappings;\n                var visualDataViews = options.visualDataViews;\n                var dataRoles = options.dataRoles;\n                var objectDescriptors = options.objectDescriptors;\n                var objectDefinitions = options.objectDefinitions;\n                var colorAllocatorFactory = options.colorAllocatorFactory;\n                var transformSelects = options.transformSelects;\n                var projectionActiveItems = options.projectionActiveItems;\n                var metadata = options.metadata;\n                if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\n                    // compute linear regression line if applicable\n                    var roleKindByQueryRef = data.DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\n                    var projections = data.DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\n                    if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\n                        return visualDataViews;\n                    var applicableDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\n                    if (applicableDataViewMappings) {\n                        var regressionDataViewMapping = _.find(applicableDataViewMappings, function (dataViewMapping) {\n                            return dataViewMapping.usage && dataViewMapping.usage.regression;\n                        });\n                        if (regressionDataViewMapping) {\n                            var regressionDataViews = [];\n                            for (var _i = 0, visualDataViews_1 = visualDataViews; _i < visualDataViews_1.length; _i++) {\n                                var visualDataView = visualDataViews_1[_i];\n                                var regressionDataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                                if (regressionDataView)\n                                    regressionDataViews.push(regressionDataView);\n                            }\n                            if (!_.isEmpty(regressionDataViews))\n                                visualDataViews.push.apply(visualDataViews, regressionDataViews);\n                        }\n                    }\n                }\n                return visualDataViews;\n            }\n            DataViewRegression.run = run;\n            /**\n             * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\n             * It works on scalar axis only.\n             * The algorithm is as follows\n             *\n             * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\n             * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\n             * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\n             * If highlights values are present, repeat steps 2 & 3 using highlight values.\n             * 4. Create the new dataView using the points computed above\n             */\n            function linearRegressionTransform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\n                debug.assertValue(dataRoles, 'dataRoles');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!sourceDataView.categorical)\n                    return;\n                // Step 1\n                var xColumns = getColumnsForCartesianRoleKind(0 /* X */, sourceDataView.categorical, dataRoles);\n                var yColumns = getColumnsForCartesianRoleKind(1 /* Y */, sourceDataView.categorical, dataRoles);\n                if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\n                    return;\n                var xColumnSource = xColumns[0].source;\n                var yColumnSource = yColumns[0].source;\n                var combineSeries = true;\n                if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\n                    var regressionUsage = regressionDataViewMapping.usage.regression;\n                    var combineSeriesPropertyId = regressionUsage['combineSeries'];\n                    if (combineSeriesPropertyId) {\n                        combineSeries = powerbi.DataViewObjects.getValue(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\n                    }\n                }\n                // Step 2\n                var dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\n                var lineDefSet = calculateLineDefinitions(dataPointsBySeries);\n                var xMin = lineDefSet.xMin;\n                var xMax = lineDefSet.xMax;\n                var shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\n                var highlightsLineDefSet;\n                if (shouldComputeHightlights) {\n                    var highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\n                    highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\n                    if (highlightsLineDefSet) {\n                        xMin = _.min([xMin, highlightsLineDefSet.xMin]);\n                        xMax = _.max([xMax, highlightsLineDefSet.xMax]);\n                    }\n                    else {\n                        shouldComputeHightlights = false;\n                    }\n                }\n                // Step 3\n                var valuesByTrend = [];\n                for (var _i = 0, _a = lineDefSet.lineDefs; _i < _a.length; _i++) {\n                    var trend = _a[_i];\n                    valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                }\n                var highlightsByTrend;\n                if (shouldComputeHightlights) {\n                    highlightsByTrend = [];\n                    for (var _b = 0, _c = highlightsLineDefSet.lineDefs; _b < _c.length; _b++) {\n                        var trend = _c[_b];\n                        highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                    }\n                }\n                // Step 4\n                var groupValues;\n                if (combineSeries) {\n                    groupValues = ['combinedRegressionSeries'];\n                }\n                else {\n                    // If we are producing a trend line per series we need to maintain the group identities so that we can map between the \n                    // trend line and the original series (to match the color for example).\n                    if (sourceDataView.categorical.values.source) {\n                        // Source data view has dynamic series.\n                        var groups = sourceDataView.categorical.values.grouped();\n                        groupValues = _.map(groups, function (group) { return group.name; });\n                    }\n                    else {\n                        // Source data view has static or no series.\n                        groupValues = _.map(yColumns, function (column) { return column.source.queryName; });\n                    }\n                }\n                // Step 5\n                var regressionDataView = createRegressionDataView(xColumnSource, yColumnSource, groupValues, [xMin, xMax], valuesByTrend, highlightsByTrend, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                return regressionDataView;\n            }\n            DataViewRegression.linearRegressionTransform = linearRegressionTransform;\n            function calculateLineDefinitions(dataPointsBySeries) {\n                var xMin;\n                var xMax;\n                var lineDefs = [];\n                for (var _i = 0, dataPointsBySeries_1 = dataPointsBySeries; _i < dataPointsBySeries_1.length; _i++) {\n                    var dataPointSet = dataPointsBySeries_1[_i];\n                    var unsortedXValues = dataPointSet.xValues;\n                    var unsortedYValues = dataPointSet.yValues;\n                    if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\n                        return;\n                    // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\n                    var xDataType = getDataType(unsortedXValues);\n                    if (!xDataType)\n                        return;\n                    var yDataType = getDataType(unsortedYValues);\n                    if (!yDataType)\n                        return;\n                    var sortedDataPointSet = sortValues(unsortedXValues, unsortedYValues);\n                    var minCategoryValue = sortedDataPointSet.xValues[0];\n                    var maxCategoryValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\n                    var lineDef = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\n                    xMin = _.min([xMin, minCategoryValue]);\n                    xMax = _.max([xMax, maxCategoryValue]);\n                    lineDefs.push(lineDef);\n                }\n                return {\n                    lineDefs: lineDefs,\n                    xMin: xMin,\n                    xMax: xMax,\n                };\n            }\n            function getColumnsForCartesianRoleKind(roleKind, categorical, roles) {\n                debug.assertValue(roleKind, 'roleKind');\n                debug.assertValue(categorical, 'categorical');\n                var columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n                var categories = categorical.categories;\n                if (_.isEmpty(categories))\n                    return;\n                debug.assert(categories.length === 1, 'composite category columns not supported');\n                var categoryColumn = categories[0];\n                columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n            }\n            function getColumnsWithRoleKind(roleKind, columns, roles) {\n                if (_.isEmpty(columns))\n                    return;\n                return _.filter(columns, function (column) {\n                    var _loop_1 = function(roleName) {\n                        if (!column.source.roles[roleName])\n                            return \"continue\";\n                        var role = _.find(roles, function (role) { return role.name === roleName; });\n                        if (role && role.cartesianKind === roleKind)\n                            return { value: true };\n                    };\n                    for (var roleName in column.source.roles) {\n                        var state_1 = _loop_1(roleName);\n                        if (typeof state_1 === \"object\") return state_1.value;\n                        if (state_1 === \"continue\") continue;\n                    }\n                    return false;\n                });\n            }\n            function getDataType(values) {\n                var firstNonNull = _.find(values, function (value) { return value != null; });\n                if (firstNonNull == null)\n                    return;\n                var dataType = typeof firstNonNull;\n                if (_.some(values, function (value) { return value != null && typeof value !== dataType; }))\n                    return;\n                return dataType;\n            }\n            function sortValues(unsortedXValues, unsortedYValues) {\n                debug.assertValue(unsortedXValues, 'unsortedXValues');\n                debug.assertValue(unsortedYValues, 'unsortedYValues');\n                var zippedValues = _.zip(unsortedXValues, unsortedYValues);\n                var _a = _.chain(zippedValues)\n                    .filter(function (valuePair) { return valuePair[0] != null && valuePair[1] != null; })\n                    .sortBy(function (valuePair) { return valuePair[0]; })\n                    .unzip()\n                    .value(), xValues = _a[0], yValues = _a[1];\n                return {\n                    xValues: xValues,\n                    yValues: yValues\n                };\n            }\n            /**\n             * Computes a line definition using linear regression.\n             *   xBar: average of X values, yBar: average of Y values\n             *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\n             *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\n             *   Slope: ssXY / ssXX\n             *   Intercept: yBar - xBar * slope\n             */\n            function computeRegressionLine(xValues, yValues) {\n                debug.assertValue(xValues, 'xValues');\n                debug.assertValue(yValues, 'yValues');\n                var xBar = _.sum(xValues) / xValues.length;\n                var yBar = _.sum(yValues) / yValues.length;\n                var ssXX = _.chain(xValues)\n                    .map(function (x) {\n                    return Math.pow((x - xBar), 2);\n                })\n                    .sum();\n                var ssXY = _.chain(xValues)\n                    .map(function (x, i) {\n                    return (x - xBar) * (yValues[i] - yBar);\n                })\n                    .sum();\n                var slope = ssXY / ssXX;\n                var intercept = yBar - (xBar * slope);\n                return {\n                    slope: slope,\n                    intercept: intercept\n                };\n            }\n            function computeLineYValues(lineDef, x1, x2) {\n                return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\n            }\n            function getValuesFromColumn(column, preferHighlights) {\n                if (preferHighlights) {\n                    // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\n                    var valueColumn = column;\n                    if (valueColumn.highlights) {\n                        return valueColumn.highlights;\n                    }\n                }\n                return column.values;\n            }\n            function getDataPointsBySeries(xColumns, yColumns, combineSeries, preferHighlights) {\n                var dataPointsBySeries = [];\n                var xValueArray = _.map(xColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var seriesYValues = _.map(yColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var multipleXValueColumns = xColumns.length > 1;\n                for (var i = 0; i < seriesYValues.length; i++) {\n                    var xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\n                    var yValues = seriesYValues[i];\n                    if (combineSeries && dataPointsBySeries.length > 0) {\n                        dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\n                        dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\n                    }\n                    else {\n                        dataPointsBySeries.push({\n                            xValues: xValues,\n                            yValues: yValues,\n                        });\n                    }\n                }\n                return dataPointsBySeries;\n            }\n            function createRegressionDataView(xColumnSource, yColumnSource, groupValues, categories, values, highlights, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(xColumnSource, 'xColumnSource');\n                debug.assertValue(yColumnSource, 'yColumnSource');\n                debug.assertValue(categories, 'categories');\n                debug.assertValue(values, 'values');\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertAnyValue(highlights, 'highlights');\n                debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\n                var xRole = regressionDataViewMapping.categorical.categories.for.in;\n                var grouped = regressionDataViewMapping.categorical.values.group;\n                var yRole;\n                var seriesRole;\n                if (grouped && !_.isEmpty(grouped.select)) {\n                    yRole = grouped.select[0].for ?\n                        grouped.select[0].for.in :\n                        grouped.select[0].bind.to;\n                    seriesRole = grouped.by;\n                }\n                if (!yRole || !seriesRole)\n                    return;\n                var categoricalRoles = (_a = {}, _a[xRole] = true, _a);\n                var valueRoles = (_b = {}, _b[yRole] = true, _b);\n                var seriesRoles = (_c = {}, _c[seriesRole] = true, _c);\n                var valuesBySeries = [];\n                for (var index in values) {\n                    var seriesData = {\n                        values: values[index],\n                    };\n                    if (highlights)\n                        seriesData.highlights = highlights[index];\n                    valuesBySeries.push([seriesData]);\n                }\n                var regressionDataView = data.createCategoricalDataViewBuilder()\n                    .withCategory({\n                    source: {\n                        displayName: xColumnSource.displayName,\n                        queryName: regressionXQueryName,\n                        type: xColumnSource.type,\n                        isMeasure: false,\n                        roles: categoricalRoles\n                    },\n                    values: categories,\n                    identityFrom: {\n                        fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\n                    },\n                })\n                    .withGroupedValues({\n                    groupColumn: {\n                        source: {\n                            displayName: yColumnSource.displayName + 'Regression',\n                            queryName: regressionSeriesQueryName,\n                            type: yColumnSource.type,\n                            isMeasure: yColumnSource.isMeasure,\n                            roles: seriesRoles\n                        },\n                        values: groupValues,\n                        identityFrom: {\n                            fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\n                        }\n                    },\n                    valueColumns: [{\n                            source: {\n                                displayName: yColumnSource.displayName,\n                                queryName: DataViewRegression.regressionYQueryName,\n                                type: yColumnSource.type,\n                                isMeasure: yColumnSource.isMeasure,\n                                roles: valueRoles\n                            },\n                        }],\n                    data: valuesBySeries\n                })\n                    .build();\n                data.DataViewTransform.transformObjects(regressionDataView, 1 /* Categorical */, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\n                return regressionDataView;\n                var _a, _b, _c;\n            }\n            function hasHighlightValues(columns) {\n                return _.any(columns, function (column) {\n                    var valueColumn = column;\n                    return valueColumn.highlights != null;\n                });\n            }\n        })(DataViewRegression = data.DataViewRegression || (data.DataViewRegression = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelectTransform;\n        (function (DataViewSelectTransform) {\n            /** Convert selection info to projections */\n            function projectionsFromSelects(selects, projectionActiveItems) {\n                debug.assertAnyValue(selects, \"selects\");\n                debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\n                var projections = {};\n                for (var _i = 0, selects_1 = selects; _i < selects_1.length; _i++) {\n                    var select = selects_1[_i];\n                    var roles = select.roles;\n                    if (!roles)\n                        continue;\n                    for (var roleName in roles) {\n                        if (roles[roleName]) {\n                            var qp = projections[roleName];\n                            if (!qp)\n                                qp = projections[roleName] = new data.QueryProjectionCollection([]);\n                            qp.all().push({ queryRef: select.queryName });\n                            if (projectionActiveItems && projectionActiveItems[roleName])\n                                qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], function (activeItem) { return activeItem.queryRef; });\n                        }\n                    }\n                }\n                return projections;\n            }\n            DataViewSelectTransform.projectionsFromSelects = projectionsFromSelects;\n            /** Use selections and metadata to fashion query role kinds */\n            function createRoleKindFromMetadata(selects, metadata) {\n                var roleKindByQueryRef = {};\n                for (var _i = 0, _a = metadata.columns; _i < _a.length; _i++) {\n                    var column = _a[_i];\n                    if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\n                        continue;\n                    var select = selects[column.index];\n                    if (select) {\n                        var queryRef = select.queryName;\n                        if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\n                            roleKindByQueryRef[queryRef] = column.isMeasure ? powerbi.VisualDataRoleKind.Measure : powerbi.VisualDataRoleKind.Grouping;\n                        }\n                    }\n                }\n                return roleKindByQueryRef;\n            }\n            DataViewSelectTransform.createRoleKindFromMetadata = createRoleKindFromMetadata;\n        })(DataViewSelectTransform = data.DataViewSelectTransform || (data.DataViewSelectTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createCategoricalEvalContext(colorAllocatorProvider, dataViewCategorical) {\n            return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\n        }\n        data.createCategoricalEvalContext = createCategoricalEvalContext;\n        var CategoricalEvalContext = (function () {\n            function CategoricalEvalContext(colorAllocatorProvider, dataView) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.columnsByRole = {};\n            }\n            CategoricalEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            CategoricalEvalContext.prototype.getExprValue = function (expr) {\n                return;\n            };\n            CategoricalEvalContext.prototype.getRoleValue = function (roleName) {\n                var columnsByRole = this.columnsByRole;\n                var column = columnsByRole[roleName];\n                if (!column)\n                    column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\n                if (!column)\n                    return;\n                var index = this.index;\n                if (index != null)\n                    return column.values[this.index];\n            };\n            CategoricalEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.index = index;\n            };\n            return CategoricalEvalContext;\n        }());\n        function findRuleInputColumn(dataViewCategorical, inputRole) {\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n            return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\n                findRuleInputInColumns(dataViewCategorical.categories, inputRole);\n        }\n        function findRuleInputInColumns(columns, inputRole) {\n            debug.assertAnyValue(columns, 'columns');\n            if (!columns)\n                return;\n            for (var _i = 0, columns_7 = columns; _i < columns_7.length; _i++) {\n                var column = columns_7[_i];\n                var roles = column.source.roles;\n                if (!roles || !roles[inputRole])\n                    continue;\n                return column;\n            }\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createTableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms) {\n            return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\n        }\n        data.createTableEvalContext = createTableEvalContext;\n        var TableEvalContext = (function () {\n            function TableEvalContext(colorAllocatorProvider, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            TableEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            TableEvalContext.prototype.getExprValue = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var rowIdx = this.rowIdx;\n                if (rowIdx == null)\n                    return;\n                return data.getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\n            };\n            TableEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            TableEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.rowIdx = index;\n            };\n            return TableEvalContext;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var RuleEvaluation = (function () {\n            function RuleEvaluation() {\n            }\n            // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\n            RuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\n            };\n            return RuleEvaluation;\n        }());\n        data.RuleEvaluation = RuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ColorRuleEvaluation = (function (_super) {\n            __extends(ColorRuleEvaluation, _super);\n            function ColorRuleEvaluation(inputRole, allocator) {\n                debug.assertValue(inputRole, 'inputRole');\n                debug.assertValue(allocator, 'allocator');\n                _super.call(this);\n                this.inputRole = inputRole;\n                this.allocator = allocator;\n            }\n            ColorRuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertValue(evalContext, 'evalContext');\n                var value = evalContext.getRoleValue(this.inputRole);\n                if (value !== undefined)\n                    return this.allocator.color(value);\n            };\n            return ColorRuleEvaluation;\n        }(data.RuleEvaluation));\n        data.ColorRuleEvaluation = ColorRuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var inherit = powerbi.Prototype.inherit;\n            var inheritSingle = powerbi.Prototype.inheritSingle;\n            var ArrayExtensions = jsCommon.ArrayExtensions;\n            var DataViewMatrixUtils;\n            (function (DataViewMatrixUtils) {\n                /**\n                 * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the\n                 * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the\n                 * particular leaf node in the context of this forEachLeafNode(...) invocation.\n                 *\n                 * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\n                 *\n                 * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified\n                 * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\n                 * then treePath will be an array of length 1 containing that very node.\n                 *\n                 * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\n                 * If your callback needs to retain a copy of the treePath, please clone the array before returning.\n                 */\n                function forEachLeafNode(rootNodes, callback) {\n                    debug.assertAnyValue(rootNodes, 'rootNodes');\n                    debug.assertValue(callback, 'callback');\n                    // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\n                    // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \n                    // for the fact that all the properties on DataViewMatrixNode are optional...\n                    if (rootNodes) {\n                        if (isNodeArray(rootNodes)) {\n                            var index = 0;\n                            for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {\n                                var rootNode = rootNodes_1[_i];\n                                if (rootNode) {\n                                    index = forEachLeafNodeRecursive(rootNode, index, [], callback);\n                                }\n                            }\n                        }\n                        else {\n                            forEachLeafNodeRecursive(rootNodes, 0, [], callback);\n                        }\n                    }\n                }\n                DataViewMatrixUtils.forEachLeafNode = forEachLeafNode;\n                function isNodeArray(nodeOrNodeArray) {\n                    return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\n                }\n                /**\n                 * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\n                 * Returns the index for the next node after the last node that this function invokes callback with.\n                 *\n                 * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\n                 */\n                function forEachLeafNodeRecursive(matrixNode, nextIndex, treePath, callback) {\n                    debug.assertValue(matrixNode, 'matrixNode');\n                    debug.assertValue(treePath, 'treePath');\n                    debug.assertValue(callback, 'callback');\n                    // If treePath already contains matrixNode, then either one of the following errors has happened:\n                    // 1. the caller code mistakenly added matrixNode to treePath, or\n                    // 2. the callback modified treePath by adding a node to it, or\n                    // 3. the matrix hierarchy contains a cyclical node reference.');\n                    debug.assert(!_.contains(treePath, matrixNode), 'pre-condition: treePath must not already contain matrixNode');\n                    treePath.push(matrixNode);\n                    if (_.isEmpty(matrixNode.children)) {\n                        callback(matrixNode, nextIndex, treePath);\n                        nextIndex++;\n                    }\n                    else {\n                        var children = matrixNode.children;\n                        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n                            var nextChild = children_1[_i];\n                            if (nextChild) {\n                                nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\n                            }\n                        }\n                    }\n                    debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\n                    treePath.pop();\n                    return nextIndex;\n                }\n                /**\n                 * Returned an object tree where each node and its children property are inherited from the specified node\n                 * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\n                 *\n                 * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array\n                 * property, i.e. its children property is the same array object referenced in the input node's object tree.\n                 *\n                 * @param node The input node with the hierarchy object tree.\n                 * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\n                 * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is\n                 * not already an inherited object. Same goes for the node's children property.  This is useful for creating\n                 * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for\n                 * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains\n                 * inherited objects.\n                 */\n                function inheritMatrixNodeHierarchy(node, deepestLevelToInherit, useInheritSingle) {\n                    debug.assertValue(node, 'node');\n                    debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\n                    debug.assertValue(useInheritSingle, 'useInheritSingle');\n                    var returnNode = node;\n                    // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\n                    // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\n                    // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\n                    //  {\n                    //    \"level\": 0,\n                    //    \"isSubtotal\": true,\n                    //    \"children\": [\n                    //      { \"level\": 2, \"isSubtotal\": true },\n                    //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\n                    //    ]\n                    //  }\n                    var isRootNode = _.isUndefined(node.level);\n                    var shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\n                    if (shouldInheritCurrentNode) {\n                        var inheritFunc = useInheritSingle ? inheritSingle : inherit;\n                        var inheritedNode = inheritFunc(node);\n                        var shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\n                        if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\n                            inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\n                            for (var i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\n                                inheritedNode.children[i] =\n                                    inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\n                            }\n                        }\n                        returnNode = inheritedNode;\n                    }\n                    return returnNode;\n                }\n                DataViewMatrixUtils.inheritMatrixNodeHierarchy = inheritMatrixNodeHierarchy;\n                /**\n                 * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\n                 * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\n                 * Year === 2016, Quarter === 'Qtr 1', Month === 1.\n                 *\n                 * Returns false if the specified matrixOrHierarchy does not contain any composite group,\n                 * or if matrixOrHierarchy is null or undefined.\n                 */\n                function containsCompositeGroup(matrixOrHierarchy) {\n                    debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\n                    var hasCompositeGroup = false;\n                    if (matrixOrHierarchy) {\n                        if (isMatrix(matrixOrHierarchy)) {\n                            hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\n                                containsCompositeGroup(matrixOrHierarchy.columns);\n                        }\n                        else {\n                            var hierarchyLevels = matrixOrHierarchy.levels;\n                            if (!_.isEmpty(hierarchyLevels)) {\n                                for (var _i = 0, hierarchyLevels_1 = hierarchyLevels; _i < hierarchyLevels_1.length; _i++) {\n                                    var level = hierarchyLevels_1[_i];\n                                    // it takes at least 2 columns at the same hierarchy level to form a composite group...\n                                    if (level.sources && (level.sources.length >= 2)) {\n                                        debug.assert(_.all(level.sources, function (sourceColumn) { return sourceColumn.isMeasure === level.sources[0].isMeasure; }), 'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\n                                        // Measure headers are not group\n                                        var isMeasureHeadersLevel = level.sources[0].isMeasure;\n                                        if (!isMeasureHeadersLevel) {\n                                            hasCompositeGroup = true;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return hasCompositeGroup;\n                }\n                DataViewMatrixUtils.containsCompositeGroup = containsCompositeGroup;\n                function isMatrix(matrixOrHierarchy) {\n                    return 'rows' in matrixOrHierarchy &&\n                        'columns' in matrixOrHierarchy &&\n                        'valueSources' in matrixOrHierarchy;\n                }\n            })(DataViewMatrixUtils = utils.DataViewMatrixUtils || (utils.DataViewMatrixUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var DataViewMetadataColumnUtils;\n            (function (DataViewMetadataColumnUtils) {\n                /**\n                 * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\n                 */\n                function isForRole(metadataColumn, targetRole) {\n                    debug.assertValue(metadataColumn, 'metadataColumn');\n                    debug.assertValue(targetRole, 'targetRole');\n                    var roles = metadataColumn.roles;\n                    return roles && roles[targetRole];\n                }\n                DataViewMetadataColumnUtils.isForRole = isForRole;\n                /**\n                 * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\n                 *\n                 * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the\n                 * specified columnSources must be a non-filtered array of column sources from the DataView, such as\n                 * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\n                 *\n                 * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\n                 * @param projection The projection ordering.  It must contain an ordering for the specified role.\n                 * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\n                 */\n                function joinMetadataColumnsAndProjectionOrder(columnSources, projection, role) {\n                    debug.assertAnyValue(columnSources, 'columnSources');\n                    debug.assert(_.all(columnSources, function (column) { return _.isNumber(column.index); }), 'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\n                    debug.assertNonEmpty(projection[role], 'projection[role]');\n                    debug.assert(_.all(columnSources, function (column) { return !isForRole(column, role) || _.contains(projection[role], column.index); }), 'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\n                    var jointResult = [];\n                    if (!_.isEmpty(columnSources)) {\n                        var projectionOrderSelectIndices = projection[role];\n                        var selectIndexToProjectionIndexMap = {};\n                        for (var i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\n                            var selectIndex = projectionOrderSelectIndices[i];\n                            selectIndexToProjectionIndexMap[selectIndex] = i;\n                        }\n                        for (var j = 0, jlen = columnSources.length; j < jlen; j++) {\n                            var column = columnSources[j];\n                            if (isForRole(column, role)) {\n                                var jointColumnInfo = {\n                                    metadataColumn: column,\n                                    sourceIndex: j,\n                                    projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\n                                };\n                                jointResult.push(jointColumnInfo);\n                            }\n                        }\n                    }\n                    return jointResult;\n                }\n                DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder = joinMetadataColumnsAndProjectionOrder;\n            })(DataViewMetadataColumnUtils = utils.DataViewMetadataColumnUtils || (utils.DataViewMetadataColumnUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ConceptualSchema = (function () {\n            function ConceptualSchema() {\n            }\n            ConceptualSchema.prototype.findProperty = function (entityName, propertyName) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                return entity.properties.withName(propertyName);\n            };\n            ConceptualSchema.prototype.findHierarchy = function (entityName, name) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.hierarchies))\n                    return;\n                return entity.hierarchies.withName(name);\n            };\n            ConceptualSchema.prototype.findHierarchyByVariation = function (variationEntityName, variationColumnName, variationName, hierarchyName) {\n                var variationEntity = this.entities.withName(variationEntityName);\n                if (!variationEntity || _.isEmpty(variationEntity.properties))\n                    return;\n                var variationProperty = variationEntity.properties.withName(variationColumnName);\n                if (!variationProperty)\n                    return;\n                var variationColumn = variationProperty.column;\n                if (!variationColumn || _.isEmpty(variationColumn.variations))\n                    return;\n                var variation = variationColumn.variations.withName(variationName);\n                if (variation) {\n                    var targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\n                    if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\n                        return;\n                    return targetEntity.hierarchies.withName(hierarchyName);\n                }\n            };\n            /**\n            * Returns the first property of the entity whose kpi is tied to kpiProperty\n            */\n            ConceptualSchema.prototype.findPropertyWithKpi = function (entityName, kpiProperty) {\n                debug.assertValue(kpiProperty, 'kpiProperty');\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                for (var _i = 0, _a = entity.properties; _i < _a.length; _i++) {\n                    var prop = _a[_i];\n                    if (prop &&\n                        prop.measure &&\n                        prop.measure.kpi &&\n                        (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\n                        return prop;\n                }\n                return;\n            };\n            return ConceptualSchema;\n        }());\n        data.ConceptualSchema = ConceptualSchema;\n        // TODO: Remove this (replaced by ValueType)\n        (function (ConceptualDataCategory) {\n            ConceptualDataCategory[ConceptualDataCategory[\"None\"] = 0] = \"None\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Address\"] = 1] = \"Address\";\n            ConceptualDataCategory[ConceptualDataCategory[\"City\"] = 2] = \"City\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Company\"] = 3] = \"Company\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Continent\"] = 4] = \"Continent\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Country\"] = 5] = \"Country\";\n            ConceptualDataCategory[ConceptualDataCategory[\"County\"] = 6] = \"County\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Date\"] = 7] = \"Date\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Image\"] = 8] = \"Image\";\n            ConceptualDataCategory[ConceptualDataCategory[\"ImageUrl\"] = 9] = \"ImageUrl\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Latitude\"] = 10] = \"Latitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Longitude\"] = 11] = \"Longitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Organization\"] = 12] = \"Organization\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Place\"] = 13] = \"Place\";\n            ConceptualDataCategory[ConceptualDataCategory[\"PostalCode\"] = 14] = \"PostalCode\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Product\"] = 15] = \"Product\";\n            ConceptualDataCategory[ConceptualDataCategory[\"StateOrProvince\"] = 16] = \"StateOrProvince\";\n            ConceptualDataCategory[ConceptualDataCategory[\"WebUrl\"] = 17] = \"WebUrl\";\n        })(data.ConceptualDataCategory || (data.ConceptualDataCategory = {}));\n        var ConceptualDataCategory = data.ConceptualDataCategory;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var FieldExprPattern = powerbi.data.FieldExprPattern;\n    var ScriptResultUtil;\n    (function (ScriptResultUtil) {\n        function findScriptResult(dataViewMappings) {\n            if (dataViewMappings && dataViewMappings.length === 1) {\n                return dataViewMappings[0].scriptResult;\n            }\n            return undefined;\n        }\n        ScriptResultUtil.findScriptResult = findScriptResult;\n        function extractScriptResult(dataViewMappings) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult) {\n                var objects = dataViewMappings[0].metadata.objects;\n                var source = powerbi.DataViewObjects.getValue(objects, scriptResult.script.source);\n                var provider = powerbi.DataViewObjects.getValue(objects, scriptResult.script.provider);\n                return {\n                    source: source,\n                    provider: provider\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResult = extractScriptResult;\n        function extractScriptResultFromVisualConfig(dataViewMappings, objects) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult && objects) {\n                var scriptSource = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\n                var provider = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\n                return {\n                    source: scriptSource ? scriptSource.value : null,\n                    provider: provider ? provider.value : null\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResultFromVisualConfig = extractScriptResultFromVisualConfig;\n        function getScriptInput(projections, selects, schema) {\n            var scriptInput = {\n                VariableName: \"dataset\",\n                Columns: []\n            };\n            // Go over all the projections, and create an input column according to the order\n            // of the projections (including duplicate expressions)\n            if (projections && selects && !_.isEmpty(selects)) {\n                var scriptInputColumnNames = [];\n                var scriptInputColumns = [];\n                for (var role in projections) {\n                    for (var _i = 0, _a = projections[role].all(); _i < _a.length; _i++) {\n                        var projection = _a[_i];\n                        var select = selects.withName(projection.queryRef);\n                        if (select) {\n                            var scriptInputColumn = {\n                                QueryName: select.name,\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\n                            };\n                            scriptInputColumns.push(scriptInputColumn);\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\n                        }\n                    }\n                }\n                // Make sure the names of the columns are unique\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\n                // Update the names of the columns\n                for (var i = 0; i < scriptInputColumnNames.length; i++) {\n                    var scriptInputColumn = scriptInputColumns[i];\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\n                }\n                scriptInput.Columns = scriptInputColumns;\n            }\n            return scriptInput;\n        }\n        ScriptResultUtil.getScriptInput = getScriptInput;\n        var ScriptInputColumnNameVisitor = (function () {\n            function ScriptInputColumnNameVisitor(federatedSchema) {\n                this.federatedSchema = federatedSchema;\n            }\n            ScriptInputColumnNameVisitor.prototype.visitColumn = function (column) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntity = function (entity) {\n                return entity.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                return entityAggr.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchy = function (hierarchy) {\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                /*Hierarchy levels are not supported yet*/\n                return;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitMeasure = function (measure) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.getNameForHierarchy = function (pattern, federatedScheam) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedScheam.schema(pattern.schema), hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\n                if (hierarchy)\n                    return hierarchy.name;\n            };\n            ScriptInputColumnNameVisitor.getNameForProperty = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedSchema.schema(pattern.schema), property = schema.findProperty(pattern.entity, pattern.name);\n                if (property)\n                    return property.name;\n            };\n            ScriptInputColumnNameVisitor.getVariationLevelName = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var source = pattern.source;\n                var prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\n                if (!prop)\n                    return;\n                var variations = prop.column.variations;\n                for (var _i = 0, variations_1 = variations; _i < variations_1.length; _i++) {\n                    var variation = variations_1[_i];\n                    if (variation.name === pattern.variationName)\n                        for (var _a = 0, _b = variation.defaultHierarchy.levels; _a < _b.length; _a++) {\n                            var level = _b[_a];\n                            if (level.name === pattern.level.level)\n                                return level.column.name;\n                        }\n                }\n            };\n            return ScriptInputColumnNameVisitor;\n        }());\n    })(ScriptResultUtil = powerbi.ScriptResultUtil || (powerbi.ScriptResultUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var segmentation;\n        (function (segmentation) {\n            var DataViewMerger;\n            (function (DataViewMerger) {\n                function mergeDataViews(source, segment) {\n                    if (!powerbi.DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\n                        debug.assertFail(\"Cannot merge data views with different metadata columns\");\n                    }\n                    // The last segment is complete. We mark the source as complete.\n                    if (!segment.metadata.segment)\n                        delete source.metadata.segment;\n                    if (source.table && segment.table)\n                        mergeTables(source.table, segment.table);\n                    if (source.categorical && segment.categorical)\n                        mergeCategorical(source.categorical, segment.categorical);\n                    // Tree cannot support subtotals hence we can get into situations\n                    // where a node has no children in one segment and more than 1 child\n                    // in another segment.\n                    if (source.tree && segment.tree)\n                        mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\n                    if (source.matrix && segment.matrix)\n                        mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\n                }\n                DataViewMerger.mergeDataViews = mergeDataViews;\n                /** Note: Public for testability */\n                function mergeTables(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    if (segment.rows.length === 0)\n                        return;\n                    merge(source.rows, segment.rows, segment.lastMergeIndex + 1);\n                }\n                DataViewMerger.mergeTables = mergeTables;\n                /**\n                 * Merge categories values and identities\n                 *\n                 * Note: Public for testability\n                 */\n                function mergeCategorical(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    // Merge categories values and identities\n                    if (source.categories && segment.categories) {\n                        var segmentCategoriesLength = segment.categories.length;\n                        debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\n                        for (var categoryIndex = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\n                            var segmentCategory = segment.categories[categoryIndex];\n                            var sourceCategory = source.categories[categoryIndex];\n                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\n                            if (!sourceCategory.values && segmentCategory.values) {\n                                sourceCategory.values = [];\n                                debug.assert(!sourceCategory.identity, \"Source category is missing values but has identities.\");\n                            }\n                            if (segmentCategory.values) {\n                                merge(sourceCategory.values, segmentCategory.values, segment.lastMergeIndex + 1);\n                            }\n                            if (!sourceCategory.identity && segmentCategory.identity) {\n                                sourceCategory.identity = [];\n                            }\n                            if (segmentCategory.identity) {\n                                merge(sourceCategory.identity, segmentCategory.identity, segment.lastMergeIndex + 1);\n                            }\n                        }\n                    }\n                    // Merge values for each value column\n                    if (source.values && segment.values) {\n                        var segmentValuesLength = segment.values.length;\n                        debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\n                        for (var valueIndex = 0; valueIndex < segmentValuesLength; valueIndex++) {\n                            var segmentValue = segment.values[valueIndex];\n                            var sourceValue = source.values[valueIndex];\n                            debug.assert(jsCommon.JsonComparer.equals(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\n                            if (!sourceValue.values && segmentValue.values) {\n                                sourceValue.values = [];\n                            }\n                            if (segmentValue.values) {\n                                merge(sourceValue.values, segmentValue.values, segment.lastMergeIndex + 1);\n                            }\n                            if (segmentValue.highlights) {\n                                merge(sourceValue.highlights, segmentValue.highlights, segment.lastMergeIndex + 1);\n                            }\n                        }\n                    }\n                }\n                DataViewMerger.mergeCategorical = mergeCategorical;\n                /**\n                 * Merges the segment array starting at the specified index into the source array\n                 * and returns the segment slice that wasn't merged.\n                 * The segment array is spliced up to specified index in the process.\n                 */\n                function merge(source, segment, index) {\n                    if (index >= segment.length)\n                        return segment;\n                    var result = [];\n                    if (index !== undefined)\n                        result = segment.splice(0, index);\n                    Array.prototype.push.apply(source, segment);\n                    return result;\n                }\n                /** Note: Public for testability */\n                function mergeTreeNodes(sourceRoot, segmentRoot, allowDifferentStructure) {\n                    debug.assertValue(sourceRoot, 'sourceRoot');\n                    debug.assertValue(segmentRoot, 'segmentRoot');\n                    if (!segmentRoot.children || segmentRoot.children.length === 0)\n                        return;\n                    if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\n                        sourceRoot.children = segmentRoot.children;\n                        return;\n                    }\n                    debug.assert(sourceRoot.children && sourceRoot.children.length >= 0, \"Source tree has different structure than segment.\");\n                    var firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\n                    var lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\n                    var mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\n                    if (mergedChildren.length > 0)\n                        mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\n                }\n                DataViewMerger.mergeTreeNodes = mergeTreeNodes;\n                function findFirstAppendIndex(children) {\n                    if (children.length === 0)\n                        return 0;\n                    var i = 0;\n                    for (; i < children.length; i++) {\n                        var childSegment = children[i];\n                        if (!childSegment.isMerge)\n                            break;\n                    }\n                    return i;\n                }\n            })(DataViewMerger = segmentation.DataViewMerger || (segmentation.DataViewMerger = {}));\n        })(segmentation = data.segmentation || (data.segmentation = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Rewrites an expression tree, including all descendant nodes. */\n        var SQExprRewriter = (function () {\n            function SQExprRewriter() {\n            }\n            SQExprRewriter.prototype.visitColumnRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQColumnRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitMeasureRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQMeasureRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitAggr = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQAggregationExpr(rewrittenArg, expr.func);\n            };\n            SQExprRewriter.prototype.visitHierarchy = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyExpr(rewrittenArg, expr.hierarchy);\n            };\n            SQExprRewriter.prototype.visitHierarchyLevel = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyLevelExpr(rewrittenArg, expr.level);\n            };\n            SQExprRewriter.prototype.visitPropertyVariationSource = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\n            };\n            SQExprRewriter.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitAnd = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQAndExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitBetween = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this), origLower = orig.lower, rewrittenLower = origLower.accept(this), origUpper = orig.upper, rewrittenUpper = origUpper.accept(this);\n                if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\n                    return orig;\n                return new data.SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\n            };\n            SQExprRewriter.prototype.visitIn = function (orig) {\n                var origArgs = orig.args, rewrittenArgs = this.rewriteAll(origArgs), origValues = orig.values, rewrittenValues;\n                for (var i = 0, len = origValues.length; i < len; i++) {\n                    var origValueTuple = origValues[i], rewrittenValueTuple = this.rewriteAll(origValueTuple);\n                    if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\n                        rewrittenValues = ArrayExtensions.take(origValues, i);\n                    if (rewrittenValues)\n                        rewrittenValues.push(rewrittenValueTuple);\n                }\n                if (origArgs === rewrittenArgs && !rewrittenValues)\n                    return orig;\n                return new data.SQInExpr(rewrittenArgs, rewrittenValues || origValues);\n            };\n            SQExprRewriter.prototype.rewriteAll = function (origExprs) {\n                debug.assertValue(origExprs, 'origExprs');\n                var rewrittenResult;\n                for (var i = 0, len = origExprs.length; i < len; i++) {\n                    var origExpr = origExprs[i], rewrittenExpr = origExpr.accept(this);\n                    if (origExpr !== rewrittenExpr && !rewrittenResult)\n                        rewrittenResult = ArrayExtensions.take(origExprs, i);\n                    if (rewrittenResult)\n                        rewrittenResult.push(rewrittenExpr);\n                }\n                return rewrittenResult || origExprs;\n            };\n            SQExprRewriter.prototype.visitOr = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQOrExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitCompare = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitContains = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQContainsExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitExists = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQExistsExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNot = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQNotExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitStartsWith = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQStartsWithExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitConstant = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitDateSpan = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateSpanExpr(orig.unit, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitDateAdd = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNow = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitDefaultValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitAnyValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitArithmetic = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\n            };\n            SQExprRewriter.prototype.visitScopedEval = function (orig) {\n                var origExpression = orig.expression, rewrittenExpression = origExpression.accept(this), origScope = orig.scope, rewrittenScope = this.rewriteAll(origScope);\n                if (origExpression === rewrittenExpression && origScope === rewrittenScope)\n                    return orig;\n                return new data.SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\n            };\n            SQExprRewriter.prototype.visitFillRule = function (orig) {\n                var origInput = orig.input, rewrittenInput = origInput.accept(this);\n                var origRule = orig.rule;\n                var origGradient2 = origRule.linearGradient2, rewrittenGradient2 = origGradient2;\n                if (origGradient2) {\n                    rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\n                }\n                var origGradient3 = origRule.linearGradient3, rewrittenGradient3 = origGradient3;\n                if (origGradient3) {\n                    rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\n                }\n                if (origInput !== rewrittenInput ||\n                    origGradient2 !== rewrittenGradient2 ||\n                    origGradient3 !== rewrittenGradient3) {\n                    var rewrittenRule = {};\n                    if (rewrittenGradient2)\n                        rewrittenRule.linearGradient2 = rewrittenGradient2;\n                    if (rewrittenGradient3)\n                        rewrittenRule.linearGradient3 = rewrittenGradient3;\n                    return new data.SQFillRuleExpr(rewrittenInput, rewrittenRule);\n                }\n                return orig;\n            };\n            SQExprRewriter.prototype.visitLinearGradient2 = function (origGradient2) {\n                debug.assertValue(origGradient2, 'origGradient2');\n                var origMin = origGradient2.min, rewrittenMin = this.visitFillRuleStop(origMin), origMax = origGradient2.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient2;\n            };\n            SQExprRewriter.prototype.visitLinearGradient3 = function (origGradient3) {\n                debug.assertValue(origGradient3, 'origGradient3');\n                var origMin = origGradient3.min, rewrittenMin = this.visitFillRuleStop(origMin), origMid = origGradient3.mid, rewrittenMid = this.visitFillRuleStop(origMid), origMax = origGradient3.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        mid: rewrittenMid,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient3;\n            };\n            SQExprRewriter.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                var origColor = stop.color, rewrittenColor = stop.color.accept(this);\n                var origValue = stop.value, rewrittenValue = origValue;\n                if (origValue)\n                    rewrittenValue = origValue.accept(this);\n                if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\n                    var rewrittenStop = {\n                        color: rewrittenColor\n                    };\n                    if (rewrittenValue)\n                        rewrittenStop.value = rewrittenValue;\n                    return rewrittenStop;\n                }\n                return stop;\n            };\n            SQExprRewriter.prototype.visitResourcePackageItem = function (orig) {\n                return orig;\n            };\n            return SQExprRewriter;\n        }());\n        data.SQExprRewriter = SQExprRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for writing equality comparisons against a field to an SQInExpr. */\n        var EqualsToInRewriter;\n        (function (EqualsToInRewriter) {\n            function run(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(new Rewriter());\n            }\n            EqualsToInRewriter.run = run;\n            var Rewriter = (function (_super) {\n                __extends(Rewriter, _super);\n                function Rewriter() {\n                    _super.call(this);\n                }\n                Rewriter.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return this.visitUnsupported(expr);\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var leftIsComparand = this.isComparand(expr.left);\n                    var rightIsComparand = this.isComparand(expr.right);\n                    if (leftIsComparand === rightIsComparand)\n                        return this.visitUnsupported(expr);\n                    var operand = leftIsComparand\n                        ? expr.left\n                        : expr.right;\n                    var value = leftIsComparand\n                        ? expr.right\n                        : expr.left;\n                    var current = this.current;\n                    if (!current) {\n                        return data.SQExprBuilder.inExpr([operand], [[value]]);\n                    }\n                    current.add(operand, value);\n                    return expr;\n                };\n                Rewriter.prototype.visitOr = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current;\n                    if (!this.current) {\n                        current = this.current = new InBuilder();\n                    }\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                    if (current) {\n                        this.current = null;\n                        return current.complete() || expr;\n                    }\n                    return expr;\n                };\n                Rewriter.prototype.visitAnd = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current = this.current;\n                    if (current) {\n                        // NOTE: Composite keys are not supported by this algorithm.\n                        current.cancel();\n                        return expr;\n                    }\n                    return _super.prototype.visitAnd.call(this, expr);\n                };\n                Rewriter.prototype.visitUnsupported = function (expr) {\n                    var current = this.current;\n                    if (current)\n                        current.cancel();\n                    return expr;\n                };\n                Rewriter.prototype.isSupported = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return expr instanceof data.SQCompareExpr\n                        || expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQConstantExpr\n                        || expr instanceof data.SQHierarchyLevelExpr\n                        || expr instanceof data.SQOrExpr\n                        || expr instanceof data.SQAndExpr;\n                };\n                Rewriter.prototype.isComparand = function (expr) {\n                    return expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQHierarchyLevelExpr;\n                };\n                return Rewriter;\n            }(data.SQExprRewriter));\n            var InBuilder = (function () {\n                function InBuilder() {\n                }\n                InBuilder.prototype.add = function (operand, value) {\n                    debug.assertValue(operand, 'operand');\n                    debug.assertValue(value, 'value');\n                    if (this.cancelled)\n                        return;\n                    if (this.operand && !data.SQExpr.equals(operand, this.operand)) {\n                        this.cancel();\n                        return;\n                    }\n                    this.operand = operand;\n                    var values = this.values;\n                    if (!values)\n                        values = this.values = [];\n                    values.push(value);\n                };\n                InBuilder.prototype.cancel = function () {\n                    this.cancelled = true;\n                };\n                InBuilder.prototype.complete = function () {\n                    if (this.cancelled || !this.operand)\n                        return;\n                    return data.SQExprBuilder.inExpr([this.operand], _.map(this.values, function (v) { return [v]; }));\n                };\n                return InBuilder;\n            }());\n        })(EqualsToInRewriter = data.EqualsToInRewriter || (data.EqualsToInRewriter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asScopeIdsContainer(filter, fieldSQExprs) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\n                var filterItems = filter.conditions();\n                debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\n                var filterItem = filterItems[0];\n                if (filterItem) {\n                    var visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\n                    if (filterItem.accept(visitor))\n                        return visitor.getResult();\n                }\n            }\n            SQExprConverter.asScopeIdsContainer = asScopeIdsContainer;\n            /** Gets a comparand value from the given DataViewScopeIdentity. */\n            function getFirstComparandValue(identity) {\n                debug.assertValue(identity, 'identity');\n                var comparandExpr = identity.expr.accept(new FindComparandVisitor());\n                if (comparandExpr)\n                    return comparandExpr.value;\n            }\n            SQExprConverter.getFirstComparandValue = getFirstComparandValue;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\n        var FilterScopeIdsCollectorVisitor = (function (_super) {\n            __extends(FilterScopeIdsCollectorVisitor, _super);\n            function FilterScopeIdsCollectorVisitor(fieldSQExprs) {\n                _super.call(this);\n                this.isRoot = true;\n                this.isNot = false;\n                this.keyExprsCount = null;\n                this.valueExprs = [];\n                // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\n                // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\n                // need to drop it in order to use JsonComparer.\n                this.fieldExprs = [];\n                for (var _i = 0, fieldSQExprs_1 = fieldSQExprs; _i < fieldSQExprs_1.length; _i++) {\n                    var field = fieldSQExprs_1[_i];\n                    this.fieldExprs.push(data.SQExprBuilder.removeEntityVariables(field));\n                }\n            }\n            FilterScopeIdsCollectorVisitor.prototype.getResult = function () {\n                debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');\n                var valueExprs = this.valueExprs, scopeIds = [];\n                var valueCount = this.keyExprsCount || 1;\n                for (var startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\n                    var values = valueExprs.slice(startIndex, endIndex);\n                    var scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\n                    if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, powerbi.DataViewScopeIdentity.equals))\n                        scopeIds.push(scopeId);\n                    startIndex += valueCount;\n                    endIndex += valueCount;\n                }\n                return {\n                    isNot: this.isNot,\n                    scopeIds: scopeIds,\n                };\n            };\n            FilterScopeIdsCollectorVisitor.getScopeIdentity = function (fieldExprs, valueExprs) {\n                debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\n                debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\n                var compoundSQExpr;\n                for (var i = 0, len = fieldExprs.length; i < len; i++) {\n                    var equalsExpr = data.SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\n                    if (!compoundSQExpr)\n                        compoundSQExpr = equalsExpr;\n                    else\n                        compoundSQExpr = data.SQExprBuilder.and(compoundSQExpr, equalsExpr);\n                }\n                return data.createDataViewScopeIdentity(compoundSQExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitOr = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitNot = function (expr) {\n                if (!this.isRoot)\n                    return this.unsupportedSQExpr();\n                this.isNot = true;\n                return expr.arg.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitConstant = function (expr) {\n                if (this.isRoot && expr.type.primitiveType === powerbi.PrimitiveType.Null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitCompare = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                if (expr.comparison !== data.QueryComparisonKind.Equal)\n                    return this.unsupportedSQExpr();\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitIn = function (expr) {\n                this.keyExprsCount = 0;\n                var result;\n                this.isRoot = false;\n                for (var _i = 0, _a = expr.args; _i < _a.length; _i++) {\n                    var arg = _a[_i];\n                    result = arg.accept(this);\n                    if (!result)\n                        return this.unsupportedSQExpr();\n                    this.keyExprsCount++;\n                }\n                if (this.keyExprsCount !== this.fieldExprs.length)\n                    return this.unsupportedSQExpr();\n                var values = expr.values;\n                for (var _b = 0, values_1 = values; _b < values_1.length; _b++) {\n                    var valueTuple = values_1[_b];\n                    var jlen = valueTuple.length;\n                    debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\n                    for (var _c = 0, valueTuple_1 = valueTuple; _c < valueTuple_1.length; _c++) {\n                        var value = valueTuple_1[_c];\n                        result = value.accept(this);\n                        if (!result)\n                            return this.unsupportedSQExpr();\n                    }\n                }\n                return result;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitColumnRef = function (expr) {\n                if (this.isRoot)\n                    return this.unsupportedSQExpr();\n                var fixedExpr = data.SQExprBuilder.removeEntityVariables(expr);\n                if (this.keyExprsCount !== null)\n                    return data.SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\n                return data.SQExpr.equals(this.fieldExprs[0], fixedExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefaultValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitAnyValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefault = function (expr) {\n                return this.unsupportedSQExpr();\n            };\n            FilterScopeIdsCollectorVisitor.prototype.unsupportedSQExpr = function () {\n                return false;\n            };\n            return FilterScopeIdsCollectorVisitor;\n        }(data.DefaultSQExprVisitor));\n        var FindComparandVisitor = (function (_super) {\n            __extends(FindComparandVisitor, _super);\n            function FindComparandVisitor() {\n                _super.apply(this, arguments);\n            }\n            FindComparandVisitor.prototype.visitAnd = function (expr) {\n                return expr.left.accept(this) || expr.right.accept(this);\n            };\n            FindComparandVisitor.prototype.visitCompare = function (expr) {\n                if (expr.comparison === data.QueryComparisonKind.Equal) {\n                    if (expr.right instanceof data.SQConstantExpr)\n                        return expr.right;\n                    if (expr.left instanceof data.SQConstantExpr)\n                        return expr.left;\n                }\n            };\n            return FindComparandVisitor;\n        }(data.DefaultSQExprVisitor));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\n        var ScopeIdentityExtractor;\n        (function (ScopeIdentityExtractor) {\n            function getKeys(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return null;\n                return ArrayExtensions.emptyToNull(extractor.keys);\n            }\n            ScopeIdentityExtractor.getKeys = getKeys;\n            function getInExpr(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return;\n                var keys = ArrayExtensions.emptyToNull(extractor.keys);\n                var keyValues = ArrayExtensions.emptyToNull(extractor.values);\n                if (keys && keyValues)\n                    return data.SQExprBuilder.inExpr(keys, [keyValues]);\n            }\n            ScopeIdentityExtractor.getInExpr = getInExpr;\n            /**\n             * Recognizes expressions of the form:\n             * 1) Equals(ColRef, Constant)\n             * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\n             * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\n             */\n            var ScopeIdExtractorImpl = (function (_super) {\n                __extends(ScopeIdExtractorImpl, _super);\n                function ScopeIdExtractorImpl() {\n                    _super.apply(this, arguments);\n                    this.keys = [];\n                    this.values = [];\n                }\n                ScopeIdExtractorImpl.prototype.visitAnd = function (expr) {\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal) {\n                        this.visitDefault(expr);\n                        return;\n                    }\n                    debug.assert(expr.left instanceof data.SQExpr && expr.right instanceof data.SQConstantExpr, 'invalid compare expr operands');\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitColumnRef = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitHierarchyLevel = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitConstant = function (expr) {\n                    this.values.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitArithmetic = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitDefault = function (expr) {\n                    this.malformed = true;\n                };\n                return ScopeIdExtractorImpl;\n            }(data.DefaultSQExprVisitor));\n        })(ScopeIdentityExtractor = data.ScopeIdentityExtractor || (data.ScopeIdentityExtractor = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var PrimitiveValueEncoding;\n        (function (PrimitiveValueEncoding) {\n            var SingleQuoteRegex = /'/g;\n            function decimal(value) {\n                debug.assertValue(value, 'value');\n                return value + 'M';\n            }\n            PrimitiveValueEncoding.decimal = decimal;\n            function double(value) {\n                debug.assertValue(value, 'value');\n                return value + 'D';\n            }\n            PrimitiveValueEncoding.double = double;\n            function integer(value) {\n                debug.assertValue(value, 'value');\n                return value + 'L';\n            }\n            PrimitiveValueEncoding.integer = integer;\n            function dateTime(value) {\n                debug.assertValue(value, 'value');\n                // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\n                // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\n                // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\n                var date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\n                var dateTimeString = date.toISOString();\n                // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\n                // we will drop it.\n                // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\n                if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\n                    dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\n                return \"datetime'\" + dateTimeString + \"'\";\n            }\n            PrimitiveValueEncoding.dateTime = dateTime;\n            function text(value) {\n                debug.assertValue(value, 'value');\n                return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\n            }\n            PrimitiveValueEncoding.text = text;\n            function nullEncoding() {\n                return 'null';\n            }\n            PrimitiveValueEncoding.nullEncoding = nullEncoding;\n            function boolean(value) {\n                return value ? 'true' : 'false';\n            }\n            PrimitiveValueEncoding.boolean = boolean;\n        })(PrimitiveValueEncoding = data.PrimitiveValueEncoding || (data.PrimitiveValueEncoding = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Agg = powerbi.data.QueryAggregateFunction;\n        function createSQAggregationOperations(datetimeMinMaxSupported) {\n            return new SQAggregationOperations(datetimeMinMaxSupported);\n        }\n        data.createSQAggregationOperations = createSQAggregationOperations;\n        var SQAggregationOperations = (function () {\n            function SQAggregationOperations(datetimeMinMaxSupported) {\n                this.datetimeMinMaxSupported = datetimeMinMaxSupported;\n            }\n            SQAggregationOperations.prototype.getSupportedAggregates = function (expr, schema, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                debug.assertAnyValue(targetTypes, 'targetTypes');\n                var metadata = getMetadataForUnderlyingType(expr, schema);\n                // don't use expr.validate as validate will be using this function and we end up in a recursive loop\n                if (!metadata)\n                    return [];\n                var valueType = metadata.type, fieldKind = metadata.kind, isPropertyIdentity = metadata.idOnEntityKey;\n                if (!valueType)\n                    return [];\n                // Cannot aggregate on model measures\n                if (fieldKind === 1 /* Measure */)\n                    return [];\n                if (valueType.numeric || valueType.integer) {\n                    var aggregates_1 = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var currentSchema = schema.schema(fieldExprItem.schema);\n                    if (currentSchema.capabilities.supportsMedian)\n                        aggregates_1.push(Agg.Median);\n                    return aggregates_1;\n                }\n                var aggregates = [];\n                // Min/Max of DateTime\n                if (this.datetimeMinMaxSupported &&\n                    valueType.dateTime &&\n                    (_.isEmpty(targetTypes) || powerbi.ValueType.isCompatibleTo(valueType, targetTypes))) {\n                    aggregates.push(Agg.Min);\n                    aggregates.push(Agg.Max);\n                }\n                // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\n                // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\n                var distinctCountAggExists = data.SQExprInfo.getAggregate(expr) === Agg.Count;\n                if (!(isPropertyIdentity && !distinctCountAggExists))\n                    aggregates.push(Agg.Count);\n                aggregates.push(Agg.CountNonNull);\n                return aggregates;\n            };\n            SQAggregationOperations.prototype.isSupportedAggregate = function (expr, schema, aggregate, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\n                return _.contains(supportedAggregates, aggregate);\n            };\n            SQAggregationOperations.prototype.createExprWithAggregate = function (expr, schema, aggregateNonNumericFields, targetTypes, preferredAggregate) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var aggregate;\n                if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\n                    aggregate = preferredAggregate;\n                }\n                else {\n                    aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\n                }\n                if (aggregate !== undefined)\n                    expr = data.SQExprBuilder.aggregate(expr, aggregate);\n                return expr;\n            };\n            return SQAggregationOperations;\n        }());\n        function getMetadataForUnderlyingType(expr, schema) {\n            // Unwrap the aggregate (if the expr has one), and look at the underlying type.\n            var metadata = data.SQExprBuilder.removeAggregate(expr).getMetadata(schema);\n            if (!metadata)\n                metadata = expr.getMetadata(schema);\n            return metadata;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQHierarchyExprUtils;\n        (function (SQHierarchyExprUtils) {\n            function getConceptualHierarchyLevelFromExpr(conceptualSchema, fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                var hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\n                if (hierarchyLevel)\n                    return SQHierarchyExprUtils.getConceptualHierarchyLevel(conceptualSchema, fieldExprItem.schema, fieldExprItem.entity, hierarchyLevel.name, hierarchyLevel.level);\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr = getConceptualHierarchyLevelFromExpr;\n            function getConceptualHierarchyLevel(conceptualSchema, schemaName, entity, hierarchy, hierarchyLevel) {\n                var schema = conceptualSchema.schema(schemaName);\n                var conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\n                if (conceptualHierarchy) {\n                    return conceptualHierarchy.levels.withName(hierarchyLevel);\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevel = getConceptualHierarchyLevel;\n            function getConceptualHierarchy(sqExpr, federatedSchema) {\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchy = sqExpr;\n                    if (sqExpr.arg instanceof data.SQEntityExpr) {\n                        var entityExpr = sqExpr.arg;\n                        return federatedSchema\n                            .schema(entityExpr.schema)\n                            .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\n                    }\n                    else if (sqExpr.arg instanceof data.SQPropertyVariationSourceExpr) {\n                        var variationExpr = sqExpr.arg;\n                        var sourceEntityExpr = variationExpr.arg;\n                        return federatedSchema\n                            .schema(sourceEntityExpr.schema)\n                            .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\n                    }\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchy = getConceptualHierarchy;\n            function expandExpr(schema, expr, suppressHierarchyLevelExpansion) {\n                return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\n                    SQExprVariationConverter.expand(expr, schema) ||\n                    // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\n                    (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\n                    expr;\n            }\n            SQHierarchyExprUtils.expandExpr = expandExpr;\n            function isHierarchyOrVariation(schema, expr) {\n                if (expr instanceof data.SQHierarchyExpr || expr instanceof data.SQHierarchyLevelExpr)\n                    return true;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0)\n                        return true;\n                }\n                return false;\n            }\n            SQHierarchyExprUtils.isHierarchyOrVariation = isHierarchyOrVariation;\n            // Return column reference expression for hierarchy level expression.\n            function getSourceVariationExpr(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                if (fieldExprPattern.columnHierarchyLevelVariation) {\n                    var entity = data.SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\n                    return data.SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceVariationExpr = getSourceVariationExpr;\n            // Return hierarchy expression for hierarchy level expression.\n            function getSourceHierarchy(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                var hierarchyLevel = fieldExprPattern.hierarchyLevel;\n                if (hierarchyLevel) {\n                    var entity = data.SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\n                    return data.SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceHierarchy = getSourceHierarchy;\n            function getHierarchySourceAsVariationSource(hierarchyLevelExpr) {\n                // Make sure the hierarchy level source is a hierarchy\n                if (!(hierarchyLevelExpr.arg instanceof data.SQHierarchyExpr))\n                    return;\n                // Check if the hierarchy source if a variation\n                var hierarchyRef = hierarchyLevelExpr.arg;\n                if (hierarchyRef.arg instanceof data.SQPropertyVariationSourceExpr)\n                    return hierarchyRef.arg;\n            }\n            SQHierarchyExprUtils.getHierarchySourceAsVariationSource = getHierarchySourceAsVariationSource;\n            /**\n            * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\n            */\n            function areHierarchyLevelsOrdered(allLevels, firstExpr, secondExpr) {\n                // Validate that both items hierarchy levels\n                if (!(firstExpr instanceof data.SQHierarchyLevelExpr) || !(secondExpr instanceof data.SQHierarchyLevelExpr))\n                    return false;\n                var firstLevel = firstExpr;\n                var secondLevel = secondExpr;\n                // Validate that both items belong to the same hierarchy\n                if (!data.SQExpr.equals(firstLevel.arg, secondLevel.arg))\n                    return false;\n                // Determine the order\n                var firstIndex = data.SQExprUtils.indexOfExpr(allLevels, firstLevel);\n                var secondIndex = data.SQExprUtils.indexOfExpr(allLevels, secondLevel);\n                return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\n            }\n            SQHierarchyExprUtils.areHierarchyLevelsOrdered = areHierarchyLevelsOrdered;\n            /**\n             * Given an ordered set of levels and an ordered subset of those levels, returns the index where\n             * expr should be inserted into the subset to maintain the correct order.\n             */\n            function getInsertionIndex(allLevels, orderedSubsetOfLevels, expr) {\n                var insertIndex = 0;\n                // Loop through the supplied levels until the insertion would no longer be in the correct order\n                while (insertIndex < orderedSubsetOfLevels.length &&\n                    areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\n                    insertIndex++;\n                }\n                return insertIndex;\n            }\n            SQHierarchyExprUtils.getInsertionIndex = getInsertionIndex;\n        })(SQHierarchyExprUtils = data.SQHierarchyExprUtils || (data.SQHierarchyExprUtils = {}));\n        var SQExprHierarchyToHierarchyLevelConverter;\n        (function (SQExprHierarchyToHierarchyLevelConverter) {\n            function convert(sqExpr, federatedSchema) {\n                debug.assertValue(sqExpr, 'sqExpr');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchyExpr = sqExpr;\n                    var conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\n                    if (conceptualHierarchy)\n                        return _.map(conceptualHierarchy.levels, function (hierarchyLevel) { return data.SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name); });\n                }\n            }\n            SQExprHierarchyToHierarchyLevelConverter.convert = convert;\n        })(SQExprHierarchyToHierarchyLevelConverter = data.SQExprHierarchyToHierarchyLevelConverter || (data.SQExprHierarchyToHierarchyLevelConverter = {}));\n        var SQExprHierarchyLevelConverter;\n        (function (SQExprHierarchyLevelConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs = [];\n                if (expr instanceof data.SQHierarchyLevelExpr) {\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    if (fieldExpr.hierarchyLevel) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        var hierarchy = schema\n                            .schema(fieldExprItem.schema)\n                            .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\n                        if (hierarchy) {\n                            var hierarchyLevels = hierarchy.levels;\n                            for (var _i = 0, hierarchyLevels_2 = hierarchyLevels; _i < hierarchyLevels_2.length; _i++) {\n                                var hierarchyLevel = hierarchyLevels_2[_i];\n                                if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\n                                    exprs.push(expr);\n                                    break;\n                                }\n                                else\n                                    exprs.push(data.SQExprBuilder.hierarchyLevel(data.SQExprBuilder.hierarchy(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), hierarchy.name), hierarchyLevel.name));\n                            }\n                        }\n                    }\n                }\n                if (!_.isEmpty(exprs))\n                    return exprs;\n            }\n            SQExprHierarchyLevelConverter.expand = expand;\n        })(SQExprHierarchyLevelConverter || (SQExprHierarchyLevelConverter = {}));\n        var SQExprVariationConverter;\n        (function (SQExprVariationConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0) {\n                        var variations = column.variations;\n                        // for SU11, we support only one variation\n                        debug.assert(variations.length === 1, \"variations.length\");\n                        var variation = variations[0];\n                        var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        exprs = [];\n                        if (variation.defaultHierarchy) {\n                            var hierarchyExpr = data.SQExprBuilder.hierarchy(data.SQExprBuilder.propertyVariationSource(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), variation.name, conceptualProperty.name), variation.defaultHierarchy.name);\n                            for (var _i = 0, _a = variation.defaultHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                exprs.push(data.SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\n                            }\n                        }\n                    }\n                }\n                return exprs;\n            }\n            SQExprVariationConverter.expand = expand;\n        })(SQExprVariationConverter || (SQExprVariationConverter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        ;\n        var SQExprGroupUtils;\n        (function (SQExprGroupUtils) {\n            /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\n            function groupExprs(schema, exprs) {\n                var groups = [];\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i];\n                    debug.assertValue(expr, \"Expression not found\");\n                    if (!(expr instanceof data.SQHierarchyLevelExpr)) {\n                        groups.push({ expr: expr, children: null, selectQueryIndex: i });\n                    }\n                    else {\n                        addChildToGroup(schema, groups, expr, i);\n                    }\n                }\n                return groups;\n            }\n            SQExprGroupUtils.groupExprs = groupExprs;\n            function addChildToGroup(schema, groups, expr, selectQueryIndex) {\n                // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \n                // a new Group or to the last Group\n                var shouldAddExpressionToNewGroup = true;\n                var exprSource = data.SQHierarchyExprUtils.getSourceVariationExpr(expr) || data.SQHierarchyExprUtils.getSourceHierarchy(expr);\n                var lastGroup = _.last(groups);\n                // The relevant group is always the last added. If it has the same source hierarchy,\n                // and is properly ordered within that hierarchy, we will need to add to this group.\n                if (lastGroup && lastGroup.children && data.SQExpr.equals(lastGroup.expr, exprSource)) {\n                    var expandedExpr = data.SQHierarchyExprUtils.expandExpr(schema, expr.arg);\n                    if (expandedExpr instanceof Array) {\n                        var allHierarchyLevels = expandedExpr;\n                        shouldAddExpressionToNewGroup = !data.SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\n                    }\n                }\n                if (shouldAddExpressionToNewGroup)\n                    // Use the Sourcevariation as the expression for the group.\n                    groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\n                else {\n                    debug.assertValue(lastGroup, 'There should be a group to add the variation to');\n                    debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\n                    lastGroup.children.push(expr);\n                }\n            }\n        })(SQExprGroupUtils = data.SQExprGroupUtils || (data.SQExprGroupUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var StringExtensions = jsCommon.StringExtensions;\n        /** Represents an immutable expression within a SemanticQuery. */\n        var SQExpr = (function () {\n            function SQExpr(kind) {\n                debug.assertValue(kind, 'kind');\n                this._kind = kind;\n            }\n            SQExpr.equals = function (x, y, ignoreCase) {\n                return SQExprEqualityVisitor.run(x, y, ignoreCase);\n            };\n            SQExpr.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.accept(validator);\n                return validator.errors;\n            };\n            SQExpr.prototype.accept = function (visitor, arg) {\n                debug.assertFail('abstract method');\n                return;\n            };\n            Object.defineProperty(SQExpr.prototype, \"kind\", {\n                get: function () {\n                    return this._kind;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            SQExpr.isColumn = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 1 /* ColumnRef */;\n            };\n            SQExpr.isConstant = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 16 /* Constant */;\n            };\n            SQExpr.isEntity = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 0 /* Entity */;\n            };\n            SQExpr.isHierarchy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 5 /* Hierarchy */;\n            };\n            SQExpr.isHierarchyLevel = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 6 /* HierarchyLevel */;\n            };\n            SQExpr.isAggregation = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 3 /* Aggregation */;\n            };\n            SQExpr.isMeasure = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 2 /* MeasureRef */;\n            };\n            SQExpr.isResourcePackageItem = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 24 /* ResourcePackageItem */;\n            };\n            SQExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                if (field.column || field.columnAggr || field.measure)\n                    return this.getMetadataForProperty(field, federatedSchema);\n                if (field.hierarchyLevel || field.hierarchyLevelAggr)\n                    return this.getMetadataForHierarchyLevel(field, federatedSchema);\n                if (field.columnHierarchyLevelVariation)\n                    return this.getMetadataForVariation(field, federatedSchema);\n                return SQExpr.getMetadataForEntity(field, federatedSchema);\n            };\n            SQExpr.prototype.getDefaultAggregate = function (federatedSchema, forceAggregation) {\n                if (forceAggregation === void 0) { forceAggregation = false; }\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                var aggregate;\n                if (property && property.kind === 0 /* Column */) {\n                    var propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\n                    if ((property.type.integer || property.type.numeric) &&\n                        propertyDefaultAggregate !== 1 /* None */) {\n                        aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\n                        if (aggregate === undefined)\n                            aggregate = defaultAggregateForDataType(property.type);\n                    }\n                    // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \n                    // aggregate on CountNonNull.\n                    if (aggregate === undefined && forceAggregation) {\n                        aggregate = data.QueryAggregateFunction.CountNonNull;\n                    }\n                }\n                return aggregate;\n            };\n            /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\n            SQExpr.prototype.getKeyColumns = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keySQExprs = [];\n                var keys = this.getPropertyKeys(schema);\n                if (keys && keys.length > 0) {\n                    for (var i = 0, len = keys.length; i < len; i++) {\n                        keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\n                    }\n                }\n                else\n                    keySQExprs.push(columnRefExpr);\n                return keySQExprs;\n            };\n            /** Returns a value indicating whether the expression would group on keys other than itself.*/\n            SQExpr.prototype.hasGroupOnKeys = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keys = this.getPropertyKeys(schema);\n                if (!keys || keys.length < 1)\n                    return false;\n                if (keys.length > 1)\n                    return true;\n                var keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\n                return !SQExpr.equals(keySqExpr, this);\n            };\n            SQExpr.prototype.getPropertyKeys = function (schema) {\n                var property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\n                if (!property)\n                    return;\n                return property.column ? property.column.keys : undefined;\n            };\n            SQExpr.prototype.getConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var propertyName = data.FieldExprPattern.getPropertyName(field);\n                if (propertyName)\n                    return federatedSchema\n                        .schema(fieldExprItem.schema)\n                        .findProperty(fieldExprItem.entity, propertyName);\n            };\n            SQExpr.prototype.getTargetEntityForVariation = function (federatedSchema, variationName) {\n                var property = this.getConceptualProperty(federatedSchema);\n                if (property && property.column && !_.isEmpty(property.column.variations)) {\n                    var variations = property.column.variations;\n                    for (var _i = 0, variations_2 = variations; _i < variations_2.length; _i++) {\n                        var variation = variations_2[_i];\n                        if (variation.name === variationName)\n                            return variation.navigationProperty.targetEntity.name;\n                    }\n                }\n            };\n            SQExpr.prototype.getTargetEntity = function (federatedSchema) {\n                return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\n            };\n            SQExpr.prototype.getHierarchyLevelConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\n                if (fieldExprHierachyLevel) {\n                    var fieldExprEntity = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                    var hierarchy = federatedSchema\n                        .schema(fieldExprEntity.schema)\n                        .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\n                    if (hierarchy) {\n                        var hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\n                        if (hierarchyLevel)\n                            return hierarchyLevel.column;\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForVariation = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var sourceProperty = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\n                if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\n                    for (var _i = 0, _a = sourceProperty.column.variations; _i < _a.length; _i++) {\n                        var variation = _a[_i];\n                        if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\n                            for (var _b = 0, _c = variation.defaultHierarchy.levels; _b < _c.length; _b++) {\n                                var level = _c[_b];\n                                if (level.name === columnHierarchyLevelVariation.level.level) {\n                                    var property = level.column;\n                                    return {\n                                        kind: (property.kind === 1 /* Measure */) ? 1 /* Measure */ : 0 /* Column */,\n                                        type: property.type,\n                                        format: property.format,\n                                        idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                                        defaultAggregate: property.column ? property.column.defaultAggregate : null\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForHierarchyLevel = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.prototype.getPropertyMetadata = function (field, property) {\n                var format = property.format;\n                var type = property.type;\n                var columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\n                if (columnAggregate) {\n                    switch (columnAggregate.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer);\n                            format = undefined;\n                            break;\n                        case data.QueryAggregateFunction.Avg:\n                            if (type.integer)\n                                type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double);\n                            break;\n                    }\n                }\n                return {\n                    kind: (property.kind === 1 /* Measure */ || (columnAggregate && columnAggregate.aggregate !== undefined)) ? 1 /* Measure */ : 0 /* Column */,\n                    type: type,\n                    format: format,\n                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                    aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\n                    defaultAggregate: property.column ? property.column.defaultAggregate : null\n                };\n            };\n            SQExpr.prototype.getMetadataForProperty = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.getMetadataForEntity = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var entity = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .entities\n                    .withName(fieldExprItem.entity);\n                if (!entity)\n                    return;\n                // We only support count and countnonnull for entity.\n                if (field.entityAggr) {\n                    switch (field.entityAggr.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            return {\n                                kind: 1 /* Measure */,\n                                type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer),\n                                format: undefined,\n                                idOnEntityKey: false,\n                                aggregate: field.entityAggr.aggregate\n                            };\n                    }\n                }\n            };\n            return SQExpr;\n        }());\n        data.SQExpr = SQExpr;\n        /** Note: Exported for testability */\n        function defaultAggregateForDataType(type) {\n            if (type.integer || type.numeric)\n                return data.QueryAggregateFunction.Sum;\n            return data.QueryAggregateFunction.Count;\n        }\n        data.defaultAggregateForDataType = defaultAggregateForDataType;\n        /** Note: Exported for testability */\n        function defaultAggregateToQueryAggregateFunction(aggregate) {\n            switch (aggregate) {\n                case 6 /* Average */:\n                    return data.QueryAggregateFunction.Avg;\n                case 3 /* Count */:\n                    return data.QueryAggregateFunction.CountNonNull;\n                case 7 /* DistinctCount */:\n                    return data.QueryAggregateFunction.Count;\n                case 5 /* Max */:\n                    return data.QueryAggregateFunction.Max;\n                case 4 /* Min */:\n                    return data.QueryAggregateFunction.Min;\n                case 2 /* Sum */:\n                    return data.QueryAggregateFunction.Sum;\n                default:\n                    return;\n            }\n        }\n        data.defaultAggregateToQueryAggregateFunction = defaultAggregateToQueryAggregateFunction;\n        var SQEntityExpr = (function (_super) {\n            __extends(SQEntityExpr, _super);\n            function SQEntityExpr(schema, entity, variable) {\n                debug.assertValue(entity, 'entity');\n                _super.call(this, 0 /* Entity */);\n                this.schema = schema;\n                this.entity = entity;\n                if (variable)\n                    this.variable = variable;\n            }\n            SQEntityExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitEntity(this, arg);\n            };\n            return SQEntityExpr;\n        }(SQExpr));\n        data.SQEntityExpr = SQEntityExpr;\n        var SQArithmeticExpr = (function (_super) {\n            __extends(SQArithmeticExpr, _super);\n            function SQArithmeticExpr(left, right, operator) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                debug.assertValue(operator, 'operator');\n                _super.call(this, 22 /* Arithmetic */);\n                this.left = left;\n                this.right = right;\n                this.operator = operator;\n            }\n            SQArithmeticExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitArithmetic(this, arg);\n            };\n            return SQArithmeticExpr;\n        }(SQExpr));\n        data.SQArithmeticExpr = SQArithmeticExpr;\n        var SQScopedEvalExpr = (function (_super) {\n            __extends(SQScopedEvalExpr, _super);\n            function SQScopedEvalExpr(expression, scope) {\n                debug.assertValue(expression, 'expression');\n                debug.assertValue(scope, 'scope');\n                _super.call(this, 25 /* ScopedEval */);\n                this.expression = expression;\n                this.scope = scope;\n            }\n            SQScopedEvalExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitScopedEval(this, arg);\n            };\n            return SQScopedEvalExpr;\n        }(SQExpr));\n        data.SQScopedEvalExpr = SQScopedEvalExpr;\n        var SQPropRefExpr = (function (_super) {\n            __extends(SQPropRefExpr, _super);\n            function SQPropRefExpr(kind, source, ref) {\n                debug.assertValue(kind, 'kind');\n                debug.assertValue(source, 'source');\n                debug.assertValue(ref, 'ref');\n                _super.call(this, kind);\n                this.source = source;\n                this.ref = ref;\n            }\n            return SQPropRefExpr;\n        }(SQExpr));\n        data.SQPropRefExpr = SQPropRefExpr;\n        var SQColumnRefExpr = (function (_super) {\n            __extends(SQColumnRefExpr, _super);\n            function SQColumnRefExpr(source, ref) {\n                _super.call(this, 1 /* ColumnRef */, source, ref);\n            }\n            SQColumnRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitColumnRef(this, arg);\n            };\n            return SQColumnRefExpr;\n        }(SQPropRefExpr));\n        data.SQColumnRefExpr = SQColumnRefExpr;\n        var SQMeasureRefExpr = (function (_super) {\n            __extends(SQMeasureRefExpr, _super);\n            function SQMeasureRefExpr(source, ref) {\n                _super.call(this, 2 /* MeasureRef */, source, ref);\n            }\n            SQMeasureRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitMeasureRef(this, arg);\n            };\n            return SQMeasureRefExpr;\n        }(SQPropRefExpr));\n        data.SQMeasureRefExpr = SQMeasureRefExpr;\n        var SQAggregationExpr = (function (_super) {\n            __extends(SQAggregationExpr, _super);\n            function SQAggregationExpr(arg, func) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(func, 'func');\n                _super.call(this, 3 /* Aggregation */);\n                this.arg = arg;\n                this.func = func;\n            }\n            SQAggregationExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAggr(this, arg);\n            };\n            return SQAggregationExpr;\n        }(SQExpr));\n        data.SQAggregationExpr = SQAggregationExpr;\n        var SQPropertyVariationSourceExpr = (function (_super) {\n            __extends(SQPropertyVariationSourceExpr, _super);\n            function SQPropertyVariationSourceExpr(arg, name, property) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(name, 'name');\n                debug.assertValue(property, 'property');\n                _super.call(this, 4 /* PropertyVariationSource */);\n                this.arg = arg;\n                this.name = name;\n                this.property = property;\n            }\n            SQPropertyVariationSourceExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPropertyVariationSource(this, arg);\n            };\n            return SQPropertyVariationSourceExpr;\n        }(SQExpr));\n        data.SQPropertyVariationSourceExpr = SQPropertyVariationSourceExpr;\n        var SQHierarchyExpr = (function (_super) {\n            __extends(SQHierarchyExpr, _super);\n            function SQHierarchyExpr(arg, hierarchy) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(hierarchy, 'hierarchy');\n                _super.call(this, 5 /* Hierarchy */);\n                this.arg = arg;\n                this.hierarchy = hierarchy;\n            }\n            SQHierarchyExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchy(this, arg);\n            };\n            return SQHierarchyExpr;\n        }(SQExpr));\n        data.SQHierarchyExpr = SQHierarchyExpr;\n        var SQHierarchyLevelExpr = (function (_super) {\n            __extends(SQHierarchyLevelExpr, _super);\n            function SQHierarchyLevelExpr(arg, level) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(level, 'level');\n                _super.call(this, 6 /* HierarchyLevel */);\n                this.arg = arg;\n                this.level = level;\n            }\n            SQHierarchyLevelExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchyLevel(this, arg);\n            };\n            return SQHierarchyLevelExpr;\n        }(SQExpr));\n        data.SQHierarchyLevelExpr = SQHierarchyLevelExpr;\n        var SQAndExpr = (function (_super) {\n            __extends(SQAndExpr, _super);\n            function SQAndExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 7 /* And */);\n                this.left = left;\n                this.right = right;\n            }\n            SQAndExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnd(this, arg);\n            };\n            return SQAndExpr;\n        }(SQExpr));\n        data.SQAndExpr = SQAndExpr;\n        var SQBetweenExpr = (function (_super) {\n            __extends(SQBetweenExpr, _super);\n            function SQBetweenExpr(arg, lower, upper) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(lower, 'lower');\n                debug.assertValue(upper, 'upper');\n                _super.call(this, 8 /* Between */);\n                this.arg = arg;\n                this.lower = lower;\n                this.upper = upper;\n            }\n            SQBetweenExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitBetween(this, arg);\n            };\n            return SQBetweenExpr;\n        }(SQExpr));\n        data.SQBetweenExpr = SQBetweenExpr;\n        var SQInExpr = (function (_super) {\n            __extends(SQInExpr, _super);\n            function SQInExpr(args, values) {\n                debug.assertValue(args, 'args');\n                debug.assertValue(values, 'values');\n                _super.call(this, 9 /* In */);\n                this.args = args;\n                this.values = values;\n            }\n            SQInExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitIn(this, arg);\n            };\n            return SQInExpr;\n        }(SQExpr));\n        data.SQInExpr = SQInExpr;\n        var SQOrExpr = (function (_super) {\n            __extends(SQOrExpr, _super);\n            function SQOrExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 10 /* Or */);\n                this.left = left;\n                this.right = right;\n            }\n            SQOrExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitOr(this, arg);\n            };\n            return SQOrExpr;\n        }(SQExpr));\n        data.SQOrExpr = SQOrExpr;\n        var SQCompareExpr = (function (_super) {\n            __extends(SQCompareExpr, _super);\n            function SQCompareExpr(comparison, left, right) {\n                debug.assertValue(comparison, 'kind');\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 12 /* Compare */);\n                this.comparison = comparison;\n                this.left = left;\n                this.right = right;\n            }\n            SQCompareExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitCompare(this, arg);\n            };\n            return SQCompareExpr;\n        }(SQExpr));\n        data.SQCompareExpr = SQCompareExpr;\n        var SQContainsExpr = (function (_super) {\n            __extends(SQContainsExpr, _super);\n            function SQContainsExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 11 /* Contains */);\n                this.left = left;\n                this.right = right;\n            }\n            SQContainsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitContains(this, arg);\n            };\n            return SQContainsExpr;\n        }(SQExpr));\n        data.SQContainsExpr = SQContainsExpr;\n        var SQStartsWithExpr = (function (_super) {\n            __extends(SQStartsWithExpr, _super);\n            function SQStartsWithExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 13 /* StartsWith */);\n                this.left = left;\n                this.right = right;\n            }\n            SQStartsWithExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitStartsWith(this, arg);\n            };\n            return SQStartsWithExpr;\n        }(SQExpr));\n        data.SQStartsWithExpr = SQStartsWithExpr;\n        var SQExistsExpr = (function (_super) {\n            __extends(SQExistsExpr, _super);\n            function SQExistsExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 14 /* Exists */);\n                this.arg = arg;\n            }\n            SQExistsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitExists(this, arg);\n            };\n            return SQExistsExpr;\n        }(SQExpr));\n        data.SQExistsExpr = SQExistsExpr;\n        var SQNotExpr = (function (_super) {\n            __extends(SQNotExpr, _super);\n            function SQNotExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 15 /* Not */);\n                this.arg = arg;\n            }\n            SQNotExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNot(this, arg);\n            };\n            return SQNotExpr;\n        }(SQExpr));\n        data.SQNotExpr = SQNotExpr;\n        var SQConstantExpr = (function (_super) {\n            __extends(SQConstantExpr, _super);\n            function SQConstantExpr(type, value, valueEncoded) {\n                debug.assertValue(type, 'type');\n                _super.call(this, 16 /* Constant */);\n                this.type = type;\n                this.value = value;\n                this.valueEncoded = valueEncoded;\n            }\n            SQConstantExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitConstant(this, arg);\n            };\n            SQConstantExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                return {\n                    // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\n                    // A getType or similiar function in the future would be more appropriate. \n                    kind: 1 /* Measure */,\n                    type: this.type,\n                };\n            };\n            return SQConstantExpr;\n        }(SQExpr));\n        data.SQConstantExpr = SQConstantExpr;\n        var SQDateSpanExpr = (function (_super) {\n            __extends(SQDateSpanExpr, _super);\n            function SQDateSpanExpr(unit, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 17 /* DateSpan */);\n                this.unit = unit;\n                this.arg = arg;\n            }\n            SQDateSpanExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateSpan(this, arg);\n            };\n            return SQDateSpanExpr;\n        }(SQExpr));\n        data.SQDateSpanExpr = SQDateSpanExpr;\n        var SQDateAddExpr = (function (_super) {\n            __extends(SQDateAddExpr, _super);\n            function SQDateAddExpr(unit, amount, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(amount, 'amount');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 18 /* DateAdd */);\n                this.unit = unit;\n                this.arg = arg;\n                this.amount = amount;\n            }\n            SQDateAddExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateAdd(this, arg);\n            };\n            return SQDateAddExpr;\n        }(SQExpr));\n        data.SQDateAddExpr = SQDateAddExpr;\n        var SQNowExpr = (function (_super) {\n            __extends(SQNowExpr, _super);\n            function SQNowExpr() {\n                _super.call(this, 19 /* Now */);\n            }\n            SQNowExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNow(this, arg);\n            };\n            return SQNowExpr;\n        }(SQExpr));\n        data.SQNowExpr = SQNowExpr;\n        var SQDefaultValueExpr = (function (_super) {\n            __extends(SQDefaultValueExpr, _super);\n            function SQDefaultValueExpr() {\n                _super.call(this, 21 /* DefaultValue */);\n            }\n            SQDefaultValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDefaultValue(this, arg);\n            };\n            return SQDefaultValueExpr;\n        }(SQExpr));\n        data.SQDefaultValueExpr = SQDefaultValueExpr;\n        var SQAnyValueExpr = (function (_super) {\n            __extends(SQAnyValueExpr, _super);\n            function SQAnyValueExpr() {\n                _super.call(this, 20 /* AnyValue */);\n            }\n            SQAnyValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnyValue(this, arg);\n            };\n            return SQAnyValueExpr;\n        }(SQExpr));\n        data.SQAnyValueExpr = SQAnyValueExpr;\n        var SQFillRuleExpr = (function (_super) {\n            __extends(SQFillRuleExpr, _super);\n            function SQFillRuleExpr(input, fillRule) {\n                debug.assertValue(input, 'input');\n                debug.assertValue(fillRule, 'fillRule');\n                _super.call(this, 23 /* FillRule */);\n                this.input = input;\n                this.rule = fillRule;\n            }\n            SQFillRuleExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitFillRule(this, arg);\n            };\n            return SQFillRuleExpr;\n        }(SQExpr));\n        data.SQFillRuleExpr = SQFillRuleExpr;\n        var SQResourcePackageItemExpr = (function (_super) {\n            __extends(SQResourcePackageItemExpr, _super);\n            function SQResourcePackageItemExpr(packageName, packageType, itemName) {\n                debug.assertValue(packageName, 'packageName');\n                debug.assertValue(itemName, 'itemName');\n                _super.call(this, 24 /* ResourcePackageItem */);\n                this.packageName = packageName;\n                this.packageType = packageType;\n                this.itemName = itemName;\n            }\n            SQResourcePackageItemExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitResourcePackageItem(this, arg);\n            };\n            return SQResourcePackageItemExpr;\n        }(SQExpr));\n        data.SQResourcePackageItemExpr = SQResourcePackageItemExpr;\n        /** Provides utilities for creating & manipulating expressions. */\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function entity(schema, entity, variable) {\n                return new SQEntityExpr(schema, entity, variable);\n            }\n            SQExprBuilder.entity = entity;\n            function columnRef(source, prop) {\n                return new SQColumnRefExpr(source, prop);\n            }\n            SQExprBuilder.columnRef = columnRef;\n            function measureRef(source, prop) {\n                return new SQMeasureRefExpr(source, prop);\n            }\n            SQExprBuilder.measureRef = measureRef;\n            function aggregate(source, aggregate) {\n                return new SQAggregationExpr(source, aggregate);\n            }\n            SQExprBuilder.aggregate = aggregate;\n            function hierarchy(source, hierarchy) {\n                return new SQHierarchyExpr(source, hierarchy);\n            }\n            SQExprBuilder.hierarchy = hierarchy;\n            function propertyVariationSource(source, name, property) {\n                return new SQPropertyVariationSourceExpr(source, name, property);\n            }\n            SQExprBuilder.propertyVariationSource = propertyVariationSource;\n            function hierarchyLevel(source, level) {\n                return new SQHierarchyLevelExpr(source, level);\n            }\n            SQExprBuilder.hierarchyLevel = hierarchyLevel;\n            function and(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                return new SQAndExpr(left, right);\n            }\n            SQExprBuilder.and = and;\n            function between(arg, lower, upper) {\n                return new SQBetweenExpr(arg, lower, upper);\n            }\n            SQExprBuilder.between = between;\n            function inExpr(args, values) {\n                return new SQInExpr(args, values);\n            }\n            SQExprBuilder.inExpr = inExpr;\n            function or(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                if (left instanceof SQInExpr && right instanceof SQInExpr) {\n                    var inExpr_1 = tryUseInExprs(left, right);\n                    if (inExpr_1)\n                        return inExpr_1;\n                }\n                return new SQOrExpr(left, right);\n            }\n            SQExprBuilder.or = or;\n            function tryUseInExprs(left, right) {\n                if (!left.args || !right.args)\n                    return;\n                var leftArgLen = left.args.length;\n                var rightArgLen = right.args.length;\n                if (leftArgLen !== rightArgLen)\n                    return;\n                for (var i = 0; i < leftArgLen; ++i) {\n                    if (!SQExpr.equals(left.args[i], right.args[i]))\n                        return;\n                }\n                var combinedValues = left.values.concat(right.values);\n                return SQExprBuilder.inExpr(left.args, combinedValues);\n            }\n            function compare(kind, left, right) {\n                return new SQCompareExpr(kind, left, right);\n            }\n            SQExprBuilder.compare = compare;\n            function contains(left, right) {\n                return new SQContainsExpr(left, right);\n            }\n            SQExprBuilder.contains = contains;\n            function exists(arg) {\n                return new SQExistsExpr(arg);\n            }\n            SQExprBuilder.exists = exists;\n            function equal(left, right) {\n                return compare(data.QueryComparisonKind.Equal, left, right);\n            }\n            SQExprBuilder.equal = equal;\n            function not(arg) {\n                return new SQNotExpr(arg);\n            }\n            SQExprBuilder.not = not;\n            function startsWith(left, right) {\n                return new SQStartsWithExpr(left, right);\n            }\n            SQExprBuilder.startsWith = startsWith;\n            function nullConstant() {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Null), null, data.PrimitiveValueEncoding.nullEncoding());\n            }\n            SQExprBuilder.nullConstant = nullConstant;\n            function now() {\n                return new SQNowExpr();\n            }\n            SQExprBuilder.now = now;\n            function defaultValue() {\n                return new SQDefaultValueExpr();\n            }\n            SQExprBuilder.defaultValue = defaultValue;\n            function anyValue() {\n                return new SQAnyValueExpr();\n            }\n            SQExprBuilder.anyValue = anyValue;\n            function boolean(value) {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Boolean), value, data.PrimitiveValueEncoding.boolean(value));\n            }\n            SQExprBuilder.boolean = boolean;\n            function dateAdd(unit, amount, arg) {\n                return new SQDateAddExpr(unit, amount, arg);\n            }\n            SQExprBuilder.dateAdd = dateAdd;\n            function dateTime(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.dateTime(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.DateTime), value, valueEncoded);\n            }\n            SQExprBuilder.dateTime = dateTime;\n            function dateSpan(unit, arg) {\n                return new SQDateSpanExpr(unit, arg);\n            }\n            SQExprBuilder.dateSpan = dateSpan;\n            function decimal(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.decimal(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Decimal), value, valueEncoded);\n            }\n            SQExprBuilder.decimal = decimal;\n            function double(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.double(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double), value, valueEncoded);\n            }\n            SQExprBuilder.double = double;\n            function integer(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.integer(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer), value, valueEncoded);\n            }\n            SQExprBuilder.integer = integer;\n            function text(value, valueEncoded) {\n                debug.assert(!valueEncoded || valueEncoded === data.PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Text), value, valueEncoded || data.PrimitiveValueEncoding.text(value));\n            }\n            SQExprBuilder.text = text;\n            /** Returns an SQExpr that evaluates to the constant value. */\n            function typedConstant(value, type) {\n                if (value == null)\n                    return nullConstant();\n                if (_.isBoolean(value)) {\n                    return boolean(value);\n                }\n                if (_.isString(value)) {\n                    return text(value);\n                }\n                if (_.isNumber(value)) {\n                    if (type.integer && powerbi.Double.isInteger(value))\n                        return integer(value);\n                    return double(value);\n                }\n                if (value instanceof Date) {\n                    return dateTime(value);\n                }\n            }\n            SQExprBuilder.typedConstant = typedConstant;\n            function arithmetic(left, right, operator) {\n                return new SQArithmeticExpr(left, right, operator);\n            }\n            SQExprBuilder.arithmetic = arithmetic;\n            function scopedEval(expression, scope) {\n                return new SQScopedEvalExpr(expression, scope);\n            }\n            SQExprBuilder.scopedEval = scopedEval;\n            function setAggregate(expr, aggregate) {\n                return SQExprChangeAggregateRewriter.rewrite(expr, aggregate);\n            }\n            SQExprBuilder.setAggregate = setAggregate;\n            function removeAggregate(expr) {\n                return SQExprRemoveAggregateRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeAggregate = removeAggregate;\n            function removeEntityVariables(expr) {\n                return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeEntityVariables = removeEntityVariables;\n            function fillRule(expr, rule) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(rule, 'rule');\n                return new SQFillRuleExpr(expr, rule);\n            }\n            SQExprBuilder.fillRule = fillRule;\n            function resourcePackageItem(packageName, packageType, itemName) {\n                return new SQResourcePackageItemExpr(packageName, packageType, itemName);\n            }\n            SQExprBuilder.resourcePackageItem = resourcePackageItem;\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        /** Provides utilities for obtaining information about expressions. */\n        var SQExprInfo;\n        (function (SQExprInfo) {\n            function getAggregate(expr) {\n                return SQExprAggregateInfoVisitor.getAggregate(expr);\n            }\n            SQExprInfo.getAggregate = getAggregate;\n        })(SQExprInfo = data.SQExprInfo || (data.SQExprInfo = {}));\n        var SQExprEqualityVisitor = (function () {\n            function SQExprEqualityVisitor(ignoreCase) {\n                this.ignoreCase = ignoreCase;\n            }\n            SQExprEqualityVisitor.run = function (x, y, ignoreCase) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (ignoreCase)\n                    return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\n                return x.accept(SQExprEqualityVisitor.instance, y);\n            };\n            SQExprEqualityVisitor.prototype.visitColumnRef = function (expr, comparand) {\n                return comparand instanceof SQColumnRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitMeasureRef = function (expr, comparand) {\n                return comparand instanceof SQMeasureRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitAggr = function (expr, comparand) {\n                return comparand instanceof SQAggregationExpr &&\n                    expr.func === comparand.func &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchy = function (expr, comparand) {\n                return comparand instanceof SQHierarchyExpr &&\n                    expr.hierarchy === comparand.hierarchy &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchyLevel = function (expr, comparand) {\n                return comparand instanceof SQHierarchyLevelExpr &&\n                    expr.level === comparand.level &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPropertyVariationSource = function (expr, comparand) {\n                return comparand instanceof SQPropertyVariationSourceExpr &&\n                    expr.name === comparand.name &&\n                    expr.property === comparand.property &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitBetween = function (expr, comparand) {\n                return comparand instanceof SQBetweenExpr &&\n                    this.equals(expr.arg, comparand.arg) &&\n                    this.equals(expr.lower, comparand.lower) &&\n                    this.equals(expr.upper, comparand.upper);\n            };\n            SQExprEqualityVisitor.prototype.visitIn = function (expr, comparand) {\n                if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, comparand.args))\n                    return false;\n                var values = expr.values, compareValues = comparand.values;\n                if (values.length !== compareValues.length)\n                    return false;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    if (!this.equalsAll(values[i], compareValues[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.visitEntity = function (expr, comparand) {\n                return comparand instanceof SQEntityExpr &&\n                    expr.schema === comparand.schema &&\n                    expr.entity === comparand.entity &&\n                    this.optionalEqual(expr.variable, comparand.variable);\n            };\n            SQExprEqualityVisitor.prototype.visitAnd = function (expr, comparand) {\n                return comparand instanceof SQAndExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitOr = function (expr, comparand) {\n                return comparand instanceof SQOrExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitCompare = function (expr, comparand) {\n                return comparand instanceof SQCompareExpr &&\n                    expr.comparison === comparand.comparison &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitContains = function (expr, comparand) {\n                return comparand instanceof SQContainsExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitDateSpan = function (expr, comparand) {\n                return comparand instanceof SQDateSpanExpr &&\n                    expr.unit === comparand.unit &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitDateAdd = function (expr, comparand) {\n                return comparand instanceof SQDateAddExpr &&\n                    expr.unit === comparand.unit &&\n                    expr.amount === comparand.amount &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitExists = function (expr, comparand) {\n                return comparand instanceof SQExistsExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNot = function (expr, comparand) {\n                return comparand instanceof SQNotExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNow = function (expr, comparand) {\n                return comparand instanceof SQNowExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitDefaultValue = function (expr, comparand) {\n                return comparand instanceof SQDefaultValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitAnyValue = function (expr, comparand) {\n                return comparand instanceof SQAnyValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitResourcePackageItem = function (expr, comparand) {\n                return comparand instanceof SQResourcePackageItemExpr &&\n                    expr.packageName === comparand.packageName &&\n                    expr.packageType === comparand.packageType &&\n                    expr.itemName === comparand.itemName;\n            };\n            SQExprEqualityVisitor.prototype.visitStartsWith = function (expr, comparand) {\n                return comparand instanceof SQStartsWithExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitConstant = function (expr, comparand) {\n                if (comparand instanceof SQConstantExpr && expr.type === comparand.type)\n                    return expr.type.text && this.ignoreCase ?\n                        StringExtensions.equalIgnoreCase(expr.valueEncoded, comparand.valueEncoded) :\n                        expr.valueEncoded === comparand.valueEncoded;\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitFillRule = function (expr, comparand) {\n                if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\n                    var leftRule = expr.rule, rightRule = comparand.rule;\n                    if (leftRule === rightRule)\n                        return true;\n                    var leftLinearGradient2 = leftRule.linearGradient2, rightLinearGradient2 = rightRule.linearGradient2;\n                    if (leftLinearGradient2 && rightLinearGradient2) {\n                        return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\n                    }\n                    var leftLinearGradient3 = leftRule.linearGradient3, rightLinearGradient3 = rightRule.linearGradient3;\n                    if (leftLinearGradient3 && rightLinearGradient3) {\n                        return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\n                    }\n                }\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient2 = function (left2, right2) {\n                debug.assertValue(left2, 'left2');\n                debug.assertValue(right2, 'right2');\n                return this.equalsFillRuleStop(left2.min, right2.min) &&\n                    this.equalsFillRuleStop(left2.max, right2.max);\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient3 = function (left3, right3) {\n                debug.assertValue(left3, 'left3');\n                debug.assertValue(right3, 'right3');\n                return this.equalsFillRuleStop(left3.min, right3.min) &&\n                    this.equalsFillRuleStop(left3.mid, right3.mid) &&\n                    this.equalsFillRuleStop(left3.max, right3.max);\n            };\n            SQExprEqualityVisitor.prototype.equalsFillRuleStop = function (stop1, stop2) {\n                debug.assertValue(stop1, 'stop1');\n                debug.assertValue(stop2, 'stop2');\n                if (!this.equals(stop1.color, stop2.color))\n                    return false;\n                if (!stop1.value)\n                    return stop1.value === stop2.value;\n                return this.equals(stop1.value, stop2.value);\n            };\n            SQExprEqualityVisitor.prototype.visitArithmetic = function (expr, comparand) {\n                return comparand instanceof SQArithmeticExpr &&\n                    expr.operator === comparand.operator &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitScopedEval = function (expr, comparand) {\n                return comparand instanceof SQScopedEvalExpr &&\n                    this.equals(expr.expression, comparand.expression) &&\n                    this.equalsAll(expr.scope, comparand.scope);\n            };\n            SQExprEqualityVisitor.prototype.optionalEqual = function (x, y) {\n                // Only check equality if both values are specified.\n                if (x && y)\n                    return x === y;\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.equals = function (x, y) {\n                return x.accept(this, y);\n            };\n            SQExprEqualityVisitor.prototype.equalsAll = function (x, y) {\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!this.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.instance = new SQExprEqualityVisitor(/* ignoreCase */ false);\n            SQExprEqualityVisitor.ignoreCaseInstance = new SQExprEqualityVisitor(true);\n            return SQExprEqualityVisitor;\n        }());\n        /** Rewrites a root-level expression. */\n        var SQExprRootRewriter = (function (_super) {\n            __extends(SQExprRootRewriter, _super);\n            function SQExprRootRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRootRewriter.prototype.visitDefault = function (expr) {\n                return expr;\n            };\n            return SQExprRootRewriter;\n        }(data.DefaultSQExprVisitor));\n        var SQExprValidationVisitor = (function (_super) {\n            __extends(SQExprValidationVisitor, _super);\n            function SQExprValidationVisitor(schema, aggrUtils, errors) {\n                debug.assertValue(schema, 'schema');\n                debug.assertValue(aggrUtils, 'aggrUtils');\n                _super.call(this);\n                this.schema = schema;\n                this.aggrUtils = aggrUtils;\n                if (errors)\n                    this.errors = errors;\n            }\n            SQExprValidationVisitor.prototype.visitIn = function (expr) {\n                var inExpr = _super.prototype.visitIn.call(this, expr);\n                var args = inExpr.args;\n                var values = inExpr.values;\n                for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n                    var valueTuple = values_2[_i];\n                    debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\n                    for (var i = 0, len = valueTuple.length; i < len; ++i)\n                        this.validateCompatibleType(args[i], valueTuple[i]);\n                }\n                return inExpr;\n            };\n            SQExprValidationVisitor.prototype.visitCompare = function (expr) {\n                var compareExpr = _super.prototype.visitCompare.call(this, expr);\n                this.validateCompatibleType(compareExpr.left, compareExpr.right);\n                return compareExpr;\n            };\n            SQExprValidationVisitor.prototype.visitColumnRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.column.name);\n                        if (!prop ||\n                            prop.kind !== 0 /* Column */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(3 /* invalidColumnReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitMeasureRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.measure.name);\n                        if (!prop ||\n                            prop.kind !== 1 /* Measure */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(4 /* invalidMeasureReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitAggr = function (expr) {\n                var aggregateExpr = _super.prototype.visitAggr.call(this, expr);\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\n                if (columnRefExpr) {\n                    if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/ null))\n                        this.register(0 /* invalidAggregateFunction */);\n                }\n                return aggregateExpr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchy = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = fieldExpr.hierarchy;\n                    if (fieldExprItem) {\n                        this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\n                    }\n                    else {\n                        this.register(5 /* invalidHierarchyReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var hierarchyLevelFieldExprItem = fieldExpr.hierarchyLevel;\n                    if (hierarchyLevelFieldExprItem) {\n                        this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\n                    }\n                    else if (!fieldExpr.columnHierarchyLevelVariation) {\n                        this.register(6 /* invalidHierarchyLevelReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitEntity = function (expr) {\n                this.validateEntity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitContains = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitStartsWith = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitArithmetic = function (expr) {\n                this.validateArithmeticTypes(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitScopedEval = function (expr) {\n                // No validation necessary\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.validateOperandsAndTypeForStartOrContains = function (left, right) {\n                if (left instanceof SQColumnRefExpr) {\n                    this.visitColumnRef(left);\n                }\n                else if (left instanceof SQHierarchyLevelExpr) {\n                    this.visitHierarchyLevel(left);\n                }\n                else {\n                    this.register(7 /* invalidLeftOperandType */);\n                }\n                if (!(right instanceof SQConstantExpr) || !right.type.text)\n                    this.register(8 /* invalidRightOperandType */);\n                else\n                    this.validateCompatibleType(left, right);\n            };\n            SQExprValidationVisitor.prototype.validateArithmeticTypes = function (left, right) {\n                if (!data.SQExprUtils.supportsArithmetic(left, this.schema))\n                    this.register(7 /* invalidLeftOperandType */);\n                if (!data.SQExprUtils.supportsArithmetic(right, this.schema))\n                    this.register(8 /* invalidRightOperandType */);\n            };\n            SQExprValidationVisitor.prototype.validateCompatibleType = function (left, right) {\n                var leftMetadata = left.getMetadata(this.schema), leftType = leftMetadata && leftMetadata.type, rightMetadata = right.getMetadata(this.schema), rightType = rightMetadata && rightMetadata.type;\n                if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\n                    this.register(9 /* invalidValueType */);\n            };\n            SQExprValidationVisitor.prototype.validateEntity = function (schemaName, entityName) {\n                var schema = this.schema.schema(schemaName);\n                if (schema) {\n                    var entity = schema.entities.withName(entityName);\n                    if (entity)\n                        return entity;\n                    this.register(2 /* invalidEntityReference */);\n                }\n                else {\n                    this.register(1 /* invalidSchemaReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchy = function (schemaName, entityName, hierarchyName) {\n                var entity = this.validateEntity(schemaName, entityName);\n                if (entity) {\n                    var hierarchy = entity.hierarchies.withName(hierarchyName);\n                    if (hierarchy)\n                        return hierarchy;\n                    this.register(5 /* invalidHierarchyReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchyLevel = function (schemaName, entityName, hierarchyName, levelName) {\n                var hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\n                if (hierarchy) {\n                    var hierarchyLevel = hierarchy.levels.withName(levelName);\n                    if (hierarchyLevel)\n                        return hierarchyLevel;\n                    this.register(6 /* invalidHierarchyLevelReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.register = function (error) {\n                if (!this.errors)\n                    this.errors = [];\n                this.errors.push(error);\n            };\n            SQExprValidationVisitor.prototype.isQueryable = function (fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\n                    var hierarchyLevelConceptualProperty = data.SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\n                    return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== 1 /* Error */;\n                }\n                return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, data.FieldExprPattern.getPropertyName(fieldExpr)).queryable !== 1 /* Error */;\n            };\n            return SQExprValidationVisitor;\n        }(data.SQExprRewriter));\n        data.SQExprValidationVisitor = SQExprValidationVisitor;\n        /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\n        var SQExprAggregateInfoVisitor = (function (_super) {\n            __extends(SQExprAggregateInfoVisitor, _super);\n            function SQExprAggregateInfoVisitor() {\n                _super.apply(this, arguments);\n            }\n            SQExprAggregateInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.func;\n            };\n            SQExprAggregateInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprAggregateInfoVisitor.getAggregate = function (expr) {\n                var visitor = new SQExprAggregateInfoVisitor();\n                return expr.accept(visitor);\n            };\n            return SQExprAggregateInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQExprColumnRef expression or undefined.*/\n        var SQExprColumnRefInfoVisitor = (function (_super) {\n            __extends(SQExprColumnRefInfoVisitor, _super);\n            function SQExprColumnRefInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQExprColumnRefInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return expr;\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var ref = expr.level;\n                var hierarchy = (expr.arg);\n                var sourceExpr = hierarchy.accept(this);\n                if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\n                    var propertyVariationSource = hierarchy.arg;\n                    var targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\n                    if (sourceExpr && targetEntity) {\n                        var schemaName = (sourceExpr.source).schema;\n                        var targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\n                        var schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\n                        if (schemaHierarchy) {\n                            for (var _i = 0, _a = schemaHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                if (level.name === ref)\n                                    return new SQColumnRefExpr(targetEntityExpr, level.column.name);\n                            }\n                        }\n                    }\n                }\n                else {\n                    var entityExpr = (hierarchy.arg);\n                    var hierarchyLevelRef = data.SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema, entityExpr.schema, entityExpr.entity, hierarchy.hierarchy, expr.level);\n                    if (hierarchyLevelRef)\n                        return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\n                }\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var propertyName = expr.property;\n                return new SQColumnRefExpr(expr.arg, propertyName);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprColumnRefInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQExprColumnRefInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQEntityExpr expression or undefined.*/\n        var SQEntityExprInfoVisitor = (function (_super) {\n            __extends(SQEntityExprInfoVisitor, _super);\n            function SQEntityExprInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQEntityExprInfoVisitor.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQEntityExprInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return SQEntityExprInfoVisitor.getEntity(expr);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQEntityExprInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitAggr = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitMeasureRef = function (expr) {\n                return expr.source.accept(this);\n            };\n            SQEntityExprInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            SQEntityExprInfoVisitor.getEntity = function (columnRef) {\n                var field = data.SQExprConverter.asFieldPattern(columnRef);\n                var column = field.column;\n                return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\n            };\n            SQEntityExprInfoVisitor.getEntityExpr = function (schema, expr) {\n                var visitor = new SQEntityExprInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQEntityExprInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        var SQExprChangeAggregateRewriter = (function (_super) {\n            __extends(SQExprChangeAggregateRewriter, _super);\n            function SQExprChangeAggregateRewriter(func) {\n                debug.assertValue(func, 'func');\n                _super.call(this);\n                this.func = func;\n            }\n            SQExprChangeAggregateRewriter.prototype.visitAggr = function (expr) {\n                if (expr.func === this.func)\n                    return expr;\n                return new SQAggregationExpr(expr.arg, this.func);\n            };\n            SQExprChangeAggregateRewriter.prototype.visitColumnRef = function (expr) {\n                return new SQAggregationExpr(expr, this.func);\n            };\n            SQExprChangeAggregateRewriter.rewrite = function (expr, func) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(func, 'func');\n                var rewriter = new SQExprChangeAggregateRewriter(func);\n                return expr.accept(rewriter);\n            };\n            return SQExprChangeAggregateRewriter;\n        }(SQExprRootRewriter));\n        var SQExprRemoveAggregateRewriter = (function (_super) {\n            __extends(SQExprRemoveAggregateRewriter, _super);\n            function SQExprRemoveAggregateRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveAggregateRewriter.prototype.visitAggr = function (expr) {\n                return expr.arg;\n            };\n            SQExprRemoveAggregateRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveAggregateRewriter.instance);\n            };\n            SQExprRemoveAggregateRewriter.instance = new SQExprRemoveAggregateRewriter();\n            return SQExprRemoveAggregateRewriter;\n        }(SQExprRootRewriter));\n        var SQExprRemoveEntityVariablesRewriter = (function (_super) {\n            __extends(SQExprRemoveEntityVariablesRewriter, _super);\n            function SQExprRemoveEntityVariablesRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveEntityVariablesRewriter.prototype.visitEntity = function (expr) {\n                if (expr.variable)\n                    return SQExprBuilder.entity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprRemoveEntityVariablesRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\n            };\n            SQExprRemoveEntityVariablesRewriter.instance = new SQExprRemoveEntityVariablesRewriter();\n            return SQExprRemoveEntityVariablesRewriter;\n        }(data.SQExprRewriter));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var StringExtensions = jsCommon.StringExtensions;\n        var SQExprUtils;\n        (function (SQExprUtils) {\n            function supportsArithmetic(expr, schema) {\n                var metadata = expr.getMetadata(schema), type = metadata && metadata.type;\n                if (!metadata || !type) {\n                    return false;\n                }\n                return type.numeric || type.dateTime || type.duration;\n            }\n            SQExprUtils.supportsArithmetic = supportsArithmetic;\n            function indexOfExpr(items, searchElement) {\n                debug.assertValue(items, 'items');\n                debug.assertValue(searchElement, 'searchElement');\n                for (var i = 0, len = items.length; i < len; i++) {\n                    if (data.SQExpr.equals(items[i], searchElement))\n                        return i;\n                }\n                return -1;\n            }\n            SQExprUtils.indexOfExpr = indexOfExpr;\n            function sequenceEqual(x, y) {\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!data.SQExpr.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            SQExprUtils.sequenceEqual = sequenceEqual;\n            function uniqueName(namedItems, expr, exprDefaultName) {\n                debug.assertValue(namedItems, 'namedItems');\n                // Determine all names\n                var names = {};\n                for (var i = 0, len = namedItems.length; i < len; i++)\n                    names[namedItems[i].name] = true;\n                return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\n            }\n            SQExprUtils.uniqueName = uniqueName;\n            /** Generates a default expression name  */\n            function defaultName(expr, fallback) {\n                if (fallback === void 0) { fallback = 'select'; }\n                if (!expr)\n                    return fallback;\n                return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\n            }\n            SQExprUtils.defaultName = defaultName;\n            /** Gets a value indicating whether the expr is a model measure or an aggregate. */\n            function isMeasure(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsMeasureVisitor.instance);\n            }\n            SQExprUtils.isMeasure = isMeasure;\n            /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\n            function isAnyValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsAnyValueVisitor.instance);\n            }\n            SQExprUtils.isAnyValue = isAnyValue;\n            /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\n            function isDefaultValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsDefaultValueVisitor.instance);\n            }\n            SQExprUtils.isDefaultValue = isDefaultValue;\n            function discourageAggregation(expr, schema) {\n                var capabilities = getSchemaCapabilities(expr, schema);\n                return capabilities && capabilities.discourageQueryAggregateUsage;\n            }\n            SQExprUtils.discourageAggregation = discourageAggregation;\n            function getAggregateBehavior(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var column = getConceptualColumn(expr, schema);\n                if (column)\n                    return column.aggregateBehavior;\n            }\n            SQExprUtils.getAggregateBehavior = getAggregateBehavior;\n            function getSchemaCapabilities(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var field = data.SQExprConverter.asFieldPattern(expr);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var conceptualSchema = schema.schema(fieldExprItem.schema);\n                if (conceptualSchema)\n                    return conceptualSchema.capabilities;\n            }\n            SQExprUtils.getSchemaCapabilities = getSchemaCapabilities;\n            function getKpiMetadata(expr, schema) {\n                var kpiStatusProperty = getKpiStatusProperty(expr, schema);\n                if (kpiStatusProperty)\n                    return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\n                var kpiTrendProperty = getKpiTrendProperty(expr, schema);\n                if (kpiTrendProperty)\n                    return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\n            }\n            SQExprUtils.getKpiMetadata = getKpiMetadata;\n            function getConceptualEntity(entityExpr, schema) {\n                debug.assertValue(entityExpr, 'entityExpr');\n                var conceptualEntity = schema\n                    .schema(entityExpr.schema)\n                    .entities\n                    .withName(entityExpr.entity);\n                return conceptualEntity;\n            }\n            SQExprUtils.getConceptualEntity = getConceptualEntity;\n            function getKpiStatusProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.status === property)\n                    return property;\n            }\n            function getKpiTrendProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.trend === property)\n                    return property;\n            }\n            function getDefaultValue(fieldSQExpr, schema) {\n                var column = getConceptualColumn(fieldSQExpr, schema);\n                if (column)\n                    return column.defaultValue;\n            }\n            SQExprUtils.getDefaultValue = getDefaultValue;\n            function getConceptualColumn(fieldSQExpr, schema) {\n                if (!fieldSQExpr || !schema)\n                    return;\n                var sqField = data.SQExprConverter.asFieldPattern(fieldSQExpr);\n                if (!sqField)\n                    return;\n                var column = sqField.column;\n                if (column) {\n                    if (schema.schema(column.schema) && sqField.column.name) {\n                        var property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\n                        if (property)\n                            return property.column;\n                    }\n                }\n                else {\n                    var hierarchyLevelField = sqField.hierarchyLevel;\n                    if (hierarchyLevelField) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(sqField);\n                        var schemaName = fieldExprItem.schema;\n                        if (schema.schema(schemaName)) {\n                            var hierarchy = schema.schema(schemaName)\n                                .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\n                            if (hierarchy) {\n                                var hierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\n                                if (hierarchyLevel && hierarchyLevel.column)\n                                    return hierarchyLevel.column.column;\n                            }\n                        }\n                    }\n                }\n            }\n            function getDefaultValues(fieldSQExprs, schema) {\n                if (_.isEmpty(fieldSQExprs) || !schema)\n                    return;\n                var result = [];\n                for (var _i = 0, fieldSQExprs_2 = fieldSQExprs; _i < fieldSQExprs_2.length; _i++) {\n                    var sqExpr = fieldSQExprs_2[_i];\n                    var defaultValue = getDefaultValue(sqExpr, schema);\n                    if (defaultValue)\n                        result.push(defaultValue);\n                }\n                return result;\n            }\n            SQExprUtils.getDefaultValues = getDefaultValues;\n            /** Return compare or and expression for key value pairs. */\n            function getDataViewScopeIdentityComparisonExpr(fieldsExpr, values) {\n                debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\n                var compareExprs = [];\n                for (var i = 0; i < fieldsExpr.length; i++) {\n                    compareExprs.push(data.SQExprBuilder.compare(data.QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\n                }\n                if (_.isEmpty(compareExprs))\n                    return;\n                var resultExpr;\n                for (var _i = 0, compareExprs_1 = compareExprs; _i < compareExprs_1.length; _i++) {\n                    var compareExpr = compareExprs_1[_i];\n                    resultExpr = data.SQExprBuilder.and(resultExpr, compareExpr);\n                }\n                return resultExpr;\n            }\n            SQExprUtils.getDataViewScopeIdentityComparisonExpr = getDataViewScopeIdentityComparisonExpr;\n            function getActiveTablesNames(queryDefn) {\n                var tables = [];\n                if (queryDefn) {\n                    var selectedItems = queryDefn.from();\n                    if (selectedItems !== undefined) {\n                        for (var _i = 0, _a = selectedItems.keys(); _i < _a.length; _i++) {\n                            var key = _a[_i];\n                            var entityObj = selectedItems.entity(key);\n                            if (tables.indexOf(entityObj.entity) < 0)\n                                tables.push(entityObj.entity);\n                        }\n                    }\n                }\n                return tables;\n            }\n            SQExprUtils.getActiveTablesNames = getActiveTablesNames;\n            function isRelatedToMany(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 0 /* ZeroOrOne */, 2 /* Many */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 2 /* Many */, 0 /* ZeroOrOne */);\n            }\n            SQExprUtils.isRelatedToMany = isRelatedToMany;\n            function isRelatedToOne(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 2 /* Many */, 0 /* ZeroOrOne */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 0 /* ZeroOrOne */, 2 /* Many */);\n            }\n            SQExprUtils.isRelatedToOne = isRelatedToOne;\n            function isRelated(schema, sourceExpr, targetExpr, sourceMultiplicity, targetMultiplicity) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                if (_.isEmpty(source.navigationProperties))\n                    return false;\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var queue = [];\n                queue.push(source);\n                // walk the relationship path from source.\n                while (!_.isEmpty(queue)) {\n                    var current = queue.shift();\n                    var navProperties = current.navigationProperties;\n                    if (_.isEmpty(navProperties))\n                        continue;\n                    for (var _i = 0, navProperties_1 = navProperties; _i < navProperties_1.length; _i++) {\n                        var navProperty = navProperties_1[_i];\n                        if (!navProperty.isActive)\n                            continue;\n                        if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\n                            if (navProperty.targetEntity === target)\n                                return true;\n                            queue.push(navProperty.targetEntity);\n                        }\n                    }\n                }\n                return false;\n            }\n            function isRelatedOneToOne(schema, sourceExpr, targetExpr) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var sourceNavigations = source.navigationProperties;\n                var targetNavigations = target.navigationProperties;\n                if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\n                    return false;\n                return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\n            }\n            SQExprUtils.isRelatedOneToOne = isRelatedOneToOne;\n            function hasOneToOneNavigation(navigationProperties, targetEntity) {\n                if (_.isEmpty(navigationProperties))\n                    return false;\n                for (var _i = 0, navigationProperties_1 = navigationProperties; _i < navigationProperties_1.length; _i++) {\n                    var navigationProperty = navigationProperties_1[_i];\n                    if (!navigationProperty.isActive)\n                        continue;\n                    if (navigationProperty.targetEntity !== targetEntity)\n                        continue;\n                    if (navigationProperty.sourceMultiplicity === 0 /* ZeroOrOne */ &&\n                        navigationProperty.targetMultiplicity === 0 /* ZeroOrOne */) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\n                and returns a new array. When available, we should use _.unionWith from lodash. */\n            function concatUnique(leftExprs, rightExprs) {\n                debug.assertValue(leftExprs, 'leftExprs');\n                debug.assertValue(rightExprs, 'rightExprs');\n                var concatExprs = ArrayExtensions.copy(leftExprs);\n                for (var _i = 0, rightExprs_1 = rightExprs; _i < rightExprs_1.length; _i++) {\n                    var expr = rightExprs_1[_i];\n                    if (indexOfExpr(concatExprs, expr) === -1) {\n                        concatExprs.push(expr);\n                    }\n                }\n                return concatExprs;\n            }\n            SQExprUtils.concatUnique = concatUnique;\n            var SQExprDefaultNameGenerator = (function (_super) {\n                __extends(SQExprDefaultNameGenerator, _super);\n                function SQExprDefaultNameGenerator() {\n                    _super.apply(this, arguments);\n                }\n                SQExprDefaultNameGenerator.prototype.visitEntity = function (expr) {\n                    return expr.entity;\n                };\n                SQExprDefaultNameGenerator.prototype.visitColumnRef = function (expr) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitMeasureRef = function (expr, fallback) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitAggr = function (expr, fallback) {\n                    return data.QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitArithmetic = function (expr, fallback) {\n                    return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitConstant = function (expr) {\n                    return 'const';\n                };\n                SQExprDefaultNameGenerator.prototype.visitDefault = function (expr, fallback) {\n                    return fallback || 'expr';\n                };\n                SQExprDefaultNameGenerator.instance = new SQExprDefaultNameGenerator();\n                return SQExprDefaultNameGenerator;\n            }(data.DefaultSQExprVisitorWithArg));\n            var IsMeasureVisitor = (function (_super) {\n                __extends(IsMeasureVisitor, _super);\n                function IsMeasureVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsMeasureVisitor.prototype.visitMeasureRef = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitAggr = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitArithmetic = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsMeasureVisitor.instance = new IsMeasureVisitor();\n                return IsMeasureVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsDefaultValueVisitor = (function (_super) {\n                __extends(IsDefaultValueVisitor, _super);\n                function IsDefaultValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsDefaultValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitDefaultValue = function (expr) {\n                    return true;\n                };\n                IsDefaultValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsDefaultValueVisitor.instance = new IsDefaultValueVisitor();\n                return IsDefaultValueVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsAnyValueVisitor = (function (_super) {\n                __extends(IsAnyValueVisitor, _super);\n                function IsAnyValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsAnyValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnyValue = function (expr) {\n                    return true;\n                };\n                IsAnyValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsAnyValueVisitor.instance = new IsAnyValueVisitor();\n                return IsAnyValueVisitor;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprUtils = data.SQExprUtils || (data.SQExprUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SemanticQueryRewriter = (function () {\n            function SemanticQueryRewriter(exprRewriter) {\n                this.exprRewriter = exprRewriter;\n            }\n            SemanticQueryRewriter.prototype.rewriteFrom = function (fromValue) {\n                var fromContents = {};\n                var originalFrom = fromValue, originalFromKeys = originalFrom.keys();\n                for (var i = 0, len = originalFromKeys.length; i < len; i++) {\n                    var keyName = originalFromKeys[i], originalEntityRef = originalFrom.entity(keyName), originalEntityExpr = data.SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName), updatedEntityExpr = originalEntityExpr.accept(this.exprRewriter);\n                    fromContents[keyName] = {\n                        schema: updatedEntityExpr.schema,\n                        entity: updatedEntityExpr.entity,\n                    };\n                }\n                return new data.SQFrom(fromContents);\n            };\n            SemanticQueryRewriter.prototype.rewriteSelect = function (selectItems, from) {\n                debug.assertValue(selectItems, 'selectItems');\n                debug.assertValue(from, 'from');\n                return this.rewriteNamedSQExpressions(selectItems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteGroupBy = function (groupByitems, from) {\n                debug.assertAnyValue(groupByitems, 'groupByitems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(groupByitems))\n                    return;\n                return this.rewriteNamedSQExpressions(groupByitems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteNamedSQExpressions = function (expressions, from) {\n                var _this = this;\n                debug.assertValue(expressions, 'expressions');\n                return _.map(expressions, function (item) {\n                    return {\n                        name: item.name,\n                        expr: data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(_this.exprRewriter), from)\n                    };\n                });\n            };\n            SemanticQueryRewriter.prototype.rewriteOrderBy = function (orderByItems, from) {\n                debug.assertAnyValue(orderByItems, 'orderByItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(orderByItems))\n                    return;\n                var orderBy = [];\n                for (var i = 0, len = orderByItems.length; i < len; i++) {\n                    var item = orderByItems[i], updatedExpr = data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\n                    orderBy.push({\n                        direction: item.direction,\n                        expr: updatedExpr,\n                    });\n                }\n                return orderBy;\n            };\n            SemanticQueryRewriter.prototype.rewriteWhere = function (whereItems, from) {\n                var _this = this;\n                debug.assertAnyValue(whereItems, 'whereItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(whereItems))\n                    return;\n                var where = [];\n                for (var i = 0, len = whereItems.length; i < len; i++) {\n                    var originalWhere = whereItems[i];\n                    var updatedWhere = {\n                        condition: data.SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\n                    };\n                    if (originalWhere.target)\n                        updatedWhere.target = _.map(originalWhere.target, function (e) { return data.SQExprRewriterWithSourceRenames.rewrite(e.accept(_this.exprRewriter), from); });\n                    where.push(updatedWhere);\n                }\n                return where;\n            };\n            return SemanticQueryRewriter;\n        }());\n        data.SemanticQueryRewriter = SemanticQueryRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /**\n         * Represents a semantic query that is:\n         * 1) Round-trippable with a JSON QueryDefinition.\n         * 2) Immutable\n         * 3) Long-lived and does not have strong references to a conceptual model (only names).\n         */\n        var SemanticQuery = (function () {\n            function SemanticQuery(from, where, orderBy, select, groupBy) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(select, 'select');\n                this.fromValue = from;\n                this.whereItems = where;\n                this.orderByItems = orderBy;\n                this.selectItems = select;\n                this.groupByItems = groupBy;\n            }\n            SemanticQuery.create = function () {\n                if (!SemanticQuery.empty)\n                    SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\n                return SemanticQuery.empty;\n            };\n            SemanticQuery.createWithTrimmedFrom = function (from, where, orderBy, select, groupBy) {\n                var unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\n                // Where\n                if (where) {\n                    for (var i = 0, len = where.length; i < len; i++) {\n                        var filter = where[i];\n                        filter.condition.accept(unreferencedKeyFinder);\n                        var filterTarget = filter.target;\n                        if (filterTarget) {\n                            for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                                if (filterTarget[j])\n                                    filterTarget[j].accept(unreferencedKeyFinder);\n                        }\n                    }\n                }\n                // OrderBy\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++)\n                        orderBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                // Select\n                for (var i = 0, len = select.length; i < len; i++)\n                    select[i].expr.accept(unreferencedKeyFinder);\n                // GroupBy\n                if (groupBy) {\n                    for (var i = 0, len = groupBy.length; i < len; i++)\n                        groupBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                var unreferencedKeys = unreferencedKeyFinder.result();\n                for (var i = 0, len = unreferencedKeys.length; i < len; i++)\n                    from.remove(unreferencedKeys[i]);\n                return new SemanticQuery(from, where, orderBy, select, groupBy);\n            };\n            SemanticQuery.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticQuery.prototype.select = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getSelect();\n                return this.setSelect(values);\n            };\n            SemanticQuery.prototype.getSelect = function () {\n                return SemanticQuery.createNamedExpressionArray(this.selectItems);\n            };\n            SemanticQuery.createNamedExpressionArray = function (items) {\n                return ArrayExtensions.extendWithName(_.map(items, function (s) {\n                    return {\n                        name: s.name,\n                        expr: s.expr,\n                    };\n                }));\n            };\n            SemanticQuery.prototype.setSelect = function (values) {\n                var from = this.fromValue.clone();\n                var selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.rewriteExpressionsWithSourceRenames = function (values, from) {\n                var items = [];\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    items.push({\n                        name: value.name,\n                        expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\n                    });\n                }\n                return items;\n            };\n            /** Removes the given expression from the select. */\n            SemanticQuery.prototype.removeSelect = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var originalItems = this.selectItems, selectItems = [];\n                for (var i = 0, len = originalItems.length; i < len; i++) {\n                    var originalExpr = originalItems[i];\n                    if (data.SQExpr.equals(originalExpr.expr, expr))\n                        continue;\n                    selectItems.push(originalExpr);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            /** Removes the given expression from order by. */\n            SemanticQuery.prototype.removeOrderBy = function (expr) {\n                var sorts = this.orderBy();\n                for (var i = sorts.length - 1; i >= 0; i--) {\n                    if (data.SQExpr.equals(sorts[i].expr, expr))\n                        sorts.splice(i, 1);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.selectNameOf = function (expr) {\n                var index = data.SQExprUtils.indexOfExpr(_.map(this.selectItems, function (s) { return s.expr; }), expr);\n                if (index >= 0)\n                    return this.selectItems[index].name;\n            };\n            SemanticQuery.prototype.setSelectAt = function (index, expr) {\n                debug.assertValue(expr, 'expr');\n                if (index >= this.selectItems.length)\n                    return;\n                var select = this.select(), from = this.fromValue.clone(), originalName = select[index].name;\n                select[index] = {\n                    name: originalName,\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\n            };\n            /** Adds a the expression to the select clause. */\n            SemanticQuery.prototype.addSelect = function (expr, exprName) {\n                debug.assertValue(expr, 'expr');\n                var selectItems = this.select(), from = this.fromValue.clone();\n                selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.createNamedExpr = function (currentNames, from, expr, exprName) {\n                return {\n                    name: data.SQExprUtils.uniqueName(currentNames, expr, exprName),\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n            };\n            SemanticQuery.prototype.groupBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getGroupBy();\n                return this.setGroupBy(values);\n            };\n            SemanticQuery.prototype.getGroupBy = function () {\n                return SemanticQuery.createNamedExpressionArray(this.groupByItems);\n            };\n            SemanticQuery.prototype.setGroupBy = function (values) {\n                var from = this.fromValue.clone();\n                var groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.addGroupBy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var groupByItems = this.groupBy(), from = this.fromValue.clone();\n                groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.orderBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getOrderBy();\n                return this.setOrderBy(values);\n            };\n            SemanticQuery.prototype.getOrderBy = function () {\n                var result = [];\n                var orderBy = this.orderByItems;\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++) {\n                        var clause = orderBy[i];\n                        result.push({\n                            expr: clause.expr,\n                            direction: clause.direction,\n                        });\n                    }\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setOrderBy = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedOrderBy = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var clause = values[i];\n                    updatedOrderBy.push({\n                        expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\n                        direction: clause.direction,\n                    });\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.where = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getWhere();\n                return this.setWhere(values);\n            };\n            SemanticQuery.prototype.getWhere = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                if (whereItems) {\n                    for (var i = 0, len = whereItems.length; i < len; i++)\n                        result.push(whereItems[i]);\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setWhere = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedWhere = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var filter = values[i];\n                    var updatedFilter = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\n                    };\n                    var filterTarget = filter.target;\n                    if (filterTarget) {\n                        updatedFilter.target = [];\n                        for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                            if (filterTarget[j]) {\n                                var updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\n                                updatedFilter.target.push(updatedTarget);\n                            }\n                    }\n                    updatedWhere.push(updatedFilter);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.addWhere = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedWhere = this.where(), incomingWhere = filter.where(), from = this.fromValue.clone();\n                for (var i = 0, len = incomingWhere.length; i < len; i++) {\n                    var clause = incomingWhere[i];\n                    var updatedClause = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\n                    };\n                    if (clause.target)\n                        updatedClause.target = _.map(clause.target, function (t) { return SQExprRewriterWithSourceRenames.rewrite(t, from); });\n                    updatedWhere.push(updatedClause);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                var orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\n                var select = rewriter.rewriteSelect(this.selectItems, from);\n                var groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\n                return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\n            };\n            return SemanticQuery;\n        }());\n        data.SemanticQuery = SemanticQuery;\n        /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\n        var SemanticFilter = (function () {\n            function SemanticFilter(from, where) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                this.fromValue = from;\n                this.whereItems = where;\n            }\n            SemanticFilter.fromSQExpr = function (contract) {\n                debug.assertValue(contract, 'contract');\n                var from = new SQFrom();\n                var rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\n                // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\n                //         Thus not setting a target here.\n                var where = [{\n                        condition: rewrittenContract\n                    }];\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.getDefaultValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.defaultValue());\n            };\n            SemanticFilter.getAnyValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.anyValue());\n            };\n            SemanticFilter.getDataViewScopeIdentityComparisonFilters = function (fieldSQExprs, value) {\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assertValue(value, 'value');\n                if (fieldSQExprs instanceof Array) {\n                    var values = Array.apply(null, Array(fieldSQExprs.length)).map(function () { return value; });\n                    return SemanticFilter.fromSQExpr(data.SQExprUtils.getDataViewScopeIdentityComparisonExpr(fieldSQExprs, values));\n                }\n                return SemanticFilter.fromSQExpr(data.SQExprBuilder.equal(fieldSQExprs, value));\n            };\n            SemanticFilter.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticFilter.prototype.conditions = function () {\n                var expressions = [];\n                var where = this.whereItems;\n                for (var i = 0, len = where.length; i < len; i++) {\n                    var filter = where[i];\n                    expressions.push(filter.condition);\n                }\n                return expressions;\n            };\n            SemanticFilter.prototype.where = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                for (var i = 0, len = whereItems.length; i < len; i++)\n                    result.push(whereItems[i]);\n                return result;\n            };\n            SemanticFilter.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new data.SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.rewrite(validator);\n                return validator.errors;\n            };\n            /** Merges a list of SemanticFilters into one. */\n            SemanticFilter.merge = function (filters) {\n                if (_.isEmpty(filters))\n                    return null;\n                if (filters.length === 1)\n                    return filters[0];\n                var firstFilter = filters[0];\n                var from = firstFilter.from(), where = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\n                for (var i = 1, len = filters.length; i < len; i++)\n                    SemanticFilter.applyFilter(filters[i], from, where);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.isDefaultFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isDefaultValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isAnyFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isAnyValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isSameFilter = function (leftFilter, rightFilter) {\n                if (jsCommon.JsonComparer.equals(leftFilter, rightFilter)) {\n                    return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\n                        || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\n                }\n                return false;\n            };\n            SemanticFilter.applyFilter = function (filter, from, where) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                // Where\n                var filterWhereItems = filter.whereItems;\n                for (var i = 0; i < filterWhereItems.length; i++) {\n                    var filterWhereItem = filterWhereItems[i];\n                    var updatedWhereItem = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\n                    };\n                    if (filterWhereItem.target)\n                        updatedWhereItem.target = _.map(filterWhereItem.target, function (e) { return SQExprRewriterWithSourceRenames.rewrite(e, from); });\n                    where.push(updatedWhereItem);\n                }\n            };\n            return SemanticFilter;\n        }());\n        data.SemanticFilter = SemanticFilter;\n        /** Represents a SemanticQuery/SemanticFilter from clause. */\n        var SQFrom = (function () {\n            function SQFrom(items) {\n                this.items = items || {};\n            }\n            SQFrom.prototype.keys = function () {\n                return Object.keys(this.items);\n            };\n            SQFrom.prototype.entity = function (key) {\n                return this.items[key];\n            };\n            SQFrom.prototype.ensureEntity = function (entity, desiredVariableName) {\n                debug.assertValue(entity, 'entity');\n                // 1) Reuse a reference to the entity among the already referenced\n                var keys = this.keys();\n                for (var i_1 = 0, len = keys.length; i_1 < len; i_1++) {\n                    var key = keys[i_1], item = this.items[key];\n                    if (item && entity.entity === item.entity && entity.schema === item.schema)\n                        return { name: key };\n                }\n                // 2) Add a reference to the entity\n                var candidateName = desiredVariableName || this.candidateName(entity.entity), uniqueName = candidateName, i = 2;\n                while (this.items[uniqueName]) {\n                    uniqueName = candidateName + i++;\n                }\n                this.items[uniqueName] = entity;\n                return { name: uniqueName, new: true };\n            };\n            SQFrom.prototype.remove = function (key) {\n                delete this.items[key];\n            };\n            /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\n            SQFrom.prototype.candidateName = function (ref) {\n                debug.assertValue(ref, 'ref');\n                var idx = ref.lastIndexOf('.');\n                if (idx >= 0 && (idx !== ref.length - 1))\n                    ref = ref.substr(idx + 1);\n                return ref.substring(0, 1).toLowerCase();\n            };\n            SQFrom.prototype.clone = function () {\n                // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\n                var cloned = new SQFrom();\n                // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\n                $.extend(cloned.items, this.items);\n                return cloned;\n            };\n            return SQFrom;\n        }());\n        data.SQFrom = SQFrom;\n        var SQExprRewriterWithSourceRenames = (function (_super) {\n            __extends(SQExprRewriterWithSourceRenames, _super);\n            function SQExprRewriterWithSourceRenames(renames) {\n                debug.assertValue(renames, 'renames');\n                _super.call(this);\n                this.renames = renames;\n            }\n            SQExprRewriterWithSourceRenames.prototype.visitEntity = function (expr) {\n                var updatedName = this.renames[expr.entity];\n                if (updatedName)\n                    return new data.SQEntityExpr(expr.schema, expr.entity, updatedName);\n                return _super.prototype.visitEntity.call(this, expr);\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteFilter = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedTargets = undefined;\n                if (filter.target)\n                    updatedTargets = this.rewriteArray(filter.target);\n                var updatedCondition = filter.condition.accept(this);\n                if (filter.condition === updatedCondition && filter.target === updatedTargets)\n                    return filter;\n                var updatedFilter = {\n                    condition: updatedCondition,\n                };\n                if (updatedTargets)\n                    updatedFilter.target = updatedTargets;\n                return updatedFilter;\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteArray = function (exprs) {\n                debug.assertValue(exprs, 'exprs');\n                var updatedExprs;\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i], rewrittenExpr = expr.accept(this);\n                    if (expr !== rewrittenExpr && !updatedExprs)\n                        updatedExprs = ArrayExtensions.take(exprs, i);\n                    if (updatedExprs)\n                        updatedExprs.push(rewrittenExpr);\n                }\n                return updatedExprs || exprs;\n            };\n            SQExprRewriterWithSourceRenames.rewrite = function (expr, from) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(from, 'from');\n                var renames = QuerySourceRenameDetector.run(expr, from);\n                var rewriter = new SQExprRewriterWithSourceRenames(renames);\n                return expr.accept(rewriter);\n            };\n            return SQExprRewriterWithSourceRenames;\n        }(data.SQExprRewriter));\n        data.SQExprRewriterWithSourceRenames = SQExprRewriterWithSourceRenames;\n        /** Responsible for updating a QueryFrom based on SQExpr references. */\n        var QuerySourceRenameDetector = (function (_super) {\n            __extends(QuerySourceRenameDetector, _super);\n            function QuerySourceRenameDetector(from) {\n                debug.assertValue(from, 'from');\n                _super.call(this);\n                this.from = from;\n                this.renames = {};\n            }\n            QuerySourceRenameDetector.run = function (expr, from) {\n                var detector = new QuerySourceRenameDetector(from);\n                expr.accept(detector);\n                return detector.renames;\n            };\n            QuerySourceRenameDetector.prototype.visitEntity = function (expr) {\n                // TODO: Renames must take the schema into account, not just entity set name.\n                var existingEntity = this.from.entity(expr.variable);\n                if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\n                    return;\n                var actualEntity = this.from.ensureEntity({\n                    schema: expr.schema,\n                    entity: expr.entity,\n                }, expr.variable);\n                this.renames[expr.entity] = actualEntity.name;\n            };\n            return QuerySourceRenameDetector;\n        }(data.DefaultSQExprVisitorWithTraversal));\n        /** Visitor for finding unreferenced sources. */\n        var UnreferencedKeyFinder = (function (_super) {\n            __extends(UnreferencedKeyFinder, _super);\n            function UnreferencedKeyFinder(keys) {\n                debug.assertValue(keys, 'keys');\n                _super.call(this);\n                this.keys = keys;\n            }\n            UnreferencedKeyFinder.prototype.visitEntity = function (expr) {\n                var index = this.keys.indexOf(expr.variable);\n                if (index >= 0)\n                    this.keys.splice(index, 1);\n            };\n            UnreferencedKeyFinder.prototype.result = function () {\n                return this.keys;\n            };\n            return UnreferencedKeyFinder;\n        }(data.DefaultSQExprVisitorWithTraversal));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data_4) {\n        var DataViewTransform = powerbi.data.DataViewTransform;\n        var SQExprBuilder = powerbi.data.SQExprBuilder;\n        function createCategoricalDataViewBuilder() {\n            return new CategoricalDataViewBuilder();\n        }\n        data_4.createCategoricalDataViewBuilder = createCategoricalDataViewBuilder;\n        var CategoricalDataViewBuilder = (function () {\n            function CategoricalDataViewBuilder() {\n                this.categories = [];\n                this.measureColumns = [];\n                this.columnIndex = 0;\n            }\n            CategoricalDataViewBuilder.prototype.withCategory = function (options) {\n                var categoryValues = options.values, identityFrom = options.identityFrom, type = options.source.type;\n                var categoryColumn = {\n                    source: options.source,\n                    identityFields: options.identityFrom.fields,\n                    identity: options.identityFrom.identities || [],\n                    values: categoryValues,\n                };\n                if (!options.identityFrom.identities) {\n                    for (var categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\n                        categoryColumn.identity.push(getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\n                    }\n                }\n                if (!this.categories)\n                    this.categories = [];\n                this.categories.push(categoryColumn);\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withCategories = function (categories) {\n                if (_.isEmpty(this.categories))\n                    this.categories = categories;\n                else\n                    Array.prototype.push.apply(this.categories, categories);\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withValues = function (options) {\n                debug.assertValue(options, 'options');\n                var columns = options.columns;\n                debug.assertValue(columns, 'columns');\n                for (var _i = 0, columns_8 = columns; _i < columns_8.length; _i++) {\n                    var column = columns_8[_i];\n                    this.measureColumns.push(column.source);\n                }\n                this.data = columns;\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withGroupedValues = function (options) {\n                debug.assertValue(options, 'options');\n                this.hasDynamicSeries = true;\n                var groupColumn = options.groupColumn;\n                debug.assertValue(groupColumn, 'groupColumn');\n                this.dynamicSeriesMetadata = {\n                    column: groupColumn.source,\n                    identityFrom: groupColumn.identityFrom,\n                    values: groupColumn.values,\n                };\n                var valueColumns = options.valueColumns;\n                for (var _i = 0, valueColumns_1 = valueColumns; _i < valueColumns_1.length; _i++) {\n                    var valueColumn = valueColumns_1[_i];\n                    this.measureColumns.push(valueColumn.source);\n                }\n                this.data = options.data;\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.fillData = function (dataViewValues, groups) {\n                var categoryColumn = _.first(this.categories);\n                var categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 1;\n                if (this.hasDynamicSeries) {\n                    // Dynamic series\n                    var data_5 = this.data;\n                    for (var seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\n                        var seriesMeasures = data_5[seriesIndex];\n                        debug.assert(seriesMeasures.length === this.measureColumns.length, 'seriesMeasures.length === this.measureColumns.length');\n                        for (var measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                            var groupIndex = seriesIndex * measuresLen + measureIndex;\n                            applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\n                        }\n                    }\n                }\n                else {\n                    // Static series\n                    var data_6 = this.data;\n                    for (var measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                        applySeriesData(dataViewValues[measureIndex], data_6[measureIndex], categoryLength);\n                    }\n                }\n            };\n            CategoricalDataViewBuilder.prototype.build = function () {\n                var metadataColumns = [];\n                var categorical = {};\n                var groups;\n                var categoryMetadata = this.categories;\n                var dynamicSeriesMetadata = this.dynamicSeriesMetadata;\n                // --- Build metadata columns and value groups ---\n                for (var _i = 0, categoryMetadata_1 = categoryMetadata; _i < categoryMetadata_1.length; _i++) {\n                    var columnMetadata = categoryMetadata_1[_i];\n                    pushIfNotExists(metadataColumns, columnMetadata.source);\n                }\n                if (this.hasDynamicSeries) {\n                    pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\n                }\n                if (this.hasDynamicSeries) {\n                    // Dynamic series\n                    categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\n                    var measures = this.measureColumns;\n                    groups = [];\n                    // For each series value we will make one column per measure\n                    var seriesValues = dynamicSeriesMetadata.values;\n                    for (var seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\n                        var seriesValue = seriesValues[seriesIndex];\n                        var seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\n                        for (var _a = 0, measures_1 = measures; _a < measures_1.length; _a++) {\n                            var measure = measures_1[_a];\n                            var column = _.clone(measure);\n                            column.groupName = seriesValue;\n                            groups.push(column);\n                            pushIfNotExists(metadataColumns, column);\n                            categorical.values.push({\n                                source: column,\n                                values: [],\n                                identity: seriesIdentity,\n                            });\n                        }\n                    }\n                }\n                else {\n                    // Static series / no series\n                    categorical.values = DataViewTransform.createValueColumns();\n                    groups = this.measureColumns;\n                    for (var _b = 0, groups_2 = groups; _b < groups_2.length; _b++) {\n                        var measure = groups_2[_b];\n                        var column = measure;\n                        pushIfNotExists(metadataColumns, column);\n                        categorical.values.push({\n                            source: column,\n                            values: [],\n                        });\n                    }\n                }\n                var categories = this.categories;\n                if (!_.isEmpty(categories))\n                    categorical.categories = categories;\n                // --- Fill in data point values ---\n                this.fillData(categorical.values, groups);\n                return {\n                    metadata: {\n                        columns: metadataColumns,\n                    },\n                    categorical: categorical,\n                };\n            };\n            return CategoricalDataViewBuilder;\n        }());\n        function getScopeIdentity(source, index, value, valueType) {\n            var identities = source.identities;\n            if (identities) {\n                return identities[index];\n            }\n            debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\n            return data_4.createDataViewScopeIdentity(SQExprBuilder.equal(source.fields[0], SQExprBuilder.typedConstant(value, valueType)));\n        }\n        function pushIfNotExists(items, itemToAdd) {\n            if (_.contains(items, itemToAdd))\n                return;\n            items.push(itemToAdd);\n        }\n        function applySeriesData(target, source, categoryLength) {\n            debug.assertValue(target, 'target');\n            debug.assertValue(source, 'source');\n            debug.assertValue(categoryLength, 'categoryLength');\n            var values = source.values;\n            debug.assert(categoryLength === values.length, 'categoryLength === values.length');\n            target.values = values;\n            var highlights = source.highlights;\n            if (highlights) {\n                debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\n                target.highlights = highlights;\n            }\n            if (source.minLocal !== undefined)\n                target.minLocal = source.minLocal;\n            if (source.maxLocal !== undefined)\n                target.maxLocal = source.maxLocal;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExpr = powerbi.data.SQExpr;\n        function createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n            return new StaticEvalContext(colorAllocatorCache || data.createColorAllocatorCache(), dataView || { metadata: { columns: [] } }, selectTransforms);\n        }\n        data.createStaticEvalContext = createStaticEvalContext;\n        /**\n         * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\n         * are supported.\n         */\n        var StaticEvalContext = (function () {\n            function StaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorCache = colorAllocatorCache;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            StaticEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorCache.get(expr);\n            };\n            StaticEvalContext.prototype.getExprValue = function (expr) {\n                var dataView = this.dataView, selectTransforms = this.selectTransforms;\n                if (dataView && dataView.table && selectTransforms)\n                    return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\n            };\n            StaticEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            return StaticEvalContext;\n        }());\n        function getExprValueFromTable(expr, selectTransforms, table, rowIdx) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            debug.assertValue(table, 'table');\n            debug.assertValue(rowIdx, 'rowIdx');\n            var rows = table.rows;\n            if (_.isEmpty(rows) || rows.length <= rowIdx)\n                return;\n            var cols = table.columns;\n            for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                var selectTransform = selectTransforms[selectIdx];\n                if (!SQExpr.equals(selectTransform.expr, expr) || !selectTransform.queryName)\n                    continue;\n                for (var colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\n                    if (selectIdx !== cols[colIdx].index)\n                        continue;\n                    return rows[rowIdx][colIdx];\n                }\n            }\n        }\n        data.getExprValueFromTable = getExprValueFromTable;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createMatrixEvalContext(colorAllocatorProvider, dataViewMatrix) {\n            // NOTE: Matrix context-sensitive evaluation is not yet implemented.\n            return data.createStaticEvalContext(colorAllocatorProvider);\n        }\n        data.createMatrixEvalContext = createMatrixEvalContext;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi_1) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var Formatting = jsCommon.Formatting;\n    var RegExpExtensions = jsCommon.RegExpExtensions;\n    /** Formatting Encoder */\n    var FormattingEncoder;\n    (function (FormattingEncoder) {\n        function preserveEscaped(format, specialChars) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = \"\\\\\" + specialChars[i];\n                var newText = String.fromCharCode(0xE000 + i);\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveEscaped = preserveEscaped;\n        function restoreEscaped(format, specialChars) {\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = String.fromCharCode(0xE000 + i);\n                var newText = specialChars[i];\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\n        }\n        FormattingEncoder.restoreEscaped = restoreEscaped;\n        function preserveLiterals(format, literals) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            for (var i = 0;; i++) {\n                var fromIndex = format.indexOf(\"'\");\n                if (fromIndex < 0) {\n                    break;\n                }\n                var toIndex = format.indexOf(\"'\", fromIndex + 1);\n                if (toIndex < 0) {\n                    break;\n                }\n                var literal = format.substring(fromIndex, toIndex + 1);\n                literals.push(literal.substring(1, toIndex - fromIndex));\n                var token = String.fromCharCode(0xE100 + i);\n                format = format.replace(literal, token);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveLiterals = preserveLiterals;\n        function restoreLiterals(format, literals) {\n            var count = literals.length;\n            for (var i = 0; i < count; i++) {\n                var token = String.fromCharCode(0xE100 + i);\n                var literal = literals[i];\n                format = format.replace(token, literal);\n            }\n            return format;\n        }\n        FormattingEncoder.restoreLiterals = restoreLiterals;\n    })(FormattingEncoder || (FormattingEncoder = {}));\n    var IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\n    var ZeroPlaceholder = '0';\n    var DigitPlaceholder = '#';\n    var ExponentialFormatChar = 'E';\n    var NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\n    var NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\n    /** Formatting Service */\n    var FormattingService = (function () {\n        function FormattingService() {\n        }\n        FormattingService.prototype.formatValue = function (value, format, culture) {\n            // Handle special cases\n            if (value === undefined || value === null) {\n                return '';\n            }\n            var gculture = this.getCulture(culture);\n            if (DateTimeFormat.canFormat(value)) {\n                // Dates\n                return DateTimeFormat.format(value, format, gculture);\n            }\n            else if (NumberFormat.canFormat(value)) {\n                // Numbers\n                return NumberFormat.format(value, format, gculture);\n            }\n            else {\n                // Other data types - return as string\n                return value.toString();\n            }\n        };\n        FormattingService.prototype.format = function (formatWithIndexedTokens, args, culture) {\n            var _this = this;\n            if (!formatWithIndexedTokens) {\n                return \"\";\n            }\n            var result = formatWithIndexedTokens.replace(IndexedTokensRegex, function (match, left, right, argToken) {\n                if (left) {\n                    return \"{\";\n                }\n                else if (right) {\n                    return \"}\";\n                }\n                else {\n                    var parts = argToken.split(\":\");\n                    var argIndex = parseInt(parts[0], 10);\n                    var argFormat = parts[1];\n                    return _this.formatValue(args[argIndex], argFormat, culture);\n                }\n            });\n            return result;\n        };\n        FormattingService.prototype.isStandardNumberFormat = function (format) {\n            return NumberFormat.isStandardFormat(format);\n        };\n        FormattingService.prototype.formatNumberWithCustomOverride = function (value, format, nonScientificOverrideFormat, culture) {\n            var gculture = this.getCulture(culture);\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\n        };\n        FormattingService.prototype.dateFormatString = function (unit) {\n            if (!this._dateTimeScaleFormatInfo)\n                this.initialize();\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\n        };\n        /**\n         * Sets the current localization culture\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         */\n        FormattingService.prototype.setCurrentCulture = function (cultureSelector) {\n            if (this._currentCultureSelector !== cultureSelector) {\n                this._currentCulture = this.getCulture(cultureSelector);\n                this._currentCultureSelector = cultureSelector;\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\n            }\n        };\n        /**\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         * Exposing this function for testability of unsupported cultures\n         */\n        FormattingService.prototype.getCulture = function (cultureSelector) {\n            if (cultureSelector == null) {\n                if (this._currentCulture == null) {\n                    this.initialize();\n                }\n                return this._currentCulture;\n            }\n            else {\n                var culture = Globalize.findClosestCulture(cultureSelector);\n                if (!culture)\n                    culture = Globalize.culture(\"en-US\");\n                return culture;\n            }\n        };\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\n        FormattingService.prototype.initialize = function () {\n            var cultureName = this.getCurrentCulture();\n            this.setCurrentCulture(cultureName);\n            var calendarName = this.getUrlParam(\"calendar\");\n            if (calendarName) {\n                var culture = this._currentCulture;\n                var c = culture.calendars[calendarName];\n                if (c) {\n                    culture.calendar = c;\n                }\n            }\n        };\n        /**\n         *  Exposing this function for testability\n         */\n        FormattingService.prototype.getCurrentCulture = function () {\n            var urlParam = this.getUrlParam(\"language\");\n            if (urlParam) {\n                return urlParam;\n            }\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\n                // Get cultureInfo set in powerbi\n                return powerbi.common.cultureInfo;\n            }\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\n        };\n        /**\n         *  Exposing this function for testability\n         *  @param name: queryString name\n         */\n        FormattingService.prototype.getUrlParam = function (name) {\n            var param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\n            return param ? param[1] : undefined;\n        };\n        return FormattingService;\n    }());\n    /**\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for dates.\n     */\n    var DateTimeFormat;\n    (function (DateTimeFormat) {\n        var _currentCachedFormat;\n        var _currentCachedProcessedFormat;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = value instanceof Date;\n            return result;\n        }\n        DateTimeFormat.canFormat = canFormat;\n        /** Formats the date using provided format and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            var isStandard = format.length === 1;\n            try {\n                if (isStandard) {\n                    return formatDateStandard(value, format, culture);\n                }\n                else {\n                    return formatDateCustom(value, format, culture);\n                }\n            }\n            catch (e) {\n                return formatDateStandard(value, \"G\", culture);\n            }\n        }\n        DateTimeFormat.format = format;\n        /** Formats the date using standard format expression */\n        function formatDateStandard(value, format, culture) {\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\n            var patterns = culture.calendar.patterns;\n            // Extend supported set of patterns\n            ensurePatterns(culture.calendar);\n            // Handle extended set of formats\n            var output = Formatting.findDateFormat(value, format, culture.name);\n            if (output.format.length === 1)\n                format = patterns[output.format];\n            else\n                format = output.format;\n            //need to revisit when globalization is enabled\n            culture = Globalize.culture(\"en-US\");\n            return Globalize.format(output.value, format, culture);\n        }\n        /** Formats the date using custom format expression */\n        function formatDateCustom(value, format, culture) {\n            var result;\n            var literals = [];\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            format = FormattingEncoder.preserveLiterals(format, literals);\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            if (format.indexOf(\"F\") > -1) {\n                // F is not supported so we need to replace the F with f based on the milliseconds\n                // Replace all sequences of F longer than 3 with \"FFF\"\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\n                // Based on milliseconds update the format to use fff\n                var milliseconds = value.getMilliseconds();\n                if (milliseconds % 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\n                if ((milliseconds % 100) / 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\n                if ((milliseconds % 1000) / 100 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\n                }\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\n                if (format === \"\" || format === \"%\")\n                    return \"\";\n            }\n            format = processCustomDateTimeFormat(format);\n            result = Globalize.format(value, format, culture);\n            result = localize(result, culture.calendar);\n            result = FormattingEncoder.restoreLiterals(result, literals);\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            return result;\n        }\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\n        function processCustomDateTimeFormat(format) {\n            if (format === _currentCachedFormat) {\n                return _currentCachedProcessedFormat;\n            }\n            _currentCachedFormat = format;\n            format = Formatting.fixDateTimeFormat(format);\n            _currentCachedProcessedFormat = format;\n            return format;\n        }\n        /** Localizes the time separator symbol */\n        function localize(value, dictionary) {\n            var timeSeparator = dictionary[\":\"];\n            if (timeSeparator === \":\") {\n                return value;\n            }\n            var result = \"\";\n            var count = value.length;\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \":\":\n                        result += timeSeparator;\n                        break;\n                    default:\n                        result += char;\n                        break;\n                }\n            }\n            return result;\n        }\n        function ensurePatterns(calendar) {\n            var patterns = calendar.patterns;\n            if (patterns[\"g\"] === undefined) {\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, short time\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, long time\n            }\n        }\n    })(DateTimeFormat || (DateTimeFormat = {}));\n    /**\n     * NumberFormat module contains the static methods for formatting the numbers.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for numeric types including custom formats.\n     */\n    var NumberFormat;\n    (function (NumberFormat) {\n        var NonScientificFormatRegex = /^\\{.+\\}.*/;\n        var NumericalPlaceHolderRegex = /\\{.+\\}/;\n        var ScientificFormatRegex = /e[+-]*[0#]+/i;\n        var StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\n        var TrailingZerosRegex = /0+$/;\n        var DecimalFormatRegex = /\\.([0#]*)/g;\n        var NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\n        var LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\n        var DecimalFormatCharacter = '.';\n        NumberFormat.NumberFormatComponentsDelimeter = ';';\n        function getNonScientificFormatWithPrecision(baseFormat, numericFormat) {\n            if (!numericFormat || baseFormat === undefined)\n                return baseFormat;\n            var newFormat = \"{0:\" + numericFormat + \"}\";\n            return baseFormat.replace(\"{0}\", newFormat);\n        }\n        function getNumericFormat(value, baseFormat) {\n            if (baseFormat == null)\n                return baseFormat;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                if (value > 0)\n                    return getNumericFormatFromComponent(value, positive);\n                else if (value === 0)\n                    return getNumericFormatFromComponent(value, zero);\n                return getNumericFormatFromComponent(value, negative);\n            }\n            return getNumericFormatFromComponent(value, baseFormat);\n        }\n        NumberFormat.getNumericFormat = getNumericFormat;\n        function getNumericFormatFromComponent(value, format) {\n            var match = RegExpExtensions.run(NumericFormatRegex, format);\n            if (match)\n                return match[0];\n            return format;\n        }\n        function addDecimalsToFormat(baseFormat, decimals, trailingZeros) {\n            if (decimals == null)\n                return baseFormat;\n            // Default format string\n            if (baseFormat == null)\n                baseFormat = ZeroPlaceholder;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                var formats = [positive, negative, zero];\n                for (var i = 0; i < formats.length; i++) {\n                    // Update format in formats array\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\n                }\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\n            }\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\n        }\n        NumberFormat.addDecimalsToFormat = addDecimalsToFormat;\n        function addDecimalsToFormatComponent(format, decimals, trailingZeros) {\n            decimals = Math.abs(decimals);\n            if (decimals >= 0) {\n                var placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\n                var decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\n                var match = RegExpExtensions.run(DecimalFormatRegex, format);\n                if (match) {\n                    var beforeDecimal = format.substr(0, match.index);\n                    var formatDecimal = format.substr(match.index + 1, match[1].length);\n                    var afterDecimal = format.substr(match.index + match[0].length);\n                    if (trailingZeros)\n                        // Use explicit decimals argument as placeholders\n                        formatDecimal = decimalPlaceholders;\n                    else {\n                        var decimalChange = decimalPlaceholders.length - formatDecimal.length;\n                        if (decimalChange > 0)\n                            // Append decimalPlaceholders to existing decimal portion of format string\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\n                        else if (decimalChange < 0)\n                            // Remove decimals from formatDecimal\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\n                    }\n                    if (formatDecimal.length > 0)\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\n                    return beforeDecimal + formatDecimal + afterDecimal;\n                }\n                else if (decimalPlaceholders.length > 0)\n                    // Replace last numeric placeholder with decimal portion\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\n            }\n            return format;\n        }\n        function hasFormatComponents(format) {\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\n        }\n        NumberFormat.hasFormatComponents = hasFormatComponents;\n        function getComponents(format) {\n            var signFormat = {\n                hasNegative: false,\n                positive: format,\n                negative: format,\n                zero: format,\n            };\n            var signSpecificFormats = format.split(NumberFormat.NumberFormatComponentsDelimeter);\n            var formatCount = signSpecificFormats.length;\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\n            if (formatCount > 1) {\n                signFormat.hasNegative = true;\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\n                signFormat.negative = signSpecificFormats[1];\n                if (formatCount > 2)\n                    signFormat.zero = signSpecificFormats[2];\n            }\n            return signFormat;\n        }\n        NumberFormat.getComponents = getComponents;\n        var _lastCustomFormatMeta;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = typeof (value) === \"number\";\n            return result;\n        }\n        NumberFormat.canFormat = canFormat;\n        function isStandardFormat(format) {\n            debug.assertValue(format, 'format');\n            return StandardFormatRegex.test(format);\n        }\n        NumberFormat.isStandardFormat = isStandardFormat;\n        /** Formats the number using specified format expression and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            try {\n                if (isStandardFormat(format))\n                    return formatNumberStandard(value, format, culture);\n                return formatNumberCustom(value, format, culture);\n            }\n            catch (e) {\n                return Globalize.format(value, undefined, culture);\n            }\n        }\n        NumberFormat.format = format;\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\n        function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {\n            debug.assertValue(value, 'value');\n            debug.assertValue(format, 'format');\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\n            debug.assertValue(culture, 'culture');\n            debug.assert(!isStandardFormat(format), 'Standard format');\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\n        }\n        NumberFormat.formatWithCustomOverride = formatWithCustomOverride;\n        /** Formats the number using standard format expression */\n        function formatNumberStandard(value, format, culture) {\n            var result;\n            var precision = (format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\n            var numberFormatInfo = culture.numberFormat;\n            var formatChar = format.charAt(0);\n            switch (formatChar) {\n                case \"e\":\n                case \"E\":\n                    if (precision === undefined) {\n                        precision = 6;\n                    }\n                    var mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\n                    result = formatNumberCustom(value, format, culture);\n                    break;\n                case \"f\":\n                case \"F\":\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"g\":\n                case \"G\":\n                    var abs = Math.abs(value);\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\n                    }\n                    else {\n                        // Otherwise use exponential\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\n                        result = result.replace(\"e\", \"E\");\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"r\":\n                case \"R\":\n                    result = value.toString();\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"x\":\n                case \"X\":\n                    result = value.toString(16);\n                    if (formatChar === \"X\") {\n                        result = result.toUpperCase();\n                    }\n                    if (precision !== undefined) {\n                        var actualPrecision = result.length;\n                        var isNegative = value < 0;\n                        if (isNegative) {\n                            actualPrecision--;\n                        }\n                        var paddingZerosCount = precision - actualPrecision;\n                        var paddingZeros = undefined;\n                        if (paddingZerosCount > 0) {\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\n                        }\n                        if (isNegative) {\n                            result = \"-\" + paddingZeros + result.substr(1);\n                        }\n                        else {\n                            result = paddingZeros + result;\n                        }\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                default:\n                    result = Globalize.format(value, format, culture);\n            }\n            return result;\n        }\n        /** Formats the number using custom format expression */\n        function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {\n            var result;\n            var numberFormatInfo = culture.numberFormat;\n            if (isFinite(value)) {\n                // Split format by positive[;negative;zero] pattern\n                var formatComponents = getComponents(format);\n                // Pick a format based on the sign of value\n                if (value > 0) {\n                    format = formatComponents.positive;\n                }\n                else if (value === 0) {\n                    format = formatComponents.zero;\n                }\n                else {\n                    format = formatComponents.negative;\n                }\n                // Normalize value if we have an explicit negative format\n                if (formatComponents.hasNegative)\n                    value = Math.abs(value);\n                // Get format metadata\n                var formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\n                // Preserve literals and escaped chars\n                if (formatMeta.hasEscapes) {\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%\");\n                }\n                var literals = [];\n                if (formatMeta.hasQuotes) {\n                    format = FormattingEncoder.preserveLiterals(format, literals);\n                }\n                // Scientific format\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\n                    var scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\n                    if (scientificMatch) {\n                        // Case 2.1. Scientific custom format\n                        var formatM = format.substr(0, scientificMatch.index);\n                        var formatE = format.substr(scientificMatch.index + 2); // E(+|-)\n                        var precision = getCustomFormatPrecision(formatM, formatMeta);\n                        var scale = getCustomFormatScale(formatM, formatMeta);\n                        if (scale !== 1) {\n                            value = value * scale;\n                        }\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        var s = value.toExponential(precision);\n                        var indexOfE = s.indexOf(\"e\");\n                        var mantissa = s.substr(0, indexOfE);\n                        var exp = s.substr(indexOfE + 1);\n                        var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\n                        var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\n                            resultE = resultE.substr(1);\n                        }\n                        var e = scientificMatch[0].charAt(0);\n                        result = resultM + e + resultE;\n                    }\n                }\n                // Non scientific format\n                if (result === undefined) {\n                    var valueFormatted = void 0;\n                    var isValueGlobalized = false;\n                    var precision = getCustomFormatPrecision(format, formatMeta);\n                    var scale = getCustomFormatScale(format, formatMeta);\n                    if (scale !== 1)\n                        value = value * scale;\n                    // Rounding\n                    value = parseFloat(toNonScientific(value, precision));\n                    if (nonScientificOverrideFormat) {\n                        // Get numeric format from format string\n                        var numericFormat = NumberFormat.getNumericFormat(value, format);\n                        // Add separators and decimalFormat to nonScientificFormat\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\n                        // Format the value\n                        valueFormatted = powerbi_1.formattingService.format(nonScientificOverrideFormat, [value], culture.name);\n                        isValueGlobalized = true;\n                    }\n                    else\n                        valueFormatted = toNonScientific(value, precision);\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\n                }\n                if (formatMeta.hasQuotes) {\n                    result = FormattingEncoder.restoreLiterals(result, literals);\n                }\n                if (formatMeta.hasEscapes) {\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%\");\n                }\n                _lastCustomFormatMeta = formatMeta;\n            }\n            else {\n                return Globalize.format(value, undefined);\n            }\n            return result;\n        }\n        /** Returns string with the fixed point respresentation of the number */\n        function toNonScientific(value, precision) {\n            var result = \"\";\n            var precisionZeros = 0;\n            // Double precision numbers support actual 15-16 decimal digits of precision.\n            if (precision > 16) {\n                precisionZeros = precision - 16;\n                precision = 16;\n            }\n            var digitsBeforeDecimalPoint = powerbi_1.Double.log10(Math.abs(value));\n            if (digitsBeforeDecimalPoint < 16) {\n                if (digitsBeforeDecimalPoint > 0) {\n                    var maxPrecision = 16 - digitsBeforeDecimalPoint;\n                    if (precision > maxPrecision) {\n                        precisionZeros += precision - maxPrecision;\n                        precision = maxPrecision;\n                    }\n                }\n                result = value.toFixed(precision);\n            }\n            else if (digitsBeforeDecimalPoint === 16) {\n                result = value.toFixed(0);\n                precisionZeros += precision;\n                if (precisionZeros > 0) {\n                    result += \".\";\n                }\n            }\n            else {\n                // Different browsers have different implementations of the toFixed().\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\n                // So we need to check for range and convert the to exponential with the max precision.\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\n                // Assert that value is a number and fall back on returning value if it is not\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                if (typeof (value) !== \"number\")\n                    return String(value);\n                result = value.toExponential(15);\n                var indexOfE = result.indexOf(\"e\");\n                if (indexOfE > 0) {\n                    var indexOfDot = result.indexOf(\".\");\n                    var mantissa = result.substr(0, indexOfE);\n                    var exp = result.substr(indexOfE + 1);\n                    var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\n                    if (precision > 0) {\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\n                    }\n                }\n            }\n            if (precisionZeros > 0) {\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\n            }\n            return result;\n        }\n        /**\n         * Returns the formatMetadata of the format\n         * When calculating precision and scale, if format string of\n         * positive[;negative;zero] => positive format will be used\n         * @param (required) format - format string\n         * @param (optional) calculatePrecision - calculate precision of positive format\n         * @param (optional) calculateScale - calculate scale of positive format\n         */\n        function getCustomFormatMetadata(format, calculatePrecision, calculateScale) {\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\n                return _lastCustomFormatMeta;\n            }\n            var result = {\n                format: format,\n                hasEscapes: false,\n                hasQuotes: false,\n                hasE: false,\n                hasCommas: false,\n                hasDots: false,\n                hasPercent: false,\n                hasPermile: false,\n                precision: undefined,\n                scale: undefined,\n            };\n            for (var i = 0, length_1 = format.length; i < length_1; i++) {\n                var c = format.charAt(i);\n                switch (c) {\n                    case \"\\\\\":\n                        result.hasEscapes = true;\n                        break;\n                    case \"'\":\n                    case \"\\\"\":\n                        result.hasQuotes = true;\n                        break;\n                    case \"e\":\n                    case \"E\":\n                        result.hasE = true;\n                        break;\n                    case \",\":\n                        result.hasCommas = true;\n                        break;\n                    case \".\":\n                        result.hasDots = true;\n                        break;\n                    case \"%\":\n                        result.hasPercent = true;\n                        break;\n                    case \"\":\n                        result.hasPermile = true;\n                        break;\n                }\n            }\n            // Use positive format for calculating these values\n            var formatComponents = getComponents(format);\n            if (calculatePrecision)\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\n            if (calculateScale)\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\n            return result;\n        }\n        NumberFormat.getCustomFormatMetadata = getCustomFormatMetadata;\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\n        function getCustomFormatPrecision(format, formatMeta) {\n            if (formatMeta.precision > -1) {\n                return formatMeta.precision;\n            }\n            var result = 0;\n            if (formatMeta.hasDots) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex > -1) {\n                    var count = format.length;\n                    for (var i = dotIndex; i < count; i++) {\n                        var char = format.charAt(i);\n                        if (char.match(NumericPlaceholderRegex))\n                            result++;\n                        // 0.00E+0 :: Break before counting 0 in\n                        // exponential portion of format string\n                        if (char === ExponentialFormatChar)\n                            break;\n                    }\n                    result = Math.min(19, result);\n                }\n            }\n            formatMeta.precision = result;\n            return result;\n        }\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\n        function getCustomFormatScale(format, formatMeta) {\n            if (formatMeta.scale > -1) {\n                return formatMeta.scale;\n            }\n            var result = 1;\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\n                result = result * 100;\n            }\n            if (formatMeta.hasPermile && format.indexOf(\"\") > -1) {\n                result = result * 1000;\n            }\n            if (formatMeta.hasCommas) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex === -1) {\n                    dotIndex = format.length;\n                }\n                for (var i = dotIndex - 1; i > -1; i--) {\n                    var char = format.charAt(i);\n                    if (char === \",\") {\n                        result = result / 1000;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            formatMeta.scale = result;\n            return result;\n        }\n        function fuseNumberWithCustomFormat(value, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized) {\n            var suppressModifyValue = !!nonScientificOverrideFormat;\n            var formatParts = format.split(\".\", 2);\n            if (formatParts.length === 2) {\n                var wholeFormat = formatParts[0];\n                var fractionFormat = formatParts[1];\n                var displayUnit = \"\";\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\n                if (nonScientificOverrideFormat) {\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\n                    value = value.replace(displayUnit, \"\");\n                }\n                var globalizedDecimalSeparator = numberFormatInfo[\".\"];\n                var decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\n                var valueParts = value.split(decimalSeparator, 2);\n                var wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\n                var fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\n                var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\n                var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\n                    return wholeFormattedValue + fractionFormattedValue.value;\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\n            }\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\n        }\n        function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {\n            var groupSymbolIndex = format.indexOf(\",\");\n            var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\n            var groupDigitCount = 0;\n            var groupIndex = 0;\n            var groupSizes = numberFormatInfo.groupSizes || [3];\n            var groupSize = groupSizes[0];\n            var groupSeparator = numberFormatInfo[\",\"];\n            var sign = \"\";\n            var firstChar = value.charAt(0);\n            if (firstChar === \"+\" || firstChar === \"-\") {\n                sign = numberFormatInfo[firstChar];\n                value = value.substr(1);\n            }\n            var isZero = value === \"0\";\n            var result = \"\";\n            var leftBuffer = \"\";\n            var vi = value.length - 1;\n            var fmtOnly = true;\n            // Iterate through format chars and replace 0 and # with the digits from the value string\n            for (var fi = format.length - 1; fi > -1; fi--) {\n                var formatChar = format.charAt(fi);\n                switch (formatChar) {\n                    case ZeroPlaceholder:\n                    case DigitPlaceholder:\n                        fmtOnly = false;\n                        if (leftBuffer !== \"\") {\n                            result = leftBuffer + result;\n                            leftBuffer = \"\";\n                        }\n                        if (!suppressModifyValue) {\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\n                                if (enableGroups) {\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\n                                    if (groupDigitCount === groupSize) {\n                                        result = groupSeparator + result;\n                                        groupIndex++;\n                                        if (groupIndex < groupSizes.length) {\n                                            groupSize = groupSizes[groupIndex];\n                                        }\n                                        groupDigitCount = 1;\n                                    }\n                                    else {\n                                        groupDigitCount++;\n                                    }\n                                }\n                            }\n                            if (vi > -1) {\n                                if (isZero && formatChar === DigitPlaceholder) {\n                                }\n                                else {\n                                    result = value.charAt(vi) + result;\n                                }\n                                vi--;\n                            }\n                            else if (formatChar !== DigitPlaceholder) {\n                                result = formatChar + result;\n                            }\n                        }\n                        break;\n                    case \",\":\n                        // We should skip all the , chars\n                        break;\n                    default:\n                        leftBuffer = formatChar + leftBuffer;\n                        break;\n                }\n            }\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\n            if (!suppressModifyValue) {\n                if (vi > -1 && result !== \"\") {\n                    if (enableGroups) {\n                        while (vi > -1) {\n                            if (groupDigitCount === groupSize) {\n                                result = groupSeparator + result;\n                                groupIndex++;\n                                if (groupIndex < groupSizes.length) {\n                                    groupSize = groupSizes[groupIndex];\n                                }\n                                groupDigitCount = 1;\n                            }\n                            else {\n                                groupDigitCount++;\n                            }\n                            result = value.charAt(vi) + result;\n                            vi--;\n                        }\n                    }\n                    else {\n                        result = value.substr(0, vi + 1) + result;\n                    }\n                }\n                // Insert sign in front of the leftBuffer and result\n                return sign + leftBuffer + result;\n            }\n            if (fmtOnly)\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\n                return sign + leftBuffer + result;\n            return sign + leftBuffer + value + result;\n        }\n        function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {\n            var vi = 0;\n            var fCount = format.length;\n            var vCount = value.length;\n            if (suppressModifyValue) {\n                debug.assert(fCount > 0, \"Empty formatting string\");\n                var lastChar = format.charAt(fCount - 1);\n                if (!lastChar.match(NumericPlaceholderRegex))\n                    return {\n                        value: value + lastChar,\n                        fmtOnly: value === \"\",\n                    };\n                return {\n                    value: value,\n                    fmtOnly: value === \"\",\n                };\n            }\n            var result = \"\", fmtOnly = true;\n            for (var fi = 0; fi < fCount; fi++) {\n                var formatChar = format.charAt(fi);\n                if (vi < vCount) {\n                    switch (formatChar) {\n                        case ZeroPlaceholder:\n                        case DigitPlaceholder:\n                            result += value[vi++];\n                            fmtOnly = false;\n                            break;\n                        default:\n                            result += formatChar;\n                    }\n                }\n                else {\n                    if (formatChar !== DigitPlaceholder) {\n                        result += formatChar;\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\n                    }\n                }\n            }\n            return {\n                value: result,\n                fmtOnly: fmtOnly,\n            };\n        }\n        function localize(value, dictionary) {\n            var plus = dictionary[\"+\"];\n            var minus = dictionary[\"-\"];\n            var dot = dictionary[\".\"];\n            var comma = dictionary[\",\"];\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\n                return value;\n            }\n            var count = value.length;\n            var result = \"\";\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \"+\":\n                        result = result + plus;\n                        break;\n                    case \"-\":\n                        result = result + minus;\n                        break;\n                    case \".\":\n                        result = result + dot;\n                        break;\n                    case \",\":\n                        result = result + comma;\n                        break;\n                    default:\n                        result = result + char;\n                        break;\n                }\n            }\n            return result;\n        }\n    })(NumberFormat = powerbi_1.NumberFormat || (powerbi_1.NumberFormat = {}));\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\n    var DateTimeScaleFormatInfo = (function () {\n        // Constructor\n        /**\n         * Creates new instance of the DateTimeScaleFormatInfo class.\n         * @param culture - culture which calendar info is going to be used to derive the formats.\n         */\n        function DateTimeScaleFormatInfo(culture) {\n            var calendar = culture.calendar;\n            var patterns = calendar.patterns;\n            var monthAbbreviations = calendar[\"months\"][\"namesAbbr\"];\n            var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];\n            var yearMonthPattern = patterns[\"Y\"];\n            var monthDayPattern = patterns[\"M\"];\n            var fullPattern = patterns[\"f\"];\n            var longTimePattern = patterns[\"T\"];\n            var shortTimePattern = patterns[\"t\"];\n            var separator = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\n            var hasYearSymbol = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\n            var yearPos = fullPattern.indexOf(\"yy\");\n            var monthPos = fullPattern.indexOf(\"MMMM\");\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\n            var minutePos = fullPattern.indexOf(\"mm\");\n            var pmPos = fullPattern.indexOf(\"tt\");\n            var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\n            this.MinutePattern = shortTimePattern;\n            this.SecondPattern = longTimePattern;\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\n            // Special cases\n            switch (culture.name) {\n                case \"fi-FI\":\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\n                    break;\n            }\n        }\n        // Methods\n        /**\n         * Returns the format string of the provided DateTimeUnit.\n         * @param unit - date or time unit\n         */\n        DateTimeScaleFormatInfo.prototype.getFormatString = function (unit) {\n            switch (unit) {\n                case powerbi_1.DateTimeUnit.Year:\n                    return this.YearPattern;\n                case powerbi_1.DateTimeUnit.Month:\n                    return this.MonthPattern;\n                case powerbi_1.DateTimeUnit.Week:\n                case powerbi_1.DateTimeUnit.Day:\n                    return this.DayPattern;\n                case powerbi_1.DateTimeUnit.Hour:\n                    return this.HourPattern;\n                case powerbi_1.DateTimeUnit.Minute:\n                    return this.MinutePattern;\n                case powerbi_1.DateTimeUnit.Second:\n                    return this.SecondPattern;\n                case powerbi_1.DateTimeUnit.Millisecond:\n                    return this.MillisecondPattern;\n            }\n            debug.assertFail('Unexpected unit: ' + unit);\n        };\n        return DateTimeScaleFormatInfo;\n    }());\n    powerbi_1.formattingService = new FormattingService();\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\n        var SQExprShortSerializer;\n        (function (SQExprShortSerializer) {\n            function serialize(expr) {\n                return JSON.stringify(expr.accept(SQExprSerializer.instance));\n            }\n            SQExprShortSerializer.serialize = serialize;\n            function serializeArray(exprs) {\n                var str = '[';\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    if (i > 0)\n                        str += ',';\n                    str += SQExprShortSerializer.serialize(exprs[i]);\n                }\n                return str + ']';\n            }\n            SQExprShortSerializer.serializeArray = serializeArray;\n            /** Responsible for serializing an SQExpr into a comparable string. */\n            var SQExprSerializer = (function (_super) {\n                __extends(SQExprSerializer, _super);\n                function SQExprSerializer() {\n                    _super.apply(this, arguments);\n                }\n                SQExprSerializer.prototype.visitColumnRef = function (expr) {\n                    return {\n                        col: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitMeasureRef = function (expr) {\n                    return {\n                        measure: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitAggr = function (expr) {\n                    return {\n                        agg: {\n                            a: expr.arg.accept(this),\n                            f: expr.func,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitEntity = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    debug.assertValue(expr.entity, 'expr.entity');\n                    return {\n                        e: expr.entity\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchyLevel = function (expr) {\n                    return {\n                        h: expr.arg.accept(this),\n                        l: expr.level,\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchy = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        h: expr.hierarchy,\n                    };\n                };\n                SQExprSerializer.prototype.visitPropertyVariationSource = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        n: expr.name,\n                        p: expr.property,\n                    };\n                };\n                SQExprSerializer.prototype.visitAnd = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        and: {\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitCompare = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        comp: {\n                            k: expr.comparison,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitConstant = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        const: {\n                            t: expr.type.primitiveType,\n                            v: expr.value,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitArithmetic = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        arithmetic: {\n                            o: expr.operator,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitScopedEval = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        scopedEval: {\n                            e: expr.expression.accept(this),\n                            s: serializeArray(expr.scope)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitDefault = function (expr) {\n                    debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\n                    return;\n                };\n                SQExprSerializer.instance = new SQExprSerializer();\n                return SQExprSerializer;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprShortSerializer = data.SQExprShortSerializer || (data.SQExprShortSerializer = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var Selector = powerbi.data.Selector;\n        /**\n         * A combination of identifiers used to uniquely identify\n         * data points and their bound geometry.\n         */\n        var SelectionId = (function () {\n            function SelectionId(selector, highlight) {\n                this.selector = selector;\n                this.highlight = highlight;\n                this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\n                this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\n            }\n            SelectionId.prototype.equals = function (other) {\n                if (!this.selector || !other.selector) {\n                    return (!this.selector === !other.selector) && this.highlight === other.highlight;\n                }\n                return this.highlight === other.highlight && Selector.equals(this.selector, other.selector);\n            };\n            /**\n             * Checks equality against other for all identifiers existing in this.\n             */\n            SelectionId.prototype.includes = function (other, ignoreHighlight) {\n                if (ignoreHighlight === void 0) { ignoreHighlight = false; }\n                var thisSelector = this.selector;\n                var otherSelector = other.selector;\n                if (!thisSelector || !otherSelector) {\n                    return false;\n                }\n                var thisData = thisSelector.data;\n                var otherData = otherSelector.data;\n                if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\n                    return false;\n                if (!ignoreHighlight && this.highlight !== other.highlight)\n                    return false;\n                if (thisData) {\n                    if (!otherData)\n                        return false;\n                    if (thisData.length > 0) {\n                        for (var i = 0, ilen = thisData.length; i < ilen; i++) {\n                            var thisValue = thisData[i];\n                            if (!otherData.some(function (otherValue) { return powerbi.DataViewScopeIdentity.equals(thisValue, otherValue); }))\n                                return false;\n                        }\n                    }\n                }\n                return true;\n            };\n            SelectionId.prototype.getKey = function () {\n                return this.key;\n            };\n            SelectionId.prototype.getKeyWithoutHighlight = function () {\n                return this.keyWithoutHighlight;\n            };\n            /**\n             * Temporary workaround since a few things currently rely on this, but won't need to.\n             */\n            SelectionId.prototype.hasIdentity = function () {\n                return (this.selector && !!this.selector.data);\n            };\n            SelectionId.prototype.getSelector = function () {\n                return this.selector;\n            };\n            SelectionId.prototype.getSelectorsByColumn = function () {\n                return this.selectorsByColumn;\n            };\n            SelectionId.createNull = function (highlight) {\n                if (highlight === void 0) { highlight = false; }\n                return new SelectionId(null, highlight);\n            };\n            SelectionId.createWithId = function (id, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                if (id) {\n                    selector = {\n                        data: [id]\n                    };\n                }\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithMeasure = function (measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                debug.assertValue(measureId, 'measureId');\n                var selector = {\n                    metadata: measureId\n                };\n                var selectionId = new SelectionId(selector, highlight);\n                selectionId.selectorsByColumn = { metadata: measureId };\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasure = function (id, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                if (id) {\n                    selector.data = [id];\n                }\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id && !measureId)\n                    selector = null;\n                var selectionId = new SelectionId(selector, highlight);\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasureAndCategory = function (id, measureId, queryName, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\n                if (selectionId.selector) {\n                    selectionId.selectorsByColumn = {};\n                    if (id && queryName) {\n                        selectionId.selectorsByColumn.dataMap = {};\n                        selectionId.selectorsByColumn.dataMap[queryName] = id;\n                    }\n                    if (measureId)\n                        selectionId.selectorsByColumn.metadata = measureId;\n                }\n                return selectionId;\n            };\n            SelectionId.createWithIds = function (id1, id2, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector = { data: selectorData };\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithIdsAndMeasure = function (id1, id2, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector.data = selectorData;\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id1 && !id2 && !measureId)\n                    selector = null;\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithSelectorForColumnAndMeasure = function (dataMap, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId;\n                var keys = Object.keys(dataMap);\n                if (keys.length === 2) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], dataMap[keys[1]], measureId, highlight);\n                }\n                else if (keys.length === 1) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], null, measureId, highlight);\n                }\n                else {\n                    selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\n                }\n                var selectorsByColumn = {};\n                if (!_.isEmpty(dataMap))\n                    selectorsByColumn.dataMap = dataMap;\n                if (measureId)\n                    selectorsByColumn.metadata = measureId;\n                if (!dataMap && !measureId)\n                    selectorsByColumn = null;\n                selectionId.selectorsByColumn = selectorsByColumn;\n                return selectionId;\n            };\n            SelectionId.createWithHighlight = function (original) {\n                debug.assertValue(original, 'original');\n                debug.assert(!original.highlight, '!original.highlight');\n                var newId = new SelectionId(original.getSelector(), /*highlight*/ true);\n                newId.selectorsByColumn = original.selectorsByColumn;\n                return newId;\n            };\n            SelectionId.idArray = function (id1, id2) {\n                if (id1 || id2) {\n                    var data_7 = [];\n                    if (id1)\n                        data_7.push(id1);\n                    if (id2 && id2 !== id1)\n                        data_7.push(id2);\n                    return data_7;\n                }\n            };\n            return SelectionId;\n        }());\n        visuals.SelectionId = SelectionId;\n        /**\n         * This class is designed to simplify the creation of SelectionId objects\n         * It allows chaining to build up an object before calling 'create' to build a SelectionId\n         */\n        var SelectionIdBuilder = (function () {\n            function SelectionIdBuilder() {\n            }\n            SelectionIdBuilder.builder = function () {\n                return new SelectionIdBuilder();\n            };\n            SelectionIdBuilder.prototype.withCategory = function (categoryColumn, index) {\n                if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\n                    this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\n                return this;\n            };\n            SelectionIdBuilder.prototype.withSeries = function (seriesColumn, valueColumn) {\n                if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\n                    this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\n                return this;\n            };\n            SelectionIdBuilder.prototype.withMeasure = function (measureId) {\n                this.measure = measureId;\n                return this;\n            };\n            SelectionIdBuilder.prototype.createSelectionId = function () {\n                return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\n            };\n            SelectionIdBuilder.prototype.ensureDataMap = function () {\n                if (!this.dataMap)\n                    this.dataMap = {};\n                return this.dataMap;\n            };\n            return SelectionIdBuilder;\n        }());\n        visuals.SelectionIdBuilder = SelectionIdBuilder;\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n\n\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Allows generic traversal and type discovery for a SQExpr tree. */\r\n    export interface ISQExprVisitorWithArg<T, TArg> {\r\n        visitEntity(expr: SQEntityExpr, arg: TArg): T;\r\n        visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T;\r\n        visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T;\r\n        visitAggr(expr: SQAggregationExpr, arg: TArg): T;\r\n        visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T;\r\n        visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T;\r\n        visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T;\r\n        visitAnd(expr: SQAndExpr, arg: TArg): T;\r\n        visitBetween(expr: SQBetweenExpr, arg: TArg): T;\r\n        visitIn(expr: SQInExpr, arg: TArg): T;\r\n        visitOr(expr: SQOrExpr, arg: TArg): T;\r\n        visitCompare(expr: SQCompareExpr, arg: TArg): T;\r\n        visitContains(expr: SQContainsExpr, arg: TArg): T;\r\n        visitExists(expr: SQExistsExpr, arg: TArg): T;\r\n        visitNot(expr: SQNotExpr, arg: TArg): T;\r\n        visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T;\r\n        visitConstant(expr: SQConstantExpr, arg: TArg): T;\r\n        visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T;\r\n        visitDateAdd(expr: SQDateAddExpr, arg: TArg): T;\r\n        visitNow(expr: SQNowExpr, arg: TArg): T;\r\n        visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T;\r\n        visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T;\r\n        visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T;\r\n        visitFillRule(expr: SQFillRuleExpr, arg: TArg): T;\r\n        visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T;\r\n        visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T;\r\n    }\r\n\r\n    export interface ISQExprVisitor<T> extends ISQExprVisitorWithArg<T, void> {\r\n    }\r\n\r\n    /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\r\n    export class DefaultSQExprVisitorWithArg<T, TArg> implements ISQExprVisitorWithArg<T, TArg> {\r\n        public visitEntity(expr: SQEntityExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr, arg: TArg): T {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that others may derive from. */\r\n    export class DefaultSQExprVisitor<T> extends DefaultSQExprVisitorWithArg<T, void> implements ISQExprVisitor<T> {\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\r\n    export class DefaultSQExprVisitorWithTraversal implements ISQExprVisitor<void>, IFillRuleDefinitionVisitor<void, void> {\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): void {\r\n            expr.arg.accept(this);\r\n        } \r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr): void {\r\n            expr.arg.accept(this);\r\n            expr.lower.accept(this);\r\n            expr.upper.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): void {\r\n            let args = expr.args;\r\n            for (let i = 0, len = args.length; i < len; i++)\r\n                args[i].accept(this);\r\n\r\n            let values = expr.values;\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let valueTuple = values[i];\r\n                for (let j = 0, jlen = valueTuple.length; j < jlen; j++)\r\n                    valueTuple[j].accept(this);\r\n            }\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr): void {\r\n            expr.input.accept(this);\r\n\r\n            let rule = expr.rule,\r\n                gradient2 = rule.linearGradient2,\r\n                gradient3 = rule.linearGradient3;\r\n\r\n            if (gradient2) {\r\n                this.visitLinearGradient2(gradient2);\r\n            }\r\n\r\n            if (gradient3) {\r\n                this.visitLinearGradient3(gradient3);\r\n            }\r\n        }\r\n\r\n        public visitLinearGradient2(gradient2: LinearGradient2Definition): void {\r\n            debug.assertValue(gradient2, 'gradient2');\r\n\r\n            this.visitFillRuleStop(gradient2.min);\r\n            this.visitFillRuleStop(gradient2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(gradient3: LinearGradient3Definition): void {\r\n            debug.assertValue(gradient3, 'gradient3');\r\n\r\n            this.visitFillRuleStop(gradient3.min);\r\n            this.visitFillRuleStop(gradient3.mid);\r\n            this.visitFillRuleStop(gradient3.max);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): void {\r\n            expr.expression.accept(this);\r\n            for (let scopeExpr of expr.scope) {\r\n                scopeExpr.accept(this);\r\n            }\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): void {\r\n            return;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): void {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            stop.color.accept(this);\r\n\r\n            let value = stop.value;\r\n            if (value)\r\n                value.accept(this);\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Defines a custom enumeration data type, and its values. */\r\n    export interface IEnumType {\r\n        /** Gets the members of the enumeration, limited to the validMembers, if appropriate. */\r\n        members(validMembers?: EnumMemberValue[]): IEnumMember[];\r\n    }\r\n\r\n    export function createEnumType(members: IEnumMember[]): IEnumType {\r\n        return new EnumType(members);\r\n    }\r\n\r\n    class EnumType implements IEnumType {\r\n        private allMembers: IEnumMember[];\r\n\r\n        constructor(allMembers: IEnumMember[]) {\r\n            debug.assertValue(allMembers, 'allMembers');\r\n\r\n            this.allMembers = allMembers;\r\n        }\r\n\r\n        public members(validMembers?: EnumMemberValue[]): IEnumMember[] {\r\n            let allMembers = this.allMembers;\r\n            if (!validMembers)\r\n                return allMembers;\r\n\r\n            let membersToReturn: IEnumMember[] = [];\r\n            for (let member of allMembers) {\r\n                if (_.contains(validMembers, member.value))\r\n                    membersToReturn.push(member);\r\n            }\r\n            return membersToReturn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface FillDefinition {\r\n        solid?: {\r\n            color?: SQExpr;\r\n        };\r\n        gradient?: {\r\n            startColor?: SQExpr;\r\n            endColor?: SQExpr;\r\n        };\r\n        pattern?: {\r\n            patternKind?: SQExpr;\r\n            color?: SQExpr;\r\n        };\r\n    }\r\n\r\n    export module FillSolidColorTypeDescriptor {\r\n        /** Gets a value indicating whether the descriptor is nullable or not. */\r\n        export function nullable(descriptor: FillSolidColorTypeDescriptor): boolean {\r\n            debug.assertValue(descriptor, 'descriptor');\r\n\r\n            if (descriptor === true)\r\n                return false;\r\n\r\n            let advancedDescriptor = <FillSolidColorAdvancedTypeDescriptor>descriptor;\r\n            return !!advancedDescriptor.nullable;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ImageTypeDescriptor {\r\n    }\r\n\r\n    export type ImageDefinition = ImageDefinitionGeneric<SQExpr>;\r\n\r\n    export module ImageDefinition {\r\n        export const urlType: ValueTypeDescriptor = { misc: { imageUrl: true } };\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SemanticFilter = powerbi.data.SemanticFilter;\r\n\r\n    export type StructuralObjectDefinition =\r\n        FillDefinition |\r\n        FillRuleDefinition |\r\n        SemanticFilter |\r\n        DefaultValueDefinition |\r\n        ImageDefinition |\r\n        ParagraphsDefinition;\r\n\r\n    export module StructuralTypeDescriptor {\r\n        export function isValid(type: StructuralTypeDescriptor): boolean {\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (type.fill ||\r\n                type.fillRule ||\r\n                type.filter ||\r\n                type.expression ||\r\n                type.image ||\r\n                type.paragraphs) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n\r\n    export interface ValueTypeDescriptor {\r\n        extendedType?: ExtendedType;\r\n    }\r\n    \r\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\r\n    export class ValueType implements ValueTypeDescriptor {\r\n        private static typeCache: { [id: string]: ValueType } = {};\r\n\r\n        private underlyingType: ExtendedType;\r\n        private category: string;\r\n\r\n        private temporalType: TemporalType;\r\n        private geographyType: GeographyType;\r\n        private miscType: MiscellaneousType;\r\n        private formattingType: FormattingType;\r\n        private enumType: IEnumType;\r\n        private scriptingType: ScriptType;\r\n\r\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\r\n        constructor(type: ExtendedType, category?: string, enumType?: IEnumType) {\r\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\r\n            debug.assert(!!category || category === null, 'category');\r\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\r\n\r\n            this.underlyingType = type;\r\n            this.category = category;\r\n\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\r\n                this.temporalType = new TemporalType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\r\n                this.geographyType = new GeographyType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\r\n                this.miscType = new MiscellaneousType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\r\n                this.formattingType = new FormattingType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\r\n                this.enumType = enumType;\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\r\n                this.scriptingType = new ScriptType(type);\r\n            }\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\r\n        public static fromDescriptor(descriptor: ValueTypeDescriptor): ValueType {\r\n            descriptor = descriptor || {};\r\n\r\n            // Simplified primitive types\r\n            if (descriptor.text) return ValueType.fromExtendedType(ExtendedType.Text);\r\n            if (descriptor.integer) return ValueType.fromExtendedType(ExtendedType.Integer);\r\n            if (descriptor.numeric) return ValueType.fromExtendedType(ExtendedType.Double);\r\n            if (descriptor.bool) return ValueType.fromExtendedType(ExtendedType.Boolean);\r\n            if (descriptor.dateTime) return ValueType.fromExtendedType(ExtendedType.DateTime);\r\n            if (descriptor.duration) return ValueType.fromExtendedType(ExtendedType.Duration);\r\n            if (descriptor.binary) return ValueType.fromExtendedType(ExtendedType.Binary);\r\n            if (descriptor.none) return ValueType.fromExtendedType(ExtendedType.None);\r\n\r\n            // Extended types\r\n            if (descriptor.scripting) {\r\n                if (descriptor.scripting.source) return ValueType.fromExtendedType(ExtendedType.ScriptSource);\r\n            }\r\n            if (descriptor.enumeration) return ValueType.fromEnum(descriptor.enumeration);\r\n            if (descriptor.temporal) {\r\n                if (descriptor.temporal.year) return ValueType.fromExtendedType(ExtendedType.Year_Integer);\r\n                if (descriptor.temporal.month) return ValueType.fromExtendedType(ExtendedType.Month_Integer);\r\n            }\r\n            if (descriptor.geography) {\r\n                if (descriptor.geography.address) return ValueType.fromExtendedType(ExtendedType.Address);\r\n                if (descriptor.geography.city) return ValueType.fromExtendedType(ExtendedType.City);\r\n                if (descriptor.geography.continent) return ValueType.fromExtendedType(ExtendedType.Continent);\r\n                if (descriptor.geography.country) return ValueType.fromExtendedType(ExtendedType.Country);\r\n                if (descriptor.geography.county) return ValueType.fromExtendedType(ExtendedType.County);\r\n                if (descriptor.geography.region) return ValueType.fromExtendedType(ExtendedType.Region);\r\n                if (descriptor.geography.postalCode) return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\r\n                if (descriptor.geography.stateOrProvince) return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\r\n                if (descriptor.geography.place) return ValueType.fromExtendedType(ExtendedType.Place);\r\n                if (descriptor.geography.latitude) return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\r\n                if (descriptor.geography.longitude) return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\r\n            }\r\n            if (descriptor.misc) {\r\n                if (descriptor.misc.image) return ValueType.fromExtendedType(ExtendedType.Image);\r\n                if (descriptor.misc.imageUrl) return ValueType.fromExtendedType(ExtendedType.ImageUrl);\r\n                if (descriptor.misc.webUrl) return ValueType.fromExtendedType(ExtendedType.WebUrl);\r\n            }\r\n            if (descriptor.formatting) {\r\n                if (descriptor.formatting.color) return ValueType.fromExtendedType(ExtendedType.Color);\r\n                if (descriptor.formatting.formatString) return ValueType.fromExtendedType(ExtendedType.FormatString);\r\n                if (descriptor.formatting.alignment) return ValueType.fromExtendedType(ExtendedType.Alignment);\r\n                if (descriptor.formatting.labelDisplayUnits) return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\r\n                if (descriptor.formatting.fontSize) return ValueType.fromExtendedType(ExtendedType.FontSize);\r\n                if (descriptor.formatting.labelDensity) return ValueType.fromExtendedType(ExtendedType.LabelDensity);\r\n            }\r\n            if (descriptor.extendedType) {\r\n                return ValueType.fromExtendedType(descriptor.extendedType);\r\n            }\r\n\r\n            return ValueType.fromExtendedType(ExtendedType.Null);\r\n        }\r\n\r\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\r\n        public static fromExtendedType(extendedType: ExtendedType): ValueType {\r\n            extendedType = extendedType || ExtendedType.Null;\r\n\r\n            let primitiveType = getPrimitiveType(extendedType),\r\n                category = getCategoryFromExtendedType(extendedType);\r\n            debug.assert(\r\n                primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null,\r\n                'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\r\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\r\n        public static fromPrimitiveTypeAndCategory(primitiveType: PrimitiveType, category?: string): ValueType {\r\n            primitiveType = primitiveType || PrimitiveType.Null;\r\n            category = category || null;\r\n\r\n            let id = primitiveType.toString();\r\n            if (category)\r\n                id += '|' + category;\r\n\r\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\r\n        }\r\n\r\n        /** Creates a ValueType to describe the given IEnumType. */\r\n        public static fromEnum(enumType: IEnumType): ValueType {\r\n            debug.assertValue(enumType, 'enumType');\r\n\r\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\r\n        }\r\n\r\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\r\n        public static isCompatibleTo(type: ValueTypeDescriptor, otherTypes: ValueTypeDescriptor[]): boolean {\r\n            debug.assertValue(type, 'type');\r\n            debug.assertValue(otherTypes, 'otherTypes');\r\n\r\n            let valueType = ValueType.fromDescriptor(type);\r\n            for (let otherType of otherTypes) {\r\n                let otherValueType = ValueType.fromDescriptor(otherType);\r\n\r\n                if (otherValueType.isCompatibleFrom(valueType))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\r\n        public isCompatibleFrom(other: ValueType): boolean {\r\n            debug.assertValue(other, 'other');\r\n\r\n            let otherPrimitiveType = other.primitiveType;\r\n            if (this === other ||\r\n                this.primitiveType === otherPrimitiveType ||\r\n                otherPrimitiveType === PrimitiveType.Null)\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /** Gets the exact primitive type of this ValueType. */\r\n        public get primitiveType(): PrimitiveType {\r\n            return getPrimitiveType(this.underlyingType);\r\n        }\r\n\r\n        /** Gets the exact extended type of this ValueType. */\r\n        public get extendedType(): ExtendedType {\r\n            return this.underlyingType;\r\n        }\r\n\r\n        /** Gets the data category string (if any) for this ValueType. */\r\n        public get categoryString(): string {\r\n            return this.category;\r\n        }\r\n\r\n        // Simplified primitive types\r\n\r\n        /** Indicates whether the type represents text values. */\r\n        public get text(): boolean {\r\n            return this.primitiveType === PrimitiveType.Text;\r\n        }\r\n\r\n        /** Indicates whether the type represents any numeric value. */\r\n        public get numeric(): boolean {\r\n            return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\r\n        }\r\n\r\n        /** Indicates whether the type represents integer numeric values. */\r\n        public get integer(): boolean {\r\n            return this.primitiveType === PrimitiveType.Integer;\r\n        }\r\n\r\n        /** Indicates whether the type represents Boolean values. */\r\n        public get bool(): boolean {\r\n            return this.primitiveType === PrimitiveType.Boolean;\r\n        }\r\n\r\n        /** Indicates whether the type represents any date/time values. */\r\n        public get dateTime(): boolean {\r\n            return this.primitiveType === PrimitiveType.DateTime ||\r\n                this.primitiveType === PrimitiveType.Date ||\r\n                this.primitiveType === PrimitiveType.Time;\r\n        }\r\n\r\n        /** Indicates whether the type represents duration values. */\r\n        public get duration(): boolean {\r\n            return this.primitiveType === PrimitiveType.Duration;\r\n        }\r\n\r\n        /** Indicates whether the type represents binary values. */\r\n        public get binary(): boolean {\r\n            return this.primitiveType === PrimitiveType.Binary;\r\n        }\r\n\r\n        /** Indicates whether the type represents none values. */\r\n        public get none(): boolean {\r\n            return this.primitiveType === PrimitiveType.None;\r\n        }\r\n\r\n        // Extended types\r\n\r\n        /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\r\n        public get temporal(): TemporalType {\r\n            return this.temporalType;\r\n        }\r\n\r\n        /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\r\n        public get geography(): GeographyType {\r\n            return this.geographyType;\r\n        }\r\n\r\n        /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\r\n        public get misc(): MiscellaneousType {\r\n            return this.miscType;\r\n        }\r\n\r\n        /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\r\n        public get formatting(): FormattingType {\r\n            return this.formattingType;\r\n        }\r\n\r\n        /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\r\n        public get enum(): IEnumType {\r\n            return this.enumType;\r\n        }\r\n\r\n        public get scripting(): ScriptType {\r\n            return this.scriptingType;\r\n        }\r\n    }\r\n\r\n    export class ScriptType implements ScriptTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get source(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\r\n        }\r\n    }\r\n\r\n    export class TemporalType implements TemporalTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get year(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\r\n        }\r\n        public get month(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\r\n        }\r\n    }\r\n\r\n    export class GeographyType implements GeographyTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get address(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\r\n        }\r\n        public get city(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\r\n        }\r\n        public get continent(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\r\n        }\r\n        public get country(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\r\n        }\r\n        public get county(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\r\n        }\r\n        public get region(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\r\n        }\r\n        public get postalCode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\r\n        }\r\n        public get stateOrProvince(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\r\n        }\r\n        public get place(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\r\n        }\r\n        public get latitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\r\n        }\r\n        public get longitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\r\n        }\r\n    }\r\n\r\n    export class MiscellaneousType implements MiscellaneousTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get image(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\r\n        }\r\n        public get imageUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\r\n        }\r\n        public get webUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\r\n        }\r\n    }\r\n\r\n    export class FormattingType implements FormattingTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get color(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\r\n        }\r\n\r\n        public get formatString(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\r\n        }\r\n\r\n        public get alignment(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\r\n        }\r\n\r\n        public get labelDisplayUnits(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\r\n        }\r\n\r\n        public get fontSize(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\r\n        }\r\n\r\n        public get labelDensity(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\r\n        }\r\n    }\r\n\r\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\r\n    export enum PrimitiveType {\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = 2,\r\n        Double = 3,\r\n        Integer = 4,\r\n        Boolean = 5,\r\n        Date = 6,\r\n        DateTime = 7,\r\n        DateTimeZone = 8,\r\n        Time = 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n    }\r\n\r\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\r\n    export enum ExtendedType {\r\n        // Flags (1 << 8-15 range [0xFF00])\r\n        // Important: Enum members must be declared before they are used in TypeScript.\r\n        Numeric = 1 << 8,\r\n        Temporal = 1 << 9,\r\n        Geography = 1 << 10,\r\n        Miscellaneous = 1 << 11,\r\n        Formatting = 1 << 12,\r\n        Scripting = 1 << 13,        \r\n\r\n        // Primitive types (0-255 range [0xFF] | flags)\r\n        // The member names and base values must match those in PrimitiveType.\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = Numeric | 2,\r\n        Double = Numeric | 3,\r\n        Integer = Numeric | 4,\r\n        Boolean = 5,\r\n        Date = Temporal | 6,\r\n        DateTime = Temporal | 7,\r\n        DateTimeZone = Temporal | 8,\r\n        Time = Temporal | 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n\r\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\r\n        // Temporal\r\n        Year = Temporal | (1 << 16),\r\n        Year_Text = Year | Text,\r\n        Year_Integer = Year | Integer,\r\n        Year_Date = Year | Date,\r\n        Year_DateTime = Year | DateTime,\r\n        Month = Temporal | (2 << 16),\r\n        Month_Text = Month | Text,\r\n        Month_Integer = Month | Integer,\r\n        Month_Date = Month | Date,\r\n        Month_DateTime = Month | DateTime,\r\n        // Geography\r\n        Address = Text | Geography | (100 << 16),\r\n        City = Text | Geography | (101 << 16),\r\n        Continent = Text | Geography | (102 << 16),\r\n        Country = Text | Geography | (103 << 16),\r\n        County = Text | Geography | (104 << 16),\r\n        Region = Text | Geography | (105 << 16),\r\n        PostalCode = Geography | (106 << 16),\r\n        PostalCode_Text = PostalCode | Text,\r\n        PostalCode_Integer = PostalCode | Integer,\r\n        StateOrProvince = Text | Geography | (107 << 16),\r\n        Place = Text | Geography | (108 << 16),\r\n        Latitude = Geography | (109 << 16),\r\n        Latitude_Decimal = Latitude | Decimal,\r\n        Latitude_Double = Latitude | Double,\r\n        Longitude = Geography | (110 << 16),\r\n        Longitude_Decimal = Longitude | Decimal,\r\n        Longitude_Double = Longitude | Double,\r\n        // Miscellaneous\r\n        Image = Binary | Miscellaneous | (200 << 16),\r\n        ImageUrl = Text | Miscellaneous | (201 << 16),\r\n        WebUrl = Text | Miscellaneous | (202 << 16),\r\n        // Formatting\r\n        Color = Text | Formatting | (300 << 16),\r\n        FormatString = Text | Formatting | (301 << 16),\r\n        Alignment = Text | Formatting | (306 << 16),\r\n        LabelDisplayUnits = Text | Formatting | (307 << 16),\r\n        FontSize = Double | Formatting | (308 << 16),\r\n        LabelDensity = Double | Formatting | (309 << 16),\r\n        // Enumeration\r\n        Enumeration = Text | 400 << 16,\r\n        // Scripting\r\n        ScriptSource = Text | Scripting | (500 << 16),        \r\n        // NOTE: To avoid confusion, underscores should be used only to delimit primitive type variants of an extended type\r\n        // (e.g. Year_Integer or Latitude_Double above)\r\n    }\r\n\r\n    const PrimitiveTypeMask = 0xFF;\r\n    const PrimitiveTypeWithFlagsMask = 0xFFFF;\r\n    const PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\r\n\r\n    function getPrimitiveType(extendedType: ExtendedType): PrimitiveType {\r\n        return extendedType & PrimitiveTypeMask;\r\n    }\r\n\r\n    function isPrimitiveType(extendedType: ExtendedType): boolean {\r\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\r\n    }\r\n\r\n    function getCategoryFromExtendedType(extendedType: ExtendedType): string {\r\n        if (isPrimitiveType(extendedType))\r\n            return null;\r\n\r\n        let category = ExtendedType[extendedType];\r\n        if (category) {\r\n            // Check for ExtendedType declaration without a primitive type.\r\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\r\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\r\n            let delimIdx = category.lastIndexOf('_');\r\n            if (delimIdx > 0) {\r\n                let baseCategory = category.slice(0, delimIdx);\r\n                if (ExtendedType[baseCategory]) {\r\n                    debug.assert(\r\n                        (ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask),\r\n                        'Unexpected value for ExtendedType base member of ' + extendedType);\r\n                    category = baseCategory;\r\n                }\r\n            }\r\n        }\r\n        return category || null;\r\n    }\r\n\r\n    function toExtendedType(primitiveType: PrimitiveType, category?: string): ExtendedType {\r\n        let primitiveString = PrimitiveType[primitiveType];\r\n        let t = ExtendedType[primitiveString];\r\n        if (t == null) {\r\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\r\n            t = ExtendedType.Null;\r\n        }\r\n\r\n        if (primitiveType && category) {\r\n            let categoryType: ExtendedType = ExtendedType[category];\r\n            if (categoryType) {\r\n                let categoryPrimitiveType = getPrimitiveType(categoryType);\r\n                if (categoryPrimitiveType === PrimitiveType.Null) {\r\n                    // Category supports multiple primitive types, check if requested primitive type is supported\r\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\r\n                    categoryType = t | categoryType;\r\n                    if (ExtendedType[categoryType]) {\r\n                        debug.assert(\r\n                            ExtendedType[categoryType] === (category + '_' + primitiveString),\r\n                            'Unexpected name for ExtendedType member ' + categoryType);\r\n                        t = categoryType;\r\n                    }\r\n                }\r\n                else if (categoryPrimitiveType === primitiveType) {\r\n                    // Primitive type matches the single supported type for the category\r\n                    t = categoryType;\r\n                }\r\n            }\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    function matchesExtendedTypeWithAnyPrimitive(a: ExtendedType, b: ExtendedType): boolean {\r\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /**\r\n     * Represents the versions of the data shape binding structure.\r\n     * NOTE Keep this file in sync with the Sql\\InfoNav\\src\\Data\\Contracts\\DsqGeneration\\DataShapeBindingVersions.cs\r\n     * file in the TFS Dev branch.\r\n     */\r\n    export const enum DataShapeBindingVersions {\r\n        /** The initial version of data shape binding */\r\n        Version0 = 0,\r\n        /** Explicit subtotal support for axis groupings. */\r\n        Version1 = 1,\r\n    }\r\n\r\n    export interface DataShapeBindingLimitTarget {\r\n        Primary?: number;\r\n    }\r\n\r\n    export enum DataShapeBindingLimitType {\r\n        Top = 0,\r\n        First = 1,\r\n        Last = 2,\r\n        Sample = 3,\r\n        Bottom = 4,\r\n    }\r\n\r\n    export interface DataShapeBindingLimit {\r\n        Count?: number;\r\n        Target: DataShapeBindingLimitTarget;\r\n        Type: DataShapeBindingLimitType;\r\n    }\r\n\r\n    export interface DataShapeBinding {\r\n        Version?: number;\r\n        Primary: DataShapeBindingAxis;\r\n        Secondary?: DataShapeBindingAxis;\r\n        Aggregates?: DataShapeBindingAggregate[];\r\n        Projections?: number[];\r\n        Limits?: DataShapeBindingLimit[];\r\n        Highlights?: FilterDefinition[];\r\n        DataReduction?: DataShapeBindingDataReduction;\r\n        IncludeEmptyGroups?: boolean;\r\n        SuppressedJoinPredicates?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingDataReduction {\r\n        Primary?: DataShapeBindingDataReductionAlgorithm;\r\n        Secondary?: DataShapeBindingDataReductionAlgorithm;\r\n        DataVolume?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionAlgorithm {\r\n        Top?: DataShapeBindingDataReductionTopLimit;\r\n        Sample?: DataShapeBindingDataReductionSampleLimit;\r\n        Bottom?: DataShapeBindingDataReductionBottomLimit;\r\n        Window?: DataShapeBindingDataReductionDataWindow;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionTopLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionSampleLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionBottomLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionDataWindow {\r\n        Count?: number;\r\n        RestartTokens?: RestartToken;\r\n    }\r\n\r\n    export interface DataShapeBindingAxis {\r\n        Groupings: DataShapeBindingAxisGrouping[];\r\n    }\r\n\r\n    export enum SubtotalType {\r\n        None = 0,\r\n        Before = 1,\r\n        After = 2\r\n    }\r\n\r\n    export interface DataShapeBindingAxisGrouping {\r\n        Projections: number[];\r\n        GroupBy?: number[];\r\n        SuppressedProjections?: number[];\r\n        Subtotal?: SubtotalType;\r\n        ShowItemsWithNoData?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingAggregate {\r\n        Select: number;\r\n        Kind: DataShapeBindingAggregateKind;\r\n    }\r\n\r\n    export const enum DataShapeBindingAggregateKind {\r\n        None = 0,\r\n        Min = 1,\r\n        Max = 1 << 1,\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataShapeBindingDataReduction {\r\n\r\n        export function createFrom(reduction: ReductionAlgorithm): DataShapeBindingDataReductionAlgorithm {\r\n            if (!reduction)\r\n                return;\r\n\r\n            var result: DataShapeBindingDataReductionAlgorithm;\r\n            if (reduction.top) {\r\n                result = {\r\n                    Top: {}\r\n                };\r\n\r\n                if (reduction.top.count)\r\n                    result.Top.Count = reduction.top.count;\r\n            }\r\n\r\n            if (reduction.bottom) {\r\n                result = {\r\n                    Bottom: {}\r\n                };\r\n\r\n                if (reduction.bottom.count)\r\n                    result.Bottom.Count = reduction.bottom.count;\r\n            }\r\n\r\n            if (reduction.sample) {\r\n                result = {\r\n                    Sample: {}\r\n                };\r\n\r\n                if (reduction.sample.count)\r\n                    result.Sample.Count = reduction.sample.count;\r\n            }\r\n\r\n            if (reduction.window) {\r\n                result = {\r\n                    Window: {}\r\n                };\r\n\r\n                if (reduction.window.count)\r\n                    result.Window.Count = reduction.window.count;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface FederatedConceptualSchemaInitOptions {\r\n        schemas: { [name: string]: ConceptualSchema };\r\n        links?: ConceptualSchemaLink[];\r\n    }\r\n\r\n    /** Represents a federated conceptual schema. */\r\n    export class FederatedConceptualSchema {\r\n        private schemas: { [name: string]: ConceptualSchema };\r\n        private links: ConceptualSchemaLink[];\r\n\r\n        constructor(options: FederatedConceptualSchemaInitOptions) {\r\n            debug.assertValue(options, 'options');\r\n\r\n            this.schemas = options.schemas; \r\n            if (options.links)\r\n                this.links = options.links;\r\n        }\r\n\r\n        public schema(name: string): ConceptualSchema {\r\n            return this.schemas[name];\r\n        }\r\n    }\r\n\r\n    /** Describes a semantic relationship between ConceptualSchemas. */\r\n    export interface ConceptualSchemaLink {\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module Selector {\r\n        export function filterFromSelector(selectors: Selector[], isNot?: boolean): SemanticFilter {\r\n            if (_.isEmpty(selectors))\r\n                return;\r\n\r\n            let exprs: SQExpr[] = [];\r\n            for (let i = 0, ilen = selectors.length; i < ilen; i++) {\r\n                let identity = selectors[i];\r\n                let data = identity.data;\r\n                let exprToAdd: SQExpr = undefined;\r\n                if (data && data.length) {\r\n                    for (let j = 0, jlen = data.length; j < jlen; j++) {\r\n                        exprToAdd = SQExprBuilder.and(exprToAdd, <SQExpr>(<DataViewScopeIdentity>identity.data[j]).expr);\r\n                    }\r\n                }\r\n\r\n                if (exprToAdd)\r\n                    exprs.push(exprToAdd);\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return DataViewScopeIdentity.filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function matchesData(selector: Selector, identities: DataViewScopeIdentity[]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(identities, 'identities');\r\n\r\n            let selectorData = selector.data;\r\n            if (selectorData.length !== identities.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = selectorData.length; i < len; i++) {\r\n                let dataItem = selector.data[i];\r\n                let selectorDataItem = <DataViewScopeIdentity>dataItem;\r\n                if (selectorDataItem.expr) {\r\n                    if (!DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\r\n                        return false;\r\n                }\r\n                else {\r\n                    if (!DataViewScopeWildcard.matches(<DataViewScopeWildcard>dataItem, identities[i]))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function matchesKeys(selector: Selector, keysList: SQExpr[][]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(keysList, 'keysList');\r\n\r\n            let selectorData = selector.data,\r\n                selectorDataLength = selectorData.length;\r\n            if (selectorDataLength !== keysList.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < selectorDataLength; i++) {\r\n                let selectorDataItem = selector.data[i],\r\n                    selectorDataExprs: SQExpr[];\r\n\r\n                if ((<DataViewScopeIdentity>selectorDataItem).expr) {\r\n                    selectorDataExprs = ScopeIdentityExtractor.getKeys(<SQExpr>(<DataViewScopeIdentity>selectorDataItem).expr);\r\n                }\r\n                else if ((<DataViewScopeWildcard>selectorDataItem).exprs) {\r\n                    selectorDataExprs = <SQExpr[]>(<DataViewScopeWildcard>selectorDataItem).exprs;\r\n                } else { \r\n                    // In case DataViewRoleWildcard\r\n                    return false;\r\n                }\r\n\r\n                if (!selectorDataExprs)\r\n                    continue;\r\n                if (!SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /** Determines whether two selectors are equal. */\r\n        export function equals(x: Selector, y: Selector): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            if (x.id !== y.id)\r\n                return false;\r\n            if (x.metadata !== y.metadata)\r\n                return false;\r\n            if (!equalsDataArray(x.data, y.data))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsDataArray(x: DataRepetitionSelector[], y: DataRepetitionSelector[]): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            if (x.length !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = x.length; i < len; i++) {\r\n                if (!equalsData(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsData(x: DataRepetitionSelector, y: DataRepetitionSelector): boolean {\r\n            if (!(<DataViewScopeIdentity>x).expr && (<DataViewScopeIdentity>y).expr) {\r\n                // TODO: We need to also check wildcard selectors too (once that's supported/figured out).\r\n                return false;\r\n            }\r\n\r\n            return DataViewScopeIdentity.equals(<DataViewScopeIdentity>x, <DataViewScopeIdentity>y);\r\n        }\r\n\r\n        export function getKey(selector: Selector): string {\r\n            let toStringify: any = {};\r\n            if (selector.data) {\r\n                let data = [];\r\n                for (let i = 0, ilen = selector.data.length; i < ilen; i++) {\r\n                    data.push(selector.data[i].key);\r\n                }\r\n                toStringify.data = data;\r\n            }\r\n            if (selector.metadata)\r\n                toStringify.metadata = selector.metadata;\r\n            if (selector.id)\r\n                toStringify.id = selector.id;\r\n            return JSON.stringify(toStringify);\r\n        }\r\n\r\n        export function containsWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (!dataItems)\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                let wildCard = <DataViewScopeWildcard & DataViewRoleWildcard>dataItem;\r\n                if (wildCard.exprs || wildCard.roles)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function hasRoleWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (_.isEmpty(dataItems))\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                if (isRoleWildcard(dataItem))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRoleWildcard(dataItem: DataRepetitionSelector): dataItem is DataViewRoleWildcard {\r\n            return !_.isEmpty((<DataViewRoleWildcard>dataItem).roles);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface QueryDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where?: QueryFilter[];\r\n        OrderBy?: QuerySortClause[];\r\n        Select: QueryExpressionContainer[];\r\n        GroupBy?: QueryExpressionContainer[];\r\n    }\r\n\r\n    export interface FilterDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where: QueryFilter[];\r\n    }    \r\n\r\n    export enum EntitySourceType {\r\n        Table = 0,\r\n        Pod = 1,\r\n    }\r\n\r\n    export interface EntitySource {\r\n        Name: string;\r\n        EntitySet?: string; // TODO: Remove this when Q&A Silverlight is removed and make Entity required\r\n        Entity?: string;\r\n        Schema?: string;\r\n        Type?: EntitySourceType;\r\n    }\r\n\r\n    export interface QueryFilter {\r\n        Target?: QueryExpressionContainer[];\r\n        Condition: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QuerySortClause {\r\n        Expression: QueryExpressionContainer;\r\n        Direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryExpressionContainer {\r\n        Name?: string;\r\n\r\n        SourceRef?: QuerySourceRefExpression;\r\n        Column?: QueryColumnExpression;\r\n        Measure?: QueryMeasureExpression;\r\n        Aggregation?: QueryAggregationExpression;\r\n        Hierarchy?: QueryHierarchyExpression;\r\n        HierarchyLevel?: QueryHierarchyLevelExpression;\r\n        PropertyVariationSource?: QueryPropertyVariationSourceExpression;\r\n\r\n        // Logical\r\n        And?: QueryBinaryExpression;\r\n        Between?: QueryBetweenExpression;\r\n        In?: QueryInExpression;\r\n        Or?: QueryBinaryExpression;\r\n        Comparison?: QueryComparisonExpression;\r\n        Not?: QueryNotExpression;\r\n        Contains?: QueryContainsExpression;\r\n        StartsWith?: QueryStartsWithExpression;\r\n        Exists?: QueryExistsExpression;\r\n\r\n        // Constants\r\n        Boolean?: QueryBooleanExpression;\r\n        DateTime?: QueryDateTimeExpression;\r\n        DateTimeSecond?: QueryDateTimeSecondExpression;\r\n        Date?: QueryDateTimeExpression;\r\n        Decimal?: QueryDecimalExpression;\r\n        Integer?: QueryIntegerExpression;\r\n        Null?: QueryNullExpression;\r\n        Number?: QueryNumberExpression;\r\n        String?: QueryStringExpression;\r\n        Literal?: QueryLiteralExpression;\r\n\r\n        DateSpan?: QueryDateSpanExpression;\r\n        DateAdd?: QueryDateAddExpression;\r\n        Now?: QueryNowExpression;\r\n\r\n        // Default Values\r\n        DefaultValue?: QueryDefaultValueExpression;\r\n        AnyValue?: QueryAnyValueExpression;\r\n\r\n        Arithmetic?: QueryArithmeticExpression;\r\n\r\n        // Client-only expressions\r\n        FillRule?: QueryFillRuleExpression;\r\n        ResourcePackageItem?: QueryResourcePackageItem;\r\n\r\n        // Evaluation Expressions\r\n        ScopedEval?: QueryScopedEvalExpression;\r\n    }\r\n\r\n    export interface QueryPropertyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryColumnExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QueryMeasureExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QuerySourceRefExpression {\r\n        Source: string;\r\n    }\r\n\r\n    export interface QueryAggregationExpression {\r\n        Function: QueryAggregateFunction;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryHierarchyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Hierarchy: string;\r\n    }\r\n\r\n    export interface QueryHierarchyLevelExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Level: string;\r\n    }\r\n\r\n    export interface QueryPropertyVariationSourceExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Name: string;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryBinaryExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryBetweenExpression {\r\n        Expression: QueryExpressionContainer;\r\n        LowerBound: QueryExpressionContainer;\r\n        UpperBound: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryInExpression {\r\n        Expressions: QueryExpressionContainer[];\r\n        Values: QueryExpressionContainer[][];\r\n    }\r\n\r\n    export interface QueryComparisonExpression extends QueryBinaryExpression {\r\n        ComparisonKind: QueryComparisonKind;\r\n    }\r\n\r\n    export interface QueryContainsExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryNotExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryStartsWithExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryExistsExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryConstantExpression<T> {\r\n        Value: T;\r\n    }\r\n\r\n    export interface QueryLiteralExpression {\r\n        Value: string;\r\n    }\r\n\r\n    export interface QueryBooleanExpression extends QueryConstantExpression<boolean> { }\r\n    export interface QueryDateTimeExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDateTimeSecondExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDecimalExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryIntegerExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryNumberExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryNullExpression { }\r\n    export interface QueryStringExpression extends QueryConstantExpression<string> { }\r\n\r\n    export interface QueryDateSpanExpression {\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryDateAddExpression {\r\n        Amount: number;\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryNowExpression { }\r\n\r\n    export interface QueryDefaultValueExpression { }\r\n\r\n    export interface QueryAnyValueExpression { }\r\n\r\n    export interface QueryArithmeticExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n        Operator: ArithmeticOperatorKind;\r\n    }\r\n\r\n    export const enum ArithmeticOperatorKind {\r\n        Add = 0,\r\n        Subtract = 1,\r\n        Multiply = 2,\r\n        Divide = 3,\r\n    }\r\n\r\n    export function getArithmeticOperatorName(arithmeticOperatorKind: ArithmeticOperatorKind): string {\r\n        switch (arithmeticOperatorKind) {\r\n            case ArithmeticOperatorKind.Add:\r\n                return \"Add\";\r\n            case ArithmeticOperatorKind.Subtract:\r\n                return \"Subtract\";\r\n            case ArithmeticOperatorKind.Multiply:\r\n                return \"Multiply\";\r\n            case ArithmeticOperatorKind.Divide:\r\n                return \"Divide\";\r\n        }\r\n        throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\r\n    }\r\n\r\n    export interface QueryFillRuleExpression {\r\n        Input: QueryExpressionContainer;\r\n        FillRule: FillRuleGeneric<QueryExpressionContainer, QueryExpressionContainer>;\r\n    }\r\n\r\n    export interface QueryResourcePackageItem {\r\n        PackageName: string;\r\n        PackageType: number;\r\n        ItemName: string;\r\n    }\r\n\r\n    export interface QueryScopedEvalExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Scope: QueryExpressionContainer[];\r\n    }\r\n\r\n    export enum TimeUnit {\r\n        Day = 0,\r\n        Week = 1,\r\n        Month = 2,\r\n        Year = 3,\r\n        Decade = 4,\r\n        Second = 5,\r\n        Minute = 6,\r\n        Hour = 7,\r\n    }\r\n\r\n    export enum QueryAggregateFunction {\r\n        Sum = 0,\r\n        Avg = 1,\r\n        Count = 2,\r\n        Min = 3,\r\n        Max = 4,\r\n        CountNonNull = 5,\r\n        Median = 6,\r\n        StandardDeviation = 7,\r\n        Variance = 8,\r\n    }\r\n\r\n    export enum QueryComparisonKind {\r\n        Equal = 0,\r\n        GreaterThan = 1,\r\n        GreaterThanOrEqual = 2,\r\n        LessThan = 3,\r\n        LessThanOrEqual = 4,\r\n    }\r\n\r\n    /** Defines semantic data types. */\r\n    export enum SemanticType {\r\n        None = 0x0,\r\n        Number = 0x1,\r\n        Integer = Number + 0x2,\r\n        DateTime = 0x4,\r\n        Time = 0x08,\r\n        Date = DateTime + 0x10,\r\n        Month = Integer + 0x20,\r\n        Year = Integer + 0x40,\r\n        YearAndMonth = 0x80,\r\n        MonthAndDay = 0x100,\r\n        Decade = Integer + 0x200,\r\n        YearAndWeek = 0x400,\r\n        String = 0x800,\r\n        Boolean = 0x1000,\r\n        Table = 0x2000,\r\n        Range = 0x4000,\r\n    }\r\n\r\n    export interface QueryMetadata {\r\n        Select?: SelectMetadata[];\r\n        Filters?: FilterMetadata[];\r\n    }\r\n\r\n    // TODO: Stop using SemanticType and ConceptualDataCategory here (may need server contract changes)\r\n    export interface SelectMetadata {\r\n        Restatement: string;\r\n        \r\n        /* SemanticType or PrimitiveType. */\r\n        Type?: number; \r\n\r\n        Format?: string;\r\n        DataCategory?: ConceptualDataCategory;\r\n\r\n        /** The select projection name. */\r\n        Name?: string;\r\n\r\n        /* If defined, this indicates the KPI class*/\r\n        kpiStatusGraphic?: string; // old version of kpi data\r\n\r\n        /* If defined, this indicates the KPI metadata*/\r\n        kpi?: DataViewKpiColumnMetadata;\r\n    }\r\n\r\n    export interface FilterMetadata {\r\n        Restatement: string;\r\n        Kind?: FilterKind;\r\n        /** The expression being filtered.  This is reflected in the filter card UI. */\r\n        expression?: QueryExpressionContainer;\r\n    }\r\n\r\n    export enum FilterKind {\r\n        Default,\r\n        Period,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Represents a projection from a query result. */\r\n    export interface QueryProjection {\r\n        /** Name of item in the semantic query Select clause. */\r\n        queryRef: string;\r\n\r\n        /** Optional format string. */\r\n        format?: string; // TODO: Deprecate this, and populate format string through objects instead.\r\n    }\r\n\r\n    /** A set of QueryProjections, grouped by visualization property, and ordered within that property. */\r\n    export interface QueryProjectionsByRole {\r\n        [roleName: string]: QueryProjectionCollection;\r\n    }\r\n\r\n    export class QueryProjectionCollection {\r\n        private items: QueryProjection[];\r\n\r\n        /* The activeProjectionReference is an array that contains all the items that we are grouping on in case of a drillable\r\n           role. For example, if you have a drill role with [Country, State, City] and the user drilled to state, the active items\r\n           will include [Country and State]. This means that the query will group on both country and state and the state \"last item\"\r\n           is the item that the user drilled to.\r\n        */\r\n        private _activeProjectionRefs: string[];\r\n        private _showAll: boolean;\r\n\r\n        public constructor(items: QueryProjection[], activeProjectionRefs?: string[], showAll?: boolean) {\r\n            debug.assertValue(items, 'items');\r\n\r\n            this.items = items;\r\n            this._activeProjectionRefs = activeProjectionRefs;\r\n            this._showAll = showAll;\r\n        }\r\n\r\n        /** Returns all projections in a mutable array. */\r\n        public all(): QueryProjection[] {\r\n            return this.items;\r\n        }\r\n\r\n        public get activeProjectionRefs(): string[] {\r\n            return this._activeProjectionRefs;\r\n        }\r\n\r\n        public set activeProjectionRefs(queryReferences: string[]) {\r\n            if (!_.isEmpty(queryReferences)) {\r\n                let queryRefs = this.items.map(val => val.queryRef);\r\n\r\n                for (let queryReference of queryReferences) {\r\n                    if (!_.contains(queryRefs, queryReference))\r\n                        return;\r\n                }\r\n\r\n                this._activeProjectionRefs = queryReferences;\r\n            }\r\n        }\r\n\r\n        public get showAll(): boolean {\r\n            return this._showAll;\r\n        }\r\n\r\n        public set showAll(value: boolean) {\r\n            this._showAll = value;\r\n        }\r\n\r\n        public addActiveQueryReference(queryRef: string): void {\r\n            if (!this._activeProjectionRefs)\r\n                this._activeProjectionRefs = [queryRef];\r\n            else\r\n                this._activeProjectionRefs.push(queryRef);\r\n        }\r\n\r\n        public getLastActiveQueryReference(): string {\r\n            if (!_.isEmpty(this._activeProjectionRefs)) {\r\n                return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\r\n            }\r\n        }\r\n\r\n        public clone(): QueryProjectionCollection {\r\n            return new QueryProjectionCollection(_.clone(this.items), _.clone(this._activeProjectionRefs), this._showAll);\r\n        }\r\n    }\r\n\r\n    export module QueryProjectionsByRole {\r\n        /** Clones the QueryProjectionsByRole. */\r\n        export function clone(roles: QueryProjectionsByRole): QueryProjectionsByRole {\r\n            if (!roles)\r\n                return roles;\r\n\r\n            let clonedRoles: QueryProjectionsByRole = {};\r\n\r\n            for (let roleName in roles)\r\n                clonedRoles[roleName] = roles[roleName].clone();\r\n\r\n            return clonedRoles;\r\n        }\r\n\r\n        /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\r\n        export function getRole(roles: QueryProjectionsByRole, name: string): QueryProjectionCollection {\r\n            debug.assertAnyValue(roles, 'roles');\r\n            debug.assertValue(name, 'name');\r\n\r\n            if (!roles)\r\n                return;\r\n\r\n            return roles[name];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export interface VisualElement {\r\n        DataRoles?: DataRole[];\r\n        Settings?: VisualElementSettings;\r\n    }\r\n\r\n    /** Defines common settings for a visual element. */\r\n    export interface VisualElementSettings {\r\n        DisplayUnitSystemType?: DisplayUnitSystemType;\r\n    }\r\n\r\n    export interface DataRole {\r\n        Name: string;\r\n        Projection: number;\r\n        isActive?: boolean;\r\n    }\r\n\r\n    /** The system used to determine display units used during formatting */\r\n    export enum DisplayUnitSystemType {\r\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\r\n        Default,\r\n\r\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\r\n        Verbose,\r\n\r\n        /**\r\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\r\n         * Suitable for dashboard tile cards\r\n         */\r\n        WholeUnits,\r\n\r\n        /**A display unit system that also contains Auto and None units for data labels*/\r\n        DataLabels,\r\n    }\r\n}\r\n\r\nmodule powerbi.data.contracts {\r\n\r\n    export interface DataViewSource {\r\n        data: any;\r\n        type?: string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Repreasents the sequence of the dates/times */\r\n    export class DateTimeSequence {\r\n        // Constants\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;        \r\n\r\n        // Fields\r\n        public min: Date;\r\n        public max: Date;\r\n        public unit: DateTimeUnit;\r\n        public sequence: Date[];\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n\r\n        // Constructors\r\n        /** Creates new instance of the DateTimeSequence */\r\n        constructor(unit: DateTimeUnit) { \r\n            this.unit = unit;\r\n            this.sequence = [];\r\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\r\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Add a new Date to a sequence.\r\n         * @param date - date to add\r\n         */\r\n        public add(date: Date) { \r\n            if (date < this.min) { \r\n                this.min = date;\r\n            }\r\n            if (date > this.max) { \r\n                this.max = date;\r\n            }\r\n            this.sequence.push(date);\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Extends the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public extendToCover(min: Date, max: Date): void {\r\n            let x: Date = this.min;\r\n            while (min < x) {\r\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\r\n                this.sequence.splice(0, 0, x);\r\n            }\r\n            this.min = x;\r\n\r\n            x = this.max;\r\n            while (x < max) {\r\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\r\n                this.sequence.push(x);\r\n            }\r\n            this.max = x;\r\n        }\r\n\r\n        /** \r\n         * Move the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public moveToCover(min: Date, max: Date): void { \r\n            let delta: number = DateTimeSequence.getDelta(min, max, this.unit);\r\n            let count = Math.floor(delta / this.interval);\r\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\r\n\r\n            this.sequence = [];            \r\n            this.sequence.push(this.min);\r\n            this.max = this.min;\r\n            while (this.max < max) {\r\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\r\n                this.sequence.push(this.max);\r\n            }\r\n        }\r\n\r\n        // Static\r\n        /**\r\n         * Calculate a new DateTimeSequence\r\n         * @param dataMin - Date representing min of the data range\r\n         * @param dataMax - Date representing max of the data range\r\n         * @param expectedCount - expected number of intervals in the sequence\r\n         * @param unit - of the intervals in the sequence\r\n         */\r\n        public static calculate(dataMin: Date, dataMax: Date, expectedCount: number, unit?: DateTimeUnit): DateTimeSequence {\r\n            if (!unit) { \r\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\r\n            }\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Month:\r\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Week:\r\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Day:\r\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Hour:\r\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Minute:\r\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Second:\r\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\r\n                default:\r\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\r\n            }\r\n        }\r\n\r\n        public static calculateYears(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\r\n\r\n            // Calculate range and sequence\r\n            let yearsRange = NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\r\n\r\n            // Calculate year sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\r\n            let newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval; \r\n            let date = new Date(newMinYear, 0, 1);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Year);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMonths(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let minYear = dataMin.getFullYear();\r\n            let maxYear = dataMax.getFullYear();\r\n            let minMonth = dataMin.getMonth();\r\n            let maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\r\n            let date = new Date(minYear, 0, 1);\r\n            \r\n            // Calculate month sequence\r\n            let sequence = NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Month);\r\n            return result;\r\n        }\r\n\r\n        public static calculateWeeks(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            let firstDayOfWeek = 0;\r\n            let minDayOfWeek = dataMin.getDay();\r\n            let dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\r\n            let minDay = dataMin.getDate() - dayOffset;\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Week));\r\n\r\n            // Calculate week sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Week);\r\n            return result;\r\n        }\r\n\r\n        public static calculateDays(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, DateTimeUnit.Day));\r\n            \r\n            // Calculate day sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Day);\r\n            return result;\r\n        }\r\n\r\n        public static calculateHours(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Hour));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Hour));\r\n            \r\n            // Calculate hour sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Hour);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMinutes(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Minute));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Minute));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Minute);\r\n            return result;\r\n        }\r\n\r\n        public static calculateSeconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Second));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Second));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Second);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMilliseconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\r\n            let min = DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Millisecond);\r\n            let max = DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Millisecond);\r\n            \r\n            // Calculate milliseconds numeric sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(min, max), expectedCount, 0);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Millisecond);\r\n            return result;\r\n        }\r\n\r\n        private static fromNumericSequence(date: Date, sequence: NumericSequence, unit: DateTimeUnit) { \r\n            let result = new DateTimeSequence(unit);\r\n            for (let i = 0; i < sequence.sequence.length; i++) { \r\n                let x: number = sequence.sequence[i];\r\n                let d: Date = DateTimeSequence.addInterval(date, x, unit);\r\n                result.add(d);\r\n            }\r\n            result.interval = sequence.interval;\r\n            result.intervalOffset = sequence.intervalOffset;\r\n            return result;\r\n        }\r\n\r\n        private static addInterval(value: Date, interval: number, unit: DateTimeUnit): Date {\r\n            interval = Math.round(interval);\r\n            switch (unit)\r\n            {\r\n                case DateTimeUnit.Year:\r\n                    return DateUtils.addYears(value, interval);\r\n                case DateTimeUnit.Month:\r\n                    return DateUtils.addMonths(value, interval);\r\n                case DateTimeUnit.Week:\r\n                    return DateUtils.addWeeks(value, interval);\r\n                case DateTimeUnit.Day:\r\n                    return DateUtils.addDays(value, interval);\r\n                case DateTimeUnit.Hour:\r\n                    return DateUtils.addHours(value, interval);\r\n                case DateTimeUnit.Minute:\r\n                    return DateUtils.addMinutes(value, interval);\r\n                case DateTimeUnit.Second:\r\n                    return DateUtils.addSeconds(value, interval);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateUtils.addMilliseconds(value, interval);\r\n            }\r\n        }\r\n\r\n        private static getDelta(min: Date, max: Date, unit: DateTimeUnit): number {\r\n            let delta: number = 0;\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    delta = max.getFullYear() - min.getFullYear();\r\n                    break;\r\n                case DateTimeUnit.Month:\r\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\r\n                    break;\r\n                case DateTimeUnit.Week:\r\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Day:\r\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Hour:\r\n                    delta = (max.getTime() - min.getTime()) / 3600000;\r\n                    break;\r\n                case DateTimeUnit.Minute:\r\n                    delta = (max.getTime() - min.getTime()) / 60000;\r\n                    break;\r\n                case DateTimeUnit.Second:\r\n                    delta = (max.getTime() - min.getTime()) / 1000;\r\n                    break;\r\n                case DateTimeUnit.Millisecond:\r\n                    delta = max.getTime() - min.getTime();\r\n                    break;\r\n            }\r\n            return delta;\r\n        }\r\n\r\n        public static getIntervalUnit(min:Date, max:Date, maxCount: number): DateTimeUnit {\r\n            maxCount = Math.max(maxCount, 2);\r\n            let totalDays = DateTimeSequence.getDelta(min, max, DateTimeUnit.Day);\r\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\r\n                return DateTimeUnit.Year;\r\n            if (totalDays > 60 && totalDays > 7 * maxCount)\r\n                return DateTimeUnit.Month;\r\n            if (totalDays > 14 && totalDays > 2 * maxCount)\r\n                return DateTimeUnit.Week;\r\n            let totalHours = DateTimeSequence.getDelta(min, max, DateTimeUnit.Hour);\r\n            if (totalDays > 2 && totalHours > 12 * maxCount)\r\n                return DateTimeUnit.Day;\r\n            if (totalHours >= 24 && totalHours >= maxCount)\r\n                return DateTimeUnit.Hour;\r\n            let totalMinutes = DateTimeSequence.getDelta(min, max, DateTimeUnit.Minute);\r\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\r\n                return DateTimeUnit.Minute;\r\n            let totalSeconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Second);\r\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\r\n                return DateTimeUnit.Second;\r\n            let totalMilliseconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Millisecond);\r\n            if (totalMilliseconds > 0)\r\n                return DateTimeUnit.Millisecond;\r\n  \r\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\r\n            let date = min;\r\n            if (date.getMilliseconds() !== 0)\r\n                return DateTimeUnit.Millisecond;\r\n            if (date.getSeconds() !== 0)\r\n                return DateTimeUnit.Second;\r\n            if (date.getMinutes() !== 0)\r\n                return DateTimeUnit.Minute;\r\n            if (date.getHours() !== 0)\r\n                return DateTimeUnit.Hour;\r\n            if (date.getDate() !== 1)\r\n                return DateTimeUnit.Day;\r\n            if (date.getMonth() !== 0)\r\n                return DateTimeUnit.Month;\r\n            \r\n            return DateTimeUnit.Year;\r\n        }\r\n    }\r\n\r\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\r\n    export module DateUtils { \r\n        let MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n        let MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n\r\n        /**\r\n         * Returns bool indicating weither the provided year is a leap year.\r\n         * @param year - year value\r\n         */\r\n        function isLeap(year: number): boolean { \r\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\r\n        }\r\n\r\n        /** \r\n         * Returns number of days in the provided year/month.\r\n         * @param year - year value\r\n         * @param month - month value\r\n         */\r\n        function getMonthDays(year: number, month: number) { \r\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of years to the provided date.\r\n         * @param date - date value\r\n         * @param yearDelta - number of years to add\r\n         */\r\n        export function addYears(date: Date, yearDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n            let isLeapDay = month === 2 && day === 29;\r\n\r\n            let result = new Date(date.getTime());\r\n            year = year + yearDelta;\r\n            if (isLeapDay && !isLeap(year)) {\r\n                day = 28;\r\n            } \r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of months to the provided date.\r\n         * @param date - date value\r\n         * @param monthDelta - number of months to add\r\n         */\r\n        export function addMonths(date: Date, monthDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n           \r\n            let result = new Date(date.getTime());\r\n            year += (monthDelta - (monthDelta % 12)) / 12;\r\n            month += monthDelta % 12;\r\n\r\n            // VSTS 1325771: Certain column charts don't display any data\r\n            // Wrap arround the month if is after december (value 11)\r\n            if (month > 11) {\r\n                month = month % 12;\r\n                year++;\r\n            }\r\n\r\n            day = Math.min(day, getMonthDays(year, month));\r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of weeks to the provided date.\r\n         * @param date - date value\r\n         * @param weeks - number of weeks to add\r\n         */\r\n        export function addWeeks(date: Date, weeks: number): Date { \r\n            return addDays(date, weeks * 7);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of days to the provided date.\r\n         * @param date - date value\r\n         * @param days - number of days to add\r\n         */\r\n        export function addDays(date: Date, days: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();           \r\n            let result = new Date(date.getTime());\r\n            result.setFullYear(year, month, day + days);\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of hours to the provided date.\r\n         * @param date - date value\r\n         * @param hours - number of hours to add\r\n         */\r\n        export function addHours(date: Date, hours: number): Date { \r\n            return new Date(date.getTime() + hours * 3600000);\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of minutes to the provided date.\r\n         * @param date - date value\r\n         * @param minutes - number of minutes to add\r\n         */\r\n        export function addMinutes(date: Date, minutes: number): Date { \r\n            return new Date(date.getTime() + minutes * 60000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of seconds to the provided date.\r\n         * @param date - date value\r\n         * @param seconds - number of seconds to add\r\n         */\r\n        export function addSeconds(date: Date, seconds: number): Date { \r\n            return new Date(date.getTime() + seconds * 1000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of milliseconds to the provided date.\r\n         * @param date - date value\r\n         * @param milliseconds - number of milliseconds to add\r\n         */\r\n        export function addMilliseconds(date: Date, milliseconds: number): Date { \r\n            return new Date(date.getTime() + milliseconds);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    // Constants\r\n    const maxExponent = 24;\r\n    const defaultScientificBigNumbersBoundary = 1E15;\r\n    const scientificSmallNumbersBoundary = 1E-4;\r\n    const PERCENTAGE_FORMAT = '%';\r\n    const SCIENTIFIC_FORMAT = 'E+0';\r\n    const DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\r\n\r\n    // Regular expressions\r\n    /**\r\n     * This regex looks for strings that match one of the following conditions:\r\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\r\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\r\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\r\n     * The entire string (start to end) must match, and the match is not case-sensitive.\r\n     */\r\n    const SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\r\n\r\n    export class DisplayUnit {\r\n        // Fields\r\n        public value: number;\r\n        public title: string;\r\n        public labelFormat: string;\r\n        public applicableRangeMin: number;\r\n        public applicableRangeMax: number;\r\n\r\n        // Methods\r\n        public project(value: number): number {\r\n            if (this.value) {\r\n                return Double.removeDecimalNoise(value / this.value);\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public reverseProject(value: number): number {\r\n            if (this.value) {\r\n                return value * this.value;\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public isApplicableTo(value: number): boolean {\r\n            value = Math.abs(value);\r\n            let precision = Double.getPrecision(value, 3);\r\n            return Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && Double.lessWithPrecision(value, this.applicableRangeMax, precision);\r\n        }\r\n\r\n        public isScaling(): boolean {\r\n            return this.value > 1;\r\n        }\r\n    }\r\n\r\n    export class DisplayUnitSystem {\r\n        // Fields\r\n        public units: DisplayUnit[];\r\n        public displayUnit: DisplayUnit;\r\n        private unitBaseValue: number;\r\n        protected static UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\r\n\r\n        // Constructor\r\n        constructor(units?: DisplayUnit[]) {\r\n            this.units = units ? units : [];\r\n        }\r\n\r\n        // Properties\r\n        public get title(): string {\r\n            return this.displayUnit ? this.displayUnit.title : undefined;\r\n        }\r\n\r\n        // Methods\r\n        public update(value: number): void {\r\n            if (value === undefined)\r\n                return;\r\n\r\n            this.unitBaseValue = value;\r\n            this.displayUnit = this.findApplicableDisplayUnit(value);\r\n        }\r\n\r\n        private findApplicableDisplayUnit(value: number): DisplayUnit {\r\n            for (let unit of this.units) {\r\n                if (unit.isApplicableTo(value))\r\n                    return unit;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        public format(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n            if (this.isFormatSupported(format)) {\r\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\r\n\r\n                if (this.hasScientitifcFormat(format)) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\r\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\r\n                }\r\n                if (decimals != null) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n            }\r\n            \r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        public isPercentageFormat(format: string): boolean {\r\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\r\n        }\r\n\r\n        public shouldRespectScalingUnit(format: string): boolean {\r\n            return !this.isPercentageFormat(format);\r\n        }\r\n\r\n        public getNumberOfDecimalsForFormatting(format: string, decimals?: number) {\r\n            return decimals;\r\n        }\r\n\r\n        public isScalingUnit(): boolean {\r\n            return this.displayUnit && this.displayUnit.isScaling();\r\n        }\r\n\r\n        private formatHelper(value: number, nonScientificFormat: string, format: string, decimals?: number, trailingZeros?: boolean) {\r\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\r\n            if ((format === 'g' || format === 'G') && decimals != null)\r\n                format = visuals.valueFormatter.DefaultNumericFormat;\r\n\r\n            format = NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\r\n\r\n            if (format && !formattingService.isStandardNumberFormat(format))\r\n                return formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\r\n\r\n            if (!format)\r\n                format = 'G';\r\n            if (!nonScientificFormat)\r\n                nonScientificFormat = '{0}';\r\n\r\n            let text = formattingService.formatValue(value, format);\r\n            return formattingService.format(nonScientificFormat, [text]);\r\n        }\r\n\r\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\r\n        public formatSingleValue(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            // Change unit base to a value appropriate for this value\r\n            this.update(this.shouldUseValuePrecision(value) ? Double.getPrecision(value, 8) : value);\r\n\r\n            return this.format(value, format, decimals, trailingZeros);\r\n        }\r\n\r\n        private shouldUseValuePrecision(value: number): boolean {\r\n            if (this.units.length === 0)\r\n                return true;\r\n\r\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\r\n            let applicableRangeMin: number = 0;\r\n            for (let i = 0; i < this.units.length; i++) {\r\n                if (this.units[i].isScaling()) {\r\n                    applicableRangeMin = this.units[i].applicableRangeMin;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return Math.abs(value) < applicableRangeMin;\r\n        }\r\n\r\n        protected isScientific(value: number): boolean {\r\n            return value < - defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\r\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\r\n        }\r\n\r\n        protected hasScientitifcFormat(format: string): boolean {\r\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\r\n        }\r\n\r\n        protected supportsScientificFormat(format: string): boolean {\r\n            if (format)\r\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\r\n\r\n            return true;\r\n        }\r\n\r\n        protected shouldFallbackToScientific(value: number, format: string): boolean {\r\n            return !this.hasScientitifcFormat(format)\r\n                && this.supportsScientificFormat(format)\r\n                && this.isScientific(value);\r\n        }\r\n\r\n        protected getScientificFormat(data: number, format: string, decimals: number, trailingZeros: boolean): string {\r\n            // Use scientific format outside of the range\r\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\r\n                let numericFormat = NumberFormat.getNumericFormat(data, format);\r\n                if (decimals)\r\n                    numericFormat = NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\r\n\r\n                if (numericFormat)\r\n                    return numericFormat + SCIENTIFIC_FORMAT;\r\n                else\r\n                    return DEFAULT_SCIENTIFIC_FORMAT;\r\n            }\r\n\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\r\n    export class NoDisplayUnitSystem extends DisplayUnitSystem {\r\n        // Constructor\r\n        constructor() {\r\n            super([]);\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\r\n        we are showing values (chart axes) and as such it is the default unit system. */\r\n    export class DefaultDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DefaultDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        // Methods\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n\r\n        public static reset(): void {\r\n            DefaultDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DefaultDisplayUnitSystem.units) {\r\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, (value: number, previousUnitValue: number, min: number) => {\r\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\r\n                    if (value - previousUnitValue >= 1000) {\r\n                        return value / 10;\r\n                    }\r\n\r\n                    return min;\r\n                });\r\n\r\n                // Ensure last unit has max of infinity\r\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DefaultDisplayUnitSystem.units;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\r\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\r\n        where we have restricted space but do not want to show partial units. */\r\n    export class WholeUnitsDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public static reset(): void {\r\n            WholeUnitsDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!WholeUnitsDisplayUnitSystem.units) {\r\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\r\n\r\n                // Ensure last unit has max of infinity\r\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n\r\n            return WholeUnitsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export class DataLabelsDisplayUnitSystem extends DisplayUnitSystem {\r\n\r\n        // Constants\r\n        private static AUTO_DISPLAYUNIT_VALUE = 0;\r\n        private static NONE_DISPLAYUNIT_VALUE = 1;\r\n        protected static UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\r\n\r\n        private static units: DisplayUnit[];\r\n\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DataLabelsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DataLabelsDisplayUnitSystem.units) {\r\n                let units = [];\r\n                let adjustMinBasedOnPreviousUnit = (value: number, previousUnitValue: number, min: number): number => {\r\n                    // Never returns true, we are always ignoring\r\n                    // We do not early switch (e.g. 100K instead of 0.1M)\r\n                    // Intended? If so, remove this function, otherwise, remove if statement\r\n                    if (value === -1)\r\n                        if (value - previousUnitValue >= 1000) {\r\n                            return value / 10;\r\n                        }\r\n                    return min;\r\n                };\r\n\r\n                // Add Auto & None\r\n                let names = unitLookup(-1);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                names = unitLookup(0);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                // Add normal units\r\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\r\n\r\n                // Ensure last unit has max of infinity\r\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DataLabelsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export interface DisplayUnitSystemNames {\r\n        title: string;\r\n        format: string;\r\n    }\r\n\r\n    function createDisplayUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames, adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number) {\r\n        let units = [];\r\n        for (let i = 3; i < maxExponent; i++) {\r\n            let names = unitLookup(i);\r\n            if (names)\r\n                addUnitIfNonEmpty(units, Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n        }\r\n\r\n        return units;\r\n    }\r\n\r\n    function addUnitIfNonEmpty(\r\n        units: DisplayUnit[],\r\n        value: number,\r\n        title: string,\r\n        labelFormat: string,\r\n        adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number): void {\r\n        if (title || labelFormat) {\r\n            let min = value;\r\n\r\n            if (units.length > 0) {\r\n                let previousUnit = units[units.length - 1];\r\n\r\n                if (adjustMinBasedOnPreviousUnit)\r\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\r\n\r\n                previousUnit.applicableRangeMax = min;\r\n            }\r\n            let unit = new DisplayUnit();\r\n            unit.value = value;\r\n            unit.applicableRangeMin = min;\r\n            unit.applicableRangeMax = min * 1000;\r\n            unit.title = title;\r\n            unit.labelFormat = labelFormat;\r\n            units.push(unit);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequence {\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;\r\n\r\n        private maxAllowedMargin: number;\r\n        private canExtendMin: boolean;\r\n        private canExtendMax: boolean;\r\n\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n        public min: number;\r\n        public max: number;\r\n        public precision: number;\r\n        public sequence: number[];\r\n\r\n        public static calculate (range: NumericSequenceRange, expectedCount: number, maxAllowedMargin?: number, minPower?: number, useZeroRefPoint?: boolean, steps?: number[]): NumericSequence {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\r\n            debug.assert(minPower === undefined|| (minPower >= Double.MIN_EXP && minPower <= Double.MAX_EXP), \"minPower\");\r\n            debug.assert(maxAllowedMargin === undefined|| (maxAllowedMargin >= 0), \"maxAllowedMargin\");\r\n\r\n            let result = new NumericSequence();\r\n\r\n            if (expectedCount === undefined)\r\n                expectedCount = 10;\r\n            else\r\n                expectedCount = Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (minPower === undefined)\r\n                minPower = Double.MIN_EXP;\r\n            if (useZeroRefPoint === undefined)\r\n                useZeroRefPoint = false;\r\n            if (maxAllowedMargin === undefined)\r\n                maxAllowedMargin = 1;\r\n            if (steps === undefined)\r\n                steps = [1, 2, 5];\r\n\r\n            // Handle single stop case\r\n            if (range.forcedSingleStop) {\r\n                result.interval = range.getSize();\r\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\r\n                result.min = range.min;\r\n                result.max = range.max;\r\n                result.sequence = [range.forcedSingleStop];\r\n                return result;\r\n            }\r\n\r\n            let interval = 0;\r\n            let min = 0;\r\n            let max = 9;\r\n            let canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\r\n            let canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\r\n\r\n            let size = range.getSize();\r\n            let exp = Double.log10(size);\r\n\r\n            // Account for Exp of steps\r\n            let stepExp = Double.log10(steps[0]);\r\n            exp = exp - stepExp;\r\n\r\n            // Account for MaxCount\r\n            let expectedCountExp = Double.log10(expectedCount);\r\n            exp = exp - expectedCountExp;\r\n\r\n            // Account for MinPower\r\n            exp = Math.max(exp, minPower - stepExp + 1);\r\n            let count = undefined;\r\n            // Create array of \"good looking\" numbers\r\n            if (interval !== 0) {\r\n                // If explicit interval is defined - use it instead of the steps array.\r\n                let power = Double.pow10(exp);\r\n                let roundMin = Double.floorToPrecision(range.min, power);\r\n                let roundMax = Double.ceilToPrecision(range.max, power);\r\n                let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\r\n\r\n                roundRange.shrinkByStep(range, interval);\r\n                min = roundRange.min;\r\n                max = roundRange.max;\r\n                count = Math.floor(roundRange.getSize() / interval);\r\n            }\r\n            else {\r\n                // No interval defined -> find optimal interval\r\n                let dexp;\r\n                for (dexp = 0; dexp < 3; dexp++) {\r\n                    let e = exp + dexp;\r\n                    let power = Double.pow10(e);\r\n\r\n                    let roundMin = Double.floorToPrecision(range.min, power);\r\n                    let roundMax = Double.ceilToPrecision(range.max, power);\r\n\r\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\r\n                    let stepsCount = steps.length;\r\n                    let stepPower = Double.pow10(e - 1);\r\n                    for (let i = 0; i < stepsCount; i++) {\r\n                        let step = steps[i] * stepPower;\r\n                        let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\r\n                        roundRange.shrinkByStep(range, step);\r\n\r\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\r\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\r\n                            roundRange.min -= step;\r\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\r\n                            roundRange.max += step;\r\n\r\n                        // Count the intervals\r\n                        count = Double.ceilWithPrecision(roundRange.getSize() / step);\r\n\r\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\r\n                            interval = step;\r\n                            min = roundRange.min;\r\n                            max = roundRange.max;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // Increase the scale power until the interval is found\r\n                    if (interval !== 0)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Avoid extreme count cases (>1000 ticks)\r\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\r\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\r\n                interval = (max - min) / count;\r\n            }\r\n\r\n            result.min = min;\r\n            result.max = max;\r\n            result.interval = interval;\r\n            result.intervalOffset = min - range.min;\r\n            result.maxAllowedMargin = maxAllowedMargin;\r\n            result.canExtendMin = canExtendMin;\r\n            result.canExtendMax = canExtendMax;\r\n\r\n            // Fill in the Sequence\r\n            let precision = Double.getPrecision(interval, 0);\r\n            result.precision = precision;\r\n\r\n            let sequence = [];\r\n\r\n            let x = Double.roundToPrecision(min, precision);\r\n            sequence.push(x);\r\n            for (let i = 0; i < count; i++) {\r\n                x = Double.roundToPrecision(x + interval, precision);\r\n                sequence.push(x);\r\n            }\r\n            \r\n            result.sequence = sequence;\r\n\r\n            result.trimMinMax(range.min, range.max);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid. \r\n         * @min - The minimum of the range.\r\n         * @max - The maximum of the range.\r\n         * @maxCount - The max count of intervals.\r\n         * @steps - array of intervals.\r\n         */\r\n        public static calculateUnits(min: number, max: number, maxCount: number, steps: number[]): NumericSequence {\r\n            // Initialization actions\r\n            maxCount = Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (min === max) {\r\n                max = min + 1;\r\n            }\r\n            let stepCount = 0;\r\n            let step = 0;\r\n\r\n            // Calculate step\r\n            for (let i = 0; i < steps.length; i++)\r\n            {\r\n                step = steps[i];\r\n                let maxStepCount = Double.ceilWithPrecision(max / step);\r\n                let minStepCount = Double.floorWithPrecision(min / step);\r\n                stepCount = maxStepCount - minStepCount;\r\n                    \r\n                if (stepCount <= maxCount) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Calculate the offset\r\n            let offset = -min;\r\n            offset = offset % step;\r\n\r\n            // Create sequence\r\n            let result = new NumericSequence();\r\n            result.sequence = [];\r\n            for (let x = min + offset; ; x += step)\r\n            {\r\n                result.sequence.push(x);\r\n                if (x >= max)\r\n                    break;\r\n            }\r\n            result.interval = step;\r\n            result.intervalOffset = offset;\r\n            result.min = result.sequence[0];\r\n            result.max = result.sequence[result.sequence.length - 1];\r\n            return result;\r\n        }\r\n\r\n        public trimMinMax(min: number, max: number): void {        \r\n            let minMargin = (min - this.min) / this.interval;\r\n            let maxMargin = (this.max - max) / this.interval;\r\n            let marginPrecision = 0.001;\r\n\r\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\r\n                this.min = min;\r\n            }\r\n\r\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\r\n                this.max = max;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequenceRange {\r\n        private static DEFAULT_MAX: number = 10;\r\n        private static MIN_SUPPORTED_DOUBLE = -1E307;\r\n        private static MAX_SUPPORTED_DOUBLE = 1E307;\r\n\r\n        public min: number;\r\n        public max: number;\r\n        public includeZero: boolean;\r\n        public forcedSingleStop: number;\r\n        public hasDataRange: boolean;\r\n        public hasFixedMin: boolean;\r\n        public hasFixedMax: boolean;\r\n\r\n        private _ensureIncludeZero(): void { \r\n            if (this.includeZero) {\r\n                // fixed min and max has higher priority than includeZero\r\n                if (this.min > 0 && !this.hasFixedMin) {\r\n                    this.min = 0;\r\n                }\r\n                if (this.max < 0 && !this.hasFixedMax) {\r\n                    this.max = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureNotEmpty(): void { \r\n            if (this.min === this.max) {\r\n                if (!this.min) {\r\n                    this.min = 0;\r\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\r\n                    this.hasFixedMin = true;\r\n                    this.hasFixedMax = true;\r\n                } else {\r\n                    // We are dealing with a single data value (includeZero is not set)\r\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\r\n                    // Interval is calculated based on the number:\r\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\r\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\r\n                    let value = this.min;\r\n                    let exp = Double.log10(Math.abs(value));\r\n                    let step: number;\r\n                    if (exp >= 0 && exp < 4) {\r\n                        step = 0.5;\r\n                        this.forcedSingleStop = value;\r\n                    } else {\r\n                        step = Double.pow10(exp) / 2;\r\n                        this.forcedSingleStop = null;\r\n                    }\r\n                    this.min = value - step;\r\n                    this.max = value + step;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureDirection() { \r\n            if (this.min > this.max) { \r\n                let temp = this.min;\r\n                this.min = this.max;\r\n                this.max = temp;\r\n            }\r\n        }\r\n\r\n        public getSize(): number {\r\n            return this.max - this.min;\r\n        }\r\n\r\n        public shrinkByStep(range: NumericSequenceRange, step: number) {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(step > 0, \"step\");\r\n\r\n            let oldCount = this.min / step;\r\n            let newCount = range.min / step;\r\n            let deltaCount = Math.floor(newCount - oldCount);\r\n            this.min += deltaCount * step;\r\n\r\n            oldCount = this.max / step;\r\n            newCount = range.max / step;\r\n            deltaCount = Math.ceil(newCount - oldCount);\r\n            this.max += deltaCount * step;\r\n        }\r\n\r\n        public static calculate(dataMin: number, dataMax: number, fixedMin?:number, fixedMax?:number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\r\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.includeZero = includeZero ? true : false;\r\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\r\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\r\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\r\n\r\n            dataMin = Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n            dataMax = Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n\r\n            // Calculate the range using the min, max, dataRange\r\n            if (result.hasFixedMin && result.hasFixedMax) {\r\n                result.min = fixedMin;\r\n                result.max = fixedMax;\r\n            } else if (result.hasFixedMin) {\r\n                result.min = fixedMin;\r\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\r\n            } else if (result.hasFixedMax) {\r\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\r\n                result.max = fixedMax;\r\n            } else if (result.hasDataRange) {\r\n                result.min = dataMin;\r\n                result.max = dataMax;\r\n            } else {\r\n                result.min = 0;\r\n                result.max = 0;\r\n            }\r\n\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            \r\n            if (result.min === 0) {\r\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\r\n            } else if (result.max === 0) {\r\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public static calculateDataRange(dataMin: number, dataMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\r\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\r\n            } else {\r\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\r\n            }\r\n        }\r\n\r\n        public static calculateFixedRange(fixedMin: number, fixedMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assertValue(fixedMin, \"fixedMin\");\r\n            debug.assertValue(fixedMax, \"fixedMax\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.hasDataRange = false;\r\n            result.includeZero = includeZero;\r\n            result.min = fixedMin;\r\n            result.max = fixedMax;\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            result.hasFixedMin = true;\r\n            result.hasFixedMax = true;\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export module ValueUtil {\r\n        export function hasValue(value: any): boolean {\r\n            return value !== undefined && value !== null;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n\r\n    /**\r\n     * Formats the value using provided format expression\r\n     * @param value - value to be formatted and converted to string.\r\n     * @param format - format to be applied if the number shouldn't be abbreviated.\r\n     * If the number should be abbreviated this string is checked for special characters like $ or % if any\r\n     */\r\n    export interface ICustomValueFormatter {\r\n        (value: any, format?: string): string;\r\n    }\r\n\r\n    export interface ICustomValueColumnFormatter {\r\n        (value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier): string;\r\n    }\r\n\r\n    export interface ValueFormatterOptions {\r\n        /** The format string to use. */\r\n        format?: string;\r\n\r\n        /** The data value. */\r\n        value?: any;\r\n\r\n        /** The data value. */\r\n        value2?: any;\r\n\r\n        /** The number of ticks. */\r\n        tickCount?: any;\r\n\r\n        /** The display unit system to use */\r\n        displayUnitSystemType?: DisplayUnitSystemType;\r\n\r\n        /** True if we are formatting single values in isolation (e.g. card), as opposed to multiple values with a common base (e.g. chart axes) */\r\n        formatSingleValues?: boolean;\r\n\r\n        /** True if we want to trim off unnecessary zeroes after the decimal and remove a space before the % symbol */\r\n        allowFormatBeautification?: boolean;\r\n\r\n        /** Specifies the maximum number of decimal places to show*/\r\n        precision?: number;\r\n\r\n        /** Detect axis precision based on value */\r\n        detectAxisPrecision?: boolean;\r\n\r\n        /** Specifies the column type of the data value */\r\n        columnType?: ValueTypeDescriptor;\r\n    }\r\n\r\n    export interface IValueFormatter {\r\n        format(value: any): string;\r\n        displayUnit?: DisplayUnit;\r\n        options?: ValueFormatterOptions;\r\n    }\r\n\r\n    /** Captures all locale-specific options used by the valueFormatter. */\r\n    export interface ValueFormatterLocalizationOptions {\r\n        null: string;\r\n        true: string;\r\n        false: string;\r\n        NaN: string;\r\n        infinity: string;\r\n        negativeInfinity: string;\r\n\r\n        /** Returns a beautified form the given format string. */\r\n        beautify(format: string): string;\r\n\r\n        /** Returns an object describing the given exponent in the current language. */\r\n        describe(exponent: number): DisplayUnitSystemNames;\r\n        restatementComma: string;\r\n        restatementCompoundAnd: string;\r\n        restatementCompoundOr: string;\r\n    }\r\n\r\n    export module valueFormatter {\r\n        import StringExtensions = jsCommon.StringExtensions;\r\n        const BeautifiedFormat: { [x: string]: string } = {\r\n            '0.00 %;-0.00 %;0.00 %': 'Percentage',\r\n            '0.0 %;-0.0 %;0.0 %': 'Percentage1',\r\n        };\r\n\r\n        export const DefaultIntegerFormat = 'g';\r\n        export const DefaultNumericFormat = '#,0.00';\r\n        export const DefaultDateFormat = 'd';\r\n\r\n        const defaultLocalizedStrings = {\r\n            'NullValue': '(Blank)',\r\n            'BooleanTrue': 'True',\r\n            'BooleanFalse': 'False',\r\n            'NaNValue': 'NaN',\r\n            'InfinityValue': '+Infinity',\r\n            'NegativeInfinityValue': '-Infinity',\r\n            'RestatementComma': '{0}, {1}',\r\n            'RestatementCompoundAnd': '{0} and {1}',\r\n            'RestatementCompoundOr': '{0} or {1}',\r\n            'DisplayUnitSystem_EAuto_Title': 'Auto',\r\n            'DisplayUnitSystem_E0_Title': 'None',\r\n            'DisplayUnitSystem_E3_LabelFormat': '{0}K',\r\n            'DisplayUnitSystem_E3_Title': 'Thousands',\r\n            'DisplayUnitSystem_E6_LabelFormat': '{0}M',\r\n            'DisplayUnitSystem_E6_Title': 'Millions',\r\n            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\r\n            'DisplayUnitSystem_E9_Title': 'Billions',\r\n            'DisplayUnitSystem_E12_LabelFormat': '{0}T',\r\n            'DisplayUnitSystem_E12_Title': 'Trillions',\r\n            'Percentage': '#,0.##%',\r\n            'Percentage1': '#,0.#%',\r\n            'TableTotalLabel': 'Total',\r\n            'Tooltip_HighlightedValueDisplayName': 'Highlighted',\r\n            'Funnel_PercentOfFirst': 'Percent of first',\r\n            'Funnel_PercentOfPrevious': 'Percent of previous',\r\n            'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlight)',\r\n            'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlight)',\r\n            // Geotagging strings\r\n            'GeotaggingString_Continent': 'continent',\r\n            'GeotaggingString_Continents': 'continents',\r\n            'GeotaggingString_Country': 'country',\r\n            'GeotaggingString_Countries': 'countries',\r\n            'GeotaggingString_State': 'state',\r\n            'GeotaggingString_States': 'states',\r\n            'GeotaggingString_City': 'city',\r\n            'GeotaggingString_Cities': 'cities',\r\n            'GeotaggingString_Town': 'town',\r\n            'GeotaggingString_Towns': 'towns',\r\n            'GeotaggingString_Province': 'province',\r\n            'GeotaggingString_Provinces': 'provinces',\r\n            'GeotaggingString_County': 'county',\r\n            'GeotaggingString_Counties': 'counties',\r\n            'GeotaggingString_Village': 'village',\r\n            'GeotaggingString_Villages': 'villages',\r\n            'GeotaggingString_Post': 'post',\r\n            'GeotaggingString_Zip': 'zip',\r\n            'GeotaggingString_Code': 'code',\r\n            'GeotaggingString_Place': 'place',\r\n            'GeotaggingString_Places': 'places',\r\n            'GeotaggingString_Address': 'address',\r\n            'GeotaggingString_Addresses': 'addresses',\r\n            'GeotaggingString_Street': 'street',\r\n            'GeotaggingString_Streets': 'streets',\r\n            'GeotaggingString_Longitude': 'longitude',\r\n            'GeotaggingString_Longitude_Short': 'lon',\r\n            'GeotaggingString_Latitude': 'latitude',\r\n            'GeotaggingString_Latitude_Short': 'lat',\r\n            'GeotaggingString_PostalCode': 'postal code',\r\n            'GeotaggingString_PostalCodes': 'postal codes',\r\n            'GeotaggingString_ZipCode': 'zip code',\r\n            'GeotaggingString_ZipCodes': 'zip codes',\r\n            'GeotaggingString_Territory': 'territory',\r\n            'GeotaggingString_Territories': 'territories',\r\n        };\r\n\r\n        function beautify(format: string): string {\r\n            let key = BeautifiedFormat[format];\r\n            if (key)\r\n                return defaultLocalizedStrings[key] || format;\r\n            return format;\r\n        }\r\n\r\n        function describeUnit(exponent: number): DisplayUnitSystemNames {\r\n            let exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\r\n\r\n            let title: string = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\r\n            let format: string = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\r\n\r\n            if (title || format)\r\n                return { title: title, format: format };\r\n        }\r\n\r\n        export function getLocalizedString(stringId: string): string {\r\n            return defaultLocalizedStrings[stringId];\r\n        }\r\n\r\n        // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\r\n        let locale: ValueFormatterLocalizationOptions = {\r\n            null: defaultLocalizedStrings['NullValue'],\r\n            true: defaultLocalizedStrings['BooleanTrue'],\r\n            false: defaultLocalizedStrings['BooleanFalse'],\r\n            NaN: defaultLocalizedStrings['NaNValue'],\r\n            infinity: defaultLocalizedStrings['InfinityValue'],\r\n            negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\r\n            beautify: format => beautify(format),\r\n            describe: exponent => describeUnit(exponent),\r\n            restatementComma: defaultLocalizedStrings['RestatementComma'],\r\n            restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\r\n            restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\r\n        };\r\n\r\n        const MaxScaledDecimalPlaces = 2;\r\n        const MaxValueForDisplayUnitRounding = 1000;\r\n        const MinIntegerValueForDisplayUnits = 10000;\r\n        const MinPrecisionForDisplayUnits = 2;\r\n\r\n        const DateTimeMetadataColumn: DataViewMetadataColumn = {\r\n            displayName: '',\r\n            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),\r\n        };\r\n\r\n        export function getFormatMetadata(format: string): powerbi.NumberFormat.NumericFormatMetadata {\r\n            return powerbi.NumberFormat.getCustomFormatMetadata(format);\r\n        }\r\n\r\n        export function setLocaleOptions(options: ValueFormatterLocalizationOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            locale = options;\r\n\r\n            DefaultDisplayUnitSystem.reset();\r\n            WholeUnitsDisplayUnitSystem.reset();\r\n        }\r\n\r\n        export function createDefaultFormatter(formatString: string, allowFormatBeautification: boolean = false): IValueFormatter {\r\n            let formatBeaut: string = allowFormatBeautification ? locale.beautify(formatString) : formatString;\r\n            return {\r\n                format: function (value: any): string {\r\n                    if (value == null)\r\n                        return locale.null;\r\n\r\n                    return formatCore(value, formatBeaut);\r\n                }\r\n            };\r\n        }\r\n\r\n        /** Creates an IValueFormatter to be used for a range of values. */\r\n        export function create(options: ValueFormatterOptions): IValueFormatter {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\r\n\r\n            if (shouldUseNumericDisplayUnits(options)) {\r\n                let displayUnitSystem = createDisplayUnitSystem(options.displayUnitSystemType);\r\n\r\n                let singleValueFormattingMode = !!options.formatSingleValues;\r\n\r\n                displayUnitSystem.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\r\n\r\n                let forcePrecision = options.precision != null;\r\n\r\n                let decimals: number;\r\n\r\n                if (forcePrecision)\r\n                    decimals = -options.precision;\r\n                else if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 1)\r\n                    decimals = -MaxScaledDecimalPlaces;\r\n\r\n                // Detect axis precision\r\n                if (options.detectAxisPrecision) {\r\n                    // Trailing zeroes\r\n                    forcePrecision = true;\r\n\r\n                    let axisValue = options.value;\r\n                    if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 0)\r\n                        axisValue = axisValue / displayUnitSystem.displayUnit.value;\r\n\r\n                    if (Double.isInteger(axisValue))\r\n                        decimals = 0;\r\n                    else\r\n                        decimals = Double.log10(axisValue);\r\n                }\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        let formattedValue: string = getStringFormat(value, true /*nullsAreBlank*/);\r\n                        if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                            return formattedValue;\r\n\r\n                        // Round to Double.DEFAULT_PRECISION\r\n                        if (value && !displayUnitSystem.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision)\r\n                            value = Double.roundToPrecision(value);\r\n\r\n                        return singleValueFormattingMode ?\r\n                            displayUnitSystem.formatSingleValue(value, format, decimals, forcePrecision) :\r\n                            displayUnitSystem.format(value, format, decimals, forcePrecision);\r\n                    },\r\n                    displayUnit: displayUnitSystem.displayUnit,\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\r\n                let unit = DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        if (value == null)\r\n                            return locale.null;\r\n\r\n                        let formatString = formattingService.dateFormatString(unit);\r\n                        return formatCore(value, formatString);\r\n                    },\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            return createDefaultFormatter(format);\r\n        }\r\n\r\n        export function format(value: any, format?: string, allowFormatBeautification?: boolean): string {\r\n            if (value == null)\r\n                return locale.null;\r\n\r\n            return formatCore(\r\n                value,\r\n                !!allowFormatBeautification ? locale.beautify(format) : format);\r\n        }\r\n\r\n        function getValueFormat(value: any, columnType: ValueTypeDescriptor): string {\r\n            // If column type not defined or is not datetime\r\n            // ...and the value is of time datetime,\r\n            // then use the default date format string\r\n            if ((!columnType || !columnType.dateTime) && value instanceof Date)\r\n                return getFormatString(DateTimeMetadataColumn, null, false);\r\n        }\r\n\r\n        export function formatValueColumn(value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier): string {\r\n            let valueFormat = getValueFormat(value, column.type);\r\n            if (valueFormat)\r\n                return formatCore(value, valueFormat);\r\n            else\r\n                return formatCore(value, getFormatString(column, formatStringProp));\r\n        }\r\n\r\n        function createDisplayUnitSystem(displayUnitSystemType?: DisplayUnitSystemType): DisplayUnitSystem {\r\n            if (displayUnitSystemType == null)\r\n                return new DefaultDisplayUnitSystem(locale.describe);\r\n\r\n            switch (displayUnitSystemType) {\r\n                case DisplayUnitSystemType.Default:\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.WholeUnits:\r\n                    return new WholeUnitsDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.Verbose:\r\n                    return new NoDisplayUnitSystem();\r\n                case DisplayUnitSystemType.DataLabels:\r\n                    return new DataLabelsDisplayUnitSystem(locale.describe);\r\n                default:\r\n                    debug.assertFail('Unknown display unit system type');\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n            }\r\n        }\r\n\r\n        function shouldUseNumericDisplayUnits(options: ValueFormatterOptions): boolean {\r\n            let value = options.value;\r\n            let value2 = options.value2;\r\n            let format = options.format;\r\n            // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\r\n            if (options.formatSingleValues && format) {\r\n\r\n                if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\r\n\r\n                    let isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\r\n\r\n                    if (isCustomFormat) {\r\n                        let precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\r\n\r\n                        if (precision < MinPrecisionForDisplayUnits)\r\n                            return false;\r\n                    }\r\n                    else if (Double.isInteger(value))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            if ((typeof value === 'number') || (typeof value2 === 'number')) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        function shouldUseDateUnits(value: any, value2?: any, tickCount?: number): boolean {\r\n            // must check both value and value2 because we'll need to get an interval for date units\r\n            return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\r\n        }\r\n\r\n        /*\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Column format\r\n         *  2. Default PowerView policy for column type\r\n         */\r\n        export function getFormatString(column: DataViewMetadataColumn, formatStringProperty: DataViewObjectPropertyIdentifier, suppressTypeFallback?: boolean): string {\r\n            if (column) {\r\n                if (formatStringProperty) {\r\n                    let propertyValue = DataViewObjects.getValue<string>(column.objects, formatStringProperty);\r\n                    if (propertyValue)\r\n                        return propertyValue;\r\n                }\r\n\r\n                if (!suppressTypeFallback) {\r\n                    let columnType = column.type;\r\n                    if (columnType) {\r\n                        if (columnType.dateTime)\r\n                            return DefaultDateFormat;\r\n                        if (columnType.integer)\r\n                            return DefaultIntegerFormat;\r\n                        if (columnType.numeric)\r\n                            return DefaultNumericFormat;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function formatListCompound(strings: string[], conjunction: string): string {\r\n            let result: string;\r\n\r\n            if (!strings) {\r\n                return null;\r\n            }\r\n\r\n            let length = strings.length;\r\n            if (length > 0) {\r\n                result = strings[0];\r\n                let lastIndex = length - 1;\r\n                for (let i = 1, len = lastIndex; i < len; i++) {\r\n                    let value = strings[i];\r\n                    result = StringExtensions.format(locale.restatementComma, result, value);\r\n                }\r\n\r\n                if (length > 1) {\r\n                    let value = strings[lastIndex];\r\n                    result = StringExtensions.format(conjunction, result, value);\r\n                }\r\n            }\r\n            else {\r\n                result = null;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., and C'  */\r\n        export function formatListAnd(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundAnd);\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., or C' */\r\n        export function formatListOr(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundOr);\r\n        }\r\n\r\n        function formatCore(value: any, format: string): string {\r\n            let formattedValue = getStringFormat(value, false /*nullsAreBlank*/);\r\n\r\n            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                return formattedValue;\r\n\r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        function getStringFormat(value: any, nullsAreBlank: boolean): string {\r\n            if (value == null && nullsAreBlank)\r\n                return locale.null;\r\n\r\n            if (value === true)\r\n                return locale.true;\r\n\r\n            if (value === false)\r\n                return locale.false;\r\n\r\n            if (typeof value === 'number' && isNaN(value))\r\n                return locale.NaN;\r\n\r\n            if (value === Number.NEGATIVE_INFINITY)\r\n                return locale.negativeInfinity;\r\n\r\n            if (value === Number.POSITIVE_INFINITY)\r\n                return locale.infinity;\r\n\r\n            return '';\r\n        }\r\n\r\n        export function getDisplayUnits(displayUnitSystemType: DisplayUnitSystemType): DisplayUnit[] {\r\n            let displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\r\n            return displayUnitSystem.units;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataRoleHelper {\r\n        export function getMeasureIndexOfRole(grouped: DataViewValueColumnGroup[], roleName: string): number {\r\n            if (!_.isEmpty(grouped)) {\r\n                let firstGroup = grouped[0];\r\n                if (firstGroup.values && firstGroup.values.length > 0) {\r\n                    for (let i = 0, len = firstGroup.values.length; i < len; ++i) {\r\n                        let value = firstGroup.values[i];\r\n                        if (value && value.source) {\r\n                            if (hasRole(value.source, roleName))\r\n                                return i;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function getCategoryIndexOfRole(categories: DataViewCategoryColumn[], roleName: string): number {\r\n            if (!_.isEmpty(categories)) {\r\n                for (let i = 0, ilen = categories.length; i < ilen; i++) {\r\n                    if (hasRole(categories[i].source, roleName))\r\n                        return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function hasRole(column: DataViewMetadataColumn, name: string): boolean {\r\n            let roles = column.roles;\r\n            return roles && roles[name];\r\n        }\r\n\r\n        export function hasRoleInDataView(dataView: DataView, name: string): boolean {\r\n            return dataView != null\r\n                && dataView.metadata != null\r\n                && dataView.metadata.columns\r\n                && _.any(dataView.metadata.columns, c => c.roles && c.roles[name] !== undefined);\r\n        }\r\n        \r\n        export function hasRoleInValueColumn(valueColumn: DataViewValueColumn, name: string): boolean {\r\n            return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\r\n\r\n    export function createIDataViewCategoricalReader(dataView: DataView): IDataViewCategoricalReader {\r\n        return new DataViewCategoricalReader(dataView);\r\n    }\r\n\r\n    export interface IDataViewCategoricalReader {\r\n        // Category functions\r\n        hasCategories(): boolean;\r\n        getCategoryCount(): number;\r\n        getCategoryValues(roleName: string): any;\r\n        getCategoryValue(roleName: string, categoryIndex: number): any;\r\n        getCategoryColumn(roleName: string): DataViewCategoryColumn;\r\n        getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn;\r\n        getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[];\r\n        getCategoryDisplayName(roleName: string): string;\r\n        hasCompositeCategories(): boolean;\r\n        hasCategoryWithRole(roleName: string): boolean;\r\n        getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects;\r\n        // Value functions\r\n        hasValues(roleName: string): boolean;\r\n        /**\r\n         * Obtains the value for the given role name, category index, and series index.\r\n         *\r\n         * Note: in cases where have multiple values in a role where the multiple values\r\n         * are not being used to create a static series, the first is obtained.\r\n         */\r\n        getValue(roleName: string, categoryIndex: number, seriesIndex?: number): any;\r\n        /**\r\n         * Obtains all the values for the given role name, category index, and series index, drawing\r\n         * from each of the value columns at that intersection.  Used when you have multiple\r\n         * values in a role that are not conceptually a static series.\r\n         */\r\n        getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex?: number): any[];\r\n        /**\r\n         * Obtains the first non-null value for the given role name and category index.\r\n         * It should mainly be used for values that are expected to be the same across\r\n         * series, but avoids false nulls when the data is sparse.\r\n         */\r\n        getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any;\r\n        getMeasureQueryName(roleName: string): string;\r\n        getValueColumn(roleName: string, seriesIndex?: number): DataViewValueColumn;\r\n        getValueMetadataColumn(roleName: string, seriesIndex?: number): DataViewMetadataColumn;\r\n        getValueDisplayName(roleName: string, seriesIndex?: number): string;\r\n        // Series Methods\r\n        hasDynamicSeries(): boolean;\r\n        getSeriesCount(): number;\r\n        getSeriesObjects(seriesIndex: number): DataViewObjects;\r\n        getSeriesValueColumns(): DataViewValueColumns;\r\n        getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup;\r\n        getSeriesMetadataColumn(): DataViewMetadataColumn;\r\n        getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[];\r\n        getSeriesName(seriesIndex: number): PrimitiveValue;\r\n        getSeriesDisplayName(): string;\r\n    }\r\n\r\n    /**\r\n     * A mapping used to map indeces within a specific roleName to an index into the values\r\n     * of a grouped.  This is used so that you can iterate over values within a role without\r\n     * expensive filtering or extra traversal.\r\n     */ \r\n    interface RoleIndexMapping {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    class DataViewCategoricalReader implements IDataViewCategoricalReader {\r\n        private dataView: DataView;\r\n        private categories: DataViewCategoryColumn[];\r\n        private grouped: DataViewValueColumnGroup[];\r\n        private dataHasDynamicSeries: boolean;\r\n        private valueRoleIndexMapping: RoleIndexMapping;\r\n        \r\n        // Validation variables\r\n        private hasValidCategories: boolean;\r\n        private hasAnyValidValues: boolean;\r\n\r\n        constructor(dataView: DataView) {\r\n            debug.assertValue(dataView, 'dataView');\r\n            this.dataView = dataView;\r\n            // Validate categories\r\n            let categorical: DataViewCategorical;\r\n            if (dataView)\r\n                categorical = dataView.categorical;\r\n            let categories: DataViewCategoryColumn[];\r\n            if (categorical)\r\n                categories = this.categories = categorical.categories;\r\n            this.hasValidCategories = !_.isEmpty(categories);\r\n\r\n            // Validate values\r\n            let values: DataViewValueColumns;\r\n            if (categorical)\r\n                values = categorical.values;\r\n            // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\r\n            // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\r\n            this.hasAnyValidValues = false;\r\n            if (values != null) {\r\n                let grouped = dataView.categorical.values.grouped();\r\n\r\n                if (grouped.length > 0) {\r\n                    this.hasAnyValidValues = true;\r\n                    this.grouped = grouped;\r\n\r\n                    // Iterate through the first group's values to populate the valueRoleIndexMapping\r\n                    let valueRoleIndexMapping: RoleIndexMapping = {};\r\n                    let firstGroupValues = grouped[0].values;\r\n                    for (let valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\r\n                        let valueRoles = firstGroupValues[valueIndex].source.roles;\r\n                        for (let role in valueRoles) {\r\n                            if (valueRoles[role]) {\r\n                                if (!valueRoleIndexMapping[role])\r\n                                    valueRoleIndexMapping[role] = [];\r\n                                valueRoleIndexMapping[role].push(valueIndex);\r\n                            }\r\n                        }\r\n                    }\r\n                    this.valueRoleIndexMapping = valueRoleIndexMapping;\r\n                }\r\n            }\r\n\r\n            if (this.hasAnyValidValues)\r\n                this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\r\n        }\r\n\r\n        // Category methods\r\n        \r\n        public hasCategories(): boolean {\r\n            return this.hasValidCategories;\r\n        }\r\n\r\n        public getCategoryCount(): number {\r\n            if (this.hasValidCategories)\r\n                return this.categories[0].values.length;\r\n            else\r\n                return 0;\r\n        }\r\n\r\n        public getCategoryValues(roleName: string): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryValue(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values[categoryIndex] : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumn(roleName: string): DataViewCategoryColumn {\r\n            if (this.hasValidCategories)\r\n                return this.getCategoryFromRole(roleName);\r\n        }\r\n\r\n        public getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.source : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[] {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.identityFields : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryDisplayName(roleName: string): string {\r\n            if (this.hasValidCategories) {\r\n                let targetColumn = this.getCategoryColumn(roleName);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        public hasCompositeCategories(): boolean {\r\n            if (this.hasValidCategories)\r\n                return this.categories.length > 1;\r\n        }\r\n\r\n        public hasCategoryWithRole(roleName: string): boolean {\r\n            return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\r\n        }\r\n\r\n        public getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects {\r\n            if (this.hasValidCategories) {\r\n                let category = this.getCategoryFromRole(roleName);\r\n                if (category && category.objects) {\r\n                    return category.objects[categoryIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        private getCategoryFromRole(roleName: string): DataViewCategoryColumn {\r\n            let categories = this.categories;\r\n            return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\r\n        }\r\n\r\n        // Value and measure methods\r\n\r\n        public hasValues(roleName: string): boolean {\r\n            return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\r\n        }\r\n\r\n        public getValue(roleName: string, categoryIndex: number, seriesIndex: number = 0): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    // For dynamic series, we only ever obtain the first value column from a role\r\n                    return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0);\r\n                }\r\n                else {\r\n                    // For static series or single series, we obtain value columns from the first series\r\n                    //    and use the seriesIndex to index into the value columns within the role\r\n                    return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex);\r\n                }\r\n            }\r\n        }\r\n\r\n        public getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex: number = 0): any[] {\r\n            if (this.hasValues(roleName)) {\r\n                let valuesInRole = [];\r\n                for (let roleValueIndex, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex));\r\n                }\r\n                return valuesInRole;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Obtains the value from grouped.\r\n         *\r\n         * Grouped:             [0] [1] [2] [3] (seriesIndex)\r\n         *                         /   \\\r\n         * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\r\n         *                    /    \\ \\  \\           \r\n         * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\r\n         * \r\n         *--------------------------------|\r\n         *                      |Category |\r\n         * Series|Value Columns |A B C D E|\r\n         *--------------------------------|\r\n         *      0|col0 (tooltip)|         |\r\n         *       |col1 (value)  |         |\r\n         *       |col2 (value)  |         |\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      1|col0 (tooltip)|         |\r\n         *       |col1 (value)  |0 1 2 3 4|\r\n         *       |col2 (value)  |5 6 7 8 9|\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      2|col0 (tooltip)|...      |\r\n         * \r\n         * valueColumnIndexInRole is for indexing into the values for a single role\r\n         * valueColumnIndex is for indexing into the entire value array including\r\n         * all roles\r\n         * \r\n         * The valueRoleIndexMapping converts roleValueIndex and role (value role\r\n         * with an index of 1) into groupedValueIndex (2)\r\n         *\r\n         * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\r\n         * the second value column with role \"value\" (which is converted to a\r\n         * groupedValueIndex of 2) and the fourth value within that value column.\r\n         */\r\n        private getValueInternal(roleName: string, categoryIndex: number, groupIndex: number, valueColumnIndexInRole: number): any {\r\n            if (this.hasValues(roleName)) {\r\n                let valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\r\n                return this.grouped[groupIndex].values[valueColumnIndex].values[categoryIndex];\r\n            }\r\n        }\r\n\r\n        public getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (!this.dataHasDynamicSeries) {\r\n                    debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\r\n                    return this.getValue(roleName, categoryIndex);\r\n                }\r\n                for (let seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\r\n                    let value = this.getValue(roleName, categoryIndex, seriesIndex);\r\n                    if (value != null) {\r\n                        return value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public getMeasureQueryName(roleName: string): string {\r\n            if (this.hasValues(roleName))\r\n                return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\r\n        }\r\n\r\n        public getValueColumn(roleName: string, seriesIndex: number = 0): DataViewValueColumn {\r\n            if (this.hasValues(roleName))\r\n                return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\r\n        }\r\n\r\n        public getValueMetadataColumn(roleName: string, seriesIndex: number = 0): DataViewMetadataColumn {\r\n            if (this.hasValues(roleName))\r\n                return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]].source;\r\n        }\r\n\r\n        public getValueDisplayName(roleName: string, seriesIndex?: number): string {\r\n            if (this.hasValues(roleName)) {\r\n                let targetColumn = this.getValueColumn(roleName, seriesIndex);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Series methods\r\n\r\n        public hasDynamicSeries(): boolean {\r\n            return this.dataHasDynamicSeries;\r\n        }\r\n\r\n        public getSeriesCount(): number {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped.length;\r\n        }\r\n\r\n        public getSeriesObjects(seriesIndex: number): DataViewObjects {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].objects;\r\n        }\r\n\r\n        public getSeriesValueColumns(): DataViewValueColumns {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values;\r\n        }\r\n\r\n        public getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex];\r\n        }\r\n\r\n        public getSeriesMetadataColumn(): DataViewMetadataColumn {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.source;\r\n        }\r\n\r\n        public getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[] {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.identityFields;\r\n        }\r\n\r\n        public getSeriesName(seriesIndex: number): PrimitiveValue {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].name;\r\n        }\r\n\r\n        public getSeriesDisplayName(): string {\r\n            if (this.hasAnyValidValues && this.dataHasDynamicSeries)\r\n                return this.dataView.categorical.values.source.displayName;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n    import valueFormatter = powerbi.visuals.valueFormatter;\r\n\r\n    export module DataViewConcatenateCategoricalColumns {\r\n\r\n        /* Represents a collection of DataViewCategoryColumn that are tied to the same role. */\r\n        interface CategoryColumnsByRole {\r\n            /* The name of the role shared by all the objects in the categories property. */\r\n            roleName: string;\r\n\r\n            /**\r\n             * The list of columns that are tied to roleName, in the same order as they appear\r\n             * in the categories property of their owner DataViewCategorical object.\r\n             */\r\n            categories: DataViewCategoryColumn[];\r\n        }\r\n\r\n        export function detectAndApply(\r\n            dataView: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            selects: DataViewSelectTransform[],\r\n            projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n\r\n            let result = dataView;\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            if (dataViewCategorical) {\r\n                let concatenationSource: CategoryColumnsByRole = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\r\n\r\n                if (concatenationSource) {\r\n                    // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\r\n                    let columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\r\n                    if (columnsSortedByProjectionOrdering.length >= 2) {\r\n                        let activeItemsToIgnoreInConcatenation =\r\n                            _.chain(projectionActiveItems[concatenationSource.roleName])\r\n                                .filter((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.suppressConcat)\r\n                                .map((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.queryRef)\r\n                                .value();\r\n\r\n                        result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\r\n        export function applyToPlayChartCategorical(\r\n            metadata: DataViewMetadata,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            categoryRoleName: string,\r\n            categorical: DataViewCategorical): DataView {\r\n            debug.assertValue(metadata, 'metadata');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let result: DataView;\r\n            if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\r\n                // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\r\n                // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\r\n                // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\r\n                // use inherit() rather than inheritSingle() here.\r\n                let transformingColumns = inherit(metadata.columns);\r\n                let transformingMetadata = inherit(metadata, m => { m.columns = transformingColumns; });\r\n\r\n                let transformingDataView = { metadata: transformingMetadata, categorical: categorical };\r\n                result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\r\n            }\r\n            else {\r\n                result = { metadata: metadata, categorical: categorical };\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the role and its assocated category columns (from dataViewCategorical.categories)\r\n         * that should be concatenated for the case of hierarchical group.\r\n         *\r\n         * Note: In the future if we support sibling hierarchical groups in categorical,\r\n         * change the return type to CategoryColumnsByRole[] and update detection logic.\r\n         */\r\n        function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical: DataViewCategorical, metadata: DataViewMetadata, dataViewMappings: DataViewMapping[], selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): CategoryColumnsByRole {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\r\n\r\n            let result: CategoryColumnsByRole;\r\n\r\n            // For now, just handle the case where roleMappings.length === 1.\r\n            // In the future, if there is more than 1, we might want to proceed if, \r\n            // for example, all role mappings map category to the same role name and they all have { max: 1 } conditions.\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\r\n            let projections = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let roleMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            let roleMappingForCategorical: DataViewMapping = (roleMappings && roleMappings.length === 1 && !!roleMappings[0].categorical) ? roleMappings[0] : undefined;\r\n            if (roleMappingForCategorical) {\r\n                let roleNamesForCategory: string[] = getAllRolesInCategories(roleMappingForCategorical.categorical);\r\n\r\n                // With \"list\" in role mapping, is it possible to have multiple role names for category.\r\n                // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\r\n                // We can change this if we want to support independent (sibling) group hierarchies in categorical.\r\n                if (roleNamesForCategory && roleNamesForCategory.length === 1) {\r\n                    let targetRoleName = roleNamesForCategory[0];\r\n\r\n                    let isVisualExpectingMaxOneCategoryColumn: boolean =\r\n                        !_.isEmpty(roleMappingForCategorical.conditions) &&\r\n                        _.every(roleMappingForCategorical.conditions, condition => condition[targetRoleName] && condition[targetRoleName].max === 1);\r\n\r\n                    if (isVisualExpectingMaxOneCategoryColumn) {\r\n                        let categoriesForTargetRole: DataViewCategoryColumn[] = _.filter(\r\n                            dataViewCategorical.categories,\r\n                            (categoryColumn: DataViewCategoryColumn) => categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName]);\r\n\r\n                        // At least for now, we expect all category columns for the same role to have the same number of value entries.\r\n                        // If that's not the case, we won't run the concatenate logic for that role at all...\r\n                        let areValuesCountsEqual: boolean = _.every(\r\n                            categoriesForTargetRole,\r\n                            (categoryColumn: DataViewCategoryColumn) => categoryColumn.values.length === categoriesForTargetRole[0].values.length);\r\n\r\n                        // Also, there is no need to concatenate columns unless there is actually more than one column\r\n                        if (areValuesCountsEqual &&\r\n                            categoriesForTargetRole.length >= 2) {\r\n                            result = {\r\n                                roleName: targetRoleName,\r\n                                categories: categoriesForTargetRole\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n        \r\n        /**\r\n         * Returns the array of role names that are mapped to categorical categories.\r\n         * Returns an empty array if none exists.\r\n         */\r\n        function getAllRolesInCategories(categoricalRoleMapping: DataViewCategoricalMapping): string[] {\r\n            debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\r\n\r\n            let roleNames: string[] = [];\r\n            DataViewMapping.visitCategoricalCategories(\r\n                categoricalRoleMapping.categories,\r\n                {\r\n                    visitRole: (roleName: string) => {\r\n                        roleNames.push(roleName);\r\n                    }\r\n                });\r\n\r\n            return roleNames;\r\n        }\r\n\r\n        function applyConcatenation(dataView: DataView, objectDescriptors: DataViewObjectDescriptors, roleName: string, columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let formatStringPropId: DataViewObjectPropertyIdentifier = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            let concatenatedValues: string[] = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\r\n\r\n            let columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, categoryColumn => categoryColumn.source);\r\n            let concatenatedColumnMetadata: DataViewMetadataColumn = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\r\n            let transformedDataView = inheritSingle(dataView);\r\n            addToMetadata(transformedDataView, concatenatedColumnMetadata);\r\n\r\n            let concatenatedCategoryColumn: DataViewCategoryColumn = createConcatenatedCategoryColumn(\r\n                columnsSortedByProjectionOrdering,\r\n                concatenatedColumnMetadata,\r\n                concatenatedValues);\r\n\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            let transformedCategoricalCategories: DataViewCategoryColumn[] = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\r\n            transformedCategoricalCategories.push(concatenatedCategoryColumn);\r\n\r\n            let transformedCategorical: DataViewCategorical = inheritSingle(dataViewCategorical);\r\n            transformedCategorical.categories = transformedCategoricalCategories;\r\n            transformedDataView.categorical = transformedCategorical;\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        function concatenateValues(columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[], formatStringPropId: DataViewObjectPropertyIdentifier): string[] {\r\n            debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\r\n            debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\r\n            debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\r\n\r\n            let concatenatedValues: string[] = [];\r\n\r\n            // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\r\n            for (let categoryColumn of columnsSortedByProjectionOrdering) {\r\n                let formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\r\n\r\n                for (let i = 0, len = categoryColumn.values.length; i < len; i++) {\r\n                    if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\r\n                        let value = categoryColumn.values && categoryColumn.values[i];\r\n                        let formattedValue = valueFormatter.format(value, formatString);\r\n                        concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return concatenatedValues;\r\n        }\r\n\r\n        /**\r\n        * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\r\n        */\r\n        function sortColumnsByProjectionOrdering(projectionOrdering: DataViewProjectionOrdering, roleName: string, columns: DataViewCategoryColumn[]): DataViewCategoryColumn[] {\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            let columnsInProjectionOrdering: DataViewCategoryColumn[];\r\n\r\n            if (projectionOrdering) {\r\n                // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\r\n                let columnsByIndex: { [index: number]: DataViewCategoricalColumn } = {};\r\n                for (let column of columns) {\r\n                    if (column.source.roles[roleName]) {\r\n                        debug.assert(!columnsByIndex[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\r\n                        columnsByIndex[column.source.index] = column;\r\n                    }\r\n                }\r\n\r\n                let columnIndicesInProjectionOrdering: number[] = projectionOrdering[roleName];\r\n\r\n                columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\r\n                    .map(columnIndex => columnsByIndex[columnIndex])\r\n                    .filter((column: DataViewCategoricalColumn) => !!column)\r\n                    .value();\r\n            }\r\n            else {\r\n                // If projectionOrder is unspecified, just return the columns for the specified role in their current order\r\n                columnsInProjectionOrdering = _.filter(columns, column => column.source.roles[roleName]);\r\n            }\r\n\r\n            return columnsInProjectionOrdering;\r\n        }\r\n\r\n        /**\r\n         * Creates the column metadata that will back the column with the concatenated values. \r\n         */\r\n        function createConcatenatedColumnMetadata(roleName: string, sourceColumnsSortedByProjectionOrdering: DataViewMetadataColumn[], queryRefsToIgnore?: string[]): DataViewMetadataColumn {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\r\n            debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(c => c.isMeasure).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\r\n\r\n            let concatenatedDisplayName: string;\r\n\r\n            for (let columnSource of sourceColumnsSortedByProjectionOrdering) {\r\n                if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\r\n                    concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\r\n                }\r\n            }\r\n\r\n            let newRoles: { [name: string]: boolean } = {};\r\n            newRoles[roleName] = true;\r\n\r\n            let newColumnMetadata: DataViewMetadataColumn = {\r\n                displayName: concatenatedDisplayName,\r\n                roles: newRoles,\r\n                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)\r\n            };\r\n\r\n            let columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\r\n            if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\r\n                newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\r\n            }\r\n\r\n            // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\r\n            // If queryName is not set at all, the column chart visual will only render column for the first group instance.\r\n            // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\r\n            newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\r\n\r\n            return newColumnMetadata;\r\n        }\r\n\r\n        function addToMetadata(transformedDataView: DataView, newColumn: DataViewMetadataColumn): void {\r\n            debug.assertValue(transformedDataView, 'transformedDataView');\r\n            debug.assertValue(newColumn, 'newColumn');\r\n\r\n            let transformedColumns = inheritSingle(transformedDataView.metadata.columns);\r\n            transformedColumns.push(newColumn);\r\n\r\n            let transformedMetadata = inheritSingle(transformedDataView.metadata);\r\n            transformedMetadata.columns = transformedColumns;\r\n\r\n            transformedDataView.metadata = transformedMetadata;\r\n        }\r\n\r\n        function createConcatenatedCategoryColumn(\r\n            sourceColumnsSortedByProjectionOrdering: DataViewCategoryColumn[],\r\n            columnMetadata: DataViewMetadataColumn,\r\n            concatenatedValues: string[]): DataViewCategoryColumn {\r\n            debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let newCategoryColumn: DataViewCategoryColumn = {\r\n                source: columnMetadata,\r\n                values: concatenatedValues\r\n            };\r\n\r\n            // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\r\n            // So, we'll just take the identities and identityFields from the first column\r\n            let firstColumn = sourceColumnsSortedByProjectionOrdering[0];\r\n\r\n            if (firstColumn.identity) {\r\n                newCategoryColumn.identity = firstColumn.identity;\r\n            }\r\n\r\n            if (firstColumn.identityFields) {\r\n                newCategoryColumn.identityFields = firstColumn.identityFields;\r\n            }\r\n\r\n            // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\r\n            if (firstColumn.objects) {\r\n                newCategoryColumn.objects = firstColumn.objects;\r\n            }\r\n\r\n            return newCategoryColumn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export const enum RoleItemContext {\r\n        CategoricalValue,\r\n        CategoricalValueGroup,\r\n    }\r\n\r\n    export interface IDataViewMappingVisitor {\r\n        visitRole(role: string, context?: RoleItemContext): void;\r\n        visitReduction?(reductionAlgorithm?: ReductionAlgorithm): void;\r\n    }\r\n\r\n    export module DataViewMapping {\r\n        export function visitMapping(mapping: DataViewMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let categorical = mapping.categorical;\r\n            if (categorical)\r\n                visitCategorical(categorical, visitor);\r\n\r\n            let table = mapping.table;\r\n            if (table)\r\n                visitTable(table, visitor);\r\n\r\n            let matrix = mapping.matrix;\r\n            if (matrix)\r\n                visitMatrix(matrix, visitor);\r\n\r\n            let tree = mapping.tree;\r\n            if (tree)\r\n                visitTree(tree, visitor);\r\n            \r\n            let single = mapping.single;\r\n            if (single)\r\n                visitSingle(single, visitor);\r\n        }\r\n\r\n        export function visitCategorical(mapping: DataViewCategoricalMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitCategoricalCategories(mapping.categories, visitor);\r\n\r\n            visitCategoricalValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitCategoricalCategories(mapping: DataViewRoleMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitCategoricalValues(mapping: DataViewRoleMapping | DataViewGroupedRoleMapping | DataViewListRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n\r\n                let groupedRoleMapping = <DataViewGroupedRoleMapping>mapping;\r\n                visitGrouped(groupedRoleMapping, visitor);\r\n\r\n                let group = groupedRoleMapping.group;\r\n                if (group) {\r\n                    for (let item of group.select) {\r\n                        visitBind(<DataViewRoleBindMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                        visitFor(<DataViewRoleForMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitTable(mapping: DataViewTableMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let rows = mapping.rows;\r\n            visitBind(<DataViewRoleBindMapping>rows, visitor);\r\n            visitFor(<DataViewRoleForMapping>rows, visitor);\r\n            visitList(<DataViewListRoleMapping>rows, visitor);\r\n\r\n            visitReduction(rows, visitor);\r\n        }\r\n\r\n        function visitMatrix(mapping: DataViewMatrixMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitMatrixItems(mapping.rows, visitor);\r\n            visitMatrixItems(mapping.columns, visitor);\r\n            visitMatrixItems(mapping.values, visitor);\r\n        }\r\n\r\n        /**\r\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         *\r\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         * @param visitor The visitor.\r\n         */\r\n        export function visitMatrixItems(mapping: DataViewRoleForMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitTree(mapping: DataViewTreeMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitTreeNodes(mapping.nodes, visitor);\r\n            visitTreeValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitTreeNodes(mapping: DataViewRoleForMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitTreeValues(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitBind(mapping: DataViewRoleBindMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let bind = mapping.bind;\r\n            if (bind) {\r\n                if (context != null)\r\n                    visitor.visitRole(bind.to, context);\r\n                else\r\n                    visitor.visitRole(bind.to);\r\n            }\r\n        }\r\n\r\n        function visitFor(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let forValue = mapping.for;\r\n            if (forValue) {\r\n                if (context != null)\r\n                    visitor.visitRole(forValue.in, context);\r\n                else\r\n                    visitor.visitRole(forValue.in);\r\n            }\r\n        }\r\n\r\n        function visitList(mapping: DataViewListRoleMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let select = mapping.select;\r\n            if (select) {\r\n                for (let item of select) {\r\n                    visitBind(<DataViewRoleBindMapping>item, visitor, context);\r\n                    visitFor(<DataViewRoleForMapping>item, visitor, context);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitGrouped(mapping: DataViewGroupedRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (!mapping)\r\n                return;\r\n\r\n            let group = mapping.group;\r\n            if (group) {\r\n                visitor.visitRole(group.by);\r\n\r\n                visitReduction(group, visitor);\r\n            }\r\n        }\r\n\r\n        function visitReduction(mapping: HasReductionAlgorithm, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (visitor.visitReduction) {\r\n                let reductionAlgorithm = mapping.dataReductionAlgorithm;\r\n                if (reductionAlgorithm) {\r\n                    visitor.visitReduction(reductionAlgorithm);\r\n                }\r\n            }\r\n        }\r\n\r\n        function visitSingle(mapping: DataViewSingleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitor.visitRole(mapping.role);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inheritSingle = Prototype.inheritSingle;\r\n\r\n    export interface DataViewNormalizeValuesApplyOptions {\r\n        dataview: DataView;\r\n        dataViewMappings: DataViewMapping[];\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a column is tied to any role that has required type(s).\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns true iff the column in the specified columnIndex is tied to any role that has required type(s), i.e. if the value in that column potentially needs to get normalized.\r\n     */\r\n    export interface IMetadataColumnFilter {\r\n        (columnIndex: number): boolean;\r\n    }\r\n\r\n    /**\r\n     * Returns true iff the specified value is of matching type as required by the role assigned to the column associated with this filter object.\r\n     */\r\n    export interface IColumnValueFilter {\r\n        (value: any): boolean;\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns false iff the specified value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     */\r\n    export interface IValueFilter {\r\n        (columnIndex: number, value: any): boolean;\r\n    }\r\n\r\n    export module DataViewNormalizeValues {\r\n        export function apply(options: DataViewNormalizeValuesApplyOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let rolesToNormalize = _.filter(options.dataRoles, role => !_.isEmpty(role.requiredTypes));\r\n\r\n            filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\r\n        }\r\n\r\n        export function filterVariantMeasures(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[]): void {\r\n            debug.assertValue(dataview, 'dataview');\r\n\r\n            // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\r\n                return;\r\n\r\n            let columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\r\n            let valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\r\n\r\n            let usedMappings = {};\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                // Get dataview specified in mappings which are also in dataview\r\n                for (let dataViewMappingProp in dataViewMapping) {\r\n                    if (dataview[dataViewMappingProp] != null)\r\n                        usedMappings[dataViewMappingProp] = true;\r\n                }\r\n            }\r\n\r\n            if (usedMappings['categorical'])\r\n                filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\r\n            if (usedMappings['table'])\r\n                filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\r\n            if (usedMappings['tree'])\r\n                filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\r\n            if (usedMappings['matrix'])\r\n                filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\r\n            if (usedMappings['single'])\r\n                filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\r\n        }\r\n\r\n        export function generateMetadataColumnFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IMetadataColumnFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => false;\r\n\r\n            let columnsToNormalize = {};\r\n            for (let column of columns) {\r\n                let roles = column.roles;\r\n                if (!roles)\r\n                    continue;\r\n                for (let role of rolesToNormalize) {\r\n                    if (!roles[role.name])\r\n                        continue;\r\n                    columnsToNormalize[column.index] = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return (columnIndex: number) => {\r\n                if (isNaN(columnIndex))\r\n                    return false;\r\n\r\n                return !!columnsToNormalize[columnIndex];\r\n            };\r\n        }\r\n\r\n        export function generateValueFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IValueFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => true;\r\n\r\n            let columnValueFilters: IColumnValueFilter[] = [];\r\n\r\n            // Build columnValueFilters based on role requiredTypes\r\n            for (let column of columns) {\r\n                let columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\r\n\r\n                if (columnValueFilter)\r\n                    columnValueFilters[column.index] = columnValueFilter;\r\n            }\r\n\r\n            return <IValueFilter>(columnIndex: number, value: any) => {\r\n                if (columnValueFilters[columnIndex])\r\n                    return columnValueFilters[columnIndex](value);\r\n\r\n                return true;\r\n            };\r\n        }\r\n\r\n        function generateColumnValueFilter(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): IColumnValueFilter {\r\n            let requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\r\n\r\n            if (_.isEmpty(requiredTypes))\r\n                return;\r\n\r\n            return (value: any): boolean => {\r\n                return doesValueMatchTypes(value, requiredTypes);\r\n            };\r\n        }\r\n\r\n        export function getColumnRequiredTypes(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): ValueType[] {\r\n            let requiredTypes = [];\r\n            let columnRoles = column && column.roles;\r\n\r\n            if (!columnRoles)\r\n                return requiredTypes;\r\n\r\n            for (let role of rolesToNormalize) {\r\n                if (!columnRoles[role.name])\r\n                    continue;\r\n                for (let typeDescriptor of role.requiredTypes) {\r\n                    let type = ValueType.fromDescriptor(typeDescriptor);\r\n                    requiredTypes.push(type);\r\n                }\r\n            }\r\n\r\n            return requiredTypes;\r\n        }\r\n\r\n        function filterVariantMeasuresCategorical(dataview: DataViewCategorical, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let values = dataview && dataview.values;\r\n            if (!values)\r\n                return;\r\n\r\n            let valuesGrouped = values.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            for (let valueGroup of valuesGrouped) {\r\n                let valuesInGroup = valueGroup.values;\r\n                for (let valueColumn of valuesInGroup) {\r\n                    let columnIndex = valueColumn.source.index;\r\n                    if (!columnFilter(columnIndex))\r\n                        continue;\r\n\r\n                    for (let i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\r\n                        valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTable(dataview: DataViewTable, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let columns = dataview && dataview.columns;\r\n\r\n            if (!columns)\r\n                return;\r\n\r\n            let filteredColumns = [];\r\n            for (let column of columns) {\r\n                if (columnFilter(column.index))\r\n                    filteredColumns.push(column.index);\r\n            }\r\n\r\n            let rows = dataview.rows;\r\n            for (let i = 0, ilen = rows.length; i < ilen; i++) {\r\n                for (let index of filteredColumns) {\r\n                    rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTreeNode(node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let columnIndex in node.values) {\r\n                    // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\r\n                    if (columnFilter(<any>columnIndex)) {\r\n                        // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\r\n                        if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\r\n                            node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', <any>columnIndex, valueFilter);\r\n                        else // if node.values[columnIndex] is a primitive value\r\n                            node.values = normalizeVariant(node.values, columnIndex, <any>columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresMatrix(dataview: DataViewMatrix, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let root = dataview && dataview.rows && dataview.rows.root;\r\n\r\n            if (!root)\r\n                return;\r\n\r\n            // Recurse into rows.children\r\n            // e.g. rows.children -> .children -> .children.values\r\n            filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\r\n        }\r\n\r\n        function filterVariantMeasuresMatrixRecursive(dataviewMatrix: DataViewMatrix, node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let id in node.values) {\r\n                    // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\r\n                    let nodeValue: DataViewMatrixNodeValue = node.values[id];\r\n\r\n                    // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\r\n                    let valueSourceIndex: number = nodeValue.valueSourceIndex || 0;\r\n\r\n                    // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\r\n                    let columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\r\n\r\n                    if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\r\n                        node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresSingle(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[], valueFilter: IValueFilter): void {\r\n            if (!dataview.single)\r\n                return;\r\n\r\n            let roleNames: string[] = [];\r\n            for (let role of rolesToNormalize) {\r\n                if (role.name)\r\n                    roleNames.push(role.name);\r\n            }\r\n\r\n            let columns = dataview.metadata.columns;\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                let roleName = dataViewMapping.single.role;\r\n                if (roleNames.indexOf(roleName) !== -1) {\r\n                    let column = firstColumnByRoleName(columns, roleName);\r\n                    if (column)\r\n                        dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        export function normalizeVariant<T>(object: T, key: string|number, columnIndex: number, valueFilter: IValueFilter): T {\r\n            if (!object)\r\n                return;\r\n\r\n            let value = object[key];\r\n            if (value !== null && !valueFilter(columnIndex, value)) {\r\n                object = inheritSingle(object);\r\n                object[key] = null;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        function doesValueMatchTypes<T>(value: T, types: ValueType[]): boolean {\r\n            for (let type of types) {\r\n                if (type.numeric || type.integer)\r\n                    return typeof (value) === 'number';\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function firstColumnByRoleName(columns: DataViewMetadataColumn[], roleName: string): DataViewMetadataColumn {\r\n            for (let column of columns) {\r\n                let columnRoles = column && column.roles;\r\n                if (columnRoles && columnRoles[roleName])\r\n                    return column;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewObjects {\r\n        /** Gets the value of the given object/property pair. */\r\n        export function getValue<T>(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultValue?: T): T {\r\n            debug.assertAnyValue(objects, 'objects');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            if (!objects)\r\n                return defaultValue;\r\n\r\n            let objectOrMap = objects[propertyId.objectName];\r\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\r\n\r\n            let object = <DataViewObject>objectOrMap;\r\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\r\n        }\r\n\r\n        /** Gets an object from objects. */\r\n        export function getObject(objects: DataViewObjects, objectName: string, defaultValue?: DataViewObject): DataViewObject {\r\n            if (objects && objects[objectName]) {\r\n                let object = <DataViewObject>objects[objectName];\r\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\r\n                return object;\r\n            }\r\n            else {\r\n                return defaultValue;\r\n            }\r\n        }\r\n\r\n        /** Gets a map of user-defined objects. */\r\n        export function getUserDefinedObjects(objects: DataViewObjects, objectName: string): DataViewObjectMap {\r\n            if (objects && objects[objectName]) {\r\n                let map = <DataViewObjectMap>objects[objectName];\r\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\r\n                return map;\r\n            }\r\n        }\r\n\r\n        /** Gets the solid color from a fill property. */\r\n        export function getFillColor(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultColor?: string): string {\r\n            let value: Fill = getValue(objects, propertyId);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n\r\n        /** Returns true if the given object represents a collection of user-defined objects */\r\n        export function isUserDefined(objectOrMap: DataViewObject | DataViewObjectMap): boolean {\r\n            return _.isArray(objectOrMap);\r\n        }\r\n    }\r\n\r\n    export module DataViewObject {\r\n        export function getValue<T>(object: DataViewObject, propertyName: string, defaultValue?: T): T {\r\n            debug.assertAnyValue(object, 'object');\r\n            debug.assertValue(propertyName, 'propertyName');\r\n\r\n            if (!object)\r\n                return defaultValue;\r\n\r\n            let propertyValue = <T>object[propertyName];\r\n            if (propertyValue === undefined)\r\n                return defaultValue;\r\n\r\n            return propertyValue;\r\n        }\r\n\r\n        /** Gets the solid color from a fill property using only a propertyName */\r\n        export function getFillColorByPropertyName(objects: DataViewObjects, propertyName: string, defaultColor?: string): string {\r\n            let value: Fill = DataViewObject.getValue(objects, propertyName);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import JsonComparer = jsCommon.JsonComparer;\r\n\r\n    /** Defines the values for particular objects. */\r\n    export interface DataViewObjectDefinitions {\r\n        [objectName: string]: DataViewObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinition {\r\n        selector?: Selector;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export interface DataViewObjectPropertyDefinitions {\r\n        [name: string]: DataViewObjectPropertyDefinition;\r\n    }\r\n\r\n    export type DataViewObjectPropertyDefinition = SQExpr | StructuralObjectDefinition;\r\n\r\n    export module DataViewObjectDefinitions {\r\n\r\n        /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\r\n        export function ensure(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                defns[objectName] = defnsForObject = [];\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n\r\n            let newDefn: DataViewObjectDefinition = {\r\n                selector: selector,\r\n                properties: {},\r\n            };\r\n            defnsForObject.push(newDefn);\r\n\r\n            return newDefn;\r\n        }\r\n\r\n        export function deleteProperty(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector,\r\n            propertyName: string): void {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defn = getObjectDefinition(defns, objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\r\n        }\r\n        \r\n        export function setValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n            debug.assertValue(defns, 'defns');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        export function getValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinition {\r\n\r\n            let properties = getPropertyContainer(defns, propertyId, selector);\r\n            if (!properties)\r\n                return;\r\n\r\n            return properties[propertyId.propertyName];\r\n        }\r\n\r\n        export function getPropertyContainer(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinitions {\r\n\r\n            let defn = getObjectDefinition(defns, propertyId.objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            return defn.properties;\r\n        }\r\n\r\n        export function getObjectDefinition(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertAnyValue(defns, 'defns');\r\n            debug.assertValue(objectName, 'objectName');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!defns)\r\n                return;\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                return;\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n        }\r\n\r\n        export function propertiesAreEqual(a: DataViewObjectPropertyDefinition, b: DataViewObjectPropertyDefinition): boolean {\r\n            if (a instanceof SemanticFilter && b instanceof SemanticFilter) {\r\n                return SemanticFilter.isSameFilter(<SemanticFilter>a, <SemanticFilter>b);\r\n            }\r\n\r\n            return JsonComparer.equals(a, b);\r\n        }\r\n\r\n        export function allPropertiesAreEqual(a: DataViewObjectPropertyDefinitions, b: DataViewObjectPropertyDefinitions): boolean {\r\n            debug.assertValue(a, 'a');\r\n            debug.assertValue(b, 'b');\r\n\r\n            if (Object.keys(a).length !== Object.keys(b).length)\r\n                return false;\r\n\r\n            for (let property in a) {\r\n                if (!propertiesAreEqual(a[property], b[property]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function encodePropertyValue(value: DataViewPropertyValue, valueTypeDescriptor: ValueTypeDescriptor): DataViewObjectPropertyDefinition {\r\n            debug.assertAnyValue(value, 'value');\r\n            debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\r\n\r\n            if (valueTypeDescriptor.bool) {\r\n                if (typeof (value) !== 'boolean')\r\n                    value = false; // This is fallback, which doesn't really belong here.\r\n\r\n                return SQExprBuilder.boolean(<boolean>value);\r\n            }\r\n            else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\r\n                return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.numeric) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).fill) {\r\n                if (value) {\r\n                    return {\r\n                        solid: { color: SQExprBuilder.text(<string>value) }\r\n                    };\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.formatting) {\r\n                if (valueTypeDescriptor.formatting.labelDisplayUnits) {\r\n                    return SQExprBuilder.double(+value);\r\n                }\r\n                else {\r\n                    return SQExprBuilder.text(<string>value);\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.enumeration) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n                else\r\n                    return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.misc) {\r\n                if (value) {\r\n                    value = SQExprBuilder.text(<string>value);\r\n                } else {\r\n                    value = null;\r\n                }\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).image) {\r\n                if (value) {\r\n                    let imageValue = <ImageValue>value;\r\n                    let imageDefinition: ImageDefinition = {\r\n                        name: SQExprBuilder.text(imageValue.name),\r\n                        url: SQExprBuilder.text(imageValue.url),\r\n                    };\r\n\r\n                    if (imageValue.scaling)\r\n                        imageDefinition.scaling = SQExprBuilder.text(imageValue.scaling);\r\n\r\n                    return imageDefinition;\r\n                }\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        export function clone(original: DataViewObjectDefinitions): DataViewObjectDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            let cloned: DataViewObjectDefinitions = {};\r\n\r\n            for (let objectName in original) {\r\n                let originalDefns = original[objectName];\r\n                if (_.isEmpty(originalDefns))\r\n                    continue;\r\n\r\n                let clonedDefns: DataViewObjectDefinition[] = [];\r\n                for (let originalDefn of originalDefns) {\r\n                    clonedDefns.push({\r\n                        properties: cloneProperties(originalDefn.properties),\r\n                        selector: originalDefn.selector,\r\n                    });\r\n                }\r\n                cloned[objectName] = clonedDefns;\r\n            }\r\n\r\n            return cloned;\r\n        }\r\n\r\n        function cloneProperties(original: DataViewObjectPropertyDefinitions): DataViewObjectPropertyDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\r\n            return _.clone(original);\r\n        }\r\n    }\r\n\r\n    export module DataViewObjectDefinition {\r\n\r\n        export function deleteSingleProperty(\r\n            defn: DataViewObjectDefinition,\r\n            propertyName: string): void {\r\n\r\n            //note: We decided that delete is acceptable here and that we don't need optimization here\r\n            delete defn.properties[propertyName];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module DataViewObjectDescriptors {\r\n        /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\r\n        export function findFormatString(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let formattingTypeDesc = ValueType.fromDescriptor(propDesc.type).formatting;\r\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\r\n        export function findFilterOutput(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.filter;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\r\n        export function findDefaultValue(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.expression && propType.expression.defaultValue;\r\n                });\r\n        }\r\n\r\n        function findProperty(descriptors: DataViewObjectDescriptors, propPredicate: (propDesc: DataViewObjectPropertyDescriptor) => boolean): DataViewObjectPropertyIdentifier {\r\n            debug.assertAnyValue(descriptors, 'descriptors');\r\n            debug.assertAnyValue(propPredicate, 'propPredicate');\r\n\r\n            if (!descriptors)\r\n                return;\r\n\r\n            for (let objectName in descriptors) {\r\n                let objPropDescs = descriptors[objectName].properties;\r\n\r\n                for (let propertyName in objPropDescs) {\r\n                    if (propPredicate(objPropDescs[propertyName])) {\r\n                        return {\r\n                            objectName: objectName,\r\n                            propertyName: propertyName,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n*  Power BI Visualizations\r\n*\r\n*  Copyright (c) Microsoft Corporation\r\n*  All rights reserved. \r\n *  MIT License\r\n*\r\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n*  in the Software without restriction, including without limitation the rights\r\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*  copies of the Software, and to permit persons to whom the Software is\r\n*  furnished to do so, subject to the following conditions:\r\n*   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n*   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n*  THE SOFTWARE.\r\n*/\r\n\r\nmodule powerbi.data {\r\n    export interface DataViewObjectDefinitionsByRepetition {\r\n        metadataOnce?: DataViewObjectDefinitionsForSelector;\r\n        userDefined?: DataViewObjectDefinitionsForSelector[];\r\n        metadata?: DataViewObjectDefinitionsForSelector[];\r\n        data: DataViewObjectDefinitionsForSelectorWithRule[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelector {\r\n        selector?: Selector;\r\n        objects: DataViewNamedObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelectorWithRule extends DataViewObjectDefinitionsForSelector {\r\n        rules?: RuleEvaluation[];\r\n    }\r\n\r\n    export interface DataViewNamedObjectDefinition {\r\n        name: string;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export module DataViewObjectEvaluationUtils {\r\n        export function evaluateDataViewObjects(\r\n            evalContext: IEvalContext,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewObjects {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let objects: DataViewObjects;\r\n\r\n            for (let j = 0, jlen = objectDefns.length; j < jlen; j++) {\r\n                let objectDefinition = objectDefns[j],\r\n                    objectName = objectDefinition.name;\r\n\r\n                let evaluatedObject: DataViewObject = DataViewObjectEvaluator.run(\r\n                    evalContext,\r\n                    objectDescriptors[objectName],\r\n                    objectDefinition.properties);\r\n\r\n                if (!evaluatedObject)\r\n                    continue;\r\n\r\n                if (!objects)\r\n                    objects = {};\r\n\r\n                // NOTE: this currently has last-object-wins semantics.\r\n                objects[objectName] = evaluatedObject;\r\n            }\r\n\r\n            return objects;\r\n        }\r\n\r\n        export function groupObjectsBySelector(objectDefinitions: DataViewObjectDefinitions): DataViewObjectDefinitionsByRepetition {\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n\r\n            let grouped: DataViewObjectDefinitionsByRepetition = {\r\n                data: [],\r\n            };\r\n\r\n            if (objectDefinitions) {\r\n                for (let objectName in objectDefinitions) {\r\n                    let objectDefnList = objectDefinitions[objectName];\r\n\r\n                    for (let i = 0, len = objectDefnList.length; i < len; i++) {\r\n                        let objectDefn = objectDefnList[i];\r\n\r\n                        ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\r\n                            name: objectName,\r\n                            properties: objectDefn.properties,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return grouped;\r\n        }\r\n\r\n        function ensureDefinitionListForSelector(grouped: DataViewObjectDefinitionsByRepetition, selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(grouped, 'grouped');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!selector) {\r\n                if (!grouped.metadataOnce)\r\n                    grouped.metadataOnce = { objects: [] };\r\n                return grouped.metadataOnce;\r\n            }\r\n\r\n            let groupedObjects: DataViewObjectDefinitionsForSelector[];\r\n            if (selector.data) {\r\n                groupedObjects = grouped.data;\r\n            }\r\n            else if (selector.metadata) {\r\n                if (!grouped.metadata)\r\n                    grouped.metadata = [];\r\n                groupedObjects = grouped.metadata;\r\n            }\r\n            else if (selector.id) {\r\n                if (!grouped.userDefined)\r\n                    grouped.userDefined = [];\r\n                groupedObjects = grouped.userDefined;\r\n            }\r\n\r\n            debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\r\n\r\n            for (let item of groupedObjects) {\r\n                if (Selector.equals(selector, item.selector))\r\n                    return item;\r\n            }\r\n\r\n            let item: DataViewObjectDefinitionsForSelector = {\r\n                selector: selector,\r\n                objects: [],\r\n            };\r\n            groupedObjects.push(item);\r\n\r\n            return item;\r\n        }\r\n\r\n        export function addImplicitObjects(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            if (selectTransforms) {\r\n                addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n                addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n            }\r\n        }\r\n\r\n        function addDefaultFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let formatStringProp = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            if (!formatStringProp)\r\n                return;\r\n\r\n            for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n                let selectTransform = selectTransforms[selectIdx];\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyFormatString(\r\n                    objectsForAllSelectors,\r\n                    formatStringProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\r\n            }\r\n        }\r\n\r\n        /** Registers properties for default value, if the properties are not explicitly provided. */\r\n        function addDefaultValue (\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let defaultValueProp = DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\r\n            if (!defaultValueProp)\r\n                return;\r\n\r\n            for (let selectTransform of selectTransforms) {\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyDefaultValue(\r\n                    objectsForAllSelectors,\r\n                    defaultValueProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.defaultValue);\r\n            }\r\n        }\r\n\r\n        function getColumnFormatForIndex(columns: DataViewMetadataColumn[], selectIdx: number): string {\r\n            for (let columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\r\n                let column = columns[columnIdx];\r\n                if (!column || column.index !== selectIdx)\r\n                    continue;\r\n\r\n                return column.format;\r\n            }\r\n        }\r\n\r\n        function applyFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            formatStringProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            formatStringValue: string): void {\r\n            if (!formatStringValue)\r\n                return;\r\n\r\n            // There is a format string specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                formatStringProp,\r\n                { metadata: queryName },\r\n                SQExprBuilder.text(formatStringValue));\r\n        }\r\n\r\n        function applyDefaultValue(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            defaultValueProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            defaultValue: DefaultValueDefinition): void {\r\n            if (!defaultValue)\r\n                return;\r\n\r\n            // There is a default value specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                defaultValueProp,\r\n                { metadata: queryName },\r\n                defaultValue);\r\n        }\r\n\r\n        function applyMetadataProperty(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n\r\n            let objectDefns: DataViewObjectDefinitionsForSelector[];\r\n            if (selector) {\r\n                let metadataObjects = objectsForAllSelectors.metadata;\r\n                if (!metadataObjects)\r\n                    metadataObjects = objectsForAllSelectors.metadata = [];\r\n                objectDefns = metadataObjects;\r\n            }\r\n            else {\r\n                let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n                if (!metadataOnce)\r\n                    metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\r\n                objectDefns = [metadataOnce];\r\n            }\r\n\r\n            let targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\r\n            let targetObjectDefn: DataViewNamedObjectDefinition;\r\n            if (targetMetadataObject) {\r\n                let targetObjectDefns = targetMetadataObject.objects;\r\n                targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\r\n                if (targetObjectDefn) {\r\n                    if (targetObjectDefn.properties[propertyId.propertyName])\r\n                        return;\r\n                }\r\n                else {\r\n                    targetObjectDefn = {\r\n                        name: propertyId.objectName,\r\n                        properties: {},\r\n                    };\r\n                    targetObjectDefns.push(targetObjectDefn);\r\n                }\r\n            }\r\n            else {\r\n                targetObjectDefn = {\r\n                    name: propertyId.objectName,\r\n                    properties: {}\r\n                };\r\n\r\n                objectDefns.push({\r\n                    selector: selector,\r\n                    objects: [targetObjectDefn],\r\n                });\r\n            }\r\n\r\n            targetObjectDefn.properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        function findWithMatchingSelector(objects: DataViewObjectDefinitionsForSelector[], selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(objects, 'objects');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            for (let i = 0, len = objects.length; i < len; i++) {\r\n                let object = objects[i];\r\n                if (Selector.equals(object.selector, selector))\r\n                    return object;\r\n            }\r\n        }\r\n\r\n        function findExistingObject(objectDefns: DataViewNamedObjectDefinition[], objectName: string): DataViewNamedObjectDefinition {\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(objectName, 'objectName');\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefn = objectDefns[i];\r\n\r\n                if (objectDefn.name === objectName)\r\n                    return objectDefn;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n \r\n\r\nmodule powerbi.data {\r\n    /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\r\n    export module DataViewObjectEvaluator {\r\n        const colorValueType: ValueType = ValueType.fromDescriptor({ formatting: { color: true } });\r\n        const numericType: ValueType = ValueType.fromDescriptor({ numeric: true });\r\n        const textType: ValueType = ValueType.fromDescriptor({ text: true });\r\n\r\n        export function run(\r\n            evalContext: IEvalContext,\r\n            objectDescriptor: DataViewObjectDescriptor,\r\n            propertyDefinitions: DataViewObjectPropertyDefinitions): DataViewObject {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\r\n            debug.assertValue(propertyDefinitions, 'propertyDefinitions');\r\n\r\n            if (!objectDescriptor)\r\n                return;\r\n\r\n            let object: DataViewObject,\r\n                propertyDescriptors = objectDescriptor.properties;\r\n            for (let propertyName in propertyDefinitions) {\r\n                let propertyDefinition = propertyDefinitions[propertyName],\r\n                    propertyDescriptor = propertyDescriptors[propertyName];\r\n\r\n                if (!propertyDescriptor)\r\n                    continue;\r\n\r\n                let propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\r\n                if (propertyValue === undefined)\r\n                    continue;\r\n\r\n                if (!object)\r\n                    object = {};\r\n                object[propertyName] = propertyValue;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        /** Note: Exported for testability */\r\n        export function evaluateProperty(\r\n            evalContext: IEvalContext,\r\n            propertyDescriptor: DataViewObjectPropertyDescriptor,\r\n            propertyDefinition: DataViewObjectPropertyDefinition): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(propertyDescriptor, 'propertyDescriptor');\r\n            debug.assertValue(propertyDefinition, 'propertyDefinition');\r\n\r\n            let structuralType = <StructuralTypeDescriptor>propertyDescriptor.type;\r\n            if (structuralType && structuralType.expression)\r\n                return propertyDefinition;\r\n\r\n            let value = evaluateValue(evalContext, <any>propertyDefinition, ValueType.fromDescriptor(propertyDescriptor.type));\r\n            if (value !== undefined || (propertyDefinition instanceof RuleEvaluation))\r\n                return value;\r\n\r\n            return evaluateFill(evalContext, <FillDefinition>propertyDefinition, structuralType)\r\n                || evaluateFillRule(evalContext, <FillRuleDefinition>propertyDefinition, structuralType)\r\n                || evaluateImage(evalContext, <ImageDefinition>propertyDefinition, structuralType)\r\n                || evaluateParagraphs(evalContext, <ParagraphsDefinition>propertyDefinition, structuralType)\r\n                || propertyDefinition;\r\n        }\r\n\r\n        function evaluateFill(evalContext: IEvalContext, fillDefn: FillDefinition, type: StructuralTypeDescriptor): Fill {\r\n            let fillType = type.fill;\r\n            if (!fillType)\r\n                return;\r\n\r\n            if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\r\n                return {\r\n                    solid: {\r\n                        color: evaluateValue(evalContext, fillDefn.solid.color, ValueType.fromExtendedType(ExtendedType.Color)),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateFillRule(evalContext: IEvalContext, fillRuleDefn: FillRuleDefinition, type: StructuralTypeDescriptor): FillRule {\r\n            if (!type.fillRule)\r\n                return;\r\n\r\n            if (fillRuleDefn.linearGradient2) {\r\n                let linearGradient2 = fillRuleDefn.linearGradient2;\r\n                return {\r\n                    linearGradient2: {\r\n                        min: evaluateColorStop(evalContext, linearGradient2.min),\r\n                        max: evaluateColorStop(evalContext, linearGradient2.max),\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (fillRuleDefn.linearGradient3) {\r\n                let linearGradient3 = fillRuleDefn.linearGradient3;\r\n                return {\r\n                    linearGradient3: {\r\n                        min: evaluateColorStop(evalContext, linearGradient3.min),\r\n                        mid: evaluateColorStop(evalContext, linearGradient3.mid),\r\n                        max: evaluateColorStop(evalContext, linearGradient3.max),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateColorStop(evalContext: IEvalContext, colorStop: RuleColorStopDefinition): RuleColorStop {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(colorStop, 'colorStop');\r\n\r\n            let step: RuleColorStop = {\r\n                color: evaluateValue(evalContext, colorStop.color, colorValueType),\r\n            };\r\n\r\n            let value = evaluateValue(evalContext, colorStop.value, numericType);\r\n            if (value != null)\r\n                step.value = value;\r\n\r\n            return step;\r\n        }\r\n\r\n        function evaluateImage(evalContext: IEvalContext, definition: ImageDefinition, type: StructuralTypeDescriptor): ImageValue {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.image || !definition)\r\n                return;\r\n\r\n            let value: ImageValue = {\r\n                name: evaluateValue(evalContext, definition.name, textType),\r\n                url: evaluateValue(evalContext, definition.url, ValueType.fromDescriptor(ImageDefinition.urlType)),\r\n            };\r\n\r\n            if (definition.scaling)\r\n                value.scaling = evaluateValue(evalContext, definition.scaling, textType);\r\n\r\n            return value;\r\n        }\r\n\r\n        function evaluateParagraphs(evalContext: IEvalContext, definition: ParagraphsDefinition, type: StructuralTypeDescriptor): Paragraphs {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.paragraphs || !definition)\r\n                return;\r\n\r\n            return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\r\n        }\r\n\r\n        function evaluateParagraph(evalContext: IEvalContext, definition: ParagraphDefinition): Paragraph {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: Paragraph;\r\n\r\n            let definitionTextRuns = definition.textRuns;\r\n            let evaluatedTextRuns: TextRun[] = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\r\n            if (definitionTextRuns !== evaluatedTextRuns) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.textRuns = evaluatedTextRuns;\r\n            }\r\n\r\n            return evaluated || <Paragraph>definition;\r\n        }\r\n\r\n        function evaluateTextRun(evalContext: IEvalContext, definition: TextRunDefinition): TextRun {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: TextRun;\r\n\r\n            let definitionValue = definition.value;\r\n            let evaluatedValue = evaluateValue(evalContext, <any> definitionValue, textType);\r\n            if (evaluatedValue !== undefined) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.value = evaluatedValue;\r\n            }\r\n\r\n            return evaluated || <TextRun>definition;\r\n        }\r\n\r\n        /**\r\n         * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\r\n         * other than the input to it.\r\n         */\r\n        function evaluateArrayCopyOnChange<TDefinition, TEvaluated>(\r\n            evalContext: IEvalContext,\r\n            definitions: TDefinition[],\r\n            evaluator: (ctx: IEvalContext, defn: TDefinition) => TEvaluated): TEvaluated[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definitions, 'definitions');\r\n            debug.assertValue(evaluator, 'evaluator');\r\n\r\n            let evaluatedValues: TEvaluated[];\r\n\r\n            for (let i = 0, len = definitions.length; i < len; i++) {\r\n                let definition = definitions[i];\r\n                let evaluated: TEvaluated = evaluator(evalContext, definition);\r\n\r\n                // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\r\n                // between TEvaluated & TDefinition\r\n                if (!evaluatedValues && <any>definition !== evaluated) {\r\n                    evaluatedValues = _.take(<TEvaluated[]><any>definitions, i);\r\n                }\r\n\r\n                if (evaluatedValues) {\r\n                    evaluatedValues.push(evaluated);\r\n                }\r\n            }\r\n\r\n            return evaluatedValues || <TEvaluated[]><any>definitions;\r\n        }\r\n\r\n        function evaluateValue(evalContext: IEvalContext, definition: SQExpr | RuleEvaluation, valueType: ValueType): any {\r\n            if (definition instanceof SQExpr)\r\n                return ExpressionEvaluator.evaluate(<SQExpr>definition, evalContext);\r\n\r\n            if (definition instanceof RuleEvaluation)\r\n                return (<RuleEvaluation>definition).evaluate(evalContext);\r\n        }\r\n\r\n        /** Responsible for evaluating SQExprs into values. */\r\n        class ExpressionEvaluator extends DefaultSQExprVisitorWithArg<PrimitiveValue, IEvalContext> {\r\n            private static instance: ExpressionEvaluator = new ExpressionEvaluator();\r\n\r\n            public static evaluate(expr: SQExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                if (expr == null)\r\n                    return;\r\n\r\n                return expr.accept(ExpressionEvaluator.instance, evalContext);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return expr.value;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitFillRule(expr: SQFillRuleExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                let inputValue = expr.input.accept(this, evalContext);\r\n                if (inputValue !== undefined) {\r\n                    let colorAllocator = evalContext.getColorAllocator(expr);\r\n                    if (colorAllocator) {\r\n                        return colorAllocator.color(inputValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n\r\n    export module DataViewPivotCategorical {\r\n        /**\r\n         * Pivots categories in a categorical DataView into valueGroupings.\r\n         * This is akin to a mathematical matrix transpose.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return null;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return null;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values) || values.source)\r\n                return null;\r\n\r\n            let category = categories[0],\r\n                categoryIdentities = category.identity,\r\n                categoryValues = category.values,\r\n                pivotedColumns: DataViewMetadataColumn[] = [],\r\n                pivotedValues: DataViewValueColumn[] = [];\r\n            for (let rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\r\n                let categoryValue = categoryValues[rowIdx],\r\n                    categoryIdentity = categoryIdentities[rowIdx];\r\n                for (let colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\r\n                    let value = values[colIdx],\r\n                        pivotedColumn = inherit(value.source);\r\n\r\n                    // A value has a series group, which is not implemented for pivoting -- just give up.\r\n                    if (value.identity)\r\n                        return null;\r\n\r\n                    pivotedColumn.groupName = categoryValue;\r\n                    let pivotedValue: DataViewValueColumn = {\r\n                        source: pivotedColumn,\r\n                        values: [value.values[rowIdx]],\r\n                        identity: categoryIdentity,\r\n                        min: value.min,\r\n                        max: value.max,\r\n                        subtotal: value.subtotal\r\n                    };\r\n\r\n                    let highlights = value.highlights;\r\n                    if (highlights) {\r\n                        pivotedValue.highlights = [highlights[rowIdx]];\r\n                    }\r\n\r\n                    pivotedColumns.push(pivotedColumn);\r\n                    pivotedValues.push(pivotedValue);\r\n                }\r\n            }\r\n\r\n            let pivotedMetadata = inherit(dataView.metadata);\r\n            pivotedMetadata.columns = pivotedColumns;\r\n\r\n            values = DataViewTransform.createValueColumns(pivotedValues, <SQExpr[]>category.identityFields, category.source);\r\n            return {\r\n                metadata: pivotedMetadata,\r\n                categorical: {\r\n                    values: values,\r\n                },\r\n                matrix: dataView.matrix\r\n            };\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewPivotMatrix {\r\n        /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\r\n        export function apply(dataViewMatrix: DataViewMatrix, context: MatrixTransformationContext): void {\r\n            debug.assertValue(dataViewMatrix, 'dataViewMatrix');\r\n\r\n            if (!context.columnHierarchyRewritten)\r\n                dataViewMatrix.columns = Prototype.inherit(dataViewMatrix.columns);\r\n            let columns = dataViewMatrix.columns;\r\n\r\n            if (!context.rowHierarchyRewritten)\r\n                dataViewMatrix.rows = Prototype.inherit(dataViewMatrix.rows);\r\n            let rows = dataViewMatrix.rows;\r\n\r\n            if (columns.levels.length > 1)\r\n                return;\r\n\r\n            let pivotedRowNode: DataViewMatrixNode = {\r\n                level: 0\r\n            };\r\n\r\n            let columnLeafNodes: DataViewMatrixNode[] = columns.root.children;\r\n            let measureCount = columnLeafNodes.length;\r\n\r\n            // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\r\n            // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\r\n            // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \r\n            // in a matrix with 2+ column fields and 2+ measure fields.\r\n            // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\r\n            // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\r\n            let pivotResultMeasureHeaderLevel = rows.levels.length;\r\n\r\n            if (measureCount > 0) {\r\n                let index = 0;\r\n                let callback = function (node: DataViewMatrixNode) {\r\n                    // Collect values and remove them from row leaves\r\n                    if (node.values) {\r\n                        if (!pivotedRowNode.values)\r\n                            pivotedRowNode.values = {};\r\n\r\n                        for (let i = 0; i < measureCount; i++)\r\n                            pivotedRowNode.values[index++] = node.values[i];\r\n\r\n                        delete node.values;\r\n                    }\r\n\r\n                    // Create measure headers if there are more than one measures\r\n                    if (measureCount > 1) {\r\n                        if (!node.children)\r\n                            node.children = [];\r\n\r\n                        for (let j = 0; j < measureCount; j++) {\r\n                            let measureHeaderLeaf: DataViewMatrixNode = { level: pivotResultMeasureHeaderLevel };\r\n\r\n                            // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\r\n                            let columnLeafNode = columnLeafNodes[j];\r\n                            measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\r\n\r\n                            if (node.isSubtotal)\r\n                                measureHeaderLeaf.isSubtotal = true;\r\n\r\n                            node.children.push(measureHeaderLeaf);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                if (context.hierarchyTreesRewritten) {\r\n                    forEachLeaf(rows.root, callback);\r\n                }\r\n                else {\r\n                    dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\r\n                }\r\n            }\r\n            else {\r\n                if (!context.hierarchyTreesRewritten) {\r\n                    dataViewMatrix.columns.root = cloneTree(rows.root);\r\n                }\r\n            }\r\n\r\n            if (measureCount > 1) {\r\n                // Keep measure headers, but move them to the innermost level\r\n                let level: DataViewHierarchyLevel = { sources: columns.levels[0].sources };\r\n                rows.levels.push(level);\r\n\r\n                columns.levels.length = 0;\r\n            }\r\n\r\n            if (context.hierarchyTreesRewritten) {\r\n                dataViewMatrix.columns.root = rows.root;\r\n                dataViewMatrix.rows.root = {\r\n                    children: [pivotedRowNode]\r\n                };\r\n            }\r\n            else {\r\n                let updatedRowRoot = Prototype.inherit(dataViewMatrix.rows.root);\r\n                updatedRowRoot.children = [pivotedRowNode];\r\n                dataViewMatrix.rows.root = updatedRowRoot;\r\n            }\r\n\r\n            dataViewMatrix.columns.levels = rows.levels;\r\n            dataViewMatrix.rows.levels = [];\r\n        }\r\n\r\n        function forEachLeaf(root: DataViewMatrixNode, callback: (node: DataViewMatrixNode) => void): void {\r\n            let children = root.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachLeaf(children[i], callback);\r\n\r\n                return;\r\n            }\r\n\r\n            callback(root);\r\n        }\r\n\r\n        export function cloneTree(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            return cloneTreeExecuteOnLeaf(node);\r\n        }\r\n\r\n        export function cloneTreeExecuteOnLeaf(node: DataViewMatrixNode, callback?: (node: DataViewMatrixNode) => void): DataViewMatrixNode {\r\n            let updatedNode = Prototype.inherit(node);\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                let newChildren: DataViewTreeNode[] = [];\r\n\r\n                for (let i = 0, ilen = children.length; i < ilen; i++) {\r\n                    let updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\r\n                    newChildren.push(updatedChild);\r\n                }\r\n                updatedNode.children = newChildren;\r\n            }\r\n            else {\r\n                if (callback)\r\n                    callback(updatedNode);\r\n            }\r\n\r\n            return updatedNode;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewSelfCrossJoin {\r\n        /**\r\n         * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\r\n         * to itself as a value grouping.\r\n         * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            if (!dataView.categorical)\r\n                return;\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\r\n                return;\r\n            if (dataViewCategorical.values && dataViewCategorical.values.source)\r\n                return;\r\n\r\n            return applyCategorical(dataView.metadata, dataViewCategorical);\r\n        }\r\n\r\n        function applyCategorical(dataViewMetadata: DataViewMetadata, dataViewCategorical: DataViewCategorical): DataView {\r\n            debug.assertValue(dataViewMetadata, 'dataViewMetadata');\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\r\n\r\n            let category = dataViewCategorical.categories[0],\r\n                categoryValues = category.values,\r\n                categoryLength = categoryValues.length;\r\n\r\n            if (categoryLength === 0)\r\n                return;\r\n\r\n            let valuesArray: DataViewValueColumn[] = dataViewCategorical.values\r\n                ? dataViewCategorical.values.grouped()[0].values\r\n                : [];\r\n            let transformedDataView = createCategoricalDataViewBuilder()\r\n                .withCategories(dataViewCategorical.categories)\r\n                .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\r\n                .build();\r\n\r\n            dataViewMetadata = Prototype.inherit(dataViewMetadata);\r\n            dataViewMetadata.columns = transformedDataView.metadata.columns;\r\n\r\n            return {\r\n                metadata: dataViewMetadata,\r\n                categorical: transformedDataView.categorical,\r\n            };\r\n        }\r\n\r\n        function createGroupedValues(\r\n            category: DataViewCategoryColumn,\r\n            categoryValues: any[],\r\n            categoryLength: number,\r\n            valuesArray: DataViewValueColumn[]): DataViewBuilderGroupedValuesOptions {\r\n            debug.assertValue(category, 'category');\r\n            debug.assertValue(categoryValues, 'categoryValues');\r\n            debug.assertValue(categoryLength, 'categoryLength');\r\n            debug.assertValue(valuesArray, 'valuesArray');\r\n\r\n            let nullValuesArray: any[] = createNullValues(categoryLength),\r\n                valuesArrayLen = valuesArray.length,\r\n                seriesData: DataViewBuilderSeriesData[][] = [];\r\n\r\n            for (let i = 0; i < categoryLength; i++) {\r\n                let seriesDataItem: DataViewBuilderSeriesData[] = [];\r\n\r\n                for (let j = 0; j < valuesArrayLen; j++) {\r\n                    let originalValueColumn = valuesArray[j],\r\n                        originalHighlightValues = originalValueColumn.highlights;\r\n\r\n                    let seriesDataItemCategory: DataViewBuilderSeriesData = {\r\n                        values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\r\n                    };\r\n                    if (originalHighlightValues)\r\n                        seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\r\n\r\n                    seriesDataItem.push(seriesDataItemCategory);\r\n                }\r\n\r\n                seriesData.push(seriesDataItem);\r\n            }\r\n\r\n            return {\r\n                groupColumn: {\r\n                    source: category.source,\r\n                    identityFrom: { fields: <SQExpr[]>category.identityFields, identities: category.identity },\r\n                    values: category.values,\r\n                },\r\n                valueColumns: _.map(valuesArray, v => <DataViewBuilderColumnOptions>{ source: v.source }),\r\n                data: seriesData,\r\n            };\r\n        }\r\n    }\r\n\r\n    function createNullValues(length: number): any[] {\r\n        debug.assertValue(length, 'length');\r\n\r\n        let array = new Array(length);\r\n        for (let i = 0; i < length; i++)\r\n            array[i] = null;\r\n        return array;\r\n    }\r\n\r\n    function inheritArrayWithValue(nullValues: any[], original: any[], index: number): any[] {\r\n        let inherited = Prototype.inherit(nullValues);\r\n        inherited[index] = original[index];\r\n\r\n        return inherited;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\r\n    import inheritSingle = powerbi.Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export module DataViewPivotCategoricalToPrimaryGroups {\r\n\r\n        /**\r\n         * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\r\n         * pivot the secondary before the primary.\r\n         */\r\n        export function pivotBinding(binding: DataShapeBinding, allMappings: CompiledDataViewMapping[], finalMapping: CompiledDataViewMapping, defaultDataVolume: number): void {\r\n            // unpivot is inferred from result in DataViewTransform.apply but it does not have the\r\n            // compiled mappings available, let alone the merged mapping, only the original\r\n            // DataViewMappings. to keep that inference easy, only apply pivot when there's\r\n            // only one matching mapping\r\n            if (!allMappings || allMappings.length !== 1)\r\n                return;\r\n\r\n            if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\r\n                return;\r\n\r\n            if (!binding)\r\n                return;\r\n\r\n            if (!canPivotCategorical(binding, finalMapping))\r\n                return;\r\n\r\n            // pivot secondary onto front of primary\r\n            binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\r\n\r\n            binding.Secondary = undefined;\r\n        \r\n            // set primary to pivot reduction\r\n            binding.DataReduction = {\r\n                Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\r\n                DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\r\n            };\r\n        }\r\n\r\n        /** narrowly targets scatter chart scenario for now to keep code simple */\r\n        function isPivotableAxis(axis: powerbi.data.DataShapeBindingAxis): boolean {\r\n            return axis\r\n                && axis.Groupings\r\n                && axis.Groupings.length === 1\r\n                && !_.isEmpty(axis.Groupings[0].Projections)\r\n                && !axis.Groupings[0].Subtotal\r\n                && _.isEmpty(axis.Groupings[0].SuppressedProjections);\r\n        }\r\n\r\n        function canPivotCategorical(binding: DataShapeBinding, mapping: CompiledDataViewMapping): boolean {\r\n            if (!isPivotableAxis(binding.Primary))\r\n                return false;\r\n            if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\r\n                return false;\r\n\r\n            // don't pivot if either axis has a data reduction\r\n            if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        export function unpivotResult(oldDataView: DataView, selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\r\n                return oldDataView;\r\n\r\n            // This returns a subsetted version of the DataView rather than using prototypal inheritance because\r\n            // any dataviews in the old one (including ones invented after this code is written) will correspond\r\n            // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\r\n            // querying code made.\r\n            let newDataView: DataView = {\r\n                metadata: {\r\n                    columns: ArrayExtensions.copy(oldDataView.metadata.columns),\r\n                },\r\n            };\r\n            \r\n            // preserve view types that aren't affected by pivoting\r\n            if (oldDataView.single)\r\n                newDataView.single = oldDataView.single;\r\n            if (oldDataView.table)\r\n                newDataView.table = oldDataView.table;\r\n\r\n            // other views are derived from matrix\r\n            if (oldDataView.matrix) {\r\n                let newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\r\n\r\n                // categorical only if there's data\r\n                if (!_.isEmpty(newDataViewMatrix.valueSources)) {\r\n                    // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \r\n                    // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\r\n                    // this.canPivotCategorical() would have returned false in the first place for this query.\r\n                    let hasCompositeGroupInSeries = utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\r\n                    if (!hasCompositeGroupInSeries) {\r\n                        newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return newDataView;\r\n        }\r\n\r\n        /**\r\n         * Infer from the query result and the visual mappings whether the query was pivoted.\r\n         * Narrowly targets scatter chart scenario for now to keep code simple\r\n         */\r\n        function inferUnpivotTransform(selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], dataView: DataView, projectionActiveItems: DataViewProjectionActiveItems): boolean {\r\n            if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\r\n                return false;\r\n\r\n            // select applicable mappings based on select roles\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\r\n            let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let supportedDataViewMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\r\n            if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\r\n                return false;\r\n\r\n            let categoricalMapping = supportedDataViewMappings[0].categorical;\r\n            if (!categoricalMapping)\r\n                return false;\r\n\r\n            // pivoted query will have produced a matrix\r\n            let matrixDataview = dataView.matrix;\r\n            if (!matrixDataview)\r\n                return false;\r\n\r\n            // matrix must have two levels of grouping\r\n            if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\r\n                return false;\r\n            \r\n            // get category and value grouping roles\r\n            let categoryGroups: string[] = [];\r\n            let valueGroups: string[] = [];\r\n\r\n            let addGroupingRole = (roleName: string, groups: string[]) => {\r\n                let roleProjections: QueryProjectionCollection = projections[roleName];\r\n                if (!roleProjections)\r\n                    return;\r\n\r\n                for (let roleProjection of roleProjections.all()) {\r\n                    if (roleKinds[roleProjection.queryRef] === VisualDataRoleKind.Grouping)\r\n                        groups.push(roleProjection.queryRef);\r\n                }\r\n            };\r\n\r\n            DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, categoryGroups); }\r\n            });\r\n\r\n            DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, valueGroups); }\r\n            });\r\n\r\n            // need both for pivot to have been done\r\n            if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\r\n                return false;\r\n\r\n            // if there was a pivot, there won't be any measures left in the columns\r\n            for (let level of matrixDataview.columns.levels) {\r\n                for (let source of level.sources) {\r\n                    if (!source.isMeasure)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        interface DataViewMatrixNodeValues {\r\n            [id: number]: DataViewMatrixNodeValue;\r\n        }\r\n\r\n        /**\r\n         * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\r\n         * this function changes that so that the categories become the rows and the series the columns.\r\n         */\r\n        function unpivotMatrix(oldMatrix: DataViewMatrix): DataViewMatrix {\r\n            let oldRows = oldMatrix.rows;\r\n            let oldRoot = oldRows.root;\r\n            let oldChildren = <DataViewMatrixNode[]>oldRoot.children;\r\n\r\n            // series are the outer grouping\r\n            let series: DataViewMatrixNode[] = [];\r\n            let seriesIdLevel = oldRows.levels[0];\r\n            let seriesIdFields = oldRoot.childIdentityFields;\r\n\r\n            // categories are the inner grouping. \r\n            let categoryIndex: _.Dictionary<number> = {};\r\n            let categories: DataViewMatrixNode[] = [];\r\n            let categoryIdLevel = oldRows.levels[1];\r\n            let categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\r\n\r\n            let measureCount = oldMatrix.valueSources.length;\r\n\r\n            // within each series value, the category list may not be complete so cannot simply use the inner loop index\r\n            // to reference it.\r\n            let findCategory = (identity: DataViewScopeIdentity) => {\r\n                let index = categoryIndex[identity.key];\r\n\r\n                debug.assert(index !== undefined, \"findcat() !== undefined\");\r\n\r\n                return index;\r\n            };\r\n\r\n            // collect series and categories from the row hierarchy\r\n            if (oldChildren) {\r\n                let addCategory = (categoryNode: DataViewMatrixNode) => {\r\n                    let key = categoryNode.identity.key;\r\n                    let index = categoryIndex[key];\r\n                    if (index === undefined) {\r\n                        index = categories.length;\r\n                        categoryIndex[key] = index;\r\n                        categories.push(categoryNode);\r\n                    }\r\n                };\r\n\r\n                for (let seriesNode of oldChildren) {\r\n                    series.push(seriesNode);\r\n\r\n                    for (let categoryNode of <DataViewMatrixNode[]>seriesNode.children) {\r\n                        addCategory(categoryNode);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // extract intersection values from pivoted matrix\r\n            // values will be indexed by categories then series\r\n            let matrixValues: DataViewMatrixNodeValues[][] = new Array<DataViewMatrixNodeValues[]>(categories.length);\r\n            for (let j = 0; j < series.length; ++j) { // outer is series\r\n                let seriesNode = oldChildren[j];\r\n                for (let categoryNode of seriesNode.children) { // inner is categories but maybe a subset\r\n                    let i = findCategory(categoryNode.identity); // must lookup actual category index\r\n\r\n                    if (!matrixValues[i])\r\n                        matrixValues[i] = new Array<DataViewMatrixNodeValues>(series.length);\r\n\r\n                    matrixValues[i][j] = categoryNode.values;\r\n                }\r\n            }\r\n\r\n            // columns of the unpivoted matrix are the series\r\n            let newColumns: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(series, s => {\r\n                        let inheritedNode = inheritSingle(s);\r\n                        inheritedNode.level = 0; // s.level should already be 0, but just in case...\r\n                        inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\r\n                        inheritedNode.childIdentityFields = undefined;\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: seriesIdFields,\r\n                },\r\n                levels: [\r\n                    seriesIdLevel,\r\n                    \r\n                ],\r\n            };\r\n\r\n            // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\r\n            if (measureCount > 0) {\r\n                let newColChildren: DataViewMatrixNode[] = _.map(oldMatrix.columns.root.children, (srcnode: DataViewMatrixNode) => {\r\n                    let dstnode: DataViewMatrixNode = { level: 1 };\r\n                    if (srcnode.levelSourceIndex)\r\n                        dstnode.levelSourceIndex = srcnode.levelSourceIndex;\r\n                    return dstnode;\r\n                });\r\n\r\n                for (let i = 0; i < newColumns.root.children.length; ++i)\r\n                    newColumns.root.children[i].children = newColChildren;\r\n\r\n                newColumns.levels.push(oldMatrix.columns.levels[0]);\r\n            }\r\n\r\n            // rows of the unpivoted matrix are the categories\r\n            let newRows: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(categories, c => {\r\n                        let inheritedNode = inheritSingle(c);\r\n                        inheritedNode.level = 0;\r\n                        inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\r\n                        inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: categoryIdFields,\r\n                },\r\n                levels: [\r\n                    categoryIdLevel,\r\n                ],\r\n            };\r\n\r\n            // put values into rows\r\n            if (measureCount > 0) {\r\n                for (let i = 0; i < categories.length; ++i) {\r\n                    let row = newRows.root.children[i];\r\n                    let rowValues: DataViewMatrixNodeValues = {};\r\n\r\n                    for (let j = 0; j < series.length; ++j) {\r\n                        let mvalues = matrixValues[i] && matrixValues[i][j];\r\n                        for (let k = 0; k < measureCount; ++k) {\r\n                            let l = j * measureCount + k;\r\n                            rowValues[l] = !mvalues\r\n                                ? ( k === 0 ? { value: null } : { value: null, valueSourceIndex: k } )\r\n                                : mvalues[k];\r\n                        }\r\n                    }\r\n\r\n                    row.values = rowValues;\r\n                }\r\n            }\r\n\r\n            let newMatrix: DataViewMatrix = {\r\n                rows: newRows,\r\n                columns: newColumns,\r\n                valueSources: oldMatrix.valueSources,\r\n            };\r\n\r\n            return newMatrix;\r\n        }\r\n\r\n        /** build a categorical data view from an unpivoted matrix. */\r\n        function categoricalFromUnpivotedMatrix(matrix: DataViewMatrix, columnMetadata: DataViewMetadataColumn[]): DataViewCategorical {\r\n            let seriesCount = matrix.columns.root.children.length;\r\n            let measureMetadata = matrix.valueSources;\r\n            let measureCount = measureMetadata.length;\r\n\r\n            let categories: DataViewCategoryColumn[] = createCategoryColumnsFromUnpivotedMatrix(matrix);\r\n\r\n            // create grouped values\r\n            let groups: DataViewValueColumnGroup[] = [];\r\n            for (let j = 0; j < seriesCount; ++j) {\r\n                let seriesColumn = matrix.columns.root.children[j];\r\n                let group: DataViewValueColumnGroup = {\r\n                    values: [],\r\n                    identity: seriesColumn.identity,\r\n                    name: seriesColumn.value || null,\r\n                };\r\n\r\n                groups.push(group);\r\n\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    let valueColumnMetadataSrc = measureMetadata[k];\r\n                    let valueColumnMetadataDst: DataViewMetadataColumn = <DataViewMetadataColumn>{};\r\n                    for (let key in valueColumnMetadataSrc)\r\n                        valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\r\n                    valueColumnMetadataDst.groupName = group.name;\r\n\r\n                    columnMetadata.push(valueColumnMetadataDst);\r\n\r\n                    let valueColumn: DataViewValueColumn = {\r\n                        source: valueColumnMetadataDst,\r\n                        values: [],\r\n                        identity: group.identity,\r\n                    };\r\n\r\n                    group.values.push(valueColumn);\r\n\r\n                    // grab measure values in the group from across rows of matrix\r\n                    let index = k + j * measureCount;\r\n\r\n                    for (let categoryNode of matrix.rows.root.children) {\r\n                        let value = categoryNode.values[index].value;\r\n\r\n                        valueColumn.values.push(value);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // and now ungrouped\r\n            let values: DataViewValueColumns = <DataViewValueColumns>[];\r\n            for (let group of groups) {\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    values.push(group.values[k]);\r\n                }\r\n            }\r\n\r\n            values.grouped = () => groups;\r\n            values.identityFields = matrix.columns.root.childIdentityFields;\r\n            values.source = matrix.columns.levels[0].sources[0];\r\n\r\n            // final assembly\r\n            let categorical: DataViewCategorical = {\r\n                categories: categories,\r\n                values: values,\r\n            };\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix: DataViewMatrix): DataViewCategoryColumn[] {\r\n            debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\r\n            debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1),\r\n                'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\r\n\r\n            // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \r\n            // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \r\n            // same amongst the resulting DataViewCategoryColumns.\r\n            let categoryIdentity = _.map(unpivotedMatrix.rows.root.children, x => x.identity);\r\n            let categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\r\n            let categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\r\n\r\n            let categories: DataViewCategoryColumn[] = [];\r\n            for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\r\n                let groupLevelValues = _.map(unpivotedMatrix.rows.root.children, (categoryNode: DataViewMatrixNode) => {\r\n                    let levelValues: DataViewMatrixGroupValue[] = categoryNode.levelValues;\r\n\r\n                    // Please refer to the interface comments on when this is undefined... But in today's code\r\n                    // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \r\n                    if (levelValues !== undefined) {\r\n                        debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i),\r\n                            'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\r\n                        return levelValues[i].value;\r\n                    }\r\n                });\r\n\r\n                categories.push({\r\n                    source: categorySourceColumns[i],\r\n                    values: groupLevelValues,\r\n                    identity: categoryIdentity,\r\n                    identityFields: categoryIdentityFields,\r\n                });\r\n            }\r\n\r\n            return categories;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n    import INumberDictionary = jsCommon.INumberDictionary;\r\n\r\n    export interface DataViewTransformApplyOptions {\r\n        prototype: DataView;\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        dataViewMappings?: DataViewMapping[];\r\n        transforms: DataViewTransformActions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /** Describes the Transform actions to be done to a prototype DataView. */\r\n    export interface DataViewTransformActions {\r\n        /** Describes transform metadata for each semantic query select item, as the arrays align, by index. */\r\n        selects?: DataViewSelectTransform[];\r\n\r\n        /** Describes the DataViewObject definitions. */\r\n        objects?: DataViewObjectDefinitions;\r\n\r\n        /** Describes the splitting of a single input DataView into multiple DataViews. */\r\n        splits?: DataViewSplitTransform[];\r\n\r\n        /** Describes the projection metadata which includes projection ordering and active items. */\r\n        roles?: DataViewRoleTransformMetadata;\r\n    }\r\n\r\n    export interface DataViewSplitTransform {\r\n        selects: INumberDictionary<boolean>;\r\n    }\r\n\r\n    export interface DataViewProjectionOrdering {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItemInfo {\r\n        queryRef: string;\r\n\r\n        /** Describes if the active item should be ignored in concatenation.\r\n            If the active item has a drill filter, it will not be used in concatenation.\r\n            If the value of suppressConcat is true, the activeItem will be ommitted from concatenation. */\r\n        suppressConcat?: boolean;\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItems {\r\n        [roleName: string]: DataViewProjectionActiveItemInfo[];\r\n    }\r\n\r\n    export interface DataViewRoleTransformMetadata {\r\n        /** Describes the order of selects (referenced by query index) in each role. */\r\n        ordering?: DataViewProjectionOrdering;\r\n\r\n        /** Describes the active items in each role. */\r\n        activeItems?: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export interface MatrixTransformationContext {\r\n        rowHierarchyRewritten: boolean;\r\n        columnHierarchyRewritten: boolean;\r\n        hierarchyTreesRewritten: boolean;\r\n    }\r\n\r\n    interface ValueRewrite<T> {\r\n        from: T;\r\n        to: T;\r\n    }\r\n\r\n    interface NumberToNumberMapping {\r\n        [position: number]: number;\r\n    }\r\n\r\n    const enum CategoricalDataViewTransformation {\r\n        None,\r\n        Pivot,\r\n        SelfCrossJoin,\r\n    }\r\n\r\n    export const enum StandardDataViewKinds {\r\n        None = 0,\r\n        Categorical = 1,\r\n        Matrix = 1 << 1,\r\n        Single = 1 << 2,\r\n        Table = 1 << 3,\r\n        Tree = 1 << 4,\r\n    }\r\n\r\n    // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\r\n    export module DataViewTransform {\r\n        const fillRulePropertyDescriptor: DataViewObjectPropertyDescriptor = { type: { fillRule: {} } };\r\n\r\n        const enum ColumnIdentifierKind {\r\n            QueryName,\r\n            Role,\r\n        }\r\n\r\n        export function apply(options: DataViewTransformApplyOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\r\n\r\n            let prototype = options.prototype,\r\n                objectDescriptors = options.objectDescriptors,\r\n                dataViewMappings = options.dataViewMappings,\r\n                transforms = options.transforms,\r\n                projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems,\r\n                colorAllocatorFactory = options.colorAllocatorFactory,\r\n                dataRoles = options.dataRoles;\r\n\r\n            if (!prototype)\r\n                return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\r\n\r\n            if (!transforms)\r\n                return [prototype];\r\n\r\n            // Transform Query DataView\r\n            prototype = DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\r\n            let visualDataViews: DataView[] = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\r\n\r\n            // Transform and generate derived visual DataViews\r\n            visualDataViews = DataViewRegression.run({\r\n                dataViewMappings: dataViewMappings,\r\n                visualDataViews: visualDataViews,\r\n                dataRoles: dataRoles,\r\n                objectDescriptors: objectDescriptors,\r\n                objectDefinitions: transforms.objects,\r\n                colorAllocatorFactory: colorAllocatorFactory,\r\n                transformSelects: transforms.selects,\r\n                metadata: prototype.metadata,\r\n                projectionActiveItems: projectionActiveItems,\r\n            });\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        function transformQueryToVisualDataView(\r\n            prototype: DataView,\r\n            transforms: DataViewTransformActions,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            dataViewMappings: DataViewMapping[],\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[]): DataView[] {\r\n            let transformedDataViews: DataView[] = [];\r\n            let splits = transforms.splits;\r\n            if (_.isEmpty(splits)) {\r\n                transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\r\n            } else {\r\n                for (let split of splits) {\r\n                    let transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\r\n                    transformedDataViews.push(transformed);\r\n                }\r\n            }\r\n            return transformedDataViews;\r\n        }\r\n\r\n        function transformEmptyDataView(objectDescriptors: DataViewObjectDescriptors, transforms: DataViewTransformActions, colorAllocatorFactory: IColorAllocatorFactory): DataView[] {\r\n            if (transforms && transforms.objects) {\r\n                let emptyDataView: DataView = {\r\n                    metadata: {\r\n                        columns: [],\r\n                    }\r\n                };\r\n\r\n                transformObjects(\r\n                    emptyDataView,\r\n                    StandardDataViewKinds.None,\r\n                    objectDescriptors,\r\n                    transforms.objects,\r\n                    transforms.selects,\r\n                    colorAllocatorFactory);\r\n\r\n                return [emptyDataView];\r\n            }\r\n\r\n            return [];\r\n        }\r\n\r\n        function transformDataView(\r\n            prototype: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            transforms: DataViewTransformActions,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[],\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n            debug.assertValue(prototype, 'prototype');\r\n\r\n            let targetKinds = getTargetKinds(roleMappings);\r\n            let transformed = inherit(prototype);\r\n            transformed.metadata = inherit(prototype.metadata);\r\n\r\n            let projectionOrdering = transforms.roles && transforms.roles.ordering;\r\n            let projectionActiveItems = transforms.roles && transforms.roles.activeItems;\r\n            transformed = transformSelects(transformed, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\r\n            transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\r\n\r\n            // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\r\n            transformed = DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\r\n\r\n            DataViewNormalizeValues.apply({\r\n                dataview: transformed,\r\n                dataViewMappings: roleMappings,\r\n                dataRoles: dataRoles,\r\n            });\r\n\r\n            return transformed;\r\n        }\r\n\r\n        function getTargetKinds(roleMappings: DataViewMapping[]): StandardDataViewKinds {\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n\r\n            if (!roleMappings)\r\n                return StandardDataViewKinds.None;\r\n\r\n            let result = StandardDataViewKinds.None;\r\n            for (let roleMapping of roleMappings) {\r\n                if (roleMapping.categorical)\r\n                    result |= StandardDataViewKinds.Categorical;\r\n                if (roleMapping.matrix)\r\n                    result |= StandardDataViewKinds.Matrix;\r\n                if (roleMapping.single)\r\n                    result |= StandardDataViewKinds.Single;\r\n                if (roleMapping.table)\r\n                    result |= StandardDataViewKinds.Table;\r\n                if (roleMapping.tree)\r\n                    result |= StandardDataViewKinds.Tree;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function transformSelects(\r\n            dataView: DataView,\r\n            roleMappings: DataViewMapping[],\r\n            selectTransforms: DataViewSelectTransform[],\r\n            projectionOrdering?: DataViewProjectionOrdering,\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n\r\n            let columnRewrites: ValueRewrite<DataViewMetadataColumn>[] = [];\r\n            if (selectTransforms) {\r\n                dataView.metadata.columns = applyTransformsToColumns(\r\n                    dataView.metadata.columns,\r\n                    selectTransforms,\r\n                    columnRewrites);\r\n            }\r\n\r\n            // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\r\n            if (dataView.categorical) {\r\n                dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                // NOTE: This is slightly DSR-specific.\r\n                dataView = pivotIfNecessary(dataView, roleMappings);\r\n            }\r\n\r\n            if (dataView.matrix) {\r\n                let matrixTransformationContext: MatrixTransformationContext = {\r\n                    rowHierarchyRewritten: false,\r\n                    columnHierarchyRewritten: false,\r\n                    hierarchyTreesRewritten: false\r\n                };\r\n                dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                if (shouldPivotMatrix(dataView.matrix, roleMappings))\r\n                    DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\r\n            }\r\n\r\n            if (dataView.table)\r\n                dataView.table = applyRewritesToTable(dataView.table, columnRewrites, roleMappings, projectionOrdering);\r\n\r\n            return dataView;\r\n        }\r\n\r\n        function applyTransformsToColumns(\r\n            prototypeColumns: DataViewMetadataColumn[],\r\n            selects: DataViewSelectTransform[],\r\n            rewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn[] {\r\n            debug.assertValue(prototypeColumns, 'columns');\r\n\r\n            if (!selects)\r\n                return prototypeColumns;\r\n\r\n            //column may contain undefined entries\r\n            let columns = inherit(prototypeColumns);\r\n\r\n            for (let i = 0, len = prototypeColumns.length; i < len; i++) {\r\n                let prototypeColumn = prototypeColumns[i];\r\n                let select = selects[prototypeColumn.index];\r\n                if (!select)\r\n                    continue;\r\n\r\n                let column: DataViewMetadataColumn = columns[i] = inherit(prototypeColumn);\r\n\r\n                if (select.roles)\r\n                    column.roles = select.roles;\r\n                if (select.type)\r\n                    column.type = select.type;\r\n                column.format = getFormatForColumn(select, column);\r\n\r\n                if (select.displayName)\r\n                    column.displayName = select.displayName;\r\n                if (select.queryName)\r\n                    column.queryName = select.queryName;\r\n                if (select.kpi)\r\n                    column.kpi = select.kpi;\r\n                if (select.sort)\r\n                    column.sort = select.sort;\r\n                if (select.discourageAggregationAcrossGroups)\r\n                    column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\r\n\r\n                rewrites.push({\r\n                    from: prototypeColumn,\r\n                    to: column,\r\n                });\r\n            }\r\n\r\n            return columns;\r\n        }\r\n\r\n        /**\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Select format\r\n         *  2. Column format\r\n         */\r\n        function getFormatForColumn(select: DataViewSelectTransform, column: DataViewMetadataColumn): string {\r\n            // TODO: we already copied the select.Format to column.format, we probably don't need this check\r\n            return select.format || column.format;\r\n        }\r\n\r\n        function applyRewritesToCategorical(prototype: DataViewCategorical, columnRewrites: ValueRewrite<DataViewMetadataColumn>[], selectsToInclude?: INumberDictionary<boolean>): DataViewCategorical {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            let categorical = inherit(prototype);\r\n\r\n            function override(value: { source?: DataViewMetadataColumn }) {\r\n                let rewrittenSource = findOverride(value.source, columnRewrites);\r\n                if (rewrittenSource) {\r\n                    let rewritten = inherit(value);\r\n                    rewritten.source = rewrittenSource;\r\n                    return rewritten;\r\n                }\r\n            }\r\n\r\n            let categories = Prototype.overrideArray(prototype.categories, override);\r\n            if (categories)\r\n                categorical.categories = categories;\r\n\r\n            let valuesOverride = Prototype.overrideArray(prototype.values, override);\r\n            let values = valuesOverride || prototype.values;\r\n\r\n            if (values) {\r\n                let grouped = inherit(values.grouped());\r\n                for (let i = 0, ilen = grouped.length; i < ilen; i++) {\r\n                    grouped[i] = inherit(grouped[i]);\r\n                }\r\n                if (selectsToInclude) {\r\n                    // Apply selectsToInclude to values by removing value columns not included\r\n                    for (let i = values.length - 1; i >= 0; i--) {\r\n                        if (!selectsToInclude[values[i].source.index]) {\r\n                            values.splice(i, 1);\r\n                        }\r\n                    }\r\n\r\n                    // Apply selectsToInclude to grouped()\r\n                    if (values.length > 0 && values[0].identity) {\r\n                        // We have a dynamic series, so we should remove any value columns not included in the split from each\r\n                        //    valueColumnGroup\r\n                        for (let i = 0, ilen = grouped.length ; i < ilen; i++) {\r\n                            let currentGroupValues = grouped[i].values;\r\n                            for (let j = currentGroupValues.length - 1; j >= 0; j--) {\r\n                                if (!selectsToInclude[currentGroupValues[j].source.index])\r\n                                    currentGroupValues.splice(i, 1);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // We are in a static series, so we should throw away the grouped and recreate it using the static values\r\n                        //   which have already been filtered\r\n                        grouped = [];\r\n                        grouped[0] = {\r\n                            values: values,\r\n                        };\r\n                    }\r\n                }\r\n\r\n                if (values.source) {\r\n                    if (selectsToInclude && !selectsToInclude[values.source.index]) {\r\n                        values.source = undefined;\r\n                    }\r\n                    else {\r\n                        let rewrittenValuesSource = findOverride(values.source, columnRewrites);\r\n                        if (rewrittenValuesSource)\r\n                            values.source = rewrittenValuesSource;\r\n                    }\r\n                }\r\n\r\n                let currentGroupIndex = 0;\r\n                let group: DataViewValueColumnGroup;\r\n                for (let i = 0, ilen = values.length; i < ilen; i++) {\r\n                    let currentValue = values[i];\r\n                    if (!group || (currentValue.identity !== group.identity)) {\r\n                        group = inherit(grouped[currentGroupIndex]);\r\n                        grouped[currentGroupIndex] = group;\r\n                        group.values = [];\r\n                        currentGroupIndex++;\r\n                    }\r\n                    group.values.push(currentValue);\r\n                }\r\n\r\n                categorical.values = values;\r\n                setGrouped(values, grouped);\r\n            }\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function applyRewritesToTable(\r\n            prototype: DataViewTable,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering): DataViewTable {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a table.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (!roleMappings || roleMappings.length !== 1 || !roleMappings[0].table)\r\n                return prototype;\r\n\r\n            let table = inherit(prototype);\r\n\r\n            // Copy the rewritten columns into the table view\r\n            let override = (metadata: DataViewMetadataColumn) => findOverride(metadata, columnRewrites);\r\n            let columns = Prototype.overrideArray(prototype.columns, override);\r\n            if (columns)\r\n                table.columns = columns;\r\n\r\n            if (!projectionOrdering)\r\n                return table;\r\n\r\n            let newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\r\n            if (!newToOldPositions)\r\n                return table;\r\n\r\n            // Reorder the columns\r\n            let columnsClone = columns.slice(0);\r\n            let keys = Object.keys(newToOldPositions);\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let sourceColumn = columnsClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === columns.length)\r\n                    columns.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < columns.length, 'The column index is out of range for reordering.');\r\n                    columns[i] = sourceColumn;\r\n                }\r\n            }\r\n\r\n            // Reorder the rows\r\n            let rows = Prototype.overrideArray(table.rows,\r\n                (row: any[]) => {\r\n                    let newRow: any[] = [];\r\n                    for (let i = 0, len = keys.length; i < len; ++i)\r\n                        newRow[i] = row[newToOldPositions[keys[i]]];\r\n\r\n                    return newRow;\r\n                });\r\n\r\n            if (rows)\r\n                table.rows = rows;\r\n\r\n            return table;\r\n        }\r\n\r\n        /** Creates a mapping of new position to original position. */\r\n        function createTableColumnPositionMapping(\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n            let roles = Object.keys(projectionOrdering);\r\n\r\n            // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\r\n            if (roles.length !== 1)\r\n                return;\r\n\r\n            let role = roles[0],\r\n                originalOrder = _.map(columnRewrites, (rewrite: ValueRewrite<DataViewMetadataColumn>) => rewrite.from.index),\r\n                newOrder = projectionOrdering[role];\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        function applyRewritesToMatrix(\r\n            prototype: DataViewMatrix,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            context: MatrixTransformationContext): DataViewMatrix {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a matrix.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (!roleMappings || roleMappings.length < 1 || !(roleMappings[0].matrix || (roleMappings[1] && roleMappings[1].matrix)))\r\n                return prototype;\r\n\r\n            let matrixMapping = roleMappings[0].matrix || roleMappings[1].matrix;\r\n            let matrix = inherit(prototype);\r\n\r\n            function override(metadata: DataViewMetadataColumn) {\r\n                return findOverride(metadata, columnRewrites);\r\n            }\r\n\r\n            function overrideHierarchy(hierarchy: DataViewHierarchy): DataViewHierarchy {\r\n                let rewrittenHierarchy: DataViewHierarchy = null;\r\n\r\n                let newLevels = Prototype.overrideArray(\r\n                    hierarchy.levels,\r\n                    (level: DataViewHierarchyLevel) => {\r\n                        let newLevel: DataViewHierarchyLevel = null;\r\n                        let levelSources = Prototype.overrideArray(level.sources, override);\r\n                        if (levelSources)\r\n                            newLevel = ensureRewritten<DataViewHierarchyLevel>(newLevel, level, h => h.sources = levelSources);\r\n\r\n                        return newLevel;\r\n                    });\r\n                if (newLevels)\r\n                    rewrittenHierarchy = ensureRewritten<DataViewHierarchy>(rewrittenHierarchy, hierarchy, r => r.levels = newLevels);\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n\r\n            let rows = overrideHierarchy(matrix.rows);\r\n            if (rows) {\r\n                matrix.rows = rows;\r\n                context.rowHierarchyRewritten = true;\r\n            }\r\n\r\n            let columns = overrideHierarchy(matrix.columns);\r\n            if (columns) {\r\n                matrix.columns = columns;\r\n                context.columnHierarchyRewritten = true;\r\n            }\r\n\r\n            let valueSources = Prototype.overrideArray(matrix.valueSources, override);\r\n            if (valueSources) {\r\n                matrix.valueSources = valueSources;\r\n\r\n                // Only need to reorder if we have more than one value source, and they are all bound to the same role\r\n                let matrixValues = <DataViewRoleForMapping>matrixMapping.values;\r\n                if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\r\n                    let columnLevels = columns.levels.length;\r\n                    if (columnLevels > 0) {\r\n                        let newToOldPositions = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\r\n                        if (newToOldPositions) {\r\n                            let keys = Object.keys(newToOldPositions);\r\n                            let numKeys = keys.length;\r\n\r\n                            // Reorder the value columns\r\n                            columns.root = DataViewPivotMatrix.cloneTree(columns.root);\r\n                            if (columnLevels === 1)\r\n                                reorderChildNodes(columns.root, newToOldPositions);\r\n                            else\r\n                                forEachNodeAtLevel(columns.root, columnLevels - 2, (node: DataViewMatrixNode) => reorderChildNodes(node, newToOldPositions));\r\n\r\n                            // Reorder the value rows\r\n                            matrix.rows.root = DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, (node: DataViewMatrixNode) => {\r\n\r\n                                if (!node.values)\r\n                                    return;\r\n\r\n                                let newValues: { [id: number]: DataViewTreeNodeValue } = {};\r\n\r\n                                let iterations = Object.keys(node.values).length / numKeys;\r\n                                for (let i = 0, len = iterations; i < len; i++) {\r\n                                    let offset = i * numKeys;\r\n                                    for (let keysIndex = 0; keysIndex < numKeys; keysIndex++)\r\n                                        newValues[offset + keysIndex] = node.values[offset + newToOldPositions[keys[keysIndex]]];\r\n                                }\r\n\r\n                                node.values = newValues;\r\n                            });\r\n\r\n                            context.hierarchyTreesRewritten = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\r\n\r\n            return matrix;\r\n        }\r\n\r\n        function reorderChildNodes(node: DataViewMatrixNode, newToOldPositions: NumberToNumberMapping): void {\r\n            let keys = Object.keys(newToOldPositions);\r\n            let numKeys = keys.length;\r\n            let children = node.children;\r\n\r\n            let childrenClone = children.slice(0);\r\n            for (let i = 0, len = numKeys; i < len; i++) {\r\n                let sourceColumn = childrenClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === children.length)\r\n                    children.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < children.length, 'The column index is out of range for reordering.');\r\n                    children[i] = sourceColumn;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\r\n         * and values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified prototype is necessary.\r\n         */\r\n        function reorderMatrixCompositeGroups(\r\n            prototype: DataViewMatrix,\r\n            supportedDataViewMapping: DataViewMatrixMapping,\r\n            projection: DataViewProjectionOrdering): DataViewMatrix {\r\n\r\n            let transformedDataView: DataViewMatrix;\r\n\r\n            if (prototype && supportedDataViewMapping && projection) {\r\n\r\n                // reorder levelValues in any composite groups in rows hierarchy\r\n                let transformedRowsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedRowsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedRowsHierarchy || prototype.rows,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                // reorder levelValues in any composite groups in columns hierarchy\r\n                let transformedColumnsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedColumnsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedColumnsHierarchy || prototype.columns,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                if (transformedRowsHierarchy || transformedColumnsHierarchy) {\r\n                    transformedDataView = inheritSingle(prototype);\r\n                    transformedDataView.rows = transformedRowsHierarchy || transformedDataView.rows;\r\n                    transformedDataView.columns = transformedColumnsHierarchy || transformedDataView.columns;\r\n                }\r\n            }\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\r\n         * values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\r\n         */\r\n        function reorderMatrixHierarchyCompositeGroups(\r\n            matrixHierarchy: DataViewHierarchy,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): DataViewHierarchy {\r\n            debug.assertValue(matrixHierarchy, 'matrixHierarchy');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n\r\n            let transformedHierarchy: DataViewHierarchy;\r\n            let selectIndicesInProjectionOrder: number[] = projection[hierarchyRole];\r\n\r\n            // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\r\n            let hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\r\n            if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\r\n                for (let i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\r\n                    var hierarchyLevel: DataViewHierarchyLevel = matrixHierarchy.levels[i];\r\n\r\n                    // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\r\n                    let newToOldLevelSourceIndicesMapping: NumberToNumberMapping =\r\n                        createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\r\n\r\n                    if (newToOldLevelSourceIndicesMapping) {\r\n                        if (_.isUndefined(transformedHierarchy)) {\r\n                            // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\r\n                            // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\r\n                            transformedHierarchy = inheritSingle(matrixHierarchy);\r\n                            transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\r\n\r\n                            // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\r\n                            // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\r\n                            // happen in other hierarchy levels in the later iterations of this for-loop.\r\n                            transformedHierarchy.root = utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\r\n                        }\r\n\r\n                        // reorder the metadata columns in the sources array at that level\r\n                        let transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\r\n                        transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\r\n\r\n                        // reorder the level values in the composite group nodes at the current hierarchy level\r\n                        reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return transformedHierarchy;\r\n        }\r\n\r\n        /**\r\n         * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\r\n         * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\r\n         *\r\n         * The returned value maps level source indices from the new target order (calculated from projection order)\r\n         * back to the original order as they appear in the specified hierarchyLevel's sources.\r\n         * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\r\n         *\r\n         * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\r\n         *\r\n         * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\r\n         * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\r\n         * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\r\n         */\r\n        function createMatrixHierarchyLevelSourcesPositionMapping(\r\n            hierarchyLevel: DataViewHierarchyLevel,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): NumberToNumberMapping {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n            debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\r\n\r\n            let newToOldLevelSourceIndicesMapping: NumberToNumberMapping;\r\n            let levelSourceColumns = hierarchyLevel.sources;\r\n\r\n            if (levelSourceColumns && levelSourceColumns.length >= 2) {\r\n                // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\r\n\r\n                let columnsForHierarchyRoleOrderedByLevelSourceIndex = utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(\r\n                    levelSourceColumns,\r\n                    projection,\r\n                    hierarchyRole);\r\n\r\n                if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\r\n                    // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\r\n                    let columnsForHierarchyRoleOrderedByProjection = _.sortBy(\r\n                        columnsForHierarchyRoleOrderedByLevelSourceIndex,\r\n                        columnInfo => columnInfo.projectionOrderIndex);\r\n\r\n                    newToOldLevelSourceIndicesMapping = createOrderMapping(\r\n                        _.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, columnInfo => columnInfo.sourceIndex),\r\n                        _.map(columnsForHierarchyRoleOrderedByProjection, columnInfo => columnInfo.sourceIndex));\r\n                }\r\n            }\r\n\r\n            return newToOldLevelSourceIndicesMapping;\r\n        }\r\n\r\n        /**\r\n         * Applies re-ordering on the specified transformingHierarchyLevel's sources.\r\n         * Returns the same object as the specified transformingHierarchyLevel.\r\n         */\r\n        function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel: DataViewHierarchyLevel, newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewHierarchyLevel {\r\n            debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let originalLevelSources = transformingHierarchyLevel.sources;\r\n\r\n            transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\r\n\r\n            let newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\r\n            for (let i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\r\n                let newLevelSourceIndex = newLevelSourceIndices[i];\r\n                let oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\r\n\r\n                debug.assert(oldLevelSourceIndex < originalLevelSources.length,\r\n                    'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\r\n\r\n                transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\r\n            }\r\n\r\n            return transformingHierarchyLevel;\r\n        }\r\n\r\n        /**\r\n         * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\r\n         * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\r\n         *\r\n         * Returns the same object as the specified transformingHierarchyRootNode.\r\n         */\r\n        function reorderMatrixHierarchyLevelValues(\r\n            transformingHierarchyRootNode: DataViewMatrixNode,\r\n            transformingHierarchyLevelIndex: number,\r\n            newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewMatrixNode {\r\n            debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let oldToNewLevelSourceIndicesMapping: NumberToNumberMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\r\n\r\n            forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, (transformingMatrixNode: DataViewMatrixNode) => {\r\n                let originalLevelValues = transformingMatrixNode.levelValues;\r\n\r\n                // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\r\n                // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\r\n                // The following code isn't correct in the special case where a column is projected twice in this composite group,\r\n                // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\r\n                // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\r\n\r\n                if (!_.isEmpty(originalLevelValues)) {\r\n                    // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\r\n                    // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\r\n                    // because we don't want to accidentally modify the array AND its value references in Query DataView\r\n                    let newlyOrderedLevelValues = _.sortBy(originalLevelValues, levelValue => oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]);\r\n\r\n                    for (let i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\r\n                        let transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\r\n                        transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\r\n                        newlyOrderedLevelValues[i] = transformingLevelValue;\r\n                    }\r\n\r\n                    transformingMatrixNode.levelValues = newlyOrderedLevelValues;\r\n\r\n                    // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\r\n                    // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\r\n                    let newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\r\n                    if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\r\n                        transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\r\n                    }\r\n                    if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\r\n                        transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return transformingHierarchyRootNode;\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of new position to original position.\r\n         *\r\n         * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\r\n         * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\r\n         * - the value in the key-value pair is the index of the particular column in the original order\r\n         */\r\n        function createMatrixValuesPositionMapping(\r\n            matrixValues: DataViewRoleForMapping,\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            valueSources: DataViewMetadataColumn[],\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n\r\n            let role = matrixValues.for.in;\r\n            let newOrder = projectionOrdering[role];\r\n\r\n            let originalOrder = _.chain(columnRewrites)\r\n                .filter(rewrite => _.contains(valueSources, rewrite.to))\r\n                .map(rewrite => rewrite.from.index)\r\n                .value();\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\r\n         * originalOrder array.\r\n         * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\r\n         * under the context of the caller code), e.g. the Select Index in projection ordering array.\r\n         * Also, the specified originalOrder must contain every value that exists in newOrder.\r\n         *\r\n         * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\r\n         * key-value pair, each of which represents the new and old indices of a particular column:\r\n         * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\r\n         * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\r\n         *\r\n         * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\r\n         *\r\n         * If the specified originalOrder and newOrder are same, then this function returns undefined.\r\n         *\r\n         * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\r\n         * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\r\n         */\r\n        function createOrderMapping(originalOrder: number[], newOrder: number[]): NumberToNumberMapping {\r\n            // Optimization: avoid rewriting if the current order is correct\r\n            if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, (x: number, y: number) => x === y))\r\n                return;\r\n\r\n            let mapping: NumberToNumberMapping = {};\r\n            for (let i = 0, len = newOrder.length; i < len; ++i) {\r\n                let newPosition = newOrder[i];\r\n                mapping[i] = originalOrder.indexOf(newPosition);\r\n            }\r\n\r\n            return mapping;\r\n        }\r\n\r\n        function createReversedMapping(mapping: NumberToNumberMapping): NumberToNumberMapping {\r\n            debug.assertValue(mapping, 'mapping');\r\n\r\n            let reversed: NumberToNumberMapping = {};\r\n\r\n            for (let key in mapping) {\r\n                // Note: key is a string after we get it out from mapping, thus we need to parse it\r\n                // back into a number before putting it as the value in the reversed mapping\r\n                let value = mapping[key];\r\n                let keyAsNumber = parseInt(key, 10);\r\n                reversed[value] = keyAsNumber;\r\n            }\r\n\r\n            debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length,\r\n                'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\r\n\r\n            return reversed;\r\n        }\r\n\r\n        export function forEachNodeAtLevel(node: DataViewMatrixNode, targetLevel: number, callback: (node: DataViewMatrixNode) => void): void {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(targetLevel >= 0, 'argetLevel >= 0');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            if (node.level === targetLevel) {\r\n                callback(node);\r\n                return;\r\n            }\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachNodeAtLevel(children[i], targetLevel, callback);\r\n            }\r\n        }\r\n\r\n        function findOverride(source: DataViewMetadataColumn, columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn {\r\n            for (let i = 0, len = columnRewrites.length; i < len; i++) {\r\n                let columnRewrite = columnRewrites[i];\r\n                if (columnRewrite.from === source)\r\n                    return columnRewrite.to;\r\n            }\r\n        }\r\n\r\n        function ensureRewritten<T>(rewritten: T, prototype: T, callback?: (rewritten: T) => void): T {\r\n            if (!rewritten)\r\n                rewritten = inherit(prototype);\r\n\r\n            if (callback)\r\n                callback(rewritten);\r\n\r\n            return rewritten;\r\n        }\r\n\r\n        export function transformObjects(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!objectDescriptors)\r\n                return;\r\n\r\n            let objectsForAllSelectors = DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\r\n            DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\r\n\r\n            let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n            let dataObjects = objectsForAllSelectors.data;\r\n            if (metadataOnce)\r\n                evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\r\n\r\n            let metadataObjects = objectsForAllSelectors.metadata;\r\n            if (metadataObjects) {\r\n                for (let i = 0, len = metadataObjects.length; i < len; i++) {\r\n                    let metadataObject = metadataObjects[i];\r\n                    let objectDefns = metadataObject.objects;\r\n                    let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                    evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\r\n                }\r\n            }\r\n\r\n            for (let i = 0, len = dataObjects.length; i < len; i++) {\r\n                let dataObject = dataObjects[i];\r\n                let objectDefns = dataObject.objects;\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\r\n            }\r\n\r\n            let userDefined = objectsForAllSelectors.userDefined;\r\n            if (userDefined) {\r\n                // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\r\n                evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\r\n            }\r\n        }\r\n\r\n        function evaluateUserDefinedObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewObjectDefinitionsForSelector[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let dataViewObjects: DataViewObjects = dataView.metadata.objects;\r\n            if (!dataViewObjects) {\r\n                dataViewObjects = dataView.metadata.objects = {};\r\n            }\r\n\r\n            for (let objectDefn of objectDefns) {\r\n                let id = objectDefn.selector.id;\r\n\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\r\n                let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n                let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName];\r\n\r\n                    let map = <DataViewObjectMap>dataViewObjects[objectName];\r\n                    if (!map)\r\n                        map = dataViewObjects[objectName] = [];\r\n                    debug.assert(DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\r\n\r\n                    // NOTE: We do not check for duplicate ids.\r\n                    map.push({ id: id, object: object });\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Evaluates and sets properties on the DataView metadata. */\r\n        function evaluateMetadataObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            dataObjects: DataViewObjectDefinitionsForSelectorWithRule[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(dataObjects, 'dataObjects');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n            let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n            if (objects) {\r\n                dataView.metadata.objects = objects;\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName],\r\n                        objectDesc = objectDescriptors[objectName];\r\n\r\n                    for (let propertyName in object) {\r\n                        let propertyDesc = objectDesc.properties[propertyName],\r\n                            ruleDesc = propertyDesc.rule;\r\n                        if (!ruleDesc)\r\n                            continue;\r\n\r\n                        let definition = createRuleEvaluationInstance(\r\n                            dataView,\r\n                            colorAllocatorFactory,\r\n                            ruleDesc,\r\n                            objectName,\r\n                            object[propertyName],\r\n                            propertyDesc.type);\r\n                        if (!definition)\r\n                            continue;\r\n\r\n                        dataObjects.push(definition);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstance(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            objectName: string,\r\n            propertyValue: DataViewPropertyValue,\r\n            ruleType: StructuralTypeDescriptor): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n            debug.assertValue(ruleType, 'ruleType');\r\n\r\n            let ruleOutput = ruleDesc.output;\r\n            if (!ruleOutput)\r\n                return;\r\n\r\n            let selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\r\n            if (!selectorToCreate)\r\n                return;\r\n\r\n            if (ruleType.fillRule) {\r\n                return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, <FillRule>propertyValue);\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstanceFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            selectorToCreate: Selector,\r\n            objectName: string,\r\n            propertyValue: FillRule): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(selectorToCreate, 'selectorToCreate');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, ColumnIdentifierKind.Role, propertyValue);\r\n\r\n            if (!colorAllocator)\r\n                return;\r\n\r\n            let rule = new ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\r\n            let fillRuleProperties: DataViewObjectPropertyDefinitions = {};\r\n            fillRuleProperties[ruleDesc.output.property] = {\r\n                solid: { color: rule }\r\n            };\r\n\r\n            return {\r\n                selector: selectorToCreate,\r\n                rules: [rule],\r\n                objects: [{\r\n                    name: objectName,\r\n                    properties: fillRuleProperties,\r\n                }]\r\n            };\r\n        }\r\n\r\n        function tryCreateColorAllocatorForFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValue: FillRule): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            if (propertyValue.linearGradient2)\r\n                return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\r\n\r\n            if (propertyValue.linearGradient3)\r\n                return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient2(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient2: LinearGradient2): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient2, 'linearGradient2');\r\n\r\n            linearGradient2 = propertyValueFillRule.linearGradient2;\r\n            if (linearGradient2.min.value === undefined ||\r\n                linearGradient2.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                if (linearGradient2.min.value === undefined)\r\n                    linearGradient2.min.value = inputRange.min;\r\n                if (linearGradient2.max.value === undefined)\r\n                    linearGradient2.max.value = inputRange.max;\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient3(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient3: LinearGradient3): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient3, 'linearGradient3');\r\n\r\n            let splitScales: boolean;\r\n            linearGradient3 = propertyValueFillRule.linearGradient3;\r\n            if (linearGradient3.min.value === undefined ||\r\n                linearGradient3.mid.value === undefined ||\r\n                linearGradient3.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                splitScales =\r\n                linearGradient3.min.value === undefined &&\r\n                linearGradient3.max.value === undefined &&\r\n                linearGradient3.mid.value !== undefined;\r\n\r\n                if (linearGradient3.min.value === undefined) {\r\n                    linearGradient3.min.value = inputRange.min;\r\n                }\r\n                if (linearGradient3.max.value === undefined) {\r\n                    linearGradient3.max.value = inputRange.max;\r\n                }\r\n                if (linearGradient3.mid.value === undefined) {\r\n                    let midValue: number = (linearGradient3.max.value + linearGradient3.min.value) / 2;\r\n                    linearGradient3.mid.value = midValue;\r\n                }\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\r\n        }\r\n\r\n        function populateColorAllocatorCache(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): IColorAllocatorCache {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let cache = createColorAllocatorCache();\r\n            let staticEvalContext = createStaticEvalContext();\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefnProperties = objectDefns[i].properties;\r\n\r\n                for (let propertyName in objectDefnProperties) {\r\n                    let fillProperty = <FillDefinition>objectDefnProperties[propertyName];\r\n                    if (fillProperty &&\r\n                        fillProperty.solid &&\r\n                        fillProperty.solid.color &&\r\n                        fillProperty.solid.color.kind === SQExprKind.FillRule) {\r\n\r\n                        let fillRuleExpr = <SQFillRuleExpr>fillProperty.solid.color;\r\n\r\n                        let inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\r\n                        if (!inputExprQueryName)\r\n                            continue;\r\n\r\n                        let fillRule = DataViewObjectEvaluator.evaluateProperty(\r\n                            staticEvalContext,\r\n                            fillRulePropertyDescriptor,\r\n                            fillRuleExpr.rule);\r\n\r\n                        let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, ColumnIdentifierKind.QueryName, fillRule);\r\n                        if (colorAllocator)\r\n                            cache.register(fillRuleExpr, colorAllocator);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return cache;\r\n        }\r\n\r\n        function evaluateDataRepetition(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\r\n\r\n            let containsWildcard = Selector.containsWildcard(selector);\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Categorical)) {\r\n                // 1) Match against categories\r\n                evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // 2) Match against valueGrouping\r\n                evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewMatrix = dataView.matrix;\r\n            if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Matrix)) {\r\n                let rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenMatrix) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.matrix = rewrittenMatrix;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewTable = dataView.table;\r\n            if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Table)) {\r\n                let rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\r\n                let rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenTable) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.table = rewrittenTable;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n        }\r\n\r\n        function rewriteTableRoleSelector(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            if (Selector.hasRoleWildcard(selector)) {\r\n                selector = findSelectorForRoleWildcard(dataViewTable, selector);\r\n            }\r\n\r\n            return selector;\r\n        }\r\n\r\n        function findSelectorForRoleWildcard(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            let resultingSelector: Selector = {\r\n                data: [],\r\n                id: selector.id,\r\n                metadata: selector.metadata\r\n            };\r\n\r\n            for (let dataSelector of selector.data) {\r\n                if (Selector.isRoleWildcard(dataSelector)) {\r\n                    let selectorRoles = dataSelector.roles;\r\n                    let allColumnsBelongToSelectorRole: boolean = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\r\n                    let exprs = dataViewTable.identityFields;\r\n                    if (allColumnsBelongToSelectorRole && exprs) {\r\n                        resultingSelector.data.push(DataViewScopeWildcard.fromExprs(<SQExpr[]>exprs));\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\r\n                    resultingSelector.data.push(dataSelector);\r\n                }\r\n            }\r\n\r\n            return resultingSelector;\r\n        }\r\n\r\n        function isUniqueDataSelector(dataSelectors: DataRepetitionSelector[], newSelector: DataRepetitionSelector): boolean {\r\n            if (_.isEmpty(dataSelectors))\r\n                return true;\r\n\r\n            return !_.any(dataSelectors, (dataSelector: DataRepetitionSelector) => dataSelector.key === newSelector.key);\r\n        }\r\n\r\n        function allColumnsBelongToRole(columns: DataViewMetadataColumn[], selectorRoles: string[]): boolean {\r\n            for (let column of columns) {\r\n                var roles = column.roles;\r\n                if (!roles || !_.any(selectorRoles, (selectorRole) => roles[selectorRole]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalCategory(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\r\n                return;\r\n\r\n            let targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\r\n            if (!targetColumn)\r\n                return;\r\n\r\n            let identities = targetColumn.identities,\r\n                foundMatch: boolean,\r\n                evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            if (!identities)\r\n                return;\r\n\r\n            debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\r\n\r\n            for (let i = 0, len = identities.length; i < len; i++) {\r\n                let identity = identities[i];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(i);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n                        if (!targetColumn.column.objects) {\r\n                            targetColumn.column.objects = [];\r\n                            targetColumn.column.objects.length = len;\r\n                        }\r\n                        targetColumn.column.objects[i] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n\r\n                    foundMatch = true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalValueGrouping(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let dataViewCategoricalValues = dataViewCategorical.values;\r\n            if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\r\n                return;\r\n\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[dataViewCategoricalValues.identityFields]))\r\n                return;\r\n\r\n            let valuesGrouped = dataViewCategoricalValues.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\r\n            // This should be enhanced in the future.\r\n            let evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            let foundMatch: boolean;\r\n            for (let i = 0, len = valuesGrouped.length; i < len; i++) {\r\n                let valueGroup = valuesGrouped[i];\r\n                let selectorMetadata = selector.metadata;\r\n                let valuesInGroup = valueGroup.values;\r\n                if (containsWildcard || Selector.matchesData(selector, [valueGroup.identity])) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n\r\n                        if (selectorMetadata) {\r\n                            for (let j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\r\n                                let valueColumn = valuesInGroup[j],\r\n                                    valueSource = valueColumn.source;\r\n                                if (valueSource.queryName === selectorMetadata) {\r\n                                    let valueSourceOverwrite = Prototype.inherit(valueSource);\r\n                                    valueSourceOverwrite.objects = objects;\r\n                                    valueColumn.source = valueSourceOverwrite;\r\n\r\n                                    foundMatch = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            valueGroup.objects = objects;\r\n                            setGrouped(dataViewCategoricalValues, valuesGrouped);\r\n\r\n                            foundMatch = true;\r\n                        }\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrix(\r\n            dataViewMatrix: DataViewMatrix,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewMatrix {\r\n\r\n            let evalContext = createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\r\n            let rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            let rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n\r\n            if (rewrittenRows || rewrittenCols) {\r\n                let rewrittenMatrix = inheritSingle(dataViewMatrix);\r\n\r\n                if (rewrittenRows)\r\n                    rewrittenMatrix.rows = rewrittenRows;\r\n                if (rewrittenCols)\r\n                    rewrittenMatrix.columns = rewrittenCols;\r\n\r\n                return rewrittenMatrix;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixHierarchy(\r\n            evalContext: IEvalContext,\r\n            dataViewMatrixHierarchy: DataViewHierarchy,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewHierarchy {\r\n            debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (!dataViewMatrixHierarchy)\r\n                return;\r\n\r\n            let root = dataViewMatrixHierarchy.root;\r\n            if (!root)\r\n                return;\r\n\r\n            let rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            if (rewrittenRoot) {\r\n                let rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\r\n                rewrittenHierarchy.root = rewrittenRoot;\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixNode(\r\n            evalContext: IEvalContext,\r\n            dataViewNode: DataViewMatrixNode,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewMatrixNode {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(dataViewNode, 'dataViewNode');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let childNodes = dataViewNode.children;\r\n            if (!childNodes)\r\n                return;\r\n\r\n            let rewrittenNode: DataViewMatrixNode;\r\n            let shouldSearchChildren: boolean;\r\n            let childIdentityFields = dataViewNode.childIdentityFields;\r\n            if (childIdentityFields) {\r\n                // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\r\n                shouldSearchChildren = Selector.matchesKeys(selector, <SQExpr[][]>[childIdentityFields]);\r\n            }\r\n\r\n            for (let i = 0, len = childNodes.length; i < len; i++) {\r\n                let childNode = childNodes[i],\r\n                    identity = childNode.identity,\r\n                    rewrittenChildNode: DataViewMatrixNode = null;\r\n\r\n                if (shouldSearchChildren) {\r\n                    if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                        // TODO: Need to initialize context for rule-based properties.  Rule-based properties\r\n                        // (such as fillRule/gradients) are not currently implemented.\r\n\r\n                        let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                        if (objects) {\r\n                            rewrittenChildNode = inheritSingle(childNode);\r\n                            rewrittenChildNode.objects = objects;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rewrittenChildNode = evaluateDataRepetitionMatrixNode(\r\n                        evalContext,\r\n                        childNode,\r\n                        objectDescriptors,\r\n                        selector,\r\n                        rules,\r\n                        containsWildcard,\r\n                        objectDefns);\r\n                }\r\n\r\n                if (rewrittenChildNode) {\r\n                    if (!rewrittenNode)\r\n                        rewrittenNode = inheritNodeAndChildren(dataViewNode);\r\n                    rewrittenNode.children[i] = rewrittenChildNode;\r\n\r\n                    if (!containsWildcard) {\r\n                        // NOTE: once we find a match for a non-wildcard selector, stop looking.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return rewrittenNode;\r\n        }\r\n\r\n        function inheritNodeAndChildren(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            if (Object.getPrototypeOf(node) !== Object.prototype) {\r\n                return node;\r\n            }\r\n\r\n            let inherited = inheritSingle(node);\r\n            inherited.children = inherit(node.children);\r\n            return inherited;\r\n        }\r\n\r\n        function evaluateDataRepetitionTable(\r\n            dataViewTable: DataViewTable,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewTable {\r\n            debug.assertValue(dataViewTable, 'dataViewTable');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let evalContext = createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\r\n            let rewrittenRows = evaluateDataRepetitionTableRows(\r\n                evalContext,\r\n                dataViewTable.columns,\r\n                dataViewTable.rows,\r\n                dataViewTable.identity,\r\n                dataViewTable.identityFields,\r\n                objectDescriptors,\r\n                selector,\r\n                rules,\r\n                containsWildcard,\r\n                objectDefns);\r\n\r\n            if (rewrittenRows) {\r\n                let rewrittenTable = inheritSingle(dataViewTable);\r\n                rewrittenTable.rows = rewrittenRows;\r\n\r\n                return rewrittenTable;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionTableRows(\r\n            evalContext: ITableEvalContext,\r\n            columns: DataViewMetadataColumn[],\r\n            rows: DataViewTableRow[],\r\n            identities: DataViewScopeIdentity[],\r\n            identityFields: ISQExpr[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewTableRow[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(rows, 'rows');\r\n            debug.assertAnyValue(identities, 'identities');\r\n            debug.assertAnyValue(identityFields, 'identityFields');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (_.isEmpty(identities) || _.isEmpty(identityFields))\r\n                return;\r\n\r\n            if (!selector.metadata ||\r\n                !Selector.matchesKeys(selector, <SQExpr[][]>[identityFields]))\r\n                return;\r\n\r\n            let colIdx = _.findIndex(columns, col => col.queryName === selector.metadata);\r\n            if (colIdx < 0)\r\n                return;\r\n\r\n            debug.assert(rows.length === identities.length, 'row length mismatch');\r\n            let colLen = columns.length;\r\n            let inheritedRows: DataViewTableRow[];\r\n\r\n            for (let rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\r\n                let identity = identities[rowIdx];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(rowIdx);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        if (!inheritedRows)\r\n                            inheritedRows = inheritSingle(rows);\r\n\r\n                        let inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\r\n                        let objectsForColumns = inheritedRow.objects;\r\n                        if (!objectsForColumns)\r\n                            inheritedRow.objects = objectsForColumns = new Array(colLen);\r\n\r\n                        objectsForColumns[colIdx] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return inheritedRows;\r\n        }\r\n\r\n        function evaluateMetadataRepetition(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n            // revisit this, likely when we do lazy evaluation of DataView.\r\n            let columns = dataView.metadata.columns,\r\n                metadataId = selector.metadata,\r\n                evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                let column = columns[i];\r\n                if (column.queryName === metadataId) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects)\r\n                        column.objects = objects;\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Attempts to find a column that can possibly match the selector. */\r\n        function findSelectedCategoricalColumn(dataViewCategorical: DataViewCategorical, selector: Selector) {\r\n            debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\r\n\r\n            let categoricalColumn = dataViewCategorical.categories[0];\r\n            if (!categoricalColumn.identityFields)\r\n                return;\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[categoricalColumn.identityFields]))\r\n                return;\r\n\r\n            let identities = categoricalColumn.identity,\r\n                targetColumn: DataViewCategoricalColumn = categoricalColumn;\r\n\r\n            let selectedMetadataId = selector.metadata;\r\n            if (selectedMetadataId) {\r\n                let valueColumns = dataViewCategorical.values;\r\n                if (valueColumns) {\r\n                    for (let i = 0, len = valueColumns.length; i < len; i++) {\r\n                        let valueColumn = valueColumns[i];\r\n                        if (valueColumn.source.queryName === selectedMetadataId) {\r\n                            targetColumn = valueColumn;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                column: targetColumn,\r\n                identities: identities,\r\n            };\r\n        }\r\n\r\n        function findSelectorForRuleInput(dataView: DataView, selectorRoles: string[]): Selector {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectorRoles, 'selectorRoles');\r\n\r\n            if (selectorRoles.length !== 1)\r\n                return;\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return;\r\n\r\n            let categories = dataViewCategorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let categoryColumn = categories[0],\r\n                categoryRoles = categoryColumn.source.roles,\r\n                categoryIdentityFields = categoryColumn.identityFields;\r\n            if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\r\n                return;\r\n\r\n            return { data: [DataViewScopeWildcard.fromExprs(<SQExpr[]>categoryIdentityFields)] };\r\n        }\r\n\r\n        function findFirstQueryNameForExpr(selectTransforms: DataViewSelectTransform[], expr: SQExpr): string {\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (!selectTransforms)\r\n                return;\r\n\r\n            for (let i = 0, len = selectTransforms.length; i < len; i++) {\r\n                let select = selectTransforms[i],\r\n                    columnExpr = select.expr;\r\n\r\n                if (!columnExpr || !SQExpr.equals(expr, select.expr))\r\n                    continue;\r\n\r\n                return select.queryName;\r\n            }\r\n        }\r\n\r\n        /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\r\n        function findRuleInputColumnNumberRange(dataView: DataView, identifier: string, identifierKind: ColumnIdentifierKind): NumberRange {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n\r\n            // NOTE: This implementation currently only supports categorical DataView, becuase that's the\r\n            // only scenario that has custom colors, as of this writing.  This would be rewritten to be more generic\r\n            // as required, when needed.\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return;\r\n\r\n            let values = dataViewCategorical.values;\r\n            if (!values)\r\n                return;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let valueCol = values[i];\r\n\r\n                if (identifierKind === ColumnIdentifierKind.Role) {\r\n                    let valueColRoles = valueCol.source.roles;\r\n\r\n                    if (!valueColRoles || !valueColRoles[identifier])\r\n                        continue;\r\n                }\r\n                else {\r\n                    debug.assert(identifierKind === ColumnIdentifierKind.QueryName, 'identifierKind === ColumnIdentifierKind.QueryName');\r\n\r\n                    if (valueCol.source.queryName !== identifier)\r\n                        continue;\r\n                }\r\n\r\n                let min = valueCol.min;\r\n                if (min === undefined)\r\n                    min = valueCol.minLocal;\r\n                if (min === undefined)\r\n                    continue;\r\n\r\n                let max = valueCol.max;\r\n                if (max === undefined)\r\n                    max = valueCol.maxLocal;\r\n                if (max === undefined)\r\n                    continue;\r\n\r\n                return { min: min, max: max };\r\n            }\r\n        }\r\n\r\n        // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\r\n        export function createValueColumns(\r\n            values: DataViewValueColumn[] = [],\r\n            valueIdentityFields?: SQExpr[],\r\n            source?: DataViewMetadataColumn): DataViewValueColumns {\r\n            let result = <DataViewValueColumns>values;\r\n            setGrouped(<DataViewValueColumns>values);\r\n\r\n            if (valueIdentityFields)\r\n                result.identityFields = valueIdentityFields;\r\n\r\n            if (source)\r\n                result.source = source;\r\n\r\n            return result;\r\n        }\r\n\r\n        export function setGrouped(values: DataViewValueColumns, groupedResult?: DataViewValueColumnGroup[]): void {\r\n            values.grouped = groupedResult\r\n                ? () => groupedResult\r\n                : () => groupValues(values);\r\n        }\r\n\r\n        /** Group together the values with a common identity. */\r\n        function groupValues(values: DataViewValueColumn[]): DataViewValueColumnGroup[] {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let groups: DataViewValueColumnGroup[] = [],\r\n                currentGroup: DataViewValueColumnGroup;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n\r\n                if (!currentGroup || currentGroup.identity !== value.identity) {\r\n                    currentGroup = {\r\n                        values: []\r\n                    };\r\n\r\n                    if (value.identity) {\r\n                        currentGroup.identity = value.identity;\r\n\r\n                        let source = value.source;\r\n\r\n                        // allow null, which will be formatted as (Blank).\r\n                        if (source.groupName !== undefined)\r\n                            currentGroup.name = source.groupName;\r\n                        else if (source.displayName)\r\n                            currentGroup.name = source.displayName;\r\n                    }\r\n\r\n                    groups.push(currentGroup);\r\n                }\r\n\r\n                currentGroup.values.push(value);\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function pivotIfNecessary(dataView: DataView, dataViewMappings: DataViewMapping[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let transformedDataView: DataView;\r\n            switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\r\n                case CategoricalDataViewTransformation.Pivot:\r\n                    transformedDataView = DataViewPivotCategorical.apply(dataView);\r\n                    break;\r\n\r\n                case CategoricalDataViewTransformation.SelfCrossJoin:\r\n                    transformedDataView = DataViewSelfCrossJoin.apply(dataView);\r\n                    break;\r\n            }\r\n\r\n            return transformedDataView || dataView;\r\n        }\r\n\r\n        function determineCategoricalTransformation(categorical: DataViewCategorical, dataViewMappings: DataViewMapping[]): CategoricalDataViewTransformation {\r\n            if (!categorical || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values))\r\n                return;\r\n\r\n            if (values.grouped().some(vg => !!vg.identity))\r\n                return;\r\n\r\n            // If we made it here, the DataView has a single category and no valueGrouping.\r\n            let categoryRoles = categories[0].source.roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingCategorical = dataViewMappings[i].categorical;\r\n                if (!roleMappingCategorical)\r\n                    continue;\r\n\r\n                if (!hasRolesGrouped(categoryRoles, <DataViewGroupedRoleMapping>roleMappingCategorical.values))\r\n                    continue;\r\n\r\n                // If we made it here, the DataView's single category has the value grouping role.\r\n                let categoriesMapping = roleMappingCategorical.categories;\r\n                let hasCategoryRole =\r\n                    hasRolesBind(categoryRoles, <DataViewRoleBindMappingWithReduction>categoriesMapping) ||\r\n                    hasRolesFor(categoryRoles, <DataViewRoleForMappingWithReduction>categoriesMapping);\r\n\r\n                if (hasCategoryRole)\r\n                    return CategoricalDataViewTransformation.SelfCrossJoin;\r\n\r\n                return CategoricalDataViewTransformation.Pivot;\r\n            }\r\n        }\r\n\r\n        function shouldPivotMatrix(matrix: DataViewMatrix, dataViewMappings: DataViewMapping[]): boolean {\r\n            if (!matrix || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let rowLevels = matrix.rows.levels;\r\n            if (rowLevels.length < 1)\r\n                return;\r\n\r\n            let rows = matrix.rows.root.children;\r\n            if (!rows || rows.length === 0)\r\n                return;\r\n\r\n            let rowRoles = rowLevels[0].sources[0].roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingMatrix = dataViewMappings[i].matrix;\r\n                if (!roleMappingMatrix)\r\n                    continue;\r\n\r\n                if (!hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.rows) &&\r\n                    hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.columns)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        function hasRolesBind(roles: { [name: string]: boolean }, roleMapping: DataViewRoleBindMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.bind)\r\n                return roles[roleMapping.bind.to];\r\n        }\r\n\r\n        function hasRolesFor(roles: { [name: string]: boolean }, roleMapping: DataViewRoleForMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.for)\r\n                return roles[roleMapping.for.in];\r\n        }\r\n\r\n        function hasRolesGrouped(roles: { [name: string]: boolean }, roleMapping: DataViewGroupedRoleMapping): boolean {\r\n            if (roles && roleMapping && roleMapping.group)\r\n                return roles[roleMapping.group.by];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\r\n\r\n    export function createDisplayNameGetter(displayNameKey: string): (IStringResourceProvider) => string {\r\n        return (resourceProvider: IStringResourceProvider) => resourceProvider.get(displayNameKey);\r\n    }\r\n\r\n    export function getDisplayName(displayNameGetter: data.DisplayNameGetter, resourceProvider: jsCommon.IStringResourceProvider): string {\r\n        if (typeof displayNameGetter === 'function')\r\n            return displayNameGetter(resourceProvider);\r\n\r\n        if (typeof displayNameGetter === 'string')\r\n            return displayNameGetter;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    /** Enumeration of DateTimeUnits */\r\n    export enum DateTimeUnit {\r\n        Year,\r\n        Month,\r\n        Week,\r\n        Day,\r\n        Hour,\r\n        Minute,\r\n        Second,\r\n        Millisecond,\r\n    }\r\n\r\n    export interface IFormattingService {\r\n        /** \r\n         * Formats the value using provided format expression and culture\r\n         * @param value - value to be formatted and converted to string.\r\n         * @param format - format to be applied. If undefined or empty then generic format is used.        \r\n         */\r\n        formatValue(value: any, format?: string): string;\r\n\r\n        /** \r\n         * Replaces the indexed format tokens (for example {0:c2}) in the format string with the localized formatted arguments.\r\n         * @param formatWithIndexedTokens - format string with a set of indexed format tokens.\r\n         * @param args - array of values which should replace the tokens in the format string.\r\n         * @param culture - localization culture. If undefined then the current culture is used.\r\n         */\r\n        format(formatWithIndexedTokens: string, args: any[], culture?: string): string;\r\n\r\n        /** Gets a value indicating whether the specified format a standard numeric format specifier. */\r\n        isStandardNumberFormat(format: string): boolean;\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string): string;\r\n\r\n        /** Gets the format string to use for dates in particular units. */\r\n        dateFormatString(unit: DateTimeUnit): string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Represents common expression patterns for 'field' expressions such as columns, column aggregates, measures, etc. */\r\n    export interface FieldExprPattern {\r\n        column?: FieldExprColumnPattern;\r\n        columnAggr?: FieldExprColumnAggrPattern;\r\n        columnHierarchyLevelVariation?: FieldExprColumnHierarchyLevelVariationPattern;\r\n        entity?: FieldExprEntityPattern;\r\n        entityAggr?: FieldExprEntityAggrPattern;\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        hierarchyLevel?: FieldExprHierarchyLevelPattern;\r\n        hierarchyLevelAggr?: FieldExprHierarchyLevelAggrPattern;\r\n        measure?: FieldExprMeasurePattern;\r\n    }\r\n\r\n    /** By design there is no default, no-op visitor. Components concerned with patterns need to be aware of all patterns as they are added. */\r\n    export interface IFieldExprPatternVisitor<T> {\r\n        visitColumn(column: FieldExprColumnPattern): T;\r\n        visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): T;\r\n        visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): T;\r\n        visitEntity(entity: FieldExprEntityPattern): T;\r\n        visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): T;\r\n        visitHierarchy(hierarchy: FieldExprHierarchyPattern): T;\r\n        visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): T;\r\n        visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): T;\r\n        visitMeasure(measure: FieldExprMeasurePattern): T;\r\n    }\r\n\r\n    export interface FieldExprEntityPattern {\r\n        schema: string;\r\n        entity: string;\r\n        entityVar?: string;\r\n    }\r\n\r\n    export interface FieldExprEntityItemPattern extends FieldExprEntityPattern {\r\n    }\r\n\r\n    export interface FieldExprEntityPropertyPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n    }\r\n\r\n    export type FieldExprColumnPattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprMeasurePattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprHierarchyPattern = FieldExprEntityPropertyPattern;\r\n\r\n    export type FieldExprPropertyPattern = FieldExprColumnPattern | FieldExprMeasurePattern | FieldExprHierarchyPattern;\r\n\r\n    export interface FieldExprEntityAggrPattern extends FieldExprEntityPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnAggrPattern extends FieldExprColumnPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n        level: string;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelAggrPattern extends FieldExprHierarchyLevelPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnHierarchyLevelVariationPattern {\r\n        source: FieldExprColumnPattern;\r\n        level: FieldExprHierarchyLevelPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    export module SQExprBuilder {\r\n        export function fieldExpr(fieldExpr: FieldExprPattern): SQExpr {\r\n            let sqExpr = FieldExprPattern.visit<SQExpr>(fieldExpr, FieldExprToSQExprVisitor.instance);\r\n            debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\r\n            return sqExpr;\r\n        }\r\n        \r\n        export function fromColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromColumn(columnAggr), columnAggr.aggregate);\r\n        }\r\n        \r\n        export function fromColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return columnRef(fromEntity(column), column.name);\r\n        }\r\n        \r\n        export function fromEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n            return entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\r\n        }\r\n        \r\n        export function fromEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromEntity(entityAggr), entityAggr.aggregate);\r\n        }\r\n        \r\n        export function fromHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\r\n        }\r\n        \r\n        export function fromHierarchyLevel(hierarchyLevelPattern: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n            return hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\r\n        }\r\n        \r\n        export function fromHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n             return hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\r\n        }\r\n\r\n        class FieldExprToSQExprVisitor implements IFieldExprPatternVisitor<SQExpr> {\r\n            public static instance: FieldExprToSQExprVisitor = new FieldExprToSQExprVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n                return fromColumn(column);   \r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n                return fromColumnAggr(columnAggr);\r\n            } \r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariationPattern: FieldExprColumnHierarchyLevelVariationPattern): SQPropertyVariationSourceExpr {\r\n                return propertyVariationSource(\r\n                    this.visitEntity(columnHierarchyLevelVariationPattern.source),\r\n                    columnHierarchyLevelVariationPattern.source.name,\r\n                    columnHierarchyLevelVariationPattern.level.name);\r\n            }\r\n\r\n            public visitEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n                return fromEntity(entityPattern);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n                return fromEntityAggr(entityAggr);   \r\n            }\r\n\r\n            public visitHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n                return fromHierarchy(hierarchyPattern);\r\n            }\r\n\r\n            public visitHierarchyLevel(level: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n                return fromHierarchyLevel(level);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n                return fromHierarchyLevelAggr(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): SQMeasureRefExpr {\r\n                return measureRef(this.visitEntity(measure), measure.name);\r\n            }\r\n        }\r\n    }\r\n\r\n    export module SQExprConverter {\r\n        export function asFieldPattern(sqExpr: SQExpr): FieldExprPattern {\r\n            return sqExpr.accept(FieldExprPatternBuilder.instance);\r\n        }\r\n    }\r\n\r\n    interface FieldExprSourceVariationPattern {\r\n        column: FieldExprColumnPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    interface SourceExprPattern {\r\n        entity?: FieldExprEntityPattern;\r\n\r\n        // TODO: Change FieldExprHierarchyPattern to FieldExprHierarchyLevelPattern\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    interface HierarchySourceExprPattern {\r\n        hierarchy: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    class FieldExprPatternBuilder extends DefaultSQExprVisitor<FieldExprPattern> {\r\n        public static instance: FieldExprPatternBuilder = new FieldExprPatternBuilder();\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let columnRef = <FieldExprColumnPattern>sourceRef.entity;\r\n                columnRef.name = expr.ref;\r\n\r\n                return { column: columnRef };\r\n            }\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let measureRef = <FieldExprMeasurePattern>sourceRef.entity;\r\n                measureRef.name = expr.ref;\r\n\r\n                return { measure: measureRef };\r\n            }\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): FieldExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): FieldExprPattern {\r\n            let fieldPattern: FieldExprPattern = expr.arg.accept(this);\r\n            if (fieldPattern && fieldPattern.column) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.column;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.columnAggr) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.columnAggr;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.hierarchyLevel) {\r\n                let argAggr = <FieldExprHierarchyLevelAggrPattern>fieldPattern.hierarchyLevel;\r\n                argAggr.aggregate = expr.func;\r\n                return { hierarchyLevelAggr: argAggr };\r\n            }\r\n\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let argAggr = <FieldExprEntityAggrPattern>sourcePattern.entity;\r\n                argAggr.aggregate = expr.func;\r\n\r\n                return { entityAggr: argAggr };\r\n            }\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): FieldExprPattern {\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let hierarchyRef = <FieldExprHierarchyPattern>(sourcePattern.entity);\r\n                hierarchyRef.name = expr.hierarchy;\r\n                return { hierarchy: hierarchyRef };\r\n            }\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): FieldExprPattern {\r\n            let hierarchySourceExprPattern: HierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\r\n            if (!hierarchySourceExprPattern)\r\n                return;\r\n\r\n            let hierarchyLevel: FieldExprHierarchyLevelPattern;\r\n            if (hierarchySourceExprPattern.hierarchy) {\r\n                hierarchyLevel = {\r\n                    entity: hierarchySourceExprPattern.hierarchy.entity,\r\n                    schema: hierarchySourceExprPattern.hierarchy.schema,\r\n                    name: hierarchySourceExprPattern.hierarchy.name,\r\n                    level: expr.level,\r\n                };\r\n            }\r\n\r\n            if (hierarchySourceExprPattern.variation) {\r\n                return {\r\n                    columnHierarchyLevelVariation: {\r\n                        source: {\r\n                            entity: hierarchySourceExprPattern.variation.column.entity,\r\n                            schema: hierarchySourceExprPattern.variation.column.schema,\r\n                            name: hierarchySourceExprPattern.variation.column.name,\r\n                        },\r\n                        level: hierarchyLevel,\r\n                        variationName: hierarchySourceExprPattern.variation.variationName,\r\n                    }\r\n                };\r\n            }\r\n\r\n            return { hierarchyLevel: hierarchyLevel };\r\n        }\r\n    }\r\n\r\n    class SourceExprPatternBuilder extends DefaultSQExprVisitor<SourceExprPattern> {\r\n        public static instance: SourceExprPatternBuilder = new SourceExprPatternBuilder();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SourceExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SourceExprPattern {\r\n            let entityExpr = <SQEntityExpr>expr.arg;\r\n\r\n            if (entityExpr instanceof SQEntityExpr) {\r\n                let propertyVariationSource: FieldExprColumnPattern = {\r\n                    schema: entityExpr.schema,\r\n                    entity: entityExpr.entity,\r\n                    name: expr.property,\r\n                };\r\n\r\n                if (entityExpr.variable)\r\n                    propertyVariationSource.entityVar = entityExpr.variable;\r\n\r\n                return {\r\n                    variation: {\r\n                        column: propertyVariationSource,\r\n                        variationName: expr.name,\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    class HierarchyExprPatternBuiler extends DefaultSQExprVisitor<HierarchySourceExprPattern> {\r\n        public static instance: HierarchyExprPatternBuiler = new HierarchyExprPatternBuiler();\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): HierarchySourceExprPattern {\r\n            let exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            let hierarchyRef: FieldExprHierarchyPattern;\r\n            let variationRef: FieldExprSourceVariationPattern;\r\n\r\n            if (exprPattern.variation) {\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.variation.column.schema,\r\n                    entity: exprPattern.variation.column.entity,\r\n                };\r\n                variationRef = exprPattern.variation;\r\n            }\r\n            else\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.entity.schema,\r\n                    entity: exprPattern.entity.entity,\r\n                };\r\n\r\n            return {\r\n                hierarchy: hierarchyRef,\r\n                variation: variationRef\r\n            };\r\n        }\r\n    }\r\n\r\n    export module FieldExprPattern {\r\n\r\n        export function visit<T>(expr: SQExpr | FieldExprPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let fieldExprPattern = expr instanceof SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\r\n            debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\r\n\r\n            if (fieldExprPattern.column)\r\n                return visitColumn(fieldExprPattern.column, visitor);\r\n            if (fieldExprPattern.columnAggr)\r\n                return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation)\r\n                return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\r\n            if (fieldExprPattern.entity)\r\n                return visitEntity(fieldExprPattern.entity, visitor);\r\n            if (fieldExprPattern.entityAggr)\r\n                return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\r\n            if (fieldExprPattern.hierarchy)\r\n                return visitHierarchy(fieldExprPattern.hierarchy, visitor);\r\n            if (fieldExprPattern.hierarchyLevel)\r\n                return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\r\n            if (fieldExprPattern.hierarchyLevelAggr)\r\n                return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\r\n            if (fieldExprPattern.measure)\r\n                return visitMeasure(fieldExprPattern.measure, visitor);\r\n                \r\n            debug.assertFail('failed to visit a fieldExprPattern.');\r\n            return;\r\n        }\r\n\r\n        function visitColumn<T>(column: FieldExprColumnPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(column, 'column');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumn(column);\r\n        }\r\n\r\n        function visitColumnAggr<T>(columnAggr: FieldExprColumnAggrPattern, visitor: IFieldExprPatternVisitor<T>): T{\r\n            debug.assertValue(columnAggr, 'columnAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnAggr(columnAggr);\r\n        }\r\n\r\n        function visitColumnHierarchyLevelVariation<T>(\r\n            columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern,\r\n            visitor: IFieldExprPatternVisitor<T>): T{\r\n\r\n            debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\r\n        }\r\n\r\n        function visitEntity<T>(entity: FieldExprEntityPattern, visitor: IFieldExprPatternVisitor<T>): T{\r\n            debug.assertValue(entity, 'entity');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntity(entity);\r\n        }\r\n        \r\n        function visitEntityAggr<T>(entityAggr: FieldExprEntityAggrPattern, visitor: IFieldExprPatternVisitor<T>): T{\r\n            debug.assertValue(entityAggr, 'entityAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntityAggr(entityAggr);\r\n        }\r\n\r\n        function visitHierarchy<T>(hierarchy: FieldExprHierarchyPattern, visitor: IFieldExprPatternVisitor<T>): T{\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchy(hierarchy);\r\n        }\r\n\r\n        function visitHierarchyLevel<T>(hierarchyLevel: FieldExprHierarchyLevelPattern, visitor: IFieldExprPatternVisitor<T>): T{\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevel(hierarchyLevel);\r\n        }\r\n\r\n        function visitHierarchyLevelAggr<T>(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern, visitor: IFieldExprPatternVisitor<T>): T{\r\n            debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\r\n        }\r\n\r\n        function visitMeasure<T>(measure: FieldExprMeasurePattern, visitor: IFieldExprPatternVisitor<T>): T{\r\n            debug.assertValue(measure, 'measure');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitMeasure(measure);\r\n        }\r\n\r\n        export function toColumnRefSQExpr(columnPattern: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return SQExprBuilder.columnRef(\r\n                SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar),\r\n                columnPattern.name);\r\n        }\r\n\r\n        export function getAggregate(fieldExpr: FieldExprPattern): QueryAggregateFunction {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n       \r\n            return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\r\n        }\r\n\r\n        export function hasFieldExprName(fieldExpr: FieldExprPattern): boolean {\r\n            return (fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.measure) !== undefined;\r\n        }\r\n\r\n        export function getPropertyName(fieldExpr: FieldExprPattern): string {\r\n            let column = (fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.measure);\r\n\r\n            if (column)\r\n                return column.name;\r\n        }\r\n\r\n        export function getHierarchyName(fieldExpr: FieldExprPattern): string {\r\n            let hierarchy = fieldExpr.hierarchy;\r\n            if (hierarchy)\r\n                return hierarchy.name;\r\n        }\r\n\r\n        export function getColumnRef(fieldExpr: FieldExprPattern): FieldExprPropertyPattern {\r\n            if (fieldExpr.columnHierarchyLevelVariation)\r\n                return fieldExpr.columnHierarchyLevelVariation.source;\r\n\r\n            return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\r\n        }\r\n\r\n        export function getFieldExprName(fieldExpr: FieldExprPattern): string {\r\n            let name = getPropertyName(fieldExpr);\r\n\r\n            if (name)\r\n                return name;\r\n\r\n            // In case it is an entity\r\n            return toFieldExprEntityPattern(fieldExpr).entity;\r\n        }\r\n\r\n        export function toFieldExprEntityPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        export function toFieldExprEntityItemPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        class FieldExprPatternAggregateVisitor implements IFieldExprPatternVisitor<QueryAggregateFunction> {\r\n            public static instance: FieldExprPatternAggregateVisitor = new FieldExprPatternAggregateVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): QueryAggregateFunction {\r\n                return columnAggr.aggregate;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): QueryAggregateFunction {\r\n                return entityAggr.aggregate;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): QueryAggregateFunction {\r\n                return hierarchyLevelAggr.aggregate;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n        }\r\n\r\n        class FieldExprToEntityExprPatternBuilder implements IFieldExprPatternVisitor<FieldExprEntityItemPattern> {\r\n            public static instance: FieldExprToEntityExprPatternBuilder = new FieldExprToEntityExprPatternBuilder();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\r\n            }\r\n\r\n            private static toEntityItemExprPattern(exprPattern: FieldExprEntityItemPattern): FieldExprEntityItemPattern {\r\n                debug.assertValue(exprPattern, 'exprPattern');\r\n\r\n                let pattern: FieldExprEntityItemPattern = { schema: exprPattern.schema, entity: exprPattern.entity };\r\n\r\n                if (exprPattern.entityVar) {\r\n                    pattern.entityVar = exprPattern.entityVar;\r\n                }\r\n\r\n                return pattern;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export module DataViewAnalysis {\r\n        import ArrayExtensions = jsCommon.ArrayExtensions;\r\n        import QueryProjectionsByRole = powerbi.data.QueryProjectionsByRole;\r\n        import DataViewObjectDescriptors = powerbi.data.DataViewObjectDescriptors;\r\n        import DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\r\n\r\n        export interface ValidateAndReshapeResult {\r\n            dataView?: DataView;\r\n            isValid: boolean;\r\n        }\r\n\r\n        export interface RoleKindByQueryRef {\r\n            [queryRef: string]: VisualDataRoleKind;\r\n        }\r\n\r\n        export interface DataViewMappingResult {\r\n            supportedMappings: DataViewMapping[];\r\n\r\n            /** A set of mapping errors if there are no supported mappings */\r\n            mappingErrors: DataViewMappingMatchError[];\r\n        }\r\n\r\n        export enum DataViewMappingMatchErrorCode {\r\n            conditionRangeTooLarge,\r\n            conditionRangeTooSmall,\r\n            conditionKindExpectedMeasure,\r\n            conditionKindExpectedGrouping,\r\n            conditionKindExpectedGroupingOrMeasure,\r\n        }\r\n\r\n        export interface DataViewMappingMatchError {\r\n            code: DataViewMappingMatchErrorCode;\r\n            roleName: string;\r\n            mappingIndex?: number;\r\n            conditionIndex?: number;\r\n        }\r\n\r\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\r\n        export function validateAndReshape(dataView: DataView, dataViewMappings: DataViewMapping[]): ValidateAndReshapeResult {\r\n            if (!dataViewMappings || dataViewMappings.length === 0)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            if (dataView) {\r\n                for (let dataViewMapping of dataViewMappings) {\r\n                    // Keep the original when possible.\r\n                    if (supports(dataView, dataViewMapping))\r\n                        return { dataView: dataView, isValid: true };\r\n\r\n                    if (dataViewMapping.categorical && dataView.categorical)\r\n                        return reshapeCategorical(dataView, dataViewMapping);\r\n\r\n                    if (dataViewMapping.tree && dataView.tree)\r\n                        return reshapeTree(dataView, dataViewMapping.tree);\r\n\r\n                    if (dataViewMapping.single && dataView.single)\r\n                        return reshapeSingle(dataView, dataViewMapping.single);\r\n\r\n                    if (dataViewMapping.table && dataView.table)\r\n                        return reshapeTable(dataView, dataViewMapping.table);\r\n                }\r\n            }\r\n            else if (ScriptResultUtil.findScriptResult(dataViewMappings)) {\r\n                // Currently, PBI Service treats R Script Visuals as static images.\r\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\r\n                // to support the PBI Desktop scenario.\r\n                // This code will be removed once PBI Service fully supports R Script Visuals.\r\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\r\n                return { dataView: dataView, isValid: true };\r\n            }\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeCategorical(dataView: DataView, dataViewMapping: DataViewMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\r\n\r\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\r\n            let categoryRoleMapping = dataViewMapping.categorical;\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return { isValid: false };\r\n\r\n            let rowCount;\r\n            if (categoryRoleMapping.rowCount) {\r\n                rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (rowCount && rowCount.max) {\r\n                    let updated: DataViewCategorical;\r\n                    let categories = categorical.categories;\r\n                    let maxRowCount = rowCount.max;\r\n                    let originalLength = undefined;\r\n                    if (categories) {\r\n                        for (let i = 0, len = categories.length; i < len; i++) {\r\n                            let category = categories[i];\r\n                            originalLength = category.values.length;\r\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n\r\n                                // Row count too large: Trim it to fit.\r\n                                let updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\r\n\r\n                                updated = updated || { categories: [] };\r\n                                updated.categories.push({\r\n                                    source: category.source,\r\n                                    values: updatedCategories\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\r\n                        if (!originalLength)\r\n                            originalLength = categorical.values[0].values.length;\r\n\r\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n                            updated = updated || {};\r\n                            updated.values = data.DataViewTransform.createValueColumns();\r\n\r\n                            for (let i = 0, len = categorical.values.length; i < len; i++) {\r\n                                let column = categorical.values[i],\r\n                                    updatedColumn: DataViewValueColumn = {\r\n                                        source: column.source,\r\n                                        values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\r\n                                    };\r\n\r\n                                if (column.min !== undefined)\r\n                                    updatedColumn.min = column.min;\r\n                                if (column.max !== undefined)\r\n                                    updatedColumn.max = column.max;\r\n                                if (column.subtotal !== undefined)\r\n                                    updatedColumn.subtotal = column.subtotal;\r\n\r\n                                updated.values.push(updatedColumn);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (updated) {\r\n                        dataView = {\r\n                            metadata: dataView.metadata,\r\n                            categorical: updated,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (supportsCategorical(dataView, dataViewMapping))\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return null;\r\n        }\r\n\r\n        function reshapeSingle(dataView: DataView, singleRoleMapping: DataViewSingleMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (dataView.single)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            // TODO: Need to implement the reshaping of Tree\r\n            let metadata = dataView.metadata;\r\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTable(dataView: DataView, tableRoleMapping: DataViewTableMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (dataView.table)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        export function countGroups(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (!columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        export function countMeasures(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        /** Indicates whether the dataView conforms to the specified schema. */\r\n        export function supports(dataView: DataView, roleMapping: DataViewMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            if (!roleMapping || !dataView)\r\n                return false;\r\n\r\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\r\n                return false;\r\n\r\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\r\n                return false;\r\n\r\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\r\n                return false;\r\n\r\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsCategorical(dataView: DataView, categoryRoleMapping: DataViewCategoricalMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return false;\r\n\r\n            // TODO: Disabling this implementation isn't right.\r\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\r\n            //    return false;\r\n\r\n            if (categoryRoleMapping.rowCount) {\r\n                let rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\r\n                    rowCount = categoryRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\r\n                        len = dataViewCategorical.values[0].values.length;\r\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\r\n                        len = dataViewCategorical.categories[0].values.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsSingle(dataViewSingle: DataViewSingle, singleRoleMapping: DataViewSingleMapping): boolean {\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (!dataViewSingle)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): boolean {\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            let metadata = dataView.metadata;\r\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\r\n        }\r\n\r\n        function supportsTable(dataViewTable: DataViewTable, tableRoleMapping: DataViewTableMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (!dataViewTable)\r\n                return false;\r\n\r\n            if (tableRoleMapping.rowCount) {\r\n                let rowCount = tableRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\r\n                    rowCount = tableRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewTable.rows && dataViewTable.rows.length)\r\n                        len = dataViewTable.rows.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsScriptResult(dataView: DataViewScriptResultData, scriptResultRoleMapping: DataViewScriptResultMapping): boolean {\r\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\r\n\r\n            if (!dataView)\r\n                return false;\r\n\r\n            if (!dataView.imageBase64)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the range in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        export function validateRange(value: number, roleCondition: RoleCondition, ignoreMin?: boolean): DataViewMappingMatchErrorCode {\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (!roleCondition)\r\n                return;\r\n\r\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\r\n\r\n            if (roleCondition.max !== undefined && roleCondition.max < value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        function validateKind(roleCondition: RoleCondition, roleName: string, projections: QueryProjectionsByRole, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchErrorCode {\r\n            if (!roleCondition || roleCondition.kind === undefined) {\r\n                return;\r\n            }\r\n            let expectedKind = roleCondition.kind;\r\n            let roleCollection = projections[roleName];\r\n            if (roleCollection) {\r\n                let roleProjections = roleCollection.all();\r\n                for (let roleProjection of roleProjections) {\r\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\r\n                        switch (expectedKind) {\r\n                            case VisualDataRoleKind.Measure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\r\n                            case VisualDataRoleKind.Grouping:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\r\n                            case VisualDataRoleKind.GroupingOrMeasure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Determines the appropriate DataViewMappings for the projections. */\r\n        export function chooseDataViewMappings(\r\n            projections: QueryProjectionsByRole,\r\n            mappings: DataViewMapping[],\r\n            roleKindByQueryRef: RoleKindByQueryRef,\r\n            objectDescriptors?: DataViewObjectDescriptors,\r\n            objectDefinitions?: DataViewObjectDefinitions): DataViewMappingResult {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertAnyValue(mappings, 'mappings');\r\n\r\n            let supportedMappings: DataViewMapping[] = [];\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            if (!_.isEmpty(mappings)) {\r\n                for (let mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\r\n                    let mapping = mappings[mappingIndex],\r\n                        mappingConditions = mapping.conditions,\r\n                        requiredProperties = mapping.requiredProperties;\r\n                    let allPropertiesValid: boolean = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\r\n                    let conditionsMet: DataViewMappingCondition[] = [];\r\n\r\n                    if (!_.isEmpty(mappingConditions)) {\r\n                        for (let conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\r\n                            let condition = mappingConditions[conditionIndex];\r\n                            let currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\r\n                            if (!_.isEmpty(currentConditionErrors)) {\r\n                                for (let error of currentConditionErrors) {\r\n                                    error.mappingIndex = mappingIndex;\r\n                                    error.conditionIndex = conditionIndex;\r\n                                    errors.push(error);\r\n                                }\r\n                            }\r\n                            else\r\n                                conditionsMet.push(condition);\r\n                        }\r\n                    }\r\n                    else {\r\n                        conditionsMet.push({});\r\n                    }\r\n\r\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\r\n                        let supportedMapping = _.cloneDeep(mapping);\r\n\r\n                        let updatedConditions = _.filter(conditionsMet, (condition) => Object.keys(condition).length > 0);\r\n                        if (!_.isEmpty(updatedConditions))\r\n                            supportedMapping.conditions = updatedConditions;\r\n                        supportedMappings.push(supportedMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\r\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\r\n            };\r\n        }\r\n\r\n        function checkForConditionErrors(projections: QueryProjectionsByRole, condition: DataViewMappingCondition, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchError[] {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertValue(condition, 'condition');\r\n\r\n            let conditionRoles = Object.keys(condition);\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            for (let i = 0, len = conditionRoles.length; i < len; i++) {\r\n                let roleName: string = conditionRoles[i],\r\n                    isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs),\r\n                    roleCondition = condition[roleName];\r\n\r\n                let roleCount = getPropertyCount(roleName, projections, isDrillable);\r\n                let rangeError = validateRange(roleCount, roleCondition);\r\n                if (rangeError != null) {\r\n                    errors.push({\r\n                        code: rangeError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n                let kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\r\n                if (kindError != null) {\r\n                    errors.push({\r\n                        code: kindError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return errors;\r\n        }\r\n\r\n        function areAllPropertiesValid(requiredProperties: DataViewObjectPropertyIdentifier[], objectDescriptors: DataViewObjectDescriptors, objectDefinitions?: DataViewObjectDefinitions): boolean {\r\n            if (_.isEmpty(requiredProperties))\r\n                return true;\r\n\r\n            if (!objectDescriptors || !objectDefinitions)\r\n                return false;\r\n\r\n            let staticEvalContext: data.IEvalContext = data.createStaticEvalContext();\r\n\r\n            return _.every(requiredProperties, (requiredProperty) => {\r\n                let objectDescriptorValue = null;\r\n                let objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\r\n                if (objectDescriptorProperty)\r\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\r\n                let objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\r\n\r\n                if (!objectDescriptorValue || !objectDefinitionValue)\r\n                    return false;\r\n\r\n                return data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\r\n            });\r\n        }\r\n\r\n        export function getPropertyCount(roleName: string, projections: QueryProjectionsByRole, useActiveIfAvailable?: boolean): number {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(projections, 'projections');\r\n\r\n            let projectionsForRole = projections[roleName];\r\n            if (projectionsForRole) {\r\n                if (useActiveIfAvailable)\r\n                    return 1;\r\n                return projectionsForRole.all().length;\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function hasSameCategoryIdentity(dataView1: DataView, dataView2: DataView): boolean {\r\n            if (dataView1\r\n                && dataView2\r\n                && dataView1.categorical\r\n                && dataView2.categorical) {\r\n                let dv1Categories = dataView1.categorical.categories;\r\n                let dv2Categories = dataView2.categorical.categories;\r\n                if (dv1Categories\r\n                    && dv2Categories\r\n                    && dv1Categories.length === dv2Categories.length) {\r\n                    for (let i = 0, len = dv1Categories.length; i < len; i++) {\r\n                        let dv1Identity = dv1Categories[i].identity;\r\n                        let dv2Identity = dv2Categories[i].identity;\r\n\r\n                        let dv1Length = getLengthOptional(dv1Identity);\r\n                        if (dv1Length !== getLengthOptional(dv2Identity))\r\n                            return false;\r\n\r\n                        for (let j = 0; j < dv1Length; j++) {\r\n                            if (!DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\r\n                                return false;\r\n                        }\r\n                    }\r\n\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function getLengthOptional(identity: DataViewScopeIdentity[]): number {\r\n            if (identity)\r\n                return identity.length;\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function areMetadataColumnsEquivalent(column1: DataViewMetadataColumn, column2: DataViewMetadataColumn): boolean {\r\n            if (!column1 && !column2)\r\n                return true;\r\n\r\n            if (!column1 || !column2)\r\n                return false;\r\n\r\n            if (column1.displayName !== column2.displayName)\r\n                return false;\r\n\r\n            if (column1.queryName !== column2.queryName)\r\n                return false;\r\n\r\n            if (column1.isMeasure !== column2.isMeasure)\r\n                return false;\r\n\r\n            if (column1.type !== column2.type)\r\n                return false;\r\n\r\n            if (column1.sort !== column2.sort)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\r\n        export function isMetadataEquivalent(metadata1: DataViewMetadata, metadata2: DataViewMetadata): boolean {\r\n            if (!metadata1 && !metadata2)\r\n                return true;\r\n\r\n            if (!metadata1 || !metadata2)\r\n                return false;\r\n\r\n            let previousColumnsLength = metadata1.columns.length;\r\n            let newColumnsLength = metadata2.columns.length;\r\n\r\n            if (previousColumnsLength !== newColumnsLength)\r\n                return false;\r\n\r\n            for (let i: number = 0; i < newColumnsLength; i++) {\r\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewRoleWildcard {\r\n        export function fromRoles(roles: string[]): DataViewRoleWildcard {\r\n            return new DataViewRoleWildcardImpl(roles);\r\n        }\r\n\r\n        export function equals(firstRoleWildcard: DataViewRoleWildcard, secondRoleWildcard: DataViewRoleWildcard): boolean {\r\n            return firstRoleWildcard.key &&\r\n                secondRoleWildcard.key &&\r\n                firstRoleWildcard.key === secondRoleWildcard.key &&\r\n                ArrayExtensions.sequenceEqual<string>(\r\n                    firstRoleWildcard.roles,\r\n                    secondRoleWildcard.roles,\r\n                    (role1: string, role2: string) => role1 === role2);\r\n        }\r\n\r\n        class DataViewRoleWildcardImpl implements DataViewRoleWildcard {\r\n            private _roles: string[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(roles: string[]) {\r\n                debug.assertNonEmpty(roles, 'roles');\r\n\r\n                this._roles = roles;\r\n                this._key = new Lazy<string>(() => JSON.stringify(this.roles));\r\n            }\r\n\r\n            public get roles(): string[] {\r\n                return this._roles;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewScopeIdentity {\r\n        /** Compares the two DataViewScopeIdentity values for equality. */\r\n        export function equals(x: DataViewScopeIdentity, y: DataViewScopeIdentity, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            return data.SQExpr.equals(<data.SQExpr>x.expr, <data.SQExpr>y.expr, ignoreCase);\r\n        }\r\n\r\n        export function filterFromIdentity(identities: DataViewScopeIdentity[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(identities))\r\n                return;\r\n            \r\n            let exprs: data.SQExpr[] = [];\r\n            for (let identity of identities) {\r\n                exprs.push(<data.SQExpr>identity.expr);\r\n            }\r\n\r\n            return filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function filterFromExprs(orExprs: data.SQExpr[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(orExprs))\r\n                return;\r\n\r\n            let resultExpr: data.SQExpr;\r\n            for (let orExpr of orExprs) {\r\n                let inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\r\n                if (resultExpr)\r\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\r\n                else\r\n                    resultExpr = inExpr || orExpr;\r\n            }\r\n            \r\n            if (resultExpr) {\r\n                if (isNot)\r\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\r\n            }\r\n\r\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\r\n        }\r\n    }\r\n\r\n    export module data {\r\n        import Lazy = jsCommon.Lazy;\r\n\r\n        export function createDataViewScopeIdentity(expr: SQExpr): DataViewScopeIdentity {\r\n            return new DataViewScopeIdentityImpl(expr);\r\n        }\r\n\r\n        class DataViewScopeIdentityImpl implements DataViewScopeIdentity {\r\n            private _expr: SQExpr;\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(expr: SQExpr) {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                this._expr = expr;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serialize(expr));\r\n            }\r\n\r\n            public get expr(): SQExpr {\r\n                return this._expr;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewScopeWildcard {\r\n        export function matches(wildcard: DataViewScopeWildcard, instance: DataViewScopeIdentity): boolean {\r\n            let instanceExprs = ScopeIdentityExtractor.getKeys(<SQExpr>instance.expr);\r\n            if (!instanceExprs)\r\n                return false;\r\n\r\n            return SQExprUtils.sequenceEqual(<SQExpr[]>wildcard.exprs, instanceExprs);\r\n        }\r\n\r\n        export function equals(firstScopeWildcard: DataViewScopeWildcard, secondScopeWildcard: DataViewScopeWildcard): boolean {\r\n            return firstScopeWildcard.key === secondScopeWildcard.key &&\r\n                SQExprUtils.sequenceEqual(<SQExpr[]>firstScopeWildcard.exprs, <SQExpr[]>secondScopeWildcard.exprs);\r\n        }\r\n\r\n        export function fromExprs(exprs: SQExpr[]): DataViewScopeWildcard {\r\n            return new DataViewScopeWildcardImpl(exprs);\r\n        }\r\n\r\n        class DataViewScopeWildcardImpl implements DataViewScopeWildcard {\r\n            private _exprs: SQExpr[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(exprs: SQExpr[]) {\r\n                debug.assertValue(exprs, 'exprs');\r\n\r\n                this._exprs = exprs;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serializeArray(exprs));\r\n            }\r\n\r\n            public get exprs(): SQExpr[] {\r\n                return this._exprs;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface IColorAllocatorCache {\r\n        get(key: SQFillRuleExpr): IColorAllocator;\r\n        register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this;\r\n    }\r\n\r\n    export function createColorAllocatorCache(): IColorAllocatorCache {\r\n        return new ColorAllocatorProvider();\r\n    }\r\n\r\n    interface ColorAllocatorCacheEntry {\r\n        key: SQFillRuleExpr;\r\n        allocator: IColorAllocator;\r\n    }\r\n\r\n    class ColorAllocatorProvider implements IColorAllocatorCache {\r\n        private cache: ColorAllocatorCacheEntry[];\r\n\r\n        constructor() {\r\n            this.cache = [];\r\n        }\r\n\r\n        public get(key: SQFillRuleExpr): IColorAllocator {\r\n            debug.assertValue(key, 'key');\r\n\r\n            for (let entry of this.cache) {\r\n                if (entry.key === key)\r\n                    return entry.allocator;\r\n            }\r\n        }\r\n\r\n        public register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this {\r\n            debug.assertValue(key, 'key');\r\n            debug.assertValue(colorAllocator, 'colorAllocator');\r\n            debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\r\n\r\n            this.cache.push({\r\n                key: key,\r\n                allocator: colorAllocator,\r\n            });\r\n\r\n            return this;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewRegressionRunOptions {\r\n        dataViewMappings: DataViewMapping[];\r\n        visualDataViews: DataView[];\r\n        dataRoles: VisualDataRole[];\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        objectDefinitions: DataViewObjectDefinitions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        transformSelects: DataViewSelectTransform[];\r\n        metadata: DataViewMetadata;\r\n        projectionActiveItems: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export module DataViewRegression {\r\n        // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\r\n        // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\r\n        const regressionXQueryName: string = 'RegressionX';\r\n        const regressionSeriesQueryName: string = 'RegressionSeries';\r\n        export const regressionYQueryName: string = 'RegressionY';\r\n\r\n        export function run(options: DataViewRegressionRunOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let dataViewMappings: DataViewMapping[] = options.dataViewMappings;\r\n            let visualDataViews: DataView[] = options.visualDataViews;\r\n            let dataRoles: VisualDataRole[] = options.dataRoles;\r\n            let objectDescriptors: DataViewObjectDescriptors = options.objectDescriptors;\r\n            let objectDefinitions: DataViewObjectDefinitions = options.objectDefinitions;\r\n            let colorAllocatorFactory: IColorAllocatorFactory = options.colorAllocatorFactory;\r\n            let transformSelects: DataViewSelectTransform[] = options.transformSelects;\r\n            let projectionActiveItems = options.projectionActiveItems;\r\n            let metadata: DataViewMetadata = options.metadata;\r\n\r\n            if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\r\n                // compute linear regression line if applicable\r\n                let roleKindByQueryRef: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\r\n                let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\r\n                if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\r\n                    return visualDataViews;\r\n\r\n                let applicableDataViewMappings: DataViewMapping[] = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\r\n\r\n                if (applicableDataViewMappings) {\r\n                    let regressionDataViewMapping: DataViewMapping = _.find(applicableDataViewMappings, (dataViewMapping) => {\r\n                        return dataViewMapping.usage && dataViewMapping.usage.regression;\r\n                    });\r\n\r\n                    if (regressionDataViewMapping) {\r\n                        let regressionDataViews: DataView[] = [];\r\n                        for (let visualDataView of visualDataViews) {\r\n                            let regressionDataView: DataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\r\n\r\n                            if (regressionDataView)\r\n                                regressionDataViews.push(regressionDataView);\r\n                        }\r\n\r\n                        if (!_.isEmpty(regressionDataViews))\r\n                            visualDataViews.push(...regressionDataViews);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        /**\r\n         * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\r\n         * It works on scalar axis only.\r\n         * The algorithm is as follows\r\n         *\r\n         * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\r\n         * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\r\n         * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\r\n         * If highlights values are present, repeat steps 2 & 3 using highlight values.\r\n         * 4. Create the new dataView using the points computed above\r\n         */\r\n        export function linearRegressionTransform(\r\n            sourceDataView: DataView,\r\n            dataRoles: VisualDataRole[],\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\r\n            debug.assertValue(dataRoles, 'dataRoles');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!sourceDataView.categorical)\r\n                return;\r\n\r\n            // Step 1\r\n            let xColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.X, sourceDataView.categorical, dataRoles);\r\n            let yColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.Y, sourceDataView.categorical, dataRoles);\r\n\r\n            if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\r\n                return;\r\n\r\n            let xColumnSource = xColumns[0].source;\r\n            let yColumnSource = yColumns[0].source;\r\n\r\n            let combineSeries = true;\r\n            if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\r\n                let regressionUsage = regressionDataViewMapping.usage.regression;\r\n\r\n                let combineSeriesPropertyId = regressionUsage['combineSeries'];\r\n                if (combineSeriesPropertyId) {\r\n                    combineSeries = DataViewObjects.getValue<boolean>(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\r\n                }\r\n            }\r\n\r\n            // Step 2\r\n            let dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\r\n            let lineDefSet = calculateLineDefinitions(dataPointsBySeries);\r\n            let xMin = lineDefSet.xMin;\r\n            let xMax = lineDefSet.xMax;\r\n\r\n            let shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\r\n            let highlightsLineDefSet: LineDefinitionSet;\r\n            if (shouldComputeHightlights) {\r\n                let highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\r\n                highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\r\n                if (highlightsLineDefSet) {\r\n                    xMin = _.min([xMin, highlightsLineDefSet.xMin]);\r\n                    xMax = _.max([xMax, highlightsLineDefSet.xMax]);\r\n                }\r\n                else {\r\n                    shouldComputeHightlights = false;\r\n                }\r\n            }\r\n\r\n            // Step 3\r\n            let valuesByTrend: number[][] = [];\r\n            for (let trend of lineDefSet.lineDefs) {\r\n                valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n            }\r\n\r\n            let highlightsByTrend: number[][];\r\n            if (shouldComputeHightlights) {\r\n                highlightsByTrend = [];\r\n                for (let trend of highlightsLineDefSet.lineDefs) {\r\n                    highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n                }\r\n            }\r\n\r\n            // Step 4\r\n            let groupValues: PrimitiveValue[];\r\n            if (combineSeries) {\r\n                groupValues = ['combinedRegressionSeries'];\r\n            }\r\n            else {\r\n                // If we are producing a trend line per series we need to maintain the group identities so that we can map between the \r\n                // trend line and the original series (to match the color for example).\r\n                if (sourceDataView.categorical.values.source) {\r\n                    // Source data view has dynamic series.\r\n                    let groups = sourceDataView.categorical.values.grouped();\r\n                    groupValues = _.map(groups, (group) => group.name);\r\n                }\r\n                else {\r\n                    // Source data view has static or no series.\r\n                    groupValues = _.map(yColumns, (column) => column.source.queryName);\r\n                }\r\n            }\r\n\r\n            // Step 5\r\n            let regressionDataView: DataView = createRegressionDataView(\r\n                xColumnSource,\r\n                yColumnSource,\r\n                groupValues,\r\n                [xMin, xMax],\r\n                valuesByTrend,\r\n                highlightsByTrend,\r\n                sourceDataView,\r\n                regressionDataViewMapping,\r\n                objectDescriptors,\r\n                objectDefinitions,\r\n                colorAllocatorFactory);\r\n\r\n            return regressionDataView;\r\n        }\r\n\r\n        function calculateLineDefinitions(dataPointsBySeries: DataPointSet[]): LineDefinitionSet {\r\n            let xMin: PrimitiveValue;\r\n            let xMax: PrimitiveValue;\r\n            let lineDefs: LineDefinition[] = [];\r\n            for (let dataPointSet of dataPointsBySeries) {\r\n                let unsortedXValues: PrimitiveValue[] = dataPointSet.xValues;\r\n                let unsortedYValues: PrimitiveValue[] = dataPointSet.yValues;\r\n\r\n                if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\r\n                    return;\r\n\r\n                // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\r\n                let xDataType: string = getDataType(unsortedXValues);\r\n                if (!xDataType)\r\n                    return;\r\n                let yDataType: string = getDataType(unsortedYValues);\r\n                if (!yDataType)\r\n                    return;\r\n\r\n                let sortedDataPointSet: DataPointSet = sortValues(unsortedXValues, unsortedYValues);\r\n                let minCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[0];\r\n                let maxCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\r\n\r\n                let lineDef: LineDefinition = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\r\n\r\n                xMin = _.min([xMin, minCategoryValue]);\r\n                xMax = _.max([xMax, maxCategoryValue]);\r\n\r\n                lineDefs.push(lineDef);\r\n            }\r\n\r\n            return {\r\n                lineDefs: lineDefs,\r\n                xMin: xMin,\r\n                xMax: xMax,\r\n            };\r\n        }\r\n\r\n        function getColumnsForCartesianRoleKind(roleKind: CartesianRoleKind, categorical: DataViewCategorical, roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            debug.assertValue(roleKind, 'roleKind');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n\r\n            let categories = categorical.categories;\r\n            if (_.isEmpty(categories))\r\n                return;\r\n\r\n            debug.assert(categories.length === 1, 'composite category columns not supported');\r\n            let categoryColumn = categories[0];\r\n            columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n        }\r\n\r\n        function getColumnsWithRoleKind(roleKind: CartesianRoleKind, columns: DataViewCategoricalColumn[], roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            if (_.isEmpty(columns))\r\n                return;\r\n\r\n            return _.filter(columns, (column) => {\r\n                for (let roleName in column.source.roles) {\r\n                    if (!column.source.roles[roleName])\r\n                        continue;\r\n\r\n                    let role = _.find(roles, (role) => role.name === roleName);\r\n                    if (role && role.cartesianKind === roleKind)\r\n                        return true;\r\n                }\r\n\r\n                return false;\r\n            });\r\n        }\r\n\r\n        function getDataType(values: PrimitiveValue[]): string {\r\n            let firstNonNull: PrimitiveValue = _.find(values, (value) => value != null);\r\n            if (firstNonNull == null)\r\n                return;\r\n\r\n            let dataType: string = typeof firstNonNull;\r\n\r\n            if (_.some(values, (value) => value != null && typeof value !== dataType))\r\n                return;\r\n\r\n            return dataType;\r\n        }\r\n\r\n        function sortValues(unsortedXValues: PrimitiveValue[], unsortedYValues: PrimitiveValue[]): DataPointSet {\r\n            debug.assertValue(unsortedXValues, 'unsortedXValues');\r\n            debug.assertValue(unsortedYValues, 'unsortedYValues');\r\n\r\n            let zippedValues = _.zip(unsortedXValues, unsortedYValues);\r\n            let [xValues, yValues] = _.chain(zippedValues)\r\n                .filter((valuePair) => valuePair[0] != null && valuePair[1] != null)\r\n                .sortBy((valuePair) => valuePair[0])\r\n                .unzip()\r\n                .value();\r\n\r\n            return {\r\n                xValues: xValues,\r\n                yValues: yValues\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Computes a line definition using linear regression.\r\n         *   xBar: average of X values, yBar: average of Y values\r\n         *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\r\n         *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\r\n         *   Slope: ssXY / ssXX\r\n         *   Intercept: yBar - xBar * slope\r\n         */\r\n        function computeRegressionLine(xValues: number[], yValues: number[]): LineDefinition {\r\n            debug.assertValue(xValues, 'xValues');\r\n            debug.assertValue(yValues, 'yValues');\r\n\r\n            let xBar = _.sum(xValues) / xValues.length;\r\n            let yBar = _.sum(yValues) / yValues.length;\r\n\r\n            let ssXX = _.chain(xValues)\r\n                .map((x) => {\r\n                    return (x - xBar) ** 2;\r\n                })\r\n                .sum();\r\n\r\n            let ssXY = _.chain(xValues)\r\n                .map((x, i) => {\r\n                    return (x - xBar) * (yValues[i] - yBar);\r\n                })\r\n                .sum();\r\n\r\n            let slope = ssXY / ssXX;\r\n            let intercept = yBar - (xBar * slope);\r\n\r\n            return {\r\n                slope: slope,\r\n                intercept: intercept\r\n            };\r\n        }\r\n\r\n        function computeLineYValues(lineDef: LineDefinition, x1: number, x2: number): number[] {\r\n            return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\r\n        }\r\n\r\n        function getValuesFromColumn(column: DataViewCategoricalColumn, preferHighlights: boolean): PrimitiveValue[] {\r\n            if (preferHighlights) {\r\n                // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                if (valueColumn.highlights) {\r\n                    return valueColumn.highlights;\r\n                }\r\n            }\r\n\r\n            return column.values;\r\n        }\r\n\r\n        function getDataPointsBySeries(xColumns: DataViewCategoricalColumn[], yColumns: DataViewCategoricalColumn[], combineSeries: boolean, preferHighlights: boolean): DataPointSet[] {\r\n            let dataPointsBySeries: DataPointSet[] = [];\r\n            let xValueArray: PrimitiveValue[][] = _.map(xColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n            let seriesYValues: PrimitiveValue[][] = _.map(yColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n\r\n            let multipleXValueColumns: boolean = xColumns.length > 1;\r\n            for (let i = 0; i < seriesYValues.length; i++) {\r\n                let xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\r\n                let yValues = seriesYValues[i];\r\n\r\n                if (combineSeries && dataPointsBySeries.length > 0) {\r\n                    dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\r\n                    dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\r\n                }\r\n                else {\r\n                    dataPointsBySeries.push({\r\n                        xValues: xValues,\r\n                        yValues: yValues,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return dataPointsBySeries;\r\n        }\r\n\r\n        function createRegressionDataView(\r\n            xColumnSource: DataViewMetadataColumn,\r\n            yColumnSource: DataViewMetadataColumn,\r\n            groupValues: PrimitiveValue[],\r\n            categories: PrimitiveValue[],\r\n            values: PrimitiveValue[][],\r\n            highlights: PrimitiveValue[][],\r\n            sourceDataView: DataView,\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(xColumnSource, 'xColumnSource');\r\n            debug.assertValue(yColumnSource, 'yColumnSource');\r\n            debug.assertValue(categories, 'categories');\r\n            debug.assertValue(values, 'values');\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertAnyValue(highlights, 'highlights');\r\n            debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\r\n\r\n            let xRole: string = (<DataViewRoleForMapping>regressionDataViewMapping.categorical.categories).for.in;\r\n            let grouped = (<DataViewGroupedRoleMapping>regressionDataViewMapping.categorical.values).group;\r\n            let yRole: string;\r\n            let seriesRole: string;\r\n            if (grouped && !_.isEmpty(grouped.select)) {\r\n                yRole = (<DataViewRoleForMapping>grouped.select[0]).for ?\r\n                    (<DataViewRoleForMapping>grouped.select[0]).for.in :\r\n                    (<DataViewRoleBindMapping>grouped.select[0]).bind.to;\r\n                seriesRole = grouped.by;\r\n            }\r\n            if (!yRole || !seriesRole)\r\n                return;\r\n\r\n            let categoricalRoles: { [name: string]: boolean } = {[xRole]: true};\r\n            let valueRoles: { [name: string]: boolean } = {[yRole]: true};\r\n            let seriesRoles: { [name: string]: boolean } = {[seriesRole]: true};\r\n\r\n            let valuesBySeries: DataViewBuilderSeriesData[][] = [];\r\n            for (let index in values) {\r\n                let seriesData: DataViewBuilderSeriesData = {\r\n                    values: values[index],\r\n                };\r\n\r\n                if (highlights)\r\n                    seriesData.highlights = highlights[index];\r\n\r\n                valuesBySeries.push([seriesData]);\r\n            }\r\n\r\n            let regressionDataView: DataView = createCategoricalDataViewBuilder()\r\n                .withCategory({\r\n                    source: {\r\n                        displayName: xColumnSource.displayName,\r\n                        queryName: regressionXQueryName,\r\n                        type: xColumnSource.type,\r\n                        isMeasure: false,\r\n                        roles: categoricalRoles\r\n                    },\r\n                    values: categories,\r\n                    identityFrom: {\r\n                        fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\r\n                    },\r\n                })\r\n                .withGroupedValues({\r\n                    groupColumn: {\r\n                        source: {\r\n                            displayName: yColumnSource.displayName + 'Regression',\r\n                            queryName: regressionSeriesQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: seriesRoles\r\n                        },\r\n                        values: groupValues,\r\n                        identityFrom: {\r\n                            fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\r\n                        }\r\n                    },\r\n                    valueColumns: [{\r\n                        source: {\r\n                            displayName: yColumnSource.displayName,\r\n                            queryName: regressionYQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: valueRoles\r\n                        },\r\n                    }],\r\n                    data: valuesBySeries\r\n                })\r\n                .build();\r\n            DataViewTransform.transformObjects(regressionDataView, data.StandardDataViewKinds.Categorical, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\r\n            return regressionDataView;\r\n        }\r\n\r\n        function hasHighlightValues(columns: DataViewCategoricalColumn[]): boolean {\r\n            return _.any(columns, (column) => {\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                return valueColumn.highlights != null;\r\n            });\r\n        }\r\n    }\r\n\r\n    interface DataPointSet {\r\n        xValues: any[];\r\n        yValues: any[];\r\n    }\r\n\r\n    interface LineDefinition {\r\n        slope: number;\r\n        intercept: number;\r\n    }\r\n\r\n    interface LineDefinitionSet {\r\n        lineDefs: LineDefinition[];\r\n        xMin: PrimitiveValue;\r\n        xMax: PrimitiveValue;\r\n    }\r\n}\r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewSelectTransform {\r\n        displayName?: string;\r\n        queryName?: string;\r\n        format?: string;\r\n        type?: ValueType;\r\n        roles?: { [roleName: string]: boolean };\r\n        kpi?: DataViewKpiColumnMetadata;\r\n        sort?: SortDirection;\r\n        expr?: SQExpr;\r\n        discourageAggregationAcrossGroups?: boolean;\r\n\r\n        /** Describes the default value applied to a column, if any. */\r\n        defaultValue?: DefaultValueDefinition;\r\n    }\r\n\r\n    export module DataViewSelectTransform {\r\n        /** Convert selection info to projections */\r\n        export function projectionsFromSelects(selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): QueryProjectionsByRole {\r\n            debug.assertAnyValue(selects, \"selects\");\r\n            debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\r\n\r\n            let projections: QueryProjectionsByRole = {};\r\n            for (let select of selects) {\r\n                let roles = select.roles;\r\n                if (!roles)\r\n                    continue;\r\n\r\n                for (let roleName in roles) {\r\n                    if (roles[roleName]) {\r\n                        let qp = projections[roleName];\r\n                        if (!qp)\r\n                            qp = projections[roleName] = new QueryProjectionCollection([]);\r\n                        qp.all().push({ queryRef: select.queryName });\r\n\r\n                        if (projectionActiveItems && projectionActiveItems[roleName])\r\n                            qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], (activeItem: DataViewProjectionActiveItemInfo) => activeItem.queryRef);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return projections;\r\n        }\r\n\r\n        /** Use selections and metadata to fashion query role kinds */\r\n        export function createRoleKindFromMetadata(selects: DataViewSelectTransform[], metadata: DataViewMetadata): RoleKindByQueryRef {\r\n            let roleKindByQueryRef: DataViewAnalysis.RoleKindByQueryRef = {};\r\n            for (let column of metadata.columns) {\r\n                if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\r\n                    continue;\r\n\r\n                let select = selects[column.index];\r\n                if (select) {\r\n                    let queryRef = select.queryName;\r\n                    if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\r\n                        roleKindByQueryRef[queryRef] = column.isMeasure ? VisualDataRoleKind.Measure : VisualDataRoleKind.Grouping;\r\n                    }\r\n                }\r\n            }\r\n            return roleKindByQueryRef;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface ICategoricalEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createCategoricalEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewCategorical: DataViewCategorical): ICategoricalEvalContext {\r\n        return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\r\n    }\r\n\r\n    class CategoricalEvalContext implements ICategoricalEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewCategorical;\r\n        private columnsByRole: { [name: string]: DataViewCategoricalColumn };\r\n        private index: number;\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewCategorical) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.columnsByRole = {};\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            let columnsByRole = this.columnsByRole;\r\n            let column = columnsByRole[roleName];\r\n            if (!column)\r\n                column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\r\n            \r\n            if (!column)\r\n                return;\r\n\r\n            let index = this.index;\r\n            if (index != null)\r\n                return column.values[this.index];\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.index = index;\r\n        }\r\n    }\r\n\r\n    function findRuleInputColumn(dataViewCategorical: DataViewCategorical, inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n\r\n        return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\r\n            findRuleInputInColumns(dataViewCategorical.categories, inputRole);\r\n    }\r\n\r\n    function findRuleInputInColumns(columns: DataViewCategoricalColumn[], inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertAnyValue(columns, 'columns');\r\n\r\n        if (!columns)\r\n            return;\r\n\r\n        for (let column of columns) {\r\n            let roles = column.source.roles;\r\n            if (!roles || !roles[inputRole])\r\n                continue;\r\n\r\n            return column;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ITableEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createTableEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewTable: DataViewTable, selectTransforms: DataViewSelectTransform[]): ITableEvalContext {\r\n        return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\r\n    }\r\n\r\n    class TableEvalContext implements ITableEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewTable;\r\n        private rowIdx: number;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewTable, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let rowIdx = this.rowIdx;\r\n            if (rowIdx == null)\r\n                return;\r\n\r\n            return getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.rowIdx = index;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class RuleEvaluation {\r\n        // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class ColorRuleEvaluation extends RuleEvaluation {\r\n        private inputRole: string;\r\n        private allocator: IColorAllocator;\r\n\r\n        constructor(inputRole: string, allocator: IColorAllocator) {\r\n            debug.assertValue(inputRole, 'inputRole');\r\n            debug.assertValue(allocator, 'allocator');\r\n\r\n            super();\r\n            this.inputRole = inputRole;\r\n            this.allocator = allocator;\r\n        }\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n\r\n            let value: any = evalContext.getRoleValue(this.inputRole);\r\n            if (value !== undefined)\r\n                return this.allocator.color(value);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    export module DataViewMatrixUtils {\r\n\r\n        /**\r\n         * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the \r\n         * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the \r\n         * particular leaf node in the context of this forEachLeafNode(...) invocation.\r\n         *\r\n         * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\r\n         *\r\n         * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified \r\n         * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\r\n         * then treePath will be an array of length 1 containing that very node.\r\n         *\r\n         * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\r\n         * If your callback needs to retain a copy of the treePath, please clone the array before returning.\r\n         */\r\n        export function forEachLeafNode(\r\n            rootNodes: DataViewMatrixNode | DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): void {\r\n            debug.assertAnyValue(rootNodes, 'rootNodes');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\r\n            // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \r\n            // for the fact that all the properties on DataViewMatrixNode are optional...\r\n            if (rootNodes) {\r\n                if (isNodeArray(rootNodes)) {\r\n                    let index = 0;\r\n                    for (let rootNode of rootNodes) {\r\n                        if (rootNode) {\r\n                            index = forEachLeafNodeRecursive(rootNode, index, [], callback);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    forEachLeafNodeRecursive(rootNodes, 0, [], callback);\r\n                }\r\n            }\r\n        }\r\n\r\n        function isNodeArray(nodeOrNodeArray: DataViewMatrixNode | DataViewMatrixNode[]): nodeOrNodeArray is DataViewMatrixNode[] {\r\n            return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\r\n        }\r\n\r\n        /**\r\n         * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\r\n         * Returns the index for the next node after the last node that this function invokes callback with.\r\n         *\r\n         * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\r\n         */\r\n        function forEachLeafNodeRecursive(\r\n            matrixNode: DataViewMatrixNode,\r\n            nextIndex: number,\r\n            treePath: DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): number {\r\n            debug.assertValue(matrixNode, 'matrixNode');\r\n            debug.assertValue(treePath, 'treePath');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // If treePath already contains matrixNode, then either one of the following errors has happened:\r\n            // 1. the caller code mistakenly added matrixNode to treePath, or\r\n            // 2. the callback modified treePath by adding a node to it, or\r\n            // 3. the matrix hierarchy contains a cyclical node reference.');\r\n            debug.assert(!_.contains(treePath, matrixNode),\r\n                'pre-condition: treePath must not already contain matrixNode');\r\n\r\n            treePath.push(matrixNode);\r\n\r\n            if (_.isEmpty(matrixNode.children)) { // if it is a leaf node\r\n                callback(matrixNode, nextIndex, treePath);\r\n                nextIndex++;\r\n            }\r\n            else {\r\n                let children = matrixNode.children;\r\n                for (let nextChild of children) {\r\n                    if (nextChild) {\r\n                        nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\r\n                    }\r\n                }\r\n            }\r\n\r\n            debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\r\n            treePath.pop();\r\n\r\n            return nextIndex;\r\n        }\r\n\r\n        /**\r\n         * Returned an object tree where each node and its children property are inherited from the specified node \r\n         * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\r\n         *\r\n         * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array \r\n         * property, i.e. its children property is the same array object referenced in the input node's object tree.\r\n         *\r\n         * @param node The input node with the hierarchy object tree.\r\n         * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\r\n         * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is \r\n         * not already an inherited object. Same goes for the node's children property.  This is useful for creating \r\n         * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for \r\n         * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains \r\n         * inherited objects.\r\n         */\r\n        export function inheritMatrixNodeHierarchy(\r\n            node: DataViewMatrixNode,\r\n            deepestLevelToInherit: number,\r\n            useInheritSingle: boolean): DataViewMatrixNode {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\r\n            debug.assertValue(useInheritSingle, 'useInheritSingle');\r\n\r\n            let returnNode = node;\r\n\r\n            // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\r\n            // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\r\n            // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\r\n            //  {\r\n            //    \"level\": 0,\r\n            //    \"isSubtotal\": true,\r\n            //    \"children\": [\r\n            //      { \"level\": 2, \"isSubtotal\": true },\r\n            //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\r\n            //    ]\r\n            //  }\r\n            let isRootNode = _.isUndefined(node.level);\r\n            let shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\r\n            if (shouldInheritCurrentNode) {\r\n                let inheritFunc = useInheritSingle ? inheritSingle : inherit;\r\n                let inheritedNode: DataViewMatrixNode = inheritFunc(node);\r\n\r\n                let shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\r\n                if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\r\n                    inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\r\n                    for (let i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\r\n                        inheritedNode.children[i] =\r\n                            inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\r\n                    }\r\n                }\r\n\r\n                returnNode = inheritedNode;\r\n            }\r\n\r\n            return returnNode;\r\n        }\r\n\r\n        /**\r\n         * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\r\n         * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\r\n         * Year === 2016, Quarter === 'Qtr 1', Month === 1.\r\n         *\r\n         * Returns false if the specified matrixOrHierarchy does not contain any composite group, \r\n         * or if matrixOrHierarchy is null or undefined.\r\n         */\r\n        export function containsCompositeGroup(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): boolean {\r\n            debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\r\n\r\n            let hasCompositeGroup = false;\r\n\r\n            if (matrixOrHierarchy) {\r\n                if (isMatrix(matrixOrHierarchy)) {\r\n                    hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\r\n                        containsCompositeGroup(matrixOrHierarchy.columns);\r\n                }\r\n                else {\r\n                    let hierarchyLevels = matrixOrHierarchy.levels;\r\n                    if (!_.isEmpty(hierarchyLevels)) {\r\n                        for (var level of hierarchyLevels) {\r\n                            // it takes at least 2 columns at the same hierarchy level to form a composite group...\r\n                            if (level.sources && (level.sources.length >= 2)) {\r\n\r\n                                debug.assert(_.all(level.sources, sourceColumn => sourceColumn.isMeasure === level.sources[0].isMeasure),\r\n                                    'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\r\n\r\n                                // Measure headers are not group\r\n                                let isMeasureHeadersLevel = level.sources[0].isMeasure;\r\n                                if (!isMeasureHeadersLevel) {\r\n                                    hasCompositeGroup = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return hasCompositeGroup;\r\n        }\r\n\r\n        function isMatrix(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): matrixOrHierarchy is DataViewMatrix {\r\n            return 'rows' in matrixOrHierarchy &&\r\n                'columns' in matrixOrHierarchy &&\r\n                'valueSources' in matrixOrHierarchy;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    export module DataViewMetadataColumnUtils {\r\n\r\n        export interface MetadataColumnAndProjectionIndex {\r\n            /**\r\n            * A metadata column taken from a source collection, e.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n            */\r\n            metadataColumn: DataViewMetadataColumn;\r\n\r\n            /**\r\n             * The index of this.metadataColumn in its sources collection.\r\n             *\r\n             * E.g.1 This can be the value of the property DataViewMatrixGroupValue.levelSourceIndex which is the index of this.metadataColumn in DataViewHierarchyLevel.sources.\r\n             * E.g.2 This can be the value of the property DataViewMatrixNodeValue.valueSourceIndex which refer to columns in DataViewMatrix.valueSources.\r\n             */\r\n            sourceIndex: number;\r\n\r\n            /**\r\n            * The index of this.metadataColumn in the projection ordering of a given role.\r\n            */\r\n            projectionOrderIndex: number;\r\n        }\r\n\r\n        /**\r\n         * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\r\n         */\r\n        export function isForRole(metadataColumn: DataViewMetadataColumn, targetRole: string): boolean {\r\n            debug.assertValue(metadataColumn, 'metadataColumn');\r\n            debug.assertValue(targetRole, 'targetRole');\r\n\r\n            let roles = metadataColumn.roles;\r\n            return roles && roles[targetRole];\r\n        }\r\n\r\n        /**\r\n         * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\r\n         *\r\n         * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the \r\n         * specified columnSources must be a non-filtered array of column sources from the DataView, such as\r\n         * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\r\n         *\r\n         * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n         * @param projection The projection ordering.  It must contain an ordering for the specified role.\r\n         * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\r\n         */\r\n        export function joinMetadataColumnsAndProjectionOrder(\r\n            columnSources: DataViewMetadataColumn[],\r\n            projection: DataViewProjectionOrdering,\r\n            role: string): MetadataColumnAndProjectionIndex[] {\r\n            debug.assertAnyValue(columnSources, 'columnSources');\r\n            debug.assert(_.all(columnSources, column => _.isNumber(column.index)),\r\n                'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\r\n            debug.assertNonEmpty(projection[role], 'projection[role]');\r\n            debug.assert(_.all(columnSources, column => !isForRole(column, role) || _.contains(projection[role], column.index)),\r\n                'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\r\n\r\n            let jointResult: MetadataColumnAndProjectionIndex[] = [];\r\n\r\n            if (!_.isEmpty(columnSources)) {\r\n                let projectionOrderSelectIndices = projection[role];\r\n                let selectIndexToProjectionIndexMap: { [selectIndex: number]: number } = {};\r\n                for (let i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\r\n                    let selectIndex = projectionOrderSelectIndices[i];\r\n                    selectIndexToProjectionIndexMap[selectIndex] = i;\r\n                }\r\n\r\n                for (let j = 0, jlen = columnSources.length; j < jlen; j++) {\r\n                    var column = columnSources[j];\r\n                    if (isForRole(column, role)) {\r\n                        let jointColumnInfo: MetadataColumnAndProjectionIndex = {\r\n                            metadataColumn: column,\r\n                            sourceIndex: j,\r\n                            projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\r\n                        };\r\n\r\n                        jointResult.push(jointColumnInfo);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return jointResult;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export class ConceptualSchema {\r\n        public entities: ArrayNamedItems<ConceptualEntity>;\r\n        public capabilities: ConceptualCapabilities;\r\n\r\n        /** Indicates whether the user can edit this ConceptualSchema.  This is used to enable/disable model authoring UX. */\r\n        public canEdit: boolean;\r\n\r\n        public findProperty(entityName: string, propertyName: string): ConceptualProperty {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            return entity.properties.withName(propertyName);\r\n        }\r\n\r\n        public findHierarchy(entityName: string, name: string): ConceptualHierarchy {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.hierarchies))\r\n                return;\r\n\r\n            return entity.hierarchies.withName(name);\r\n        }\r\n\r\n        public findHierarchyByVariation(\r\n            variationEntityName: string,\r\n            variationColumnName: string,\r\n            variationName: string,\r\n            hierarchyName: string): ConceptualHierarchy {\r\n\r\n            let variationEntity = this.entities.withName(variationEntityName);\r\n            if (!variationEntity || _.isEmpty(variationEntity.properties))\r\n                return;\r\n\r\n            let variationProperty = variationEntity.properties.withName(variationColumnName);\r\n            if (!variationProperty)\r\n                return;\r\n\r\n            let variationColumn = variationProperty.column;\r\n            if (!variationColumn || _.isEmpty(variationColumn.variations))\r\n                return;\r\n\r\n            let variation = variationColumn.variations.withName(variationName);\r\n            if (variation) {\r\n                let targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\r\n                if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\r\n                    return;\r\n\r\n                return targetEntity.hierarchies.withName(hierarchyName);\r\n            }\r\n        }\r\n\r\n        /**\r\n        * Returns the first property of the entity whose kpi is tied to kpiProperty\r\n        */\r\n        public findPropertyWithKpi(entityName: string, kpiProperty: ConceptualProperty): ConceptualProperty {\r\n            debug.assertValue(kpiProperty, 'kpiProperty');\r\n\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            for (let prop of entity.properties) {\r\n                if (prop &&\r\n                    prop.measure &&\r\n                    prop.measure.kpi &&\r\n                    (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\r\n                    return prop;\r\n            }\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    export interface ConceptualCapabilities {\r\n        discourageQueryAggregateUsage: boolean;\r\n        normalizedFiveStateKpiRange: boolean;\r\n        supportsMedian: boolean;\r\n        supportsPercentile: boolean;\r\n    }\r\n\r\n    export interface ConceptualPropertyItemContainer {\r\n        properties: ArrayNamedItems<ConceptualProperty>;\r\n        hierarchies?: ArrayNamedItems<ConceptualHierarchy>;\r\n        displayFolders?: ArrayNamedItems<ConceptualDisplayFolder>;\r\n    }\r\n\r\n    export interface ConceptualPropertyItem {\r\n        name: string;\r\n        displayName: string;\r\n        hidden?: boolean;\r\n    }\r\n\r\n    export interface ConceptualEntity extends ConceptualPropertyItemContainer {\r\n        name: string;\r\n        displayName: string;\r\n        visibility?: ConceptualVisibility;\r\n        calculated?: boolean;\r\n        queryable?: ConceptualQueryableState;\r\n        navigationProperties?: ArrayNamedItems<ConceptualNavigationProperty>;\r\n    }\r\n\r\n    export interface ConceptualDisplayFolder extends ConceptualPropertyItem, ConceptualPropertyItemContainer {\r\n    }\r\n\r\n    export interface ConceptualProperty extends ConceptualPropertyItem {\r\n        type: ValueType;\r\n        kind: ConceptualPropertyKind;\r\n        format?: string;\r\n        column?: ConceptualColumn;\r\n        queryable?: ConceptualQueryableState;\r\n        measure?: ConceptualMeasure;\r\n        kpiValue?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualHierarchy extends ConceptualPropertyItem {\r\n        levels: ArrayNamedItems<ConceptualHierarchyLevel>;\r\n    }\r\n\r\n    export interface ConceptualHierarchyLevel extends ConceptualPropertyItem {\r\n        column: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualNavigationProperty {\r\n        name: string;\r\n        isActive: boolean;\r\n        sourceColumn?: ConceptualColumn;\r\n        targetEntity: ConceptualEntity;\r\n        sourceMultiplicity: ConceptualMultiplicity;\r\n        targetMultiplicity: ConceptualMultiplicity;\r\n    }\r\n\r\n    export interface ConceptualVariationSource {\r\n        name: string;\r\n        isDefault: boolean;\r\n        navigationProperty?: ConceptualNavigationProperty;\r\n        defaultHierarchy?: ConceptualHierarchy;\r\n        defaultProperty?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualColumn {\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n        keys?: ArrayNamedItems<ConceptualProperty>;\r\n        idOnEntityKey?: boolean;\r\n        calculated?: boolean;\r\n        defaultValue?: SQConstantExpr;\r\n        variations?: ArrayNamedItems<ConceptualVariationSource>;\r\n        aggregateBehavior?: ConceptualAggregateBehavior;\r\n    }\r\n\r\n    export interface ConceptualMeasure {\r\n        kpi?: ConceptualPropertyKpi;\r\n    }\r\n\r\n    export interface ConceptualPropertyKpi {\r\n        statusMetadata: DataViewKpiColumnMetadata;\r\n        trendMetadata?: DataViewKpiColumnMetadata;\r\n        status?: ConceptualProperty;\r\n        goal?: ConceptualProperty;\r\n        trend?: ConceptualProperty;\r\n    }\r\n\r\n    export const enum ConceptualVisibility {\r\n        Visible = 0,\r\n        Hidden = 1,\r\n        ShowAsVariationsOnly = 2,\r\n        IsPrivate = 4,\r\n    }\r\n\r\n    export const enum ConceptualQueryableState {\r\n        Queryable = 0,\r\n        Error = 1,\r\n    }\r\n\r\n    export const enum ConceptualMultiplicity {\r\n        ZeroOrOne = 0,\r\n        One = 1,\r\n        Many = 2,\r\n    }\r\n\r\n    export const enum ConceptualPropertyKind {\r\n        Column,\r\n        Measure,\r\n        Kpi,\r\n    }\r\n\r\n    export const enum ConceptualDefaultAggregate {\r\n        Default,\r\n        None,\r\n        Sum,\r\n        Count,\r\n        Min,\r\n        Max,\r\n        Average,\r\n        DistinctCount,\r\n    }\r\n\r\n    // TODO: Remove this (replaced by ValueType)\r\n    export enum ConceptualDataCategory {\r\n        None,\r\n        Address,\r\n        City,\r\n        Company,\r\n        Continent,\r\n        Country,\r\n        County,\r\n        Date,\r\n        Image,\r\n        ImageUrl,\r\n        Latitude,\r\n        Longitude,\r\n        Organization,\r\n        Place,\r\n        PostalCode,\r\n        Product,\r\n        StateOrProvince,\r\n        WebUrl,\r\n    }\r\n\r\n    export const enum ConceptualAggregateBehavior {\r\n        Default,\r\n        DiscourageAcrossGroups,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import FederatedConceptualSchema = powerbi.data.FederatedConceptualSchema;\r\n    import FieldExprColumnPattern = powerbi.data.FieldExprColumnPattern;\r\n    import FieldExprColumnAggrPattern = powerbi.data.FieldExprColumnAggrPattern;\r\n    import FieldExprColumnHierarchyLevelVariationPattern = powerbi.data.FieldExprColumnHierarchyLevelVariationPattern;\r\n    import FieldExprEntityPattern = powerbi.data.FieldExprEntityPattern;\r\n    import FieldExprEntityAggrPattern = powerbi.data.FieldExprEntityAggrPattern;\r\n    import FieldExprHierarchyPattern = powerbi.data.FieldExprHierarchyPattern;\r\n    import FieldExprHierarchyLevelPattern = powerbi.data.FieldExprHierarchyLevelPattern;\r\n    import FieldExprHierarchyLevelAggrPattern = powerbi.data.FieldExprHierarchyLevelAggrPattern;\r\n    import FieldExprMeasurePattern = powerbi.data.FieldExprMeasurePattern;\r\n    import FieldExprPattern = powerbi.data.FieldExprPattern;\r\n    import IFieldExprPatternVisitor = powerbi.data.IFieldExprPatternVisitor;\r\n    import QueryProjectionsByRole = data.QueryProjectionsByRole;\r\n\r\n    export interface ScriptResult {\r\n        source: string;\r\n        provider: string;\r\n    }\r\n\r\n    export module ScriptResultUtil {\r\n\r\n        export function findScriptResult(dataViewMappings: DataViewMapping[] | data.CompiledDataViewMapping[]): DataViewScriptResultMapping | data.CompiledDataViewScriptResultMapping {\r\n            if (dataViewMappings && dataViewMappings.length === 1) {\r\n                return dataViewMappings[0].scriptResult;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResult(dataViewMappings: data.CompiledDataViewMapping[]): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult) {\r\n                let objects = dataViewMappings[0].metadata.objects;\r\n                let source: string = DataViewObjects.getValue<string>(objects, scriptResult.script.source);\r\n                let provider: string = DataViewObjects.getValue<string>(objects, scriptResult.script.provider);\r\n                return {\r\n                    source: source,\r\n                    provider: provider\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResultFromVisualConfig(dataViewMappings: DataViewMapping[], objects: powerbi.data.DataViewObjectDefinitions): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult && objects) {\r\n                let scriptSource = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\r\n                let provider = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\r\n                return {\r\n                    source: scriptSource ? scriptSource.value : null,\r\n                    provider: provider ? provider.value : null\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function getScriptInput(projections: QueryProjectionsByRole, selects: ArrayNamedItems<data.NamedSQExpr>, schema: FederatedConceptualSchema): data.ScriptInput {\r\n            let scriptInput: data.ScriptInput = {\r\n                VariableName: \"dataset\",\r\n                Columns: []\r\n            };\r\n\r\n            // Go over all the projections, and create an input column according to the order\r\n            // of the projections (including duplicate expressions)\r\n            if (projections && selects && !_.isEmpty(selects)) {\r\n                let scriptInputColumnNames: string[] = [];\r\n                let scriptInputColumns: data.ScriptInputColumn[] = [];\r\n                for (let role in projections) {\r\n                    for (let projection of projections[role].all()) {\r\n                        let select = selects.withName(projection.queryRef);\r\n                        if (select) {\r\n                            let scriptInputColumn = <data.ScriptInputColumn>{\r\n                                QueryName: select.name,\r\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\r\n                            };\r\n\r\n                            scriptInputColumns.push(scriptInputColumn);\r\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Make sure the names of the columns are unique\r\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\r\n\r\n                // Update the names of the columns\r\n                for (let i = 0; i < scriptInputColumnNames.length; i++) {\r\n                    let scriptInputColumn = scriptInputColumns[i];\r\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\r\n                }\r\n\r\n                scriptInput.Columns = scriptInputColumns;\r\n            }\r\n\r\n            return scriptInput;\r\n        }\r\n\r\n        class ScriptInputColumnNameVisitor implements IFieldExprPatternVisitor<string>\r\n        {\r\n            private federatedSchema: FederatedConceptualSchema;\r\n\r\n            constructor(federatedSchema: FederatedConceptualSchema) {\r\n                this.federatedSchema = federatedSchema;\r\n            }\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): string {\r\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): string {\r\n                return entity.entity;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): string {\r\n                return entityAggr.entity;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): string {\r\n                /*Hierarchy levels are not supported yet*/\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\r\n            }\r\n\r\n            private static getNameForHierarchy(pattern: FieldExprHierarchyPattern, federatedScheam: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedScheam.schema(pattern.schema),\r\n                    hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\r\n\r\n                if (hierarchy)\r\n                    return hierarchy.name;\r\n            }\r\n\r\n            private static getNameForProperty(pattern: data.FieldExprPropertyPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedSchema.schema(pattern.schema),\r\n                    property = schema.findProperty(pattern.entity, pattern.name);\r\n\r\n                if (property)\r\n                    return property.name;\r\n            }\r\n\r\n            private static getVariationLevelName(pattern: FieldExprColumnHierarchyLevelVariationPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let source = pattern.source;\r\n                let prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\r\n                if (!prop)\r\n                    return;\r\n\r\n                let variations = prop.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === pattern.variationName)\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            if (level.name === pattern.level.level)\r\n                                return level.column.name;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.segmentation {\r\n\r\n    export interface DataViewTableSegment extends DataViewTable {\r\n        /** \r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other. \r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewTreeSegmentNode extends DataViewTreeNode {\r\n        /** Indicates whether the node is a duplicate of a node from a previous segment. */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export interface DataViewCategoricalSegment extends DataViewCategorical {\r\n        /** \r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other. \r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewMatrixSegmentNode extends DataViewMatrixNode {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other. \r\n         */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export module DataViewMerger {\r\n\r\n        export function mergeDataViews(source: DataView, segment: DataView): void {\r\n\r\n            if (!DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\r\n                debug.assertFail(\"Cannot merge data views with different metadata columns\");\r\n            }\r\n\r\n            // The last segment is complete. We mark the source as complete.\r\n            if (!segment.metadata.segment)\r\n                delete source.metadata.segment;\r\n\r\n            if (source.table && segment.table)\r\n                mergeTables(source.table, <DataViewTableSegment>segment.table);\r\n\r\n            if (source.categorical && segment.categorical)\r\n                mergeCategorical(source.categorical, <DataViewCategoricalSegment>segment.categorical);\r\n\r\n            // Tree cannot support subtotals hence we can get into situations\r\n            // where a node has no children in one segment and more than 1 child\r\n            // in another segment.\r\n            if (source.tree && segment.tree)\r\n                mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\r\n\r\n            if (source.matrix && segment.matrix)\r\n                mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTables(source: DataViewTable, segment: DataViewTableSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            if (segment.rows.length === 0)\r\n                return;\r\n\r\n            merge(source.rows, segment.rows, segment.lastMergeIndex + 1);\r\n        }\r\n\r\n        /**\r\n         * Merge categories values and identities\r\n         * \r\n         * Note: Public for testability \r\n         */\r\n        export function mergeCategorical(source: DataViewCategorical, segment: DataViewCategoricalSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            // Merge categories values and identities\r\n            if (source.categories && segment.categories) {\r\n                let segmentCategoriesLength = segment.categories.length;\r\n                debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\r\n\r\n                for (let categoryIndex: number = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\r\n                    let segmentCategory = segment.categories[categoryIndex];\r\n                    let sourceCategory = source.categories[categoryIndex];\r\n\r\n                    debug.assert(DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\r\n\r\n                    if (!sourceCategory.values && segmentCategory.values) {\r\n                        sourceCategory.values = [];\r\n                        debug.assert(!sourceCategory.identity, \"Source category is missing values but has identities.\");\r\n                    }\r\n\r\n                    if (segmentCategory.values) {\r\n                        merge(sourceCategory.values, segmentCategory.values, segment.lastMergeIndex + 1);\r\n                    }\r\n\r\n                    if (!sourceCategory.identity && segmentCategory.identity) {\r\n                        sourceCategory.identity = [];\r\n                    }\r\n\r\n                    if (segmentCategory.identity) {\r\n                        merge(sourceCategory.identity, segmentCategory.identity, segment.lastMergeIndex + 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Merge values for each value column\r\n            if (source.values && segment.values) {\r\n                let segmentValuesLength = segment.values.length;\r\n                debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\r\n\r\n                for (let valueIndex: number = 0; valueIndex < segmentValuesLength; valueIndex++) {\r\n                    let segmentValue = segment.values[valueIndex];\r\n                    let sourceValue = source.values[valueIndex];\r\n\r\n                    debug.assert(jsCommon.JsonComparer.equals(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\r\n\r\n                    if (!sourceValue.values && segmentValue.values) {\r\n                        sourceValue.values = [];\r\n                    }\r\n\r\n                    if (segmentValue.values) {\r\n                        merge(sourceValue.values, segmentValue.values, segment.lastMergeIndex + 1);\r\n                    }\r\n\r\n                    if (segmentValue.highlights) {\r\n                        merge(sourceValue.highlights, segmentValue.highlights, segment.lastMergeIndex + 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Merges the segment array starting at the specified index into the source array \r\n         * and returns the segment slice that wasn't merged.\r\n         * The segment array is spliced up to specified index in the process.\r\n         */\r\n        function merge(source: any[], segment: any[], index?: number): any[] {\r\n            if (index >= segment.length)\r\n                return segment;\r\n\r\n            let result: any[] = [];\r\n            if (index !== undefined)\r\n                result = segment.splice(0, index);\r\n\r\n            Array.prototype.push.apply(source, segment);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTreeNodes(sourceRoot: DataViewTreeNode, segmentRoot: DataViewTreeNode, allowDifferentStructure: boolean): void {\r\n            debug.assertValue(sourceRoot, 'sourceRoot');\r\n            debug.assertValue(segmentRoot, 'segmentRoot');\r\n\r\n            if (!segmentRoot.children || segmentRoot.children.length === 0)\r\n                return;\r\n\r\n            if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\r\n                sourceRoot.children = segmentRoot.children;\r\n                return;\r\n            }\r\n\r\n            debug.assert(sourceRoot.children && sourceRoot.children.length >= 0,\r\n                \"Source tree has different structure than segment.\");\r\n\r\n            let firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\r\n            let lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\r\n            let mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\r\n\r\n            if (mergedChildren.length > 0)\r\n                mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\r\n        }\r\n\r\n        function findFirstAppendIndex(children: DataViewTreeNode[]): number {\r\n            if (children.length === 0)\r\n                return 0;\r\n\r\n            let i: number = 0;\r\n            for (; i < children.length; i++) {\r\n                let childSegment: DataViewTreeSegmentNode = <DataViewTreeSegmentNode>children[i];\r\n                if (!childSegment.isMerge)\r\n                    break;\r\n            }\r\n\r\n            return i;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Rewrites an expression tree, including all descendant nodes. */\r\n    export class SQExprRewriter implements ISQExprVisitor<SQExpr>, IFillRuleDefinitionVisitor<LinearGradient2Definition, LinearGradient3Definition> {\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQColumnRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQMeasureRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(rewrittenArg, expr.func);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyExpr(rewrittenArg, expr.hierarchy);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyLevelExpr(rewrittenArg, expr.level);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitAnd(orig: SQAndExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQAndExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitBetween(orig: SQBetweenExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this),\r\n                origLower = orig.lower,\r\n                rewrittenLower = origLower.accept(this),\r\n                origUpper = orig.upper,\r\n                rewrittenUpper = origUpper.accept(this);\r\n\r\n            if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\r\n                return orig;\r\n\r\n            return new SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\r\n        }\r\n\r\n        public visitIn(orig: SQInExpr): SQExpr {\r\n            let origArgs = orig.args,\r\n                rewrittenArgs = this.rewriteAll(origArgs),\r\n                origValues: SQExpr[][] = orig.values,\r\n                rewrittenValues: SQExpr[][];\r\n\r\n            for (let i = 0, len = origValues.length; i < len; i++) {\r\n                let origValueTuple = origValues[i],\r\n                    rewrittenValueTuple = this.rewriteAll(origValueTuple);\r\n\r\n                if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\r\n                    rewrittenValues = ArrayExtensions.take(origValues, i);\r\n\r\n                if (rewrittenValues)\r\n                    rewrittenValues.push(rewrittenValueTuple);\r\n            }\r\n\r\n            if (origArgs === rewrittenArgs && !rewrittenValues)\r\n                return orig;\r\n\r\n            return new SQInExpr(rewrittenArgs, rewrittenValues || origValues);\r\n        }\r\n\r\n        private rewriteAll(origExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(origExprs, 'origExprs');\r\n\r\n            let rewrittenResult: SQExpr[];\r\n            for (let i = 0, len = origExprs.length; i < len; i++) {\r\n                let origExpr = origExprs[i],\r\n                    rewrittenExpr = origExpr.accept(this);\r\n\r\n                if (origExpr !== rewrittenExpr && !rewrittenResult)\r\n                    rewrittenResult = ArrayExtensions.take(origExprs, i);\r\n\r\n                if (rewrittenResult)\r\n                    rewrittenResult.push(rewrittenExpr);\r\n            }\r\n\r\n            return rewrittenResult || origExprs;\r\n        }\r\n\r\n        public visitOr(orig: SQOrExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQOrExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitCompare(orig: SQCompareExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitContains(orig: SQContainsExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQContainsExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitExists(orig: SQExistsExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQExistsExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitNot(orig: SQNotExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQNotExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitStartsWith(orig: SQStartsWithExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQStartsWithExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitDateSpan(orig: SQDateSpanExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateSpanExpr(orig.unit, rewrittenArg);\r\n        }\r\n\r\n        public visitDateAdd(orig: SQDateAddExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\r\n        }\r\n\r\n        public visitNow(orig: SQNowExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitDefaultValue(orig: SQDefaultValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitAnyValue(orig: SQAnyValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitArithmetic(orig: SQArithmeticExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\r\n        }\r\n\r\n        public visitScopedEval(orig: SQScopedEvalExpr): SQExpr {\r\n            let origExpression = orig.expression,\r\n                rewrittenExpression = origExpression.accept(this),\r\n                origScope = orig.scope,\r\n                rewrittenScope = this.rewriteAll(origScope);\r\n\r\n            if (origExpression === rewrittenExpression && origScope === rewrittenScope)\r\n                return orig;\r\n\r\n            return new SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\r\n        }\r\n\r\n        public visitFillRule(orig: SQFillRuleExpr): SQExpr {\r\n            let origInput = orig.input,\r\n                rewrittenInput = origInput.accept(this);\r\n\r\n            let origRule = orig.rule;\r\n\r\n            let origGradient2 = origRule.linearGradient2,\r\n                rewrittenGradient2 = origGradient2;\r\n            if (origGradient2) {\r\n                rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\r\n            }\r\n\r\n            let origGradient3 = origRule.linearGradient3,\r\n                rewrittenGradient3 = origGradient3;\r\n            if (origGradient3) {\r\n                rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\r\n            }\r\n\r\n            if (origInput !== rewrittenInput ||\r\n                origGradient2 !== rewrittenGradient2 ||\r\n                origGradient3 !== rewrittenGradient3) {\r\n                let rewrittenRule: FillRuleDefinition = {};\r\n                if (rewrittenGradient2)\r\n                    rewrittenRule.linearGradient2 = rewrittenGradient2;\r\n                if (rewrittenGradient3)\r\n                    rewrittenRule.linearGradient3 = rewrittenGradient3;\r\n\r\n                return new SQFillRuleExpr(rewrittenInput, rewrittenRule);\r\n            }\r\n\r\n            return orig;\r\n        }\r\n\r\n        public visitLinearGradient2(origGradient2: LinearGradient2Definition): LinearGradient2Definition {\r\n            debug.assertValue(origGradient2, 'origGradient2');\r\n\r\n            let origMin = origGradient2.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMax = origGradient2.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient2;\r\n        }\r\n\r\n        public visitLinearGradient3(origGradient3: LinearGradient3Definition): LinearGradient3Definition {\r\n            debug.assertValue(origGradient3, 'origGradient3');\r\n\r\n            let origMin = origGradient3.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMid = origGradient3.mid,\r\n                rewrittenMid = this.visitFillRuleStop(origMid),\r\n                origMax = origGradient3.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    mid: rewrittenMid,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient3;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): RuleColorStopDefinition {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            let origColor = stop.color,\r\n                rewrittenColor = stop.color.accept(this);\r\n\r\n            let origValue = stop.value,\r\n                rewrittenValue = origValue;\r\n            if (origValue)\r\n                rewrittenValue = origValue.accept(this);\r\n\r\n            if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\r\n                let rewrittenStop: RuleColorStopDefinition = {\r\n                    color: rewrittenColor\r\n                };\r\n\r\n                if (rewrittenValue)\r\n                    rewrittenStop.value = rewrittenValue;\r\n\r\n                return rewrittenStop;\r\n            }\r\n\r\n            return stop;\r\n        }\r\n\r\n        public visitResourcePackageItem(orig: SQResourcePackageItemExpr): SQExpr {\r\n            return orig;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Responsible for writing equality comparisons against a field to an SQInExpr. */\r\n    export module EqualsToInRewriter {\r\n        export function run(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(new Rewriter());\r\n        }\r\n\r\n        class Rewriter extends SQExprRewriter {\r\n            private current: InBuilder;\r\n\r\n            constructor() {\r\n                super();\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): SQExpr {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return this.visitUnsupported(expr);\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let leftIsComparand = this.isComparand(expr.left);\r\n                let rightIsComparand = this.isComparand(expr.right);\r\n                if (leftIsComparand === rightIsComparand)\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let operand: SQExpr = leftIsComparand\r\n                    ? expr.left\r\n                    : expr.right;\r\n                let value: SQExpr = leftIsComparand\r\n                    ? expr.right\r\n                    : expr.left;\r\n\r\n                let current = this.current;\r\n                if (!current) {\r\n                    return SQExprBuilder.inExpr([operand], [[value]]);\r\n                }\r\n\r\n                current.add(operand, value);\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitOr(expr: SQOrExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current: InBuilder;\r\n                if (!this.current) {\r\n                    current = this.current = new InBuilder();\r\n                }\r\n\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n\r\n                if (current) {\r\n                    this.current = null;\r\n                    return current.complete() || expr;\r\n                }\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current = this.current;\r\n                if (current) {\r\n                    // NOTE: Composite keys are not supported by this algorithm.\r\n                    current.cancel();\r\n                    return expr;\r\n                }\r\n\r\n                return super.visitAnd(expr);\r\n            }\r\n\r\n            private visitUnsupported(expr: SQExpr): SQExpr {\r\n                let current = this.current;\r\n                if (current)\r\n                    current.cancel();\r\n\r\n                return expr;\r\n            }\r\n\r\n            private isSupported(expr: SQExpr): boolean {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return expr instanceof SQCompareExpr\r\n                    || expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQConstantExpr\r\n                    || expr instanceof SQHierarchyLevelExpr\r\n                    || expr instanceof SQOrExpr\r\n                    || expr instanceof SQAndExpr;\r\n            }\r\n\r\n            private isComparand(expr: SQExpr): boolean {\r\n                return expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQHierarchyLevelExpr;\r\n            }\r\n        }\r\n\r\n        class InBuilder {\r\n            private operand: SQExpr;\r\n            private values: SQExpr[];\r\n            private cancelled: boolean;\r\n\r\n            public add(operand: SQExpr, value: SQExpr): void {\r\n                debug.assertValue(operand, 'operand');\r\n                debug.assertValue(value, 'value');\r\n\r\n                if (this.cancelled)\r\n                    return;\r\n\r\n                if (this.operand && !SQExpr.equals(operand, this.operand)) {\r\n                    this.cancel();\r\n                    return;\r\n                }\r\n\r\n                this.operand = operand;\r\n\r\n                let values = this.values;\r\n                if (!values)\r\n                    values = this.values = [];\r\n\r\n                values.push(value);\r\n            }\r\n\r\n            public cancel(): void {\r\n                this.cancelled = true;\r\n            }\r\n\r\n            public complete(): SQInExpr {\r\n                if (this.cancelled || !this.operand)\r\n                    return;\r\n\r\n                return SQExprBuilder.inExpr([this.operand], _.map(this.values, v => [v]));\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface FilterValueScopeIdsContainer {\r\n            isNot: boolean;\r\n            scopeIds: DataViewScopeIdentity[];\r\n        }\r\n\r\n    export module SQExprConverter {\r\n        export function asScopeIdsContainer(filter: SemanticFilter, fieldSQExprs: SQExpr[]): FilterValueScopeIdsContainer {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\r\n\r\n            let filterItems = filter.conditions();\r\n            debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\r\n            let filterItem = filterItems[0];\r\n            if (filterItem) {\r\n                let visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\r\n                if (filterItem.accept(visitor))\r\n                    return visitor.getResult();\r\n            }\r\n        }\r\n\r\n        /** Gets a comparand value from the given DataViewScopeIdentity. */\r\n        export function getFirstComparandValue(identity: DataViewScopeIdentity): any {\r\n            debug.assertValue(identity, 'identity');\r\n\r\n            let comparandExpr = (<SQExpr>identity.expr).accept(new FindComparandVisitor());\r\n            if (comparandExpr)\r\n                return comparandExpr.value;\r\n        }\r\n    }\r\n\r\n    /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\r\n    class FilterScopeIdsCollectorVisitor extends DefaultSQExprVisitor<boolean>{\r\n        private isRoot: boolean;\r\n        private isNot: boolean;\r\n        private keyExprsCount: number;\r\n        private valueExprs: SQExpr[];\r\n        private fieldExprs: SQExpr[];\r\n\r\n        constructor(fieldSQExprs:SQExpr[]) {\r\n            super();\r\n            this.isRoot = true;\r\n            this.isNot = false;\r\n            this.keyExprsCount = null;\r\n            this.valueExprs = [];\r\n\r\n            // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\r\n            // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\r\n            // need to drop it in order to use JsonComparer.\r\n            this.fieldExprs = [];\r\n            for (let field of fieldSQExprs) {\r\n                this.fieldExprs.push(SQExprBuilder.removeEntityVariables(field));\r\n            }\r\n        }\r\n\r\n        public getResult(): FilterValueScopeIdsContainer {\r\n            debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');            \r\n\r\n            let valueExprs = this.valueExprs,\r\n                scopeIds: DataViewScopeIdentity[] = [];\r\n            let valueCount: number = this.keyExprsCount || 1;\r\n\r\n            for (let startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\r\n                let values = valueExprs.slice(startIndex, endIndex);\r\n                let scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\r\n\r\n                if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, DataViewScopeIdentity.equals))\r\n                    scopeIds.push(scopeId);\r\n\r\n                startIndex += valueCount;\r\n                endIndex += valueCount;\r\n            }\r\n\r\n            return {\r\n                isNot: this.isNot,\r\n                scopeIds: scopeIds,\r\n            };\r\n        }\r\n\r\n        private static getScopeIdentity(fieldExprs: SQExpr[], valueExprs: SQExpr[]): DataViewScopeIdentity {\r\n            debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\r\n            debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\r\n\r\n            let compoundSQExpr: SQExpr;\r\n            for (let i = 0, len = fieldExprs.length; i < len; i++) {\r\n                let equalsExpr = SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\r\n                if (!compoundSQExpr)\r\n                    compoundSQExpr = equalsExpr;\r\n                else\r\n                    compoundSQExpr = SQExprBuilder.and(compoundSQExpr, equalsExpr);\r\n            }\r\n\r\n            return createDataViewScopeIdentity(compoundSQExpr);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): boolean {\r\n            if (!this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isNot = true;\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): boolean {\r\n            if (this.isRoot && expr.type.primitiveType === PrimitiveType.Null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);            \r\n            return true;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n\r\n            if (expr.comparison !== QueryComparisonKind.Equal)\r\n                return this.unsupportedSQExpr();\r\n\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): boolean {\r\n            this.keyExprsCount = 0;\r\n            let result: boolean;\r\n            this.isRoot = false;\r\n            for (let arg of expr.args) {\r\n                result = arg.accept(this);\r\n                if (!result)\r\n                    return this.unsupportedSQExpr();\r\n\r\n                this.keyExprsCount++;\r\n            }\r\n\r\n            if (this.keyExprsCount !== this.fieldExprs.length)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let values = expr.values;\r\n            for (let valueTuple of values) {\r\n                let jlen = valueTuple.length;\r\n                debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\r\n\r\n                for (let value of valueTuple) {\r\n                    result = value.accept(this);\r\n                    if (!result)\r\n                        return this.unsupportedSQExpr();\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): boolean {\r\n            if (this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let fixedExpr = SQExprBuilder.removeEntityVariables(expr);\r\n            if (this.keyExprsCount !== null)\r\n                return SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\r\n\r\n            return SQExpr.equals(this.fieldExprs[0], fixedExpr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): boolean {\r\n            return this.unsupportedSQExpr();\r\n        }\r\n\r\n        private unsupportedSQExpr(): boolean {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    class FindComparandVisitor extends DefaultSQExprVisitor<SQConstantExpr> {\r\n        public visitAnd(expr: SQAndExpr): SQConstantExpr {\r\n            return expr.left.accept(this) || expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQConstantExpr {\r\n            if (expr.comparison === QueryComparisonKind.Equal) {\r\n                if (expr.right instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.right;\r\n                if (expr.left instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.left;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\r\n    export module ScopeIdentityExtractor {\r\n        export function getKeys(expr: SQExpr): SQExpr[] {\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return null;\r\n\r\n            return ArrayExtensions.emptyToNull(extractor.keys);\r\n        }\r\n\r\n        export function getInExpr(expr: SQExpr): SQInExpr{\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return;\r\n            \r\n            let keys = ArrayExtensions.emptyToNull(extractor.keys);\r\n            let keyValues = ArrayExtensions.emptyToNull(extractor.values);\r\n\r\n            if (keys && keyValues)\r\n                return data.SQExprBuilder.inExpr(keys, [keyValues]);\r\n        }\r\n\r\n        /**\r\n         * Recognizes expressions of the form:\r\n         * 1) Equals(ColRef, Constant)\r\n         * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\r\n         * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\r\n         */\r\n        class ScopeIdExtractorImpl extends DefaultSQExprVisitor<void> {\r\n            public keys: SQExpr[] = [];\r\n            public values: SQConstantExpr[] = [];\r\n            public malformed: boolean;\r\n\r\n            public visitAnd(expr: SQAndExpr): void {\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): void {\r\n                if (expr.comparison !== QueryComparisonKind.Equal) {\r\n                    this.visitDefault(expr);\r\n                    return;\r\n                }\r\n                debug.assert(expr.left instanceof SQExpr && expr.right instanceof SQConstantExpr, 'invalid compare expr operands');\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): void {\r\n                this.values.push(expr);\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): void {\r\n                this.malformed = true;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module PrimitiveValueEncoding {\r\n        const SingleQuoteRegex = /'/g;\r\n\r\n        export function decimal(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'M';\r\n        }\r\n\r\n        export function double(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'D';\r\n        }\r\n\r\n        export function integer(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'L';\r\n        }\r\n\r\n        export function dateTime(value: Date): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\r\n            // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\r\n            // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\r\n            let date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\r\n            let dateTimeString = date.toISOString();\r\n\r\n            // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\r\n            // we will drop it.\r\n            // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\r\n            if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\r\n                dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\r\n            return \"datetime'\" + dateTimeString + \"'\";\r\n        }\r\n\r\n        export function text(value: string): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\r\n        }\r\n\r\n        export function nullEncoding(): string {\r\n            return 'null';\r\n        }\r\n\r\n        export function boolean(value: boolean): string {\r\n            return value ? 'true' : 'false';\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Agg = powerbi.data.QueryAggregateFunction;\r\n\r\n    export interface ISQAggregationOperations {\r\n        /** Returns an array of supported aggregates for a given expr and role type. */\r\n        getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[];\r\n\r\n        isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean;\r\n\r\n        createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr;\r\n    }\r\n\r\n    export function createSQAggregationOperations(datetimeMinMaxSupported: boolean): ISQAggregationOperations {\r\n        return new SQAggregationOperations(datetimeMinMaxSupported);\r\n    }\r\n\r\n    class SQAggregationOperations implements ISQAggregationOperations {\r\n        constructor(private datetimeMinMaxSupported: boolean) {\r\n        }\r\n\r\n        public getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[] {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertAnyValue(targetTypes, 'targetTypes');\r\n\r\n            let metadata = getMetadataForUnderlyingType(expr, schema);\r\n\r\n            // don't use expr.validate as validate will be using this function and we end up in a recursive loop\r\n            if (!metadata)\r\n                return [];\r\n\r\n            let valueType = metadata.type,\r\n                fieldKind = metadata.kind,\r\n                isPropertyIdentity = metadata.idOnEntityKey;\r\n\r\n            if (!valueType)\r\n                return [];\r\n\r\n            // Cannot aggregate on model measures\r\n            if (fieldKind === FieldKind.Measure)\r\n                return [];\r\n\r\n            if (valueType.numeric || valueType.integer) {\r\n                let aggregates = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                let currentSchema = schema.schema(fieldExprItem.schema);\r\n                if (currentSchema.capabilities.supportsMedian)\r\n                    aggregates.push(Agg.Median);\r\n\r\n                return aggregates;\r\n            }\r\n\r\n            let aggregates: QueryAggregateFunction[] = [];\r\n\r\n            // Min/Max of DateTime\r\n            if (this.datetimeMinMaxSupported &&\r\n                valueType.dateTime &&\r\n                (_.isEmpty(targetTypes) || ValueType.isCompatibleTo(valueType, targetTypes))) {\r\n                aggregates.push(Agg.Min);\r\n                aggregates.push(Agg.Max);\r\n            }\r\n\r\n            // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\r\n            // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\r\n            let distinctCountAggExists = SQExprInfo.getAggregate(expr) === Agg.Count;\r\n            if (!(isPropertyIdentity && !distinctCountAggExists))\r\n                aggregates.push(Agg.Count);\r\n\r\n            aggregates.push(Agg.CountNonNull);\r\n\r\n            return aggregates;\r\n        }\r\n\r\n        public isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\r\n            return _.contains(supportedAggregates, aggregate);\r\n        }\r\n\r\n        public createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n            if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\r\n                aggregate = preferredAggregate;\r\n            }\r\n            else {\r\n                aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\r\n            }\r\n            if (aggregate !== undefined)\r\n                expr = SQExprBuilder.aggregate(expr, aggregate);\r\n\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    function getMetadataForUnderlyingType(expr: SQExpr, schema: FederatedConceptualSchema): SQExprMetadata {\r\n        // Unwrap the aggregate (if the expr has one), and look at the underlying type.\r\n        let metadata = SQExprBuilder.removeAggregate(expr).getMetadata(schema);\r\n\r\n        if (!metadata)\r\n            metadata = expr.getMetadata(schema);\r\n\r\n        return metadata;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module SQHierarchyExprUtils {\r\n        export function getConceptualHierarchyLevelFromExpr(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            fieldExpr: FieldExprPattern): ConceptualHierarchyLevel {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            let hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\r\n            if (hierarchyLevel)\r\n                return SQHierarchyExprUtils.getConceptualHierarchyLevel(\r\n                    conceptualSchema,\r\n                    fieldExprItem.schema,\r\n                    fieldExprItem.entity,\r\n                    hierarchyLevel.name,\r\n                    hierarchyLevel.level);\r\n        }\r\n\r\n        export function getConceptualHierarchyLevel(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            schemaName: string,\r\n            entity: string,\r\n            hierarchy: string,\r\n            hierarchyLevel: string): ConceptualHierarchyLevel {\r\n\r\n            let schema = conceptualSchema.schema(schemaName);\r\n            let conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\r\n            if (conceptualHierarchy) {\r\n                return conceptualHierarchy.levels.withName(hierarchyLevel);\r\n            }\r\n        }\r\n\r\n        export function getConceptualHierarchy(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): ConceptualHierarchy {\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchy = <SQHierarchyExpr>sqExpr;\r\n\r\n                if (sqExpr.arg instanceof SQEntityExpr) {\r\n                    let entityExpr = <SQEntityExpr>sqExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(entityExpr.schema)\r\n                        .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\r\n                } else if (sqExpr.arg instanceof SQPropertyVariationSourceExpr) {\r\n                    let variationExpr = <SQPropertyVariationSourceExpr>sqExpr.arg;\r\n                    let sourceEntityExpr = <SQEntityExpr>variationExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(sourceEntityExpr.schema)\r\n                        .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function expandExpr(schema: FederatedConceptualSchema, expr: SQExpr, suppressHierarchyLevelExpansion?: boolean): SQExpr | SQExpr[] {\r\n            return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\r\n                SQExprVariationConverter.expand(expr, schema) ||\r\n                // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\r\n                (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\r\n                expr;\r\n        }\r\n\r\n        export function isHierarchyOrVariation(schema: FederatedConceptualSchema, expr: SQExpr): boolean {\r\n            if (expr instanceof SQHierarchyExpr || expr instanceof SQHierarchyLevelExpr)\r\n                return true;\r\n\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Return column reference expression for hierarchy level expression.\r\n        export function getSourceVariationExpr(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\r\n\r\n                return SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\r\n            }\r\n        }\r\n\r\n        // Return hierarchy expression for hierarchy level expression.\r\n        export function getSourceHierarchy(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQHierarchyExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            let hierarchyLevel = fieldExprPattern.hierarchyLevel;\r\n            if (hierarchyLevel) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\r\n                return SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\r\n            }\r\n        }\r\n\r\n        export function getHierarchySourceAsVariationSource(hierarchyLevelExpr: SQHierarchyLevelExpr): SQPropertyVariationSourceExpr {\r\n\r\n            // Make sure the hierarchy level source is a hierarchy\r\n            if (!(hierarchyLevelExpr.arg instanceof SQHierarchyExpr))\r\n                return;\r\n                        \r\n            // Check if the hierarchy source if a variation\r\n            let hierarchyRef = <SQHierarchyExpr>hierarchyLevelExpr.arg;\r\n            if (hierarchyRef.arg instanceof SQPropertyVariationSourceExpr)\r\n                return <SQPropertyVariationSourceExpr>hierarchyRef.arg;\r\n        }\r\n\r\n        /**\r\n        * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\r\n        */\r\n        export function areHierarchyLevelsOrdered(allLevels: SQHierarchyLevelExpr[], firstExpr: SQExpr, secondExpr: SQExpr): boolean {\r\n\r\n            // Validate that both items hierarchy levels\r\n            if (!(firstExpr instanceof SQHierarchyLevelExpr) || !(secondExpr instanceof SQHierarchyLevelExpr))\r\n                return false;\r\n\r\n            let firstLevel = <SQHierarchyLevelExpr>firstExpr;\r\n            let secondLevel = <SQHierarchyLevelExpr>secondExpr;\r\n\r\n            // Validate that both items belong to the same hierarchy\r\n            if (!SQExpr.equals(firstLevel.arg, secondLevel.arg))\r\n                return false;\r\n\r\n            // Determine the order\r\n            let firstIndex = SQExprUtils.indexOfExpr(allLevels, firstLevel);\r\n            let secondIndex = SQExprUtils.indexOfExpr(allLevels, secondLevel);\r\n\r\n            return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\r\n        }\r\n\r\n        /**\r\n         * Given an ordered set of levels and an ordered subset of those levels, returns the index where\r\n         * expr should be inserted into the subset to maintain the correct order.\r\n         */\r\n        export function getInsertionIndex(allLevels: SQHierarchyLevelExpr[], orderedSubsetOfLevels: SQHierarchyLevelExpr[], expr: SQHierarchyLevelExpr): number {\r\n\r\n            let insertIndex = 0;\r\n\r\n            // Loop through the supplied levels until the insertion would no longer be in the correct order\r\n            while (insertIndex < orderedSubsetOfLevels.length &&\r\n                areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\r\n                insertIndex++;\r\n            }\r\n\r\n            return insertIndex;\r\n        }\r\n    }\r\n\r\n    export module SQExprHierarchyToHierarchyLevelConverter {\r\n        export function convert(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(sqExpr, 'sqExpr');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchyExpr = <SQHierarchyExpr>sqExpr;\r\n\r\n                let conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\r\n                if (conceptualHierarchy)\r\n                    return _.map(conceptualHierarchy.levels, hierarchyLevel => SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name));\r\n            }\r\n        }\r\n    }\r\n\r\n    module SQExprHierarchyLevelConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n            let exprs: SQExpr[] = [];\r\n\r\n            if (expr instanceof SQHierarchyLevelExpr) {\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                if (fieldExpr.hierarchyLevel) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                    let hierarchy = schema\r\n                        .schema(fieldExprItem.schema)\r\n                        .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\r\n\r\n                    if (hierarchy) {\r\n                        let hierarchyLevels = hierarchy.levels;\r\n                        for (let hierarchyLevel of hierarchyLevels) {\r\n                            if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\r\n                                exprs.push(expr);\r\n                                break;\r\n                            }\r\n                            else\r\n                                exprs.push(\r\n                                    SQExprBuilder.hierarchyLevel(\r\n                                        SQExprBuilder.hierarchy(\r\n                                            SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                            hierarchy.name),\r\n                                        hierarchyLevel.name)\r\n                                );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return exprs;\r\n        }\r\n    }\r\n\r\n    module SQExprVariationConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n\r\n            let exprs: SQExpr[];\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0) {\r\n                    let variations = column.variations;\r\n\r\n                    // for SU11, we support only one variation\r\n                    debug.assert(variations.length === 1, \"variations.length\");\r\n                    let variation = variations[0];\r\n\r\n                    let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                    exprs = [];\r\n                    if (variation.defaultHierarchy) {\r\n                        let hierarchyExpr = SQExprBuilder.hierarchy(\r\n                            SQExprBuilder.propertyVariationSource(\r\n                                SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                variation.name, conceptualProperty.name),\r\n                            variation.defaultHierarchy.name);\r\n\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            exprs.push(SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\r\n                    }\r\n                }\r\n            }\r\n\r\n            return exprs;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    // A group can consist of either a single expression, or a collection of hierarchy expressions\r\n    export interface SQExprGroup {\r\n        expr: SQExpr;\r\n        children: SQHierarchyLevelExpr[];\r\n\r\n        /** Index of expression in the query. */\r\n        selectQueryIndex: number;\r\n    };\r\n\r\n    export module SQExprGroupUtils {\r\n        /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\r\n        export function groupExprs(schema: FederatedConceptualSchema, exprs: SQExpr[]): SQExprGroup[] {\r\n            let groups: SQExprGroup[] = [];\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i];\r\n                debug.assertValue(expr, \"Expression not found\");\r\n\r\n                if (!(expr instanceof SQHierarchyLevelExpr)) {\r\n                    groups.push({ expr: expr, children: null, selectQueryIndex: i });\r\n                }\r\n                else {\r\n                    addChildToGroup(schema, groups, expr, i);\r\n                }\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function addChildToGroup(\r\n            schema: FederatedConceptualSchema,\r\n            groups: SQExprGroup[],\r\n            expr: SQHierarchyLevelExpr,\r\n            selectQueryIndex: number): void {\r\n\r\n            // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \r\n            // a new Group or to the last Group\r\n            let shouldAddExpressionToNewGroup = true;\r\n            let exprSource = SQHierarchyExprUtils.getSourceVariationExpr(expr) || SQHierarchyExprUtils.getSourceHierarchy(expr);\r\n            let lastGroup = _.last(groups);\r\n\r\n            // The relevant group is always the last added. If it has the same source hierarchy,\r\n            // and is properly ordered within that hierarchy, we will need to add to this group.\r\n            if (lastGroup && lastGroup.children && SQExpr.equals(lastGroup.expr, exprSource)) {\r\n                let expandedExpr = SQHierarchyExprUtils.expandExpr(schema, expr.arg);\r\n                if (expandedExpr instanceof Array) {\r\n                    let allHierarchyLevels = <SQHierarchyLevelExpr[]>expandedExpr;\r\n                    shouldAddExpressionToNewGroup = !SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\r\n                }\r\n            }\r\n\r\n            if (shouldAddExpressionToNewGroup)\r\n                // Use the Sourcevariation as the expression for the group.\r\n                groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\r\n            else {\r\n                debug.assertValue(lastGroup, 'There should be a group to add the variation to');\r\n                debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\r\n                lastGroup.children.push(expr);\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    /** Represents an immutable expression within a SemanticQuery. */\r\n    export abstract class SQExpr implements ISQExpr {\r\n        private _kind: SQExprKind;\r\n\r\n        constructor(kind: SQExprKind) {\r\n            debug.assertValue(kind, 'kind');\r\n\r\n            this._kind = kind;\r\n        }\r\n\r\n        public static equals(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            return SQExprEqualityVisitor.run(x, y, ignoreCase);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.accept(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            debug.assertFail('abstract method');\r\n            return;\r\n        }\r\n\r\n        public get kind(): SQExprKind {\r\n            return this._kind;\r\n        }\r\n\r\n        public static isColumn(expr: SQExpr): expr is SQColumnRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ColumnRef;\r\n        }\r\n\r\n        public static isConstant(expr: SQExpr): expr is SQConstantExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Constant;\r\n        }\r\n\r\n        public static isEntity(expr: SQExpr): expr is SQEntityExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Entity;\r\n        }\r\n\r\n        public static isHierarchy(expr: SQExpr): expr is SQHierarchyExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Hierarchy;\r\n        }\r\n\r\n        public static isHierarchyLevel(expr: SQExpr): expr is SQHierarchyLevelExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.HierarchyLevel;\r\n        }\r\n\r\n        public static isAggregation(expr: SQExpr): expr is SQAggregationExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Aggregation;\r\n        }\r\n\r\n        public static isMeasure(expr: SQExpr): expr is SQMeasureRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.MeasureRef;\r\n        }\r\n\r\n        public static isResourcePackageItem(expr: SQExpr): expr is SQResourcePackageItemExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ResourcePackageItem;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            if (field.column || field.columnAggr || field.measure)\r\n                return this.getMetadataForProperty(field, federatedSchema);\r\n\r\n            if (field.hierarchyLevel || field.hierarchyLevelAggr)\r\n                return this.getMetadataForHierarchyLevel(field, federatedSchema);\r\n\r\n            if (field.columnHierarchyLevelVariation)\r\n                return this.getMetadataForVariation(field, federatedSchema);\r\n\r\n            return SQExpr.getMetadataForEntity(field, federatedSchema);\r\n        }\r\n\r\n        public getDefaultAggregate(federatedSchema: FederatedConceptualSchema, forceAggregation: boolean = false): QueryAggregateFunction {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n\r\n            if (property && property.kind === ConceptualPropertyKind.Column) {\r\n                let propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\r\n\r\n                if ((property.type.integer || property.type.numeric) &&\r\n                    propertyDefaultAggregate !== ConceptualDefaultAggregate.None) {\r\n                    aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\r\n                    if (aggregate === undefined)\r\n                        aggregate = defaultAggregateForDataType(property.type);\r\n                }\r\n\r\n                // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \r\n                // aggregate on CountNonNull.\r\n                if (aggregate === undefined && forceAggregation) {\r\n                    aggregate = QueryAggregateFunction.CountNonNull;\r\n                }\r\n            }\r\n\r\n            return aggregate;\r\n        }\r\n\r\n        /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\r\n        public getKeyColumns(schema: FederatedConceptualSchema): SQExpr[] {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n\r\n            let keySQExprs: SQExpr[] = [];\r\n            let keys = this.getPropertyKeys(schema);\r\n            if (keys && keys.length > 0) {\r\n                for (let i = 0, len = keys.length; i < len; i++) {\r\n                    keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\r\n                }\r\n            }\r\n            else\r\n                keySQExprs.push(columnRefExpr);\r\n\r\n            return keySQExprs;\r\n        }\r\n\r\n        /** Returns a value indicating whether the expression would group on keys other than itself.*/\r\n        public hasGroupOnKeys(schema: FederatedConceptualSchema): boolean {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n            let keys = this.getPropertyKeys(schema);\r\n\r\n            if (!keys || keys.length < 1)\r\n                return false;\r\n\r\n            if (keys.length > 1)\r\n                return true;\r\n\r\n            let keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\r\n            return !SQExpr.equals(keySqExpr, this);\r\n        }\r\n\r\n        private getPropertyKeys(schema: FederatedConceptualSchema): jsCommon.ArrayNamedItems<ConceptualProperty> {\r\n            let property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            return property.column ? property.column.keys : undefined;\r\n        }\r\n\r\n        public getConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let propertyName = FieldExprPattern.getPropertyName(field);\r\n\r\n            if (propertyName)\r\n                return federatedSchema\r\n                    .schema(fieldExprItem.schema)\r\n                    .findProperty(fieldExprItem.entity, propertyName);\r\n        }\r\n\r\n        public getTargetEntityForVariation(federatedSchema: FederatedConceptualSchema, variationName: string): string {\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (property && property.column && !_.isEmpty(property.column.variations)) {\r\n                let variations = property.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === variationName)\r\n                        return variation.navigationProperty.targetEntity.name;\r\n            }\r\n        }\r\n\r\n        public getTargetEntity(federatedSchema: FederatedConceptualSchema): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\r\n        }\r\n\r\n        private getHierarchyLevelConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\r\n            if (fieldExprHierachyLevel) {\r\n                let fieldExprEntity = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n\r\n                let hierarchy = federatedSchema\r\n                    .schema(fieldExprEntity.schema)\r\n                    .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\r\n\r\n                if (hierarchy) {\r\n                    let hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\r\n                    if (hierarchyLevel)\r\n                        return hierarchyLevel.column;\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForVariation(field: data.FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let sourceProperty = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\r\n\r\n            if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\r\n                for (let variation of sourceProperty.column.variations) {\r\n                    if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\r\n                        for (let level of variation.defaultHierarchy.levels) {\r\n                            if (level.name === columnHierarchyLevelVariation.level.level) {\r\n                                let property = level.column;\r\n                                return {\r\n                                    kind: (property.kind === ConceptualPropertyKind.Measure) ? FieldKind.Measure : FieldKind.Column,\r\n                                    type: property.type,\r\n                                    format: property.format,\r\n                                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                                    defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n                                };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForHierarchyLevel(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private getPropertyMetadata(field: FieldExprPattern, property: ConceptualProperty): SQExprMetadata {\r\n            let format = property.format;\r\n            let type = property.type;\r\n            let columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\r\n\r\n            if (columnAggregate) {\r\n                switch (columnAggregate.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        type = ValueType.fromExtendedType(ExtendedType.Integer);\r\n                        format = undefined;\r\n                        break;\r\n                    case QueryAggregateFunction.Avg:\r\n                        if (type.integer)\r\n                            type = ValueType.fromExtendedType(ExtendedType.Double);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return {\r\n                kind: (property.kind === ConceptualPropertyKind.Measure || (columnAggregate && columnAggregate.aggregate !== undefined)) ? FieldKind.Measure : FieldKind.Column,\r\n                type: type,\r\n                format: format,\r\n                idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\r\n                defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n            };\r\n        }\r\n\r\n        private getMetadataForProperty(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private static getMetadataForEntity(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let entity = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .entities\r\n                .withName(fieldExprItem.entity);\r\n\r\n            if (!entity)\r\n                return;\r\n\r\n            // We only support count and countnonnull for entity.\r\n            if (field.entityAggr) {\r\n                switch (field.entityAggr.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        return {\r\n                            kind: FieldKind.Measure,\r\n                            type: ValueType.fromExtendedType(ExtendedType.Integer),\r\n                            format: undefined,\r\n                            idOnEntityKey: false,\r\n                            aggregate: field.entityAggr.aggregate\r\n                        };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export const enum SQExprKind {\r\n        Entity,\r\n        ColumnRef,\r\n        MeasureRef,\r\n        Aggregation,\r\n        PropertyVariationSource,\r\n        Hierarchy,\r\n        HierarchyLevel,\r\n        And,\r\n        Between,\r\n        In,\r\n        Or,\r\n        Contains,\r\n        Compare,\r\n        StartsWith,\r\n        Exists,\r\n        Not,\r\n        Constant,\r\n        DateSpan,\r\n        DateAdd,\r\n        Now,\r\n        AnyValue,\r\n        DefaultValue,\r\n        Arithmetic,\r\n        FillRule,\r\n        ResourcePackageItem,\r\n        ScopedEval,\r\n        Scope,\r\n    }\r\n\r\n    export interface SQExprMetadata {\r\n        kind: FieldKind;\r\n        type: ValueType;\r\n        format?: string;\r\n        idOnEntityKey?: boolean;\r\n        aggregate?: QueryAggregateFunction;\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n    }\r\n\r\n    export const enum FieldKind {\r\n        /** Indicates the field references a column, which evaluates to a distinct set of values (e.g., Year, Name, SalesQuantity, etc.). */\r\n        Column,\r\n\r\n        /** Indicates the field references a measure, which evaluates to a single value (e.g., SalesYTD, Sum(Sales), etc.). */\r\n        Measure,\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateForDataType(type: ValueType): QueryAggregateFunction {\r\n        if (type.integer || type.numeric)\r\n            return QueryAggregateFunction.Sum;\r\n\r\n        return QueryAggregateFunction.Count;\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateToQueryAggregateFunction(aggregate: ConceptualDefaultAggregate): QueryAggregateFunction {\r\n        switch (aggregate) {\r\n            case ConceptualDefaultAggregate.Average:\r\n                return QueryAggregateFunction.Avg;\r\n            case ConceptualDefaultAggregate.Count:\r\n                return QueryAggregateFunction.CountNonNull;\r\n            case ConceptualDefaultAggregate.DistinctCount:\r\n                return QueryAggregateFunction.Count;\r\n            case ConceptualDefaultAggregate.Max:\r\n                return QueryAggregateFunction.Max;\r\n            case ConceptualDefaultAggregate.Min:\r\n                return QueryAggregateFunction.Min;\r\n            case ConceptualDefaultAggregate.Sum:\r\n                return QueryAggregateFunction.Sum;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    export class SQEntityExpr extends SQExpr {\r\n        public schema: string;\r\n        public entity: string;\r\n        public variable: string;\r\n\r\n        constructor(schema: string, entity: string, variable?: string) {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            super(SQExprKind.Entity);\r\n            this.schema = schema;\r\n            this.entity = entity;\r\n            if (variable)\r\n                this.variable = variable;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitEntity(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQArithmeticExpr extends SQExpr {\r\n        public left: SQExpr;\r\n        public right: SQExpr;\r\n        public operator: ArithmeticOperatorKind;\r\n\r\n        constructor(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n            debug.assertValue(operator, 'operator');\r\n\r\n            super(SQExprKind.Arithmetic);\r\n            this.left = left;\r\n            this.right = right;\r\n            this.operator = operator;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitArithmetic(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQScopedEvalExpr extends SQExpr {\r\n        public expression: SQExpr;\r\n        public scope: SQExpr[];\r\n\r\n        constructor(expression: SQExpr, scope: SQExpr[]) {\r\n            debug.assertValue(expression, 'expression');\r\n            debug.assertValue(scope, 'scope');\r\n\r\n            super(SQExprKind.ScopedEval);\r\n            this.expression = expression;\r\n            this.scope = scope;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitScopedEval(this, arg);\r\n        }\r\n    }\r\n\r\n    export abstract class SQPropRefExpr extends SQExpr {\r\n        public ref: string;\r\n        public source: SQExpr;\r\n\r\n        constructor(kind: SQExprKind, source: SQExpr, ref: string) {\r\n            debug.assertValue(kind, 'kind');\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            super(kind);\r\n            this.source = source;\r\n            this.ref = ref;\r\n        }\r\n    }\r\n\r\n    export class SQColumnRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.ColumnRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitColumnRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQMeasureRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.MeasureRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitMeasureRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAggregationExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public func: QueryAggregateFunction;\r\n\r\n        constructor(arg: SQExpr, func: QueryAggregateFunction) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(func, 'func');\r\n\r\n            super(SQExprKind.Aggregation);\r\n            this.arg = arg;\r\n            this.func = func;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAggr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPropertyVariationSourceExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public name: string;\r\n        public property: string;\r\n\r\n        constructor(arg: SQExpr, name: string, property: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(name, 'name');\r\n            debug.assertValue(property, 'property');\r\n\r\n            super(SQExprKind.PropertyVariationSource);\r\n            this.arg = arg;\r\n            this.name = name;\r\n            this.property = property;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPropertyVariationSource(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public hierarchy: string;\r\n\r\n        constructor(arg: SQExpr, hierarchy: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n\r\n            super(SQExprKind.Hierarchy);\r\n            this.arg = arg;\r\n            this.hierarchy = hierarchy;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchy(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyLevelExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public level: string;\r\n\r\n        constructor(arg: SQExpr, level: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(level, 'level');\r\n\r\n            super(SQExprKind.HierarchyLevel);\r\n            this.arg = arg;\r\n            this.level = level;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchyLevel(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAndExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.And);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQBetweenExpr extends SQExpr {\r\n        arg: SQExpr;\r\n        lower: SQExpr;\r\n        upper: SQExpr;\r\n\r\n        constructor(arg: SQExpr, lower: SQExpr, upper: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(lower, 'lower');\r\n            debug.assertValue(upper, 'upper');\r\n\r\n            super(SQExprKind.Between);\r\n            this.arg = arg;\r\n            this.lower = lower;\r\n            this.upper = upper;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitBetween(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQInExpr extends SQExpr {\r\n        args: SQExpr[];\r\n        values: SQExpr[][];\r\n\r\n        constructor(args: SQExpr[], values: SQExpr[][]) {\r\n            debug.assertValue(args, 'args');\r\n            debug.assertValue(values, 'values');\r\n\r\n            super(SQExprKind.In);\r\n            this.args = args;\r\n            this.values = values;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitIn(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQOrExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Or);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitOr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQCompareExpr extends SQExpr {\r\n        comparison: QueryComparisonKind;\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(comparison: QueryComparisonKind, left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(comparison, 'kind');\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Compare);\r\n            this.comparison = comparison;\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitCompare(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQContainsExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Contains);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitContains(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQStartsWithExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.StartsWith);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitStartsWith(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQExistsExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Exists);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitExists(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNotExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Not);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNot(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQConstantExpr extends SQExpr implements ISQConstantExpr {\r\n        public type: ValueType;\r\n\r\n        /** The native JavaScript representation of the value. */\r\n        public value: any;\r\n\r\n        /** The string encoded, lossless representation of the value. */\r\n        public valueEncoded: string;\r\n\r\n        constructor(type: ValueType, value: any, valueEncoded: string) {\r\n            debug.assertValue(type, 'type');\r\n\r\n            super(SQExprKind.Constant);\r\n            this.type = type;\r\n            this.value = value;\r\n            this.valueEncoded = valueEncoded;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitConstant(this, arg);\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            return {\r\n                // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\r\n                // A getType or similiar function in the future would be more appropriate. \r\n                kind: FieldKind.Measure,\r\n                type: this.type,\r\n            };\r\n        }\r\n    }\r\n\r\n    export class SQDateSpanExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateSpan);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateSpan(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDateAddExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public amount: number;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, amount: number, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(amount, 'amount');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateAdd);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n            this.amount = amount;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateAdd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNowExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.Now);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNow(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDefaultValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.DefaultValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDefaultValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAnyValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.AnyValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnyValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQFillRuleExpr extends SQExpr {\r\n        public input: SQExpr;\r\n        public rule: FillRuleDefinition;\r\n\r\n        constructor(\r\n            input: SQExpr,\r\n            fillRule: FillRuleDefinition) {\r\n            debug.assertValue(input, 'input');\r\n            debug.assertValue(fillRule, 'fillRule');\r\n\r\n            super(SQExprKind.FillRule);\r\n            this.input = input;\r\n            this.rule = fillRule;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitFillRule(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQResourcePackageItemExpr extends SQExpr {\r\n        public packageName: string;\r\n        public packageType: number;\r\n        public itemName: string;\r\n\r\n        constructor(packageName: string, packageType: number, itemName: string) {\r\n            debug.assertValue(packageName, 'packageName');\r\n            debug.assertValue(itemName, 'itemName');\r\n\r\n            super(SQExprKind.ResourcePackageItem);\r\n            this.packageName = packageName;\r\n            this.packageType = packageType;\r\n            this.itemName = itemName;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitResourcePackageItem(this, arg);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for creating & manipulating expressions. */\r\n    export module SQExprBuilder {\r\n        export function entity(schema: string, entity: string, variable?: string): SQEntityExpr {\r\n            return new SQEntityExpr(schema, entity, variable);\r\n        }\r\n\r\n        export function columnRef(source: SQExpr, prop: string): SQColumnRefExpr {\r\n            return new SQColumnRefExpr(source, prop);\r\n        }\r\n\r\n        export function measureRef(source: SQExpr, prop: string): SQMeasureRefExpr {\r\n            return new SQMeasureRefExpr(source, prop);\r\n        }\r\n\r\n        export function aggregate(source: SQExpr, aggregate: QueryAggregateFunction): SQAggregationExpr {\r\n            return new SQAggregationExpr(source, aggregate);\r\n        }\r\n\r\n        export function hierarchy(source: SQExpr, hierarchy: string): SQHierarchyExpr {\r\n            return new SQHierarchyExpr(source, hierarchy);\r\n        }\r\n\r\n        export function propertyVariationSource(source: SQExpr, name: string, property: string): SQPropertyVariationSourceExpr {\r\n            return new SQPropertyVariationSourceExpr(source, name, property);\r\n        }\r\n\r\n        export function hierarchyLevel(source: SQExpr, level: string): SQHierarchyLevelExpr {\r\n            return new SQHierarchyLevelExpr(source, level);\r\n        }\r\n\r\n        export function and(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n\r\n            return new SQAndExpr(left, right);\r\n        }\r\n\r\n        export function between(arg: SQExpr, lower: SQExpr, upper: SQExpr): SQBetweenExpr {\r\n            return new SQBetweenExpr(arg, lower, upper);\r\n        }\r\n\r\n        export function inExpr(args: SQExpr[], values: SQExpr[][]): SQInExpr {\r\n            return new SQInExpr(args, values);\r\n        }\r\n\r\n        export function or(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n            if (left instanceof SQInExpr && right instanceof SQInExpr) {\r\n                let inExpr = tryUseInExprs(<SQInExpr>left, <SQInExpr>right);\r\n                if (inExpr)\r\n                    return inExpr;\r\n            }\r\n\r\n            return new SQOrExpr(left, right);\r\n        }\r\n\r\n        function tryUseInExprs(left: SQInExpr, right: SQInExpr): SQInExpr {\r\n            if (!left.args || !right.args)\r\n                return;\r\n\r\n            let leftArgLen = left.args.length;\r\n            let rightArgLen = right.args.length;\r\n            if (leftArgLen !== rightArgLen)\r\n                return;\r\n\r\n            for (let i = 0; i < leftArgLen; ++i) {\r\n                if (!SQExpr.equals(left.args[i], right.args[i]))\r\n                    return;\r\n            }\r\n\r\n            let combinedValues = left.values.concat(right.values);\r\n            return SQExprBuilder.inExpr(left.args, combinedValues);\r\n        }\r\n\r\n        export function compare(kind: QueryComparisonKind, left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return new SQCompareExpr(kind, left, right);\r\n        }\r\n\r\n        export function contains(left: SQExpr, right: SQExpr): SQContainsExpr {\r\n            return new SQContainsExpr(left, right);\r\n        }\r\n\r\n        export function exists(arg: SQExpr): SQExistsExpr {\r\n            return new SQExistsExpr(arg);\r\n        }\r\n\r\n        export function equal(left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return compare(QueryComparisonKind.Equal, left, right);\r\n        }\r\n\r\n        export function not(arg: SQExpr): SQNotExpr {\r\n            return new SQNotExpr(arg);\r\n        }\r\n\r\n        export function startsWith(left: SQExpr, right: SQExpr): SQStartsWithExpr {\r\n            return new SQStartsWithExpr(left, right);\r\n        }\r\n\r\n        export function nullConstant(): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Null),\r\n                null,\r\n                PrimitiveValueEncoding.nullEncoding());\r\n        }\r\n\r\n        export function now(): SQNowExpr {\r\n            return new SQNowExpr();\r\n        }\r\n\r\n        export function defaultValue(): SQDefaultValueExpr {\r\n            return new SQDefaultValueExpr();\r\n        }\r\n\r\n        export function anyValue(): SQAnyValueExpr {\r\n            return new SQAnyValueExpr();\r\n        }\r\n\r\n        export function boolean(value: boolean): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Boolean),\r\n                value,\r\n                PrimitiveValueEncoding.boolean(value));\r\n        }\r\n\r\n        export function dateAdd(unit: TimeUnit, amount: number, arg: SQExpr): SQDateAddExpr {\r\n            return new SQDateAddExpr(unit, amount, arg);\r\n        }\r\n\r\n        export function dateTime(value: Date, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.dateTime(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.DateTime), value, valueEncoded);\r\n        }\r\n\r\n        export function dateSpan(unit: TimeUnit, arg: SQExpr): SQDateSpanExpr {\r\n            return new SQDateSpanExpr(unit, arg);\r\n        }\r\n\r\n        export function decimal(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.decimal(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Decimal), value, valueEncoded);\r\n        }\r\n\r\n        export function double(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.double(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Double), value, valueEncoded);\r\n        }\r\n\r\n        export function integer(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.integer(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Integer), value, valueEncoded);\r\n        }\r\n\r\n        export function text(value: string, valueEncoded?: string): SQConstantExpr {\r\n            debug.assert(!valueEncoded || valueEncoded === PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\r\n\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Text),\r\n                value,\r\n                valueEncoded || PrimitiveValueEncoding.text(value));\r\n        }\r\n\r\n        /** Returns an SQExpr that evaluates to the constant value. */\r\n        export function typedConstant(value: PrimitiveValue, type: ValueTypeDescriptor): SQConstantExpr {\r\n            if (value == null)\r\n                return nullConstant();\r\n\r\n            if (_.isBoolean(value)) {\r\n                return boolean(<boolean>value);\r\n            }\r\n\r\n            if (_.isString(value)) {\r\n                return text(<string>value);\r\n            }\r\n\r\n            if (_.isNumber(value)) {\r\n                if (type.integer && Double.isInteger(<number>value))\r\n                    return integer(<number>value);\r\n\r\n                return double(<number>value);\r\n            }\r\n\r\n            if (value instanceof Date) {\r\n                return dateTime(value);\r\n            }\r\n        }\r\n\r\n        export function arithmetic(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind): SQArithmeticExpr {\r\n            return new SQArithmeticExpr(left, right, operator);\r\n        }\r\n\r\n        export function scopedEval(expression: SQExpr, scope: SQExpr[]): SQScopedEvalExpr {\r\n            return new SQScopedEvalExpr(expression, scope);\r\n        }\r\n\r\n        export function setAggregate(expr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return SQExprChangeAggregateRewriter.rewrite(expr, aggregate);\r\n        }\r\n\r\n        export function removeAggregate(expr: SQExpr): SQExpr {\r\n            return SQExprRemoveAggregateRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removeEntityVariables(expr: SQExpr): SQExpr {\r\n            return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function fillRule(expr: SQExpr, rule: FillRuleDefinition): SQFillRuleExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(rule, 'rule');\r\n\r\n            return new SQFillRuleExpr(expr, rule);\r\n        }\r\n\r\n        export function resourcePackageItem(packageName: string, packageType: number, itemName: string): SQResourcePackageItemExpr {\r\n            return new SQResourcePackageItemExpr(packageName, packageType, itemName);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for obtaining information about expressions. */\r\n    export module SQExprInfo {\r\n        export function getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            return SQExprAggregateInfoVisitor.getAggregate(expr);\r\n        }\r\n    }\r\n\r\n    class SQExprEqualityVisitor implements ISQExprVisitorWithArg<boolean, SQExpr>, IFillRuleDefinitionVisitor<boolean, boolean> {\r\n        private static instance: SQExprEqualityVisitor = new SQExprEqualityVisitor(/* ignoreCase */ false);\r\n        private static ignoreCaseInstance: SQExprEqualityVisitor = new SQExprEqualityVisitor(true);\r\n        private ignoreCase: boolean;\r\n\r\n        public static run(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n            if (ignoreCase)\r\n                return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\r\n\r\n            return x.accept(SQExprEqualityVisitor.instance, y);\r\n        }\r\n\r\n        constructor(ignoreCase: boolean) {\r\n            this.ignoreCase = ignoreCase;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, comparand: SQColumnRefExpr): boolean {\r\n            return comparand instanceof SQColumnRefExpr &&\r\n                expr.ref === (<SQColumnRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQColumnRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, comparand: SQMeasureRefExpr): boolean {\r\n            return comparand instanceof SQMeasureRefExpr &&\r\n                expr.ref === (<SQMeasureRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQMeasureRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAggregationExpr &&\r\n                expr.func === (<SQAggregationExpr>comparand).func &&\r\n                this.equals(expr.arg, (<SQAggregationExpr>comparand).arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, comparand: SQHierarchyExpr): boolean {\r\n            return comparand instanceof SQHierarchyExpr &&\r\n                expr.hierarchy === comparand.hierarchy &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, comparand: SQHierarchyLevelExpr): boolean {\r\n            return comparand instanceof SQHierarchyLevelExpr &&\r\n                expr.level === comparand.level &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, comparand: SQPropertyVariationSourceExpr): boolean {\r\n            return comparand instanceof SQPropertyVariationSourceExpr &&\r\n                expr.name === comparand.name &&\r\n                expr.property === comparand.property &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQBetweenExpr &&\r\n                this.equals(expr.arg, (<SQBetweenExpr>comparand).arg) &&\r\n                this.equals(expr.lower, (<SQBetweenExpr>comparand).lower) &&\r\n                this.equals(expr.upper, (<SQBetweenExpr>comparand).upper);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, comparand: SQExpr): boolean {\r\n            if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, (<SQInExpr>comparand).args))\r\n                return false;\r\n\r\n            let values = expr.values,\r\n                compareValues = (<SQInExpr>comparand).values;\r\n            if (values.length !== compareValues.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                if (!this.equalsAll(values[i], compareValues[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQEntityExpr &&\r\n                expr.schema === (<SQEntityExpr>comparand).schema &&\r\n                expr.entity === (<SQEntityExpr>comparand).entity &&\r\n                this.optionalEqual(expr.variable, (<SQEntityExpr>comparand).variable);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAndExpr &&\r\n                this.equals(expr.left, (<SQAndExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQAndExpr>comparand).right);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQOrExpr &&\r\n                this.equals(expr.left, (<SQOrExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQOrExpr>comparand).right);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQCompareExpr &&\r\n                expr.comparison === (<SQCompareExpr>comparand).comparison &&\r\n                this.equals(expr.left, (<SQCompareExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQCompareExpr>comparand).right);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQContainsExpr &&\r\n                this.equals(expr.left, (<SQContainsExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQContainsExpr>comparand).right);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateSpanExpr &&\r\n                expr.unit === (<SQDateSpanExpr>comparand).unit &&\r\n                this.equals(expr.arg, (<SQDateSpanExpr>comparand).arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateAddExpr &&\r\n                expr.unit === (<SQDateAddExpr>comparand).unit &&\r\n                expr.amount === (<SQDateAddExpr>comparand).amount &&\r\n                this.equals(expr.arg, (<SQDateAddExpr>comparand).arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQExistsExpr &&\r\n                this.equals(expr.arg, (<SQExistsExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNotExpr &&\r\n                this.equals(expr.arg, (<SQNotExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNowExpr;\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDefaultValueExpr;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAnyValueExpr;\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQResourcePackageItemExpr &&\r\n                expr.packageName === comparand.packageName &&\r\n                expr.packageType === comparand.packageType &&\r\n                expr.itemName === comparand.itemName;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQStartsWithExpr &&\r\n                this.equals(expr.left, (<SQStartsWithExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQStartsWithExpr>comparand).right);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQConstantExpr && expr.type === (<SQConstantExpr>comparand).type)\r\n                return expr.type.text && this.ignoreCase ?\r\n                    StringExtensions.equalIgnoreCase(expr.valueEncoded, (<SQConstantExpr>comparand).valueEncoded) :\r\n                    expr.valueEncoded === (<SQConstantExpr>comparand).valueEncoded;\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\r\n                let leftRule = expr.rule,\r\n                    rightRule = comparand.rule;\r\n\r\n                if (leftRule === rightRule)\r\n                    return true;\r\n\r\n                let leftLinearGradient2 = leftRule.linearGradient2,\r\n                    rightLinearGradient2 = rightRule.linearGradient2;\r\n                if (leftLinearGradient2 && rightLinearGradient2) {\r\n                    return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\r\n                }\r\n\r\n                let leftLinearGradient3 = leftRule.linearGradient3,\r\n                    rightLinearGradient3 = rightRule.linearGradient3;\r\n                if (leftLinearGradient3 && rightLinearGradient3) {\r\n                    return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitLinearGradient2(left2: LinearGradient2Definition, right2: LinearGradient2Definition): boolean {\r\n            debug.assertValue(left2, 'left2');\r\n            debug.assertValue(right2, 'right2');\r\n\r\n            return this.equalsFillRuleStop(left2.min, right2.min) &&\r\n                this.equalsFillRuleStop(left2.max, right2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(left3: LinearGradient3Definition, right3: LinearGradient3Definition): boolean {\r\n            debug.assertValue(left3, 'left3');\r\n            debug.assertValue(right3, 'right3');\r\n\r\n            return this.equalsFillRuleStop(left3.min, right3.min) &&\r\n                this.equalsFillRuleStop(left3.mid, right3.mid) &&\r\n                this.equalsFillRuleStop(left3.max, right3.max);\r\n        }\r\n\r\n        private equalsFillRuleStop(stop1: RuleColorStopDefinition, stop2: RuleColorStopDefinition): boolean {\r\n            debug.assertValue(stop1, 'stop1');\r\n            debug.assertValue(stop2, 'stop2');\r\n\r\n            if (!this.equals(stop1.color, stop2.color))\r\n                return false;\r\n\r\n            if (!stop1.value)\r\n                return stop1.value === stop2.value;\r\n\r\n            return this.equals(stop1.value, stop2.value);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQArithmeticExpr &&\r\n                expr.operator === (<SQArithmeticExpr>comparand).operator &&\r\n                this.equals(expr.left, (<SQArithmeticExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQArithmeticExpr>comparand).right);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQScopedEvalExpr &&\r\n                this.equals(expr.expression, comparand.expression) &&\r\n                this.equalsAll(expr.scope, comparand.scope);\r\n        }\r\n\r\n        private optionalEqual(x: string, y: string) {\r\n            // Only check equality if both values are specified.\r\n            if (x && y)\r\n                return x === y;\r\n\r\n            return true;\r\n        }\r\n\r\n        private equals(x: SQExpr, y: SQExpr): boolean {\r\n            return x.accept(this, y);\r\n        }\r\n\r\n        private equalsAll(x: SQExpr[], y: SQExpr[]): boolean {\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!this.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /** Rewrites a root-level expression. */\r\n    class SQExprRootRewriter extends DefaultSQExprVisitor<SQExpr> {\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    export const enum SQExprValidationError {\r\n        invalidAggregateFunction,\r\n        invalidSchemaReference,\r\n        invalidEntityReference,\r\n        invalidColumnReference,\r\n        invalidMeasureReference,\r\n        invalidHierarchyReference,\r\n        invalidHierarchyLevelReference,\r\n        invalidLeftOperandType,\r\n        invalidRightOperandType,\r\n        invalidValueType,\r\n    }\r\n\r\n    export class SQExprValidationVisitor extends SQExprRewriter {\r\n        public errors: SQExprValidationError[];\r\n        private schema: FederatedConceptualSchema;\r\n        private aggrUtils: ISQAggregationOperations;\r\n\r\n        constructor(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]) {\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertValue(aggrUtils, 'aggrUtils');\r\n\r\n            super();\r\n            this.schema = schema;\r\n            this.aggrUtils = aggrUtils;\r\n            if (errors)\r\n                this.errors = errors;\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): SQExpr {\r\n            let inExpr = <SQInExpr>super.visitIn(expr);\r\n            let args = inExpr.args;\r\n            let values = inExpr.values;\r\n            for (let valueTuple of values) {\r\n                debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\r\n                for (let i = 0, len = valueTuple.length; i < len; ++i)\r\n                    this.validateCompatibleType(args[i], valueTuple[i]);\r\n            }\r\n\r\n            return inExpr;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQExpr {\r\n            let compareExpr = <SQCompareExpr>super.visitCompare(expr);\r\n            this.validateCompatibleType(compareExpr.left, compareExpr.right);\r\n\r\n            return compareExpr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.column.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Column ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidColumnReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.measure.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Measure ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidMeasureReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let aggregateExpr = <SQAggregationExpr>super.visitAggr(expr);\r\n\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\r\n            if (columnRefExpr) {\r\n                if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/null))\r\n                    this.register(SQExprValidationError.invalidAggregateFunction);\r\n            }\r\n\r\n            return aggregateExpr;\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem: FieldExprHierarchyPattern = <FieldExprHierarchyPattern>fieldExpr.hierarchy;\r\n                if (fieldExprItem) {\r\n                    this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\r\n                } else {\r\n                    this.register(SQExprValidationError.invalidHierarchyReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let hierarchyLevelFieldExprItem: FieldExprHierarchyLevelPattern = <FieldExprHierarchyLevelPattern>fieldExpr.hierarchyLevel;\r\n                if (hierarchyLevelFieldExprItem) {\r\n                    this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\r\n                } else if (!fieldExpr.columnHierarchyLevelVariation) {\r\n                    this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            this.validateEntity(expr.schema, expr.entity);\r\n            return expr;\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): SQExpr {\r\n            this.validateArithmeticTypes(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): SQExpr {\r\n            // No validation necessary\r\n            return expr;\r\n        }\r\n\r\n        private validateOperandsAndTypeForStartOrContains(left: SQExpr, right: SQExpr): void {\r\n            if (left instanceof SQColumnRefExpr) {\r\n                this.visitColumnRef(<SQColumnRefExpr>left);\r\n            } else if (left instanceof SQHierarchyLevelExpr) {\r\n                this.visitHierarchyLevel(<SQHierarchyLevelExpr>left);\r\n            } else {\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            }\r\n\r\n            if (!(right instanceof SQConstantExpr) || !(<SQConstantExpr>right).type.text)\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n            else\r\n                this.validateCompatibleType(left, right);\r\n        }\r\n\r\n        private validateArithmeticTypes(left: SQExpr, right: SQExpr): void {\r\n            if (!SQExprUtils.supportsArithmetic(left, this.schema))\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            if (!SQExprUtils.supportsArithmetic(right, this.schema))\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n        }\r\n\r\n        private validateCompatibleType(left: SQExpr, right: SQExpr): void {\r\n            let leftMetadata = left.getMetadata(this.schema),\r\n                leftType = leftMetadata && leftMetadata.type,\r\n                rightMetadata = right.getMetadata(this.schema),\r\n                rightType = rightMetadata && rightMetadata.type;\r\n\r\n            if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\r\n                this.register(SQExprValidationError.invalidValueType);\r\n        }\r\n\r\n        private validateEntity(schemaName: string, entityName: string): ConceptualEntity {\r\n            let schema = this.schema.schema(schemaName);\r\n            if (schema) {\r\n                let entity = schema.entities.withName(entityName);\r\n                if (entity)\r\n                    return entity;\r\n\r\n                this.register(SQExprValidationError.invalidEntityReference);\r\n            }\r\n            else {\r\n                this.register(SQExprValidationError.invalidSchemaReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchy(schemaName: string, entityName: string, hierarchyName: string): ConceptualHierarchy {\r\n            let entity = this.validateEntity(schemaName, entityName);\r\n            if (entity) {\r\n                let hierarchy = entity.hierarchies.withName(hierarchyName);\r\n                if (hierarchy)\r\n                    return hierarchy;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchyLevel(schemaName: string, entityName: string, hierarchyName: string, levelName: string): ConceptualHierarchyLevel {\r\n            let hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\r\n            if (hierarchy) {\r\n                let hierarchyLevel = hierarchy.levels.withName(levelName);\r\n                if (hierarchyLevel)\r\n                    return hierarchyLevel;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n            }\r\n        }\r\n\r\n        private register(error: SQExprValidationError) {\r\n            if (!this.errors)\r\n                this.errors = [];\r\n            this.errors.push(error);\r\n        }\r\n\r\n        private isQueryable(fieldExpr: FieldExprPattern): boolean {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\r\n                let hierarchyLevelConceptualProperty = SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\r\n                return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== ConceptualQueryableState.Error;\r\n            }\r\n\r\n            return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, FieldExprPattern.getPropertyName(fieldExpr)).queryable !== ConceptualQueryableState.Error;\r\n        }\r\n    }\r\n\r\n    /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\r\n    class SQExprAggregateInfoVisitor extends DefaultSQExprVisitor<QueryAggregateFunction> {\r\n        public visitAggr(expr: SQAggregationExpr): QueryAggregateFunction {\r\n            return expr.func;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): QueryAggregateFunction {\r\n            return;\r\n        }\r\n\r\n        public static getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            let visitor = new SQExprAggregateInfoVisitor();\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQExprColumnRef expression or undefined.*/\r\n    class SQExprColumnRefInfoVisitor extends DefaultSQExprVisitor<SQColumnRefExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQColumnRefExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let ref: string = expr.level;\r\n            let hierarchy = <SQHierarchyExpr>(expr.arg);\r\n            let sourceExpr: SQColumnRefExpr = hierarchy.accept(this);\r\n\r\n            if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\r\n                let propertyVariationSource = <SQPropertyVariationSourceExpr>hierarchy.arg;\r\n                let targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\r\n\r\n                if (sourceExpr && targetEntity) {\r\n                    let schemaName = (<SQEntityExpr>(sourceExpr.source)).schema;\r\n                    let targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\r\n                    let schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\r\n\r\n                    if (schemaHierarchy) {\r\n                        for (let level of schemaHierarchy.levels)\r\n                            if (level.name === ref)\r\n                                return new SQColumnRefExpr(targetEntityExpr, level.column.name);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let entityExpr = <SQEntityExpr>(hierarchy.arg);\r\n                let hierarchyLevelRef = SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema,\r\n                    entityExpr.schema,\r\n                    entityExpr.entity,\r\n                    hierarchy.hierarchy,\r\n                    expr.level);\r\n\r\n                if (hierarchyLevelRef)\r\n                    return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\r\n            }\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQColumnRefExpr {\r\n            let propertyName = expr.property;\r\n            return new SQColumnRefExpr(expr.arg, propertyName);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQColumnRefExpr {\r\n            return;\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQEntityExpr expression or undefined.*/\r\n    class SQEntityExprInfoVisitor extends DefaultSQExprVisitor<SQEntityExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQEntityExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntity(expr);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQEntityExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQEntityExpr {\r\n            return expr.source.accept(this);\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n\r\n        public static getEntity(columnRef: SQColumnRefExpr): SQEntityExpr {\r\n            let field = SQExprConverter.asFieldPattern(columnRef);\r\n            let column = field.column;\r\n            return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\r\n        }\r\n\r\n        public static getEntityExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQEntityExpr {\r\n            let visitor = new SQEntityExprInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    class SQExprChangeAggregateRewriter extends SQExprRootRewriter {\r\n        private func: QueryAggregateFunction;\r\n\r\n        constructor(func: QueryAggregateFunction) {\r\n            debug.assertValue(func, 'func');\r\n\r\n            super();\r\n            this.func = func;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            if (expr.func === this.func)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(expr.arg, this.func);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            return new SQAggregationExpr(expr, this.func);\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, func: QueryAggregateFunction): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(func, 'func');\r\n\r\n            let rewriter = new SQExprChangeAggregateRewriter(func);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveAggregateRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemoveAggregateRewriter = new SQExprRemoveAggregateRewriter();\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            return expr.arg;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveAggregateRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveEntityVariablesRewriter extends SQExprRewriter {\r\n        private static instance: SQExprRemoveEntityVariablesRewriter = new SQExprRemoveEntityVariablesRewriter();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            if (expr.variable)\r\n                return SQExprBuilder.entity(expr.schema, expr.entity);\r\n\r\n            return expr;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import ConceptualEntity = powerbi.data.ConceptualEntity;\r\n    import ConceptualMultiplicity = powerbi.data.ConceptualMultiplicity;\r\n    import SQEntityExpr = powerbi.data.SQEntityExpr;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    export module SQExprUtils {\r\n        export function supportsArithmetic(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let metadata = expr.getMetadata(schema),\r\n                type = metadata && metadata.type;\r\n\r\n            if (!metadata || !type) {\r\n                return false;\r\n            }\r\n            \r\n            return type.numeric || type.dateTime || type.duration;\r\n        }\r\n\r\n        export function indexOfExpr(items: SQExpr[], searchElement: SQExpr): number {\r\n            debug.assertValue(items, 'items');\r\n            debug.assertValue(searchElement, 'searchElement');\r\n\r\n            for (let i = 0, len = items.length; i < len; i++) {\r\n                if (SQExpr.equals(items[i], searchElement))\r\n                    return i;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function sequenceEqual(x: SQExpr[], y: SQExpr[]): boolean {\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!SQExpr.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n        \r\n        export function uniqueName(namedItems: NamedSQExpr[], expr: SQExpr, exprDefaultName?: string): string {\r\n            debug.assertValue(namedItems, 'namedItems');\r\n\r\n            // Determine all names\r\n            let names: { [name: string]: boolean } = {};\r\n            for (let i = 0, len = namedItems.length; i < len; i++)\r\n                names[namedItems[i].name] = true;\r\n\r\n            return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\r\n        }\r\n\r\n        /** Generates a default expression name  */\r\n        export function defaultName(expr: SQExpr, fallback: string = 'select'): string {\r\n            if (!expr)\r\n                return fallback;\r\n\r\n            return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a model measure or an aggregate. */\r\n        export function isMeasure(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsMeasureVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\r\n        export function isAnyValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsAnyValueVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\r\n        export function isDefaultValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsDefaultValueVisitor.instance);\r\n        }\r\n\r\n        export function discourageAggregation(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let capabilities = getSchemaCapabilities(expr, schema);\r\n            return capabilities && capabilities.discourageQueryAggregateUsage;\r\n        }\r\n\r\n        export function getAggregateBehavior(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualAggregateBehavior {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let column = getConceptualColumn(expr, schema);\r\n            if (column)\r\n                return column.aggregateBehavior;\r\n        }\r\n\r\n        export function getSchemaCapabilities(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualCapabilities {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(expr);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let conceptualSchema = schema.schema(fieldExprItem.schema);\r\n            if (conceptualSchema)\r\n                return conceptualSchema.capabilities;\r\n        }\r\n\r\n        export function getKpiMetadata(expr: SQExpr, schema: FederatedConceptualSchema): DataViewKpiColumnMetadata {\r\n            let kpiStatusProperty = getKpiStatusProperty(expr, schema);\r\n            if (kpiStatusProperty)\r\n                return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\r\n\r\n            let kpiTrendProperty = getKpiTrendProperty(expr, schema);\r\n            if (kpiTrendProperty)\r\n                return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\r\n        }\r\n\r\n        export function getConceptualEntity(entityExpr: SQEntityExpr, schema: FederatedConceptualSchema): ConceptualEntity {\r\n            debug.assertValue(entityExpr, 'entityExpr');\r\n\r\n            let conceptualEntity = schema\r\n                .schema(entityExpr.schema)\r\n                .entities\r\n                .withName(entityExpr.entity);\r\n            return conceptualEntity;\r\n        }\r\n\r\n        function getKpiStatusProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.status === property)\r\n                return property;\r\n        }\r\n\r\n        function getKpiTrendProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.trend === property)\r\n                return property;\r\n        }\r\n\r\n        export function getDefaultValue(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): SQConstantExpr {\r\n            let column = getConceptualColumn(fieldSQExpr, schema);\r\n            if (column)\r\n                return column.defaultValue;\r\n        }\r\n\r\n        function getConceptualColumn(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): ConceptualColumn {\r\n            if (!fieldSQExpr || !schema)\r\n                return;\r\n\r\n            let sqField = SQExprConverter.asFieldPattern(fieldSQExpr);\r\n            if (!sqField)\r\n                return;\r\n\r\n            let column: FieldExprPropertyPattern = sqField.column;\r\n\r\n            if (column) {\r\n                if (schema.schema(column.schema) && sqField.column.name) {\r\n                    let property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\r\n\r\n                    if (property)\r\n                        return property.column;\r\n                }\r\n            }\r\n            else {\r\n                let hierarchyLevelField: FieldExprHierarchyLevelPattern = sqField.hierarchyLevel;\r\n                if (hierarchyLevelField) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(sqField);\r\n                    let schemaName = fieldExprItem.schema;\r\n                    if (schema.schema(schemaName)) {\r\n                        let hierarchy = schema.schema(schemaName)\r\n                            .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\r\n\r\n                        if (hierarchy) {\r\n                            let hierarchyLevel: ConceptualHierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\r\n                            if (hierarchyLevel && hierarchyLevel.column)\r\n                                return hierarchyLevel.column.column;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function getDefaultValues(fieldSQExprs: SQExpr[], schema: FederatedConceptualSchema): SQConstantExpr[] {\r\n            if (_.isEmpty(fieldSQExprs) || !schema)\r\n                return;\r\n            let result: SQConstantExpr[] = [];\r\n            for (let sqExpr of fieldSQExprs) {\r\n                let defaultValue = getDefaultValue(sqExpr, schema);\r\n                if (defaultValue)\r\n                    result.push(defaultValue);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Return compare or and expression for key value pairs. */\r\n        export function getDataViewScopeIdentityComparisonExpr(fieldsExpr: SQExpr[], values: SQConstantExpr[]): SQExpr {\r\n            debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\r\n\r\n            let compareExprs: SQCompareExpr[] = [];\r\n            for (let i = 0; i < fieldsExpr.length; i++) {\r\n                compareExprs.push(SQExprBuilder.compare(QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\r\n            }\r\n\r\n            if (_.isEmpty(compareExprs))\r\n                return;\r\n\r\n            let resultExpr: SQExpr;\r\n            for (let compareExpr of compareExprs) {\r\n                resultExpr = SQExprBuilder.and(resultExpr, compareExpr);\r\n            }\r\n\r\n            return resultExpr;\r\n        }\r\n\r\n        export function getActiveTablesNames(queryDefn: data.SemanticQuery): string[] {\r\n            let tables: string[] = [];\r\n            if (queryDefn) {\r\n                let selectedItems = queryDefn.from();\r\n                if (selectedItems !== undefined) {\r\n                    for (let key of selectedItems.keys()) {\r\n                        let entityObj = selectedItems.entity(key);\r\n                        if (tables.indexOf(entityObj.entity) < 0)\r\n                            tables.push(entityObj.entity);\r\n                    }\r\n                }\r\n            }\r\n            return tables;\r\n        }\r\n\r\n        export function isRelatedToMany(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne);\r\n        }\r\n\r\n        export function isRelatedToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many);\r\n        }\r\n\r\n        function isRelated(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr,\r\n            sourceMultiplicity: ConceptualMultiplicity,\r\n            targetMultiplicity: ConceptualMultiplicity): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n\r\n            if (_.isEmpty(source.navigationProperties))\r\n                return false;\r\n\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let queue: ConceptualEntity[] = [];\r\n            queue.push(source);\r\n\r\n            // walk the relationship path from source.\r\n            while (!_.isEmpty(queue)) {\r\n                let current = queue.shift();\r\n\r\n                let navProperties = current.navigationProperties;\r\n                if (_.isEmpty(navProperties))\r\n                    continue;\r\n\r\n                for (let navProperty of navProperties) {\r\n                    if (!navProperty.isActive)\r\n                        continue;\r\n\r\n                    if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\r\n                        if (navProperty.targetEntity === target)\r\n                            return true;\r\n                        queue.push(navProperty.targetEntity);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRelatedOneToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let sourceNavigations = source.navigationProperties;\r\n            let targetNavigations = target.navigationProperties;\r\n\r\n            if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\r\n                return false;\r\n\r\n            return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\r\n        }\r\n\r\n        function hasOneToOneNavigation(navigationProperties: ArrayNamedItems<ConceptualNavigationProperty>, targetEntity: ConceptualEntity): boolean {\r\n            if (_.isEmpty(navigationProperties))\r\n                return false;\r\n\r\n            for (let navigationProperty of navigationProperties) {\r\n                if (!navigationProperty.isActive)\r\n                    continue;\r\n\r\n                if (navigationProperty.targetEntity !== targetEntity)\r\n                    continue;\r\n\r\n                if (navigationProperty.sourceMultiplicity === ConceptualMultiplicity.ZeroOrOne &&\r\n                    navigationProperty.targetMultiplicity === ConceptualMultiplicity.ZeroOrOne) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\r\n            and returns a new array. When available, we should use _.unionWith from lodash. */\r\n        export function concatUnique(leftExprs: SQExpr[], rightExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(leftExprs, 'leftExprs');\r\n            debug.assertValue(rightExprs, 'rightExprs');\r\n\r\n            let concatExprs = ArrayExtensions.copy(leftExprs);\r\n            for (let expr of rightExprs) {\r\n                if (indexOfExpr(concatExprs, expr) === -1) {\r\n                    concatExprs.push(expr);\r\n                }\r\n            }\r\n\r\n            return concatExprs;\r\n        }\r\n\r\n        class SQExprDefaultNameGenerator extends DefaultSQExprVisitorWithArg<string, string> {\r\n            public static instance: SQExprDefaultNameGenerator = new SQExprDefaultNameGenerator();\r\n\r\n            public visitEntity(expr: SQEntityExpr): string {\r\n                return expr.entity;\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, fallback: string): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, fallback: string): string {\r\n                return QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr, fallback: string): string {\r\n                return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): string {\r\n                return 'const';\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr, fallback: string): string {\r\n                return fallback || 'expr';\r\n            }\r\n        }\r\n\r\n        class IsMeasureVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsMeasureVisitor = new IsMeasureVisitor();\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsDefaultValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsDefaultValueVisitor = new IsDefaultValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsAnyValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsAnyValueVisitor = new IsAnyValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export class SemanticQueryRewriter {\r\n        private exprRewriter: ISQExprVisitor<SQExpr>;\r\n\r\n        constructor(exprRewriter: ISQExprVisitor<SQExpr>) {\r\n            this.exprRewriter = exprRewriter;\r\n        }\r\n\r\n        public rewriteFrom(fromValue: SQFrom): SQFrom {\r\n            let fromContents: { [name: string]: SQFromEntitySource } = {};\r\n            let originalFrom = fromValue,\r\n                originalFromKeys = originalFrom.keys();\r\n            for (let i = 0, len = originalFromKeys.length; i < len; i++) {\r\n                let keyName = originalFromKeys[i],\r\n                    originalEntityRef = originalFrom.entity(keyName),\r\n                    originalEntityExpr = SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName),\r\n                    updatedEntityExpr = <SQEntityExpr>originalEntityExpr.accept(this.exprRewriter);\r\n                \r\n                fromContents[keyName] = {\r\n                    schema: updatedEntityExpr.schema,\r\n                    entity: updatedEntityExpr.entity,\r\n                };\r\n            }\r\n            return new SQFrom(fromContents);\r\n        }\r\n\r\n        public rewriteSelect(selectItems: NamedSQExpr[], from: SQFrom): NamedSQExpr[]{\r\n            debug.assertValue(selectItems, 'selectItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            return this.rewriteNamedSQExpressions(selectItems, from);\r\n        }\r\n\r\n        public rewriteGroupBy(groupByitems: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertAnyValue(groupByitems, 'groupByitems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(groupByitems))\r\n                return;\r\n\r\n            return this.rewriteNamedSQExpressions(groupByitems, from);\r\n        }\r\n\r\n        private rewriteNamedSQExpressions(expressions: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertValue(expressions, 'expressions');\r\n\r\n            return _.map(expressions, item => {\r\n                return {\r\n                    name: item.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from)\r\n                };\r\n            });\r\n        }\r\n\r\n        public rewriteOrderBy(orderByItems: SQSortDefinition[], from: SQFrom): SQSortDefinition[]{\r\n            debug.assertAnyValue(orderByItems, 'orderByItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(orderByItems))\r\n                return;\r\n\r\n            let orderBy: SQSortDefinition[] = [];\r\n            for (let i = 0, len = orderByItems.length; i < len; i++) {\r\n                let item = orderByItems[i],\r\n                    updatedExpr = SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\r\n                orderBy.push({\r\n                        direction: item.direction,\r\n                        expr: updatedExpr,\r\n                    });\r\n            }\r\n\r\n            return orderBy;\r\n        }\r\n\r\n        public rewriteWhere(whereItems: SQFilter[], from: SQFrom): SQFilter[]{\r\n            debug.assertAnyValue(whereItems, 'whereItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(whereItems))\r\n                return;\r\n\r\n            let where: SQFilter[] = [];\r\n            for (let i = 0, len = whereItems.length; i < len; i++) {\r\n                let originalWhere = whereItems[i];\r\n\r\n                let updatedWhere: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\r\n                };\r\n\r\n                if (originalWhere.target)\r\n                    updatedWhere.target = _.map(originalWhere.target, e => SQExprRewriterWithSourceRenames.rewrite(e.accept(this.exprRewriter), from));\r\n\r\n                where.push(updatedWhere);\r\n            }\r\n\r\n            return where;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export interface NamedSQExpr {\r\n        name: string;\r\n        expr: SQExpr;\r\n    }\r\n\r\n    export interface SQFilter {\r\n        target?: SQExpr[];\r\n        condition: SQExpr;\r\n    }\r\n\r\n    /** Represents an entity reference in SemanticQuery from. */\r\n    export interface SQFromEntitySource {\r\n        entity: string;\r\n        schema: string;\r\n    }\r\n\r\n    /** Represents a sort over an expression. */\r\n    export interface SQSortDefinition {\r\n        expr: SQExpr;\r\n        direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryFromEnsureEntityResult {\r\n        name: string;\r\n        new?: boolean;\r\n    }\r\n\r\n    export interface SQSourceRenames {\r\n        [from: string]: string;\r\n    }\r\n\r\n    /**\r\n     * Represents a semantic query that is:\r\n     * 1) Round-trippable with a JSON QueryDefinition.\r\n     * 2) Immutable\r\n     * 3) Long-lived and does not have strong references to a conceptual model (only names).\r\n     */\r\n    export class SemanticQuery {\r\n        private static empty: SemanticQuery;\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n        private orderByItems: SQSortDefinition[];\r\n        private selectItems: NamedSQExpr[];\r\n        private groupByItems: NamedSQExpr[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[], orderBy: SQSortDefinition[], select: NamedSQExpr[], groupBy: NamedSQExpr[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(select, 'select');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n            this.orderByItems = orderBy;\r\n            this.selectItems = select;\r\n            this.groupByItems = groupBy;\r\n        }\r\n\r\n        public static create(): SemanticQuery {\r\n            if (!SemanticQuery.empty)\r\n                SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\r\n\r\n            return SemanticQuery.empty;\r\n        }\r\n\r\n        private static createWithTrimmedFrom(\r\n            from: SQFrom,\r\n            where: SQFilter[],\r\n            orderBy: SQSortDefinition[],\r\n            select: NamedSQExpr[],\r\n            groupBy: NamedSQExpr[]): SemanticQuery {\r\n\r\n            let unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\r\n\r\n            // Where\r\n            if (where) {\r\n                for (let i = 0, len = where.length; i < len; i++) {\r\n                    let filter = where[i];\r\n\r\n                    filter.condition.accept(unreferencedKeyFinder);\r\n\r\n                    let filterTarget = filter.target;\r\n                    if (filterTarget) {\r\n                        for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                            if (filterTarget[j])\r\n                                filterTarget[j].accept(unreferencedKeyFinder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // OrderBy\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++)\r\n                    orderBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            // Select\r\n            for (let i = 0, len = select.length; i < len; i++)\r\n                select[i].expr.accept(unreferencedKeyFinder);\r\n\r\n            // GroupBy\r\n            if (groupBy) {\r\n                for (let i = 0, len = groupBy.length; i < len; i++)\r\n                    groupBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            let unreferencedKeys = unreferencedKeyFinder.result();\r\n            for (let i = 0, len = unreferencedKeys.length; i < len; i++)\r\n                from.remove(unreferencedKeys[i]);\r\n\r\n            return new SemanticQuery(from, where, orderBy, select, groupBy);\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        /** Returns a query equivalent to this, with the specified selected items. */\r\n        select(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the items being selected in this query. */\r\n        select(): ArrayNamedItems<NamedSQExpr>;\r\n        public select(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getSelect();\r\n\r\n            return this.setSelect(values);\r\n        }\r\n\r\n        private getSelect(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.selectItems);\r\n        }\r\n\r\n        private static createNamedExpressionArray(items: NamedSQExpr[]): ArrayNamedItems<NamedSQExpr> {\r\n            return ArrayExtensions.extendWithName<NamedSQExpr>(_.map(items, s => {\r\n                return {\r\n                    name: s.name,\r\n                    expr: s.expr,\r\n                };\r\n            }));\r\n        }\r\n\r\n        private setSelect(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private static rewriteExpressionsWithSourceRenames(values: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            let items: NamedSQExpr[] = [];\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n                items.push({\r\n                    name: value.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\r\n                });\r\n            }\r\n\r\n            return items;\r\n        } \r\n\r\n        /** Removes the given expression from the select. */\r\n        public removeSelect(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let originalItems = this.selectItems,\r\n                selectItems: NamedSQExpr[] = [];\r\n            for (let i = 0, len = originalItems.length; i < len; i++) {\r\n                let originalExpr = originalItems[i];\r\n                if (SQExpr.equals(originalExpr.expr, expr))\r\n                    continue;\r\n\r\n                selectItems.push(originalExpr);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Removes the given expression from order by. */\r\n        public removeOrderBy(expr: SQExpr): SemanticQuery {\r\n            let sorts = this.orderBy();\r\n            for (let i = sorts.length - 1; i >= 0; i--) {\r\n                if (SQExpr.equals(sorts[i].expr, expr))\r\n                    sorts.splice(i, 1);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public selectNameOf(expr: SQExpr): string {\r\n            let index = SQExprUtils.indexOfExpr(_.map(this.selectItems, s => s.expr), expr);\r\n            if (index >= 0)\r\n                return this.selectItems[index].name;\r\n        }\r\n\r\n        public setSelectAt(index: number, expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (index >= this.selectItems.length)\r\n                return;\r\n\r\n            let select = this.select(),\r\n                from = this.fromValue.clone(),\r\n                originalName = select[index].name;\r\n            select[index] = {\r\n                name: originalName,\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\r\n        }\r\n\r\n        /** Adds a the expression to the select clause. */\r\n        public addSelect(expr: SQExpr, exprName?: string): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let selectItems = this.select(),\r\n                from = this.fromValue.clone();\r\n            selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private createNamedExpr(currentNames: ArrayNamedItems<NamedSQExpr>, from: SQFrom, expr: SQExpr, exprName?: string): NamedSQExpr{\r\n            return {\r\n                name: SQExprUtils.uniqueName(currentNames, expr, exprName),\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n        } \r\n\r\n        /** Returns a query equivalent to this, with the specified groupBy items. */\r\n        groupBy(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the groupby items in this query. */\r\n        groupBy(): ArrayNamedItems<NamedSQExpr>;\r\n        public groupBy(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getGroupBy();\r\n\r\n            return this.setGroupBy(values);\r\n        }\r\n\r\n        private getGroupBy(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.groupByItems);\r\n        }\r\n\r\n        private setGroupBy(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        public addGroupBy(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let groupByItems = this.groupBy(),\r\n                from = this.fromValue.clone();\r\n            groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the sorting for this query. */\r\n        orderBy(values: SQSortDefinition[]): SemanticQuery;\r\n        orderBy(): SQSortDefinition[];\r\n\r\n        public orderBy(values?: SQSortDefinition[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getOrderBy();\r\n\r\n            return this.setOrderBy(values);\r\n        }\r\n\r\n        private getOrderBy(): SQSortDefinition[] {\r\n            let result: SQSortDefinition[] = [];\r\n\r\n            let orderBy = this.orderByItems;\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++) {\r\n                    let clause = orderBy[i];\r\n\r\n                    result.push({\r\n                        expr: clause.expr,\r\n                        direction: clause.direction,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setOrderBy(values: SQSortDefinition[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedOrderBy: SQSortDefinition[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let clause = values[i];\r\n                updatedOrderBy.push({\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\r\n                    direction: clause.direction,\r\n                });\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the filters for this query. */\r\n        where(values: SQFilter[]): SemanticQuery;\r\n        where(): SQFilter[];\r\n\r\n        public where(values?: SQFilter[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getWhere();\r\n\r\n            return this.setWhere(values);\r\n        }\r\n\r\n        private getWhere(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            if (whereItems) {\r\n                for (let i = 0, len = whereItems.length; i < len; i++)\r\n                    result.push(whereItems[i]);\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setWhere(values: SQFilter[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedWhere: SQFilter[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let filter = values[i];\r\n                let updatedFilter: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\r\n                };\r\n\r\n                let filterTarget = filter.target;\r\n                if (filterTarget) {\r\n                    updatedFilter.target = [];\r\n                    for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                        if (filterTarget[j]) {\r\n                            let updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\r\n                            updatedFilter.target.push(updatedTarget);\r\n                        }\r\n                }\r\n\r\n                updatedWhere.push(updatedFilter);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public addWhere(filter: SemanticFilter): SemanticQuery {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedWhere: SQFilter[] = this.where(),\r\n                incomingWhere: SQFilter[] = filter.where(),\r\n                from = this.fromValue.clone();\r\n\r\n            for (let i = 0, len = incomingWhere.length; i < len; i++) {\r\n                let clause = incomingWhere[i];\r\n\r\n                let updatedClause: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\r\n                };\r\n\r\n                if (clause.target)\r\n                    updatedClause.target = _.map(clause.target, t => SQExprRewriterWithSourceRenames.rewrite(t, from));\r\n\r\n                updatedWhere.push(updatedClause);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticQuery {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n            let orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\r\n            let select = rewriter.rewriteSelect(this.selectItems, from);\r\n            let groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\r\n        }\r\n    }\r\n\r\n    /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\r\n    export class SemanticFilter implements ISemanticFilter {\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n        }\r\n\r\n        public static fromSQExpr(contract: SQExpr): SemanticFilter {\r\n            debug.assertValue(contract, 'contract');\r\n\r\n            let from = new SQFrom();\r\n\r\n            let rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\r\n            // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\r\n            //         Thus not setting a target here.\r\n            let where: SQFilter[] = [{\r\n                condition: rewrittenContract\r\n            }];\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static getDefaultValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.defaultValue());\r\n        }\r\n\r\n        public static getAnyValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.anyValue());\r\n        }\r\n\r\n        private static getDataViewScopeIdentityComparisonFilters(fieldSQExprs: SQExpr | SQExpr[], value: SQExpr): SemanticFilter {\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (fieldSQExprs instanceof Array) {\r\n                let values: SQConstantExpr[] = Array.apply(null, Array(fieldSQExprs.length)).map(() => { return value; });\r\n                return SemanticFilter.fromSQExpr(SQExprUtils.getDataViewScopeIdentityComparisonExpr(<SQExpr[]>fieldSQExprs, values));\r\n            }\r\n\r\n            return SemanticFilter.fromSQExpr(SQExprBuilder.equal(<SQExpr>fieldSQExprs, value));\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        public conditions(): SQExpr[] {\r\n            let expressions: SQExpr[] = [];\r\n\r\n            let where = this.whereItems;\r\n            for (let i = 0, len = where.length; i < len; i++) {\r\n                let filter = where[i];\r\n                expressions.push(filter.condition);\r\n            }\r\n            return expressions;\r\n        }\r\n\r\n        public where(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            for (let i = 0, len = whereItems.length; i < len; i++)\r\n                result.push(whereItems[i]);\r\n\r\n            return result;\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticFilter {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.rewrite(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        /** Merges a list of SemanticFilters into one. */\r\n        public static merge(filters: SemanticFilter[]): SemanticFilter {\r\n            if (_.isEmpty(filters))\r\n                return null;\r\n\r\n            if (filters.length === 1)\r\n                return filters[0];\r\n\r\n            let firstFilter = filters[0];\r\n            let from = firstFilter.from(),\r\n                where: SQFilter[] = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\r\n\r\n            for (let i = 1, len = filters.length; i < len; i++)\r\n                SemanticFilter.applyFilter(filters[i], from, where);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static isDefaultFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isDefaultValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isAnyFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isAnyValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isSameFilter(leftFilter: SemanticFilter, rightFilter: SemanticFilter): boolean {\r\n            if (jsCommon.JsonComparer.equals<SemanticFilter>(leftFilter, rightFilter)) {\r\n                return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\r\n                    || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private static applyFilter(filter: SemanticFilter, from: SQFrom, where: SQFilter[]): void {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            // Where\r\n            let filterWhereItems = filter.whereItems;\r\n            for (let i = 0; i < filterWhereItems.length; i++) {\r\n                let filterWhereItem = filterWhereItems[i];\r\n\r\n                let updatedWhereItem: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\r\n                };\r\n\r\n                if (filterWhereItem.target)\r\n                    updatedWhereItem.target = _.map(filterWhereItem.target, e => SQExprRewriterWithSourceRenames.rewrite(e, from));\r\n\r\n                where.push(updatedWhereItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Represents a SemanticQuery/SemanticFilter from clause. */\r\n    export class SQFrom {\r\n        private items: { [name: string]: SQFromEntitySource };\r\n\r\n        constructor(items?: { [name: string]: SQFromEntitySource }) {\r\n            this.items = items || {};\r\n        }\r\n\r\n        public keys(): string[] {\r\n            return Object.keys(this.items);\r\n        }\r\n\r\n        public entity(key: string): SQFromEntitySource {\r\n            return this.items[key];\r\n        }\r\n\r\n        public ensureEntity(entity: SQFromEntitySource, desiredVariableName?: string): QueryFromEnsureEntityResult {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            // 1) Reuse a reference to the entity among the already referenced\r\n            let keys = this.keys();\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let key = keys[i],\r\n                    item = this.items[key];\r\n                if (item && entity.entity === item.entity && entity.schema === item.schema)\r\n                    return { name: key };\r\n            }\r\n\r\n            // 2) Add a reference to the entity\r\n            let candidateName = desiredVariableName || this.candidateName(entity.entity),\r\n                uniqueName: string = candidateName,\r\n                i = 2;\r\n            while (this.items[uniqueName]) {\r\n                uniqueName = candidateName + i++;\r\n            }\r\n\r\n            this.items[uniqueName] = entity;\r\n            return { name: uniqueName, new: true };\r\n        }\r\n\r\n        public remove(key: string): void {\r\n            delete this.items[key];\r\n        }\r\n\r\n        /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\r\n        private candidateName(ref: string): string {\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            let idx = ref.lastIndexOf('.');\r\n            if (idx >= 0 && (idx !== ref.length - 1))\r\n                ref = ref.substr(idx + 1);\r\n\r\n            return ref.substring(0, 1).toLowerCase();\r\n        }\r\n\r\n        public clone(): SQFrom {\r\n            // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\r\n            let cloned = new SQFrom();\r\n\r\n            // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\r\n            $.extend(cloned.items, this.items);\r\n\r\n            return cloned;\r\n        }\r\n    }\r\n\r\n    export class SQExprRewriterWithSourceRenames extends SQExprRewriter {\r\n        private renames: SQSourceRenames;\r\n\r\n        constructor(renames: SQSourceRenames) {\r\n            debug.assertValue(renames, 'renames');\r\n\r\n            super();\r\n            this.renames = renames;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            let updatedName = this.renames[expr.entity];\r\n\r\n            if (updatedName)\r\n                return new SQEntityExpr(expr.schema, expr.entity, updatedName);\r\n\r\n            return super.visitEntity(expr);\r\n        }\r\n\r\n        public rewriteFilter(filter: SQFilter): SQFilter {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedTargets = undefined;\r\n            if (filter.target)\r\n                updatedTargets = this.rewriteArray(filter.target);\r\n\r\n            let updatedCondition = filter.condition.accept(this);\r\n\r\n            if (filter.condition === updatedCondition && filter.target === updatedTargets)\r\n                return filter;\r\n\r\n            let updatedFilter: SQFilter = {\r\n                condition: updatedCondition,\r\n            };\r\n\r\n            if (updatedTargets)\r\n                updatedFilter.target = updatedTargets;\r\n\r\n            return updatedFilter;\r\n        }\r\n\r\n        public rewriteArray(exprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(exprs, 'exprs');\r\n\r\n            let updatedExprs: SQExpr[];\r\n\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i],\r\n                    rewrittenExpr = expr.accept(this);\r\n\r\n                if (expr !== rewrittenExpr && !updatedExprs)\r\n                    updatedExprs = ArrayExtensions.take(exprs, i);\r\n\r\n                if (updatedExprs)\r\n                    updatedExprs.push(rewrittenExpr);\r\n            }\r\n\r\n            return updatedExprs || exprs;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, from: SQFrom): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(from, 'from');\r\n\r\n            let renames = QuerySourceRenameDetector.run(expr, from);\r\n            let rewriter = new SQExprRewriterWithSourceRenames(renames);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    /** Responsible for updating a QueryFrom based on SQExpr references. */\r\n    class QuerySourceRenameDetector extends DefaultSQExprVisitorWithTraversal {\r\n        private from: SQFrom;\r\n        private renames: SQSourceRenames;\r\n\r\n        public static run(expr: SQExpr, from: SQFrom): SQSourceRenames {\r\n            let detector = new QuerySourceRenameDetector(from);\r\n            expr.accept(detector);\r\n\r\n            return detector.renames;\r\n        }\r\n\r\n        constructor(from: SQFrom) {\r\n            debug.assertValue(from, 'from');\r\n            super();\r\n\r\n            this.from = from;\r\n            this.renames = {};\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            // TODO: Renames must take the schema into account, not just entity set name.\r\n            let existingEntity = this.from.entity(expr.variable);\r\n            if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\r\n                return;\r\n\r\n            let actualEntity = this.from.ensureEntity(\r\n                {\r\n                    schema: expr.schema,\r\n                    entity: expr.entity,\r\n                },\r\n                expr.variable);\r\n\r\n            this.renames[expr.entity] = actualEntity.name;\r\n        }\r\n    }\r\n\r\n    /** Visitor for finding unreferenced sources. */\r\n    class UnreferencedKeyFinder extends DefaultSQExprVisitorWithTraversal {\r\n        private keys: string[];\r\n\r\n        constructor(keys: string[]) {\r\n            debug.assertValue(keys, 'keys');\r\n\r\n            super();\r\n            this.keys = keys;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            let index = this.keys.indexOf(expr.variable);\r\n            if (index >= 0)\r\n                this.keys.splice(index, 1);\r\n        }\r\n\r\n        public result(): string[] {\r\n            return this.keys;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataViewTransform = powerbi.data.DataViewTransform;\r\n    import SQExprBuilder = powerbi.data.SQExprBuilder;\r\n\r\n    /** Utility for creating a DataView from columns of data. */\r\n    export interface IDataViewBuilderCategorical {\r\n        withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical;\r\n        withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical;\r\n        withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical;\r\n        withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical;\r\n\r\n        build(): DataView;\r\n    }\r\n\r\n    export interface DataViewBuilderColumnOptions {\r\n        source: DataViewMetadataColumn;\r\n    }\r\n\r\n    export interface DataViewBuilderCategoryColumnOptions extends DataViewBuilderColumnOptions {\r\n        values: PrimitiveValue[];\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n    }\r\n\r\n    export interface DataViewBuilderValuesOptions {\r\n        columns: DataViewBuilderValuesColumnOptions[];\r\n    }\r\n\r\n    export interface DataViewBuilderGroupedValuesOptions {\r\n        groupColumn: DataViewBuilderCategoryColumnOptions;\r\n        valueColumns: DataViewBuilderColumnOptions[];\r\n        data: DataViewBuilderSeriesData[][];\r\n    }\r\n\r\n    /** Indicates the source set of identities. */\r\n    export interface DataViewBuilderColumnIdentitySource {\r\n        fields: SQExpr[];\r\n        identities?: DataViewScopeIdentity[];\r\n    }\r\n\r\n    export interface DataViewBuilderValuesColumnOptions extends DataViewBuilderColumnOptions, DataViewBuilderSeriesData {\r\n    }\r\n\r\n    export interface DataViewBuilderSeriesData {\r\n        values: PrimitiveValue[];\r\n        highlights?: PrimitiveValue[];\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        maxLocal?: any;\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        minLocal?: any;\r\n    }\r\n\r\n    export function createCategoricalDataViewBuilder(): IDataViewBuilderCategorical {\r\n        return new CategoricalDataViewBuilder();\r\n    }\r\n\r\n    interface ColumnMetadata {\r\n        column: DataViewMetadataColumn;\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n        values: PrimitiveValue[];\r\n    }\r\n\r\n    class CategoricalDataViewBuilder implements IDataViewBuilderCategorical {\r\n        private categories: DataViewCategoryColumn[];\r\n        private measureColumns: DataViewMetadataColumn[];\r\n        private hasDynamicSeries: boolean;\r\n        private dynamicSeriesMetadata: ColumnMetadata;\r\n        private columnIndex: number;\r\n        private data: DataViewBuilderValuesColumnOptions[]| DataViewBuilderSeriesData[][];\r\n\r\n        constructor() {\r\n            this.categories = [];\r\n            this.measureColumns = [];\r\n            this.columnIndex = 0;\r\n        }\r\n\r\n        public withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical {\r\n            let categoryValues = options.values,\r\n                identityFrom = options.identityFrom,\r\n                type = options.source.type;\r\n\r\n            let categoryColumn: DataViewCategoryColumn = {\r\n                source: options.source,\r\n                identityFields: options.identityFrom.fields,\r\n                identity: options.identityFrom.identities || [],\r\n                values: categoryValues,\r\n            };\r\n\r\n            if (!options.identityFrom.identities) {\r\n                for (let categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\r\n                    categoryColumn.identity.push(\r\n                        getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\r\n                }\r\n            }\r\n\r\n            if (!this.categories)\r\n                this.categories = [];\r\n\r\n            this.categories.push(categoryColumn);\r\n\r\n            return this;\r\n        }\r\n\r\n        public withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical {\r\n            if (_.isEmpty(this.categories))\r\n                this.categories = categories;\r\n            else\r\n                Array.prototype.push.apply(this.categories, categories);\r\n\r\n            return this;\r\n        }\r\n\r\n        public withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let columns = options.columns;\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            for (let column of columns) {\r\n                this.measureColumns.push(column.source);\r\n            }\r\n\r\n            this.data = columns;\r\n\r\n            return this;\r\n        }\r\n\r\n        public withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            this.hasDynamicSeries = true;\r\n\r\n            let groupColumn = options.groupColumn;\r\n            debug.assertValue(groupColumn, 'groupColumn');\r\n\r\n            this.dynamicSeriesMetadata = {\r\n                column: groupColumn.source,\r\n                identityFrom: groupColumn.identityFrom,\r\n                values: groupColumn.values,\r\n            };\r\n\r\n            let valueColumns = options.valueColumns;\r\n            for (let valueColumn of valueColumns) {\r\n                this.measureColumns.push(valueColumn.source);\r\n            }\r\n\r\n            this.data = options.data;\r\n\r\n            return this;\r\n        }\r\n\r\n        private fillData(dataViewValues: DataViewValueColumns, groups: DataViewMetadataColumn[]) {\r\n            let categoryColumn = _.first(this.categories);\r\n            let categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 1;\r\n\r\n            if (this.hasDynamicSeries) {\r\n                // Dynamic series\r\n                let data = <DataViewBuilderSeriesData[][]>this.data;\r\n                for (let seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\r\n                    let seriesMeasures = data[seriesIndex];\r\n                    debug.assert(seriesMeasures.length === this.measureColumns.length, 'seriesMeasures.length === this.measureColumns.length');\r\n\r\n                    for (let measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                        let groupIndex = seriesIndex * measuresLen + measureIndex;\r\n\r\n                        applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Static series\r\n                let data = <DataViewBuilderValuesColumnOptions[]>this.data;\r\n                for (let measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                    applySeriesData(dataViewValues[measureIndex], data[measureIndex], categoryLength);\r\n                }\r\n            }\r\n        }\r\n\r\n        public build(): DataView {\r\n            let metadataColumns: DataViewMetadataColumn[] = [];\r\n            let categorical: DataViewCategorical = {};\r\n            let groups: DataViewMetadataColumn[];\r\n\r\n            let categoryMetadata = this.categories;\r\n            let dynamicSeriesMetadata = this.dynamicSeriesMetadata;\r\n\r\n            // --- Build metadata columns and value groups ---\r\n            for (let columnMetadata of categoryMetadata) {\r\n                pushIfNotExists(metadataColumns, columnMetadata.source);\r\n            }\r\n\r\n            if (this.hasDynamicSeries) {\r\n                pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\r\n            }\r\n\r\n            if (this.hasDynamicSeries) {\r\n                // Dynamic series\r\n                categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\r\n\r\n                let measures = this.measureColumns;\r\n                groups = [];\r\n\r\n                // For each series value we will make one column per measure\r\n                let seriesValues = dynamicSeriesMetadata.values;\r\n                for (let seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\r\n                    let seriesValue = seriesValues[seriesIndex];\r\n                    let seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\r\n\r\n                    for (let measure of measures) {\r\n                        let column = _.clone(measure);\r\n                        column.groupName = <string>seriesValue;\r\n                        groups.push(column);\r\n\r\n                        pushIfNotExists(metadataColumns, column);\r\n                        categorical.values.push({\r\n                            source: column,\r\n                            values: [],\r\n                            identity: seriesIdentity,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Static series / no series\r\n                categorical.values = DataViewTransform.createValueColumns();\r\n                groups = this.measureColumns;\r\n                for (let measure of groups) {\r\n                    let column = measure;\r\n                    pushIfNotExists(metadataColumns, column);\r\n                    categorical.values.push({\r\n                        source: column,\r\n                        values: [],\r\n                    });\r\n                }\r\n            }\r\n\r\n            let categories = this.categories;\r\n            if (!_.isEmpty(categories))\r\n                categorical.categories = categories;\r\n\r\n            // --- Fill in data point values ---\r\n            this.fillData(categorical.values, groups);\r\n\r\n            return {\r\n                metadata: {\r\n                    columns: metadataColumns,\r\n                },\r\n                categorical: categorical,\r\n            };\r\n        }\r\n    }\r\n\r\n    function getScopeIdentity(\r\n        source: DataViewBuilderColumnIdentitySource,\r\n        index: number,\r\n        value: PrimitiveValue,\r\n        valueType: ValueTypeDescriptor): DataViewScopeIdentity {\r\n        let identities = source.identities;\r\n        if (identities) {\r\n            return identities[index];\r\n        }\r\n\r\n        debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\r\n\r\n        return createDataViewScopeIdentity(\r\n            SQExprBuilder.equal(\r\n                source.fields[0],\r\n                SQExprBuilder.typedConstant(value, valueType)));\r\n    }\r\n\r\n    function pushIfNotExists(items: DataViewMetadataColumn[], itemToAdd: DataViewMetadataColumn): void {\r\n        if (_.contains(items, itemToAdd))\r\n            return;\r\n\r\n        items.push(itemToAdd);\r\n    }\r\n\r\n    function applySeriesData(target: DataViewValueColumn, source: DataViewBuilderSeriesData, categoryLength: number): void {\r\n        debug.assertValue(target, 'target');\r\n        debug.assertValue(source, 'source');\r\n        debug.assertValue(categoryLength, 'categoryLength');\r\n\r\n        let values = source.values;\r\n        debug.assert(categoryLength === values.length, 'categoryLength === values.length');\r\n\r\n        target.values = values;\r\n\r\n        let highlights = source.highlights;\r\n        if (highlights) {\r\n            debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\r\n\r\n            target.highlights = highlights;\r\n        }\r\n\r\n        if (source.minLocal !== undefined)\r\n            target.minLocal = source.minLocal;\r\n\r\n        if (source.maxLocal !== undefined)\r\n            target.maxLocal = source.maxLocal;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export function createStaticEvalContext(colorAllocatorCache?: IColorAllocatorCache): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView?: DataView, selectTransforms?: DataViewSelectTransform[]): IEvalContext {\r\n        return new StaticEvalContext(\r\n            colorAllocatorCache || createColorAllocatorCache(),\r\n            dataView || { metadata: { columns: [] } },\r\n            selectTransforms);\r\n    }\r\n\r\n    /**\r\n     * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\r\n     * are supported.\r\n     */\r\n    class StaticEvalContext implements IEvalContext {\r\n        private colorAllocatorCache: IColorAllocatorCache;\r\n        private dataView: DataView;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorCache = colorAllocatorCache;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorCache.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            let dataView = this.dataView,\r\n                selectTransforms = this.selectTransforms;\r\n            if (dataView && dataView.table && selectTransforms)\r\n                return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n    }\r\n\r\n    export function getExprValueFromTable(expr: SQExpr, selectTransforms: DataViewSelectTransform[], table: DataViewTable, rowIdx: number): PrimitiveValue {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n        debug.assertValue(table, 'table');\r\n        debug.assertValue(rowIdx, 'rowIdx');\r\n\r\n        let rows = table.rows;\r\n        if (_.isEmpty(rows) || rows.length <= rowIdx)\r\n            return;\r\n\r\n        let cols = table.columns;\r\n        for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n            let selectTransform = selectTransforms[selectIdx];\r\n            if (!SQExpr.equals(selectTransform.expr, expr) || !selectTransform.queryName)\r\n                continue;\r\n\r\n            for (let colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\r\n                if (selectIdx !== cols[colIdx].index)\r\n                    continue;\r\n\r\n                return rows[rowIdx][colIdx];\r\n            }\r\n        }\r\n\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export function createMatrixEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewMatrix: DataViewMatrix): IEvalContext {\r\n        // NOTE: Matrix context-sensitive evaluation is not yet implemented.\r\n        return createStaticEvalContext(colorAllocatorProvider);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import Formatting = jsCommon.Formatting;\r\n    import RegExpExtensions = jsCommon.RegExpExtensions;\r\n\r\n    /** Culture interfaces. These match the Globalize library interfaces intentionally. */\r\n    export interface Culture {\r\n        name: string;\r\n        calendar: Calendar;\r\n        calendars: CalendarDictionary;\r\n        numberFormat: NumberFormatInfo;\r\n    }\r\n\r\n    export interface Calendar {\r\n        patterns: any;\r\n        firstDay: number;\r\n    }\r\n\r\n    export interface CalendarDictionary {\r\n        [key: string]: Calendar;\r\n    }\r\n\r\n    export interface NumberFormatInfo {\r\n        decimals: number;\r\n        groupSizes: number[];\r\n        negativeInfinity: string;\r\n        positiveInfinity: string;\r\n    }\r\n\r\n    /**\r\n     *  Creating a dummy module to declare cultureInfo string, so we could do a strongly typed usage in Visuals\r\n     */\r\n    declare module powerbi.common {\r\n        let cultureInfo: string;\r\n    }\r\n\r\n    /** Formatting Encoder */\r\n    module FormattingEncoder {\r\n        export function preserveEscaped(format: string, specialChars: string): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = \"\\\\\" + specialChars[i];\r\n                let newText = String.fromCharCode(0xE000 + i);\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreEscaped(format: string, specialChars: string): string {\r\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = String.fromCharCode(0xE000 + i);\r\n                let newText = specialChars[i];\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\r\n        }\r\n\r\n        export function preserveLiterals(format: string, literals: string[]): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            for (let i = 0; ; i++) {\r\n                let fromIndex = format.indexOf(\"'\");\r\n                if (fromIndex < 0) {\r\n                    break;\r\n                }\r\n                let toIndex = format.indexOf(\"'\", fromIndex + 1);\r\n                if (toIndex < 0) {\r\n                    break;\r\n                }\r\n                let literal = format.substring(fromIndex, toIndex + 1);\r\n                literals.push(literal.substring(1, toIndex - fromIndex));\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                format = format.replace(literal, token);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreLiterals(format: string, literals: string[]): string {\r\n            let count = literals.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                let literal = literals[i];\r\n                format = format.replace(token, literal);\r\n            }\r\n            return format;\r\n        }\r\n    }\r\n\r\n    const IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\r\n    const ZeroPlaceholder = '0';\r\n    const DigitPlaceholder = '#';\r\n    const ExponentialFormatChar = 'E';\r\n    const NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\r\n    const NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\r\n\r\n    /** Formatting Service */\r\n    class FormattingService implements IFormattingService {\r\n\r\n        _currentCultureSelector: string;\r\n        _currentCulture: Culture;\r\n        _dateTimeScaleFormatInfo: DateTimeScaleFormatInfo;\r\n\r\n        public formatValue(value: any, format?: string, culture?: string): string {\r\n            // Handle special cases\r\n            if (value === undefined || value === null) {\r\n                return '';\r\n            }\r\n            let gculture = this.getCulture(culture);\r\n\r\n            if (DateTimeFormat.canFormat(value)) {\r\n                // Dates\r\n                return DateTimeFormat.format(value, format, gculture);\r\n            } else if (NumberFormat.canFormat(value)) {\r\n                // Numbers\r\n                return NumberFormat.format(value, format, gculture);\r\n            } else {\r\n                // Other data types - return as string\r\n                return value.toString();\r\n            }\r\n        }\r\n\r\n        public format(formatWithIndexedTokens: string, args: any[], culture?: string): string {\r\n            if (!formatWithIndexedTokens) {\r\n                return \"\";\r\n            }\r\n            let result = formatWithIndexedTokens.replace(IndexedTokensRegex, (match: string, left: string, right: string, argToken: string) => {\r\n                if (left) {\r\n                    return \"{\";\r\n                } else if (right) {\r\n                    return \"}\";\r\n                } else {\r\n                    let parts = argToken.split(\":\");\r\n                    let argIndex = parseInt(parts[0], 10);\r\n                    let argFormat = parts[1];\r\n                    return this.formatValue(args[argIndex], argFormat, culture);\r\n                }\r\n            });\r\n\r\n            return result;\r\n        }\r\n\r\n        public isStandardNumberFormat(format: string): boolean {\r\n            return NumberFormat.isStandardFormat(format);\r\n        }\r\n\r\n        public formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string, culture?: string): string {\r\n            let gculture = this.getCulture(culture);\r\n\r\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\r\n        }\r\n\r\n        public dateFormatString(unit: DateTimeUnit): string {\r\n            if (!this._dateTimeScaleFormatInfo)\r\n                this.initialize();\r\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\r\n        }\r\n\r\n        /**\r\n         * Sets the current localization culture\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         */\r\n        private setCurrentCulture(cultureSelector: string): void {\r\n            if (this._currentCultureSelector !== cultureSelector) {\r\n                this._currentCulture = this.getCulture(cultureSelector);\r\n                this._currentCultureSelector = cultureSelector;\r\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         * Exposing this function for testability of unsupported cultures\r\n         */\r\n        public getCulture(cultureSelector?: string): Culture {\r\n            if (cultureSelector == null) {\r\n                if (this._currentCulture == null) {\r\n                    this.initialize();\r\n                }\r\n                return this._currentCulture;\r\n            } else {\r\n                let culture = Globalize.findClosestCulture(cultureSelector);\r\n                if (!culture)\r\n                    culture = Globalize.culture(\"en-US\");\r\n                return culture;\r\n            }\r\n        }\r\n\r\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\r\n        private initialize() {\r\n            let cultureName = this.getCurrentCulture();\r\n            this.setCurrentCulture(cultureName);\r\n            let calendarName = this.getUrlParam(\"calendar\");\r\n            if (calendarName) {\r\n                let culture = this._currentCulture;\r\n                let c = culture.calendars[calendarName];\r\n                if (c) {\r\n                    culture.calendar = c;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability \r\n         */\r\n        public getCurrentCulture(): string {\r\n            let urlParam = this.getUrlParam(\"language\");\r\n\r\n            if (urlParam) {\r\n                return urlParam;\r\n            }\r\n\r\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\r\n                // Get cultureInfo set in powerbi\r\n                return powerbi.common.cultureInfo;\r\n            }\r\n\r\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability\r\n         *  @param name: queryString name\r\n         */\r\n        public getUrlParam(name: string): string {\r\n            let param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\r\n            return param ? param[1] : undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for dates.\r\n     */\r\n    module DateTimeFormat {\r\n\r\n        let _currentCachedFormat: string;\r\n        let _currentCachedProcessedFormat: string;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = value instanceof Date;\r\n            return result;\r\n        }\r\n\r\n        /** Formats the date using provided format and culture */\r\n        export function format(value: Date, format: string, culture: Culture): string {\r\n            format = format || \"G\";\r\n            let isStandard = format.length === 1;\r\n            try {\r\n                if (isStandard) {\r\n                    return formatDateStandard(value, format, culture);\r\n                } else {\r\n                    return formatDateCustom(value, format, culture);\r\n                }\r\n            } catch (e) {\r\n                return formatDateStandard(value, \"G\", culture);\r\n            }\r\n        }\r\n\r\n        /** Formats the date using standard format expression */\r\n        function formatDateStandard(value: Date, format: string, culture: Culture) {\r\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\r\n            let patterns = culture.calendar.patterns;\r\n            // Extend supported set of patterns\r\n            ensurePatterns(culture.calendar);\r\n            // Handle extended set of formats\r\n            let output = Formatting.findDateFormat(value, format, culture.name);\r\n            if (output.format.length === 1)\r\n                format = patterns[output.format];\r\n            else\r\n                format = output.format;\r\n            //need to revisit when globalization is enabled\r\n            culture = Globalize.culture(\"en-US\");\r\n            return Globalize.format(output.value, format, culture);\r\n        }\r\n\r\n        /** Formats the date using custom format expression */\r\n        function formatDateCustom(value: Date, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let literals: string[] = [];\r\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            format = FormattingEncoder.preserveLiterals(format, literals);\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            if (format.indexOf(\"F\") > -1) {\r\n                // F is not supported so we need to replace the F with f based on the milliseconds\r\n                // Replace all sequences of F longer than 3 with \"FFF\"\r\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\r\n                // Based on milliseconds update the format to use fff\r\n                let milliseconds = value.getMilliseconds();\r\n                if (milliseconds % 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\r\n                if ((milliseconds % 100) / 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\r\n                if ((milliseconds % 1000) / 100 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\r\n                if (format === \"\" || format === \"%\")\r\n                    return \"\";\r\n            }\r\n            format = processCustomDateTimeFormat(format);\r\n            result = Globalize.format(value, format, culture);\r\n            result = localize(result, culture.calendar);\r\n            result = FormattingEncoder.restoreLiterals(result, literals);\r\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            return result;\r\n        }\r\n\r\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\r\n        function processCustomDateTimeFormat(format: string): string {\r\n            if (format === _currentCachedFormat) {\r\n                return _currentCachedProcessedFormat;\r\n            }\r\n            _currentCachedFormat = format;\r\n            format = Formatting.fixDateTimeFormat(format);\r\n            _currentCachedProcessedFormat = format;\r\n            return format;\r\n        }\r\n\r\n        /** Localizes the time separator symbol */\r\n        function localize(value: string, dictionary: any): string {\r\n            let timeSeparator = dictionary[\":\"];\r\n            if (timeSeparator === \":\") {\r\n                return value;\r\n            }\r\n            let result = \"\";\r\n            let count = value.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \":\":\r\n                        result += timeSeparator;\r\n                        break;\r\n                    default:\r\n                        result += char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function ensurePatterns(calendar: GlobalizeCalendar) {\r\n            let patterns = calendar.patterns;\r\n            if (patterns[\"g\"] === undefined) {\r\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, short time\r\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, long time\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * NumberFormat module contains the static methods for formatting the numbers.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for numeric types including custom formats.\r\n     */\r\n    export module NumberFormat {\r\n\r\n        const NonScientificFormatRegex = /^\\{.+\\}.*/;\r\n        const NumericalPlaceHolderRegex = /\\{.+\\}/;\r\n        const ScientificFormatRegex = /e[+-]*[0#]+/i;\r\n        const StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\r\n        const TrailingZerosRegex = /0+$/;\r\n        const DecimalFormatRegex = /\\.([0#]*)/g;\r\n        const NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\r\n        const LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\r\n        const DecimalFormatCharacter = '.';\r\n\r\n        export const NumberFormatComponentsDelimeter = ';';\r\n\r\n        export interface NumericFormatMetadata {\r\n            format: string;\r\n            hasEscapes: boolean;\r\n            hasQuotes: boolean;\r\n            hasE: boolean;\r\n            hasCommas: boolean;\r\n            hasDots: boolean;\r\n            hasPercent: boolean;\r\n            hasPermile: boolean;\r\n            precision: number;\r\n            scale: number;\r\n        }\r\n\r\n        export interface NumberFormatComponents {\r\n            hasNegative: boolean;\r\n            positive: string;\r\n            negative: string;\r\n            zero: string;\r\n        }\r\n\r\n        function getNonScientificFormatWithPrecision(baseFormat: string, numericFormat: string): string {\r\n            if (!numericFormat || baseFormat === undefined)\r\n                return baseFormat;\r\n\r\n            let newFormat = \"{0:\" + numericFormat + \"}\";\r\n\r\n            return baseFormat.replace(\"{0}\", newFormat);\r\n        }\r\n\r\n        export function getNumericFormat(value: number, baseFormat: string): string {\r\n            if (baseFormat == null)\r\n                return baseFormat;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n\r\n                if (value > 0)\r\n                    return getNumericFormatFromComponent(value, positive);\r\n                else if (value === 0)\r\n                    return getNumericFormatFromComponent(value, zero);\r\n\r\n                return getNumericFormatFromComponent(value, negative);\r\n            }\r\n\r\n            return getNumericFormatFromComponent(value, baseFormat);\r\n        }\r\n\r\n        function getNumericFormatFromComponent(value: number, format: string): string {\r\n            let match = RegExpExtensions.run(NumericFormatRegex, format);\r\n            if (match)\r\n                return match[0];\r\n\r\n            return format;\r\n        }\r\n\r\n        export function addDecimalsToFormat(baseFormat: string, decimals: number, trailingZeros: boolean): string {\r\n            if (decimals == null)\r\n                return baseFormat;\r\n\r\n            // Default format string\r\n            if (baseFormat == null)\r\n                baseFormat = ZeroPlaceholder;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n                let formats = [positive, negative, zero];\r\n                for (let i = 0; i < formats.length; i++) {\r\n                    // Update format in formats array\r\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\r\n                }\r\n\r\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\r\n            }\r\n\r\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\r\n        }\r\n\r\n        function addDecimalsToFormatComponent(format: string, decimals: number, trailingZeros: boolean): string {\r\n            decimals = Math.abs(decimals);\r\n\r\n            if (decimals >= 0) {\r\n                let placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\r\n                let decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\r\n\r\n                let match = RegExpExtensions.run(DecimalFormatRegex, format);\r\n                if (match) {\r\n                    let beforeDecimal = format.substr(0, match.index);\r\n                    let formatDecimal = format.substr(match.index + 1, match[1].length);\r\n                    let afterDecimal = format.substr(match.index + match[0].length);\r\n\r\n                    if (trailingZeros)\r\n                        // Use explicit decimals argument as placeholders\r\n                        formatDecimal = decimalPlaceholders;\r\n                    else {\r\n                        let decimalChange = decimalPlaceholders.length - formatDecimal.length;\r\n                        if (decimalChange > 0)\r\n                            // Append decimalPlaceholders to existing decimal portion of format string\r\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\r\n                        else if (decimalChange < 0)\r\n                            // Remove decimals from formatDecimal\r\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\r\n                    }\r\n\r\n                    if (formatDecimal.length > 0)\r\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\r\n\r\n                    return beforeDecimal + formatDecimal + afterDecimal;\r\n                }\r\n                else if (decimalPlaceholders.length > 0)\r\n                    // Replace last numeric placeholder with decimal portion\r\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\r\n            }\r\n\r\n            return format;\r\n        }\r\n\r\n        export function hasFormatComponents(format: string): boolean {\r\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\r\n        }\r\n\r\n        export function getComponents(format: string): NumberFormatComponents {\r\n            let signFormat: NumberFormatComponents = {\r\n                hasNegative: false,\r\n                positive: format,\r\n                negative: format,\r\n                zero: format,\r\n            };\r\n\r\n            let signSpecificFormats = format.split(NumberFormatComponentsDelimeter);\r\n            let formatCount = signSpecificFormats.length;\r\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\r\n\r\n            if (formatCount > 1) {\r\n                signFormat.hasNegative = true;\r\n\r\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\r\n                signFormat.negative = signSpecificFormats[1];\r\n\r\n                if (formatCount > 2)\r\n                    signFormat.zero = signSpecificFormats[2];\r\n            }\r\n\r\n            return signFormat;\r\n        }\r\n\r\n        let _lastCustomFormatMeta: NumericFormatMetadata;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = typeof (value) === \"number\";\r\n            return result;\r\n        }\r\n\r\n        export function isStandardFormat(format: string): boolean {\r\n            debug.assertValue(format, 'format');\r\n            return StandardFormatRegex.test(format);\r\n        }\r\n\r\n        /** Formats the number using specified format expression and culture */\r\n        export function format(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture): string {\r\n            format = format || \"G\";\r\n            try {\r\n                if (isStandardFormat(format))\r\n                    return formatNumberStandard(value, format, culture);\r\n\r\n                return formatNumberCustom(value, format, culture);\r\n            } catch (e) {\r\n                return Globalize.format(value, undefined, culture);\r\n            }\r\n        }\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        export function formatWithCustomOverride(\r\n            value: number,\r\n            format: string,\r\n            nonScientificOverrideFormat: string,\r\n            culture: Culture): string {\r\n            debug.assertValue(value, 'value');\r\n            debug.assertValue(format, 'format');\r\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\r\n            debug.assertValue(culture, 'culture');\r\n            debug.assert(!isStandardFormat(format), 'Standard format');\r\n\r\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\r\n        }\r\n\r\n        /** Formats the number using standard format expression */\r\n        function formatNumberStandard(value: number, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let precision = <number>(format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\r\n            let numberFormatInfo = culture.numberFormat;\r\n            let formatChar = format.charAt(0);\r\n            switch (formatChar) {\r\n                case \"e\":\r\n                case \"E\":\r\n                    if (precision === undefined) {\r\n                        precision = 6;\r\n                    }\r\n                    let mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\r\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\r\n                    result = formatNumberCustom(value, format, culture);\r\n                    break;\r\n                case \"f\":\r\n                case \"F\":\r\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    let abs = Math.abs(value);\r\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\r\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\r\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\r\n                    } else {\r\n                        // Otherwise use exponential\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\r\n                        result = result.replace(\"e\", \"E\");\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"r\":\r\n                case \"R\":\r\n                    result = value.toString();\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"x\":\r\n                case \"X\":\r\n                    result = value.toString(16);\r\n                    if (formatChar === \"X\") {\r\n                        result = result.toUpperCase();\r\n                    }\r\n                    if (precision !== undefined) {\r\n                        let actualPrecision = result.length;\r\n                        let isNegative = value < 0;\r\n                        if (isNegative) {\r\n                            actualPrecision--;\r\n                        }\r\n                        let paddingZerosCount = precision - actualPrecision;\r\n                        let paddingZeros = undefined;\r\n                        if (paddingZerosCount > 0) {\r\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\r\n                        }\r\n                        if (isNegative) {\r\n                            result = \"-\" + paddingZeros + result.substr(1);\r\n                        } else {\r\n                            result = paddingZeros + result;\r\n                        }\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                default:\r\n                    result = Globalize.format(value, format, culture);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Formats the number using custom format expression */\r\n        function formatNumberCustom(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture,\r\n            nonScientificOverrideFormat?: string): string {\r\n            let result: string;\r\n            let numberFormatInfo = culture.numberFormat;\r\n            if (isFinite(value)) {\r\n                // Split format by positive[;negative;zero] pattern\r\n                let formatComponents = getComponents(format);\r\n\r\n                // Pick a format based on the sign of value\r\n                if (value > 0) {\r\n                    format = formatComponents.positive;\r\n                } else if (value === 0) {\r\n                    format = formatComponents.zero;\r\n                } else {\r\n                    format = formatComponents.negative;\r\n                }\r\n\r\n                // Normalize value if we have an explicit negative format\r\n                if (formatComponents.hasNegative)\r\n                    value = Math.abs(value);\r\n\r\n                // Get format metadata\r\n                let formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\r\n\r\n                // Preserve literals and escaped chars\r\n                if (formatMeta.hasEscapes) {\r\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%\");\r\n                }\r\n                let literals: string[] = [];\r\n                if (formatMeta.hasQuotes) {\r\n                    format = FormattingEncoder.preserveLiterals(format, literals);\r\n                }\r\n\r\n                // Scientific format\r\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\r\n                    let scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\r\n                    if (scientificMatch) {\r\n                        // Case 2.1. Scientific custom format\r\n                        let formatM = format.substr(0, scientificMatch.index);\r\n                        let formatE = format.substr(scientificMatch.index + 2); // E(+|-)\r\n                        let precision = getCustomFormatPrecision(formatM, formatMeta);\r\n                        let scale = getCustomFormatScale(formatM, formatMeta);\r\n                        if (scale !== 1) {\r\n                            value = value * scale;\r\n                        }\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        let s = value.toExponential(precision);\r\n                        let indexOfE = s.indexOf(\"e\");\r\n                        let mantissa = s.substr(0, indexOfE);\r\n                        let exp = s.substr(indexOfE + 1);\r\n                        let resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\r\n                        let resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\r\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\r\n                            resultE = resultE.substr(1);\r\n                        }\r\n                        let e = scientificMatch[0].charAt(0);\r\n                        result = resultM + e + resultE;\r\n                    }\r\n                }\r\n\r\n                // Non scientific format\r\n                if (result === undefined) {\r\n                    let valueFormatted: string;\r\n                    let isValueGlobalized: boolean = false;\r\n                    let precision = getCustomFormatPrecision(format, formatMeta);\r\n                    let scale = getCustomFormatScale(format, formatMeta);\r\n\r\n                    if (scale !== 1)\r\n                        value = value * scale;\r\n\r\n                    // Rounding\r\n                    value = parseFloat(toNonScientific(value, precision));\r\n\r\n                    if (nonScientificOverrideFormat) {\r\n                        // Get numeric format from format string\r\n                        let numericFormat = NumberFormat.getNumericFormat(value, format);\r\n\r\n                        // Add separators and decimalFormat to nonScientificFormat\r\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\r\n\r\n                        // Format the value\r\n                        valueFormatted = formattingService.format(nonScientificOverrideFormat, [value], culture.name);\r\n                        isValueGlobalized = true;\r\n                    }\r\n                    else\r\n                        valueFormatted = toNonScientific(value, precision);\r\n\r\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\r\n                }\r\n                if (formatMeta.hasQuotes) {\r\n                    result = FormattingEncoder.restoreLiterals(result, literals);\r\n                }\r\n                if (formatMeta.hasEscapes) {\r\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%\");\r\n                }\r\n\r\n                _lastCustomFormatMeta = formatMeta;\r\n            } else {\r\n                return Globalize.format(value, undefined);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Returns string with the fixed point respresentation of the number */\r\n        function toNonScientific(value: number, precision: number): string {\r\n            let result = \"\";\r\n            let precisionZeros = 0;\r\n            // Double precision numbers support actual 15-16 decimal digits of precision.\r\n            if (precision > 16) {\r\n                precisionZeros = precision - 16;\r\n                precision = 16;\r\n            }\r\n            let digitsBeforeDecimalPoint = Double.log10(Math.abs(value));\r\n            if (digitsBeforeDecimalPoint < 16) {\r\n                if (digitsBeforeDecimalPoint > 0) {\r\n                    let maxPrecision = 16 - digitsBeforeDecimalPoint;\r\n                    if (precision > maxPrecision) {\r\n                        precisionZeros += precision - maxPrecision;\r\n                        precision = maxPrecision;\r\n                    }\r\n                }\r\n                result = value.toFixed(precision);\r\n            } else if (digitsBeforeDecimalPoint === 16) {\r\n                result = value.toFixed(0);\r\n                precisionZeros += precision;\r\n                if (precisionZeros > 0) {\r\n                    result += \".\";\r\n                }\r\n            } else { // digitsBeforeDecimalPoint > 16\r\n                // Different browsers have different implementations of the toFixed().\r\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\r\n                // So we need to check for range and convert the to exponential with the max precision.\r\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\r\n                // Assert that value is a number and fall back on returning value if it is not\r\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                if (typeof (value) !== \"number\")\r\n                    return String(value);\r\n                result = value.toExponential(15);\r\n                let indexOfE = result.indexOf(\"e\");\r\n                if (indexOfE > 0) {\r\n                    let indexOfDot = result.indexOf(\".\");\r\n                    let mantissa = result.substr(0, indexOfE);\r\n                    let exp = result.substr(indexOfE + 1);\r\n                    let powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\r\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\r\n                    if (precision > 0) {\r\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\r\n                    }\r\n                }\r\n            }\r\n            if (precisionZeros > 0) {\r\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the formatMetadata of the format\r\n         * When calculating precision and scale, if format string of\r\n         * positive[;negative;zero] => positive format will be used\r\n         * @param (required) format - format string\r\n         * @param (optional) calculatePrecision - calculate precision of positive format\r\n         * @param (optional) calculateScale - calculate scale of positive format\r\n         */\r\n        export function getCustomFormatMetadata(format: string, calculatePrecision?: boolean, calculateScale?: boolean): NumericFormatMetadata {\r\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\r\n                return _lastCustomFormatMeta;\r\n            }\r\n\r\n            let result = {\r\n                format: format,\r\n                hasEscapes: false,\r\n                hasQuotes: false,\r\n                hasE: false,\r\n                hasCommas: false,\r\n                hasDots: false,\r\n                hasPercent: false,\r\n                hasPermile: false,\r\n                precision: undefined,\r\n                scale: undefined,\r\n            };\r\n\r\n            for (let i = 0, length = format.length; i < length; i++) {\r\n                let c = format.charAt(i);\r\n                switch (c) {\r\n                    case \"\\\\\":\r\n                        result.hasEscapes = true;\r\n                        break;\r\n                    case \"'\":\r\n                    case \"\\\"\":\r\n                        result.hasQuotes = true;\r\n                        break;\r\n                    case \"e\":\r\n                    case \"E\":\r\n                        result.hasE = true;\r\n                        break;\r\n                    case \",\":\r\n                        result.hasCommas = true;\r\n                        break;\r\n                    case \".\":\r\n                        result.hasDots = true;\r\n                        break;\r\n                    case \"%\":\r\n                        result.hasPercent = true;\r\n                        break;\r\n                    case \"\":\r\n                        result.hasPermile = true;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Use positive format for calculating these values\r\n            let formatComponents = getComponents(format);\r\n\r\n            if (calculatePrecision)\r\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\r\n            if (calculateScale)\r\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\r\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\r\n        function getCustomFormatPrecision(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.precision > -1) {\r\n                return formatMeta.precision;\r\n            }\r\n            let result = 0;\r\n            if (formatMeta.hasDots) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex > -1) {\r\n                    let count = format.length;\r\n                    for (let i = dotIndex; i < count; i++) {\r\n                        let char = format.charAt(i);\r\n                        if (char.match(NumericPlaceholderRegex))\r\n                            result++;\r\n                        // 0.00E+0 :: Break before counting 0 in\r\n                        // exponential portion of format string\r\n                        if (char === ExponentialFormatChar)\r\n                            break;\r\n                    }\r\n                    result = Math.min(19, result);\r\n                }\r\n            }\r\n\r\n            formatMeta.precision = result;\r\n            return result;\r\n        }\r\n\r\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\r\n        function getCustomFormatScale(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.scale > -1) {\r\n                return formatMeta.scale;\r\n            }\r\n            let result = 1;\r\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\r\n                result = result * 100;\r\n            }\r\n            if (formatMeta.hasPermile && format.indexOf(\"\") > -1) {\r\n                result = result * 1000;\r\n            }\r\n            if (formatMeta.hasCommas) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex === -1) {\r\n                    dotIndex = format.length;\r\n                }\r\n                for (let i = dotIndex - 1; i > -1; i--) {\r\n                    let char = format.charAt(i);\r\n                    if (char === \",\") {\r\n                        result = result / 1000;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            formatMeta.scale = result;\r\n            return result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormat(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, nonScientificOverrideFormat?: string, isValueGlobalized?: boolean): string {\r\n            let suppressModifyValue = !!nonScientificOverrideFormat;\r\n            let formatParts = format.split(\".\", 2);\r\n            if (formatParts.length === 2) {\r\n                let wholeFormat = formatParts[0];\r\n                let fractionFormat = formatParts[1];\r\n                let displayUnit = \"\";\r\n\r\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\r\n                if (nonScientificOverrideFormat) {\r\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\r\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\r\n                    value = value.replace(displayUnit, \"\");\r\n                }\r\n\r\n                let globalizedDecimalSeparator = numberFormatInfo[\".\"];\r\n                let decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\r\n                let valueParts = value.split(decimalSeparator, 2);\r\n                let wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\r\n                let fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\r\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\r\n\r\n                let wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\r\n                let fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\r\n\r\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\r\n                    return wholeFormattedValue + fractionFormattedValue.value;\r\n\r\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\r\n            }\r\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatLeft(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, suppressModifyValue?: boolean): string {\r\n            let groupSymbolIndex = format.indexOf(\",\");\r\n            let enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\r\n            let groupDigitCount = 0;\r\n            let groupIndex = 0;\r\n            let groupSizes = numberFormatInfo.groupSizes || [3];\r\n            let groupSize = groupSizes[0];\r\n            let groupSeparator = numberFormatInfo[\",\"];\r\n            let sign = \"\";\r\n            let firstChar = value.charAt(0);\r\n            if (firstChar === \"+\" || firstChar === \"-\") {\r\n                sign = numberFormatInfo[firstChar];\r\n                value = value.substr(1);\r\n            }\r\n            let isZero = value === \"0\";\r\n            let result = \"\";\r\n            let leftBuffer = \"\";\r\n            let vi = value.length - 1;\r\n            let fmtOnly = true;\r\n            // Iterate through format chars and replace 0 and # with the digits from the value string\r\n            for (let fi = format.length - 1; fi > -1; fi--) {\r\n                let formatChar = format.charAt(fi);\r\n                switch (formatChar) {\r\n                    case ZeroPlaceholder:\r\n                    case DigitPlaceholder:\r\n                        fmtOnly = false;\r\n                        if (leftBuffer !== \"\") {\r\n                            result = leftBuffer + result;\r\n                            leftBuffer = \"\";\r\n                        }\r\n                        if (!suppressModifyValue) {\r\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\r\n                                if (enableGroups) {\r\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\r\n                                    if (groupDigitCount === groupSize) {\r\n                                        result = groupSeparator + result;\r\n                                        groupIndex++;\r\n                                        if (groupIndex < groupSizes.length) {\r\n                                            groupSize = groupSizes[groupIndex];\r\n                                        }\r\n                                        groupDigitCount = 1;\r\n                                    } else {\r\n                                        groupDigitCount++;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (vi > -1) {\r\n                                if (isZero && formatChar === DigitPlaceholder) {\r\n                                    // Special case - if we need to format a zero value and the # symbol is used - we don't copy it into the result)\r\n                                } else {\r\n                                    result = value.charAt(vi) + result;\r\n                                }\r\n                                vi--;\r\n                            } else if (formatChar !== DigitPlaceholder) {\r\n                                result = formatChar + result;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \",\":\r\n                        // We should skip all the , chars\r\n                        break;\r\n                    default:\r\n                        leftBuffer = formatChar + leftBuffer;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\r\n            if (!suppressModifyValue) {\r\n                if (vi > -1 && result !== \"\") {\r\n                    if (enableGroups) {\r\n                        while (vi > -1) {\r\n                            if (groupDigitCount === groupSize) {\r\n                                result = groupSeparator + result;\r\n                                groupIndex++;\r\n                                if (groupIndex < groupSizes.length) {\r\n                                    groupSize = groupSizes[groupIndex];\r\n                                }\r\n                                groupDigitCount = 1;\r\n                            } else {\r\n                                groupDigitCount++;\r\n                            }\r\n                            result = value.charAt(vi) + result;\r\n                            vi--;\r\n                        }\r\n                    } else {\r\n                        result = value.substr(0, vi + 1) + result;\r\n                    }\r\n                }\r\n                // Insert sign in front of the leftBuffer and result\r\n                return sign + leftBuffer + result;\r\n            }\r\n\r\n            if (fmtOnly)\r\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\r\n                return sign + leftBuffer + result;\r\n\r\n            return sign + leftBuffer + value + result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatRight(value: string, format: string, suppressModifyValue?: boolean): { value: string; fmtOnly?: boolean } {\r\n            let vi = 0;\r\n            let fCount = format.length;\r\n            let vCount = value.length;\r\n\r\n            if (suppressModifyValue) {\r\n                debug.assert(fCount > 0, \"Empty formatting string\");\r\n\r\n                let lastChar = format.charAt(fCount - 1);\r\n                if (!lastChar.match(NumericPlaceholderRegex))\r\n                    return {\r\n                        value: value + lastChar,\r\n                        fmtOnly: value === \"\",\r\n                    };\r\n\r\n                return {\r\n                    value: value,\r\n                    fmtOnly: value === \"\",\r\n                };\r\n            }\r\n\r\n            let result = \"\",\r\n                fmtOnly: boolean = true;\r\n            for (let fi = 0; fi < fCount; fi++) {\r\n                let formatChar = format.charAt(fi);\r\n                if (vi < vCount) {\r\n                    switch (formatChar) {\r\n                        case ZeroPlaceholder:\r\n                        case DigitPlaceholder:\r\n                            result += value[vi++];\r\n                            fmtOnly = false;\r\n                            break;\r\n                        default:\r\n                            result += formatChar;\r\n                    }\r\n                } else {\r\n                    if (formatChar !== DigitPlaceholder) {\r\n                        result += formatChar;\r\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                value: result,\r\n                fmtOnly: fmtOnly,\r\n            };\r\n        }\r\n\r\n        function localize(value: string, dictionary: any): string {\r\n            let plus = dictionary[\"+\"];\r\n            let minus = dictionary[\"-\"];\r\n            let dot = dictionary[\".\"];\r\n            let comma = dictionary[\",\"];\r\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\r\n                return value;\r\n            }\r\n            let count = value.length;\r\n            let result = \"\";\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \"+\":\r\n                        result = result + plus;\r\n                        break;\r\n                    case \"-\":\r\n                        result = result + minus;\r\n                        break;\r\n                    case \".\":\r\n                        result = result + dot;\r\n                        break;\r\n                    case \",\":\r\n                        result = result + comma;\r\n                        break;\r\n                    default:\r\n                        result = result + char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n    }\r\n\r\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\r\n    class DateTimeScaleFormatInfo {\r\n\r\n        // Fields\r\n        public YearPattern: string;\r\n        public MonthPattern: string;\r\n        public DayPattern: string;\r\n        public HourPattern: string;\r\n        public MinutePattern: string;\r\n        public SecondPattern: string;\r\n        public MillisecondPattern: string;\r\n\r\n        // Constructor\r\n        /**\r\n         * Creates new instance of the DateTimeScaleFormatInfo class.\r\n         * @param culture - culture which calendar info is going to be used to derive the formats.\r\n         */\r\n        constructor(culture: Culture) {\r\n            let calendar: Calendar = culture.calendar;\r\n            let patterns: any = calendar.patterns;\r\n            let monthAbbreviations: any = calendar[\"months\"][\"namesAbbr\"];\r\n            let cultureHasMonthAbbr: boolean = monthAbbreviations && monthAbbreviations[0];\r\n            let yearMonthPattern: string = patterns[\"Y\"];\r\n            let monthDayPattern: string = patterns[\"M\"];\r\n            let fullPattern: string = patterns[\"f\"];\r\n            let longTimePattern: string = patterns[\"T\"];\r\n            let shortTimePattern: string = patterns[\"t\"];\r\n            let separator: string = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\r\n\r\n            let hasYearSymbol: boolean = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\r\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\r\n\r\n            let yearPos: number = fullPattern.indexOf(\"yy\");\r\n            let monthPos: number = fullPattern.indexOf(\"MMMM\");\r\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\r\n\r\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\r\n\r\n            let minutePos: number = fullPattern.indexOf(\"mm\");\r\n            let pmPos: number = fullPattern.indexOf(\"tt\");\r\n            let shortHourPattern: string = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\r\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\r\n\r\n            this.MinutePattern = shortTimePattern;\r\n\r\n            this.SecondPattern = longTimePattern;\r\n\r\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\r\n\r\n            // Special cases\r\n            switch (culture.name) {\r\n                case \"fi-FI\":\r\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\r\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Methods\r\n\r\n        /**\r\n         * Returns the format string of the provided DateTimeUnit.\r\n         * @param unit - date or time unit\r\n         */\r\n        public getFormatString(unit: DateTimeUnit): string {\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return this.YearPattern;\r\n                case DateTimeUnit.Month:\r\n                    return this.MonthPattern;\r\n                case DateTimeUnit.Week:\r\n                case DateTimeUnit.Day:\r\n                    return this.DayPattern;\r\n                case DateTimeUnit.Hour:\r\n                    return this.HourPattern;\r\n                case DateTimeUnit.Minute:\r\n                    return this.MinutePattern;\r\n                case DateTimeUnit.Second:\r\n                    return this.SecondPattern;\r\n                case DateTimeUnit.Millisecond:\r\n                    return this.MillisecondPattern;\r\n            }\r\n\r\n            debug.assertFail('Unexpected unit: ' + unit);\r\n        }\r\n    }\r\n\r\n    export var formattingService: IFormattingService = new FormattingService();\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\r\n    export module SQExprShortSerializer {\r\n        export function serialize(expr: SQExpr): string {\r\n            return JSON.stringify(expr.accept(SQExprSerializer.instance));\r\n        }\r\n\r\n        export function serializeArray(exprs: SQExpr[]): string {\r\n            let str = '[';\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                if (i > 0)\r\n                    str += ',';\r\n                str += SQExprShortSerializer.serialize(exprs[i]);\r\n            }\r\n            return str + ']';\r\n        }\r\n\r\n        /** Responsible for serializing an SQExpr into a comparable string. */\r\n        class SQExprSerializer extends DefaultSQExprVisitor<{}> {\r\n            public static instance: SQExprSerializer = new SQExprSerializer();\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): {} {\r\n                return {\r\n                    col: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): {} {\r\n                return {\r\n                    measure: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): {} {\r\n                return {\r\n                    agg: {\r\n                        a: expr.arg.accept(this),\r\n                        f: expr.func,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitEntity(expr: SQEntityExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n                debug.assertValue(expr.entity, 'expr.entity');\r\n\r\n                return {\r\n                    e: expr.entity\r\n                };\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): {} {\r\n                return {\r\n                    h: expr.arg.accept(this),\r\n                    l: expr.level,\r\n                };\r\n            }\r\n\r\n            public visitHierarchy(expr: SQHierarchyExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    h: expr.hierarchy,\r\n                };\r\n            }\r\n\r\n            public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    n: expr.name,\r\n                    p: expr.property,\r\n                };\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    and: {\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    comp: {\r\n                        k: expr.comparison,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    const: {\r\n                        t: expr.type.primitiveType,\r\n                        v: expr.value,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    arithmetic: {\r\n                        o: expr.operator,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitScopedEval(expr: SQScopedEvalExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    scopedEval: {\r\n                        e: expr.expression.accept(this),\r\n                        s: serializeArray(expr.scope)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): {} {\r\n                debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n    import Selector = powerbi.data.Selector;\r\n    import SelectorsByColumn = powerbi.SelectorsByColumn;\r\n    import SelectorForColumn = powerbi.SelectorForColumn;\r\n\r\n    /**\r\n     * A combination of identifiers used to uniquely identify\r\n     * data points and their bound geometry.\r\n     */\r\n    export class SelectionId implements ISelectionId {\r\n        private selector: Selector;\r\n        // This is a new data structure to support drilling -- in the long term it should replace the 'selector' field\r\n        private selectorsByColumn: SelectorsByColumn;\r\n        private key: string;\r\n        private keyWithoutHighlight: string;\r\n\r\n        public highlight: boolean;\r\n\r\n        constructor(selector: Selector, highlight: boolean) {\r\n            this.selector = selector;\r\n            this.highlight = highlight;\r\n            this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\r\n            this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\r\n        }\r\n\r\n        public equals(other: SelectionId): boolean {\r\n            if (!this.selector || !other.selector) {\r\n                return (!this.selector === !other.selector) && this.highlight === other.highlight;\r\n            }\r\n            return this.highlight === other.highlight &&  Selector.equals(this.selector, other.selector);\r\n        }\r\n        \r\n        /**\r\n         * Checks equality against other for all identifiers existing in this.\r\n         */\r\n        public includes(other: SelectionId, ignoreHighlight: boolean = false): boolean {\r\n            let thisSelector = this.selector;\r\n            let otherSelector = other.selector;\r\n            if (!thisSelector || !otherSelector) {\r\n                return false;\r\n            }\r\n            let thisData = thisSelector.data;\r\n            let otherData = otherSelector.data;\r\n            if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\r\n                return false;\r\n            if (!ignoreHighlight && this.highlight !== other.highlight)\r\n                return false;\r\n            if (thisData) {\r\n                if (!otherData)\r\n                    return false;\r\n                if (thisData.length > 0) {\r\n                    for (let i = 0, ilen = thisData.length; i < ilen; i++) {\r\n                        var thisValue = <DataViewScopeIdentity>thisData[i];\r\n                        if (!otherData.some((otherValue: DataViewScopeIdentity) => DataViewScopeIdentity.equals(thisValue, otherValue)))\r\n                            return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public getKey(): string {\r\n            return this.key;\r\n        }\r\n\r\n        public getKeyWithoutHighlight(): string {\r\n            return this.keyWithoutHighlight;\r\n        }\r\n        \r\n        /**\r\n         * Temporary workaround since a few things currently rely on this, but won't need to.\r\n         */\r\n        public hasIdentity(): boolean {\r\n            return (this.selector && !!this.selector.data);\r\n        }\r\n\r\n        public getSelector(): Selector {\r\n            return this.selector;\r\n        }\r\n\r\n        public getSelectorsByColumn(): Selector {\r\n            return this.selectorsByColumn;\r\n        }\r\n\r\n        public static createNull(highlight: boolean = false): SelectionId {\r\n            return new SelectionId(null, highlight);\r\n        }\r\n\r\n        public static createWithId(id: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            if (id) {\r\n                selector = {\r\n                    data: [id]\r\n                };\r\n            }\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithMeasure(measureId: string, highlight: boolean = false): SelectionId {\r\n            debug.assertValue(measureId, 'measureId');\r\n\r\n            let selector: Selector = {\r\n                metadata: measureId\r\n            };\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n            selectionId.selectorsByColumn = { metadata: measureId };\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasure(id: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: powerbi.data.Selector = {};\r\n            if (id) {\r\n                selector.data = [id];\r\n            }\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id && !measureId)\r\n                selector = null;\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasureAndCategory(id: DataViewScopeIdentity, measureId: string, queryName: string, highlight: boolean = false): SelectionId {\r\n            let selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\r\n\r\n            if (selectionId.selector) {\r\n                selectionId.selectorsByColumn = {};\r\n                if (id && queryName) {\r\n                    selectionId.selectorsByColumn.dataMap = {};\r\n                    selectionId.selectorsByColumn.dataMap[queryName] = id;\r\n                }\r\n                if (measureId)\r\n                    selectionId.selectorsByColumn.metadata = measureId;\r\n            }\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIds(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector = { data: selectorData };\r\n            \r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithIdsAndMeasure(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = {};\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector.data = selectorData;\r\n\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id1 && !id2 && !measureId)\r\n                selector = null;\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithSelectorForColumnAndMeasure(dataMap: SelectorForColumn, measureId: string, highlight: boolean = false): SelectionId {\r\n\r\n            let selectionId: visuals.SelectionId;\r\n            let keys = Object.keys(dataMap);\r\n            if (keys.length === 2) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], <DataViewScopeIdentity>dataMap[keys[1]], measureId, highlight);\r\n            } else if (keys.length === 1) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], null, measureId, highlight);\r\n            } else {\r\n                selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\r\n            }\r\n\r\n            let selectorsByColumn: SelectorsByColumn = {};\r\n            if (!_.isEmpty(dataMap))\r\n                selectorsByColumn.dataMap = dataMap;\r\n            if (measureId)\r\n                selectorsByColumn.metadata = measureId;\r\n            if (!dataMap && !measureId)\r\n                selectorsByColumn = null;\r\n\r\n            selectionId.selectorsByColumn = selectorsByColumn;\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithHighlight(original: SelectionId): SelectionId {\r\n            debug.assertValue(original, 'original');\r\n            debug.assert(!original.highlight, '!original.highlight');\r\n\r\n            let newId = new SelectionId(original.getSelector(), /*highlight*/ true);\r\n            newId.selectorsByColumn = original.selectorsByColumn;\r\n\r\n            return newId;\r\n        }\r\n\r\n        private static idArray(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity): DataViewScopeIdentity[] {\r\n            if (id1 || id2) {\r\n                let data = [];\r\n                if (id1)\r\n                    data.push(id1);\r\n                if (id2 && id2 !== id1)\r\n                    data.push(id2);\r\n                return data;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This class is designed to simplify the creation of SelectionId objects\r\n     * It allows chaining to build up an object before calling 'create' to build a SelectionId\r\n     */\r\n    export class SelectionIdBuilder implements ISelectionIdBuilder {\r\n        private dataMap: SelectorForColumn;\r\n        private measure: string;\r\n\r\n        public static builder(): SelectionIdBuilder {\r\n            return new SelectionIdBuilder();\r\n        }\r\n\r\n        public withCategory(categoryColumn: DataViewCategoryColumn, index: number): this{\r\n            if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\r\n                this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\r\n            \r\n            return this;\r\n        }\r\n\r\n        public withSeries(seriesColumn: DataViewValueColumns, valueColumn: DataViewValueColumn | DataViewValueColumnGroup): this {\r\n            if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\r\n                this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\r\n\r\n            return this;\r\n        }\r\n\r\n        public withMeasure(measureId: string): this {\r\n            this.measure = measureId;\r\n\r\n            return this;\r\n        }\r\n\r\n        public createSelectionId(): SelectionId {\r\n            return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\r\n        }\r\n\r\n        private ensureDataMap(): SelectorForColumn {\r\n            if (!this.dataMap)\r\n                this.dataMap = {};\r\n\r\n            return this.dataMap;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"/source/"}