{"version":3,"sources":["VisualsData.js","../ts/visualsData/semanticQuery/sqExprVisitor.ts","../ts/visualsData/types/enumType.ts","../ts/visualsData/types/fill.ts","../ts/visualsData/types/image.ts","../ts/visualsData/types/structuralType.ts","../ts/visualsData/types/valueType.ts","../ts/visualsData/contracts/dataShapeBinding.ts","../ts/visualsData/contracts/dataShapeBindingDataReduction.ts","../ts/visualsData/contracts/federatedConceptualSchema.ts","../ts/visualsData/contracts/selector.ts","../ts/visualsData/contracts/query.ts","../ts/visualsData/contracts/queryProjection.ts","../ts/visualsData/contracts/visualData.ts","../ts/visualsData/formatting/dateTimeSequence.ts","../ts/visualsData/formatting/displayUnitSystem.ts","../ts/visualsData/formatting/numericSequence.ts","../ts/visualsData/formatting/numericSequenceRange.ts","../ts/visualsData/formatting/valueFormatter.ts","../ts/visualsData/dataView/dataRoleHelper.ts","../ts/visualsData/dataView/dataViewCategoricalReader.ts","../ts/visualsData/dataView/dataViewConcatenateCategoricalColumns.ts","../ts/visualsData/dataView/dataViewMappingVisitor.ts","../ts/visualsData/dataView/dataViewNormalizeValues.ts","../ts/visualsData/dataView/dataViewObject.ts","../ts/visualsData/dataView/dataViewObjectDefinition.ts","../ts/visualsData/dataView/dataViewObjectDescriptor.ts","../ts/visualsData/dataView/dataViewObjectEvaluationUtils.ts","../ts/visualsData/dataView/dataViewObjectEvaluator.ts","../ts/visualsData/dataView/dataViewPivotCategorical.ts","../ts/visualsData/dataView/dataViewPivotMatrix.ts","../ts/visualsData/dataView/dataViewSelfCrossJoin.ts","../ts/visualsData/dataView/dataViewPivotCategoricalToPrimaryGroups.ts","../ts/visualsData/dataView/dataViewTransform.ts","../ts/visualsData/displayNameGetter.ts","../ts/visualsData/iFormattingService.ts","../ts/visualsData/semanticQuery/exprPatterns/fieldExprPattern.ts","../ts/visualsData/dataView/dataViewAnalysis.ts","../ts/visualsData/dataView/dataViewRoleWildcard.ts","../ts/visualsData/dataView/dataViewScopeIdentity.ts","../ts/visualsData/dataView/dataViewScopeWildcard.ts","../ts/visualsData/dataView/rules/colorAllocatorCache.ts","../ts/visualsData/dataView/dataViewRegression.ts","../ts/visualsData/dataView/dataViewSelectTransform.ts","../ts/visualsData/dataView/rules/categoricalEvalContext.ts","../ts/visualsData/dataView/rules/tableEvalContext.ts","../ts/visualsData/dataView/rules/ruleEvaluation.ts","../ts/visualsData/dataView/rules/colorRuleEvaluation.ts","../ts/visualsData/dataView/utils/dataViewMatrixUtils.ts","../ts/visualsData/dataView/utils/dataViewMetadataColumnUtils.ts","../ts/visualsData/contracts/conceptualSchema.ts","../ts/visualsData/dataView/scriptResultUtil.ts","../ts/visualsData/segmentation/dataViewMerger.ts","../ts/visualsData/semanticQuery/sqExprRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/equalsToInRewriter.ts","../ts/visualsData/semanticQuery/exprPatterns/filterScopeIdsCollector.ts","../ts/visualsData/semanticQuery/exprPatterns/scopeIdentityExtractor.ts","../ts/visualsData/semanticQuery/primitiveValueEncoding.ts","../ts/visualsData/semanticQuery/sqAggregationOperations.ts","../ts/visualsData/semanticQuery/sqHierarchyExprUtils.ts","../ts/visualsData/semanticQuery/sqExprGroupUtils.ts","../ts/visualsData/semanticQuery/sqExpr.ts","../ts/visualsData/semanticQuery/sqExprUtils.ts","../ts/visualsData/semanticQuery/semanticQueryRewriter.ts","../ts/visualsData/semanticQuery/semanticQuery.ts","../ts/visualsData/dataView/dataViewBuilder.ts","../ts/visualsData/dataView/rules/staticEvalContext.ts","../ts/visualsData/dataView/rules/matrixEvalContext.ts","../ts/visualsData/services/formattingService.ts","../ts/visualsData/services/serialization/sqExprShortSerializer.ts","../ts/visualsData/selection/selectionId.ts"],"names":["__extends","this","d","b","__","constructor","p","hasOwnProperty","prototype","Object","create","powerbi","data","DefaultSQExprVisitorWithArg","visitEntity","expr","arg","visitDefault","visitColumnRef","visitMeasureRef","visitAggr","visitPercentile","visitHierarchy","visitHierarchyLevel","visitPropertyVariationSource","visitBetween","visitIn","visitAnd","visitOr","visitCompare","visitContains","visitExists","visitNot","visitStartsWith","visitConstant","visitDateSpan","visitDateAdd","visitNow","visitDefaultValue","visitAnyValue","visitArithmetic","visitFillRule","visitResourcePackageItem","visitScopedEval","DefaultSQExprVisitor","_super","apply","arguments","DefaultSQExprVisitorWithTraversal","source","accept","lower","upper","args","i","len","length","values","valueTuple","j","jlen","left","right","input","rule","gradient2","linearGradient2","gradient3","linearGradient3","visitLinearGradient2","visitLinearGradient3","visitFillRuleStop","min","max","mid","expression","_i","_a","scope","scopeExpr","stop","color","value","createEnumType","members","EnumType","allMembers","validMembers","membersToReturn","allMembers_1","member","_","contains","push","FillSolidColorTypeDescriptor","nullable","descriptor","advancedDescriptor","ImageDefinition","urlType","misc","imageUrl","StructuralTypeDescriptor","isValid","type","fill","fillRule","filter","image","paragraphs","getPrimitiveType","extendedType","PrimitiveTypeMask","isPrimitiveType","PrimitiveTypeWithFlagsMask","getCategoryFromExtendedType","category","ExtendedType","delimIdx","lastIndexOf","baseCategory","slice","toExtendedType","primitiveType","primitiveString","PrimitiveType","t","Null","categoryType","categoryPrimitiveType","matchesExtendedTypeWithAnyPrimitive","a","PrimitiveTypeFlagsExcludedMask","EnumExtensions","jsCommon","ValueType","enumType","underlyingType","hasFlag","Temporal","temporalType","TemporalType","Geography","geographyType","GeographyType","Miscellaneous","miscType","MiscellaneousType","Formatting","formattingType","FormattingType","Enumeration","Scripting","scriptingType","ScriptType","fromDescriptor","text","fromExtendedType","Text","integer","Integer","numeric","Double","bool","Boolean","dateTime","DateTime","duration","Duration","binary","Binary","none","None","scripting","ScriptSource","enumeration","fromEnum","temporal","year","Year_Integer","month","Month_Integer","geography","address","Address","city","City","continent","Continent","country","Country","county","County","region","Region","postalCode","PostalCode_Text","stateOrProvince","StateOrProvince","place","Place","latitude","Latitude_Double","longitude","Longitude_Double","Image","ImageUrl","webUrl","WebUrl","barcode","Barcode_Text","formatting","Color","formatString","FormatString","alignment","Alignment","labelDisplayUnits","LabelDisplayUnits","fontSize","FontSize","labelDensity","LabelDensity","fromPrimitiveTypeAndCategory","id","toString","typeCache","isCompatibleTo","otherTypes","valueType","otherTypes_1","otherType","otherValueType","isCompatibleFrom","other","otherPrimitiveType","equals","isEqual","defineProperty","get","enumerable","configurable","Numeric","Date","Time","Year","Month","PostalCode","Latitude","Longitude","Barcode","DataShapeBindingLimitType","SubtotalType","DataShapeBindingDataReduction","createFrom","reduction","result","top","Top","count","Count","bottom","Bottom","sample","Sample","window","Window","FederatedConceptualSchema","options","schemas","links","schema","name","data_1","Selector","filterFromSelector","selectors","isNot","isEmpty","exprs","ilen","identity","data_2","exprToAdd","undefined","SQExprBuilder","and","DataViewScopeIdentity","filterFromExprs","matchesData","selector","identities","selectorData","dataItem","selectorDataItem","DataViewScopeWildcard","matches","matchesKeys","keysList","selectorDataLength","selectorDataExprs","ScopeIdentityExtractor","getKeys","SQExprUtils","sequenceEqual","x","y","metadata","equalsDataArray","equalsData","selector1","selector2","roles","DataViewRoleWildcard","getKey","toStringify","data_3","key","JSON","stringify","containsWildcard","dataItems","dataItems_1","wildCard","hasRoleWildcard","dataItems_2","isRoleWildcard","getArithmeticOperatorName","arithmeticOperatorKind","Error","EntitySourceType","TimeUnit","QueryAggregateFunction","QueryComparisonKind","SemanticType","FilterKind","QueryProjectionCollection","items","activeProjectionRefs","showAll","_activeProjectionRefs","_showAll","all","set","queryReferences","queryRefs","map","val","queryRef","queryReferences_1","queryReference","addActiveQueryReference","getLastActiveQueryReference","replaceQueryRef","oldQueryRef","newQueryRef","item","clone","cloneDeep","QueryProjectionsByRole","clonedRoles","roleName","getRole","DisplayUnitSystemType","DateTimeSequence","unit","sequence","add","date","extendToCover","addInterval","interval","splice","moveToCover","delta","getDelta","Math","floor","calculate","dataMin","dataMax","expectedCount","getIntervalUnit","DateTimeUnit","calculateYears","calculateMonths","Week","calculateWeeks","Day","calculateDays","Hour","calculateHours","Minute","calculateMinutes","Second","calculateSeconds","Millisecond","calculateMilliseconds","yearsRange","NumericSequenceRange","calculateDataRange","getFullYear","NumericSequence","newMinYear","fromNumericSequence","minYear","maxYear","minMonth","getMonth","maxMonth","calculateUnits","firstDayOfWeek","minDayOfWeek","getDay","dayOffset","minDay","getDate","ceilWithPrecision","floorWithPrecision","getHours","getMinutes","getSeconds","intervalOffset","round","DateUtils","addYears","addMonths","addWeeks","addDays","addHours","addMinutes","addSeconds","addMilliseconds","getTime","maxCount","totalDays","totalHours","totalMinutes","totalSeconds","totalMilliseconds","getMilliseconds","MIN_COUNT","MAX_COUNT","isLeap","getMonthDays","MonthDaysLeap","MonthDays","yearDelta","day","isLeapDay","setFullYear","monthDelta","weeks","days","hours","minutes","seconds","milliseconds","createDisplayUnits","unitLookup","adjustMinBasedOnPreviousUnit","units","maxExponent","names","addUnitIfNonEmpty","pow10","title","format","labelFormat","previousUnit","applicableRangeMax","DisplayUnit","applicableRangeMin","defaultScientificBigNumbersBoundary","scientificSmallNumbersBoundary","PERCENTAGE_FORMAT","SCIENTIFIC_FORMAT","DEFAULT_SCIENTIFIC_FORMAT","SUPPORTED_SCIENTIFIC_FORMATS","project","removeDecimalNoise","reverseProject","isApplicableTo","abs","precision","getPrecision","greaterOrEqualWithPrecision","lessWithPrecision","isScaling","DisplayUnitSystem","displayUnit","update","unitBaseValue","findApplicableDisplayUnit","decimals","trailingZeros","isFormatSupported","getNumberOfDecimalsForFormatting","hasScientitifcFormat","formatHelper","isScalingUnit","shouldRespectScalingUnit","formattingService","formatValue","UNSUPPORTED_FORMATS","test","isPercentageFormat","indexOf","nonScientificFormat","visuals","valueFormatter","DefaultNumericFormat","NumberFormat","addDecimalsToFormat","isStandardNumberFormat","formatNumberWithCustomOverride","formatSingleValue","shouldUseValuePrecision","isScientific","toUpperCase","supportsScientificFormat","shouldFallbackToScientific","getScientificFormat","numericFormat","getNumericFormat","NoDisplayUnitSystem","call","DefaultDisplayUnitSystem","getUnits","reset","previousUnitValue","Infinity","WholeUnitsDisplayUnitSystem","DataLabelsDisplayUnitSystem","AUTO_DISPLAYUNIT_VALUE","NONE_DISPLAYUNIT_VALUE","concat","range","maxAllowedMargin","minPower","useZeroRefPoint","steps","ensureInRange","MIN_EXP","forcedSingleStop","getSize","canExtendMin","hasFixedMin","canExtendMax","hasFixedMax","size","exp","log10","stepExp","expectedCountExp","power","roundMin","floorToPrecision","roundMax","ceilToPrecision","roundRange","calculateFixedRange","shrinkByStep","dexp","e","stepsCount","stepPower","step","roundToPrecision","trimMinMax","stepCount","maxStepCount","minStepCount","offset","minMargin","maxMargin","marginPrecision","_ensureIncludeZero","includeZero","_ensureNotEmpty","DEFAULT_MAX","_ensureDirection","temp","oldCount","newCount","deltaCount","ceil","fixedMin","fixedMax","hasDataRange","ValueUtil","hasValue","MIN_SUPPORTED_DOUBLE","MAX_SUPPORTED_DOUBLE","beautify","BeautifiedFormat","defaultLocalizedStrings","describeUnit","exponent","exponentLookup","getLocalizedString","stringId","getFormatMetadata","getCustomFormatMetadata","setLocaleOptions","locale","createDefaultFormatter","allowFormatBeautification","formatBeaut","formatCore","shouldUseNumericDisplayUnits","displayUnitSystem_1","createDisplayUnitSystem","displayUnitSystemType","singleValueFormattingMode_1","formatSingleValues","value2","decimals_1","forcePrecision_1","MaxScaledDecimalPlaces","detectAxisPrecision","axisValue","isInteger","formattedValue","getStringFormat","StringExtensions","isNullOrUndefinedOrWhiteSpaceString","MaxValueForDisplayUnitRounding","shouldUseDateUnits","tickCount","unit_1","dateFormatString","getValueFormat","columnType","getFormatString","DateTimeMetadataColumn","formatValueColumn","column","formatStringProp","valueFormat","describe","Default","WholeUnits","Verbose","DataLabels","MinIntegerValueForDisplayUnits","isCustomFormat","isStandardFormat","MinPrecisionForDisplayUnits","formatStringProperty","suppressTypeFallback","propertyValue","DataViewObjects","getValue","objects","DefaultDateFormat","DefaultIntegerFormat","formatListCompound","strings","conjunction","lastIndex","restatementComma","formatListAnd","restatementCompoundAnd","formatListOr","restatementCompoundOr","nullsAreBlank","isNaN","NaN","Number","NEGATIVE_INFINITY","negativeInfinity","POSITIVE_INFINITY","infinity","getDisplayUnits","displayUnitSystem","0.00 %;-0.00 %;0.00 %","0.0 %;-0.0 %;0.0 %","NullValue","BooleanTrue","BooleanFalse","NaNValue","InfinityValue","NegativeInfinityValue","RestatementComma","RestatementCompoundAnd","RestatementCompoundOr","DisplayUnitSystem_EAuto_Title","DisplayUnitSystem_E0_Title","DisplayUnitSystem_E3_LabelFormat","DisplayUnitSystem_E3_Title","DisplayUnitSystem_E6_LabelFormat","DisplayUnitSystem_E6_Title","DisplayUnitSystem_E9_LabelFormat","DisplayUnitSystem_E9_Title","DisplayUnitSystem_E12_LabelFormat","DisplayUnitSystem_E12_Title","Percentage","Percentage1","TableTotalLabel","Tooltip_HighlightedValueDisplayName","Funnel_PercentOfFirst","Funnel_PercentOfPrevious","Funnel_PercentOfFirst_Highlight","Funnel_PercentOfPrevious_Highlight","GeotaggingString_Continent","GeotaggingString_Continents","GeotaggingString_Country","GeotaggingString_Countries","GeotaggingString_State","GeotaggingString_States","GeotaggingString_City","GeotaggingString_Cities","GeotaggingString_Town","GeotaggingString_Towns","GeotaggingString_Province","GeotaggingString_Provinces","GeotaggingString_County","GeotaggingString_Counties","GeotaggingString_Village","GeotaggingString_Villages","GeotaggingString_Post","GeotaggingString_Zip","GeotaggingString_Code","GeotaggingString_Place","GeotaggingString_Places","GeotaggingString_Address","GeotaggingString_Addresses","GeotaggingString_Street","GeotaggingString_Streets","GeotaggingString_Longitude","GeotaggingString_Longitude_Short","GeotaggingString_Latitude","GeotaggingString_Latitude_Short","GeotaggingString_PostalCode","GeotaggingString_PostalCodes","GeotaggingString_ZipCode","GeotaggingString_ZipCodes","GeotaggingString_Territory","GeotaggingString_Territories","null","true","false","displayName","DataRoleHelper","getMeasureIndexOfRole","grouped","firstGroup","hasRole","getCategoryIndexOfRole","categories","hasRoleInDataView","dataView","columns","any","c","hasRoleInValueColumn","valueColumn","createIDataViewCategoricalReader","DataViewCategoricalReader","categorical","hasValidCategories","hasAnyValidValues","valueRoleIndexMapping","firstGroupValues","valueIndex","valueCount","valueRoles","role","dataHasDynamicSeries","hasCategories","getCategoryCount","getCategoryValues","getCategoryFromRole","getCategoryValue","categoryIndex","getCategoryColumn","getCategoryMetadataColumn","getCategoryColumnIdentityFields","identityFields","getCategoryDisplayName","targetColumn","hasCompositeCategories","hasCategoryWithRole","getCategoryObjects","hasValues","seriesIndex","getValueInternal","getAllValuesForRole","valuesInRole","roleValueIndex","roleValueCount","groupIndex","valueColumnIndexInRole","valueColumnIndex","getFirstNonNullValueForCategory","seriesCount","getMeasureQueryName","queryName","getValueColumn","getValueMetadataColumn","getValueDisplayName","hasDynamicSeries","getSeriesCount","getSeriesObjects","getSeriesValueColumns","getSeriesValueColumnGroup","getSeriesMetadataColumn","getSeriesColumnIdentityFields","getSeriesName","getSeriesDisplayName","DataViewConcatenateCategoricalColumns","inherit","Prototype","inheritSingle","detectAndApply","objectDescriptors","roleMappings","projectionOrdering","selects","projectionActiveItems","dataViewCategorical","concatenationSource","detectCategoricalRoleForHierarchicalGroup","columnsSortedByProjectionOrdering","sortColumnsByProjectionOrdering","activeItemsToIgnoreInConcatenation","chain","activeItemInfo","suppressConcat","applyConcatenation","applyToPlayChartCategorical","categoryRoleName","transformingColumns_1","transformingMetadata","m","transformingDataView","dataViewMappings","roleKinds","DataViewSelectTransform","createRoleKindFromMetadata","projections","projectionsFromSelects","DataViewAnalysis","chooseDataViewMappings","supportedMappings","roleMappingForCategorical","roleNamesForCategory","getAllRolesInCategories","targetRoleName_1","isVisualExpectingMaxOneCategoryColumn","conditions","every","condition","categoriesForTargetRole_1","categoryColumn","areValuesCountsEqual","categoricalRoleMapping","roleNames","DataViewMapping","visitCategoricalCategories","visitRole","queryRefsToIgnore","formatStringPropId","DataViewObjectDescriptors","findFormatString","concatenatedValues","concatenateValues","columnsSourceSortedByProjectionOrdering","concatenatedColumnMetadata","createConcatenatedColumnMetadata","transformedDataView","addToMetadata","concatenatedCategoryColumn","createConcatenatedCategoryColumn","transformedCategoricalCategories","difference","transformedCategorical","columnsSortedByProjectionOrdering_1","columnsInProjectionOrdering","columnsByIndex_1","columns_1","index","columnIndicesInProjectionOrdering","columnIndex","sourceColumnsSortedByProjectionOrdering","concatenatedDisplayName","sourceColumnsSortedByProjectionOrdering_1","columnSource","newRoles","newColumnMetadata","columnSourceForCurrentDrillLevel","last","isMeasure","newColumn","transformedColumns","transformedMetadata","columnMetadata","newCategoryColumn","firstColumn","visitMapping","mapping","visitor","visitCategorical","table","visitTable","matrix","visitMatrix","tree","visitTree","single","visitSingle","visitCategoricalValues","visitBind","visitFor","visitList","visitReduction","groupedRoleMapping","visitGrouped","group","select","rows","visitMatrixItems","visitTreeNodes","nodes","visitTreeValues","context","bind","to","forValue","select_1","by","reductionAlgorithm","dataReductionAlgorithm","DataViewNormalizeValues","rolesToNormalize","dataRoles","requiredTypes","filterVariantMeasures","dataview","columnFilter","generateMetadataColumnFilter","valueFilter","generateValueFilter","usedMappings","dataViewMappings_1","dataViewMapping","dataViewMappingProp","filterVariantMeasuresCategorical","filterVariantMeasuresTable","filterVariantMeasuresTreeNode","root","filterVariantMeasuresMatrix","filterVariantMeasuresSingle","columnsToNormalize","columns_2","rolesToNormalize_1","columnValueFilters","columns_3","columnValueFilter","generateColumnValueFilter","getColumnRequiredTypes","doesValueMatchTypes","columnRoles","rolesToNormalize_2","_b","typeDescriptor","valuesGrouped","valuesGrouped_1","valueGroup","valuesInGroup","valuesInGroup_1","normalizeVariant","filteredColumns","columns_4","filteredColumns_1","node","children","child","filterVariantMeasuresMatrixRecursive","dataviewMatrix","nodeValue","valueSourceIndex","valueSources","isNumber","rolesToNormalize_3","dataViewMappings_2","firstColumnByRoleName","object","types","types_1","columns_5","propertyId","defaultValue","objectOrMap","objectName","DataViewObject","propertyName","getObject","getUserDefinedObjects","getFillColor","defaultColor","solid","isUserDefined","isArray","getFillColorByPropertyName","DataViewObjectDefinitions","JsonComparer","ensure","defns","defnsForObject","defn","newDefn","properties","deleteProperty","getObjectDefinition","DataViewObjectDefinition","deleteSingleProperty","setValue","getPropertyContainer","propertiesAreEqual","SemanticFilter","isSameFilter","allPropertiesAreEqual","keys","property","encodePropertyValue","valueTypeDescriptor","$","isNumeric","imageValue","imageDefinition","url","scaling","original","cloned","originalDefns","clonedDefns","originalDefns_1","originalDefn","cloneProperties","descriptors","findProperty","propDesc","formattingTypeDesc","findFilterOutput","propType","findDefaultValue","propPredicate","objPropDescs","DataViewObjectEvaluationUtils","evaluateDataViewObjects","evalContext","objectDefns","objectDefinition","evaluatedObject","DataViewObjectEvaluator","run","groupObjectsBySelector","objectDefinitions","objectDefnList","objectDefn","ensureDefinitionListForSelector","metadataOnce","groupedObjects","userDefined","groupedObjects_1","item_1","addImplicitObjects","objectsForAllSelectors","selectTransforms","addDefaultFormatString","addDefaultValue","selectIdx","selectLen","selectTransform","applyFormatString","getColumnFormatForIndex","defaultValueProp","selectTransforms_1","applyDefaultValue","columnIdx","columnLen","formatStringValue","applyMetadataProperty","metadataObjects","targetObjectDefn","targetMetadataObject","findWithMatchingSelector","targetObjectDefns","findExistingObject","objectDescriptor","propertyDefinitions","propertyDescriptors","propertyDefinition","propertyDescriptor","evaluateProperty","structuralType","evaluateValue","RuleEvaluation","evaluateFill","evaluateFillRule","evaluateImage","evaluateParagraphs","fillDefn","fillType","fillRuleDefn","evaluateColorStop","colorStop","colorValueType","numericType","definition","textType","evaluateArrayCopyOnChange","evaluateParagraph","evaluated","definitionTextRuns","textRuns","evaluatedTextRuns","evaluateTextRun","definitionValue","evaluatedValue","definitions","evaluator","evaluatedValues","take","SQExpr","ExpressionEvaluator","evaluate","instance","getExprValue","inputValue","colorAllocator","getColorAllocator","DataViewPivotCategorical","categoryIdentities","categoryValues","pivotedColumns","pivotedValues","rowIdx","rowCount","categoryValue","categoryIdentity","colIdx","colCount","pivotedColumn","groupName","pivotedValue","subtotal","highlights","pivotedMetadata","DataViewTransform","createValueColumns","DataViewPivotMatrix","dataViewMatrix","columnHierarchyRewritten","rowHierarchyRewritten","levels","pivotedRowNode","level","columnLeafNodes","measureCount","pivotResultMeasureHeaderLevel","index_1","callback","measureHeaderLeaf","columnLeafNode","levelSourceIndex","isSubtotal","hierarchyTreesRewritten","forEachLeaf","cloneTreeExecuteOnLeaf","cloneTree","sources","updatedRowRoot","updatedNode","newChildren","updatedChild","createNullValues","array","Array","inheritArrayWithValue","nullValues","inherited","DataViewSelfCrossJoin","applyCategorical","dataViewMetadata","categoryLength","valuesArray","createCategoricalDataViewBuilder","withCategories","withGroupedValues","createGroupedValues","build","nullValuesArray","valuesArrayLen","seriesData","seriesDataItem","originalValueColumn","originalHighlightValues","seriesDataItemCategory","groupColumn","identityFrom","fields","valueColumns","v","DataViewPivotCategoricalToPrimaryGroups","ArrayExtensions","pivotBinding","binding","allMappings","finalMapping","defaultDataVolume","canPivotCategorical","Primary","Groupings","Secondary","DataReduction","DataVolume","dataVolume","isPivotableAxis","axis","Projections","Subtotal","SuppressedProjections","unpivotResult","oldDataView","inferUnpivotTransform","newDataView","copy","newDataViewMatrix","unpivotMatrix","hasCompositeGroupInSeries","utils","DataViewMatrixUtils","containsCompositeGroup","categoricalFromUnpivotedMatrix","supportedDataViewMappings","categoricalMapping","matrixDataview","categoryGroups","valueGroups","addGroupingRole","groups","roleProjections","roleProjection","VisualDataRoleKind","Grouping","_c","oldMatrix","oldRows","oldRoot","oldChildren","series","seriesIdLevel","seriesIdFields","childIdentityFields","categoryIdLevel","categoryIdFields","findCategory","addCategory","categoryNode","oldChildren_1","seriesNode","matrixValues","_d","newColumns","s","inheritedNode","newColChildren","srcnode","dstnode","newRows","row","rowValues","mvalues","k","l","newMatrix","measureMetadata","createCategoryColumnsFromUnpivotedMatrix","seriesColumn","valueColumnMetadataSrc","valueColumnMetadataDst","groups_1","unpivotedMatrix","categoryIdentityFields","categorySourceColumns","groupLevelValues","levelValues","transforms","activeItems","colorAllocatorFactory","transformEmptyDataView","visualDataViews","transformQueryToVisualDataView","DataViewRegression","transformSelects","transformedDataViews","splits","transformDataView","splits_1","split","transformed","emptyDataView","transformObjects","selectsToInclude","targetKinds","getTargetKinds","ordering","roleMappings_1","roleMapping","columnRewrites","applyTransformsToColumns","applyRewritesToCategorical","pivotIfNecessary","matrixTransformationContext","applyRewritesToMatrix","shouldPivotMatrix","applyRewritesToTable","prototypeColumns","rewrites","prototypeColumn","getFormatForColumn","kpi","sort","discourageAggregationAcrossGroups","from","override","rewrittenSource","findOverride","rewritten","overrideArray","valuesOverride","currentGroupValues","rewrittenValuesSource","currentGroupIndex","currentValue","setGrouped","newToOldPositions","createTableColumnPositionMapping","columnsClone","sourceColumn","newRow","originalOrder","rewrite","newOrder","createOrderMapping","overrideHierarchy","hierarchy","rewrittenHierarchy","newLevels","newLevel","levelSources","ensureRewritten","h","r","matrixMapping","columnLevels","newToOldPositions_1","createMatrixValuesPositionMapping","keys_1","numKeys_1","reorderChildNodes","forEachNodeAtLevel","newValues","iterations","keysIndex","reorderMatrixCompositeGroups","numKeys","childrenClone","supportedDataViewMapping","projection","transformedRowsHierarchy_1","reorderMatrixHierarchyCompositeGroups","transformedColumnsHierarchy_1","matrixHierarchy","hierarchyRole","transformedHierarchy","selectIndicesInProjectionOrder","hasMultipleColumnsInProjection","hierarchyLevel","newToOldLevelSourceIndicesMapping","createMatrixHierarchyLevelSourcesPositionMapping","isUndefined","inheritMatrixNodeHierarchy","transformingHierarchyLevel","reorderMatrixHierarchyLevelColumnSources","reorderMatrixHierarchyLevelValues","levelSourceColumns","columnsForHierarchyRoleOrderedByLevelSourceIndex","DataViewMetadataColumnUtils","joinMetadataColumnsAndProjectionOrder","columnsForHierarchyRoleOrderedByProjection","sortBy","columnInfo","projectionOrderIndex","sourceIndex","originalLevelSources","newLevelSourceIndices","newLevelSourceIndex","oldLevelSourceIndex","transformingHierarchyRootNode","transformingHierarchyLevelIndex","oldToNewLevelSourceIndicesMapping","createReversedMapping","transformingMatrixNode","originalLevelValues","newlyOrderedLevelValues","levelValue","transformingLevelValue","newlyOrderedLastLevelValue","newPosition","reversed","keyAsNumber","parseInt","targetLevel","columnRewrite","targetDataViewKinds","dataObjects","evaluateMetadataObjects","metadataObject","colorAllocatorCache","populateColorAllocatorCache","evaluateMetadataRepetition","dataObject","evaluateDataRepetition","rules","evaluateUserDefinedObjects","dataViewObjects","objectDefns_1","createStaticEvalContext","objectDesc","propertyDesc","ruleDesc","createRuleEvaluationInstance","ruleType","ruleOutput","output","selectorToCreate","findSelectorForRuleInput","createRuleEvaluationInstanceFillRule","tryCreateColorAllocatorForFillRule","inputRole","ColorRuleEvaluation","fillRuleProperties","identifier","identifierKind","createColorAllocatorLinearGradient2","createColorAllocatorLinearGradient3","propertyValueFillRule","inputRange","findRuleInputColumnNumberRange","splitScales","midValue","cache","createColorAllocatorCache","staticEvalContext","objectDefnProperties","fillProperty","kind","fillRuleExpr","inputExprQueryName","findFirstQueryNameForExpr","fillRulePropertyDescriptor","register","evaluateDataRepetitionCategoricalCategory","evaluateDataRepetitionCategoricalValueGrouping","rewrittenMatrix","evaluateDataRepetitionMatrix","dataViewTable","rewrittenSelector","rewriteTableRoleSelector","rewrittenTable","evaluateDataRepetitionTable","findSelectorForRoleWildcard","resultingSelector","dataSelector","selectorRoles","allColumnsBelongToSelectorRole","allColumnsBelongToRole","fromExprs","isUniqueDataSelector","dataSelectors","newSelector","columns_6","selectorRole","findSelectedCategoricalColumn","foundMatch","createCategoricalEvalContext","setCurrentRowIndex","dataViewCategoricalValues","selectorMetadata","valueSource","valueSourceOverwrite","createMatrixEvalContext","rewrittenRows","evaluateDataRepetitionMatrixHierarchy","rewrittenCols","dataViewMatrixHierarchy","rewrittenRoot","evaluateDataRepetitionMatrixNode","dataViewNode","childNodes","rewrittenNode","shouldSearchChildren","childNode","rewrittenChildNode","inheritNodeAndChildren","getPrototypeOf","createTableEvalContext","evaluateDataRepetitionTableRows","findIndex","col","inheritedRows","colLen","rowLen","inheritedRow","objectsForColumns","metadataId","categoricalColumn","selectedMetadataId","categoryRoles","columnExpr","valueCol","valueColRoles","minLocal","maxLocal","valueIdentityFields","groupedResult","groupValues","currentGroup","determineCategoricalTransformation","some","vg","roleMappingCategorical","hasRolesGrouped","categoriesMapping","hasCategoryRole","hasRolesBind","hasRolesFor","rowLevels","rowRoles","roleMappingMatrix","createDisplayNameGetter","displayNameKey","resourceProvider","getDisplayName","displayNameGetter","fieldExpr","sqExpr","FieldExprPattern","visit","FieldExprToSQExprVisitor","fromColumnAggr","columnAggr","aggregate","fromColumn","columnRef","fromEntity","entityPattern","entity","entityVar","fromEntityAggr","entityAggr","fromHierarchyLevelAggr","hierarchyLevelAggr","fromHierarchyLevel","hierarchyLevelPattern","fromHierarchy","hierarchyPattern","visitColumn","visitColumnAggr","visitColumnHierarchyLevelVariation","columnHierarchyLevelVariationPattern","propertyVariationSource","visitEntityAggr","visitHierarchyLevelAggr","visitMeasure","measure","measureRef","percentile","exclusive","visitPercentOfGrandTotal","percentOfGrandTotal","baseSQExpr","baseExpr","arithmetic","scopedEval","SQExprConverter","asFieldPattern","FieldExprPatternBuilder","sourceRef","SourceExprPatternBuilder","ref","entityRef","variable","fieldPattern","argAggr","func","sourcePattern","hierarchyRef","hierarchySourceExprPattern","HierarchyExprPatternBuiler","variation","columnHierarchyLevelVariation","variationName","percentOfGrandTotalPattern","entityExpr","SQEntityExpr","variationRef","exprPattern","fieldExprPattern","toColumnRefSQExpr","columnPattern","getAggregate","FieldExprPatternAggregateVisitor","isAggregation","FieldExprPatternIsAggregationVisitor","hasFieldExprName","getPropertyName","getHierarchyName","getColumnRef","getFieldExprName","toFieldExprEntityPattern","FieldExprToEntityExprPatternBuilder","toFieldExprEntityItemPattern","SQExprInfo","toEntityItemExprPattern","pattern","validateAndReshape","dataViewMappings_3","supports","reshapeCategorical","reshapeTree","reshapeSingle","reshapeTable","ScriptResultUtil","findScriptResult","categoryRoleMapping","supported","updated","maxRowCount","originalLength","updatedCategories","updatedColumn","supportsCategorical","singleRoleMapping","treeRoleMapping","validateRange","countGroups","depth","tableRoleMapping","countMeasures","usePreferredDataViewSchema","scriptResult","supportsScriptResult","supportsTree","supportsSingle","supportsTable","preferred","dataViewSingle","scriptResultRoleMapping","imageBase64","roleCondition","ignoreMin","DataViewMappingMatchErrorCode","conditionRangeTooSmall","conditionRangeTooLarge","validateKind","roleKindByQueryRef","expectedKind","roleCollection","roleProjections_1","Measure","conditionKindExpectedMeasure","conditionKindExpectedGrouping","GroupingOrMeasure","conditionKindExpectedGroupingOrMeasure","mappings","errors","mappingIndex","mappingCount","mappingConditions","requiredProperties","allPropertiesValid","areAllPropertiesValid","conditionsMet","conditionIndex","conditionCount","currentConditionErrors","checkForConditionErrors","currentConditionErrors_1","error","supportedMapping","updatedConditions","emptyToNull","mappingErrors","conditionRoles","isDrillable","roleCount","getPropertyCount","rangeError","code","kindError","requiredProperty","objectDescriptorValue","objectDescriptorProperty","objectDefinitionValue","useActiveIfAvailable","projectionsForRole","hasSameCategoryIdentity","dataView1","dataView2","dv1Categories","dv2Categories","dv1Identity","dv2Identity","dv1Length","getLengthOptional","areMetadataColumnsEquivalent","column1","column2","isMetadataEquivalent","metadata1","metadata2","previousColumnsLength","newColumnsLength","Lazy","fromRoles","DataViewRoleWildcardImpl","firstRoleWildcard","secondRoleWildcard","role1","role2","_this","_roles","_key","ignoreCase","filterFromIdentity","identities_1","orExprs","resultExpr","orExprs_1","orExpr","inExpr","getInExpr","or","not","fromSQExpr","createDataViewScopeIdentity","DataViewScopeIdentityImpl","_expr","SQExprShortSerializer","serialize","wildcard","instanceExprs","firstScopeWildcard","secondScopeWildcard","DataViewScopeWildcardImpl","_exprs","serializeArray","ColorAllocatorProvider","entry","allocator","applicableDataViewMappings","regressionDataViewMapping","find","usage","regression","regressionDataViews","visualDataViews_1","visualDataView","regressionDataView","linearRegressionTransform","sourceDataView","xColumns","getColumnsForCartesianRoleKind","yColumns","xColumnSource","yColumnSource","combineSeries","regressionUsage","combineSeriesPropertyId","highlightsLineDefSet","dataPointsBySeries","getDataPointsBySeries","lineDefSet","calculateLineDefinitions","xMin","xMax","shouldComputeHightlights","hasHighlightValues","highlightDataPointsBySeries","valuesByTrend","lineDefs","trend","computeLineYValues","highlightsByTrend","createRegressionDataView","dataPointsBySeries_1","dataPointSet","unsortedXValues","xValues","unsortedYValues","yValues","xDataType","getDataType","yDataType","sortedDataPointSet","sortValues","minCategoryValue","maxCategoryValue","lineDef","computeRegressionLine","roleKind","getColumnsWithRoleKind","_loop_1","cartesianKind","state_1","firstNonNull","dataType","zippedValues","zip","valuePair","unzip","xBar","sum","yBar","ssXX","pow","ssXY","slope","intercept","x1","x2","getValuesFromColumn","preferHighlights","xValueArray","seriesYValues","multipleXValueColumns","yRole","seriesRole","xRole","categoricalRoles","seriesRoles","valuesBySeries","withCategory","regressionXQueryName","regressionSeriesQueryName","regressionYQueryName","selects_1","qp","activeItem","colorAllocatorProvider","CategoricalEvalContext","findRuleInputColumn","findRuleInputInColumns","columns_7","columnsByRole","getRoleValue","TableEvalContext","getExprValueFromTable","forEachLeafNode","rootNodes","isNodeArray","rootNodes_1","rootNode","forEachLeafNodeRecursive","nodeOrNodeArray","isArrayOrInheritedArray","matrixNode","nextIndex","treePath","children_1","nextChild","pop","deepestLevelToInherit","useInheritSingle","returnNode","isRootNode","shouldInheritCurrentNode","inheritFunc","shouldInheritChildNodes","matrixOrHierarchy","hasCompositeGroup","isMatrix","hierarchyLevels","hierarchyLevels_1","isMeasureHeadersLevel","isForRole","metadataColumn","targetRole","columnSources","jointResult","projectionOrderSelectIndices","selectIndexToProjectionIndexMap","selectIndex","jointColumnInfo","ConceptualSchema","entityName","entities","withName","findHierarchy","hierarchies","findHierarchyByVariation","variationEntityName","variationColumnName","hierarchyName","variationEntity","variationProperty","variationColumn","variations","targetEntity","navigationProperty","findPropertyWithKpi","kpiProperty","prop","status","goal","ConceptualDataCategory","extractScriptResult","script","provider","extractScriptResultFromVisualConfig","scriptSource","getScriptInput","scriptInput","VariableName","Columns","scriptInputColumnNames","scriptInputColumns","scriptInputColumn","QueryName","Name","ScriptInputColumnNameVisitor","ensureUniqueNames","federatedSchema","getNameForProperty","getVariationLevelName","getNameForHierarchy","federatedScheam","variations_1","defaultHierarchy","segmentation","DataViewMerger","mergeDataViews","segment","mergeTables","mergeCategorical","mergeTreeNodes","mergeIndex","lastMergeIndex","merge","segmentCategoriesLength","segmentCategory","sourceCategory","segmentValuesLength","segmentValue","sourceValue","sourceRoot","segmentRoot","allowDifferentStructure","firstAppendIndex","findFirstAppendIndex","lastSourceChild","mergedChildren","childSegment","isMerge","SQExprRewriter","origArg","rewrittenArg","SQColumnRefExpr","SQMeasureRefExpr","SQAggregationExpr","SQPercentileExpr","SQHierarchyExpr","SQHierarchyLevelExpr","SQPropertyVariationSourceExpr","orig","origLeft","rewrittenLeft","origRight","rewrittenRight","SQAndExpr","origLower","rewrittenLower","origUpper","rewrittenUpper","SQBetweenExpr","rewrittenValues","origArgs","rewrittenArgs","rewriteAll","origValues","origValueTuple","rewrittenValueTuple","SQInExpr","origExprs","rewrittenResult","origExpr","rewrittenExpr","SQOrExpr","SQCompareExpr","comparison","SQContainsExpr","SQExistsExpr","SQNotExpr","SQStartsWithExpr","SQDateSpanExpr","SQDateAddExpr","amount","SQArithmeticExpr","operator","origExpression","rewrittenExpression","origScope","rewrittenScope","SQScopedEvalExpr","origInput","rewrittenInput","origRule","origGradient2","rewrittenGradient2","origGradient3","rewrittenGradient3","rewrittenRule","SQFillRuleExpr","origMin","rewrittenMin","origMax","rewrittenMax","origMid","rewrittenMid","origColor","rewrittenColor","origValue","rewrittenValue","rewrittenStop","EqualsToInRewriter","Rewriter","Equal","visitUnsupported","isSupported","leftIsComparand","isComparand","rightIsComparand","operand","current","InBuilder","complete","cancel","SQConstantExpr","cancelled","asScopeIdsContainer","fieldSQExprs","filterItems","filterItem","FilterScopeIdsCollectorVisitor","getResult","getFirstComparandValue","comparandExpr","FindComparandVisitor","isRoot","keyExprsCount","valueExprs","fieldExprs","fieldSQExprs_1","field","removeEntityVariables","scopeIds","startIndex","endIndex","scopeId","getScopeIdentity","isInArray","compoundSQExpr","equalsExpr","equal","unsupportedSQExpr","values_1","valueTuple_1","fixedExpr","extractor","ScopeIdExtractorImpl","malformed","keyValues","PrimitiveValueEncoding","decimal","double","getTimezoneOffset","dateTimeString","toISOString","endsWith","substr","replace","SingleQuoteRegex","nullEncoding","boolean","createSQAggregationOperations","datetimeMinMaxSupported","SQAggregationOperations","getMetadataForUnderlyingType","removeAggregate","getMetadata","Agg","getSupportedAggregates","targetTypes","fieldKind","isPropertyIdentity","idOnEntityKey","aggregates_1","Sum","Avg","Min","Max","CountNonNull","StandardDeviation","Variance","fieldExprItem","currentSchema","capabilities","supportsMedian","Median","aggregates","distinctCountAggExists","isSupportedAggregate","supportedAggregates","createExprWithAggregate","aggregateNonNumericFields","preferredAggregate","getDefaultAggregate","SQHierarchyExprUtils","getConceptualHierarchyLevelFromExpr","conceptualSchema","getConceptualHierarchyLevel","schemaName","conceptualHierarchy","getConceptualHierarchy","variationExpr","sourceEntityExpr","expandExpr","suppressHierarchyLevelExpansion","SQExprHierarchyToHierarchyLevelConverter","convert","SQExprVariationConverter","expand","SQExprHierarchyLevelConverter","isHierarchyOrVariation","conceptualProperty","getConceptualProperty","getSourceVariationExpr","hierarchyLevelExpr","getSourceHierarchy","getHierarchySourceAsVariationSource","areHierarchyLevelsOrdered","allLevels","firstExpr","secondExpr","firstLevel","secondLevel","firstIndex","indexOfExpr","secondIndex","getInsertionIndex","orderedSubsetOfLevels","insertIndex","hierarchyExpr","hierarchyLevels_2","SQExprGroupUtils","groupExprs","addChildToGroup","selectQueryIndex","shouldAddExpressionToNewGroup","exprSource","lastGroup","expandedExpr","allHierarchyLevels","defaultAggregateForDataType","defaultAggregateToQueryAggregateFunction","_kind","SQExprEqualityVisitor","validate","aggrUtils","validator","SQExprValidationVisitor","isColumn","isConstant","isEntity","isHierarchy","isHierarchyLevel","isResourcePackageItem","getMetadataForProperty","getMetadataForHierarchyLevel","getMetadataForVariation","getMetadataForPercentOfGrandTotal","getMetadataForEntity","forceAggregation","getHierarchyLevelConceptualProperty","propertyDefaultAggregate","defaultAggregate","getKeyColumns","columnRefExpr","SQExprColumnRefInfoVisitor","getColumnRefSQExpr","keySQExprs","getPropertyKeys","hasGroupOnKeys","keySqExpr","getTargetEntityForVariation","variations_2","getTargetEntity","SQEntityExprInfoVisitor","getEntityExpr","fieldExprHierachyLevel","fieldExprEntity","sourceProperty","getPropertyMetadata","columnAggregate","SQPropRefExpr","argMetadata","valueEncoded","SQNowExpr","SQDefaultValueExpr","SQAnyValueExpr","SQResourcePackageItemExpr","packageName","packageType","itemName","between","inExpr_1","tryUseInExprs","leftArgLen","rightArgLen","combinedValues","compare","exists","startsWith","nullConstant","now","anyValue","dateAdd","dateSpan","Decimal","typedConstant","isBoolean","isString","setAggregate","FieldExprChangeAggregateRewriter","SQExprRemoveAggregateRewriter","setPercentOfGrandTotal","SQExprSetPercentOfGrandTotalRewriter","removePercentOfGrandTotal","SQExprRemovePercentOfGrandTotalRewriter","SQExprRemoveEntityVariablesRewriter","resourcePackageItem","SQExprAggregateInfoVisitor","ignoreCaseInstance","comparand","equalsAll","compareValues","optionalEqual","equalIgnoreCase","leftRule","rightRule","leftLinearGradient2","rightLinearGradient2","leftLinearGradient3","rightLinearGradient3","left2","right2","equalsFillRuleStop","left3","right3","stop1","stop2","SQExprRootRewriter","values_2","validateCompatibleType","compareExpr","validateEntity","isQueryable","aggregateExpr","validateHierarchy","hierarchyLevelFieldExprItem","validateHierarchyLevel","validateOperandsAndTypeForStartOrContains","validateArithmeticTypes","supportsArithmetic","leftMetadata","leftType","rightMetadata","rightType","levelName","hierarchyLevelConceptualProperty","queryable","sourceExpr","targetEntityExpr","schemaHierarchy","hierarchyLevelRef","getEntity","SQExprChangeAggregateRewriter","rewriter","defaultRewrite","searchElement","uniqueName","namedItems","exprDefaultName","findUniqueName","defaultName","fallback","SQExprDefaultNameGenerator","IsMeasureVisitor","isAnyValue","IsAnyValueVisitor","isDefaultValue","IsDefaultValueVisitor","discourageAggregation","getSchemaCapabilities","discourageQueryAggregateUsage","getAggregateBehavior","getConceptualColumn","aggregateBehavior","getKpiMetadata","kpiStatusProperty","getKpiStatusProperty","kpiValue","statusMetadata","kpiTrendProperty","getKpiTrendProperty","trendMetadata","getConceptualEntity","conceptualEntity","getDefaultValue","fieldSQExpr","sqField","hierarchyLevelField","getDefaultValues","fieldSQExprs_2","getDataViewScopeIdentityComparisonExpr","fieldsExpr","compareExprs","compareExprs_1","getActiveTablesNames","queryDefn","tables","selectedItems","entityObj","isRelatedToMany","targetExpr","isRelated","isRelatedToOne","sourceMultiplicity","targetMultiplicity","navigationProperties","target","queue","shift","navProperties","navProperties_1","navProperty","isActive","isRelatedOneToOne","sourceNavigations","targetNavigations","hasOneToOneNavigation","navigationProperties_1","concatUnique","leftExprs","rightExprs","concatExprs","rightExprs_1","SemanticQueryRewriter","exprRewriter","rewriteFrom","fromValue","fromContents","originalFrom","originalFromKeys","keyName","originalEntityRef","originalEntityExpr","updatedEntityExpr","SQFrom","rewriteSelect","selectItems","rewriteNamedSQExpressions","rewriteGroupBy","groupByitems","expressions","SQExprRewriterWithSourceRenames","rewriteOrderBy","orderByItems","orderBy","updatedExpr","direction","rewriteWhere","whereItems","where","originalWhere","updatedWhere","SemanticQuery","groupBy","groupByItems","empty","createWithTrimmedFrom","unreferencedKeyFinder","UnreferencedKeyFinder","filterTarget","unreferencedKeys","remove","getSelect","setSelect","createNamedExpressionArray","extendWithName","rewriteExpressionsWithSourceRenames","removeSelect","originalItems","originalExpr","removeOrderBy","sorts","selectNameOf","setSelectAt","originalName","addSelect","exprName","createNamedExpr","currentNames","getGroupBy","setGroupBy","addGroupBy","getOrderBy","setOrderBy","clause","updatedOrderBy","getWhere","setWhere","updatedFilter","updatedTarget","addWhere","incomingWhere","updatedClause","contract","rewrittenContract","getDefaultValueFilter","getDataViewScopeIdentityComparisonFilters","getAnyValueFilter","filters","firstFilter","applyFilter","isDefaultFilter","isAnyFilter","leftFilter","rightFilter","filterWhereItems","filterWhereItem","updatedWhereItem","ensureEntity","desiredVariableName","i_1","candidateName","new","idx","substring","toLowerCase","extend","renames","updatedName","rewriteFilter","updatedTargets","rewriteArray","updatedCondition","updatedExprs","QuerySourceRenameDetector","detector","existingEntity","actualEntity","data_4","CategoricalDataViewBuilder","pushIfNotExists","itemToAdd","applySeriesData","measureColumns","withValues","columns_8","dynamicSeriesMetadata","valueColumns_1","fillData","dataViewValues","first","data_5","seriesMeasures","measureIndex","measuresLen","data_6","metadataColumns","categoryMetadata","categoryMetadata_1","measures","seriesValues","seriesValue","seriesIdentity","measures_1","groups_2","StaticEvalContext","cols","powerbi_1","FormattingEncoder","RegExpExtensions","preserveEscaped","specialChars","oldText","newText","String","fromCharCode","replaceAll","restoreEscaped","preserveLiterals","literals","fromIndex","toIndex","literal","token","restoreLiterals","DateTimeFormat","IndexedTokensRegex","ZeroPlaceholder","DigitPlaceholder","ExponentialFormatChar","NumericPlaceholders","NumericPlaceholderRegex","RegExp","join","FormattingService","culture","gculture","getCulture","canFormat","formatWithIndexedTokens","match","argToken","parts","argIndex","argFormat","nonScientificOverrideFormat","formatWithCustomOverride","_dateTimeScaleFormatInfo","initialize","setCurrentCulture","cultureSelector","_currentCultureSelector","_currentCulture","DateTimeScaleFormatInfo","Globalize","findClosestCulture","cultureName","getCurrentCulture","calendarName","getUrlParam","calendars","calendar","urlParam","common","cultureInfo","navigator","userLanguage","param","location","search","isStandard","formatDateStandard","formatDateCustom","patterns","ensurePatterns","findDateFormat","processCustomDateTimeFormat","localize","_currentCachedFormat","_currentCachedProcessedFormat","fixDateTimeFormat","dictionary","timeSeparator","char","charAt","getNonScientificFormatWithPrecision","baseFormat","newFormat","hasFormatComponents","getComponents","positive","negative","zero","getNumericFormatFromComponent","NumericFormatRegex","formats","addDecimalsToFormatComponent","NumberFormatComponentsDelimeter","placeholder","decimalPlaceholders","repeat","DecimalFormatRegex","beforeDecimal","formatDecimal","afterDecimal","decimalChange","DecimalFormatCharacter","LastNumericPlaceholderRegex","signFormat","hasNegative","signSpecificFormats","formatCount","StandardFormatRegex","formatNumberStandard","formatNumberCustom","numberFormatInfo","numberFormat","formatChar","mantissaDecimalDigits","toFixed","toPrecision","toExponential","actualPrecision","isNegative","paddingZerosCount","paddingZeros","isFinite","formatComponents","formatMeta","hasEscapes","hasQuotes","hasE","scientificMatch","ScientificFormatRegex","formatM","formatE","getCustomFormatPrecision","scale","getCustomFormatScale","indexOfE","mantissa","resultM","fuseNumberWithCustomFormat","resultE","valueFormatted","isValueGlobalized","parseFloat","toNonScientific","_lastCustomFormatMeta","precisionZeros","digitsBeforeDecimalPoint","maxPrecision","indexOfDot","powerZeros","calculatePrecision","calculateScale","hasCommas","hasDots","hasPercent","hasPermile","length_1","dotIndex","suppressModifyValue","formatParts","wholeFormat","fractionFormat","NumericalPlaceHolderRegex","globalizedDecimalSeparator","decimalSeparator","valueParts","wholeValue","fractionValue","TrailingZerosRegex","wholeFormattedValue","fuseNumberWithCustomFormatLeft","fractionFormattedValue","fuseNumberWithCustomFormatRight","fmtOnly","groupSymbolIndex","enableGroups","groupDigitCount","groupSizes","groupSize","groupSeparator","sign","firstChar","isZero","leftBuffer","vi","fi","fCount","vCount","lastChar","plus","minus","dot","comma","monthAbbreviations","cultureHasMonthAbbr","yearMonthPattern","monthDayPattern","fullPattern","longTimePattern","shortTimePattern","separator","hasYearSymbol","YearPattern","yearPos","monthPos","MonthPattern","DayPattern","minutePos","pmPos","shortHourPattern","HourPattern","MinutePattern","SecondPattern","MillisecondPattern","SQExprSerializer","str","agg","f","n","comp","const","o","SelectionId","highlight","keyWithoutHighlight","includes","ignoreHighlight","thisSelector","otherSelector","thisData","otherData","thisValue","otherValue","getKeyWithoutHighlight","hasIdentity","getSelector","getSelectorsByColumn","selectorsByColumn","createNull","createWithId","createWithMeasure","measureId","selectionId","createWithIdAndMeasure","createWithIdAndMeasureAndCategory","dataMap","createWithIds","id1","id2","idArray","createWithIdsAndMeasure","createWithSelectorForColumnAndMeasure","createWithHighlight","newId","data_7","SelectionIdBuilder","builder","ensureDataMap","withSeries","withMeasure","createSelectionId"],"mappings":"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","file":"VisualsData.min.js","sourcesContent":["var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n///<reference path=\"../../Typedefs/jquery/jquery.d.ts\"/>\n///<reference path=\"../../Typedefs/globalize/globalize.d.ts\"/>\n///<reference path=\"../../Typedefs/lodash/lodash.d.ts\"/>\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\n        var DefaultSQExprVisitorWithArg = (function () {\n            function DefaultSQExprVisitorWithArg() {\n            }\n            DefaultSQExprVisitorWithArg.prototype.visitEntity = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitColumnRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitMeasureRef = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAggr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPercentile = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchy = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitHierarchyLevel = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitPropertyVariationSource = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitBetween = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitIn = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitOr = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitCompare = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitContains = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitExists = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNot = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitStartsWith = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitConstant = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateSpan = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDateAdd = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitNow = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefaultValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitAnyValue = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitArithmetic = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitFillRule = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitResourcePackageItem = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitScopedEval = function (expr, arg) {\n                return this.visitDefault(expr, arg);\n            };\n            DefaultSQExprVisitorWithArg.prototype.visitDefault = function (expr, arg) {\n                return;\n            };\n            return DefaultSQExprVisitorWithArg;\n        }());\n        data.DefaultSQExprVisitorWithArg = DefaultSQExprVisitorWithArg;\n        /** Default ISQExprVisitor implementation that others may derive from. */\n        var DefaultSQExprVisitor = (function (_super) {\n            __extends(DefaultSQExprVisitor, _super);\n            function DefaultSQExprVisitor() {\n                _super.apply(this, arguments);\n            }\n            return DefaultSQExprVisitor;\n        }(DefaultSQExprVisitorWithArg));\n        data.DefaultSQExprVisitor = DefaultSQExprVisitor;\n        /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\n        var DefaultSQExprVisitorWithTraversal = (function () {\n            function DefaultSQExprVisitorWithTraversal() {\n            }\n            DefaultSQExprVisitorWithTraversal.prototype.visitEntity = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitColumnRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitMeasureRef = function (expr) {\n                expr.source.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAggr = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPercentile = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchy = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchyLevel = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitPropertyVariationSource = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitBetween = function (expr) {\n                expr.arg.accept(this);\n                expr.lower.accept(this);\n                expr.upper.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitIn = function (expr) {\n                var args = expr.args;\n                for (var i = 0, len = args.length; i < len; i++)\n                    args[i].accept(this);\n                var values = expr.values;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var valueTuple = values[i];\n                    for (var j = 0, jlen = valueTuple.length; j < jlen; j++)\n                        valueTuple[j].accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnd = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitOr = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitCompare = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitContains = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitExists = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNot = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitStartsWith = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitConstant = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateSpan = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDateAdd = function (expr) {\n                expr.arg.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitNow = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefaultValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitAnyValue = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitArithmetic = function (expr) {\n                expr.left.accept(this);\n                expr.right.accept(this);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRule = function (expr) {\n                expr.input.accept(this);\n                var rule = expr.rule, gradient2 = rule.linearGradient2, gradient3 = rule.linearGradient3;\n                if (gradient2) {\n                    this.visitLinearGradient2(gradient2);\n                }\n                if (gradient3) {\n                    this.visitLinearGradient3(gradient3);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient2 = function (gradient2) {\n                debug.assertValue(gradient2, 'gradient2');\n                this.visitFillRuleStop(gradient2.min);\n                this.visitFillRuleStop(gradient2.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient3 = function (gradient3) {\n                debug.assertValue(gradient3, 'gradient3');\n                this.visitFillRuleStop(gradient3.min);\n                this.visitFillRuleStop(gradient3.mid);\n                this.visitFillRuleStop(gradient3.max);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitResourcePackageItem = function (expr) {\n                this.visitDefault(expr);\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitScopedEval = function (expr) {\n                expr.expression.accept(this);\n                for (var _i = 0, _a = expr.scope; _i < _a.length; _i++) {\n                    var scopeExpr = _a[_i];\n                    scopeExpr.accept(this);\n                }\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitDefault = function (expr) {\n                return;\n            };\n            DefaultSQExprVisitorWithTraversal.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                stop.color.accept(this);\n                var value = stop.value;\n                if (value)\n                    value.accept(this);\n            };\n            return DefaultSQExprVisitorWithTraversal;\n        }());\n        data.DefaultSQExprVisitorWithTraversal = DefaultSQExprVisitorWithTraversal;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    function createEnumType(members) {\n        return new EnumType(members);\n    }\n    powerbi.createEnumType = createEnumType;\n    var EnumType = (function () {\n        function EnumType(allMembers) {\n            debug.assertValue(allMembers, 'allMembers');\n            this.allMembers = allMembers;\n        }\n        EnumType.prototype.members = function (validMembers) {\n            var allMembers = this.allMembers;\n            if (!validMembers)\n                return allMembers;\n            var membersToReturn = [];\n            for (var _i = 0, allMembers_1 = allMembers; _i < allMembers_1.length; _i++) {\n                var member = allMembers_1[_i];\n                if (_.contains(validMembers, member.value))\n                    membersToReturn.push(member);\n            }\n            return membersToReturn;\n        };\n        return EnumType;\n    }());\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var FillSolidColorTypeDescriptor;\n    (function (FillSolidColorTypeDescriptor) {\n        /** Gets a value indicating whether the descriptor is nullable or not. */\n        function nullable(descriptor) {\n            debug.assertValue(descriptor, 'descriptor');\n            if (descriptor === true)\n                return false;\n            var advancedDescriptor = descriptor;\n            return !!advancedDescriptor.nullable;\n        }\n        FillSolidColorTypeDescriptor.nullable = nullable;\n    })(FillSolidColorTypeDescriptor = powerbi.FillSolidColorTypeDescriptor || (powerbi.FillSolidColorTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var ImageDefinition;\n    (function (ImageDefinition) {\n        ImageDefinition.urlType = { misc: { imageUrl: true } };\n    })(ImageDefinition = powerbi.ImageDefinition || (powerbi.ImageDefinition = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StructuralTypeDescriptor;\n    (function (StructuralTypeDescriptor) {\n        function isValid(type) {\n            debug.assertValue(type, 'type');\n            if (type.fill ||\n                type.fillRule ||\n                type.filter ||\n                type.expression ||\n                type.image ||\n                type.paragraphs) {\n                return true;\n            }\n            return false;\n        }\n        StructuralTypeDescriptor.isValid = isValid;\n    })(StructuralTypeDescriptor = powerbi.StructuralTypeDescriptor || (powerbi.StructuralTypeDescriptor = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var EnumExtensions = jsCommon.EnumExtensions;\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\n    var ValueType = (function () {\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\n        function ValueType(type, category, enumType) {\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\n            debug.assert(!!category || category === null, 'category');\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\n            this.underlyingType = type;\n            this.category = category;\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\n                this.temporalType = new TemporalType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\n                this.geographyType = new GeographyType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\n                this.miscType = new MiscellaneousType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\n                this.formattingType = new FormattingType(type);\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\n                this.enumType = enumType;\n            }\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\n                this.scriptingType = new ScriptType(type);\n            }\n        }\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\n        ValueType.fromDescriptor = function (descriptor) {\n            descriptor = descriptor || {};\n            // Simplified primitive types\n            if (descriptor.text)\n                return ValueType.fromExtendedType(ExtendedType.Text);\n            if (descriptor.integer)\n                return ValueType.fromExtendedType(ExtendedType.Integer);\n            if (descriptor.numeric)\n                return ValueType.fromExtendedType(ExtendedType.Double);\n            if (descriptor.bool)\n                return ValueType.fromExtendedType(ExtendedType.Boolean);\n            if (descriptor.dateTime)\n                return ValueType.fromExtendedType(ExtendedType.DateTime);\n            if (descriptor.duration)\n                return ValueType.fromExtendedType(ExtendedType.Duration);\n            if (descriptor.binary)\n                return ValueType.fromExtendedType(ExtendedType.Binary);\n            if (descriptor.none)\n                return ValueType.fromExtendedType(ExtendedType.None);\n            // Extended types\n            if (descriptor.scripting) {\n                if (descriptor.scripting.source)\n                    return ValueType.fromExtendedType(ExtendedType.ScriptSource);\n            }\n            if (descriptor.enumeration)\n                return ValueType.fromEnum(descriptor.enumeration);\n            if (descriptor.temporal) {\n                if (descriptor.temporal.year)\n                    return ValueType.fromExtendedType(ExtendedType.Year_Integer);\n                if (descriptor.temporal.month)\n                    return ValueType.fromExtendedType(ExtendedType.Month_Integer);\n            }\n            if (descriptor.geography) {\n                if (descriptor.geography.address)\n                    return ValueType.fromExtendedType(ExtendedType.Address);\n                if (descriptor.geography.city)\n                    return ValueType.fromExtendedType(ExtendedType.City);\n                if (descriptor.geography.continent)\n                    return ValueType.fromExtendedType(ExtendedType.Continent);\n                if (descriptor.geography.country)\n                    return ValueType.fromExtendedType(ExtendedType.Country);\n                if (descriptor.geography.county)\n                    return ValueType.fromExtendedType(ExtendedType.County);\n                if (descriptor.geography.region)\n                    return ValueType.fromExtendedType(ExtendedType.Region);\n                if (descriptor.geography.postalCode)\n                    return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\n                if (descriptor.geography.stateOrProvince)\n                    return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\n                if (descriptor.geography.place)\n                    return ValueType.fromExtendedType(ExtendedType.Place);\n                if (descriptor.geography.latitude)\n                    return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\n                if (descriptor.geography.longitude)\n                    return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\n            }\n            if (descriptor.misc) {\n                if (descriptor.misc.image)\n                    return ValueType.fromExtendedType(ExtendedType.Image);\n                if (descriptor.misc.imageUrl)\n                    return ValueType.fromExtendedType(ExtendedType.ImageUrl);\n                if (descriptor.misc.webUrl)\n                    return ValueType.fromExtendedType(ExtendedType.WebUrl);\n                if (descriptor.misc.barcode)\n                    return ValueType.fromExtendedType(ExtendedType.Barcode_Text);\n            }\n            if (descriptor.formatting) {\n                if (descriptor.formatting.color)\n                    return ValueType.fromExtendedType(ExtendedType.Color);\n                if (descriptor.formatting.formatString)\n                    return ValueType.fromExtendedType(ExtendedType.FormatString);\n                if (descriptor.formatting.alignment)\n                    return ValueType.fromExtendedType(ExtendedType.Alignment);\n                if (descriptor.formatting.labelDisplayUnits)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\n                if (descriptor.formatting.fontSize)\n                    return ValueType.fromExtendedType(ExtendedType.FontSize);\n                if (descriptor.formatting.labelDensity)\n                    return ValueType.fromExtendedType(ExtendedType.LabelDensity);\n            }\n            if (descriptor.extendedType) {\n                return ValueType.fromExtendedType(descriptor.extendedType);\n            }\n            return ValueType.fromExtendedType(ExtendedType.Null);\n        };\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\n        ValueType.fromExtendedType = function (extendedType) {\n            extendedType = extendedType || ExtendedType.Null;\n            var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);\n            debug.assert(primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null, 'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\n        };\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\n        ValueType.fromPrimitiveTypeAndCategory = function (primitiveType, category) {\n            primitiveType = primitiveType || PrimitiveType.Null;\n            category = category || null;\n            var id = primitiveType.toString();\n            if (category)\n                id += '|' + category;\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\n        };\n        /** Creates a ValueType to describe the given IEnumType. */\n        ValueType.fromEnum = function (enumType) {\n            debug.assertValue(enumType, 'enumType');\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\n        };\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\n        ValueType.isCompatibleTo = function (type, otherTypes) {\n            debug.assertValue(type, 'type');\n            debug.assertValue(otherTypes, 'otherTypes');\n            var valueType = ValueType.fromDescriptor(type);\n            for (var _i = 0, otherTypes_1 = otherTypes; _i < otherTypes_1.length; _i++) {\n                var otherType = otherTypes_1[_i];\n                var otherValueType = ValueType.fromDescriptor(otherType);\n                if (otherValueType.isCompatibleFrom(valueType))\n                    return true;\n            }\n            return false;\n        };\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\n        ValueType.prototype.isCompatibleFrom = function (other) {\n            debug.assertValue(other, 'other');\n            var otherPrimitiveType = other.primitiveType;\n            if (this === other ||\n                this.primitiveType === otherPrimitiveType ||\n                otherPrimitiveType === PrimitiveType.Null)\n                return true;\n            return false;\n        };\n        /**\n         * Determines if the instance ValueType is equal to the 'other' ValueType\n         * @param {ValueType} other the other ValueType to check equality against\n         * @returns True if the instance ValueType is equal to the 'other' ValueType\n         */\n        ValueType.prototype.equals = function (other) {\n            return _.isEqual(this, other);\n        };\n        Object.defineProperty(ValueType.prototype, \"primitiveType\", {\n            /** Gets the exact primitive type of this ValueType. */\n            get: function () {\n                return getPrimitiveType(this.underlyingType);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"extendedType\", {\n            /** Gets the exact extended type of this ValueType. */\n            get: function () {\n                return this.underlyingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"categoryString\", {\n            /** Gets the data category string (if any) for this ValueType. */\n            get: function () {\n                return this.category;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"text\", {\n            // Simplified primitive types\n            /** Indicates whether the type represents text values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Text;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"numeric\", {\n            /** Indicates whether the type represents any numeric value. */\n            get: function () {\n                return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"integer\", {\n            /** Indicates whether the type represents integer numeric values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Integer;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"bool\", {\n            /** Indicates whether the type represents Boolean values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Boolean;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"dateTime\", {\n            /** Indicates whether the type represents any date/time values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.DateTime ||\n                    this.primitiveType === PrimitiveType.Date ||\n                    this.primitiveType === PrimitiveType.Time;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"duration\", {\n            /** Indicates whether the type represents duration values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Duration;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"binary\", {\n            /** Indicates whether the type represents binary values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.Binary;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"none\", {\n            /** Indicates whether the type represents none values. */\n            get: function () {\n                return this.primitiveType === PrimitiveType.None;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"temporal\", {\n            // Extended types\n            /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\n            get: function () {\n                return this.temporalType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"geography\", {\n            /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\n            get: function () {\n                return this.geographyType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"misc\", {\n            /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\n            get: function () {\n                return this.miscType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"formatting\", {\n            /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\n            get: function () {\n                return this.formattingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"enum\", {\n            /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\n            get: function () {\n                return this.enumType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(ValueType.prototype, \"scripting\", {\n            get: function () {\n                return this.scriptingType;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ValueType.typeCache = {};\n        return ValueType;\n    }());\n    powerbi.ValueType = ValueType;\n    var ScriptType = (function () {\n        function ScriptType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(ScriptType.prototype, \"source\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return ScriptType;\n    }());\n    powerbi.ScriptType = ScriptType;\n    var TemporalType = (function () {\n        function TemporalType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(TemporalType.prototype, \"year\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TemporalType.prototype, \"month\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return TemporalType;\n    }());\n    powerbi.TemporalType = TemporalType;\n    var GeographyType = (function () {\n        function GeographyType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(GeographyType.prototype, \"address\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"city\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"continent\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"country\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"county\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"region\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"postalCode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"stateOrProvince\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"place\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"latitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(GeographyType.prototype, \"longitude\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return GeographyType;\n    }());\n    powerbi.GeographyType = GeographyType;\n    var MiscellaneousType = (function () {\n        function MiscellaneousType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(MiscellaneousType.prototype, \"image\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"imageUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"webUrl\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MiscellaneousType.prototype, \"barcode\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Barcode);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return MiscellaneousType;\n    }());\n    powerbi.MiscellaneousType = MiscellaneousType;\n    var FormattingType = (function () {\n        function FormattingType(type) {\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\n            this.underlyingType = type;\n        }\n        Object.defineProperty(FormattingType.prototype, \"color\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"formatString\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"alignment\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDisplayUnits\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"fontSize\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(FormattingType.prototype, \"labelDensity\", {\n            get: function () {\n                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return FormattingType;\n    }());\n    powerbi.FormattingType = FormattingType;\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\n    (function (PrimitiveType) {\n        PrimitiveType[PrimitiveType[\"Null\"] = 0] = \"Null\";\n        PrimitiveType[PrimitiveType[\"Text\"] = 1] = \"Text\";\n        PrimitiveType[PrimitiveType[\"Decimal\"] = 2] = \"Decimal\";\n        PrimitiveType[PrimitiveType[\"Double\"] = 3] = \"Double\";\n        PrimitiveType[PrimitiveType[\"Integer\"] = 4] = \"Integer\";\n        PrimitiveType[PrimitiveType[\"Boolean\"] = 5] = \"Boolean\";\n        PrimitiveType[PrimitiveType[\"Date\"] = 6] = \"Date\";\n        PrimitiveType[PrimitiveType[\"DateTime\"] = 7] = \"DateTime\";\n        PrimitiveType[PrimitiveType[\"DateTimeZone\"] = 8] = \"DateTimeZone\";\n        PrimitiveType[PrimitiveType[\"Time\"] = 9] = \"Time\";\n        PrimitiveType[PrimitiveType[\"Duration\"] = 10] = \"Duration\";\n        PrimitiveType[PrimitiveType[\"Binary\"] = 11] = \"Binary\";\n        PrimitiveType[PrimitiveType[\"None\"] = 12] = \"None\";\n    })(powerbi.PrimitiveType || (powerbi.PrimitiveType = {}));\n    var PrimitiveType = powerbi.PrimitiveType;\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\n    (function (ExtendedType) {\n        // Flags (1 << 8-15 range [0xFF00])\n        // Important: Enum members must be declared before they are used in TypeScript.\n        ExtendedType[ExtendedType[\"Numeric\"] = 256] = \"Numeric\";\n        ExtendedType[ExtendedType[\"Temporal\"] = 512] = \"Temporal\";\n        ExtendedType[ExtendedType[\"Geography\"] = 1024] = \"Geography\";\n        ExtendedType[ExtendedType[\"Miscellaneous\"] = 2048] = \"Miscellaneous\";\n        ExtendedType[ExtendedType[\"Formatting\"] = 4096] = \"Formatting\";\n        ExtendedType[ExtendedType[\"Scripting\"] = 8192] = \"Scripting\";\n        // Primitive types (0-255 range [0xFF] | flags)\n        // The member names and base values must match those in PrimitiveType.\n        ExtendedType[ExtendedType[\"Null\"] = 0] = \"Null\";\n        ExtendedType[ExtendedType[\"Text\"] = 1] = \"Text\";\n        ExtendedType[ExtendedType[\"Decimal\"] = 258] = \"Decimal\";\n        ExtendedType[ExtendedType[\"Double\"] = 259] = \"Double\";\n        ExtendedType[ExtendedType[\"Integer\"] = 260] = \"Integer\";\n        ExtendedType[ExtendedType[\"Boolean\"] = 5] = \"Boolean\";\n        ExtendedType[ExtendedType[\"Date\"] = 518] = \"Date\";\n        ExtendedType[ExtendedType[\"DateTime\"] = 519] = \"DateTime\";\n        ExtendedType[ExtendedType[\"DateTimeZone\"] = 520] = \"DateTimeZone\";\n        ExtendedType[ExtendedType[\"Time\"] = 521] = \"Time\";\n        ExtendedType[ExtendedType[\"Duration\"] = 10] = \"Duration\";\n        ExtendedType[ExtendedType[\"Binary\"] = 11] = \"Binary\";\n        ExtendedType[ExtendedType[\"None\"] = 12] = \"None\";\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\n        // Temporal\n        ExtendedType[ExtendedType[\"Year\"] = 66048] = \"Year\";\n        ExtendedType[ExtendedType[\"Year_Text\"] = 66049] = \"Year_Text\";\n        ExtendedType[ExtendedType[\"Year_Integer\"] = 66308] = \"Year_Integer\";\n        ExtendedType[ExtendedType[\"Year_Date\"] = 66054] = \"Year_Date\";\n        ExtendedType[ExtendedType[\"Year_DateTime\"] = 66055] = \"Year_DateTime\";\n        ExtendedType[ExtendedType[\"Month\"] = 131584] = \"Month\";\n        ExtendedType[ExtendedType[\"Month_Text\"] = 131585] = \"Month_Text\";\n        ExtendedType[ExtendedType[\"Month_Integer\"] = 131844] = \"Month_Integer\";\n        ExtendedType[ExtendedType[\"Month_Date\"] = 131590] = \"Month_Date\";\n        ExtendedType[ExtendedType[\"Month_DateTime\"] = 131591] = \"Month_DateTime\";\n        // Geography\n        ExtendedType[ExtendedType[\"Address\"] = 6554625] = \"Address\";\n        ExtendedType[ExtendedType[\"City\"] = 6620161] = \"City\";\n        ExtendedType[ExtendedType[\"Continent\"] = 6685697] = \"Continent\";\n        ExtendedType[ExtendedType[\"Country\"] = 6751233] = \"Country\";\n        ExtendedType[ExtendedType[\"County\"] = 6816769] = \"County\";\n        ExtendedType[ExtendedType[\"Region\"] = 6882305] = \"Region\";\n        ExtendedType[ExtendedType[\"PostalCode\"] = 6947840] = \"PostalCode\";\n        ExtendedType[ExtendedType[\"PostalCode_Text\"] = 6947841] = \"PostalCode_Text\";\n        ExtendedType[ExtendedType[\"PostalCode_Integer\"] = 6948100] = \"PostalCode_Integer\";\n        ExtendedType[ExtendedType[\"StateOrProvince\"] = 7013377] = \"StateOrProvince\";\n        ExtendedType[ExtendedType[\"Place\"] = 7078913] = \"Place\";\n        ExtendedType[ExtendedType[\"Latitude\"] = 7144448] = \"Latitude\";\n        ExtendedType[ExtendedType[\"Latitude_Decimal\"] = 7144706] = \"Latitude_Decimal\";\n        ExtendedType[ExtendedType[\"Latitude_Double\"] = 7144707] = \"Latitude_Double\";\n        ExtendedType[ExtendedType[\"Longitude\"] = 7209984] = \"Longitude\";\n        ExtendedType[ExtendedType[\"Longitude_Decimal\"] = 7210242] = \"Longitude_Decimal\";\n        ExtendedType[ExtendedType[\"Longitude_Double\"] = 7210243] = \"Longitude_Double\";\n        // Miscellaneous\n        ExtendedType[ExtendedType[\"Image\"] = 13109259] = \"Image\";\n        ExtendedType[ExtendedType[\"ImageUrl\"] = 13174785] = \"ImageUrl\";\n        ExtendedType[ExtendedType[\"WebUrl\"] = 13240321] = \"WebUrl\";\n        ExtendedType[ExtendedType[\"Barcode\"] = 13305856] = \"Barcode\";\n        ExtendedType[ExtendedType[\"Barcode_Text\"] = 13305857] = \"Barcode_Text\";\n        ExtendedType[ExtendedType[\"Barcode_Integer\"] = 13306116] = \"Barcode_Integer\";\n        // Formatting\n        ExtendedType[ExtendedType[\"Color\"] = 19664897] = \"Color\";\n        ExtendedType[ExtendedType[\"FormatString\"] = 19730433] = \"FormatString\";\n        ExtendedType[ExtendedType[\"Alignment\"] = 20058113] = \"Alignment\";\n        ExtendedType[ExtendedType[\"LabelDisplayUnits\"] = 20123649] = \"LabelDisplayUnits\";\n        ExtendedType[ExtendedType[\"FontSize\"] = 20189443] = \"FontSize\";\n        ExtendedType[ExtendedType[\"LabelDensity\"] = 20254979] = \"LabelDensity\";\n        // Enumeration\n        ExtendedType[ExtendedType[\"Enumeration\"] = 26214401] = \"Enumeration\";\n        // Scripting\n        ExtendedType[ExtendedType[\"ScriptSource\"] = 32776193] = \"ScriptSource\";\n    })(powerbi.ExtendedType || (powerbi.ExtendedType = {}));\n    var ExtendedType = powerbi.ExtendedType;\n    var PrimitiveTypeMask = 0xFF;\n    var PrimitiveTypeWithFlagsMask = 0xFFFF;\n    var PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\n    function getPrimitiveType(extendedType) {\n        return extendedType & PrimitiveTypeMask;\n    }\n    function isPrimitiveType(extendedType) {\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\n    }\n    function getCategoryFromExtendedType(extendedType) {\n        if (isPrimitiveType(extendedType))\n            return null;\n        var category = ExtendedType[extendedType];\n        if (category) {\n            // Check for ExtendedType declaration without a primitive type.\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\n            var delimIdx = category.lastIndexOf('_');\n            if (delimIdx > 0) {\n                var baseCategory = category.slice(0, delimIdx);\n                if (ExtendedType[baseCategory]) {\n                    debug.assert((ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask), 'Unexpected value for ExtendedType base member of ' + extendedType);\n                    category = baseCategory;\n                }\n            }\n        }\n        return category || null;\n    }\n    function toExtendedType(primitiveType, category) {\n        var primitiveString = PrimitiveType[primitiveType];\n        var t = ExtendedType[primitiveString];\n        if (t == null) {\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\n            t = ExtendedType.Null;\n        }\n        if (primitiveType && category) {\n            var categoryType = ExtendedType[category];\n            if (categoryType) {\n                var categoryPrimitiveType = getPrimitiveType(categoryType);\n                if (categoryPrimitiveType === PrimitiveType.Null) {\n                    // Category supports multiple primitive types, check if requested primitive type is supported\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\n                    categoryType = t | categoryType;\n                    if (ExtendedType[categoryType]) {\n                        debug.assert(ExtendedType[categoryType] === (category + '_' + primitiveString), 'Unexpected name for ExtendedType member ' + categoryType);\n                        t = categoryType;\n                    }\n                }\n                else if (categoryPrimitiveType === primitiveType) {\n                    // Primitive type matches the single supported type for the category\n                    t = categoryType;\n                }\n            }\n        }\n        return t;\n    }\n    function matchesExtendedTypeWithAnyPrimitive(a, b) {\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (DataShapeBindingLimitType) {\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Top\"] = 0] = \"Top\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"First\"] = 1] = \"First\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Last\"] = 2] = \"Last\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Sample\"] = 3] = \"Sample\";\n            DataShapeBindingLimitType[DataShapeBindingLimitType[\"Bottom\"] = 4] = \"Bottom\";\n        })(data.DataShapeBindingLimitType || (data.DataShapeBindingLimitType = {}));\n        var DataShapeBindingLimitType = data.DataShapeBindingLimitType;\n        (function (SubtotalType) {\n            SubtotalType[SubtotalType[\"None\"] = 0] = \"None\";\n            SubtotalType[SubtotalType[\"Before\"] = 1] = \"Before\";\n            SubtotalType[SubtotalType[\"After\"] = 2] = \"After\";\n        })(data.SubtotalType || (data.SubtotalType = {}));\n        var SubtotalType = data.SubtotalType;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataShapeBindingDataReduction;\n        (function (DataShapeBindingDataReduction) {\n            function createFrom(reduction) {\n                if (!reduction)\n                    return;\n                var result;\n                if (reduction.top) {\n                    result = {\n                        Top: {}\n                    };\n                    if (reduction.top.count)\n                        result.Top.Count = reduction.top.count;\n                }\n                if (reduction.bottom) {\n                    result = {\n                        Bottom: {}\n                    };\n                    if (reduction.bottom.count)\n                        result.Bottom.Count = reduction.bottom.count;\n                }\n                if (reduction.sample) {\n                    result = {\n                        Sample: {}\n                    };\n                    if (reduction.sample.count)\n                        result.Sample.Count = reduction.sample.count;\n                }\n                if (reduction.window) {\n                    result = {\n                        Window: {}\n                    };\n                    if (reduction.window.count)\n                        result.Window.Count = reduction.window.count;\n                }\n                return result;\n            }\n            DataShapeBindingDataReduction.createFrom = createFrom;\n        })(DataShapeBindingDataReduction = data.DataShapeBindingDataReduction || (data.DataShapeBindingDataReduction = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Represents a federated conceptual schema. */\n        var FederatedConceptualSchema = (function () {\n            function FederatedConceptualSchema(options) {\n                debug.assertValue(options, 'options');\n                this.schemas = options.schemas;\n                if (options.links)\n                    this.links = options.links;\n            }\n            FederatedConceptualSchema.prototype.schema = function (name) {\n                return this.schemas[name];\n            };\n            return FederatedConceptualSchema;\n        }());\n        data.FederatedConceptualSchema = FederatedConceptualSchema;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data_1) {\n        var Selector;\n        (function (Selector) {\n            function filterFromSelector(selectors, isNot) {\n                if (_.isEmpty(selectors))\n                    return;\n                var exprs = [];\n                for (var i = 0, ilen = selectors.length; i < ilen; i++) {\n                    var identity = selectors[i];\n                    var data_2 = identity.data;\n                    var exprToAdd = undefined;\n                    if (data_2 && data_2.length) {\n                        for (var j = 0, jlen = data_2.length; j < jlen; j++) {\n                            exprToAdd = data_1.SQExprBuilder.and(exprToAdd, identity.data[j].expr);\n                        }\n                    }\n                    if (exprToAdd)\n                        exprs.push(exprToAdd);\n                }\n                if (!_.isEmpty(exprs))\n                    return powerbi.DataViewScopeIdentity.filterFromExprs(exprs, isNot);\n            }\n            Selector.filterFromSelector = filterFromSelector;\n            function matchesData(selector, identities) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(identities, 'identities');\n                var selectorData = selector.data;\n                if (selectorData.length !== identities.length)\n                    return false;\n                for (var i = 0, len = selectorData.length; i < len; i++) {\n                    var dataItem = selector.data[i];\n                    var selectorDataItem = dataItem;\n                    if (selectorDataItem.expr) {\n                        if (!powerbi.DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\n                            return false;\n                    }\n                    else {\n                        if (!data_1.DataViewScopeWildcard.matches(dataItem, identities[i]))\n                            return false;\n                    }\n                }\n                return true;\n            }\n            Selector.matchesData = matchesData;\n            function matchesKeys(selector, keysList) {\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(selector.data, 'selector.data');\n                debug.assertValue(keysList, 'keysList');\n                var selectorData = selector.data, selectorDataLength = selectorData.length;\n                if (selectorDataLength !== keysList.length)\n                    return false;\n                for (var i = 0; i < selectorDataLength; i++) {\n                    var selectorDataItem = selector.data[i], selectorDataExprs = void 0;\n                    if (selectorDataItem.expr) {\n                        selectorDataExprs = data_1.ScopeIdentityExtractor.getKeys(selectorDataItem.expr);\n                    }\n                    else if (selectorDataItem.exprs) {\n                        selectorDataExprs = selectorDataItem.exprs;\n                    }\n                    else {\n                        // In case DataViewRoleWildcard\n                        return false;\n                    }\n                    if (!selectorDataExprs)\n                        continue;\n                    if (!data_1.SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\n                        return false;\n                }\n                return true;\n            }\n            Selector.matchesKeys = matchesKeys;\n            /** Determines whether two selectors are equal. */\n            function equals(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (x.id !== y.id)\n                    return false;\n                if (x.metadata !== y.metadata)\n                    return false;\n                if (!equalsDataArray(x.data, y.data))\n                    return false;\n                return true;\n            }\n            Selector.equals = equals;\n            function equalsDataArray(x, y) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                if (x.length !== y.length)\n                    return false;\n                for (var i = 0, len = x.length; i < len; i++) {\n                    if (!equalsData(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            function equalsData(x, y) {\n                var selector1 = x;\n                var selector2 = y;\n                if (selector1.expr && selector2.expr)\n                    return powerbi.DataViewScopeIdentity.equals(selector1, selector2);\n                if (selector1.exprs && selector2.exprs)\n                    return data_1.DataViewScopeWildcard.equals(selector1, selector2);\n                if (selector1.roles && selector2.roles)\n                    return data_1.DataViewRoleWildcard.equals(selector1, selector2);\n                return false;\n            }\n            function getKey(selector) {\n                var toStringify = {};\n                if (selector.data) {\n                    var data_3 = [];\n                    for (var i = 0, ilen = selector.data.length; i < ilen; i++) {\n                        data_3.push(selector.data[i].key);\n                    }\n                    toStringify.data = data_3;\n                }\n                if (selector.metadata)\n                    toStringify.metadata = selector.metadata;\n                if (selector.id)\n                    toStringify.id = selector.id;\n                return JSON.stringify(toStringify);\n            }\n            Selector.getKey = getKey;\n            function containsWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (!dataItems)\n                    return false;\n                for (var _i = 0, dataItems_1 = dataItems; _i < dataItems_1.length; _i++) {\n                    var dataItem = dataItems_1[_i];\n                    var wildCard = dataItem;\n                    if (wildCard.exprs || wildCard.roles)\n                        return true;\n                }\n                return false;\n            }\n            Selector.containsWildcard = containsWildcard;\n            function hasRoleWildcard(selector) {\n                debug.assertValue(selector, 'selector');\n                var dataItems = selector.data;\n                if (_.isEmpty(dataItems))\n                    return false;\n                for (var _i = 0, dataItems_2 = dataItems; _i < dataItems_2.length; _i++) {\n                    var dataItem = dataItems_2[_i];\n                    if (isRoleWildcard(dataItem))\n                        return true;\n                }\n                return false;\n            }\n            Selector.hasRoleWildcard = hasRoleWildcard;\n            function isRoleWildcard(dataItem) {\n                return !_.isEmpty(dataItem.roles);\n            }\n            Selector.isRoleWildcard = isRoleWildcard;\n        })(Selector = data_1.Selector || (data_1.Selector = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        (function (EntitySourceType) {\n            EntitySourceType[EntitySourceType[\"Table\"] = 0] = \"Table\";\n            EntitySourceType[EntitySourceType[\"Pod\"] = 1] = \"Pod\";\n        })(data.EntitySourceType || (data.EntitySourceType = {}));\n        var EntitySourceType = data.EntitySourceType;\n        function getArithmeticOperatorName(arithmeticOperatorKind) {\n            switch (arithmeticOperatorKind) {\n                case 0 /* Add */:\n                    return \"Add\";\n                case 1 /* Subtract */:\n                    return \"Subtract\";\n                case 2 /* Multiply */:\n                    return \"Multiply\";\n                case 3 /* Divide */:\n                    return \"Divide\";\n            }\n            throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\n        }\n        data.getArithmeticOperatorName = getArithmeticOperatorName;\n        (function (TimeUnit) {\n            TimeUnit[TimeUnit[\"Day\"] = 0] = \"Day\";\n            TimeUnit[TimeUnit[\"Week\"] = 1] = \"Week\";\n            TimeUnit[TimeUnit[\"Month\"] = 2] = \"Month\";\n            TimeUnit[TimeUnit[\"Year\"] = 3] = \"Year\";\n            TimeUnit[TimeUnit[\"Decade\"] = 4] = \"Decade\";\n            TimeUnit[TimeUnit[\"Second\"] = 5] = \"Second\";\n            TimeUnit[TimeUnit[\"Minute\"] = 6] = \"Minute\";\n            TimeUnit[TimeUnit[\"Hour\"] = 7] = \"Hour\";\n        })(data.TimeUnit || (data.TimeUnit = {}));\n        var TimeUnit = data.TimeUnit;\n        (function (QueryAggregateFunction) {\n            QueryAggregateFunction[QueryAggregateFunction[\"Sum\"] = 0] = \"Sum\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Avg\"] = 1] = \"Avg\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Count\"] = 2] = \"Count\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Min\"] = 3] = \"Min\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Max\"] = 4] = \"Max\";\n            QueryAggregateFunction[QueryAggregateFunction[\"CountNonNull\"] = 5] = \"CountNonNull\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Median\"] = 6] = \"Median\";\n            QueryAggregateFunction[QueryAggregateFunction[\"StandardDeviation\"] = 7] = \"StandardDeviation\";\n            QueryAggregateFunction[QueryAggregateFunction[\"Variance\"] = 8] = \"Variance\";\n        })(data.QueryAggregateFunction || (data.QueryAggregateFunction = {}));\n        var QueryAggregateFunction = data.QueryAggregateFunction;\n        (function (QueryComparisonKind) {\n            QueryComparisonKind[QueryComparisonKind[\"Equal\"] = 0] = \"Equal\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThan\"] = 1] = \"GreaterThan\";\n            QueryComparisonKind[QueryComparisonKind[\"GreaterThanOrEqual\"] = 2] = \"GreaterThanOrEqual\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThan\"] = 3] = \"LessThan\";\n            QueryComparisonKind[QueryComparisonKind[\"LessThanOrEqual\"] = 4] = \"LessThanOrEqual\";\n        })(data.QueryComparisonKind || (data.QueryComparisonKind = {}));\n        var QueryComparisonKind = data.QueryComparisonKind;\n        /** Defines semantic data types. */\n        (function (SemanticType) {\n            SemanticType[SemanticType[\"None\"] = 0] = \"None\";\n            SemanticType[SemanticType[\"Number\"] = 1] = \"Number\";\n            SemanticType[SemanticType[\"Integer\"] = 3] = \"Integer\";\n            SemanticType[SemanticType[\"DateTime\"] = 4] = \"DateTime\";\n            SemanticType[SemanticType[\"Time\"] = 8] = \"Time\";\n            SemanticType[SemanticType[\"Date\"] = 20] = \"Date\";\n            SemanticType[SemanticType[\"Month\"] = 35] = \"Month\";\n            SemanticType[SemanticType[\"Year\"] = 67] = \"Year\";\n            SemanticType[SemanticType[\"YearAndMonth\"] = 128] = \"YearAndMonth\";\n            SemanticType[SemanticType[\"MonthAndDay\"] = 256] = \"MonthAndDay\";\n            SemanticType[SemanticType[\"Decade\"] = 515] = \"Decade\";\n            SemanticType[SemanticType[\"YearAndWeek\"] = 1024] = \"YearAndWeek\";\n            SemanticType[SemanticType[\"String\"] = 2048] = \"String\";\n            SemanticType[SemanticType[\"Boolean\"] = 4096] = \"Boolean\";\n            SemanticType[SemanticType[\"Table\"] = 8192] = \"Table\";\n            SemanticType[SemanticType[\"Range\"] = 16384] = \"Range\";\n        })(data.SemanticType || (data.SemanticType = {}));\n        var SemanticType = data.SemanticType;\n        (function (FilterKind) {\n            FilterKind[FilterKind[\"Default\"] = 0] = \"Default\";\n            FilterKind[FilterKind[\"Period\"] = 1] = \"Period\";\n        })(data.FilterKind || (data.FilterKind = {}));\n        var FilterKind = data.FilterKind;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var QueryProjectionCollection = (function () {\n            function QueryProjectionCollection(items, activeProjectionRefs, showAll) {\n                debug.assertValue(items, 'items');\n                this.items = items;\n                this._activeProjectionRefs = activeProjectionRefs;\n                this._showAll = showAll;\n            }\n            /** Returns all projections in a mutable array. */\n            QueryProjectionCollection.prototype.all = function () {\n                return this.items;\n            };\n            Object.defineProperty(QueryProjectionCollection.prototype, \"activeProjectionRefs\", {\n                get: function () {\n                    return this._activeProjectionRefs;\n                },\n                set: function (queryReferences) {\n                    if (!_.isEmpty(queryReferences)) {\n                        var queryRefs = this.items.map(function (val) { return val.queryRef; });\n                        for (var _i = 0, queryReferences_1 = queryReferences; _i < queryReferences_1.length; _i++) {\n                            var queryReference = queryReferences_1[_i];\n                            if (!_.contains(queryRefs, queryReference))\n                                return;\n                        }\n                        this._activeProjectionRefs = queryReferences;\n                    }\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(QueryProjectionCollection.prototype, \"showAll\", {\n                get: function () {\n                    return this._showAll;\n                },\n                set: function (value) {\n                    this._showAll = value;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            QueryProjectionCollection.prototype.addActiveQueryReference = function (queryRef) {\n                if (!this._activeProjectionRefs)\n                    this._activeProjectionRefs = [queryRef];\n                else\n                    this._activeProjectionRefs.push(queryRef);\n            };\n            QueryProjectionCollection.prototype.getLastActiveQueryReference = function () {\n                if (!_.isEmpty(this._activeProjectionRefs)) {\n                    return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\n                }\n            };\n            /** Replaces the given oldQueryRef with newQueryRef in this QueryProjectionCollection. */\n            QueryProjectionCollection.prototype.replaceQueryRef = function (oldQueryRef, newQueryRef) {\n                debug.assertValue(oldQueryRef, 'oldQueryRef');\n                debug.assertValue(newQueryRef, 'newQueryRef');\n                debug.assert(oldQueryRef !== newQueryRef, 'oldQueryRef !== newQueryRef');\n                debug.assert(_.isEmpty(this._activeProjectionRefs), 'replaceQueryRef(...) is not supported on the QueryProjectionCollection of a drillable role');\n                // Note: the same queryRef can get projected multiple times\n                for (var _i = 0, _a = this.items; _i < _a.length; _i++) {\n                    var item = _a[_i];\n                    if (item.queryRef === oldQueryRef) {\n                        item.queryRef = newQueryRef;\n                    }\n                }\n            };\n            QueryProjectionCollection.prototype.clone = function () {\n                return new QueryProjectionCollection(_.cloneDeep(this.items), _.clone(this._activeProjectionRefs), this._showAll);\n            };\n            return QueryProjectionCollection;\n        }());\n        data.QueryProjectionCollection = QueryProjectionCollection;\n        var QueryProjectionsByRole;\n        (function (QueryProjectionsByRole) {\n            /** Clones the QueryProjectionsByRole. */\n            function clone(roles) {\n                if (!roles)\n                    return roles;\n                var clonedRoles = {};\n                for (var roleName in roles)\n                    clonedRoles[roleName] = roles[roleName].clone();\n                return clonedRoles;\n            }\n            QueryProjectionsByRole.clone = clone;\n            /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\n            function getRole(roles, name) {\n                debug.assertAnyValue(roles, 'roles');\n                debug.assertValue(name, 'name');\n                if (!roles)\n                    return;\n                return roles[name];\n            }\n            QueryProjectionsByRole.getRole = getRole;\n        })(QueryProjectionsByRole = data.QueryProjectionsByRole || (data.QueryProjectionsByRole = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** The system used to determine display units used during formatting */\n    (function (DisplayUnitSystemType) {\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Default\"] = 0] = \"Default\";\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"Verbose\"] = 1] = \"Verbose\";\n        /**\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\n         * Suitable for dashboard tile cards\n         */\n        DisplayUnitSystemType[DisplayUnitSystemType[\"WholeUnits\"] = 2] = \"WholeUnits\";\n        /**A display unit system that also contains Auto and None units for data labels*/\n        DisplayUnitSystemType[DisplayUnitSystemType[\"DataLabels\"] = 3] = \"DataLabels\";\n    })(powerbi.DisplayUnitSystemType || (powerbi.DisplayUnitSystemType = {}));\n    var DisplayUnitSystemType = powerbi.DisplayUnitSystemType;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Repreasents the sequence of the dates/times */\n    var DateTimeSequence = (function () {\n        // Constructors\n        /** Creates new instance of the DateTimeSequence */\n        function DateTimeSequence(unit) {\n            this.unit = unit;\n            this.sequence = [];\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\n        }\n        // Methods\n        /**\n         * Add a new Date to a sequence.\n         * @param date - date to add\n         */\n        DateTimeSequence.prototype.add = function (date) {\n            if (date < this.min) {\n                this.min = date;\n            }\n            if (date > this.max) {\n                this.max = date;\n            }\n            this.sequence.push(date);\n        };\n        // Methods\n        /**\n         * Extends the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.extendToCover = function (min, max) {\n            var x = this.min;\n            while (min < x) {\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\n                this.sequence.splice(0, 0, x);\n            }\n            this.min = x;\n            x = this.max;\n            while (x < max) {\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\n                this.sequence.push(x);\n            }\n            this.max = x;\n        };\n        /**\n         * Move the sequence to cover new date range\n         * @param min - new min to be covered by sequence\n         * @param max - new max to be covered by sequence\n         */\n        DateTimeSequence.prototype.moveToCover = function (min, max) {\n            var delta = DateTimeSequence.getDelta(min, max, this.unit);\n            var count = Math.floor(delta / this.interval);\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\n            this.sequence = [];\n            this.sequence.push(this.min);\n            this.max = this.min;\n            while (this.max < max) {\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\n                this.sequence.push(this.max);\n            }\n        };\n        // Static\n        /**\n         * Calculate a new DateTimeSequence\n         * @param dataMin - Date representing min of the data range\n         * @param dataMax - Date representing max of the data range\n         * @param expectedCount - expected number of intervals in the sequence\n         * @param unit - of the intervals in the sequence\n         */\n        DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {\n            if (!unit) {\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\n            }\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Month:\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Week:\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Day:\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Second:\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\n                default:\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\n            }\n        };\n        DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\n            // Calculate range and sequence\n            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\n            // Calculate year sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\n            var newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval;\n            var date = new Date(newMinYear, 0, 1);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Year);\n            return result;\n        };\n        DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var minYear = dataMin.getFullYear();\n            var maxYear = dataMax.getFullYear();\n            var minMonth = dataMin.getMonth();\n            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\n            var date = new Date(minYear, 0, 1);\n            // Calculate month sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Month);\n            return result;\n        };\n        DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            var firstDayOfWeek = 0;\n            var minDayOfWeek = dataMin.getDay();\n            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\n            var minDay = dataMin.getDate() - dayOffset;\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Week));\n            // Calculate week sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Week);\n            return result;\n        };\n        DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = 0;\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, powerbi.DateTimeUnit.Day));\n            // Calculate day sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Day);\n            return result;\n        };\n        DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Hour));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Hour));\n            // Calculate hour sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Hour);\n            return result;\n        };\n        DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Minute));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Minute));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Minute);\n            return result;\n        };\n        DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\n            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Second));\n            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Second));\n            // Calculate minutes numeric sequence\n            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Second);\n            return result;\n        };\n        DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {\n            debug.assertValue(dataMin, \"dataMin\");\n            debug.assertValue(dataMax, \"dataMax\");\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\n            // Calculate range\n            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\n            var min = DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Millisecond);\n            var max = DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Millisecond);\n            // Calculate milliseconds numeric sequence\n            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);\n            // Convert to date sequence\n            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Millisecond);\n            return result;\n        };\n        DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {\n            var result = new DateTimeSequence(unit);\n            for (var i = 0; i < sequence.sequence.length; i++) {\n                var x = sequence.sequence[i];\n                var d = DateTimeSequence.addInterval(date, x, unit);\n                result.add(d);\n            }\n            result.interval = sequence.interval;\n            result.intervalOffset = sequence.intervalOffset;\n            return result;\n        };\n        DateTimeSequence.addInterval = function (value, interval, unit) {\n            interval = Math.round(interval);\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    return DateUtils.addYears(value, interval);\n                case powerbi.DateTimeUnit.Month:\n                    return DateUtils.addMonths(value, interval);\n                case powerbi.DateTimeUnit.Week:\n                    return DateUtils.addWeeks(value, interval);\n                case powerbi.DateTimeUnit.Day:\n                    return DateUtils.addDays(value, interval);\n                case powerbi.DateTimeUnit.Hour:\n                    return DateUtils.addHours(value, interval);\n                case powerbi.DateTimeUnit.Minute:\n                    return DateUtils.addMinutes(value, interval);\n                case powerbi.DateTimeUnit.Second:\n                    return DateUtils.addSeconds(value, interval);\n                case powerbi.DateTimeUnit.Millisecond:\n                    return DateUtils.addMilliseconds(value, interval);\n            }\n        };\n        DateTimeSequence.getDelta = function (min, max, unit) {\n            var delta = 0;\n            switch (unit) {\n                case powerbi.DateTimeUnit.Year:\n                    delta = max.getFullYear() - min.getFullYear();\n                    break;\n                case powerbi.DateTimeUnit.Month:\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\n                    break;\n                case powerbi.DateTimeUnit.Week:\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Day:\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\n                    break;\n                case powerbi.DateTimeUnit.Hour:\n                    delta = (max.getTime() - min.getTime()) / 3600000;\n                    break;\n                case powerbi.DateTimeUnit.Minute:\n                    delta = (max.getTime() - min.getTime()) / 60000;\n                    break;\n                case powerbi.DateTimeUnit.Second:\n                    delta = (max.getTime() - min.getTime()) / 1000;\n                    break;\n                case powerbi.DateTimeUnit.Millisecond:\n                    delta = max.getTime() - min.getTime();\n                    break;\n            }\n            return delta;\n        };\n        DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {\n            maxCount = Math.max(maxCount, 2);\n            var totalDays = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Day);\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\n                return powerbi.DateTimeUnit.Year;\n            if (totalDays > 60 && totalDays > 7 * maxCount)\n                return powerbi.DateTimeUnit.Month;\n            if (totalDays > 14 && totalDays > 2 * maxCount)\n                return powerbi.DateTimeUnit.Week;\n            var totalHours = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Hour);\n            if (totalDays > 2 && totalHours > 12 * maxCount)\n                return powerbi.DateTimeUnit.Day;\n            if (totalHours >= 24 && totalHours >= maxCount)\n                return powerbi.DateTimeUnit.Hour;\n            var totalMinutes = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Minute);\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\n                return powerbi.DateTimeUnit.Minute;\n            var totalSeconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Second);\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\n                return powerbi.DateTimeUnit.Second;\n            var totalMilliseconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Millisecond);\n            if (totalMilliseconds > 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\n            var date = min;\n            if (date.getMilliseconds() !== 0)\n                return powerbi.DateTimeUnit.Millisecond;\n            if (date.getSeconds() !== 0)\n                return powerbi.DateTimeUnit.Second;\n            if (date.getMinutes() !== 0)\n                return powerbi.DateTimeUnit.Minute;\n            if (date.getHours() !== 0)\n                return powerbi.DateTimeUnit.Hour;\n            if (date.getDate() !== 1)\n                return powerbi.DateTimeUnit.Day;\n            if (date.getMonth() !== 0)\n                return powerbi.DateTimeUnit.Month;\n            return powerbi.DateTimeUnit.Year;\n        };\n        // Constants\n        DateTimeSequence.MIN_COUNT = 1;\n        DateTimeSequence.MAX_COUNT = 1000;\n        return DateTimeSequence;\n    }());\n    powerbi.DateTimeSequence = DateTimeSequence;\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\n    var DateUtils;\n    (function (DateUtils) {\n        var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        /**\n         * Returns bool indicating weither the provided year is a leap year.\n         * @param year - year value\n         */\n        function isLeap(year) {\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\n        }\n        /**\n         * Returns number of days in the provided year/month.\n         * @param year - year value\n         * @param month - month value\n         */\n        function getMonthDays(year, month) {\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\n        }\n        /**\n         * Adds a specified number of years to the provided date.\n         * @param date - date value\n         * @param yearDelta - number of years to add\n         */\n        function addYears(date, yearDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var isLeapDay = month === 2 && day === 29;\n            var result = new Date(date.getTime());\n            year = year + yearDelta;\n            if (isLeapDay && !isLeap(year)) {\n                day = 28;\n            }\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addYears = addYears;\n        /**\n         * Adds a specified number of months to the provided date.\n         * @param date - date value\n         * @param monthDelta - number of months to add\n         */\n        function addMonths(date, monthDelta) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            year += (monthDelta - (monthDelta % 12)) / 12;\n            month += monthDelta % 12;\n            // VSTS 1325771: Certain column charts don't display any data\n            // Wrap arround the month if is after december (value 11)\n            if (month > 11) {\n                month = month % 12;\n                year++;\n            }\n            day = Math.min(day, getMonthDays(year, month));\n            result.setFullYear(year, month, day);\n            return result;\n        }\n        DateUtils.addMonths = addMonths;\n        /**\n         * Adds a specified number of weeks to the provided date.\n         * @param date - date value\n         * @param weeks - number of weeks to add\n         */\n        function addWeeks(date, weeks) {\n            return addDays(date, weeks * 7);\n        }\n        DateUtils.addWeeks = addWeeks;\n        /**\n         * Adds a specified number of days to the provided date.\n         * @param date - date value\n         * @param days - number of days to add\n         */\n        function addDays(date, days) {\n            var year = date.getFullYear();\n            var month = date.getMonth();\n            var day = date.getDate();\n            var result = new Date(date.getTime());\n            result.setFullYear(year, month, day + days);\n            return result;\n        }\n        DateUtils.addDays = addDays;\n        /**\n         * Adds a specified number of hours to the provided date.\n         * @param date - date value\n         * @param hours - number of hours to add\n         */\n        function addHours(date, hours) {\n            return new Date(date.getTime() + hours * 3600000);\n        }\n        DateUtils.addHours = addHours;\n        /**\n         * Adds a specified number of minutes to the provided date.\n         * @param date - date value\n         * @param minutes - number of minutes to add\n         */\n        function addMinutes(date, minutes) {\n            return new Date(date.getTime() + minutes * 60000);\n        }\n        DateUtils.addMinutes = addMinutes;\n        /**\n         * Adds a specified number of seconds to the provided date.\n         * @param date - date value\n         * @param seconds - number of seconds to add\n         */\n        function addSeconds(date, seconds) {\n            return new Date(date.getTime() + seconds * 1000);\n        }\n        DateUtils.addSeconds = addSeconds;\n        /**\n         * Adds a specified number of milliseconds to the provided date.\n         * @param date - date value\n         * @param milliseconds - number of milliseconds to add\n         */\n        function addMilliseconds(date, milliseconds) {\n            return new Date(date.getTime() + milliseconds);\n        }\n        DateUtils.addMilliseconds = addMilliseconds;\n    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    // Constants\n    var maxExponent = 24;\n    var defaultScientificBigNumbersBoundary = 1E15;\n    var scientificSmallNumbersBoundary = 1E-4;\n    var PERCENTAGE_FORMAT = '%';\n    var SCIENTIFIC_FORMAT = 'E+0';\n    var DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\n    // Regular expressions\n    /**\n     * This regex looks for strings that match one of the following conditions:\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\n     * The entire string (start to end) must match, and the match is not case-sensitive.\n     */\n    var SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\n    var DisplayUnit = (function () {\n        function DisplayUnit() {\n        }\n        // Methods\n        DisplayUnit.prototype.project = function (value) {\n            if (this.value) {\n                return powerbi.Double.removeDecimalNoise(value / this.value);\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.reverseProject = function (value) {\n            if (this.value) {\n                return value * this.value;\n            }\n            else {\n                return value;\n            }\n        };\n        DisplayUnit.prototype.isApplicableTo = function (value) {\n            value = Math.abs(value);\n            var precision = powerbi.Double.getPrecision(value, 3);\n            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);\n        };\n        DisplayUnit.prototype.isScaling = function () {\n            return this.value > 1;\n        };\n        return DisplayUnit;\n    }());\n    powerbi.DisplayUnit = DisplayUnit;\n    var DisplayUnitSystem = (function () {\n        // Constructor\n        function DisplayUnitSystem(units) {\n            this.units = units ? units : [];\n        }\n        Object.defineProperty(DisplayUnitSystem.prototype, \"title\", {\n            // Properties\n            get: function () {\n                return this.displayUnit ? this.displayUnit.title : undefined;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // Methods\n        DisplayUnitSystem.prototype.update = function (value) {\n            if (value === undefined)\n                return;\n            this.unitBaseValue = value;\n            this.displayUnit = this.findApplicableDisplayUnit(value);\n        };\n        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {\n            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {\n                var unit = _a[_i];\n                if (unit.isApplicableTo(value))\n                    return unit;\n            }\n            return undefined;\n        };\n        DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros) {\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\n            if (this.isFormatSupported(format)) {\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\n                if (this.hasScientitifcFormat(format)) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\n                }\n                if (decimals != null) {\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\n                }\n            }\n            return powerbi.formattingService.formatValue(value, format);\n        };\n        DisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DisplayUnitSystem.prototype.isPercentageFormat = function (format) {\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\n        };\n        DisplayUnitSystem.prototype.shouldRespectScalingUnit = function (format) {\n            return !this.isPercentageFormat(format);\n        };\n        DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function (format, decimals) {\n            return decimals;\n        };\n        DisplayUnitSystem.prototype.isScalingUnit = function () {\n            return this.displayUnit && this.displayUnit.isScaling();\n        };\n        DisplayUnitSystem.prototype.formatHelper = function (value, nonScientificFormat, format, decimals, trailingZeros) {\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\n            if ((format === 'g' || format === 'G') && decimals != null)\n                format = powerbi.visuals.valueFormatter.DefaultNumericFormat;\n            format = powerbi.NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\n            if (format && !powerbi.formattingService.isStandardNumberFormat(format))\n                return powerbi.formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\n            if (!format)\n                format = 'G';\n            if (!nonScientificFormat)\n                nonScientificFormat = '{0}';\n            var text = powerbi.formattingService.formatValue(value, format);\n            return powerbi.formattingService.format(nonScientificFormat, [text]);\n        };\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\n        DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals, trailingZeros) {\n            // Change unit base to a value appropriate for this value\n            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);\n            return this.format(value, format, decimals, trailingZeros);\n        };\n        DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {\n            if (this.units.length === 0)\n                return true;\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\n            var applicableRangeMin = 0;\n            for (var i = 0; i < this.units.length; i++) {\n                if (this.units[i].isScaling()) {\n                    applicableRangeMin = this.units[i].applicableRangeMin;\n                    break;\n                }\n            }\n            return Math.abs(value) < applicableRangeMin;\n        };\n        DisplayUnitSystem.prototype.isScientific = function (value) {\n            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\n        };\n        DisplayUnitSystem.prototype.hasScientitifcFormat = function (format) {\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\n        };\n        DisplayUnitSystem.prototype.supportsScientificFormat = function (format) {\n            if (format)\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\n            return true;\n        };\n        DisplayUnitSystem.prototype.shouldFallbackToScientific = function (value, format) {\n            return !this.hasScientitifcFormat(format)\n                && this.supportsScientificFormat(format)\n                && this.isScientific(value);\n        };\n        DisplayUnitSystem.prototype.getScientificFormat = function (data, format, decimals, trailingZeros) {\n            // Use scientific format outside of the range\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\n                var numericFormat = powerbi.NumberFormat.getNumericFormat(data, format);\n                if (decimals)\n                    numericFormat = powerbi.NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\n                if (numericFormat)\n                    return numericFormat + SCIENTIFIC_FORMAT;\n                else\n                    return DEFAULT_SCIENTIFIC_FORMAT;\n            }\n            return format;\n        };\n        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\n        return DisplayUnitSystem;\n    }());\n    powerbi.DisplayUnitSystem = DisplayUnitSystem;\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\n    var NoDisplayUnitSystem = (function (_super) {\n        __extends(NoDisplayUnitSystem, _super);\n        // Constructor\n        function NoDisplayUnitSystem() {\n            _super.call(this, []);\n        }\n        return NoDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\n        we are showing values (chart axes) and as such it is the default unit system. */\n    var DefaultDisplayUnitSystem = (function (_super) {\n        __extends(DefaultDisplayUnitSystem, _super);\n        // Constructor\n        function DefaultDisplayUnitSystem(unitLookup) {\n            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));\n        }\n        // Methods\n        DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        DefaultDisplayUnitSystem.reset = function () {\n            DefaultDisplayUnitSystem.units = null;\n        };\n        DefaultDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DefaultDisplayUnitSystem.units) {\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, function (value, previousUnitValue, min) {\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\n                    if (value - previousUnitValue >= 1000) {\n                        return value / 10;\n                    }\n                    return min;\n                });\n                // Ensure last unit has max of infinity\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DefaultDisplayUnitSystem.units;\n        };\n        return DefaultDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\n        where we have restricted space but do not want to show partial units. */\n    var WholeUnitsDisplayUnitSystem = (function (_super) {\n        __extends(WholeUnitsDisplayUnitSystem, _super);\n        // Constructor\n        function WholeUnitsDisplayUnitSystem(unitLookup) {\n            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        WholeUnitsDisplayUnitSystem.reset = function () {\n            WholeUnitsDisplayUnitSystem.units = null;\n        };\n        WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!WholeUnitsDisplayUnitSystem.units) {\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\n                // Ensure last unit has max of infinity\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return WholeUnitsDisplayUnitSystem.units;\n        };\n        WholeUnitsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        return WholeUnitsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;\n    var DataLabelsDisplayUnitSystem = (function (_super) {\n        __extends(DataLabelsDisplayUnitSystem, _super);\n        function DataLabelsDisplayUnitSystem(unitLookup) {\n            _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup));\n        }\n        DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function (format) {\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\n        };\n        DataLabelsDisplayUnitSystem.getUnits = function (unitLookup) {\n            if (!DataLabelsDisplayUnitSystem.units) {\n                var units = [];\n                var adjustMinBasedOnPreviousUnit = function (value, previousUnitValue, min) {\n                    // Never returns true, we are always ignoring\n                    // We do not early switch (e.g. 100K instead of 0.1M)\n                    // Intended? If so, remove this function, otherwise, remove if statement\n                    if (value === -1)\n                        if (value - previousUnitValue >= 1000) {\n                            return value / 10;\n                        }\n                    return min;\n                };\n                // Add Auto & None\n                var names = unitLookup(-1);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                names = unitLookup(0);\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\n                // Add normal units\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\n                // Ensure last unit has max of infinity\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\n            }\n            return DataLabelsDisplayUnitSystem.units;\n        };\n        DataLabelsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\n            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);\n        };\n        // Constants\n        DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0;\n        DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1;\n        DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\n        return DataLabelsDisplayUnitSystem;\n    }(DisplayUnitSystem));\n    powerbi.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;\n    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {\n        var units = [];\n        for (var i = 3; i < maxExponent; i++) {\n            var names = unitLookup(i);\n            if (names)\n                addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\n        }\n        return units;\n    }\n    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {\n        if (title || labelFormat) {\n            var min = value;\n            if (units.length > 0) {\n                var previousUnit = units[units.length - 1];\n                if (adjustMinBasedOnPreviousUnit)\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\n                previousUnit.applicableRangeMax = min;\n            }\n            var unit = new DisplayUnit();\n            unit.value = value;\n            unit.applicableRangeMin = min;\n            unit.applicableRangeMax = min * 1000;\n            unit.title = title;\n            unit.labelFormat = labelFormat;\n            units.push(unit);\n        }\n    }\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequence = (function () {\n        function NumericSequence() {\n        }\n        NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {\n            debug.assertValue(range, \"range\");\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\n            debug.assert(minPower === undefined || (minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP), \"minPower\");\n            debug.assert(maxAllowedMargin === undefined || (maxAllowedMargin >= 0), \"maxAllowedMargin\");\n            var result = new NumericSequence();\n            if (expectedCount === undefined)\n                expectedCount = 10;\n            else\n                expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (minPower === undefined)\n                minPower = powerbi.Double.MIN_EXP;\n            if (useZeroRefPoint === undefined)\n                useZeroRefPoint = false;\n            if (maxAllowedMargin === undefined)\n                maxAllowedMargin = 1;\n            if (steps === undefined)\n                steps = [1, 2, 5];\n            // Handle single stop case\n            if (range.forcedSingleStop) {\n                result.interval = range.getSize();\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\n                result.min = range.min;\n                result.max = range.max;\n                result.sequence = [range.forcedSingleStop];\n                return result;\n            }\n            var interval = 0;\n            var min = 0;\n            var max = 9;\n            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\n            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\n            var size = range.getSize();\n            var exp = powerbi.Double.log10(size);\n            // Account for Exp of steps\n            var stepExp = powerbi.Double.log10(steps[0]);\n            exp = exp - stepExp;\n            // Account for MaxCount\n            var expectedCountExp = powerbi.Double.log10(expectedCount);\n            exp = exp - expectedCountExp;\n            // Account for MinPower\n            exp = Math.max(exp, minPower - stepExp + 1);\n            var count = undefined;\n            // Create array of \"good looking\" numbers\n            if (interval !== 0) {\n                // If explicit interval is defined - use it instead of the steps array.\n                var power = powerbi.Double.pow10(exp);\n                var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\n                roundRange.shrinkByStep(range, interval);\n                min = roundRange.min;\n                max = roundRange.max;\n                count = Math.floor(roundRange.getSize() / interval);\n            }\n            else {\n                // No interval defined -> find optimal interval\n                var dexp = void 0;\n                for (dexp = 0; dexp < 3; dexp++) {\n                    var e = exp + dexp;\n                    var power = powerbi.Double.pow10(e);\n                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);\n                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\n                    var stepsCount = steps.length;\n                    var stepPower = powerbi.Double.pow10(e - 1);\n                    for (var i = 0; i < stepsCount; i++) {\n                        var step = steps[i] * stepPower;\n                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\n                        roundRange.shrinkByStep(range, step);\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\n                            roundRange.min -= step;\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\n                            roundRange.max += step;\n                        // Count the intervals\n                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step);\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\n                            interval = step;\n                            min = roundRange.min;\n                            max = roundRange.max;\n                            break;\n                        }\n                    }\n                    // Increase the scale power until the interval is found\n                    if (interval !== 0)\n                        break;\n                }\n            }\n            // Avoid extreme count cases (>1000 ticks)\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\n                interval = (max - min) / count;\n            }\n            result.min = min;\n            result.max = max;\n            result.interval = interval;\n            result.intervalOffset = min - range.min;\n            result.maxAllowedMargin = maxAllowedMargin;\n            result.canExtendMin = canExtendMin;\n            result.canExtendMax = canExtendMax;\n            // Fill in the Sequence\n            var precision = powerbi.Double.getPrecision(interval, 0);\n            result.precision = precision;\n            var sequence = [];\n            var x = powerbi.Double.roundToPrecision(min, precision);\n            sequence.push(x);\n            for (var i = 0; i < count; i++) {\n                x = powerbi.Double.roundToPrecision(x + interval, precision);\n                sequence.push(x);\n            }\n            result.sequence = sequence;\n            result.trimMinMax(range.min, range.max);\n            return result;\n        };\n        /**\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid.\n         * @min - The minimum of the range.\n         * @max - The maximum of the range.\n         * @maxCount - The max count of intervals.\n         * @steps - array of intervals.\n         */\n        NumericSequence.calculateUnits = function (min, max, maxCount, steps) {\n            // Initialization actions\n            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\n            if (min === max) {\n                max = min + 1;\n            }\n            var stepCount = 0;\n            var step = 0;\n            // Calculate step\n            for (var i = 0; i < steps.length; i++) {\n                step = steps[i];\n                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);\n                var minStepCount = powerbi.Double.floorWithPrecision(min / step);\n                stepCount = maxStepCount - minStepCount;\n                if (stepCount <= maxCount) {\n                    break;\n                }\n            }\n            // Calculate the offset\n            var offset = -min;\n            offset = offset % step;\n            // Create sequence\n            var result = new NumericSequence();\n            result.sequence = [];\n            for (var x = min + offset;; x += step) {\n                result.sequence.push(x);\n                if (x >= max)\n                    break;\n            }\n            result.interval = step;\n            result.intervalOffset = offset;\n            result.min = result.sequence[0];\n            result.max = result.sequence[result.sequence.length - 1];\n            return result;\n        };\n        NumericSequence.prototype.trimMinMax = function (min, max) {\n            var minMargin = (min - this.min) / this.interval;\n            var maxMargin = (this.max - max) / this.interval;\n            var marginPrecision = 0.001;\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\n                this.min = min;\n            }\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\n                this.max = max;\n            }\n        };\n        NumericSequence.MIN_COUNT = 1;\n        NumericSequence.MAX_COUNT = 1000;\n        return NumericSequence;\n    }());\n    powerbi.NumericSequence = NumericSequence;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var NumericSequenceRange = (function () {\n        function NumericSequenceRange() {\n        }\n        NumericSequenceRange.prototype._ensureIncludeZero = function () {\n            if (this.includeZero) {\n                // fixed min and max has higher priority than includeZero\n                if (this.min > 0 && !this.hasFixedMin) {\n                    this.min = 0;\n                }\n                if (this.max < 0 && !this.hasFixedMax) {\n                    this.max = 0;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureNotEmpty = function () {\n            if (this.min === this.max) {\n                if (!this.min) {\n                    this.min = 0;\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\n                    this.hasFixedMin = true;\n                    this.hasFixedMax = true;\n                }\n                else {\n                    // We are dealing with a single data value (includeZero is not set)\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\n                    // Interval is calculated based on the number:\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\n                    var value = this.min;\n                    var exp = powerbi.Double.log10(Math.abs(value));\n                    var step = void 0;\n                    if (exp >= 0 && exp < 4) {\n                        step = 0.5;\n                        this.forcedSingleStop = value;\n                    }\n                    else {\n                        step = powerbi.Double.pow10(exp) / 2;\n                        this.forcedSingleStop = null;\n                    }\n                    this.min = value - step;\n                    this.max = value + step;\n                }\n            }\n        };\n        NumericSequenceRange.prototype._ensureDirection = function () {\n            if (this.min > this.max) {\n                var temp = this.min;\n                this.min = this.max;\n                this.max = temp;\n            }\n        };\n        NumericSequenceRange.prototype.getSize = function () {\n            return this.max - this.min;\n        };\n        NumericSequenceRange.prototype.shrinkByStep = function (range, step) {\n            debug.assertValue(range, \"range\");\n            debug.assert(step > 0, \"step\");\n            var oldCount = this.min / step;\n            var newCount = range.min / step;\n            var deltaCount = Math.floor(newCount - oldCount);\n            this.min += deltaCount * step;\n            oldCount = this.max / step;\n            newCount = range.max / step;\n            deltaCount = Math.ceil(newCount - oldCount);\n            this.max += deltaCount * step;\n        };\n        NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\n            var result = new NumericSequenceRange();\n            result.includeZero = includeZero ? true : false;\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\n            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\n            // Calculate the range using the min, max, dataRange\n            if (result.hasFixedMin && result.hasFixedMax) {\n                result.min = fixedMin;\n                result.max = fixedMax;\n            }\n            else if (result.hasFixedMin) {\n                result.min = fixedMin;\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\n            }\n            else if (result.hasFixedMax) {\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\n                result.max = fixedMax;\n            }\n            else if (result.hasDataRange) {\n                result.min = dataMin;\n                result.max = dataMax;\n            }\n            else {\n                result.min = 0;\n                result.max = 0;\n            }\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            if (result.min === 0) {\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\n            }\n            else if (result.max === 0) {\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\n            }\n            return result;\n        };\n        NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\n            }\n            else {\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\n            }\n        };\n        NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {\n            debug.assertValue(fixedMin, \"fixedMin\");\n            debug.assertValue(fixedMax, \"fixedMax\");\n            var result = new NumericSequenceRange();\n            result.hasDataRange = false;\n            result.includeZero = includeZero;\n            result.min = fixedMin;\n            result.max = fixedMax;\n            result._ensureIncludeZero();\n            result._ensureNotEmpty();\n            result._ensureDirection();\n            result.hasFixedMin = true;\n            result.hasFixedMax = true;\n            return result;\n        };\n        NumericSequenceRange.DEFAULT_MAX = 10;\n        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;\n        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;\n        return NumericSequenceRange;\n    }());\n    powerbi.NumericSequenceRange = NumericSequenceRange;\n    /** Note: Exported for testability */\n    var ValueUtil;\n    (function (ValueUtil) {\n        function hasValue(value) {\n            return value !== undefined && value !== null;\n        }\n        ValueUtil.hasValue = hasValue;\n    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var valueFormatter;\n        (function (valueFormatter) {\n            var StringExtensions = jsCommon.StringExtensions;\n            var BeautifiedFormat = {\n                '0.00 %;-0.00 %;0.00 %': 'Percentage',\n                '0.0 %;-0.0 %;0.0 %': 'Percentage1',\n            };\n            valueFormatter.DefaultIntegerFormat = 'g';\n            valueFormatter.DefaultNumericFormat = '#,0.00';\n            valueFormatter.DefaultDateFormat = 'd';\n            var defaultLocalizedStrings = {\n                'NullValue': '(Blank)',\n                'BooleanTrue': 'True',\n                'BooleanFalse': 'False',\n                'NaNValue': 'NaN',\n                'InfinityValue': '+Infinity',\n                'NegativeInfinityValue': '-Infinity',\n                'RestatementComma': '{0}, {1}',\n                'RestatementCompoundAnd': '{0} and {1}',\n                'RestatementCompoundOr': '{0} or {1}',\n                'DisplayUnitSystem_EAuto_Title': 'Auto',\n                'DisplayUnitSystem_E0_Title': 'None',\n                'DisplayUnitSystem_E3_LabelFormat': '{0}K',\n                'DisplayUnitSystem_E3_Title': 'Thousands',\n                'DisplayUnitSystem_E6_LabelFormat': '{0}M',\n                'DisplayUnitSystem_E6_Title': 'Millions',\n                'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\n                'DisplayUnitSystem_E9_Title': 'Billions',\n                'DisplayUnitSystem_E12_LabelFormat': '{0}T',\n                'DisplayUnitSystem_E12_Title': 'Trillions',\n                'Percentage': '#,0.##%',\n                'Percentage1': '#,0.#%',\n                'TableTotalLabel': 'Total',\n                'Tooltip_HighlightedValueDisplayName': 'Highlighted',\n                'Funnel_PercentOfFirst': 'Percent of first',\n                'Funnel_PercentOfPrevious': 'Percent of previous',\n                'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlight)',\n                'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlight)',\n                // Geotagging strings\n                'GeotaggingString_Continent': 'continent',\n                'GeotaggingString_Continents': 'continents',\n                'GeotaggingString_Country': 'country',\n                'GeotaggingString_Countries': 'countries',\n                'GeotaggingString_State': 'state',\n                'GeotaggingString_States': 'states',\n                'GeotaggingString_City': 'city',\n                'GeotaggingString_Cities': 'cities',\n                'GeotaggingString_Town': 'town',\n                'GeotaggingString_Towns': 'towns',\n                'GeotaggingString_Province': 'province',\n                'GeotaggingString_Provinces': 'provinces',\n                'GeotaggingString_County': 'county',\n                'GeotaggingString_Counties': 'counties',\n                'GeotaggingString_Village': 'village',\n                'GeotaggingString_Villages': 'villages',\n                'GeotaggingString_Post': 'post',\n                'GeotaggingString_Zip': 'zip',\n                'GeotaggingString_Code': 'code',\n                'GeotaggingString_Place': 'place',\n                'GeotaggingString_Places': 'places',\n                'GeotaggingString_Address': 'address',\n                'GeotaggingString_Addresses': 'addresses',\n                'GeotaggingString_Street': 'street',\n                'GeotaggingString_Streets': 'streets',\n                'GeotaggingString_Longitude': 'longitude',\n                'GeotaggingString_Longitude_Short': 'lon',\n                'GeotaggingString_Latitude': 'latitude',\n                'GeotaggingString_Latitude_Short': 'lat',\n                'GeotaggingString_PostalCode': 'postal code',\n                'GeotaggingString_PostalCodes': 'postal codes',\n                'GeotaggingString_ZipCode': 'zip code',\n                'GeotaggingString_ZipCodes': 'zip codes',\n                'GeotaggingString_Territory': 'territory',\n                'GeotaggingString_Territories': 'territories',\n            };\n            function beautify(format) {\n                var key = BeautifiedFormat[format];\n                if (key)\n                    return defaultLocalizedStrings[key] || format;\n                return format;\n            }\n            function describeUnit(exponent) {\n                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\n                var title = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\n                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\n                if (title || format)\n                    return { title: title, format: format };\n            }\n            function getLocalizedString(stringId) {\n                return defaultLocalizedStrings[stringId];\n            }\n            valueFormatter.getLocalizedString = getLocalizedString;\n            // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\n            var locale = {\n                null: defaultLocalizedStrings['NullValue'],\n                true: defaultLocalizedStrings['BooleanTrue'],\n                false: defaultLocalizedStrings['BooleanFalse'],\n                NaN: defaultLocalizedStrings['NaNValue'],\n                infinity: defaultLocalizedStrings['InfinityValue'],\n                negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\n                beautify: function (format) { return beautify(format); },\n                describe: function (exponent) { return describeUnit(exponent); },\n                restatementComma: defaultLocalizedStrings['RestatementComma'],\n                restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\n                restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\n            };\n            var MaxScaledDecimalPlaces = 2;\n            var MaxValueForDisplayUnitRounding = 1000;\n            var MinIntegerValueForDisplayUnits = 10000;\n            var MinPrecisionForDisplayUnits = 2;\n            var DateTimeMetadataColumn = {\n                displayName: '',\n                type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.DateTime),\n            };\n            function getFormatMetadata(format) {\n                return powerbi.NumberFormat.getCustomFormatMetadata(format);\n            }\n            valueFormatter.getFormatMetadata = getFormatMetadata;\n            function setLocaleOptions(options) {\n                debug.assertValue(options, 'options');\n                locale = options;\n                powerbi.DefaultDisplayUnitSystem.reset();\n                powerbi.WholeUnitsDisplayUnitSystem.reset();\n            }\n            valueFormatter.setLocaleOptions = setLocaleOptions;\n            function createDefaultFormatter(formatString, allowFormatBeautification) {\n                if (allowFormatBeautification === void 0) { allowFormatBeautification = false; }\n                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;\n                return {\n                    format: function (value) {\n                        if (value == null)\n                            return locale.null;\n                        return formatCore(value, formatBeaut);\n                    }\n                };\n            }\n            valueFormatter.createDefaultFormatter = createDefaultFormatter;\n            /** Creates an IValueFormatter to be used for a range of values. */\n            function create(options) {\n                debug.assertValue(options, 'options');\n                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\n                if (shouldUseNumericDisplayUnits(options)) {\n                    var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType);\n                    var singleValueFormattingMode_1 = !!options.formatSingleValues;\n                    displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\n                    var forcePrecision_1 = options.precision != null;\n                    var decimals_1;\n                    if (forcePrecision_1)\n                        decimals_1 = -options.precision;\n                    else if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1)\n                        decimals_1 = -MaxScaledDecimalPlaces;\n                    // Detect axis precision\n                    if (options.detectAxisPrecision) {\n                        // Trailing zeroes\n                        forcePrecision_1 = true;\n                        var axisValue = options.value;\n                        if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 0)\n                            axisValue = axisValue / displayUnitSystem_1.displayUnit.value;\n                        if (powerbi.Double.isInteger(axisValue))\n                            decimals_1 = 0;\n                        else\n                            decimals_1 = powerbi.Double.log10(axisValue);\n                    }\n                    return {\n                        format: function (value) {\n                            var formattedValue = getStringFormat(value, true /*nullsAreBlank*/);\n                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                                return formattedValue;\n                            // Round to Double.DEFAULT_PRECISION\n                            if (value && !displayUnitSystem_1.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision_1)\n                                value = powerbi.Double.roundToPrecision(value);\n                            return singleValueFormattingMode_1 ?\n                                displayUnitSystem_1.formatSingleValue(value, format, decimals_1, forcePrecision_1) :\n                                displayUnitSystem_1.format(value, format, decimals_1, forcePrecision_1);\n                        },\n                        displayUnit: displayUnitSystem_1.displayUnit,\n                        options: options\n                    };\n                }\n                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\n                    var unit_1 = powerbi.DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\n                    return {\n                        format: function (value) {\n                            if (value == null)\n                                return locale.null;\n                            var formatString = powerbi.formattingService.dateFormatString(unit_1);\n                            return formatCore(value, formatString);\n                        },\n                        options: options\n                    };\n                }\n                return createDefaultFormatter(format);\n            }\n            valueFormatter.create = create;\n            function format(value, format, allowFormatBeautification) {\n                if (value == null)\n                    return locale.null;\n                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);\n            }\n            valueFormatter.format = format;\n            function getValueFormat(value, columnType) {\n                // If column type not defined or is not datetime\n                // ...and the value is of time datetime,\n                // then use the default date format string\n                if ((!columnType || !columnType.dateTime) && value instanceof Date)\n                    return getFormatString(DateTimeMetadataColumn, null, false);\n            }\n            function formatValueColumn(value, column, formatStringProp) {\n                var valueFormat = getValueFormat(value, column.type);\n                if (valueFormat)\n                    return formatCore(value, valueFormat);\n                else\n                    return formatCore(value, getFormatString(column, formatStringProp));\n            }\n            valueFormatter.formatValueColumn = formatValueColumn;\n            function createDisplayUnitSystem(displayUnitSystemType) {\n                if (displayUnitSystemType == null)\n                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                switch (displayUnitSystemType) {\n                    case powerbi.DisplayUnitSystemType.Default:\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.WholeUnits:\n                        return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);\n                    case powerbi.DisplayUnitSystemType.Verbose:\n                        return new powerbi.NoDisplayUnitSystem();\n                    case powerbi.DisplayUnitSystemType.DataLabels:\n                        return new powerbi.DataLabelsDisplayUnitSystem(locale.describe);\n                    default:\n                        debug.assertFail('Unknown display unit system type');\n                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);\n                }\n            }\n            function shouldUseNumericDisplayUnits(options) {\n                var value = options.value;\n                var value2 = options.value2;\n                var format = options.format;\n                // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\n                if (options.formatSingleValues && format) {\n                    if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\n                        var isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\n                        if (isCustomFormat) {\n                            var precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\n                            if (precision < MinPrecisionForDisplayUnits)\n                                return false;\n                        }\n                        else if (powerbi.Double.isInteger(value))\n                            return false;\n                    }\n                }\n                if ((typeof value === 'number') || (typeof value2 === 'number')) {\n                    return true;\n                }\n            }\n            function shouldUseDateUnits(value, value2, tickCount) {\n                // must check both value and value2 because we'll need to get an interval for date units\n                return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\n            }\n            /*\n             * Get the column format. Order of precendence is:\n             *  1. Column format\n             *  2. Default PowerView policy for column type\n             */\n            function getFormatString(column, formatStringProperty, suppressTypeFallback) {\n                if (column) {\n                    if (formatStringProperty) {\n                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);\n                        if (propertyValue)\n                            return propertyValue;\n                    }\n                    if (!suppressTypeFallback) {\n                        var columnType = column.type;\n                        if (columnType) {\n                            if (columnType.dateTime)\n                                return valueFormatter.DefaultDateFormat;\n                            if (columnType.integer)\n                                return valueFormatter.DefaultIntegerFormat;\n                            if (columnType.numeric)\n                                return valueFormatter.DefaultNumericFormat;\n                        }\n                    }\n                }\n            }\n            valueFormatter.getFormatString = getFormatString;\n            function formatListCompound(strings, conjunction) {\n                var result;\n                if (!strings) {\n                    return null;\n                }\n                var length = strings.length;\n                if (length > 0) {\n                    result = strings[0];\n                    var lastIndex = length - 1;\n                    for (var i = 1, len = lastIndex; i < len; i++) {\n                        var value = strings[i];\n                        result = StringExtensions.format(locale.restatementComma, result, value);\n                    }\n                    if (length > 1) {\n                        var value = strings[lastIndex];\n                        result = StringExtensions.format(conjunction, result, value);\n                    }\n                }\n                else {\n                    result = null;\n                }\n                return result;\n            }\n            /** The returned string will look like 'A, B, ..., and C'  */\n            function formatListAnd(strings) {\n                return formatListCompound(strings, locale.restatementCompoundAnd);\n            }\n            valueFormatter.formatListAnd = formatListAnd;\n            /** The returned string will look like 'A, B, ..., or C' */\n            function formatListOr(strings) {\n                return formatListCompound(strings, locale.restatementCompoundOr);\n            }\n            valueFormatter.formatListOr = formatListOr;\n            function formatCore(value, format) {\n                var formattedValue = getStringFormat(value, false /*nullsAreBlank*/);\n                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\n                    return formattedValue;\n                return powerbi.formattingService.formatValue(value, format);\n            }\n            function getStringFormat(value, nullsAreBlank) {\n                if (value == null && nullsAreBlank)\n                    return locale.null;\n                if (value === true)\n                    return locale.true;\n                if (value === false)\n                    return locale.false;\n                if (typeof value === 'number' && isNaN(value))\n                    return locale.NaN;\n                if (value === Number.NEGATIVE_INFINITY)\n                    return locale.negativeInfinity;\n                if (value === Number.POSITIVE_INFINITY)\n                    return locale.infinity;\n                return '';\n            }\n            function getDisplayUnits(displayUnitSystemType) {\n                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\n                return displayUnitSystem.units;\n            }\n            valueFormatter.getDisplayUnits = getDisplayUnits;\n        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper;\n        (function (DataRoleHelper) {\n            function getMeasureIndexOfRole(grouped, roleName) {\n                if (!_.isEmpty(grouped)) {\n                    var firstGroup = grouped[0];\n                    if (firstGroup.values && firstGroup.values.length > 0) {\n                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {\n                            var value = firstGroup.values[i];\n                            if (value && value.source) {\n                                if (hasRole(value.source, roleName))\n                                    return i;\n                            }\n                        }\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;\n            function getCategoryIndexOfRole(categories, roleName) {\n                if (!_.isEmpty(categories)) {\n                    for (var i = 0, ilen = categories.length; i < ilen; i++) {\n                        if (hasRole(categories[i].source, roleName))\n                            return i;\n                    }\n                }\n                return -1;\n            }\n            DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;\n            function hasRole(column, name) {\n                var roles = column.roles;\n                return roles && roles[name];\n            }\n            DataRoleHelper.hasRole = hasRole;\n            function hasRoleInDataView(dataView, name) {\n                return dataView != null\n                    && dataView.metadata != null\n                    && dataView.metadata.columns\n                    && _.any(dataView.metadata.columns, function (c) { return c.roles && c.roles[name] !== undefined; });\n            }\n            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;\n            function hasRoleInValueColumn(valueColumn, name) {\n                return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\n            }\n            DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;\n        })(DataRoleHelper = data.DataRoleHelper || (data.DataRoleHelper = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataRoleHelper = powerbi.data.DataRoleHelper;\n        function createIDataViewCategoricalReader(dataView) {\n            return new DataViewCategoricalReader(dataView);\n        }\n        data.createIDataViewCategoricalReader = createIDataViewCategoricalReader;\n        var DataViewCategoricalReader = (function () {\n            function DataViewCategoricalReader(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                this.dataView = dataView;\n                // Validate categories\n                var categorical;\n                if (dataView)\n                    categorical = dataView.categorical;\n                var categories;\n                if (categorical)\n                    categories = this.categories = categorical.categories;\n                this.hasValidCategories = !_.isEmpty(categories);\n                // Validate values\n                var values;\n                if (categorical)\n                    values = categorical.values;\n                // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\n                // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\n                this.hasAnyValidValues = false;\n                if (values != null) {\n                    var grouped = dataView.categorical.values.grouped();\n                    if (grouped.length > 0) {\n                        this.hasAnyValidValues = true;\n                        this.grouped = grouped;\n                        // Iterate through the first group's values to populate the valueRoleIndexMapping\n                        var valueRoleIndexMapping = {};\n                        var firstGroupValues = grouped[0].values;\n                        for (var valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\n                            var valueRoles = firstGroupValues[valueIndex].source.roles;\n                            for (var role in valueRoles) {\n                                if (valueRoles[role]) {\n                                    if (!valueRoleIndexMapping[role])\n                                        valueRoleIndexMapping[role] = [];\n                                    valueRoleIndexMapping[role].push(valueIndex);\n                                }\n                            }\n                        }\n                        this.valueRoleIndexMapping = valueRoleIndexMapping;\n                    }\n                }\n                if (this.hasAnyValidValues)\n                    this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\n            }\n            // Category methods\n            DataViewCategoricalReader.prototype.hasCategories = function () {\n                return this.hasValidCategories;\n            };\n            DataViewCategoricalReader.prototype.getCategoryCount = function () {\n                if (this.hasValidCategories)\n                    return this.categories[0].values.length;\n                else\n                    return 0;\n            };\n            DataViewCategoricalReader.prototype.getCategoryValues = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryValue = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.values[categoryIndex] : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumn = function (roleName) {\n                if (this.hasValidCategories)\n                    return this.getCategoryFromRole(roleName);\n            };\n            DataViewCategoricalReader.prototype.getCategoryMetadataColumn = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.source : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryColumnIdentityFields = function (roleName) {\n                if (this.hasValidCategories) {\n                    var categories = this.getCategoryFromRole(roleName);\n                    return categories ? categories.identityFields : undefined;\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryDisplayName = function (roleName) {\n                if (this.hasValidCategories) {\n                    var targetColumn = this.getCategoryColumn(roleName);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.hasCompositeCategories = function () {\n                if (this.hasValidCategories)\n                    return this.categories.length > 1;\n            };\n            DataViewCategoricalReader.prototype.hasCategoryWithRole = function (roleName) {\n                return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\n            };\n            DataViewCategoricalReader.prototype.getCategoryObjects = function (roleName, categoryIndex) {\n                if (this.hasValidCategories) {\n                    var category = this.getCategoryFromRole(roleName);\n                    if (category && category.objects) {\n                        return category.objects[categoryIndex];\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getCategoryFromRole = function (roleName) {\n                var categories = this.categories;\n                return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\n            };\n            // Value and measure methods\n            DataViewCategoricalReader.prototype.hasValues = function (roleName) {\n                return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\n            };\n            DataViewCategoricalReader.prototype.getValue = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    if (this.dataHasDynamicSeries) {\n                        // For dynamic series, we only ever obtain the first value column from a role\n                        return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0);\n                    }\n                    else {\n                        // For static series or single series, we obtain value columns from the first series\n                        //    and use the seriesIndex to index into the value columns within the role\n                        return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex);\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getAllValuesForRole = function (roleName, categoryIndex, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName)) {\n                    var valuesInRole = [];\n                    for (var roleValueIndex = void 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\n                        valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex));\n                    }\n                    return valuesInRole;\n                }\n            };\n            /**\n             * Obtains the value from grouped.\n             *\n             * Grouped:             [0] [1] [2] [3] (seriesIndex)\n             *                         /   \\\n             * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\n             *                    /    \\ \\  \\\n             * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\n             *\n             *--------------------------------|\n             *                      |Category |\n             * Series|Value Columns |A B C D E|\n             *--------------------------------|\n             *      0|col0 (tooltip)|         |\n             *       |col1 (value)  |         |\n             *       |col2 (value)  |         |\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      1|col0 (tooltip)|         |\n             *       |col1 (value)  |0 1 2 3 4|\n             *       |col2 (value)  |5 6 7 8 9|\n             *       |col3 (tooltip)|         |\n             *       |col4 (value)  |         |\n             *--------------------------------|\n             *      2|col0 (tooltip)|...      |\n             *\n             * valueColumnIndexInRole is for indexing into the values for a single role\n             * valueColumnIndex is for indexing into the entire value array including\n             * all roles\n             *\n             * The valueRoleIndexMapping converts roleValueIndex and role (value role\n             * with an index of 1) into groupedValueIndex (2)\n             *\n             * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\n             * the second value column with role \"value\" (which is converted to a\n             * groupedValueIndex of 2) and the fourth value within that value column.\n             */\n            DataViewCategoricalReader.prototype.getValueInternal = function (roleName, categoryIndex, groupIndex, valueColumnIndexInRole) {\n                if (this.hasValues(roleName)) {\n                    var valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\n                    return this.grouped[groupIndex].values[valueColumnIndex].values[categoryIndex];\n                }\n            };\n            DataViewCategoricalReader.prototype.getFirstNonNullValueForCategory = function (roleName, categoryIndex) {\n                if (this.hasValues(roleName)) {\n                    if (!this.dataHasDynamicSeries) {\n                        debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\n                        return this.getValue(roleName, categoryIndex);\n                    }\n                    for (var seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\n                        var value = this.getValue(roleName, categoryIndex, seriesIndex);\n                        if (value != null) {\n                            return value;\n                        }\n                    }\n                }\n            };\n            DataViewCategoricalReader.prototype.getMeasureQueryName = function (roleName) {\n                if (this.hasValues(roleName))\n                    return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\n            };\n            DataViewCategoricalReader.prototype.getValueColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName))\n                    return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\n            };\n            DataViewCategoricalReader.prototype.getValueMetadataColumn = function (roleName, seriesIndex) {\n                if (seriesIndex === void 0) { seriesIndex = 0; }\n                if (this.hasValues(roleName))\n                    return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]].source;\n            };\n            DataViewCategoricalReader.prototype.getValueDisplayName = function (roleName, seriesIndex) {\n                if (this.hasValues(roleName)) {\n                    var targetColumn = this.getValueColumn(roleName, seriesIndex);\n                    if (targetColumn && targetColumn.source) {\n                        return targetColumn.source.displayName;\n                    }\n                }\n            };\n            // Series methods\n            DataViewCategoricalReader.prototype.hasDynamicSeries = function () {\n                return this.dataHasDynamicSeries;\n            };\n            DataViewCategoricalReader.prototype.getSeriesCount = function () {\n                if (this.hasAnyValidValues)\n                    return this.grouped.length;\n            };\n            DataViewCategoricalReader.prototype.getSeriesObjects = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].objects;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumns = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values;\n            };\n            DataViewCategoricalReader.prototype.getSeriesValueColumnGroup = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex];\n            };\n            DataViewCategoricalReader.prototype.getSeriesMetadataColumn = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.source;\n            };\n            DataViewCategoricalReader.prototype.getSeriesColumnIdentityFields = function () {\n                if (this.hasAnyValidValues)\n                    return this.dataView.categorical.values.identityFields;\n            };\n            DataViewCategoricalReader.prototype.getSeriesName = function (seriesIndex) {\n                if (this.hasAnyValidValues)\n                    return this.grouped[seriesIndex].name;\n            };\n            DataViewCategoricalReader.prototype.getSeriesDisplayName = function () {\n                if (this.hasAnyValidValues && this.dataHasDynamicSeries)\n                    return this.dataView.categorical.values.source.displayName;\n            };\n            return DataViewCategoricalReader;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var valueFormatter = powerbi.visuals.valueFormatter;\n        var DataViewConcatenateCategoricalColumns;\n        (function (DataViewConcatenateCategoricalColumns) {\n            function detectAndApply(dataView, objectDescriptors, roleMappings, projectionOrdering, selects, projectionActiveItems) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                var result = dataView;\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical) {\n                    var concatenationSource = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\n                    if (concatenationSource) {\n                        // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\n                        var columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\n                        if (columnsSortedByProjectionOrdering.length >= 2) {\n                            var activeItemsToIgnoreInConcatenation = _.chain(projectionActiveItems[concatenationSource.roleName])\n                                .filter(function (activeItemInfo) { return activeItemInfo.suppressConcat; })\n                                .map(function (activeItemInfo) { return activeItemInfo.queryRef; })\n                                .value();\n                            result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\n                        }\n                    }\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.detectAndApply = detectAndApply;\n            /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\n            function applyToPlayChartCategorical(metadata, objectDescriptors, categoryRoleName, categorical) {\n                debug.assertValue(metadata, 'metadata');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(categorical, 'categorical');\n                var result;\n                if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\n                    // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\n                    // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\n                    // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\n                    // use inherit() rather than inheritSingle() here.\n                    var transformingColumns_1 = inherit(metadata.columns);\n                    var transformingMetadata = inherit(metadata, function (m) { m.columns = transformingColumns_1; });\n                    var transformingDataView = { metadata: transformingMetadata, categorical: categorical };\n                    result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\n                }\n                else {\n                    result = { metadata: metadata, categorical: categorical };\n                }\n                return result;\n            }\n            DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical = applyToPlayChartCategorical;\n            /**\n             * Returns the role and its assocated category columns (from dataViewCategorical.categories)\n             * that should be concatenated for the case of hierarchical group.\n             *\n             * Note: In the future if we support sibling hierarchical groups in categorical,\n             * change the return type to CategoryColumnsByRole[] and update detection logic.\n             */\n            function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, metadata, dataViewMappings, selects, projectionActiveItems) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\n                var result;\n                // For now, just handle the case where roleMappings.length === 1.\n                // In the future, if there is more than 1, we might want to proceed if, \n                // for example, all role mappings map category to the same role name and they all have { max: 1 } conditions.\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var roleMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                var roleMappingForCategorical = (roleMappings && roleMappings.length === 1 && !!roleMappings[0].categorical) ? roleMappings[0] : undefined;\n                if (roleMappingForCategorical) {\n                    var roleNamesForCategory = getAllRolesInCategories(roleMappingForCategorical.categorical);\n                    // With \"list\" in role mapping, is it possible to have multiple role names for category.\n                    // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\n                    // We can change this if we want to support independent (sibling) group hierarchies in categorical.\n                    if (roleNamesForCategory && roleNamesForCategory.length === 1) {\n                        var targetRoleName_1 = roleNamesForCategory[0];\n                        var isVisualExpectingMaxOneCategoryColumn = !_.isEmpty(roleMappingForCategorical.conditions) &&\n                            _.every(roleMappingForCategorical.conditions, function (condition) { return condition[targetRoleName_1] && condition[targetRoleName_1].max === 1; });\n                        if (isVisualExpectingMaxOneCategoryColumn) {\n                            var categoriesForTargetRole_1 = _.filter(dataViewCategorical.categories, function (categoryColumn) { return categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName_1]; });\n                            // At least for now, we expect all category columns for the same role to have the same number of value entries.\n                            // If that's not the case, we won't run the concatenate logic for that role at all...\n                            var areValuesCountsEqual = _.every(categoriesForTargetRole_1, function (categoryColumn) { return categoryColumn.values.length === categoriesForTargetRole_1[0].values.length; });\n                            // Also, there is no need to concatenate columns unless there is actually more than one column\n                            if (areValuesCountsEqual &&\n                                categoriesForTargetRole_1.length >= 2) {\n                                result = {\n                                    roleName: targetRoleName_1,\n                                    categories: categoriesForTargetRole_1\n                                };\n                            }\n                        }\n                    }\n                }\n                return result;\n            }\n            /**\n             * Returns the array of role names that are mapped to categorical categories.\n             * Returns an empty array if none exists.\n             */\n            function getAllRolesInCategories(categoricalRoleMapping) {\n                debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\n                var roleNames = [];\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalRoleMapping.categories, {\n                    visitRole: function (roleName) {\n                        roleNames.push(roleName);\n                    }\n                });\n                return roleNames;\n            }\n            function applyConcatenation(dataView, objectDescriptors, roleName, columnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(roleName, 'roleName');\n                debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\n                var formatStringPropId = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                var concatenatedValues = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\n                var columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, function (categoryColumn) { return categoryColumn.source; });\n                var concatenatedColumnMetadata = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\n                var transformedDataView = inheritSingle(dataView);\n                addToMetadata(transformedDataView, concatenatedColumnMetadata);\n                var concatenatedCategoryColumn = createConcatenatedCategoryColumn(columnsSortedByProjectionOrdering, concatenatedColumnMetadata, concatenatedValues);\n                var dataViewCategorical = dataView.categorical;\n                var transformedCategoricalCategories = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\n                transformedCategoricalCategories.push(concatenatedCategoryColumn);\n                var transformedCategorical = inheritSingle(dataViewCategorical);\n                transformedCategorical.categories = transformedCategoricalCategories;\n                transformedDataView.categorical = transformedCategorical;\n                return transformedDataView;\n            }\n            function concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId) {\n                debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\n                debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\n                debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\n                var concatenatedValues = [];\n                // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\n                for (var _i = 0, columnsSortedByProjectionOrdering_1 = columnsSortedByProjectionOrdering; _i < columnsSortedByProjectionOrdering_1.length; _i++) {\n                    var categoryColumn = columnsSortedByProjectionOrdering_1[_i];\n                    var formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\n                    for (var i = 0, len = categoryColumn.values.length; i < len; i++) {\n                        if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\n                            var value = categoryColumn.values && categoryColumn.values[i];\n                            var formattedValue = valueFormatter.format(value, formatString);\n                            concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\n                        }\n                    }\n                }\n                return concatenatedValues;\n            }\n            /**\n            * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\n            */\n            function sortColumnsByProjectionOrdering(projectionOrdering, roleName, columns) {\n                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\n                debug.assertValue(roleName, 'roleName');\n                debug.assertValue(columns, 'columns');\n                var columnsInProjectionOrdering;\n                if (projectionOrdering) {\n                    // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\n                    var columnsByIndex_1 = {};\n                    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {\n                        var column = columns_1[_i];\n                        if (column.source.roles[roleName]) {\n                            debug.assert(!columnsByIndex_1[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\n                            columnsByIndex_1[column.source.index] = column;\n                        }\n                    }\n                    var columnIndicesInProjectionOrdering = projectionOrdering[roleName];\n                    columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\n                        .map(function (columnIndex) { return columnsByIndex_1[columnIndex]; })\n                        .filter(function (column) { return !!column; })\n                        .value();\n                }\n                else {\n                    // If projectionOrder is unspecified, just return the columns for the specified role in their current order\n                    columnsInProjectionOrdering = _.filter(columns, function (column) { return column.source.roles[roleName]; });\n                }\n                return columnsInProjectionOrdering;\n            }\n            /**\n             * Creates the column metadata that will back the column with the concatenated values.\n             */\n            function createConcatenatedColumnMetadata(roleName, sourceColumnsSortedByProjectionOrdering, queryRefsToIgnore) {\n                debug.assertValue(roleName, 'roleName');\n                debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\n                debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(function (c) { return c.isMeasure; }).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\n                var concatenatedDisplayName;\n                for (var _i = 0, sourceColumnsSortedByProjectionOrdering_1 = sourceColumnsSortedByProjectionOrdering; _i < sourceColumnsSortedByProjectionOrdering_1.length; _i++) {\n                    var columnSource = sourceColumnsSortedByProjectionOrdering_1[_i];\n                    if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\n                        concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\n                    }\n                }\n                var newRoles = {};\n                newRoles[roleName] = true;\n                var newColumnMetadata = {\n                    displayName: concatenatedDisplayName,\n                    roles: newRoles,\n                    type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Text)\n                };\n                var columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\n                if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\n                    newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\n                }\n                // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\n                // If queryName is not set at all, the column chart visual will only render column for the first group instance.\n                // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\n                newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\n                return newColumnMetadata;\n            }\n            function addToMetadata(transformedDataView, newColumn) {\n                debug.assertValue(transformedDataView, 'transformedDataView');\n                debug.assertValue(newColumn, 'newColumn');\n                var transformedColumns = inheritSingle(transformedDataView.metadata.columns);\n                transformedColumns.push(newColumn);\n                var transformedMetadata = inheritSingle(transformedDataView.metadata);\n                transformedMetadata.columns = transformedColumns;\n                transformedDataView.metadata = transformedMetadata;\n            }\n            function createConcatenatedCategoryColumn(sourceColumnsSortedByProjectionOrdering, columnMetadata, concatenatedValues) {\n                debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\n                var newCategoryColumn = {\n                    source: columnMetadata,\n                    values: concatenatedValues\n                };\n                // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\n                // So, we'll just take the identities and identityFields from the first column\n                var firstColumn = sourceColumnsSortedByProjectionOrdering[0];\n                if (firstColumn.identity) {\n                    newCategoryColumn.identity = firstColumn.identity;\n                }\n                if (firstColumn.identityFields) {\n                    newCategoryColumn.identityFields = firstColumn.identityFields;\n                }\n                // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\n                if (firstColumn.objects) {\n                    newCategoryColumn.objects = firstColumn.objects;\n                }\n                return newCategoryColumn;\n            }\n        })(DataViewConcatenateCategoricalColumns = data.DataViewConcatenateCategoricalColumns || (data.DataViewConcatenateCategoricalColumns = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewMapping;\n    (function (DataViewMapping) {\n        function visitMapping(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var categorical = mapping.categorical;\n            if (categorical)\n                visitCategorical(categorical, visitor);\n            var table = mapping.table;\n            if (table)\n                visitTable(table, visitor);\n            var matrix = mapping.matrix;\n            if (matrix)\n                visitMatrix(matrix, visitor);\n            var tree = mapping.tree;\n            if (tree)\n                visitTree(tree, visitor);\n            var single = mapping.single;\n            if (single)\n                visitSingle(single, visitor);\n        }\n        DataViewMapping.visitMapping = visitMapping;\n        function visitCategorical(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitCategoricalCategories(mapping.categories, visitor);\n            visitCategoricalValues(mapping.values, visitor);\n        }\n        DataViewMapping.visitCategorical = visitCategorical;\n        function visitCategoricalCategories(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor);\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitCategoricalCategories = visitCategoricalCategories;\n        function visitCategoricalValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitBind(mapping, visitor, 0 /* CategoricalValue */);\n                visitFor(mapping, visitor, 0 /* CategoricalValue */);\n                visitList(mapping, visitor, 0 /* CategoricalValue */);\n                var groupedRoleMapping = mapping;\n                visitGrouped(groupedRoleMapping, visitor);\n                var group = groupedRoleMapping.group;\n                if (group) {\n                    for (var _i = 0, _a = group.select; _i < _a.length; _i++) {\n                        var item = _a[_i];\n                        visitBind(item, visitor, 1 /* CategoricalValueGroup */);\n                        visitFor(item, visitor, 1 /* CategoricalValueGroup */);\n                    }\n                }\n            }\n        }\n        DataViewMapping.visitCategoricalValues = visitCategoricalValues;\n        function visitTable(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var rows = mapping.rows;\n            visitBind(rows, visitor);\n            visitFor(rows, visitor);\n            visitList(rows, visitor);\n            visitReduction(rows, visitor);\n        }\n        DataViewMapping.visitTable = visitTable;\n        function visitMatrix(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitMatrixItems(mapping.rows, visitor);\n            visitMatrixItems(mapping.columns, visitor);\n            visitMatrixItems(mapping.values, visitor);\n        }\n        /**\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         *\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\n         * @param visitor The visitor.\n         */\n        function visitMatrixItems(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitList(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitMatrixItems = visitMatrixItems;\n        function visitTree(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitTreeNodes(mapping.nodes, visitor);\n            visitTreeValues(mapping.values, visitor);\n        }\n        function visitTreeNodes(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n                visitReduction(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeNodes = visitTreeNodes;\n        function visitTreeValues(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (mapping) {\n                visitFor(mapping, visitor);\n            }\n        }\n        DataViewMapping.visitTreeValues = visitTreeValues;\n        function visitBind(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var bind = mapping.bind;\n            if (bind) {\n                if (context != null)\n                    visitor.visitRole(bind.to, context);\n                else\n                    visitor.visitRole(bind.to);\n            }\n        }\n        function visitFor(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var forValue = mapping.for;\n            if (forValue) {\n                if (context != null)\n                    visitor.visitRole(forValue.in, context);\n                else\n                    visitor.visitRole(forValue.in);\n            }\n        }\n        function visitList(mapping, visitor, context) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            var select = mapping.select;\n            if (select) {\n                for (var _i = 0, select_1 = select; _i < select_1.length; _i++) {\n                    var item = select_1[_i];\n                    visitBind(item, visitor, context);\n                    visitFor(item, visitor, context);\n                }\n            }\n        }\n        function visitGrouped(mapping, visitor) {\n            debug.assertAnyValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (!mapping)\n                return;\n            var group = mapping.group;\n            if (group) {\n                visitor.visitRole(group.by);\n                visitReduction(group, visitor);\n            }\n        }\n        DataViewMapping.visitGrouped = visitGrouped;\n        function visitReduction(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            if (visitor.visitReduction) {\n                var reductionAlgorithm = mapping.dataReductionAlgorithm;\n                if (reductionAlgorithm) {\n                    visitor.visitReduction(reductionAlgorithm);\n                }\n            }\n        }\n        function visitSingle(mapping, visitor) {\n            debug.assertValue(mapping, 'mapping');\n            debug.assertValue(visitor, 'visitor');\n            visitor.visitRole(mapping.role);\n        }\n    })(DataViewMapping = powerbi.DataViewMapping || (powerbi.DataViewMapping = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewNormalizeValues;\n        (function (DataViewNormalizeValues) {\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                var rolesToNormalize = _.filter(options.dataRoles, function (role) { return !_.isEmpty(role.requiredTypes); });\n                filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\n            }\n            DataViewNormalizeValues.apply = apply;\n            function filterVariantMeasures(dataview, dataViewMappings, rolesToNormalize) {\n                debug.assertValue(dataview, 'dataview');\n                // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\n                    return;\n                var columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\n                var valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\n                var usedMappings = {};\n                for (var _i = 0, dataViewMappings_1 = dataViewMappings; _i < dataViewMappings_1.length; _i++) {\n                    var dataViewMapping = dataViewMappings_1[_i];\n                    // Get dataview specified in mappings which are also in dataview\n                    for (var dataViewMappingProp in dataViewMapping) {\n                        if (dataview[dataViewMappingProp] != null)\n                            usedMappings[dataViewMappingProp] = true;\n                    }\n                }\n                if (usedMappings['categorical'])\n                    filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\n                if (usedMappings['table'])\n                    filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\n                if (usedMappings['tree'])\n                    filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\n                if (usedMappings['matrix'])\n                    filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\n                if (usedMappings['single'])\n                    filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\n            }\n            DataViewNormalizeValues.filterVariantMeasures = filterVariantMeasures;\n            function generateMetadataColumnFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return false; };\n                var columnsToNormalize = {};\n                for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {\n                    var column = columns_2[_i];\n                    var roles = column.roles;\n                    if (!roles)\n                        continue;\n                    for (var _a = 0, rolesToNormalize_1 = rolesToNormalize; _a < rolesToNormalize_1.length; _a++) {\n                        var role = rolesToNormalize_1[_a];\n                        if (!roles[role.name])\n                            continue;\n                        columnsToNormalize[column.index] = true;\n                        break;\n                    }\n                }\n                return function (columnIndex) {\n                    if (isNaN(columnIndex))\n                        return false;\n                    return !!columnsToNormalize[columnIndex];\n                };\n            }\n            DataViewNormalizeValues.generateMetadataColumnFilter = generateMetadataColumnFilter;\n            function generateValueFilter(columns, rolesToNormalize) {\n                if (!columns || !rolesToNormalize)\n                    return function () { return true; };\n                var columnValueFilters = [];\n                // Build columnValueFilters based on role requiredTypes\n                for (var _i = 0, columns_3 = columns; _i < columns_3.length; _i++) {\n                    var column = columns_3[_i];\n                    var columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\n                    if (columnValueFilter)\n                        columnValueFilters[column.index] = columnValueFilter;\n                }\n                return function (columnIndex, value) {\n                    if (columnValueFilters[columnIndex])\n                        return columnValueFilters[columnIndex](value);\n                    return true;\n                };\n            }\n            DataViewNormalizeValues.generateValueFilter = generateValueFilter;\n            function generateColumnValueFilter(column, rolesToNormalize) {\n                var requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\n                if (_.isEmpty(requiredTypes))\n                    return;\n                return function (value) {\n                    return doesValueMatchTypes(value, requiredTypes);\n                };\n            }\n            function getColumnRequiredTypes(column, rolesToNormalize) {\n                var requiredTypes = [];\n                var columnRoles = column && column.roles;\n                if (!columnRoles)\n                    return requiredTypes;\n                for (var _i = 0, rolesToNormalize_2 = rolesToNormalize; _i < rolesToNormalize_2.length; _i++) {\n                    var role = rolesToNormalize_2[_i];\n                    if (!columnRoles[role.name])\n                        continue;\n                    for (var _a = 0, _b = role.requiredTypes; _a < _b.length; _a++) {\n                        var typeDescriptor = _b[_a];\n                        var type = powerbi.ValueType.fromDescriptor(typeDescriptor);\n                        requiredTypes.push(type);\n                    }\n                }\n                return requiredTypes;\n            }\n            DataViewNormalizeValues.getColumnRequiredTypes = getColumnRequiredTypes;\n            function filterVariantMeasuresCategorical(dataview, columnFilter, valueFilter) {\n                var values = dataview && dataview.values;\n                if (!values)\n                    return;\n                var valuesGrouped = values.grouped();\n                if (!valuesGrouped)\n                    return;\n                for (var _i = 0, valuesGrouped_1 = valuesGrouped; _i < valuesGrouped_1.length; _i++) {\n                    var valueGroup = valuesGrouped_1[_i];\n                    var valuesInGroup = valueGroup.values;\n                    for (var _a = 0, valuesInGroup_1 = valuesInGroup; _a < valuesInGroup_1.length; _a++) {\n                        var valueColumn = valuesInGroup_1[_a];\n                        var columnIndex = valueColumn.source.index;\n                        if (!columnFilter(columnIndex))\n                            continue;\n                        for (var i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\n                            valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\n                        }\n                    }\n                }\n            }\n            function filterVariantMeasuresTable(dataview, columnFilter, valueFilter) {\n                var columns = dataview && dataview.columns;\n                if (!columns)\n                    return;\n                var filteredColumns = [];\n                for (var _i = 0, columns_4 = columns; _i < columns_4.length; _i++) {\n                    var column = columns_4[_i];\n                    if (columnFilter(column.index))\n                        filteredColumns.push(column.index);\n                }\n                var rows = dataview.rows;\n                for (var i = 0, ilen = rows.length; i < ilen; i++) {\n                    for (var _a = 0, filteredColumns_1 = filteredColumns; _a < filteredColumns_1.length; _a++) {\n                        var index = filteredColumns_1[_a];\n                        rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresTreeNode(node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var columnIndex in node.values) {\n                        // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\n                        if (columnFilter(columnIndex)) {\n                            // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\n                            if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\n                                node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', columnIndex, valueFilter);\n                            else\n                                node.values = normalizeVariant(node.values, columnIndex, columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresMatrix(dataview, columnFilter, valueFilter) {\n                var root = dataview && dataview.rows && dataview.rows.root;\n                if (!root)\n                    return;\n                // Recurse into rows.children\n                // e.g. rows.children -> .children -> .children.values\n                filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\n            }\n            function filterVariantMeasuresMatrixRecursive(dataviewMatrix, node, columnFilter, valueFilter) {\n                if (node.values) {\n                    for (var id in node.values) {\n                        // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\n                        var nodeValue = node.values[id];\n                        // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\n                        var valueSourceIndex = nodeValue.valueSourceIndex || 0;\n                        // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\n                        var columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\n                        if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\n                            node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\n                        }\n                    }\n                }\n                else if (node.children) {\n                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {\n                        var child = _a[_i];\n                        filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\n                    }\n                }\n            }\n            function filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter) {\n                if (!dataview.single)\n                    return;\n                var roleNames = [];\n                for (var _i = 0, rolesToNormalize_3 = rolesToNormalize; _i < rolesToNormalize_3.length; _i++) {\n                    var role = rolesToNormalize_3[_i];\n                    if (role.name)\n                        roleNames.push(role.name);\n                }\n                var columns = dataview.metadata.columns;\n                for (var _a = 0, dataViewMappings_2 = dataViewMappings; _a < dataViewMappings_2.length; _a++) {\n                    var dataViewMapping = dataViewMappings_2[_a];\n                    var roleName = dataViewMapping.single.role;\n                    if (roleNames.indexOf(roleName) !== -1) {\n                        var column = firstColumnByRoleName(columns, roleName);\n                        if (column)\n                            dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\n                        return;\n                    }\n                }\n            }\n            function normalizeVariant(object, key, columnIndex, valueFilter) {\n                if (!object)\n                    return;\n                var value = object[key];\n                if (value !== null && !valueFilter(columnIndex, value)) {\n                    object = inheritSingle(object);\n                    object[key] = null;\n                }\n                return object;\n            }\n            DataViewNormalizeValues.normalizeVariant = normalizeVariant;\n            function doesValueMatchTypes(value, types) {\n                for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {\n                    var type = types_1[_i];\n                    if (type.numeric || type.integer)\n                        return typeof (value) === 'number';\n                }\n                return false;\n            }\n            function firstColumnByRoleName(columns, roleName) {\n                for (var _i = 0, columns_5 = columns; _i < columns_5.length; _i++) {\n                    var column = columns_5[_i];\n                    var columnRoles = column && column.roles;\n                    if (columnRoles && columnRoles[roleName])\n                        return column;\n                }\n            }\n        })(DataViewNormalizeValues = data.DataViewNormalizeValues || (data.DataViewNormalizeValues = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewObjects;\n    (function (DataViewObjects) {\n        /** Gets the value of the given object/property pair. */\n        function getValue(objects, propertyId, defaultValue) {\n            debug.assertAnyValue(objects, 'objects');\n            debug.assertValue(propertyId, 'propertyId');\n            if (!objects)\n                return defaultValue;\n            var objectOrMap = objects[propertyId.objectName];\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\n            var object = objectOrMap;\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\n        }\n        DataViewObjects.getValue = getValue;\n        /** Gets an object from objects. */\n        function getObject(objects, objectName, defaultValue) {\n            if (objects && objects[objectName]) {\n                var object = objects[objectName];\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\n                return object;\n            }\n            else {\n                return defaultValue;\n            }\n        }\n        DataViewObjects.getObject = getObject;\n        /** Gets a map of user-defined objects. */\n        function getUserDefinedObjects(objects, objectName) {\n            if (objects && objects[objectName]) {\n                var map = objects[objectName];\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\n                return map;\n            }\n        }\n        DataViewObjects.getUserDefinedObjects = getUserDefinedObjects;\n        /** Gets the solid color from a fill property. */\n        function getFillColor(objects, propertyId, defaultColor) {\n            var value = getValue(objects, propertyId);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObjects.getFillColor = getFillColor;\n        /** Returns true if the given object represents a collection of user-defined objects */\n        function isUserDefined(objectOrMap) {\n            return _.isArray(objectOrMap);\n        }\n        DataViewObjects.isUserDefined = isUserDefined;\n    })(DataViewObjects = powerbi.DataViewObjects || (powerbi.DataViewObjects = {}));\n    var DataViewObject;\n    (function (DataViewObject) {\n        function getValue(object, propertyName, defaultValue) {\n            debug.assertAnyValue(object, 'object');\n            debug.assertValue(propertyName, 'propertyName');\n            if (!object)\n                return defaultValue;\n            var propertyValue = object[propertyName];\n            if (propertyValue === undefined)\n                return defaultValue;\n            return propertyValue;\n        }\n        DataViewObject.getValue = getValue;\n        /** Gets the solid color from a fill property using only a propertyName */\n        function getFillColorByPropertyName(objects, propertyName, defaultColor) {\n            var value = DataViewObject.getValue(objects, propertyName);\n            if (!value || !value.solid)\n                return defaultColor;\n            return value.solid.color;\n        }\n        DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;\n    })(DataViewObject = powerbi.DataViewObject || (powerbi.DataViewObject = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var JsonComparer = jsCommon.JsonComparer;\n        var DataViewObjectDefinitions;\n        (function (DataViewObjectDefinitions) {\n            /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\n            function ensure(defns, objectName, selector) {\n                debug.assertValue(defns, 'defns');\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    defns[objectName] = defnsForObject = [];\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n                var newDefn = {\n                    selector: selector,\n                    properties: {},\n                };\n                defnsForObject.push(newDefn);\n                return newDefn;\n            }\n            DataViewObjectDefinitions.ensure = ensure;\n            function deleteProperty(defns, objectName, selector, propertyName) {\n                debug.assertValue(defns, 'defns');\n                var defn = getObjectDefinition(defns, objectName, selector);\n                if (!defn)\n                    return;\n                DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\n            }\n            DataViewObjectDefinitions.deleteProperty = deleteProperty;\n            function setValue(defns, propertyId, selector, value) {\n                debug.assertValue(defns, 'defns');\n                debug.assertValue(propertyId, 'propertyId');\n                ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\n            }\n            DataViewObjectDefinitions.setValue = setValue;\n            function getValue(defns, propertyId, selector) {\n                var properties = getPropertyContainer(defns, propertyId, selector);\n                if (!properties)\n                    return;\n                return properties[propertyId.propertyName];\n            }\n            DataViewObjectDefinitions.getValue = getValue;\n            function getPropertyContainer(defns, propertyId, selector) {\n                var defn = getObjectDefinition(defns, propertyId.objectName, selector);\n                if (!defn)\n                    return;\n                return defn.properties;\n            }\n            DataViewObjectDefinitions.getPropertyContainer = getPropertyContainer;\n            function getObjectDefinition(defns, objectName, selector) {\n                debug.assertAnyValue(defns, 'defns');\n                debug.assertValue(objectName, 'objectName');\n                debug.assertAnyValue(selector, 'selector');\n                if (!defns)\n                    return;\n                var defnsForObject = defns[objectName];\n                if (!defnsForObject)\n                    return;\n                for (var i = 0, len = defnsForObject.length; i < len; i++) {\n                    var defn = defnsForObject[i];\n                    if (data.Selector.equals(defn.selector, selector))\n                        return defn;\n                }\n            }\n            DataViewObjectDefinitions.getObjectDefinition = getObjectDefinition;\n            function propertiesAreEqual(a, b) {\n                if (a instanceof data.SemanticFilter && b instanceof data.SemanticFilter) {\n                    return data.SemanticFilter.isSameFilter(a, b);\n                }\n                return JsonComparer.equals(a, b);\n            }\n            DataViewObjectDefinitions.propertiesAreEqual = propertiesAreEqual;\n            function allPropertiesAreEqual(a, b) {\n                debug.assertValue(a, 'a');\n                debug.assertValue(b, 'b');\n                if (Object.keys(a).length !== Object.keys(b).length)\n                    return false;\n                for (var property in a) {\n                    if (!propertiesAreEqual(a[property], b[property]))\n                        return false;\n                }\n                return true;\n            }\n            DataViewObjectDefinitions.allPropertiesAreEqual = allPropertiesAreEqual;\n            function encodePropertyValue(value, valueTypeDescriptor) {\n                debug.assertAnyValue(value, 'value');\n                debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\n                if (valueTypeDescriptor.bool) {\n                    if (typeof (value) !== 'boolean')\n                        value = false; // This is fallback, which doesn't really belong here.\n                    return data.SQExprBuilder.boolean(value);\n                }\n                else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\n                    return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.numeric) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                }\n                else if (valueTypeDescriptor.fill) {\n                    if (value) {\n                        return {\n                            solid: { color: data.SQExprBuilder.text(value) }\n                        };\n                    }\n                }\n                else if (valueTypeDescriptor.formatting) {\n                    if (valueTypeDescriptor.formatting.labelDisplayUnits) {\n                        return data.SQExprBuilder.double(+value);\n                    }\n                    else {\n                        return data.SQExprBuilder.text(value);\n                    }\n                }\n                else if (valueTypeDescriptor.enumeration) {\n                    if ($.isNumeric(value))\n                        return data.SQExprBuilder.double(+value);\n                    else\n                        return data.SQExprBuilder.text(value);\n                }\n                else if (valueTypeDescriptor.misc) {\n                    if (value) {\n                        value = data.SQExprBuilder.text(value);\n                    }\n                    else {\n                        value = null;\n                    }\n                }\n                else if (valueTypeDescriptor.image) {\n                    if (value) {\n                        var imageValue = value;\n                        var imageDefinition = {\n                            name: data.SQExprBuilder.text(imageValue.name),\n                            url: data.SQExprBuilder.text(imageValue.url),\n                        };\n                        if (imageValue.scaling)\n                            imageDefinition.scaling = data.SQExprBuilder.text(imageValue.scaling);\n                        return imageDefinition;\n                    }\n                }\n                return value;\n            }\n            DataViewObjectDefinitions.encodePropertyValue = encodePropertyValue;\n            function clone(original) {\n                debug.assertValue(original, 'original');\n                var cloned = {};\n                for (var objectName in original) {\n                    var originalDefns = original[objectName];\n                    if (_.isEmpty(originalDefns))\n                        continue;\n                    var clonedDefns = [];\n                    for (var _i = 0, originalDefns_1 = originalDefns; _i < originalDefns_1.length; _i++) {\n                        var originalDefn = originalDefns_1[_i];\n                        clonedDefns.push({\n                            properties: cloneProperties(originalDefn.properties),\n                            selector: originalDefn.selector,\n                        });\n                    }\n                    cloned[objectName] = clonedDefns;\n                }\n                return cloned;\n            }\n            DataViewObjectDefinitions.clone = clone;\n            function cloneProperties(original) {\n                debug.assertValue(original, 'original');\n                // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\n                return _.clone(original);\n            }\n        })(DataViewObjectDefinitions = data.DataViewObjectDefinitions || (data.DataViewObjectDefinitions = {}));\n        var DataViewObjectDefinition;\n        (function (DataViewObjectDefinition) {\n            function deleteSingleProperty(defn, propertyName) {\n                //note: We decided that delete is acceptable here and that we don't need optimization here\n                delete defn.properties[propertyName];\n            }\n            DataViewObjectDefinition.deleteSingleProperty = deleteSingleProperty;\n        })(DataViewObjectDefinition = data.DataViewObjectDefinition || (data.DataViewObjectDefinition = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectDescriptors;\n        (function (DataViewObjectDescriptors) {\n            /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\n            function findFormatString(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var formattingTypeDesc = powerbi.ValueType.fromDescriptor(propDesc.type).formatting;\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\n                });\n            }\n            DataViewObjectDescriptors.findFormatString = findFormatString;\n            /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\n            function findFilterOutput(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.filter;\n                });\n            }\n            DataViewObjectDescriptors.findFilterOutput = findFilterOutput;\n            /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\n            function findDefaultValue(descriptors) {\n                return findProperty(descriptors, function (propDesc) {\n                    var propType = propDesc.type;\n                    return propType && !!propType.expression && propType.expression.defaultValue;\n                });\n            }\n            DataViewObjectDescriptors.findDefaultValue = findDefaultValue;\n            function findProperty(descriptors, propPredicate) {\n                debug.assertAnyValue(descriptors, 'descriptors');\n                debug.assertAnyValue(propPredicate, 'propPredicate');\n                if (!descriptors)\n                    return;\n                for (var objectName in descriptors) {\n                    var objPropDescs = descriptors[objectName].properties;\n                    for (var propertyName in objPropDescs) {\n                        if (propPredicate(objPropDescs[propertyName])) {\n                            return {\n                                objectName: objectName,\n                                propertyName: propertyName,\n                            };\n                        }\n                    }\n                }\n            }\n        })(DataViewObjectDescriptors = data.DataViewObjectDescriptors || (data.DataViewObjectDescriptors = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n*  Power BI Visualizations\n*\n*  Copyright (c) Microsoft Corporation\n*  All rights reserved.\n *  MIT License\n*\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\n*  in the Software without restriction, including without limitation the rights\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n*  copies of the Software, and to permit persons to whom the Software is\n*  furnished to do so, subject to the following conditions:\n*\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n*\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n*  THE SOFTWARE.\n*/\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewObjectEvaluationUtils;\n        (function (DataViewObjectEvaluationUtils) {\n            function evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var objects;\n                for (var j = 0, jlen = objectDefns.length; j < jlen; j++) {\n                    var objectDefinition = objectDefns[j], objectName = objectDefinition.name;\n                    var evaluatedObject = data.DataViewObjectEvaluator.run(evalContext, objectDescriptors[objectName], objectDefinition.properties);\n                    if (!evaluatedObject)\n                        continue;\n                    if (!objects)\n                        objects = {};\n                    // NOTE: this currently has last-object-wins semantics.\n                    objects[objectName] = evaluatedObject;\n                }\n                return objects;\n            }\n            DataViewObjectEvaluationUtils.evaluateDataViewObjects = evaluateDataViewObjects;\n            function groupObjectsBySelector(objectDefinitions) {\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                var grouped = {\n                    data: [],\n                };\n                if (objectDefinitions) {\n                    for (var objectName in objectDefinitions) {\n                        var objectDefnList = objectDefinitions[objectName];\n                        for (var i = 0, len = objectDefnList.length; i < len; i++) {\n                            var objectDefn = objectDefnList[i];\n                            ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\n                                name: objectName,\n                                properties: objectDefn.properties,\n                            });\n                        }\n                    }\n                }\n                return grouped;\n            }\n            DataViewObjectEvaluationUtils.groupObjectsBySelector = groupObjectsBySelector;\n            function ensureDefinitionListForSelector(grouped, selector) {\n                debug.assertValue(grouped, 'grouped');\n                debug.assertAnyValue(selector, 'selector');\n                if (!selector) {\n                    if (!grouped.metadataOnce)\n                        grouped.metadataOnce = { objects: [] };\n                    return grouped.metadataOnce;\n                }\n                var groupedObjects;\n                if (selector.data) {\n                    groupedObjects = grouped.data;\n                }\n                else if (selector.metadata) {\n                    if (!grouped.metadata)\n                        grouped.metadata = [];\n                    groupedObjects = grouped.metadata;\n                }\n                else if (selector.id) {\n                    if (!grouped.userDefined)\n                        grouped.userDefined = [];\n                    groupedObjects = grouped.userDefined;\n                }\n                debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\n                for (var _i = 0, groupedObjects_1 = groupedObjects; _i < groupedObjects_1.length; _i++) {\n                    var item_1 = groupedObjects_1[_i];\n                    if (data.Selector.equals(selector, item_1.selector))\n                        return item_1;\n                }\n                var item = {\n                    selector: selector,\n                    objects: [],\n                };\n                groupedObjects.push(item);\n                return item;\n            }\n            function addImplicitObjects(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                if (selectTransforms) {\n                    addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                    addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\n                }\n            }\n            DataViewObjectEvaluationUtils.addImplicitObjects = addImplicitObjects;\n            function addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);\n                if (!formatStringProp)\n                    return;\n                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                    var selectTransform = selectTransforms[selectIdx];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyFormatString(objectsForAllSelectors, formatStringProp, selectTransform.queryName, selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\n                }\n            }\n            /** Registers properties for default value, if the properties are not explicitly provided. */\n            function addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {\n                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                var defaultValueProp = data.DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\n                if (!defaultValueProp)\n                    return;\n                for (var _i = 0, selectTransforms_1 = selectTransforms; _i < selectTransforms_1.length; _i++) {\n                    var selectTransform = selectTransforms_1[_i];\n                    if (!selectTransform)\n                        continue;\n                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\n                    applyDefaultValue(objectsForAllSelectors, defaultValueProp, selectTransform.queryName, selectTransform.defaultValue);\n                }\n            }\n            function getColumnFormatForIndex(columns, selectIdx) {\n                for (var columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\n                    var column = columns[columnIdx];\n                    if (!column || column.index !== selectIdx)\n                        continue;\n                    return column.format;\n                }\n            }\n            function applyFormatString(objectsForAllSelectors, formatStringProp, queryName, formatStringValue) {\n                if (!formatStringValue)\n                    return;\n                // There is a format string specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, formatStringProp, { metadata: queryName }, data.SQExprBuilder.text(formatStringValue));\n            }\n            function applyDefaultValue(objectsForAllSelectors, defaultValueProp, queryName, defaultValue) {\n                if (!defaultValue)\n                    return;\n                // There is a default value specified -- apply it as an object property, if there is not already one specified.\n                applyMetadataProperty(objectsForAllSelectors, defaultValueProp, { metadata: queryName }, defaultValue);\n            }\n            function applyMetadataProperty(objectsForAllSelectors, propertyId, selector, value) {\n                var objectDefns;\n                if (selector) {\n                    var metadataObjects = objectsForAllSelectors.metadata;\n                    if (!metadataObjects)\n                        metadataObjects = objectsForAllSelectors.metadata = [];\n                    objectDefns = metadataObjects;\n                }\n                else {\n                    var metadataOnce = objectsForAllSelectors.metadataOnce;\n                    if (!metadataOnce)\n                        metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\n                    objectDefns = [metadataOnce];\n                }\n                var targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\n                var targetObjectDefn;\n                if (targetMetadataObject) {\n                    var targetObjectDefns = targetMetadataObject.objects;\n                    targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\n                    if (targetObjectDefn) {\n                        if (targetObjectDefn.properties[propertyId.propertyName])\n                            return;\n                    }\n                    else {\n                        targetObjectDefn = {\n                            name: propertyId.objectName,\n                            properties: {},\n                        };\n                        targetObjectDefns.push(targetObjectDefn);\n                    }\n                }\n                else {\n                    targetObjectDefn = {\n                        name: propertyId.objectName,\n                        properties: {}\n                    };\n                    objectDefns.push({\n                        selector: selector,\n                        objects: [targetObjectDefn],\n                    });\n                }\n                targetObjectDefn.properties[propertyId.propertyName] = value;\n            }\n            function findWithMatchingSelector(objects, selector) {\n                debug.assertValue(objects, 'objects');\n                debug.assertAnyValue(selector, 'selector');\n                for (var i = 0, len = objects.length; i < len; i++) {\n                    var object = objects[i];\n                    if (data.Selector.equals(object.selector, selector))\n                        return object;\n                }\n            }\n            function findExistingObject(objectDefns, objectName) {\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(objectName, 'objectName');\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefn = objectDefns[i];\n                    if (objectDefn.name === objectName)\n                        return objectDefn;\n                }\n            }\n        })(DataViewObjectEvaluationUtils = data.DataViewObjectEvaluationUtils || (data.DataViewObjectEvaluationUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\n        var DataViewObjectEvaluator;\n        (function (DataViewObjectEvaluator) {\n            var colorValueType = powerbi.ValueType.fromDescriptor({ formatting: { color: true } });\n            var numericType = powerbi.ValueType.fromDescriptor({ numeric: true });\n            var textType = powerbi.ValueType.fromDescriptor({ text: true });\n            function run(evalContext, objectDescriptor, propertyDefinitions) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\n                debug.assertValue(propertyDefinitions, 'propertyDefinitions');\n                if (!objectDescriptor)\n                    return;\n                var object, propertyDescriptors = objectDescriptor.properties;\n                for (var propertyName in propertyDefinitions) {\n                    var propertyDefinition = propertyDefinitions[propertyName], propertyDescriptor = propertyDescriptors[propertyName];\n                    if (!propertyDescriptor)\n                        continue;\n                    var propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\n                    if (propertyValue === undefined)\n                        continue;\n                    if (!object)\n                        object = {};\n                    object[propertyName] = propertyValue;\n                }\n                return object;\n            }\n            DataViewObjectEvaluator.run = run;\n            /** Note: Exported for testability */\n            function evaluateProperty(evalContext, propertyDescriptor, propertyDefinition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(propertyDescriptor, 'propertyDescriptor');\n                debug.assertValue(propertyDefinition, 'propertyDefinition');\n                var structuralType = propertyDescriptor.type;\n                if (structuralType && structuralType.expression)\n                    return propertyDefinition;\n                var value = evaluateValue(evalContext, propertyDefinition, powerbi.ValueType.fromDescriptor(propertyDescriptor.type));\n                if (value !== undefined || (propertyDefinition instanceof data.RuleEvaluation))\n                    return value;\n                return evaluateFill(evalContext, propertyDefinition, structuralType)\n                    || evaluateFillRule(evalContext, propertyDefinition, structuralType)\n                    || evaluateImage(evalContext, propertyDefinition, structuralType)\n                    || evaluateParagraphs(evalContext, propertyDefinition, structuralType)\n                    || propertyDefinition;\n            }\n            DataViewObjectEvaluator.evaluateProperty = evaluateProperty;\n            function evaluateFill(evalContext, fillDefn, type) {\n                var fillType = type.fill;\n                if (!fillType)\n                    return;\n                if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\n                    return {\n                        solid: {\n                            color: evaluateValue(evalContext, fillDefn.solid.color, powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Color)),\n                        }\n                    };\n                }\n            }\n            function evaluateFillRule(evalContext, fillRuleDefn, type) {\n                if (!type.fillRule)\n                    return;\n                if (fillRuleDefn.linearGradient2) {\n                    var linearGradient2 = fillRuleDefn.linearGradient2;\n                    return {\n                        linearGradient2: {\n                            min: evaluateColorStop(evalContext, linearGradient2.min),\n                            max: evaluateColorStop(evalContext, linearGradient2.max),\n                        }\n                    };\n                }\n                if (fillRuleDefn.linearGradient3) {\n                    var linearGradient3 = fillRuleDefn.linearGradient3;\n                    return {\n                        linearGradient3: {\n                            min: evaluateColorStop(evalContext, linearGradient3.min),\n                            mid: evaluateColorStop(evalContext, linearGradient3.mid),\n                            max: evaluateColorStop(evalContext, linearGradient3.max),\n                        }\n                    };\n                }\n            }\n            function evaluateColorStop(evalContext, colorStop) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(colorStop, 'colorStop');\n                var step = {\n                    color: evaluateValue(evalContext, colorStop.color, colorValueType),\n                };\n                var value = evaluateValue(evalContext, colorStop.value, numericType);\n                if (value != null)\n                    step.value = value;\n                return step;\n            }\n            function evaluateImage(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.image || !definition)\n                    return;\n                var value = {\n                    name: evaluateValue(evalContext, definition.name, textType),\n                    url: evaluateValue(evalContext, definition.url, powerbi.ValueType.fromDescriptor(powerbi.ImageDefinition.urlType)),\n                };\n                if (definition.scaling)\n                    value.scaling = evaluateValue(evalContext, definition.scaling, textType);\n                return value;\n            }\n            function evaluateParagraphs(evalContext, definition, type) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertAnyValue(definition, 'definition');\n                debug.assertValue(type, 'type');\n                if (!type.paragraphs || !definition)\n                    return;\n                return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\n            }\n            function evaluateParagraph(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionTextRuns = definition.textRuns;\n                var evaluatedTextRuns = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\n                if (definitionTextRuns !== evaluatedTextRuns) {\n                    evaluated = _.clone(definition);\n                    evaluated.textRuns = evaluatedTextRuns;\n                }\n                return evaluated || definition;\n            }\n            function evaluateTextRun(evalContext, definition) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definition, 'definition');\n                var evaluated;\n                var definitionValue = definition.value;\n                var evaluatedValue = evaluateValue(evalContext, definitionValue, textType);\n                if (evaluatedValue !== undefined) {\n                    evaluated = _.clone(definition);\n                    evaluated.value = evaluatedValue;\n                }\n                return evaluated || definition;\n            }\n            /**\n             * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\n             * other than the input to it.\n             */\n            function evaluateArrayCopyOnChange(evalContext, definitions, evaluator) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(definitions, 'definitions');\n                debug.assertValue(evaluator, 'evaluator');\n                var evaluatedValues;\n                for (var i = 0, len = definitions.length; i < len; i++) {\n                    var definition = definitions[i];\n                    var evaluated = evaluator(evalContext, definition);\n                    // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\n                    // between TEvaluated & TDefinition\n                    if (!evaluatedValues && definition !== evaluated) {\n                        evaluatedValues = _.take(definitions, i);\n                    }\n                    if (evaluatedValues) {\n                        evaluatedValues.push(evaluated);\n                    }\n                }\n                return evaluatedValues || definitions;\n            }\n            function evaluateValue(evalContext, definition, valueType) {\n                if (definition instanceof data.SQExpr)\n                    return ExpressionEvaluator.evaluate(definition, evalContext);\n                if (definition instanceof data.RuleEvaluation)\n                    return definition.evaluate(evalContext);\n            }\n            /** Responsible for evaluating SQExprs into values. */\n            var ExpressionEvaluator = (function (_super) {\n                __extends(ExpressionEvaluator, _super);\n                function ExpressionEvaluator() {\n                    _super.apply(this, arguments);\n                }\n                ExpressionEvaluator.evaluate = function (expr, evalContext) {\n                    if (expr == null)\n                        return;\n                    return expr.accept(ExpressionEvaluator.instance, evalContext);\n                };\n                ExpressionEvaluator.prototype.visitColumnRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitConstant = function (expr, evalContext) {\n                    return expr.value;\n                };\n                ExpressionEvaluator.prototype.visitMeasureRef = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitAggr = function (expr, evalContext) {\n                    return evalContext.getExprValue(expr);\n                };\n                ExpressionEvaluator.prototype.visitFillRule = function (expr, evalContext) {\n                    var inputValue = expr.input.accept(this, evalContext);\n                    if (inputValue !== undefined) {\n                        var colorAllocator = evalContext.getColorAllocator(expr);\n                        if (colorAllocator) {\n                            return colorAllocator.color(inputValue);\n                        }\n                    }\n                };\n                ExpressionEvaluator.instance = new ExpressionEvaluator();\n                return ExpressionEvaluator;\n            }(data.DefaultSQExprVisitorWithArg));\n        })(DataViewObjectEvaluator = data.DataViewObjectEvaluator || (data.DataViewObjectEvaluator = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var DataViewPivotCategorical;\n        (function (DataViewPivotCategorical) {\n            /**\n             * Pivots categories in a categorical DataView into valueGroupings.\n             * This is akin to a mathematical matrix transpose.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                var categorical = dataView.categorical;\n                if (!categorical)\n                    return null;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return null;\n                var values = categorical.values;\n                if (_.isEmpty(values) || values.source)\n                    return null;\n                var category = categories[0], categoryIdentities = category.identity, categoryValues = category.values, pivotedColumns = [], pivotedValues = [];\n                for (var rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\n                    var categoryValue = categoryValues[rowIdx], categoryIdentity = categoryIdentities[rowIdx];\n                    for (var colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\n                        var value = values[colIdx], pivotedColumn = inherit(value.source);\n                        // A value has a series group, which is not implemented for pivoting -- just give up.\n                        if (value.identity)\n                            return null;\n                        pivotedColumn.groupName = categoryValue;\n                        var pivotedValue = {\n                            source: pivotedColumn,\n                            values: [value.values[rowIdx]],\n                            identity: categoryIdentity,\n                            min: value.min,\n                            max: value.max,\n                            subtotal: value.subtotal\n                        };\n                        var highlights = value.highlights;\n                        if (highlights) {\n                            pivotedValue.highlights = [highlights[rowIdx]];\n                        }\n                        pivotedColumns.push(pivotedColumn);\n                        pivotedValues.push(pivotedValue);\n                    }\n                }\n                var pivotedMetadata = inherit(dataView.metadata);\n                pivotedMetadata.columns = pivotedColumns;\n                values = data.DataViewTransform.createValueColumns(pivotedValues, category.identityFields, category.source);\n                return {\n                    metadata: pivotedMetadata,\n                    categorical: {\n                        values: values,\n                    },\n                    matrix: dataView.matrix\n                };\n            }\n            DataViewPivotCategorical.apply = apply;\n        })(DataViewPivotCategorical = data.DataViewPivotCategorical || (data.DataViewPivotCategorical = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewPivotMatrix;\n        (function (DataViewPivotMatrix) {\n            /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\n            function apply(dataViewMatrix, context) {\n                debug.assertValue(dataViewMatrix, 'dataViewMatrix');\n                if (!context.columnHierarchyRewritten)\n                    dataViewMatrix.columns = powerbi.Prototype.inherit(dataViewMatrix.columns);\n                var columns = dataViewMatrix.columns;\n                if (!context.rowHierarchyRewritten)\n                    dataViewMatrix.rows = powerbi.Prototype.inherit(dataViewMatrix.rows);\n                var rows = dataViewMatrix.rows;\n                if (columns.levels.length > 1)\n                    return;\n                var pivotedRowNode = {\n                    level: 0\n                };\n                var columnLeafNodes = columns.root.children;\n                var measureCount = columnLeafNodes.length;\n                // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\n                // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\n                // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \n                // in a matrix with 2+ column fields and 2+ measure fields.\n                // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\n                // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\n                var pivotResultMeasureHeaderLevel = rows.levels.length;\n                if (measureCount > 0) {\n                    var index_1 = 0;\n                    var callback = function (node) {\n                        // Collect values and remove them from row leaves\n                        if (node.values) {\n                            if (!pivotedRowNode.values)\n                                pivotedRowNode.values = {};\n                            for (var i = 0; i < measureCount; i++)\n                                pivotedRowNode.values[index_1++] = node.values[i];\n                            delete node.values;\n                        }\n                        // Create measure headers if there are more than one measures\n                        if (measureCount > 1) {\n                            if (!node.children)\n                                node.children = [];\n                            for (var j = 0; j < measureCount; j++) {\n                                var measureHeaderLeaf = { level: pivotResultMeasureHeaderLevel };\n                                // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\n                                var columnLeafNode = columnLeafNodes[j];\n                                measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\n                                if (node.isSubtotal)\n                                    measureHeaderLeaf.isSubtotal = true;\n                                node.children.push(measureHeaderLeaf);\n                            }\n                        }\n                    };\n                    if (context.hierarchyTreesRewritten) {\n                        forEachLeaf(rows.root, callback);\n                    }\n                    else {\n                        dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\n                    }\n                }\n                else {\n                    if (!context.hierarchyTreesRewritten) {\n                        dataViewMatrix.columns.root = cloneTree(rows.root);\n                    }\n                }\n                if (measureCount > 1) {\n                    // Keep measure headers, but move them to the innermost level\n                    var level = { sources: columns.levels[0].sources };\n                    rows.levels.push(level);\n                    columns.levels.length = 0;\n                }\n                if (context.hierarchyTreesRewritten) {\n                    dataViewMatrix.columns.root = rows.root;\n                    dataViewMatrix.rows.root = {\n                        children: [pivotedRowNode]\n                    };\n                }\n                else {\n                    var updatedRowRoot = powerbi.Prototype.inherit(dataViewMatrix.rows.root);\n                    updatedRowRoot.children = [pivotedRowNode];\n                    dataViewMatrix.rows.root = updatedRowRoot;\n                }\n                dataViewMatrix.columns.levels = rows.levels;\n                dataViewMatrix.rows.levels = [];\n            }\n            DataViewPivotMatrix.apply = apply;\n            function forEachLeaf(root, callback) {\n                var children = root.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachLeaf(children[i], callback);\n                    return;\n                }\n                callback(root);\n            }\n            function cloneTree(node) {\n                return cloneTreeExecuteOnLeaf(node);\n            }\n            DataViewPivotMatrix.cloneTree = cloneTree;\n            function cloneTreeExecuteOnLeaf(node, callback) {\n                var updatedNode = powerbi.Prototype.inherit(node);\n                var children = node.children;\n                if (children && children.length > 0) {\n                    var newChildren = [];\n                    for (var i = 0, ilen = children.length; i < ilen; i++) {\n                        var updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\n                        newChildren.push(updatedChild);\n                    }\n                    updatedNode.children = newChildren;\n                }\n                else {\n                    if (callback)\n                        callback(updatedNode);\n                }\n                return updatedNode;\n            }\n            DataViewPivotMatrix.cloneTreeExecuteOnLeaf = cloneTreeExecuteOnLeaf;\n        })(DataViewPivotMatrix = data.DataViewPivotMatrix || (data.DataViewPivotMatrix = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelfCrossJoin;\n        (function (DataViewSelfCrossJoin) {\n            /**\n             * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\n             * to itself as a value grouping.\n             * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\n             */\n            function apply(dataView) {\n                debug.assertValue(dataView, 'dataView');\n                if (!dataView.categorical)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\n                    return;\n                if (dataViewCategorical.values && dataViewCategorical.values.source)\n                    return;\n                return applyCategorical(dataView.metadata, dataViewCategorical);\n            }\n            DataViewSelfCrossJoin.apply = apply;\n            function applyCategorical(dataViewMetadata, dataViewCategorical) {\n                debug.assertValue(dataViewMetadata, 'dataViewMetadata');\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\n                var category = dataViewCategorical.categories[0], categoryValues = category.values, categoryLength = categoryValues.length;\n                if (categoryLength === 0)\n                    return;\n                var valuesArray = dataViewCategorical.values\n                    ? dataViewCategorical.values.grouped()[0].values\n                    : [];\n                var transformedDataView = data.createCategoricalDataViewBuilder()\n                    .withCategories(dataViewCategorical.categories)\n                    .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\n                    .build();\n                dataViewMetadata = powerbi.Prototype.inherit(dataViewMetadata);\n                dataViewMetadata.columns = transformedDataView.metadata.columns;\n                return {\n                    metadata: dataViewMetadata,\n                    categorical: transformedDataView.categorical,\n                };\n            }\n            function createGroupedValues(category, categoryValues, categoryLength, valuesArray) {\n                debug.assertValue(category, 'category');\n                debug.assertValue(categoryValues, 'categoryValues');\n                debug.assertValue(categoryLength, 'categoryLength');\n                debug.assertValue(valuesArray, 'valuesArray');\n                var nullValuesArray = createNullValues(categoryLength), valuesArrayLen = valuesArray.length, seriesData = [];\n                for (var i = 0; i < categoryLength; i++) {\n                    var seriesDataItem = [];\n                    for (var j = 0; j < valuesArrayLen; j++) {\n                        var originalValueColumn = valuesArray[j], originalHighlightValues = originalValueColumn.highlights;\n                        var seriesDataItemCategory = {\n                            values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\n                        };\n                        if (originalHighlightValues)\n                            seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\n                        seriesDataItem.push(seriesDataItemCategory);\n                    }\n                    seriesData.push(seriesDataItem);\n                }\n                return {\n                    groupColumn: {\n                        source: category.source,\n                        identityFrom: { fields: category.identityFields, identities: category.identity },\n                        values: category.values,\n                    },\n                    valueColumns: _.map(valuesArray, function (v) { return { source: v.source }; }),\n                    data: seriesData,\n                };\n            }\n        })(DataViewSelfCrossJoin = data.DataViewSelfCrossJoin || (data.DataViewSelfCrossJoin = {}));\n        function createNullValues(length) {\n            debug.assertValue(length, 'length');\n            var array = new Array(length);\n            for (var i = 0; i < length; i++)\n                array[i] = null;\n            return array;\n        }\n        function inheritArrayWithValue(nullValues, original, index) {\n            var inherited = powerbi.Prototype.inherit(nullValues);\n            inherited[index] = original[index];\n            return inherited;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var DataViewPivotCategoricalToPrimaryGroups;\n        (function (DataViewPivotCategoricalToPrimaryGroups) {\n            /**\n             * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\n             * pivot the secondary before the primary.\n             */\n            function pivotBinding(binding, allMappings, finalMapping, defaultDataVolume) {\n                // unpivot is inferred from result in DataViewTransform.apply but it does not have the\n                // compiled mappings available, let alone the merged mapping, only the original\n                // DataViewMappings. to keep that inference easy, only apply pivot when there's\n                // only one matching mapping\n                if (!allMappings || allMappings.length !== 1)\n                    return;\n                if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\n                    return;\n                if (!binding)\n                    return;\n                if (!canPivotCategorical(binding, finalMapping))\n                    return;\n                // pivot secondary onto front of primary\n                binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\n                binding.Secondary = undefined;\n                // set primary to pivot reduction\n                binding.DataReduction = {\n                    Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\n                    DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\n                };\n            }\n            DataViewPivotCategoricalToPrimaryGroups.pivotBinding = pivotBinding;\n            /** narrowly targets scatter chart scenario for now to keep code simple */\n            function isPivotableAxis(axis) {\n                return axis\n                    && axis.Groupings\n                    && axis.Groupings.length === 1\n                    && !_.isEmpty(axis.Groupings[0].Projections)\n                    && !axis.Groupings[0].Subtotal\n                    && _.isEmpty(axis.Groupings[0].SuppressedProjections);\n            }\n            function canPivotCategorical(binding, mapping) {\n                if (!isPivotableAxis(binding.Primary))\n                    return false;\n                if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\n                    return false;\n                // don't pivot if either axis has a data reduction\n                if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\n                    return false;\n                return true;\n            }\n            function unpivotResult(oldDataView, selects, dataViewMappings, projectionActiveItems) {\n                if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\n                    return oldDataView;\n                // This returns a subsetted version of the DataView rather than using prototypal inheritance because\n                // any dataviews in the old one (including ones invented after this code is written) will correspond\n                // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\n                // querying code made.\n                var newDataView = {\n                    metadata: {\n                        columns: ArrayExtensions.copy(oldDataView.metadata.columns),\n                    },\n                };\n                // preserve view types that aren't affected by pivoting\n                if (oldDataView.single)\n                    newDataView.single = oldDataView.single;\n                if (oldDataView.table)\n                    newDataView.table = oldDataView.table;\n                // other views are derived from matrix\n                if (oldDataView.matrix) {\n                    var newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\n                    // categorical only if there's data\n                    if (!_.isEmpty(newDataViewMatrix.valueSources)) {\n                        // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \n                        // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\n                        // this.canPivotCategorical() would have returned false in the first place for this query.\n                        var hasCompositeGroupInSeries = data.utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\n                        if (!hasCompositeGroupInSeries) {\n                            newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\n                        }\n                    }\n                }\n                return newDataView;\n            }\n            DataViewPivotCategoricalToPrimaryGroups.unpivotResult = unpivotResult;\n            /**\n             * Infer from the query result and the visual mappings whether the query was pivoted.\n             * Narrowly targets scatter chart scenario for now to keep code simple\n             */\n            function inferUnpivotTransform(selects, dataViewMappings, dataView, projectionActiveItems) {\n                if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\n                    return false;\n                // select applicable mappings based on select roles\n                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\n                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\n                var supportedDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\n                // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\n                if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\n                    return false;\n                var categoricalMapping = supportedDataViewMappings[0].categorical;\n                if (!categoricalMapping)\n                    return false;\n                // pivoted query will have produced a matrix\n                var matrixDataview = dataView.matrix;\n                if (!matrixDataview)\n                    return false;\n                // matrix must have two levels of grouping\n                if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\n                    return false;\n                // get category and value grouping roles\n                var categoryGroups = [];\n                var valueGroups = [];\n                var addGroupingRole = function (roleName, groups) {\n                    var roleProjections = projections[roleName];\n                    if (!roleProjections)\n                        return;\n                    for (var _i = 0, _a = roleProjections.all(); _i < _a.length; _i++) {\n                        var roleProjection = _a[_i];\n                        if (roleKinds[roleProjection.queryRef] === powerbi.VisualDataRoleKind.Grouping)\n                            groups.push(roleProjection.queryRef);\n                    }\n                };\n                powerbi.DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, categoryGroups); }\n                });\n                powerbi.DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\n                    visitRole: function (roleName) { addGroupingRole(roleName, valueGroups); }\n                });\n                // need both for pivot to have been done\n                if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\n                    return false;\n                // if there was a pivot, there won't be any measures left in the columns\n                for (var _i = 0, _a = matrixDataview.columns.levels; _i < _a.length; _i++) {\n                    var level = _a[_i];\n                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {\n                        var source = _c[_b];\n                        if (!source.isMeasure)\n                            return false;\n                    }\n                }\n                return true;\n            }\n            /**\n             * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\n             * this function changes that so that the categories become the rows and the series the columns.\n             */\n            function unpivotMatrix(oldMatrix) {\n                var oldRows = oldMatrix.rows;\n                var oldRoot = oldRows.root;\n                var oldChildren = oldRoot.children;\n                // series are the outer grouping\n                var series = [];\n                var seriesIdLevel = oldRows.levels[0];\n                var seriesIdFields = oldRoot.childIdentityFields;\n                // categories are the inner grouping. \n                var categoryIndex = {};\n                var categories = [];\n                var categoryIdLevel = oldRows.levels[1];\n                var categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\n                var measureCount = oldMatrix.valueSources.length;\n                // within each series value, the category list may not be complete so cannot simply use the inner loop index\n                // to reference it.\n                var findCategory = function (identity) {\n                    var index = categoryIndex[identity.key];\n                    debug.assert(index !== undefined, \"findcat() !== undefined\");\n                    return index;\n                };\n                // collect series and categories from the row hierarchy\n                if (oldChildren) {\n                    var addCategory = function (categoryNode) {\n                        var key = categoryNode.identity.key;\n                        var index = categoryIndex[key];\n                        if (index === undefined) {\n                            index = categories.length;\n                            categoryIndex[key] = index;\n                            categories.push(categoryNode);\n                        }\n                    };\n                    for (var _i = 0, oldChildren_1 = oldChildren; _i < oldChildren_1.length; _i++) {\n                        var seriesNode = oldChildren_1[_i];\n                        series.push(seriesNode);\n                        for (var _a = 0, _b = seriesNode.children; _a < _b.length; _a++) {\n                            var categoryNode = _b[_a];\n                            addCategory(categoryNode);\n                        }\n                    }\n                }\n                // extract intersection values from pivoted matrix\n                // values will be indexed by categories then series\n                var matrixValues = new Array(categories.length);\n                for (var j = 0; j < series.length; ++j) {\n                    var seriesNode = oldChildren[j];\n                    for (var _c = 0, _d = seriesNode.children; _c < _d.length; _c++) {\n                        var categoryNode = _d[_c];\n                        var i = findCategory(categoryNode.identity); // must lookup actual category index\n                        if (!matrixValues[i])\n                            matrixValues[i] = new Array(series.length);\n                        matrixValues[i][j] = categoryNode.values;\n                    }\n                }\n                // columns of the unpivoted matrix are the series\n                var newColumns = {\n                    root: {\n                        children: _.map(series, function (s) {\n                            var inheritedNode = inheritSingle(s);\n                            inheritedNode.level = 0; // s.level should already be 0, but just in case...\n                            inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\n                            inheritedNode.childIdentityFields = undefined;\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: seriesIdFields,\n                    },\n                    levels: [\n                        seriesIdLevel,\n                    ],\n                };\n                // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\n                if (measureCount > 0) {\n                    var newColChildren = _.map(oldMatrix.columns.root.children, function (srcnode) {\n                        var dstnode = { level: 1 };\n                        if (srcnode.levelSourceIndex)\n                            dstnode.levelSourceIndex = srcnode.levelSourceIndex;\n                        return dstnode;\n                    });\n                    for (var i = 0; i < newColumns.root.children.length; ++i)\n                        newColumns.root.children[i].children = newColChildren;\n                    newColumns.levels.push(oldMatrix.columns.levels[0]);\n                }\n                // rows of the unpivoted matrix are the categories\n                var newRows = {\n                    root: {\n                        children: _.map(categories, function (c) {\n                            var inheritedNode = inheritSingle(c);\n                            inheritedNode.level = 0;\n                            inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\n                            inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\n                            return inheritedNode;\n                        }),\n                        childIdentityFields: categoryIdFields,\n                    },\n                    levels: [\n                        categoryIdLevel,\n                    ],\n                };\n                // put values into rows\n                if (measureCount > 0) {\n                    for (var i = 0; i < categories.length; ++i) {\n                        var row = newRows.root.children[i];\n                        var rowValues = {};\n                        for (var j = 0; j < series.length; ++j) {\n                            var mvalues = matrixValues[i] && matrixValues[i][j];\n                            for (var k = 0; k < measureCount; ++k) {\n                                var l = j * measureCount + k;\n                                rowValues[l] = !mvalues\n                                    ? (k === 0 ? { value: null } : { value: null, valueSourceIndex: k })\n                                    : mvalues[k];\n                            }\n                        }\n                        row.values = rowValues;\n                    }\n                }\n                var newMatrix = {\n                    rows: newRows,\n                    columns: newColumns,\n                    valueSources: oldMatrix.valueSources,\n                };\n                return newMatrix;\n            }\n            /** build a categorical data view from an unpivoted matrix. */\n            function categoricalFromUnpivotedMatrix(matrix, columnMetadata) {\n                var seriesCount = matrix.columns.root.children.length;\n                var measureMetadata = matrix.valueSources;\n                var measureCount = measureMetadata.length;\n                var categories = createCategoryColumnsFromUnpivotedMatrix(matrix);\n                // create grouped values\n                var groups = [];\n                for (var j = 0; j < seriesCount; ++j) {\n                    var seriesColumn = matrix.columns.root.children[j];\n                    var group = {\n                        values: [],\n                        identity: seriesColumn.identity,\n                        name: seriesColumn.value || null,\n                    };\n                    groups.push(group);\n                    for (var k = 0; k < measureCount; ++k) {\n                        var valueColumnMetadataSrc = measureMetadata[k];\n                        var valueColumnMetadataDst = {};\n                        for (var key in valueColumnMetadataSrc)\n                            valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\n                        valueColumnMetadataDst.groupName = group.name;\n                        columnMetadata.push(valueColumnMetadataDst);\n                        var valueColumn = {\n                            source: valueColumnMetadataDst,\n                            values: [],\n                            identity: group.identity,\n                        };\n                        group.values.push(valueColumn);\n                        // grab measure values in the group from across rows of matrix\n                        var index = k + j * measureCount;\n                        for (var _i = 0, _a = matrix.rows.root.children; _i < _a.length; _i++) {\n                            var categoryNode = _a[_i];\n                            var value = categoryNode.values[index].value;\n                            valueColumn.values.push(value);\n                        }\n                    }\n                }\n                // and now ungrouped\n                var values = [];\n                for (var _b = 0, groups_1 = groups; _b < groups_1.length; _b++) {\n                    var group = groups_1[_b];\n                    for (var k = 0; k < measureCount; ++k) {\n                        values.push(group.values[k]);\n                    }\n                }\n                values.grouped = function () { return groups; };\n                values.identityFields = matrix.columns.root.childIdentityFields;\n                values.source = matrix.columns.levels[0].sources[0];\n                // final assembly\n                var categorical = {\n                    categories: categories,\n                    values: values,\n                };\n                return categorical;\n            }\n            function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix) {\n                debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\n                debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1), 'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\n                // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \n                // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \n                // same amongst the resulting DataViewCategoryColumns.\n                var categoryIdentity = _.map(unpivotedMatrix.rows.root.children, function (x) { return x.identity; });\n                var categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\n                var categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\n                var categories = [];\n                for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\n                    var groupLevelValues = _.map(unpivotedMatrix.rows.root.children, function (categoryNode) {\n                        var levelValues = categoryNode.levelValues;\n                        // Please refer to the interface comments on when this is undefined... But in today's code\n                        // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \n                        if (levelValues !== undefined) {\n                            debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i), 'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\n                            return levelValues[i].value;\n                        }\n                    });\n                    categories.push({\n                        source: categorySourceColumns[i],\n                        values: groupLevelValues,\n                        identity: categoryIdentity,\n                        identityFields: categoryIdentityFields,\n                    });\n                }\n                return categories;\n            }\n        })(DataViewPivotCategoricalToPrimaryGroups = data.DataViewPivotCategoricalToPrimaryGroups || (data.DataViewPivotCategoricalToPrimaryGroups = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var inherit = powerbi.Prototype.inherit;\n        var inheritSingle = powerbi.Prototype.inheritSingle;\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var EnumExtensions = jsCommon.EnumExtensions;\n        // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\n        var DataViewTransform;\n        (function (DataViewTransform) {\n            var fillRulePropertyDescriptor = { type: { fillRule: {} } };\n            function apply(options) {\n                debug.assertValue(options, 'options');\n                // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\n                var prototype = options.prototype, objectDescriptors = options.objectDescriptors, dataViewMappings = options.dataViewMappings, transforms = options.transforms, projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems, colorAllocatorFactory = options.colorAllocatorFactory, dataRoles = options.dataRoles;\n                if (!prototype)\n                    return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\n                if (!transforms)\n                    return [prototype];\n                // Transform Query DataView\n                prototype = data.DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\n                var visualDataViews = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\n                // Transform and generate derived visual DataViews\n                visualDataViews = data.DataViewRegression.run({\n                    dataViewMappings: dataViewMappings,\n                    visualDataViews: visualDataViews,\n                    dataRoles: dataRoles,\n                    objectDescriptors: objectDescriptors,\n                    objectDefinitions: transforms.objects,\n                    colorAllocatorFactory: colorAllocatorFactory,\n                    transformSelects: transforms.selects,\n                    metadata: prototype.metadata,\n                    projectionActiveItems: projectionActiveItems,\n                });\n                return visualDataViews;\n            }\n            DataViewTransform.apply = apply;\n            function transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles) {\n                var transformedDataViews = [];\n                var splits = transforms.splits;\n                if (_.isEmpty(splits)) {\n                    transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\n                }\n                else {\n                    for (var _i = 0, splits_1 = splits; _i < splits_1.length; _i++) {\n                        var split = splits_1[_i];\n                        var transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\n                        transformedDataViews.push(transformed);\n                    }\n                }\n                return transformedDataViews;\n            }\n            function transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory) {\n                if (transforms && transforms.objects) {\n                    var emptyDataView = {\n                        metadata: {\n                            columns: [],\n                        }\n                    };\n                    transformObjects(emptyDataView, 0 /* None */, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                    return [emptyDataView];\n                }\n                return [];\n            }\n            function transformDataView(prototype, objectDescriptors, roleMappings, transforms, colorAllocatorFactory, dataRoles, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(transforms, 'transforms');\n                debug.assert(!selectsToInclude ||\n                    _.filter(Object.keys(selectsToInclude), function (selectIndex) { return selectsToInclude[selectIndex] && (!transforms.selects || !transforms.selects[selectIndex]); })\n                        .length === 0, // asserts that the number of select indices in selectsToInclude without a corresponding Select Transform === 0\n                'If selectsToInclude is specified, every Select Index in it must have a corresponding Select Transform.');\n                var targetKinds = getTargetKinds(roleMappings);\n                var transformed = inherit(prototype);\n                transformed.metadata = inherit(prototype.metadata);\n                var projectionOrdering = transforms.roles && transforms.roles.ordering;\n                var projectionActiveItems = transforms.roles && transforms.roles.activeItems;\n                transformed = transformSelects(transformed, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\n                transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\n                // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\n                transformed = data.DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\n                data.DataViewNormalizeValues.apply({\n                    dataview: transformed,\n                    dataViewMappings: roleMappings,\n                    dataRoles: dataRoles,\n                });\n                return transformed;\n            }\n            function getTargetKinds(roleMappings) {\n                debug.assertAnyValue(roleMappings, 'roleMappings');\n                if (!roleMappings)\n                    return 0 /* None */;\n                var result = 0 /* None */;\n                for (var _i = 0, roleMappings_1 = roleMappings; _i < roleMappings_1.length; _i++) {\n                    var roleMapping = roleMappings_1[_i];\n                    if (roleMapping.categorical)\n                        result |= 1 /* Categorical */;\n                    if (roleMapping.matrix)\n                        result |= 2 /* Matrix */;\n                    if (roleMapping.single)\n                        result |= 4 /* Single */;\n                    if (roleMapping.table)\n                        result |= 8 /* Table */;\n                    if (roleMapping.tree)\n                        result |= 16 /* Tree */;\n                }\n                return result;\n            }\n            function transformSelects(dataView, roleMappings, selectTransforms, projectionOrdering, selectsToInclude) {\n                var columnRewrites = [];\n                if (selectTransforms) {\n                    dataView.metadata.columns = applyTransformsToColumns(dataView.metadata.columns, selectTransforms, columnRewrites);\n                }\n                // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\n                if (dataView.categorical) {\n                    dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    // NOTE: This is slightly DSR-specific.\n                    dataView = pivotIfNecessary(dataView, roleMappings);\n                }\n                if (dataView.matrix) {\n                    var matrixTransformationContext = {\n                        rowHierarchyRewritten: false,\n                        columnHierarchyRewritten: false,\n                        hierarchyTreesRewritten: false\n                    };\n                    dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\n                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\n                    if (shouldPivotMatrix(dataView.matrix, roleMappings))\n                        data.DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\n                }\n                if (dataView.table)\n                    dataView.table = applyRewritesToTable(dataView.table, columnRewrites, roleMappings, projectionOrdering);\n                return dataView;\n            }\n            function applyTransformsToColumns(prototypeColumns, selects, rewrites) {\n                debug.assertValue(prototypeColumns, 'columns');\n                if (!selects)\n                    return prototypeColumns;\n                //column may contain undefined entries\n                var columns = inherit(prototypeColumns);\n                for (var i = 0, len = prototypeColumns.length; i < len; i++) {\n                    var prototypeColumn = prototypeColumns[i];\n                    var select = selects[prototypeColumn.index];\n                    if (!select)\n                        continue;\n                    var column = columns[i] = inherit(prototypeColumn);\n                    if (select.roles)\n                        column.roles = select.roles;\n                    if (select.type)\n                        column.type = select.type;\n                    column.format = getFormatForColumn(select, column);\n                    if (select.displayName)\n                        column.displayName = select.displayName;\n                    if (select.queryName)\n                        column.queryName = select.queryName;\n                    if (select.kpi)\n                        column.kpi = select.kpi;\n                    if (select.sort)\n                        column.sort = select.sort;\n                    if (select.discourageAggregationAcrossGroups)\n                        column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\n                    rewrites.push({\n                        from: prototypeColumn,\n                        to: column,\n                    });\n                }\n                return columns;\n            }\n            /**\n             * Get the column format. Order of precendence is:\n             *  1. Select format\n             *  2. Column format\n             */\n            function getFormatForColumn(select, column) {\n                // TODO: we already copied the select.Format to column.format, we probably don't need this check\n                return select.format || column.format;\n            }\n            function applyRewritesToCategorical(prototype, columnRewrites, selectsToInclude) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                var categorical = inherit(prototype);\n                function override(value) {\n                    var rewrittenSource = findOverride(value.source, columnRewrites);\n                    if (rewrittenSource) {\n                        var rewritten = inherit(value);\n                        rewritten.source = rewrittenSource;\n                        return rewritten;\n                    }\n                }\n                var categories = powerbi.Prototype.overrideArray(prototype.categories, override);\n                if (categories)\n                    categorical.categories = categories;\n                var valuesOverride = powerbi.Prototype.overrideArray(prototype.values, override);\n                var values = valuesOverride || prototype.values;\n                if (values) {\n                    var grouped = inherit(values.grouped());\n                    for (var i = 0, ilen = grouped.length; i < ilen; i++) {\n                        grouped[i] = inherit(grouped[i]);\n                    }\n                    if (selectsToInclude) {\n                        // Apply selectsToInclude to values by removing value columns not included\n                        for (var i = values.length - 1; i >= 0; i--) {\n                            if (!selectsToInclude[values[i].source.index]) {\n                                values.splice(i, 1);\n                            }\n                        }\n                        // Apply selectsToInclude to grouped()\n                        if (values.length > 0 && values[0].identity) {\n                            // We have a dynamic series, so we should remove any value columns not included in the split from each\n                            //    valueColumnGroup\n                            for (var i = 0, ilen = grouped.length; i < ilen; i++) {\n                                var currentGroupValues = grouped[i].values;\n                                for (var j = currentGroupValues.length - 1; j >= 0; j--) {\n                                    if (!selectsToInclude[currentGroupValues[j].source.index])\n                                        currentGroupValues.splice(i, 1);\n                                }\n                            }\n                        }\n                        else {\n                            // We are in a static series, so we should throw away the grouped and recreate it using the static values\n                            //   which have already been filtered\n                            grouped = [];\n                            grouped[0] = {\n                                values: values,\n                            };\n                        }\n                    }\n                    if (values.source) {\n                        if (selectsToInclude && !selectsToInclude[values.source.index]) {\n                            values.source = undefined;\n                        }\n                        else {\n                            var rewrittenValuesSource = findOverride(values.source, columnRewrites);\n                            if (rewrittenValuesSource)\n                                values.source = rewrittenValuesSource;\n                        }\n                    }\n                    var currentGroupIndex = 0;\n                    var group = void 0;\n                    for (var i = 0, ilen = values.length; i < ilen; i++) {\n                        var currentValue = values[i];\n                        if (!group || (currentValue.identity !== group.identity)) {\n                            debug.assert(!_.isUndefined(grouped[currentGroupIndex]) && currentValue.identity === grouped[currentGroupIndex].identity, 'The input Categorical has at least one values column whose identity does not belong to any of the Series groups. ' +\n                                'This query DataView Categorical is most likely containing the data across multiple splits, and the caller code is expected to ' +\n                                'specify the select indices for one of the splits in the parameter selectsToInclude.  ' +\n                                'Actual selectsToInclude=' + JSON.stringify(selectsToInclude));\n                            group = inherit(grouped[currentGroupIndex]);\n                            grouped[currentGroupIndex] = group;\n                            group.values = [];\n                            currentGroupIndex++;\n                        }\n                        group.values.push(currentValue);\n                    }\n                    categorical.values = values;\n                    setGrouped(values, grouped);\n                }\n                return categorical;\n            }\n            function applyRewritesToTable(prototype, columnRewrites, roleMappings, projectionOrdering) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                // Don't perform this potentially expensive transform unless we actually have a table.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (!roleMappings || roleMappings.length !== 1 || !roleMappings[0].table)\n                    return prototype;\n                var table = inherit(prototype);\n                // Copy the rewritten columns into the table view\n                var override = function (metadata) { return findOverride(metadata, columnRewrites); };\n                var columns = powerbi.Prototype.overrideArray(prototype.columns, override);\n                if (columns)\n                    table.columns = columns;\n                if (!projectionOrdering)\n                    return table;\n                var newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\n                if (!newToOldPositions)\n                    return table;\n                // Reorder the columns\n                var columnsClone = columns.slice(0);\n                var keys = Object.keys(newToOldPositions);\n                for (var i = 0, len = keys.length; i < len; i++) {\n                    var sourceColumn = columnsClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === columns.length)\n                        columns.push(sourceColumn);\n                    else {\n                        debug.assert(i < columns.length, 'The column index is out of range for reordering.');\n                        columns[i] = sourceColumn;\n                    }\n                }\n                // Reorder the rows\n                var rows = powerbi.Prototype.overrideArray(table.rows, function (row) {\n                    var newRow = [];\n                    for (var i = 0, len = keys.length; i < len; ++i)\n                        newRow[i] = row[newToOldPositions[keys[i]]];\n                    return newRow;\n                });\n                if (rows)\n                    table.rows = rows;\n                return table;\n            }\n            /** Creates a mapping of new position to original position. */\n            function createTableColumnPositionMapping(projectionOrdering, columnRewrites) {\n                var roles = Object.keys(projectionOrdering);\n                // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\n                if (roles.length !== 1)\n                    return;\n                var role = roles[0], originalOrder = _.map(columnRewrites, function (rewrite) { return rewrite.from.index; }), newOrder = projectionOrdering[role];\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            function applyRewritesToMatrix(prototype, columnRewrites, roleMappings, projectionOrdering, context) {\n                debug.assertValue(prototype, 'prototype');\n                debug.assertValue(columnRewrites, 'columnRewrites');\n                // Don't perform this potentially expensive transform unless we actually have a matrix.\n                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\n                if (!roleMappings || roleMappings.length < 1 || !(roleMappings[0].matrix || (roleMappings[1] && roleMappings[1].matrix)))\n                    return prototype;\n                var matrixMapping = roleMappings[0].matrix || roleMappings[1].matrix;\n                var matrix = inherit(prototype);\n                function override(metadata) {\n                    return findOverride(metadata, columnRewrites);\n                }\n                function overrideHierarchy(hierarchy) {\n                    var rewrittenHierarchy = null;\n                    var newLevels = powerbi.Prototype.overrideArray(hierarchy.levels, function (level) {\n                        var newLevel = null;\n                        var levelSources = powerbi.Prototype.overrideArray(level.sources, override);\n                        if (levelSources)\n                            newLevel = ensureRewritten(newLevel, level, function (h) { return h.sources = levelSources; });\n                        return newLevel;\n                    });\n                    if (newLevels)\n                        rewrittenHierarchy = ensureRewritten(rewrittenHierarchy, hierarchy, function (r) { return r.levels = newLevels; });\n                    return rewrittenHierarchy;\n                }\n                var rows = overrideHierarchy(matrix.rows);\n                if (rows) {\n                    matrix.rows = rows;\n                    context.rowHierarchyRewritten = true;\n                }\n                var columns = overrideHierarchy(matrix.columns);\n                if (columns) {\n                    matrix.columns = columns;\n                    context.columnHierarchyRewritten = true;\n                }\n                var valueSources = powerbi.Prototype.overrideArray(matrix.valueSources, override);\n                if (valueSources) {\n                    matrix.valueSources = valueSources;\n                    // Only need to reorder if we have more than one value source, and they are all bound to the same role\n                    var matrixValues = matrixMapping.values;\n                    if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\n                        var columnLevels = columns.levels.length;\n                        if (columnLevels > 0) {\n                            var newToOldPositions_1 = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\n                            if (newToOldPositions_1) {\n                                var keys_1 = Object.keys(newToOldPositions_1);\n                                var numKeys_1 = keys_1.length;\n                                // Reorder the value columns\n                                columns.root = data.DataViewPivotMatrix.cloneTree(columns.root);\n                                if (columnLevels === 1)\n                                    reorderChildNodes(columns.root, newToOldPositions_1);\n                                else\n                                    forEachNodeAtLevel(columns.root, columnLevels - 2, function (node) { return reorderChildNodes(node, newToOldPositions_1); });\n                                // Reorder the value rows\n                                matrix.rows.root = data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, function (node) {\n                                    if (!node.values)\n                                        return;\n                                    var newValues = {};\n                                    var iterations = Object.keys(node.values).length / numKeys_1;\n                                    for (var i = 0, len = iterations; i < len; i++) {\n                                        var offset = i * numKeys_1;\n                                        for (var keysIndex = 0; keysIndex < numKeys_1; keysIndex++)\n                                            newValues[offset + keysIndex] = node.values[offset + newToOldPositions_1[keys_1[keysIndex]]];\n                                    }\n                                    node.values = newValues;\n                                });\n                                context.hierarchyTreesRewritten = true;\n                            }\n                        }\n                    }\n                }\n                reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\n                return matrix;\n            }\n            function reorderChildNodes(node, newToOldPositions) {\n                var keys = Object.keys(newToOldPositions);\n                var numKeys = keys.length;\n                var children = node.children;\n                var childrenClone = children.slice(0);\n                for (var i = 0, len = numKeys; i < len; i++) {\n                    var sourceColumn = childrenClone[newToOldPositions[keys[i]]];\n                    // In the case we've hit the end of our columns array, but still have position reordering keys,\n                    // there is a duplicate column so we will need to add a new column for the duplicate data\n                    if (i === children.length)\n                        children.push(sourceColumn);\n                    else {\n                        debug.assert(i < children.length, 'The column index is out of range for reordering.');\n                        children[i] = sourceColumn;\n                    }\n                }\n            }\n            /**\n             * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\n             * and values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified prototype is necessary.\n             */\n            function reorderMatrixCompositeGroups(prototype, supportedDataViewMapping, projection) {\n                var transformedDataView;\n                if (prototype && supportedDataViewMapping && projection) {\n                    // reorder levelValues in any composite groups in rows hierarchy\n                    var transformedRowsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\n                        visitRole: function (role, context) {\n                            transformedRowsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedRowsHierarchy_1 || prototype.rows, role, projection);\n                        }\n                    });\n                    // reorder levelValues in any composite groups in columns hierarchy\n                    var transformedColumnsHierarchy_1;\n                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\n                        visitRole: function (role, context) {\n                            transformedColumnsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedColumnsHierarchy_1 || prototype.columns, role, projection);\n                        }\n                    });\n                    if (transformedRowsHierarchy_1 || transformedColumnsHierarchy_1) {\n                        transformedDataView = inheritSingle(prototype);\n                        transformedDataView.rows = transformedRowsHierarchy_1 || transformedDataView.rows;\n                        transformedDataView.columns = transformedColumnsHierarchy_1 || transformedDataView.columns;\n                    }\n                }\n                return transformedDataView;\n            }\n            /**\n             * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\n             * values re-ordered by projection ordering.\n             * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\n             */\n            function reorderMatrixHierarchyCompositeGroups(matrixHierarchy, hierarchyRole, projection) {\n                debug.assertValue(matrixHierarchy, 'matrixHierarchy');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                var transformedHierarchy;\n                var selectIndicesInProjectionOrder = projection[hierarchyRole];\n                // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\n                var hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\n                if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\n                    for (var i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\n                        var hierarchyLevel = matrixHierarchy.levels[i];\n                        // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\n                        var newToOldLevelSourceIndicesMapping = createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\n                        if (newToOldLevelSourceIndicesMapping) {\n                            if (_.isUndefined(transformedHierarchy)) {\n                                // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\n                                // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\n                                transformedHierarchy = inheritSingle(matrixHierarchy);\n                                transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\n                                // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\n                                // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\n                                // happen in other hierarchy levels in the later iterations of this for-loop.\n                                transformedHierarchy.root = data.utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\n                            }\n                            // reorder the metadata columns in the sources array at that level\n                            var transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\n                            transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\n                            // reorder the level values in the composite group nodes at the current hierarchy level\n                            reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\n                        }\n                    }\n                }\n                return transformedHierarchy;\n            }\n            /**\n             * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\n             * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\n             *\n             * The returned value maps level source indices from the new target order (calculated from projection order)\n             * back to the original order as they appear in the specified hierarchyLevel's sources.\n             * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\n             *\n             * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\n             *\n             * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\n             * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\n             * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\n             */\n            function createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(hierarchyRole, 'hierarchyRole');\n                debug.assertValue(projection, 'projection');\n                debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\n                var newToOldLevelSourceIndicesMapping;\n                var levelSourceColumns = hierarchyLevel.sources;\n                if (levelSourceColumns && levelSourceColumns.length >= 2) {\n                    // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\n                    var columnsForHierarchyRoleOrderedByLevelSourceIndex = data.utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(levelSourceColumns, projection, hierarchyRole);\n                    if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\n                        // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\n                        var columnsForHierarchyRoleOrderedByProjection = _.sortBy(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.projectionOrderIndex; });\n                        newToOldLevelSourceIndicesMapping = createOrderMapping(_.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.sourceIndex; }), _.map(columnsForHierarchyRoleOrderedByProjection, function (columnInfo) { return columnInfo.sourceIndex; }));\n                    }\n                }\n                return newToOldLevelSourceIndicesMapping;\n            }\n            /**\n             * Applies re-ordering on the specified transformingHierarchyLevel's sources.\n             * Returns the same object as the specified transformingHierarchyLevel.\n             */\n            function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var originalLevelSources = transformingHierarchyLevel.sources;\n                transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\n                var newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\n                for (var i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\n                    var newLevelSourceIndex = newLevelSourceIndices[i];\n                    var oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\n                    debug.assert(oldLevelSourceIndex < originalLevelSources.length, 'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\n                    transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\n                }\n                return transformingHierarchyLevel;\n            }\n            /**\n             * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\n             * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\n             *\n             * Returns the same object as the specified transformingHierarchyRootNode.\n             */\n            function reorderMatrixHierarchyLevelValues(transformingHierarchyRootNode, transformingHierarchyLevelIndex, newToOldLevelSourceIndicesMapping) {\n                debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\n                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\n                var oldToNewLevelSourceIndicesMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\n                forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, function (transformingMatrixNode) {\n                    var originalLevelValues = transformingMatrixNode.levelValues;\n                    // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\n                    // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\n                    // The following code isn't correct in the special case where a column is projected twice in this composite group,\n                    // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\n                    // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\n                    if (!_.isEmpty(originalLevelValues)) {\n                        // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\n                        // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\n                        // because we don't want to accidentally modify the array AND its value references in Query DataView\n                        var newlyOrderedLevelValues = _.sortBy(originalLevelValues, function (levelValue) { return oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]; });\n                        for (var i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\n                            var transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\n                            transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\n                            newlyOrderedLevelValues[i] = transformingLevelValue;\n                        }\n                        transformingMatrixNode.levelValues = newlyOrderedLevelValues;\n                        // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\n                        // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\n                        var newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\n                        if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\n                            transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\n                        }\n                        if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\n                            transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\n                        }\n                    }\n                });\n                return transformingHierarchyRootNode;\n            }\n            /**\n             * Creates a mapping of new position to original position.\n             *\n             * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\n             * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\n             * - the value in the key-value pair is the index of the particular column in the original order\n             */\n            function createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites) {\n                var role = matrixValues.for.in;\n                var newOrder = projectionOrdering[role];\n                var originalOrder = _.chain(columnRewrites)\n                    .filter(function (rewrite) { return _.contains(valueSources, rewrite.to); })\n                    .map(function (rewrite) { return rewrite.from.index; })\n                    .value();\n                return createOrderMapping(originalOrder, newOrder);\n            }\n            /**\n             * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\n             * originalOrder array.\n             * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\n             * under the context of the caller code), e.g. the Select Index in projection ordering array.\n             * Also, the specified originalOrder must contain every value that exists in newOrder.\n             *\n             * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\n             * key-value pair, each of which represents the new and old indices of a particular column:\n             * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\n             * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\n             *\n             * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\n             *\n             * If the specified originalOrder and newOrder are same, then this function returns undefined.\n             *\n             * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\n             * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\n             */\n            function createOrderMapping(originalOrder, newOrder) {\n                // Optimization: avoid rewriting if the current order is correct\n                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, function (x, y) { return x === y; }))\n                    return;\n                var mapping = {};\n                for (var i = 0, len = newOrder.length; i < len; ++i) {\n                    var newPosition = newOrder[i];\n                    mapping[i] = originalOrder.indexOf(newPosition);\n                }\n                return mapping;\n            }\n            function createReversedMapping(mapping) {\n                debug.assertValue(mapping, 'mapping');\n                var reversed = {};\n                for (var key in mapping) {\n                    // Note: key is a string after we get it out from mapping, thus we need to parse it\n                    // back into a number before putting it as the value in the reversed mapping\n                    var value = mapping[key];\n                    var keyAsNumber = parseInt(key, 10);\n                    reversed[value] = keyAsNumber;\n                }\n                debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length, 'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\n                return reversed;\n            }\n            function forEachNodeAtLevel(node, targetLevel, callback) {\n                debug.assertValue(node, 'node');\n                debug.assert(targetLevel >= 0, 'argetLevel >= 0');\n                debug.assertValue(callback, 'callback');\n                if (node.level === targetLevel) {\n                    callback(node);\n                    return;\n                }\n                var children = node.children;\n                if (children && children.length > 0) {\n                    for (var i = 0, ilen = children.length; i < ilen; i++)\n                        forEachNodeAtLevel(children[i], targetLevel, callback);\n                }\n            }\n            DataViewTransform.forEachNodeAtLevel = forEachNodeAtLevel;\n            function findOverride(source, columnRewrites) {\n                for (var i = 0, len = columnRewrites.length; i < len; i++) {\n                    var columnRewrite = columnRewrites[i];\n                    if (columnRewrite.from === source)\n                        return columnRewrite.to;\n                }\n            }\n            function ensureRewritten(rewritten, prototype, callback) {\n                if (!rewritten)\n                    rewritten = inherit(prototype);\n                if (callback)\n                    callback(rewritten);\n                return rewritten;\n            }\n            function transformObjects(dataView, targetDataViewKinds, objectDescriptors, objectDefinitions, selectTransforms, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\n                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!objectDescriptors)\n                    return;\n                var objectsForAllSelectors = data.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\n                data.DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\n                var metadataOnce = objectsForAllSelectors.metadataOnce;\n                var dataObjects = objectsForAllSelectors.data;\n                if (metadataOnce)\n                    evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\n                var metadataObjects = objectsForAllSelectors.metadata;\n                if (metadataObjects) {\n                    for (var i = 0, len = metadataObjects.length; i < len; i++) {\n                        var metadataObject = metadataObjects[i];\n                        var objectDefns = metadataObject.objects;\n                        var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                        evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\n                    }\n                }\n                for (var i = 0, len = dataObjects.length; i < len; i++) {\n                    var dataObject = dataObjects[i];\n                    var objectDefns = dataObject.objects;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                    evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\n                }\n                var userDefined = objectsForAllSelectors.userDefined;\n                if (userDefined) {\n                    // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\n                    evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\n                }\n            }\n            DataViewTransform.transformObjects = transformObjects;\n            function evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var dataViewObjects = dataView.metadata.objects;\n                if (!dataViewObjects) {\n                    dataViewObjects = dataView.metadata.objects = {};\n                }\n                for (var _i = 0, objectDefns_1 = objectDefns; _i < objectDefns_1.length; _i++) {\n                    var objectDefn = objectDefns_1[_i];\n                    var id = objectDefn.selector.id;\n                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\n                    var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                    var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\n                    for (var objectName in objects) {\n                        var object = objects[objectName];\n                        var map = dataViewObjects[objectName];\n                        if (!map)\n                            map = dataViewObjects[objectName] = [];\n                        debug.assert(powerbi.DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\n                        // NOTE: We do not check for duplicate ids.\n                        map.push({ id: id, object: object });\n                    }\n                }\n            }\n            /** Evaluates and sets properties on the DataView metadata. */\n            function evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, objectDefns, dataObjects, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(dataObjects, 'dataObjects');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\n                var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                if (objects) {\n                    dataView.metadata.objects = objects;\n                    for (var objectName in objects) {\n                        var object = objects[objectName], objectDesc = objectDescriptors[objectName];\n                        for (var propertyName in object) {\n                            var propertyDesc = objectDesc.properties[propertyName], ruleDesc = propertyDesc.rule;\n                            if (!ruleDesc)\n                                continue;\n                            var definition = createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, object[propertyName], propertyDesc.type);\n                            if (!definition)\n                                continue;\n                            dataObjects.push(definition);\n                        }\n                    }\n                }\n            }\n            function createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, propertyValue, ruleType) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(propertyValue, 'propertyValue');\n                debug.assertValue(ruleType, 'ruleType');\n                var ruleOutput = ruleDesc.output;\n                if (!ruleOutput)\n                    return;\n                var selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\n                if (!selectorToCreate)\n                    return;\n                if (ruleType.fillRule) {\n                    return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue);\n                }\n            }\n            function createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(ruleDesc, 'ruleDesc');\n                debug.assertValue(selectorToCreate, 'selectorToCreate');\n                debug.assertValue(propertyValue, 'propertyValue');\n                var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, 1 /* Role */, propertyValue);\n                if (!colorAllocator)\n                    return;\n                var rule = new data.ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\n                var fillRuleProperties = {};\n                fillRuleProperties[ruleDesc.output.property] = {\n                    solid: { color: rule }\n                };\n                return {\n                    selector: selectorToCreate,\n                    rules: [rule],\n                    objects: [{\n                            name: objectName,\n                            properties: fillRuleProperties,\n                        }]\n                };\n            }\n            function tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(propertyValue, 'propertyValue');\n                if (propertyValue.linearGradient2)\n                    return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\n                if (propertyValue.linearGradient3)\n                    return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\n            }\n            function createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient2) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient2, 'linearGradient2');\n                linearGradient2 = propertyValueFillRule.linearGradient2;\n                if (linearGradient2.min.value === undefined ||\n                    linearGradient2.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    if (linearGradient2.min.value === undefined)\n                        linearGradient2.min.value = inputRange.min;\n                    if (linearGradient2.max.value === undefined)\n                        linearGradient2.max.value = inputRange.max;\n                }\n                return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\n            }\n            function createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient3) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                debug.assertValue(linearGradient3, 'linearGradient3');\n                var splitScales;\n                linearGradient3 = propertyValueFillRule.linearGradient3;\n                if (linearGradient3.min.value === undefined ||\n                    linearGradient3.mid.value === undefined ||\n                    linearGradient3.max.value === undefined) {\n                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\n                    if (!inputRange)\n                        return;\n                    splitScales =\n                        linearGradient3.min.value === undefined &&\n                            linearGradient3.max.value === undefined &&\n                            linearGradient3.mid.value !== undefined;\n                    if (linearGradient3.min.value === undefined) {\n                        linearGradient3.min.value = inputRange.min;\n                    }\n                    if (linearGradient3.max.value === undefined) {\n                        linearGradient3.max.value = inputRange.max;\n                    }\n                    if (linearGradient3.mid.value === undefined) {\n                        var midValue = (linearGradient3.max.value + linearGradient3.min.value) / 2;\n                        linearGradient3.mid.value = midValue;\n                    }\n                }\n                return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\n            }\n            function populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                var cache = data.createColorAllocatorCache();\n                var staticEvalContext = data.createStaticEvalContext();\n                for (var i = 0, len = objectDefns.length; i < len; i++) {\n                    var objectDefnProperties = objectDefns[i].properties;\n                    for (var propertyName in objectDefnProperties) {\n                        var fillProperty = objectDefnProperties[propertyName];\n                        if (fillProperty &&\n                            fillProperty.solid &&\n                            fillProperty.solid.color &&\n                            fillProperty.solid.color.kind === 23 /* FillRule */) {\n                            var fillRuleExpr = fillProperty.solid.color;\n                            var inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\n                            if (!inputExprQueryName)\n                                continue;\n                            var fillRule = data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, fillRulePropertyDescriptor, fillRuleExpr.rule);\n                            var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, 0 /* QueryName */, fillRule);\n                            if (colorAllocator)\n                                cache.register(fillRuleExpr, colorAllocator);\n                        }\n                    }\n                }\n                return cache;\n            }\n            function evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, selector, rules, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\n                var containsWildcard = data.Selector.containsWildcard(selector);\n                var dataViewCategorical = dataView.categorical;\n                if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {\n                    // 1) Match against categories\n                    evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    // 2) Match against valueGrouping\n                    evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                }\n                var dataViewMatrix = dataView.matrix;\n                if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {\n                    var rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenMatrix) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.matrix = rewrittenMatrix;\n                    }\n                }\n                var dataViewTable = dataView.table;\n                if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {\n                    var rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\n                    var rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\n                    if (rewrittenTable) {\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                        // revisit this, likely when we do lazy evaluation of DataView.\n                        dataView.table = rewrittenTable;\n                    }\n                }\n            }\n            function rewriteTableRoleSelector(dataViewTable, selector) {\n                if (data.Selector.hasRoleWildcard(selector)) {\n                    selector = findSelectorForRoleWildcard(dataViewTable, selector);\n                }\n                return selector;\n            }\n            function findSelectorForRoleWildcard(dataViewTable, selector) {\n                var resultingSelector = {\n                    data: [],\n                    id: selector.id,\n                    metadata: selector.metadata\n                };\n                for (var _i = 0, _a = selector.data; _i < _a.length; _i++) {\n                    var dataSelector = _a[_i];\n                    if (data.Selector.isRoleWildcard(dataSelector)) {\n                        var selectorRoles = dataSelector.roles;\n                        var allColumnsBelongToSelectorRole = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\n                        var exprs = dataViewTable.identityFields;\n                        if (allColumnsBelongToSelectorRole && exprs) {\n                            resultingSelector.data.push(data.DataViewScopeWildcard.fromExprs(exprs));\n                            continue;\n                        }\n                    }\n                    if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\n                        resultingSelector.data.push(dataSelector);\n                    }\n                }\n                return resultingSelector;\n            }\n            function isUniqueDataSelector(dataSelectors, newSelector) {\n                if (_.isEmpty(dataSelectors))\n                    return true;\n                return !_.any(dataSelectors, function (dataSelector) { return dataSelector.key === newSelector.key; });\n            }\n            function allColumnsBelongToRole(columns, selectorRoles) {\n                for (var _i = 0, columns_6 = columns; _i < columns_6.length; _i++) {\n                    var column = columns_6[_i];\n                    var roles = column.roles;\n                    if (!roles || !_.any(selectorRoles, function (selectorRole) { return roles[selectorRole]; }))\n                        return false;\n                }\n                return true;\n            }\n            function evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\n                    return;\n                var targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\n                if (!targetColumn)\n                    return;\n                var identities = targetColumn.identities, foundMatch, evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                if (!identities)\n                    return;\n                debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\n                for (var i = 0, len = identities.length; i < len; i++) {\n                    var identity = identities[i];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(i);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (!targetColumn.column.objects) {\n                                targetColumn.column.objects = [];\n                                targetColumn.column.objects.length = len;\n                            }\n                            targetColumn.column.objects[i] = objects;\n                        }\n                        if (!containsWildcard)\n                            return true;\n                        foundMatch = true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(containsWildcard, 'containsWildcard');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var dataViewCategoricalValues = dataViewCategorical.values;\n                if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [dataViewCategoricalValues.identityFields]))\n                    return;\n                var valuesGrouped = dataViewCategoricalValues.grouped();\n                if (!valuesGrouped)\n                    return;\n                // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\n                // This should be enhanced in the future.\n                var evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\n                var foundMatch;\n                for (var i = 0, len = valuesGrouped.length; i < len; i++) {\n                    var valueGroup = valuesGrouped[i];\n                    var selectorMetadata = selector.metadata;\n                    var valuesInGroup = valueGroup.values;\n                    if (containsWildcard || data.Selector.matchesData(selector, [valueGroup.identity])) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                            // revisit this, likely when we do lazy evaluation of DataView.\n                            if (selectorMetadata) {\n                                for (var j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\n                                    var valueColumn = valuesInGroup[j], valueSource = valueColumn.source;\n                                    if (valueSource.queryName === selectorMetadata) {\n                                        var valueSourceOverwrite = powerbi.Prototype.inherit(valueSource);\n                                        valueSourceOverwrite.objects = objects;\n                                        valueColumn.source = valueSourceOverwrite;\n                                        foundMatch = true;\n                                        break;\n                                    }\n                                }\n                            }\n                            else {\n                                valueGroup.objects = objects;\n                                setGrouped(dataViewCategoricalValues, valuesGrouped);\n                                foundMatch = true;\n                            }\n                        }\n                        if (!containsWildcard)\n                            return true;\n                    }\n                }\n                return foundMatch;\n            }\n            function evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                var evalContext = data.createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\n                var rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                var rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows || rewrittenCols) {\n                    var rewrittenMatrix = inheritSingle(dataViewMatrix);\n                    if (rewrittenRows)\n                        rewrittenMatrix.rows = rewrittenRows;\n                    if (rewrittenCols)\n                        rewrittenMatrix.columns = rewrittenCols;\n                    return rewrittenMatrix;\n                }\n            }\n            function evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrixHierarchy, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (!dataViewMatrixHierarchy)\n                    return;\n                var root = dataViewMatrixHierarchy.root;\n                if (!root)\n                    return;\n                var rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRoot) {\n                    var rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\n                    rewrittenHierarchy.root = rewrittenRoot;\n                    return rewrittenHierarchy;\n                }\n            }\n            function evaluateDataRepetitionMatrixNode(evalContext, dataViewNode, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(dataViewNode, 'dataViewNode');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                var childNodes = dataViewNode.children;\n                if (!childNodes)\n                    return;\n                var rewrittenNode;\n                var shouldSearchChildren;\n                var childIdentityFields = dataViewNode.childIdentityFields;\n                if (childIdentityFields) {\n                    // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\n                    shouldSearchChildren = data.Selector.matchesKeys(selector, [childIdentityFields]);\n                }\n                for (var i = 0, len = childNodes.length; i < len; i++) {\n                    var childNode = childNodes[i], identity = childNode.identity, rewrittenChildNode = null;\n                    if (shouldSearchChildren) {\n                        if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                            // TODO: Need to initialize context for rule-based properties.  Rule-based properties\n                            // (such as fillRule/gradients) are not currently implemented.\n                            var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                            if (objects) {\n                                rewrittenChildNode = inheritSingle(childNode);\n                                rewrittenChildNode.objects = objects;\n                            }\n                        }\n                    }\n                    else {\n                        rewrittenChildNode = evaluateDataRepetitionMatrixNode(evalContext, childNode, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                    }\n                    if (rewrittenChildNode) {\n                        if (!rewrittenNode)\n                            rewrittenNode = inheritNodeAndChildren(dataViewNode);\n                        rewrittenNode.children[i] = rewrittenChildNode;\n                        if (!containsWildcard) {\n                            // NOTE: once we find a match for a non-wildcard selector, stop looking.\n                            break;\n                        }\n                    }\n                }\n                return rewrittenNode;\n            }\n            function inheritNodeAndChildren(node) {\n                if (Object.getPrototypeOf(node) !== Object.prototype) {\n                    return node;\n                }\n                var inherited = inheritSingle(node);\n                inherited.children = inherit(node.children);\n                return inherited;\n            }\n            function evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataViewTable, 'dataViewTable');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                var evalContext = data.createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\n                var rewrittenRows = evaluateDataRepetitionTableRows(evalContext, dataViewTable.columns, dataViewTable.rows, dataViewTable.identity, dataViewTable.identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns);\n                if (rewrittenRows) {\n                    var rewrittenTable = inheritSingle(dataViewTable);\n                    rewrittenTable.rows = rewrittenRows;\n                    return rewrittenTable;\n                }\n            }\n            function evaluateDataRepetitionTableRows(evalContext, columns, rows, identities, identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns) {\n                debug.assertValue(evalContext, 'evalContext');\n                debug.assertValue(columns, 'columns');\n                debug.assertValue(rows, 'rows');\n                debug.assertAnyValue(identities, 'identities');\n                debug.assertAnyValue(identityFields, 'identityFields');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertAnyValue(rules, 'rules');\n                debug.assertValue(objectDefns, 'objectDefns');\n                if (_.isEmpty(identities) || _.isEmpty(identityFields))\n                    return;\n                if (!selector.metadata ||\n                    !data.Selector.matchesKeys(selector, [identityFields]))\n                    return;\n                var colIdx = _.findIndex(columns, function (col) { return col.queryName === selector.metadata; });\n                if (colIdx < 0)\n                    return;\n                debug.assert(rows.length === identities.length, 'row length mismatch');\n                var colLen = columns.length;\n                var inheritedRows;\n                for (var rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\n                    var identity = identities[rowIdx];\n                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {\n                        evalContext.setCurrentRowIndex(rowIdx);\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects) {\n                            if (!inheritedRows)\n                                inheritedRows = inheritSingle(rows);\n                            var inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\n                            var objectsForColumns = inheritedRow.objects;\n                            if (!objectsForColumns)\n                                inheritedRow.objects = objectsForColumns = new Array(colLen);\n                            objectsForColumns[colIdx] = objects;\n                        }\n                        if (!containsWildcard)\n                            break;\n                    }\n                }\n                return inheritedRows;\n            }\n            function evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, selector, objectDefns, colorAllocatorCache) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(selector, 'selector');\n                debug.assertValue(objectDefns, 'objectDefns');\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\n                // revisit this, likely when we do lazy evaluation of DataView.\n                var columns = dataView.metadata.columns, metadataId = selector.metadata, evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\n                for (var i = 0, len = columns.length; i < len; i++) {\n                    var column = columns[i];\n                    if (column.queryName === metadataId) {\n                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\n                        if (objects)\n                            column.objects = objects;\n                    }\n                }\n            }\n            /** Attempts to find a column that can possibly match the selector. */\n            function findSelectedCategoricalColumn(dataViewCategorical, selector) {\n                debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\n                var categoricalColumn = dataViewCategorical.categories[0];\n                if (!categoricalColumn.identityFields)\n                    return;\n                if (!data.Selector.matchesKeys(selector, [categoricalColumn.identityFields]))\n                    return;\n                var identities = categoricalColumn.identity, targetColumn = categoricalColumn;\n                var selectedMetadataId = selector.metadata;\n                if (selectedMetadataId) {\n                    var valueColumns = dataViewCategorical.values;\n                    if (valueColumns) {\n                        for (var i = 0, len = valueColumns.length; i < len; i++) {\n                            var valueColumn = valueColumns[i];\n                            if (valueColumn.source.queryName === selectedMetadataId) {\n                                targetColumn = valueColumn;\n                                break;\n                            }\n                        }\n                    }\n                }\n                return {\n                    column: targetColumn,\n                    identities: identities,\n                };\n            }\n            function findSelectorForRuleInput(dataView, selectorRoles) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectorRoles, 'selectorRoles');\n                if (selectorRoles.length !== 1)\n                    return;\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical)\n                    return;\n                var categories = dataViewCategorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var categoryColumn = categories[0], categoryRoles = categoryColumn.source.roles, categoryIdentityFields = categoryColumn.identityFields;\n                if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\n                    return;\n                return { data: [data.DataViewScopeWildcard.fromExprs(categoryIdentityFields)] };\n            }\n            function findFirstQueryNameForExpr(selectTransforms, expr) {\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                debug.assertValue(expr, 'expr');\n                if (!selectTransforms)\n                    return;\n                for (var i = 0, len = selectTransforms.length; i < len; i++) {\n                    var select = selectTransforms[i], columnExpr = select.expr;\n                    if (!columnExpr || !data.SQExpr.equals(expr, select.expr))\n                        continue;\n                    return select.queryName;\n                }\n            }\n            /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\n            function findRuleInputColumnNumberRange(dataView, identifier, identifierKind) {\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(identifier, 'identifier');\n                debug.assertValue(identifierKind, 'identifierKind');\n                // NOTE: This implementation currently only supports categorical DataView, becuase that's the\n                // only scenario that has custom colors, as of this writing.  This would be rewritten to be more generic\n                // as required, when needed.\n                var dataViewCategorical = dataView.categorical;\n                if (!dataViewCategorical)\n                    return;\n                var values = dataViewCategorical.values;\n                if (!values)\n                    return;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var valueCol = values[i];\n                    if (identifierKind === 1 /* Role */) {\n                        var valueColRoles = valueCol.source.roles;\n                        if (!valueColRoles || !valueColRoles[identifier])\n                            continue;\n                    }\n                    else {\n                        debug.assert(identifierKind === 0 /* QueryName */, 'identifierKind === ColumnIdentifierKind.QueryName');\n                        if (valueCol.source.queryName !== identifier)\n                            continue;\n                    }\n                    var min = valueCol.min;\n                    if (min === undefined)\n                        min = valueCol.minLocal;\n                    if (min === undefined)\n                        continue;\n                    var max = valueCol.max;\n                    if (max === undefined)\n                        max = valueCol.maxLocal;\n                    if (max === undefined)\n                        continue;\n                    return { min: min, max: max };\n                }\n            }\n            // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\n            function createValueColumns(values, valueIdentityFields, source) {\n                if (values === void 0) { values = []; }\n                var result = values;\n                setGrouped(values);\n                if (valueIdentityFields)\n                    result.identityFields = valueIdentityFields;\n                if (source)\n                    result.source = source;\n                return result;\n            }\n            DataViewTransform.createValueColumns = createValueColumns;\n            function setGrouped(values, groupedResult) {\n                values.grouped = groupedResult\n                    ? function () { return groupedResult; }\n                    : function () { return groupValues(values); };\n            }\n            DataViewTransform.setGrouped = setGrouped;\n            /** Group together the values with a common identity. */\n            function groupValues(values) {\n                debug.assertValue(values, 'values');\n                var groups = [], currentGroup;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    if (!currentGroup || currentGroup.identity !== value.identity) {\n                        currentGroup = {\n                            values: []\n                        };\n                        if (value.identity) {\n                            currentGroup.identity = value.identity;\n                            var source = value.source;\n                            // allow null, which will be formatted as (Blank).\n                            if (source.groupName !== undefined)\n                                currentGroup.name = source.groupName;\n                            else if (source.displayName)\n                                currentGroup.name = source.displayName;\n                        }\n                        groups.push(currentGroup);\n                    }\n                    currentGroup.values.push(value);\n                }\n                return groups;\n            }\n            function pivotIfNecessary(dataView, dataViewMappings) {\n                debug.assertValue(dataView, 'dataView');\n                var transformedDataView;\n                switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\n                    case 1 /* Pivot */:\n                        transformedDataView = data.DataViewPivotCategorical.apply(dataView);\n                        break;\n                    case 2 /* SelfCrossJoin */:\n                        transformedDataView = data.DataViewSelfCrossJoin.apply(dataView);\n                        break;\n                }\n                return transformedDataView || dataView;\n            }\n            function determineCategoricalTransformation(categorical, dataViewMappings) {\n                if (!categorical || _.isEmpty(dataViewMappings))\n                    return;\n                var categories = categorical.categories;\n                if (!categories || categories.length !== 1)\n                    return;\n                var values = categorical.values;\n                if (_.isEmpty(values))\n                    return;\n                if (values.grouped().some(function (vg) { return !!vg.identity; }))\n                    return;\n                // If we made it here, the DataView has a single category and no valueGrouping.\n                var categoryRoles = categories[0].source.roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingCategorical = dataViewMappings[i].categorical;\n                    if (!roleMappingCategorical)\n                        continue;\n                    if (!hasRolesGrouped(categoryRoles, roleMappingCategorical.values))\n                        continue;\n                    // If we made it here, the DataView's single category has the value grouping role.\n                    var categoriesMapping = roleMappingCategorical.categories;\n                    var hasCategoryRole = hasRolesBind(categoryRoles, categoriesMapping) ||\n                        hasRolesFor(categoryRoles, categoriesMapping);\n                    if (hasCategoryRole)\n                        return 2 /* SelfCrossJoin */;\n                    return 1 /* Pivot */;\n                }\n            }\n            function shouldPivotMatrix(matrix, dataViewMappings) {\n                if (!matrix || _.isEmpty(dataViewMappings))\n                    return;\n                var rowLevels = matrix.rows.levels;\n                if (rowLevels.length < 1)\n                    return;\n                var rows = matrix.rows.root.children;\n                if (!rows || rows.length === 0)\n                    return;\n                var rowRoles = rowLevels[0].sources[0].roles;\n                for (var i = 0, len = dataViewMappings.length; i < len; i++) {\n                    var roleMappingMatrix = dataViewMappings[i].matrix;\n                    if (!roleMappingMatrix)\n                        continue;\n                    if (!hasRolesFor(rowRoles, roleMappingMatrix.rows) &&\n                        hasRolesFor(rowRoles, roleMappingMatrix.columns)) {\n                        return true;\n                    }\n                }\n            }\n            function hasRolesBind(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.bind)\n                    return roles[roleMapping.bind.to];\n            }\n            function hasRolesFor(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.for)\n                    return roles[roleMapping.for.in];\n            }\n            function hasRolesGrouped(roles, roleMapping) {\n                if (roles && roleMapping && roleMapping.group)\n                    return roles[roleMapping.group.by];\n            }\n        })(DataViewTransform = data.DataViewTransform || (data.DataViewTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createDisplayNameGetter(displayNameKey) {\n            return function (resourceProvider) { return resourceProvider.get(displayNameKey); };\n        }\n        data.createDisplayNameGetter = createDisplayNameGetter;\n        function getDisplayName(displayNameGetter, resourceProvider) {\n            if (typeof displayNameGetter === 'function')\n                return displayNameGetter(resourceProvider);\n            if (typeof displayNameGetter === 'string')\n                return displayNameGetter;\n        }\n        data.getDisplayName = getDisplayName;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    /** Enumeration of DateTimeUnits */\n    (function (DateTimeUnit) {\n        DateTimeUnit[DateTimeUnit[\"Year\"] = 0] = \"Year\";\n        DateTimeUnit[DateTimeUnit[\"Month\"] = 1] = \"Month\";\n        DateTimeUnit[DateTimeUnit[\"Week\"] = 2] = \"Week\";\n        DateTimeUnit[DateTimeUnit[\"Day\"] = 3] = \"Day\";\n        DateTimeUnit[DateTimeUnit[\"Hour\"] = 4] = \"Hour\";\n        DateTimeUnit[DateTimeUnit[\"Minute\"] = 5] = \"Minute\";\n        DateTimeUnit[DateTimeUnit[\"Second\"] = 6] = \"Second\";\n        DateTimeUnit[DateTimeUnit[\"Millisecond\"] = 7] = \"Millisecond\";\n    })(powerbi.DateTimeUnit || (powerbi.DateTimeUnit = {}));\n    var DateTimeUnit = powerbi.DateTimeUnit;\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function fieldExpr(fieldExpr) {\n                var sqExpr = FieldExprPattern.visit(fieldExpr, FieldExprToSQExprVisitor.instance);\n                debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\n                return sqExpr;\n            }\n            SQExprBuilder.fieldExpr = fieldExpr;\n            function fromColumnAggr(columnAggr) {\n                return SQExprBuilder.aggregate(fromColumn(columnAggr), columnAggr.aggregate);\n            }\n            SQExprBuilder.fromColumnAggr = fromColumnAggr;\n            function fromColumn(column) {\n                return SQExprBuilder.columnRef(fromEntity(column), column.name);\n            }\n            SQExprBuilder.fromColumn = fromColumn;\n            function fromEntity(entityPattern) {\n                return SQExprBuilder.entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\n            }\n            SQExprBuilder.fromEntity = fromEntity;\n            function fromEntityAggr(entityAggr) {\n                return SQExprBuilder.aggregate(fromEntity(entityAggr), entityAggr.aggregate);\n            }\n            SQExprBuilder.fromEntityAggr = fromEntityAggr;\n            function fromHierarchyLevelAggr(hierarchyLevelAggr) {\n                return SQExprBuilder.aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\n            }\n            SQExprBuilder.fromHierarchyLevelAggr = fromHierarchyLevelAggr;\n            function fromHierarchyLevel(hierarchyLevelPattern) {\n                return SQExprBuilder.hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\n            }\n            SQExprBuilder.fromHierarchyLevel = fromHierarchyLevel;\n            function fromHierarchy(hierarchyPattern) {\n                return SQExprBuilder.hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\n            }\n            SQExprBuilder.fromHierarchy = fromHierarchy;\n            var FieldExprToSQExprVisitor = (function () {\n                function FieldExprToSQExprVisitor() {\n                }\n                FieldExprToSQExprVisitor.prototype.visitColumn = function (column) {\n                    return fromColumn(column);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return fromColumnAggr(columnAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariationPattern) {\n                    return SQExprBuilder.propertyVariationSource(this.visitEntity(columnHierarchyLevelVariationPattern.source), columnHierarchyLevelVariationPattern.source.name, columnHierarchyLevelVariationPattern.level.name);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntity = function (entityPattern) {\n                    return fromEntity(entityPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return fromEntityAggr(entityAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchy = function (hierarchyPattern) {\n                    return fromHierarchy(hierarchyPattern);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevel = function (level) {\n                    return fromHierarchyLevel(level);\n                };\n                FieldExprToSQExprVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return fromHierarchyLevelAggr(hierarchyLevelAggr);\n                };\n                FieldExprToSQExprVisitor.prototype.visitMeasure = function (measure) {\n                    return SQExprBuilder.measureRef(this.visitEntity(measure), measure.name);\n                };\n                FieldExprToSQExprVisitor.prototype.visitPercentile = function (percentile) {\n                    var arg = SQExprBuilder.fieldExpr(percentile.arg);\n                    return SQExprBuilder.percentile(arg, percentile.k, percentile.exclusive);\n                };\n                FieldExprToSQExprVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    var baseSQExpr = SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr);\n                    return SQExprBuilder.arithmetic(baseSQExpr, SQExprBuilder.scopedEval(baseSQExpr, []), 3 /* Divide */);\n                };\n                FieldExprToSQExprVisitor.instance = new FieldExprToSQExprVisitor();\n                return FieldExprToSQExprVisitor;\n            }());\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asFieldPattern(sqExpr) {\n                return sqExpr.accept(FieldExprPatternBuilder.instance);\n            }\n            SQExprConverter.asFieldPattern = asFieldPattern;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        var FieldExprPatternBuilder = (function (_super) {\n            __extends(FieldExprPatternBuilder, _super);\n            function FieldExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            FieldExprPatternBuilder.prototype.visitColumnRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var columnRef = sourceRef.entity;\n                    columnRef.name = expr.ref;\n                    return { column: columnRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitMeasureRef = function (expr) {\n                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\n                if (!sourceRef)\n                    return;\n                if (sourceRef.entity) {\n                    var measureRef = sourceRef.entity;\n                    measureRef.name = expr.ref;\n                    return { measure: measureRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            FieldExprPatternBuilder.prototype.visitAggr = function (expr) {\n                var fieldPattern = expr.arg.accept(this);\n                if (fieldPattern && fieldPattern.column) {\n                    var argAggr = fieldPattern.column;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.columnAggr) {\n                    var argAggr = fieldPattern.columnAggr;\n                    argAggr.aggregate = expr.func;\n                    return { columnAggr: argAggr };\n                }\n                else if (fieldPattern && fieldPattern.hierarchyLevel) {\n                    var argAggr = fieldPattern.hierarchyLevel;\n                    argAggr.aggregate = expr.func;\n                    return { hierarchyLevelAggr: argAggr };\n                }\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var argAggr = sourcePattern.entity;\n                    argAggr.aggregate = expr.func;\n                    return { entityAggr: argAggr };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitPercentile = function (expr) {\n                return {\n                    percentile: {\n                        arg: expr.arg.accept(this),\n                        k: expr.k,\n                        exclusive: expr.exclusive,\n                    }\n                };\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchy = function (expr) {\n                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                if (sourcePattern && sourcePattern.entity) {\n                    var hierarchyRef = (sourcePattern.entity);\n                    hierarchyRef.name = expr.hierarchy;\n                    return { hierarchy: hierarchyRef };\n                }\n            };\n            FieldExprPatternBuilder.prototype.visitHierarchyLevel = function (expr) {\n                var hierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\n                if (!hierarchySourceExprPattern)\n                    return;\n                var hierarchyLevel;\n                if (hierarchySourceExprPattern.hierarchy) {\n                    hierarchyLevel = {\n                        entity: hierarchySourceExprPattern.hierarchy.entity,\n                        schema: hierarchySourceExprPattern.hierarchy.schema,\n                        name: hierarchySourceExprPattern.hierarchy.name,\n                        level: expr.level,\n                    };\n                }\n                if (hierarchySourceExprPattern.variation) {\n                    return {\n                        columnHierarchyLevelVariation: {\n                            source: {\n                                entity: hierarchySourceExprPattern.variation.column.entity,\n                                schema: hierarchySourceExprPattern.variation.column.schema,\n                                name: hierarchySourceExprPattern.variation.column.name,\n                            },\n                            level: hierarchyLevel,\n                            variationName: hierarchySourceExprPattern.variation.variationName,\n                        }\n                    };\n                }\n                return { hierarchyLevel: hierarchyLevel };\n            };\n            FieldExprPatternBuilder.prototype.visitArithmetic = function (expr) {\n                var percentOfGrandTotalPattern = {\n                    percentOfGrandTotal: {\n                        baseExpr: expr.left.accept(this)\n                    }\n                };\n                if (data.SQExpr.equals(expr, SQExprBuilder.fieldExpr(percentOfGrandTotalPattern))) {\n                    return percentOfGrandTotalPattern;\n                }\n            };\n            FieldExprPatternBuilder.instance = new FieldExprPatternBuilder();\n            return FieldExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var SourceExprPatternBuilder = (function (_super) {\n            __extends(SourceExprPatternBuilder, _super);\n            function SourceExprPatternBuilder() {\n                _super.apply(this, arguments);\n            }\n            SourceExprPatternBuilder.prototype.visitEntity = function (expr) {\n                var entityRef = {\n                    schema: expr.schema,\n                    entity: expr.entity\n                };\n                if (expr.variable)\n                    entityRef.entityVar = expr.variable;\n                return { entity: entityRef };\n            };\n            SourceExprPatternBuilder.prototype.visitPropertyVariationSource = function (expr) {\n                var entityExpr = expr.arg;\n                if (entityExpr instanceof data.SQEntityExpr) {\n                    var propertyVariationSource = {\n                        schema: entityExpr.schema,\n                        entity: entityExpr.entity,\n                        name: expr.property,\n                    };\n                    if (entityExpr.variable)\n                        propertyVariationSource.entityVar = entityExpr.variable;\n                    return {\n                        variation: {\n                            column: propertyVariationSource,\n                            variationName: expr.name,\n                        }\n                    };\n                }\n            };\n            SourceExprPatternBuilder.instance = new SourceExprPatternBuilder();\n            return SourceExprPatternBuilder;\n        }(data.DefaultSQExprVisitor));\n        var HierarchyExprPatternBuiler = (function (_super) {\n            __extends(HierarchyExprPatternBuiler, _super);\n            function HierarchyExprPatternBuiler() {\n                _super.apply(this, arguments);\n            }\n            HierarchyExprPatternBuiler.prototype.visitHierarchy = function (expr) {\n                var exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\n                var hierarchyRef;\n                var variationRef;\n                if (exprPattern.variation) {\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.variation.column.schema,\n                        entity: exprPattern.variation.column.entity,\n                    };\n                    variationRef = exprPattern.variation;\n                }\n                else\n                    hierarchyRef = {\n                        name: expr.hierarchy,\n                        schema: exprPattern.entity.schema,\n                        entity: exprPattern.entity.entity,\n                    };\n                return {\n                    hierarchy: hierarchyRef,\n                    variation: variationRef\n                };\n            };\n            HierarchyExprPatternBuiler.instance = new HierarchyExprPatternBuiler();\n            return HierarchyExprPatternBuiler;\n        }(data.DefaultSQExprVisitor));\n        var FieldExprPattern;\n        (function (FieldExprPattern) {\n            function visit(expr, visitor) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(visitor, 'visitor');\n                var fieldExprPattern = expr instanceof data.SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\n                debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\n                if (fieldExprPattern.column)\n                    return visitColumn(fieldExprPattern.column, visitor);\n                if (fieldExprPattern.columnAggr)\n                    return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\n                if (fieldExprPattern.columnHierarchyLevelVariation)\n                    return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\n                if (fieldExprPattern.entity)\n                    return visitEntity(fieldExprPattern.entity, visitor);\n                if (fieldExprPattern.entityAggr)\n                    return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\n                if (fieldExprPattern.hierarchy)\n                    return visitHierarchy(fieldExprPattern.hierarchy, visitor);\n                if (fieldExprPattern.hierarchyLevel)\n                    return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\n                if (fieldExprPattern.hierarchyLevelAggr)\n                    return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\n                if (fieldExprPattern.measure)\n                    return visitMeasure(fieldExprPattern.measure, visitor);\n                if (fieldExprPattern.percentile)\n                    return visitPercentile(fieldExprPattern.percentile, visitor);\n                if (fieldExprPattern.percentOfGrandTotal)\n                    return visitPercentOfGrandTotal(fieldExprPattern.percentOfGrandTotal, visitor);\n                debug.assertFail('failed to visit a fieldExprPattern.');\n                return;\n            }\n            FieldExprPattern.visit = visit;\n            function visitColumn(column, visitor) {\n                debug.assertValue(column, 'column');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumn(column);\n            }\n            function visitColumnAggr(columnAggr, visitor) {\n                debug.assertValue(columnAggr, 'columnAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnAggr(columnAggr);\n            }\n            function visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation, visitor) {\n                debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\n            }\n            function visitEntity(entity, visitor) {\n                debug.assertValue(entity, 'entity');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntity(entity);\n            }\n            function visitEntityAggr(entityAggr, visitor) {\n                debug.assertValue(entityAggr, 'entityAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitEntityAggr(entityAggr);\n            }\n            function visitHierarchy(hierarchy, visitor) {\n                debug.assertValue(hierarchy, 'hierarchy');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchy(hierarchy);\n            }\n            function visitHierarchyLevel(hierarchyLevel, visitor) {\n                debug.assertValue(hierarchyLevel, 'hierarchyLevel');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevel(hierarchyLevel);\n            }\n            function visitHierarchyLevelAggr(hierarchyLevelAggr, visitor) {\n                debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\n            }\n            function visitMeasure(measure, visitor) {\n                debug.assertValue(measure, 'measure');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitMeasure(measure);\n            }\n            function visitPercentile(percentile, visitor) {\n                debug.assertValue(percentile, 'percentile');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitPercentile(percentile);\n            }\n            function visitPercentOfGrandTotal(percentOfGrandTotal, visitor) {\n                debug.assertValue(percentOfGrandTotal, 'percentOfGrandTotal');\n                debug.assertValue(visitor, 'visitor');\n                return visitor.visitPercentOfGrandTotal(percentOfGrandTotal);\n            }\n            function toColumnRefSQExpr(columnPattern) {\n                return SQExprBuilder.columnRef(SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar), columnPattern.name);\n            }\n            FieldExprPattern.toColumnRefSQExpr = toColumnRefSQExpr;\n            function getAggregate(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\n            }\n            FieldExprPattern.getAggregate = getAggregate;\n            function isAggregation(fieldExpr) {\n                debug.assertValue(fieldExpr, 'fieldExpr');\n                return visit(fieldExpr, FieldExprPatternIsAggregationVisitor.instance);\n            }\n            FieldExprPattern.isAggregation = isAggregation;\n            function hasFieldExprName(fieldExpr) {\n                return (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.measure) !== undefined;\n            }\n            FieldExprPattern.hasFieldExprName = hasFieldExprName;\n            function getPropertyName(fieldExpr) {\n                var column = (fieldExpr.column ||\n                    fieldExpr.columnAggr ||\n                    fieldExpr.measure);\n                if (column)\n                    return column.name;\n            }\n            FieldExprPattern.getPropertyName = getPropertyName;\n            function getHierarchyName(fieldExpr) {\n                var hierarchy = fieldExpr.hierarchy;\n                if (hierarchy)\n                    return hierarchy.name;\n            }\n            FieldExprPattern.getHierarchyName = getHierarchyName;\n            function getColumnRef(fieldExpr) {\n                if (fieldExpr.columnHierarchyLevelVariation)\n                    return fieldExpr.columnHierarchyLevelVariation.source;\n                return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\n            }\n            FieldExprPattern.getColumnRef = getColumnRef;\n            function getFieldExprName(fieldExpr) {\n                var name = getPropertyName(fieldExpr);\n                if (name)\n                    return name;\n                // In case it is an entity\n                return toFieldExprEntityPattern(fieldExpr).entity;\n            }\n            FieldExprPattern.getFieldExprName = getFieldExprName;\n            function toFieldExprEntityPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityPattern = toFieldExprEntityPattern;\n            function toFieldExprEntityItemPattern(fieldExpr) {\n                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\n            }\n            FieldExprPattern.toFieldExprEntityItemPattern = toFieldExprEntityItemPattern;\n            var FieldExprPatternAggregateVisitor = (function () {\n                function FieldExprPatternAggregateVisitor() {\n                }\n                FieldExprPatternAggregateVisitor.prototype.visitColumn = function (column) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return columnAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntity = function (entity) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return entityAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return hierarchyLevelAggr.aggregate;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitMeasure = function (measure) {\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitPercentile = function (percentile) {\n                    // NOTE: Percentile behaves like an aggregate (i.e., can be performed over numeric columns like a SUM), but\n                    // this function can't really convey that because percentile (intentionally) isn't in QueryAggregateFunction enum.\n                    // This should be revisited when we have UI support for the Percentile aggregate.\n                    return;\n                };\n                FieldExprPatternAggregateVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return data.SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr));\n                };\n                FieldExprPatternAggregateVisitor.instance = new FieldExprPatternAggregateVisitor();\n                return FieldExprPatternAggregateVisitor;\n            }());\n            var FieldExprPatternIsAggregationVisitor = (function () {\n                function FieldExprPatternIsAggregationVisitor() {\n                }\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumn = function (column) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitEntity = function (entity) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchy = function (hierarchy) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return false;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitMeasure = function (measure) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitPercentile = function (percentile) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return true;\n                };\n                FieldExprPatternIsAggregationVisitor.instance = new FieldExprPatternIsAggregationVisitor();\n                return FieldExprPatternIsAggregationVisitor;\n            }());\n            var FieldExprToEntityExprPatternBuilder = (function () {\n                function FieldExprToEntityExprPatternBuilder() {\n                }\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumn = function (column) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnAggr = function (columnAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntity = function (entity) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitEntityAggr = function (entityAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchy = function (hierarchy) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitMeasure = function (measure) {\n                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitPercentile = function (percentile) {\n                    return FieldExprPattern.visit(percentile.arg, this);\n                };\n                FieldExprToEntityExprPatternBuilder.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                    return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n                };\n                FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern = function (exprPattern) {\n                    debug.assertValue(exprPattern, 'exprPattern');\n                    var pattern = { schema: exprPattern.schema, entity: exprPattern.entity };\n                    if (exprPattern.entityVar) {\n                        pattern.entityVar = exprPattern.entityVar;\n                    }\n                    return pattern;\n                };\n                FieldExprToEntityExprPatternBuilder.instance = new FieldExprToEntityExprPatternBuilder();\n                return FieldExprToEntityExprPatternBuilder;\n            }());\n        })(FieldExprPattern = data.FieldExprPattern || (data.FieldExprPattern = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewAnalysis;\n    (function (DataViewAnalysis) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\n        (function (DataViewMappingMatchErrorCode) {\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooLarge\"] = 0] = \"conditionRangeTooLarge\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionRangeTooSmall\"] = 1] = \"conditionRangeTooSmall\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedMeasure\"] = 2] = \"conditionKindExpectedMeasure\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGrouping\"] = 3] = \"conditionKindExpectedGrouping\";\n            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode[\"conditionKindExpectedGroupingOrMeasure\"] = 4] = \"conditionKindExpectedGroupingOrMeasure\";\n        })(DataViewAnalysis.DataViewMappingMatchErrorCode || (DataViewAnalysis.DataViewMappingMatchErrorCode = {}));\n        var DataViewMappingMatchErrorCode = DataViewAnalysis.DataViewMappingMatchErrorCode;\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\n        function validateAndReshape(dataView, dataViewMappings) {\n            if (!dataViewMappings || dataViewMappings.length === 0)\n                return { dataView: dataView, isValid: true };\n            if (dataView) {\n                for (var _i = 0, dataViewMappings_3 = dataViewMappings; _i < dataViewMappings_3.length; _i++) {\n                    var dataViewMapping = dataViewMappings_3[_i];\n                    // Keep the original when possible.\n                    if (supports(dataView, dataViewMapping))\n                        return { dataView: dataView, isValid: true };\n                    if (dataViewMapping.categorical && dataView.categorical)\n                        return reshapeCategorical(dataView, dataViewMapping);\n                    if (dataViewMapping.tree && dataView.tree)\n                        return reshapeTree(dataView, dataViewMapping.tree);\n                    if (dataViewMapping.single && dataView.single)\n                        return reshapeSingle(dataView, dataViewMapping.single);\n                    if (dataViewMapping.table && dataView.table)\n                        return reshapeTable(dataView, dataViewMapping.table);\n                }\n            }\n            else if (powerbi.ScriptResultUtil.findScriptResult(dataViewMappings)) {\n                // Currently, PBI Service treats R Script Visuals as static images.\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\n                // to support the PBI Desktop scenario.\n                // This code will be removed once PBI Service fully supports R Script Visuals.\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\n                return { dataView: dataView, isValid: true };\n            }\n            return { isValid: false };\n        }\n        DataViewAnalysis.validateAndReshape = validateAndReshape;\n        function reshapeCategorical(dataView, dataViewMapping) {\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\n            var categoryRoleMapping = dataViewMapping.categorical;\n            var categorical = dataView.categorical;\n            if (!categorical)\n                return { isValid: false };\n            var rowCount;\n            if (categoryRoleMapping.rowCount) {\n                rowCount = categoryRoleMapping.rowCount.supported;\n                if (rowCount && rowCount.max) {\n                    var updated = void 0;\n                    var categories = categorical.categories;\n                    var maxRowCount = rowCount.max;\n                    var originalLength = undefined;\n                    if (categories) {\n                        for (var i = 0, len = categories.length; i < len; i++) {\n                            var category = categories[i];\n                            originalLength = category.values.length;\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                                // Row count too large: Trim it to fit.\n                                var updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\n                                updated = updated || { categories: [] };\n                                updated.categories.push({\n                                    source: category.source,\n                                    values: updatedCategories\n                                });\n                            }\n                        }\n                    }\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\n                        if (!originalLength)\n                            originalLength = categorical.values[0].values.length;\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\n                            updated = updated || {};\n                            updated.values = powerbi.data.DataViewTransform.createValueColumns();\n                            for (var i = 0, len = categorical.values.length; i < len; i++) {\n                                var column = categorical.values[i], updatedColumn = {\n                                    source: column.source,\n                                    values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\n                                };\n                                if (column.min !== undefined)\n                                    updatedColumn.min = column.min;\n                                if (column.max !== undefined)\n                                    updatedColumn.max = column.max;\n                                if (column.subtotal !== undefined)\n                                    updatedColumn.subtotal = column.subtotal;\n                                updated.values.push(updatedColumn);\n                            }\n                        }\n                    }\n                    if (updated) {\n                        dataView = {\n                            metadata: dataView.metadata,\n                            categorical: updated,\n                        };\n                    }\n                }\n            }\n            if (supportsCategorical(dataView, dataViewMapping))\n                return { dataView: dataView, isValid: true };\n            return null;\n        }\n        function reshapeSingle(dataView, singleRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (dataView.single)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTree(dataView, treeRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            // TODO: Need to implement the reshaping of Tree\n            var metadata = dataView.metadata;\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function reshapeTable(dataView, tableRoleMapping) {\n            debug.assertValue(dataView, 'dataView');\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (dataView.table)\n                return { dataView: dataView, isValid: true };\n            return { isValid: false };\n        }\n        function countGroups(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (!columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countGroups = countGroups;\n        function countMeasures(columns) {\n            var count = 0;\n            for (var i = 0, len = columns.length; i < len; i++) {\n                if (columns[i].isMeasure)\n                    ++count;\n            }\n            return count;\n        }\n        DataViewAnalysis.countMeasures = countMeasures;\n        /** Indicates whether the dataView conforms to the specified schema. */\n        function supports(dataView, roleMapping, usePreferredDataViewSchema) {\n            if (!roleMapping || !dataView)\n                return false;\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\n                return false;\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\n                return false;\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\n                return false;\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\n                return false;\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\n                return false;\n            return true;\n        }\n        DataViewAnalysis.supports = supports;\n        function supportsCategorical(dataView, categoryRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\n            var dataViewCategorical = dataView.categorical;\n            if (!dataViewCategorical)\n                return false;\n            // TODO: Disabling this implementation isn't right.\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\n            //    return false;\n            if (categoryRoleMapping.rowCount) {\n                var rowCount = categoryRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\n                    rowCount = categoryRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\n                        len = dataViewCategorical.values[0].values.length;\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\n                        len = dataViewCategorical.categories[0].values.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsSingle(dataViewSingle, singleRoleMapping) {\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\n            if (!dataViewSingle)\n                return false;\n            return true;\n        }\n        function supportsTree(dataView, treeRoleMapping) {\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\n            var metadata = dataView.metadata;\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\n        }\n        function supportsTable(dataViewTable, tableRoleMapping, usePreferredDataViewSchema) {\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\n            if (!dataViewTable)\n                return false;\n            if (tableRoleMapping.rowCount) {\n                var rowCount = tableRoleMapping.rowCount.supported;\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\n                    rowCount = tableRoleMapping.rowCount.preferred;\n                if (rowCount) {\n                    var len = 0;\n                    if (dataViewTable.rows && dataViewTable.rows.length)\n                        len = dataViewTable.rows.length;\n                    if (validateRange(len, rowCount) != null)\n                        return false;\n                }\n            }\n            return true;\n        }\n        function supportsScriptResult(dataView, scriptResultRoleMapping) {\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\n            if (!dataView)\n                return false;\n            if (!dataView.imageBase64)\n                return false;\n            return true;\n        }\n        /**\n         * Determines whether the value conforms to the range in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateRange(value, roleCondition, ignoreMin) {\n            debug.assertValue(value, 'value');\n            if (!roleCondition)\n                return;\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\n            if (roleCondition.max !== undefined && roleCondition.max < value)\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\n        }\n        DataViewAnalysis.validateRange = validateRange;\n        /**\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\n         * if so or an appropriate error code if not.\n         */\n        function validateKind(roleCondition, roleName, projections, roleKindByQueryRef) {\n            if (!roleCondition || roleCondition.kind === undefined) {\n                return;\n            }\n            var expectedKind = roleCondition.kind;\n            var roleCollection = projections[roleName];\n            if (roleCollection) {\n                var roleProjections = roleCollection.all();\n                for (var _i = 0, roleProjections_1 = roleProjections; _i < roleProjections_1.length; _i++) {\n                    var roleProjection = roleProjections_1[_i];\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\n                        switch (expectedKind) {\n                            case powerbi.VisualDataRoleKind.Measure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\n                            case powerbi.VisualDataRoleKind.Grouping:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\n                            case powerbi.VisualDataRoleKind.GroupingOrMeasure:\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\n                        }\n                    }\n                }\n            }\n        }\n        /** Determines the appropriate DataViewMappings for the projections. */\n        function chooseDataViewMappings(projections, mappings, roleKindByQueryRef, objectDescriptors, objectDefinitions) {\n            debug.assertValue(projections, 'projections');\n            debug.assertAnyValue(mappings, 'mappings');\n            var supportedMappings = [];\n            var errors = [];\n            if (!_.isEmpty(mappings)) {\n                for (var mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\n                    var mapping = mappings[mappingIndex], mappingConditions = mapping.conditions, requiredProperties = mapping.requiredProperties;\n                    var allPropertiesValid = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\n                    var conditionsMet = [];\n                    if (!_.isEmpty(mappingConditions)) {\n                        for (var conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\n                            var condition = mappingConditions[conditionIndex];\n                            var currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\n                            if (!_.isEmpty(currentConditionErrors)) {\n                                for (var _i = 0, currentConditionErrors_1 = currentConditionErrors; _i < currentConditionErrors_1.length; _i++) {\n                                    var error = currentConditionErrors_1[_i];\n                                    error.mappingIndex = mappingIndex;\n                                    error.conditionIndex = conditionIndex;\n                                    errors.push(error);\n                                }\n                            }\n                            else\n                                conditionsMet.push(condition);\n                        }\n                    }\n                    else {\n                        conditionsMet.push({});\n                    }\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\n                        var supportedMapping = _.cloneDeep(mapping);\n                        var updatedConditions = _.filter(conditionsMet, function (condition) { return Object.keys(condition).length > 0; });\n                        if (!_.isEmpty(updatedConditions))\n                            supportedMapping.conditions = updatedConditions;\n                        supportedMappings.push(supportedMapping);\n                    }\n                }\n            }\n            return {\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\n            };\n        }\n        DataViewAnalysis.chooseDataViewMappings = chooseDataViewMappings;\n        function checkForConditionErrors(projections, condition, roleKindByQueryRef) {\n            debug.assertValue(projections, 'projections');\n            debug.assertValue(condition, 'condition');\n            var conditionRoles = Object.keys(condition);\n            var errors = [];\n            for (var i = 0, len = conditionRoles.length; i < len; i++) {\n                var roleName = conditionRoles[i], isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs), roleCondition = condition[roleName];\n                var roleCount = getPropertyCount(roleName, projections, isDrillable);\n                var rangeError = validateRange(roleCount, roleCondition);\n                if (rangeError != null) {\n                    errors.push({\n                        code: rangeError,\n                        roleName: roleName,\n                    });\n                }\n                var kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\n                if (kindError != null) {\n                    errors.push({\n                        code: kindError,\n                        roleName: roleName,\n                    });\n                }\n            }\n            return errors;\n        }\n        function areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions) {\n            if (_.isEmpty(requiredProperties))\n                return true;\n            if (!objectDescriptors || !objectDefinitions)\n                return false;\n            var staticEvalContext = powerbi.data.createStaticEvalContext();\n            return _.every(requiredProperties, function (requiredProperty) {\n                var objectDescriptorValue = null;\n                var objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\n                if (objectDescriptorProperty)\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\n                var objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\n                if (!objectDescriptorValue || !objectDefinitionValue)\n                    return false;\n                return powerbi.data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\n            });\n        }\n        function getPropertyCount(roleName, projections, useActiveIfAvailable) {\n            debug.assertValue(roleName, 'roleName');\n            debug.assertValue(projections, 'projections');\n            var projectionsForRole = projections[roleName];\n            if (projectionsForRole) {\n                if (useActiveIfAvailable)\n                    return 1;\n                return projectionsForRole.all().length;\n            }\n            return 0;\n        }\n        DataViewAnalysis.getPropertyCount = getPropertyCount;\n        function hasSameCategoryIdentity(dataView1, dataView2) {\n            if (dataView1\n                && dataView2\n                && dataView1.categorical\n                && dataView2.categorical) {\n                var dv1Categories = dataView1.categorical.categories;\n                var dv2Categories = dataView2.categorical.categories;\n                if (dv1Categories\n                    && dv2Categories\n                    && dv1Categories.length === dv2Categories.length) {\n                    for (var i = 0, len = dv1Categories.length; i < len; i++) {\n                        var dv1Identity = dv1Categories[i].identity;\n                        var dv2Identity = dv2Categories[i].identity;\n                        var dv1Length = getLengthOptional(dv1Identity);\n                        if (dv1Length !== getLengthOptional(dv2Identity))\n                            return false;\n                        for (var j = 0; j < dv1Length; j++) {\n                            if (!powerbi.DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\n                                return false;\n                        }\n                    }\n                    return true;\n                }\n            }\n            return false;\n        }\n        DataViewAnalysis.hasSameCategoryIdentity = hasSameCategoryIdentity;\n        function getLengthOptional(identity) {\n            if (identity)\n                return identity.length;\n            return 0;\n        }\n        function areMetadataColumnsEquivalent(column1, column2) {\n            if (!column1 && !column2)\n                return true;\n            if (!column1 || !column2)\n                return false;\n            if (column1.displayName !== column2.displayName)\n                return false;\n            if (column1.queryName !== column2.queryName)\n                return false;\n            if (column1.isMeasure !== column2.isMeasure)\n                return false;\n            if (column1.type !== column2.type)\n                return false;\n            if (column1.sort !== column2.sort)\n                return false;\n            return true;\n        }\n        DataViewAnalysis.areMetadataColumnsEquivalent = areMetadataColumnsEquivalent;\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\n        function isMetadataEquivalent(metadata1, metadata2) {\n            if (!metadata1 && !metadata2)\n                return true;\n            if (!metadata1 || !metadata2)\n                return false;\n            var previousColumnsLength = metadata1.columns.length;\n            var newColumnsLength = metadata2.columns.length;\n            if (previousColumnsLength !== newColumnsLength)\n                return false;\n            for (var i = 0; i < newColumnsLength; i++) {\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\n                    return false;\n            }\n            return true;\n        }\n        DataViewAnalysis.isMetadataEquivalent = isMetadataEquivalent;\n    })(DataViewAnalysis = powerbi.DataViewAnalysis || (powerbi.DataViewAnalysis = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var Lazy = jsCommon.Lazy;\n        var DataViewRoleWildcard;\n        (function (DataViewRoleWildcard) {\n            function fromRoles(roles) {\n                return new DataViewRoleWildcardImpl(roles);\n            }\n            DataViewRoleWildcard.fromRoles = fromRoles;\n            function equals(firstRoleWildcard, secondRoleWildcard) {\n                return firstRoleWildcard.key &&\n                    secondRoleWildcard.key &&\n                    firstRoleWildcard.key === secondRoleWildcard.key &&\n                    ArrayExtensions.sequenceEqual(firstRoleWildcard.roles, secondRoleWildcard.roles, function (role1, role2) { return role1 === role2; });\n            }\n            DataViewRoleWildcard.equals = equals;\n            var DataViewRoleWildcardImpl = (function () {\n                function DataViewRoleWildcardImpl(roles) {\n                    var _this = this;\n                    debug.assertNonEmpty(roles, 'roles');\n                    this._roles = roles;\n                    this._key = new Lazy(function () { return JSON.stringify(_this.roles); });\n                }\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"roles\", {\n                    get: function () {\n                        return this._roles;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewRoleWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewRoleWildcardImpl;\n            }());\n        })(DataViewRoleWildcard = data.DataViewRoleWildcard || (data.DataViewRoleWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var DataViewScopeIdentity;\n    (function (DataViewScopeIdentity) {\n        /** Compares the two DataViewScopeIdentity values for equality. */\n        function equals(x, y, ignoreCase) {\n            // Normalize falsy to null\n            x = x || null;\n            y = y || null;\n            if (x === y)\n                return true;\n            if (!x !== !y)\n                return false;\n            debug.assertValue(x, 'x');\n            debug.assertValue(y, 'y');\n            return data.SQExpr.equals(x.expr, y.expr, ignoreCase);\n        }\n        DataViewScopeIdentity.equals = equals;\n        function filterFromIdentity(identities, isNot) {\n            if (_.isEmpty(identities))\n                return;\n            var exprs = [];\n            for (var _i = 0, identities_1 = identities; _i < identities_1.length; _i++) {\n                var identity = identities_1[_i];\n                exprs.push(identity.expr);\n            }\n            return filterFromExprs(exprs, isNot);\n        }\n        DataViewScopeIdentity.filterFromIdentity = filterFromIdentity;\n        function filterFromExprs(orExprs, isNot) {\n            if (_.isEmpty(orExprs))\n                return;\n            var resultExpr;\n            for (var _i = 0, orExprs_1 = orExprs; _i < orExprs_1.length; _i++) {\n                var orExpr = orExprs_1[_i];\n                var inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\n                if (resultExpr)\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\n                else\n                    resultExpr = inExpr || orExpr;\n            }\n            if (resultExpr) {\n                if (isNot)\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\n            }\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\n        }\n        DataViewScopeIdentity.filterFromExprs = filterFromExprs;\n    })(DataViewScopeIdentity = powerbi.DataViewScopeIdentity || (powerbi.DataViewScopeIdentity = {}));\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        function createDataViewScopeIdentity(expr) {\n            return new DataViewScopeIdentityImpl(expr);\n        }\n        data.createDataViewScopeIdentity = createDataViewScopeIdentity;\n        var DataViewScopeIdentityImpl = (function () {\n            function DataViewScopeIdentityImpl(expr) {\n                debug.assertValue(expr, 'expr');\n                this._expr = expr;\n                this._key = new Lazy(function () { return data.SQExprShortSerializer.serialize(expr); });\n            }\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"expr\", {\n                get: function () {\n                    return this._expr;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            Object.defineProperty(DataViewScopeIdentityImpl.prototype, \"key\", {\n                get: function () {\n                    return this._key.getValue();\n                },\n                enumerable: true,\n                configurable: true\n            });\n            return DataViewScopeIdentityImpl;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Lazy = jsCommon.Lazy;\n        var DataViewScopeWildcard;\n        (function (DataViewScopeWildcard) {\n            function matches(wildcard, instance) {\n                var instanceExprs = data.ScopeIdentityExtractor.getKeys(instance.expr);\n                if (!instanceExprs)\n                    return false;\n                return data.SQExprUtils.sequenceEqual(wildcard.exprs, instanceExprs);\n            }\n            DataViewScopeWildcard.matches = matches;\n            function equals(firstScopeWildcard, secondScopeWildcard) {\n                return firstScopeWildcard.key === secondScopeWildcard.key &&\n                    data.SQExprUtils.sequenceEqual(firstScopeWildcard.exprs, secondScopeWildcard.exprs);\n            }\n            DataViewScopeWildcard.equals = equals;\n            function fromExprs(exprs) {\n                return new DataViewScopeWildcardImpl(exprs);\n            }\n            DataViewScopeWildcard.fromExprs = fromExprs;\n            var DataViewScopeWildcardImpl = (function () {\n                function DataViewScopeWildcardImpl(exprs) {\n                    debug.assertValue(exprs, 'exprs');\n                    this._exprs = exprs;\n                    this._key = new Lazy(function () { return data.SQExprShortSerializer.serializeArray(exprs); });\n                }\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"exprs\", {\n                    get: function () {\n                        return this._exprs;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                Object.defineProperty(DataViewScopeWildcardImpl.prototype, \"key\", {\n                    get: function () {\n                        return this._key.getValue();\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n                return DataViewScopeWildcardImpl;\n            }());\n        })(DataViewScopeWildcard = data.DataViewScopeWildcard || (data.DataViewScopeWildcard = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createColorAllocatorCache() {\n            return new ColorAllocatorProvider();\n        }\n        data.createColorAllocatorCache = createColorAllocatorCache;\n        var ColorAllocatorProvider = (function () {\n            function ColorAllocatorProvider() {\n                this.cache = [];\n            }\n            ColorAllocatorProvider.prototype.get = function (key) {\n                debug.assertValue(key, 'key');\n                for (var _i = 0, _a = this.cache; _i < _a.length; _i++) {\n                    var entry = _a[_i];\n                    if (entry.key === key)\n                        return entry.allocator;\n                }\n            };\n            ColorAllocatorProvider.prototype.register = function (key, colorAllocator) {\n                debug.assertValue(key, 'key');\n                debug.assertValue(colorAllocator, 'colorAllocator');\n                debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\n                this.cache.push({\n                    key: key,\n                    allocator: colorAllocator,\n                });\n                return this;\n            };\n            return ColorAllocatorProvider;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewRegression;\n        (function (DataViewRegression) {\n            // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\n            // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\n            var regressionXQueryName = 'RegressionX';\n            var regressionSeriesQueryName = 'RegressionSeries';\n            DataViewRegression.regressionYQueryName = 'RegressionY';\n            function run(options) {\n                debug.assertValue(options, 'options');\n                var dataViewMappings = options.dataViewMappings;\n                var visualDataViews = options.visualDataViews;\n                var dataRoles = options.dataRoles;\n                var objectDescriptors = options.objectDescriptors;\n                var objectDefinitions = options.objectDefinitions;\n                var colorAllocatorFactory = options.colorAllocatorFactory;\n                var transformSelects = options.transformSelects;\n                var projectionActiveItems = options.projectionActiveItems;\n                var metadata = options.metadata;\n                if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\n                    // compute linear regression line if applicable\n                    var roleKindByQueryRef = data.DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\n                    var projections = data.DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\n                    if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\n                        return visualDataViews;\n                    var applicableDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\n                    if (applicableDataViewMappings) {\n                        var regressionDataViewMapping = _.find(applicableDataViewMappings, function (dataViewMapping) {\n                            return dataViewMapping.usage && dataViewMapping.usage.regression;\n                        });\n                        if (regressionDataViewMapping) {\n                            var regressionDataViews = [];\n                            for (var _i = 0, visualDataViews_1 = visualDataViews; _i < visualDataViews_1.length; _i++) {\n                                var visualDataView = visualDataViews_1[_i];\n                                var regressionDataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                                if (regressionDataView)\n                                    regressionDataViews.push(regressionDataView);\n                            }\n                            if (!_.isEmpty(regressionDataViews))\n                                visualDataViews.push.apply(visualDataViews, regressionDataViews);\n                        }\n                    }\n                }\n                return visualDataViews;\n            }\n            DataViewRegression.run = run;\n            /**\n             * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\n             * It works on scalar axis only.\n             * The algorithm is as follows\n             *\n             * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\n             * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\n             * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\n             * If highlights values are present, repeat steps 2 & 3 using highlight values.\n             * 4. Create the new dataView using the points computed above\n             */\n            function linearRegressionTransform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\n                debug.assertValue(dataRoles, 'dataRoles');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                if (!sourceDataView.categorical)\n                    return;\n                // Step 1\n                var xColumns = getColumnsForCartesianRoleKind(0 /* X */, sourceDataView.categorical, dataRoles);\n                var yColumns = getColumnsForCartesianRoleKind(1 /* Y */, sourceDataView.categorical, dataRoles);\n                if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\n                    return;\n                var xColumnSource = xColumns[0].source;\n                var yColumnSource = yColumns[0].source;\n                var combineSeries = true;\n                if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\n                    var regressionUsage = regressionDataViewMapping.usage.regression;\n                    var combineSeriesPropertyId = regressionUsage['combineSeries'];\n                    if (combineSeriesPropertyId) {\n                        combineSeries = powerbi.DataViewObjects.getValue(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\n                    }\n                }\n                // Step 2\n                var dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\n                var lineDefSet = calculateLineDefinitions(dataPointsBySeries);\n                var xMin = lineDefSet.xMin;\n                var xMax = lineDefSet.xMax;\n                var shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\n                var highlightsLineDefSet;\n                if (shouldComputeHightlights) {\n                    var highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\n                    highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\n                    if (highlightsLineDefSet) {\n                        xMin = _.min([xMin, highlightsLineDefSet.xMin]);\n                        xMax = _.max([xMax, highlightsLineDefSet.xMax]);\n                    }\n                    else {\n                        shouldComputeHightlights = false;\n                    }\n                }\n                // Step 3\n                var valuesByTrend = [];\n                for (var _i = 0, _a = lineDefSet.lineDefs; _i < _a.length; _i++) {\n                    var trend = _a[_i];\n                    valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                }\n                var highlightsByTrend;\n                if (shouldComputeHightlights) {\n                    highlightsByTrend = [];\n                    for (var _b = 0, _c = highlightsLineDefSet.lineDefs; _b < _c.length; _b++) {\n                        var trend = _c[_b];\n                        highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\n                    }\n                }\n                // Step 4\n                var groupValues;\n                if (combineSeries) {\n                    groupValues = ['combinedRegressionSeries'];\n                }\n                else {\n                    // If we are producing a trend line per series we need to maintain the group identities so that we can map between the \n                    // trend line and the original series (to match the color for example).\n                    if (sourceDataView.categorical.values.source) {\n                        // Source data view has dynamic series.\n                        var groups = sourceDataView.categorical.values.grouped();\n                        groupValues = _.map(groups, function (group) { return group.name; });\n                    }\n                    else {\n                        // Source data view has static or no series.\n                        groupValues = _.map(yColumns, function (column) { return column.source.queryName; });\n                    }\n                }\n                // Step 5\n                var regressionDataView = createRegressionDataView(xColumnSource, yColumnSource, groupValues, [xMin, xMax], valuesByTrend, highlightsByTrend, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\n                return regressionDataView;\n            }\n            DataViewRegression.linearRegressionTransform = linearRegressionTransform;\n            function calculateLineDefinitions(dataPointsBySeries) {\n                var xMin;\n                var xMax;\n                var lineDefs = [];\n                for (var _i = 0, dataPointsBySeries_1 = dataPointsBySeries; _i < dataPointsBySeries_1.length; _i++) {\n                    var dataPointSet = dataPointsBySeries_1[_i];\n                    var unsortedXValues = dataPointSet.xValues;\n                    var unsortedYValues = dataPointSet.yValues;\n                    if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\n                        return;\n                    // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\n                    var xDataType = getDataType(unsortedXValues);\n                    if (!xDataType)\n                        return;\n                    var yDataType = getDataType(unsortedYValues);\n                    if (!yDataType)\n                        return;\n                    var sortedDataPointSet = sortValues(unsortedXValues, unsortedYValues);\n                    var minCategoryValue = sortedDataPointSet.xValues[0];\n                    var maxCategoryValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\n                    var lineDef = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\n                    xMin = _.min([xMin, minCategoryValue]);\n                    xMax = _.max([xMax, maxCategoryValue]);\n                    lineDefs.push(lineDef);\n                }\n                return {\n                    lineDefs: lineDefs,\n                    xMin: xMin,\n                    xMax: xMax,\n                };\n            }\n            function getColumnsForCartesianRoleKind(roleKind, categorical, roles) {\n                debug.assertValue(roleKind, 'roleKind');\n                debug.assertValue(categorical, 'categorical');\n                var columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n                var categories = categorical.categories;\n                if (_.isEmpty(categories))\n                    return;\n                debug.assert(categories.length === 1, 'composite category columns not supported');\n                var categoryColumn = categories[0];\n                columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\n                if (!_.isEmpty(columns))\n                    return columns;\n            }\n            function getColumnsWithRoleKind(roleKind, columns, roles) {\n                if (_.isEmpty(columns))\n                    return;\n                return _.filter(columns, function (column) {\n                    var _loop_1 = function(roleName) {\n                        if (!column.source.roles[roleName])\n                            return \"continue\";\n                        var role = _.find(roles, function (role) { return role.name === roleName; });\n                        if (role && role.cartesianKind === roleKind)\n                            return { value: true };\n                    };\n                    for (var roleName in column.source.roles) {\n                        var state_1 = _loop_1(roleName);\n                        if (typeof state_1 === \"object\") return state_1.value;\n                        if (state_1 === \"continue\") continue;\n                    }\n                    return false;\n                });\n            }\n            function getDataType(values) {\n                var firstNonNull = _.find(values, function (value) { return value != null; });\n                if (firstNonNull == null)\n                    return;\n                var dataType = typeof firstNonNull;\n                if (_.some(values, function (value) { return value != null && typeof value !== dataType; }))\n                    return;\n                return dataType;\n            }\n            function sortValues(unsortedXValues, unsortedYValues) {\n                debug.assertValue(unsortedXValues, 'unsortedXValues');\n                debug.assertValue(unsortedYValues, 'unsortedYValues');\n                var zippedValues = _.zip(unsortedXValues, unsortedYValues);\n                var _a = _.chain(zippedValues)\n                    .filter(function (valuePair) { return valuePair[0] != null && valuePair[1] != null; })\n                    .sortBy(function (valuePair) { return valuePair[0]; })\n                    .unzip()\n                    .value(), xValues = _a[0], yValues = _a[1];\n                return {\n                    xValues: xValues,\n                    yValues: yValues\n                };\n            }\n            /**\n             * Computes a line definition using linear regression.\n             *   xBar: average of X values, yBar: average of Y values\n             *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\n             *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\n             *   Slope: ssXY / ssXX\n             *   Intercept: yBar - xBar * slope\n             */\n            function computeRegressionLine(xValues, yValues) {\n                debug.assertValue(xValues, 'xValues');\n                debug.assertValue(yValues, 'yValues');\n                var xBar = _.sum(xValues) / xValues.length;\n                var yBar = _.sum(yValues) / yValues.length;\n                var ssXX = _.chain(xValues)\n                    .map(function (x) {\n                    return Math.pow((x - xBar), 2);\n                })\n                    .sum();\n                var ssXY = _.chain(xValues)\n                    .map(function (x, i) {\n                    return (x - xBar) * (yValues[i] - yBar);\n                })\n                    .sum();\n                var slope = ssXY / ssXX;\n                var intercept = yBar - (xBar * slope);\n                return {\n                    slope: slope,\n                    intercept: intercept\n                };\n            }\n            function computeLineYValues(lineDef, x1, x2) {\n                return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\n            }\n            function getValuesFromColumn(column, preferHighlights) {\n                if (preferHighlights) {\n                    // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\n                    var valueColumn = column;\n                    if (valueColumn.highlights) {\n                        return valueColumn.highlights;\n                    }\n                }\n                return column.values;\n            }\n            function getDataPointsBySeries(xColumns, yColumns, combineSeries, preferHighlights) {\n                var dataPointsBySeries = [];\n                var xValueArray = _.map(xColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var seriesYValues = _.map(yColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });\n                var multipleXValueColumns = xColumns.length > 1;\n                for (var i = 0; i < seriesYValues.length; i++) {\n                    var xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\n                    var yValues = seriesYValues[i];\n                    if (combineSeries && dataPointsBySeries.length > 0) {\n                        dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\n                        dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\n                    }\n                    else {\n                        dataPointsBySeries.push({\n                            xValues: xValues,\n                            yValues: yValues,\n                        });\n                    }\n                }\n                return dataPointsBySeries;\n            }\n            function createRegressionDataView(xColumnSource, yColumnSource, groupValues, categories, values, highlights, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {\n                debug.assertValue(xColumnSource, 'xColumnSource');\n                debug.assertValue(yColumnSource, 'yColumnSource');\n                debug.assertValue(categories, 'categories');\n                debug.assertValue(values, 'values');\n                debug.assertValue(sourceDataView, 'sourceDataView');\n                debug.assertValue(objectDescriptors, 'objectDescriptors');\n                debug.assertValue(objectDefinitions, 'objectDefinitions');\n                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\n                debug.assertAnyValue(highlights, 'highlights');\n                debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\n                var xRole = regressionDataViewMapping.categorical.categories.for.in;\n                var grouped = regressionDataViewMapping.categorical.values.group;\n                var yRole;\n                var seriesRole;\n                if (grouped && !_.isEmpty(grouped.select)) {\n                    yRole = grouped.select[0].for ?\n                        grouped.select[0].for.in :\n                        grouped.select[0].bind.to;\n                    seriesRole = grouped.by;\n                }\n                if (!yRole || !seriesRole)\n                    return;\n                var categoricalRoles = (_a = {}, _a[xRole] = true, _a);\n                var valueRoles = (_b = {}, _b[yRole] = true, _b);\n                var seriesRoles = (_c = {}, _c[seriesRole] = true, _c);\n                var valuesBySeries = [];\n                for (var index in values) {\n                    var seriesData = {\n                        values: values[index],\n                    };\n                    if (highlights)\n                        seriesData.highlights = highlights[index];\n                    valuesBySeries.push([seriesData]);\n                }\n                var regressionDataView = data.createCategoricalDataViewBuilder()\n                    .withCategory({\n                    source: {\n                        displayName: xColumnSource.displayName,\n                        queryName: regressionXQueryName,\n                        type: xColumnSource.type,\n                        isMeasure: false,\n                        roles: categoricalRoles\n                    },\n                    values: categories,\n                    identityFrom: {\n                        fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\n                    },\n                })\n                    .withGroupedValues({\n                    groupColumn: {\n                        source: {\n                            displayName: yColumnSource.displayName + 'Regression',\n                            queryName: regressionSeriesQueryName,\n                            type: yColumnSource.type,\n                            isMeasure: yColumnSource.isMeasure,\n                            roles: seriesRoles\n                        },\n                        values: groupValues,\n                        identityFrom: {\n                            fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\n                        }\n                    },\n                    valueColumns: [{\n                            source: {\n                                displayName: yColumnSource.displayName,\n                                queryName: DataViewRegression.regressionYQueryName,\n                                type: yColumnSource.type,\n                                isMeasure: yColumnSource.isMeasure,\n                                roles: valueRoles\n                            },\n                        }],\n                    data: valuesBySeries\n                })\n                    .build();\n                data.DataViewTransform.transformObjects(regressionDataView, 1 /* Categorical */, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\n                return regressionDataView;\n                var _a, _b, _c;\n            }\n            function hasHighlightValues(columns) {\n                return _.any(columns, function (column) {\n                    var valueColumn = column;\n                    return valueColumn.highlights != null;\n                });\n            }\n        })(DataViewRegression = data.DataViewRegression || (data.DataViewRegression = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var DataViewSelectTransform;\n        (function (DataViewSelectTransform) {\n            /** Convert selection info to projections */\n            function projectionsFromSelects(selects, projectionActiveItems) {\n                debug.assertAnyValue(selects, \"selects\");\n                debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\n                var projections = {};\n                for (var _i = 0, selects_1 = selects; _i < selects_1.length; _i++) {\n                    var select = selects_1[_i];\n                    var roles = select.roles;\n                    if (!roles)\n                        continue;\n                    for (var roleName in roles) {\n                        if (roles[roleName]) {\n                            var qp = projections[roleName];\n                            if (!qp)\n                                qp = projections[roleName] = new data.QueryProjectionCollection([]);\n                            qp.all().push({ queryRef: select.queryName });\n                            if (projectionActiveItems && projectionActiveItems[roleName])\n                                qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], function (activeItem) { return activeItem.queryRef; });\n                        }\n                    }\n                }\n                return projections;\n            }\n            DataViewSelectTransform.projectionsFromSelects = projectionsFromSelects;\n            /** Use selections and metadata to fashion query role kinds */\n            function createRoleKindFromMetadata(selects, metadata) {\n                var roleKindByQueryRef = {};\n                for (var _i = 0, _a = metadata.columns; _i < _a.length; _i++) {\n                    var column = _a[_i];\n                    if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\n                        continue;\n                    var select = selects[column.index];\n                    if (select) {\n                        var queryRef = select.queryName;\n                        if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\n                            roleKindByQueryRef[queryRef] = column.isMeasure ? powerbi.VisualDataRoleKind.Measure : powerbi.VisualDataRoleKind.Grouping;\n                        }\n                    }\n                }\n                return roleKindByQueryRef;\n            }\n            DataViewSelectTransform.createRoleKindFromMetadata = createRoleKindFromMetadata;\n        })(DataViewSelectTransform = data.DataViewSelectTransform || (data.DataViewSelectTransform = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createCategoricalEvalContext(colorAllocatorProvider, dataViewCategorical) {\n            return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\n        }\n        data.createCategoricalEvalContext = createCategoricalEvalContext;\n        var CategoricalEvalContext = (function () {\n            function CategoricalEvalContext(colorAllocatorProvider, dataView) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.columnsByRole = {};\n            }\n            CategoricalEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            CategoricalEvalContext.prototype.getExprValue = function (expr) {\n                return;\n            };\n            CategoricalEvalContext.prototype.getRoleValue = function (roleName) {\n                var columnsByRole = this.columnsByRole;\n                var column = columnsByRole[roleName];\n                if (!column)\n                    column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\n                if (!column)\n                    return;\n                var index = this.index;\n                if (index != null)\n                    return column.values[this.index];\n            };\n            CategoricalEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.index = index;\n            };\n            return CategoricalEvalContext;\n        }());\n        function findRuleInputColumn(dataViewCategorical, inputRole) {\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\n            return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\n                findRuleInputInColumns(dataViewCategorical.categories, inputRole);\n        }\n        function findRuleInputInColumns(columns, inputRole) {\n            debug.assertAnyValue(columns, 'columns');\n            if (!columns)\n                return;\n            for (var _i = 0, columns_7 = columns; _i < columns_7.length; _i++) {\n                var column = columns_7[_i];\n                var roles = column.source.roles;\n                if (!roles || !roles[inputRole])\n                    continue;\n                return column;\n            }\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createTableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms) {\n            return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\n        }\n        data.createTableEvalContext = createTableEvalContext;\n        var TableEvalContext = (function () {\n            function TableEvalContext(colorAllocatorProvider, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorProvider = colorAllocatorProvider;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            TableEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorProvider.get(expr);\n            };\n            TableEvalContext.prototype.getExprValue = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var rowIdx = this.rowIdx;\n                if (rowIdx == null)\n                    return;\n                return data.getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\n            };\n            TableEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            TableEvalContext.prototype.setCurrentRowIndex = function (index) {\n                debug.assertValue(index, 'index');\n                this.rowIdx = index;\n            };\n            return TableEvalContext;\n        }());\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var RuleEvaluation = (function () {\n            function RuleEvaluation() {\n            }\n            // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\n            RuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\n            };\n            return RuleEvaluation;\n        }());\n        data.RuleEvaluation = RuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ColorRuleEvaluation = (function (_super) {\n            __extends(ColorRuleEvaluation, _super);\n            function ColorRuleEvaluation(inputRole, allocator) {\n                debug.assertValue(inputRole, 'inputRole');\n                debug.assertValue(allocator, 'allocator');\n                _super.call(this);\n                this.inputRole = inputRole;\n                this.allocator = allocator;\n            }\n            ColorRuleEvaluation.prototype.evaluate = function (evalContext) {\n                debug.assertValue(evalContext, 'evalContext');\n                var value = evalContext.getRoleValue(this.inputRole);\n                if (value !== undefined)\n                    return this.allocator.color(value);\n            };\n            return ColorRuleEvaluation;\n        }(data.RuleEvaluation));\n        data.ColorRuleEvaluation = ColorRuleEvaluation;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var inherit = powerbi.Prototype.inherit;\n            var inheritSingle = powerbi.Prototype.inheritSingle;\n            var ArrayExtensions = jsCommon.ArrayExtensions;\n            var DataViewMatrixUtils;\n            (function (DataViewMatrixUtils) {\n                /**\n                 * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the\n                 * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the\n                 * particular leaf node in the context of this forEachLeafNode(...) invocation.\n                 *\n                 * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\n                 *\n                 * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified\n                 * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\n                 * then treePath will be an array of length 1 containing that very node.\n                 *\n                 * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\n                 * If your callback needs to retain a copy of the treePath, please clone the array before returning.\n                 */\n                function forEachLeafNode(rootNodes, callback) {\n                    debug.assertAnyValue(rootNodes, 'rootNodes');\n                    debug.assertValue(callback, 'callback');\n                    // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\n                    // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \n                    // for the fact that all the properties on DataViewMatrixNode are optional...\n                    if (rootNodes) {\n                        if (isNodeArray(rootNodes)) {\n                            var index = 0;\n                            for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {\n                                var rootNode = rootNodes_1[_i];\n                                if (rootNode) {\n                                    index = forEachLeafNodeRecursive(rootNode, index, [], callback);\n                                }\n                            }\n                        }\n                        else {\n                            forEachLeafNodeRecursive(rootNodes, 0, [], callback);\n                        }\n                    }\n                }\n                DataViewMatrixUtils.forEachLeafNode = forEachLeafNode;\n                function isNodeArray(nodeOrNodeArray) {\n                    return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\n                }\n                /**\n                 * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\n                 * Returns the index for the next node after the last node that this function invokes callback with.\n                 *\n                 * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\n                 */\n                function forEachLeafNodeRecursive(matrixNode, nextIndex, treePath, callback) {\n                    debug.assertValue(matrixNode, 'matrixNode');\n                    debug.assertValue(treePath, 'treePath');\n                    debug.assertValue(callback, 'callback');\n                    // If treePath already contains matrixNode, then either one of the following errors has happened:\n                    // 1. the caller code mistakenly added matrixNode to treePath, or\n                    // 2. the callback modified treePath by adding a node to it, or\n                    // 3. the matrix hierarchy contains a cyclical node reference.');\n                    debug.assert(!_.contains(treePath, matrixNode), 'pre-condition: treePath must not already contain matrixNode');\n                    treePath.push(matrixNode);\n                    if (_.isEmpty(matrixNode.children)) {\n                        callback(matrixNode, nextIndex, treePath);\n                        nextIndex++;\n                    }\n                    else {\n                        var children = matrixNode.children;\n                        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {\n                            var nextChild = children_1[_i];\n                            if (nextChild) {\n                                nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\n                            }\n                        }\n                    }\n                    debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\n                    treePath.pop();\n                    return nextIndex;\n                }\n                /**\n                 * Returned an object tree where each node and its children property are inherited from the specified node\n                 * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\n                 *\n                 * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array\n                 * property, i.e. its children property is the same array object referenced in the input node's object tree.\n                 *\n                 * @param node The input node with the hierarchy object tree.\n                 * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\n                 * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is\n                 * not already an inherited object. Same goes for the node's children property.  This is useful for creating\n                 * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for\n                 * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains\n                 * inherited objects.\n                 */\n                function inheritMatrixNodeHierarchy(node, deepestLevelToInherit, useInheritSingle) {\n                    debug.assertValue(node, 'node');\n                    debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\n                    debug.assertValue(useInheritSingle, 'useInheritSingle');\n                    var returnNode = node;\n                    // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\n                    // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\n                    // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\n                    //  {\n                    //    \"level\": 0,\n                    //    \"isSubtotal\": true,\n                    //    \"children\": [\n                    //      { \"level\": 2, \"isSubtotal\": true },\n                    //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\n                    //    ]\n                    //  }\n                    var isRootNode = _.isUndefined(node.level);\n                    var shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\n                    if (shouldInheritCurrentNode) {\n                        var inheritFunc = useInheritSingle ? inheritSingle : inherit;\n                        var inheritedNode = inheritFunc(node);\n                        var shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\n                        if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\n                            inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\n                            for (var i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\n                                inheritedNode.children[i] =\n                                    inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\n                            }\n                        }\n                        returnNode = inheritedNode;\n                    }\n                    return returnNode;\n                }\n                DataViewMatrixUtils.inheritMatrixNodeHierarchy = inheritMatrixNodeHierarchy;\n                /**\n                 * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\n                 * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\n                 * Year === 2016, Quarter === 'Qtr 1', Month === 1.\n                 *\n                 * Returns false if the specified matrixOrHierarchy does not contain any composite group,\n                 * or if matrixOrHierarchy is null or undefined.\n                 */\n                function containsCompositeGroup(matrixOrHierarchy) {\n                    debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\n                    var hasCompositeGroup = false;\n                    if (matrixOrHierarchy) {\n                        if (isMatrix(matrixOrHierarchy)) {\n                            hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\n                                containsCompositeGroup(matrixOrHierarchy.columns);\n                        }\n                        else {\n                            var hierarchyLevels = matrixOrHierarchy.levels;\n                            if (!_.isEmpty(hierarchyLevels)) {\n                                for (var _i = 0, hierarchyLevels_1 = hierarchyLevels; _i < hierarchyLevels_1.length; _i++) {\n                                    var level = hierarchyLevels_1[_i];\n                                    // it takes at least 2 columns at the same hierarchy level to form a composite group...\n                                    if (level.sources && (level.sources.length >= 2)) {\n                                        debug.assert(_.all(level.sources, function (sourceColumn) { return sourceColumn.isMeasure === level.sources[0].isMeasure; }), 'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\n                                        // Measure headers are not group\n                                        var isMeasureHeadersLevel = level.sources[0].isMeasure;\n                                        if (!isMeasureHeadersLevel) {\n                                            hasCompositeGroup = true;\n                                            break;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return hasCompositeGroup;\n                }\n                DataViewMatrixUtils.containsCompositeGroup = containsCompositeGroup;\n                function isMatrix(matrixOrHierarchy) {\n                    return 'rows' in matrixOrHierarchy &&\n                        'columns' in matrixOrHierarchy &&\n                        'valueSources' in matrixOrHierarchy;\n                }\n            })(DataViewMatrixUtils = utils.DataViewMatrixUtils || (utils.DataViewMatrixUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var utils;\n        (function (utils) {\n            var DataViewMetadataColumnUtils;\n            (function (DataViewMetadataColumnUtils) {\n                /**\n                 * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\n                 */\n                function isForRole(metadataColumn, targetRole) {\n                    debug.assertValue(metadataColumn, 'metadataColumn');\n                    debug.assertValue(targetRole, 'targetRole');\n                    var roles = metadataColumn.roles;\n                    return roles && roles[targetRole];\n                }\n                DataViewMetadataColumnUtils.isForRole = isForRole;\n                /**\n                 * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\n                 *\n                 * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the\n                 * specified columnSources must be a non-filtered array of column sources from the DataView, such as\n                 * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\n                 *\n                 * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\n                 * @param projection The projection ordering.  It must contain an ordering for the specified role.\n                 * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\n                 */\n                function joinMetadataColumnsAndProjectionOrder(columnSources, projection, role) {\n                    debug.assertAnyValue(columnSources, 'columnSources');\n                    debug.assert(_.all(columnSources, function (column) { return _.isNumber(column.index); }), 'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\n                    debug.assertNonEmpty(projection[role], 'projection[role]');\n                    debug.assert(_.all(columnSources, function (column) { return !isForRole(column, role) || _.contains(projection[role], column.index); }), 'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\n                    var jointResult = [];\n                    if (!_.isEmpty(columnSources)) {\n                        var projectionOrderSelectIndices = projection[role];\n                        var selectIndexToProjectionIndexMap = {};\n                        for (var i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\n                            var selectIndex = projectionOrderSelectIndices[i];\n                            selectIndexToProjectionIndexMap[selectIndex] = i;\n                        }\n                        for (var j = 0, jlen = columnSources.length; j < jlen; j++) {\n                            var column = columnSources[j];\n                            if (isForRole(column, role)) {\n                                var jointColumnInfo = {\n                                    metadataColumn: column,\n                                    sourceIndex: j,\n                                    projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\n                                };\n                                jointResult.push(jointColumnInfo);\n                            }\n                        }\n                    }\n                    return jointResult;\n                }\n                DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder = joinMetadataColumnsAndProjectionOrder;\n            })(DataViewMetadataColumnUtils = utils.DataViewMetadataColumnUtils || (utils.DataViewMetadataColumnUtils = {}));\n        })(utils = data.utils || (data.utils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ConceptualSchema = (function () {\n            function ConceptualSchema() {\n            }\n            ConceptualSchema.prototype.findProperty = function (entityName, propertyName) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                return entity.properties.withName(propertyName);\n            };\n            ConceptualSchema.prototype.findHierarchy = function (entityName, name) {\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.hierarchies))\n                    return;\n                return entity.hierarchies.withName(name);\n            };\n            ConceptualSchema.prototype.findHierarchyByVariation = function (variationEntityName, variationColumnName, variationName, hierarchyName) {\n                var variationEntity = this.entities.withName(variationEntityName);\n                if (!variationEntity || _.isEmpty(variationEntity.properties))\n                    return;\n                var variationProperty = variationEntity.properties.withName(variationColumnName);\n                if (!variationProperty)\n                    return;\n                var variationColumn = variationProperty.column;\n                if (!variationColumn || _.isEmpty(variationColumn.variations))\n                    return;\n                var variation = variationColumn.variations.withName(variationName);\n                if (variation) {\n                    var targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\n                    if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\n                        return;\n                    return targetEntity.hierarchies.withName(hierarchyName);\n                }\n            };\n            /**\n            * Returns the first property of the entity whose kpi is tied to kpiProperty\n            */\n            ConceptualSchema.prototype.findPropertyWithKpi = function (entityName, kpiProperty) {\n                debug.assertValue(kpiProperty, 'kpiProperty');\n                var entity = this.entities.withName(entityName);\n                if (!entity || _.isEmpty(entity.properties))\n                    return;\n                for (var _i = 0, _a = entity.properties; _i < _a.length; _i++) {\n                    var prop = _a[_i];\n                    if (prop &&\n                        prop.measure &&\n                        prop.measure.kpi &&\n                        (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\n                        return prop;\n                }\n                return;\n            };\n            return ConceptualSchema;\n        }());\n        data.ConceptualSchema = ConceptualSchema;\n        // TODO: Remove this (replaced by ValueType)\n        (function (ConceptualDataCategory) {\n            ConceptualDataCategory[ConceptualDataCategory[\"None\"] = 0] = \"None\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Address\"] = 1] = \"Address\";\n            ConceptualDataCategory[ConceptualDataCategory[\"City\"] = 2] = \"City\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Company\"] = 3] = \"Company\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Continent\"] = 4] = \"Continent\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Country\"] = 5] = \"Country\";\n            ConceptualDataCategory[ConceptualDataCategory[\"County\"] = 6] = \"County\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Date\"] = 7] = \"Date\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Image\"] = 8] = \"Image\";\n            ConceptualDataCategory[ConceptualDataCategory[\"ImageUrl\"] = 9] = \"ImageUrl\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Latitude\"] = 10] = \"Latitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Longitude\"] = 11] = \"Longitude\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Organization\"] = 12] = \"Organization\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Place\"] = 13] = \"Place\";\n            ConceptualDataCategory[ConceptualDataCategory[\"PostalCode\"] = 14] = \"PostalCode\";\n            ConceptualDataCategory[ConceptualDataCategory[\"Product\"] = 15] = \"Product\";\n            ConceptualDataCategory[ConceptualDataCategory[\"StateOrProvince\"] = 16] = \"StateOrProvince\";\n            ConceptualDataCategory[ConceptualDataCategory[\"WebUrl\"] = 17] = \"WebUrl\";\n        })(data.ConceptualDataCategory || (data.ConceptualDataCategory = {}));\n        var ConceptualDataCategory = data.ConceptualDataCategory;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var FieldExprPattern = powerbi.data.FieldExprPattern;\n    var ScriptResultUtil;\n    (function (ScriptResultUtil) {\n        function findScriptResult(dataViewMappings) {\n            if (dataViewMappings && dataViewMappings.length === 1) {\n                return dataViewMappings[0].scriptResult;\n            }\n            return undefined;\n        }\n        ScriptResultUtil.findScriptResult = findScriptResult;\n        function extractScriptResult(dataViewMappings) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult) {\n                var objects = dataViewMappings[0].metadata.objects;\n                var source = powerbi.DataViewObjects.getValue(objects, scriptResult.script.source);\n                var provider = powerbi.DataViewObjects.getValue(objects, scriptResult.script.provider);\n                return {\n                    source: source,\n                    provider: provider\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResult = extractScriptResult;\n        function extractScriptResultFromVisualConfig(dataViewMappings, objects) {\n            var scriptResult = findScriptResult(dataViewMappings);\n            if (scriptResult && objects) {\n                var scriptSource = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\n                var provider = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\n                return {\n                    source: scriptSource ? scriptSource.value : null,\n                    provider: provider ? provider.value : null\n                };\n            }\n            return undefined;\n        }\n        ScriptResultUtil.extractScriptResultFromVisualConfig = extractScriptResultFromVisualConfig;\n        function getScriptInput(projections, selects, schema) {\n            var scriptInput = {\n                VariableName: \"dataset\",\n                Columns: []\n            };\n            // Go over all the projections, and create an input column according to the order\n            // of the projections (including duplicate expressions)\n            if (projections && selects && !_.isEmpty(selects)) {\n                var scriptInputColumnNames = [];\n                var scriptInputColumns = [];\n                for (var role in projections) {\n                    for (var _i = 0, _a = projections[role].all(); _i < _a.length; _i++) {\n                        var projection = _a[_i];\n                        var select = selects.withName(projection.queryRef);\n                        if (select) {\n                            var scriptInputColumn = {\n                                QueryName: select.name,\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\n                            };\n                            scriptInputColumns.push(scriptInputColumn);\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\n                        }\n                    }\n                }\n                // Make sure the names of the columns are unique\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\n                // Update the names of the columns\n                for (var i = 0; i < scriptInputColumnNames.length; i++) {\n                    var scriptInputColumn = scriptInputColumns[i];\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\n                }\n                scriptInput.Columns = scriptInputColumns;\n            }\n            return scriptInput;\n        }\n        ScriptResultUtil.getScriptInput = getScriptInput;\n        var ScriptInputColumnNameVisitor = (function () {\n            function ScriptInputColumnNameVisitor(federatedSchema) {\n                this.federatedSchema = federatedSchema;\n            }\n            ScriptInputColumnNameVisitor.prototype.visitColumn = function (column) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnAggr = function (columnAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntity = function (entity) {\n                return entity.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitEntityAggr = function (entityAggr) {\n                return entityAggr.entity;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchy = function (hierarchy) {\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                /*Hierarchy levels are not supported yet*/\n                return;\n            };\n            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitMeasure = function (measure) {\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitPercentile = function (percentile) {\n                return FieldExprPattern.visit(percentile.arg, this);\n            };\n            ScriptInputColumnNameVisitor.prototype.visitPercentOfGrandTotal = function (percentOfGrandTotal) {\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\n            };\n            ScriptInputColumnNameVisitor.getNameForHierarchy = function (pattern, federatedScheam) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedScheam.schema(pattern.schema), hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\n                if (hierarchy)\n                    return hierarchy.name;\n            };\n            ScriptInputColumnNameVisitor.getNameForProperty = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var schema = federatedSchema.schema(pattern.schema), property = schema.findProperty(pattern.entity, pattern.name);\n                if (property)\n                    return property.name;\n            };\n            ScriptInputColumnNameVisitor.getVariationLevelName = function (pattern, federatedSchema) {\n                debug.assertValue(pattern, 'pattern');\n                var source = pattern.source;\n                var prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\n                if (!prop)\n                    return;\n                var variations = prop.column.variations;\n                for (var _i = 0, variations_1 = variations; _i < variations_1.length; _i++) {\n                    var variation = variations_1[_i];\n                    if (variation.name === pattern.variationName)\n                        for (var _a = 0, _b = variation.defaultHierarchy.levels; _a < _b.length; _a++) {\n                            var level = _b[_a];\n                            if (level.name === pattern.level.level)\n                                return level.column.name;\n                        }\n                }\n            };\n            return ScriptInputColumnNameVisitor;\n        }());\n    })(ScriptResultUtil = powerbi.ScriptResultUtil || (powerbi.ScriptResultUtil = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var segmentation;\n        (function (segmentation) {\n            var DataViewMerger;\n            (function (DataViewMerger) {\n                function mergeDataViews(source, segment) {\n                    if (!powerbi.DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\n                        debug.assertFail(\"Cannot merge data views with different metadata columns\");\n                    }\n                    // The last segment is complete. We mark the source as complete.\n                    if (!segment.metadata.segment)\n                        delete source.metadata.segment;\n                    if (source.table && segment.table)\n                        mergeTables(source.table, segment.table);\n                    if (source.categorical && segment.categorical)\n                        mergeCategorical(source.categorical, segment.categorical);\n                    // Tree cannot support subtotals hence we can get into situations\n                    // where a node has no children in one segment and more than 1 child\n                    // in another segment.\n                    if (source.tree && segment.tree)\n                        mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\n                    if (source.matrix && segment.matrix)\n                        mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\n                }\n                DataViewMerger.mergeDataViews = mergeDataViews;\n                /** Note: Public for testability */\n                function mergeTables(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    if (_.isEmpty(segment.rows))\n                        return;\n                    var mergeIndex = segment.lastMergeIndex + 1;\n                    merge(source.rows, segment.rows, mergeIndex);\n                    debug.assert(!source.identity === !segment.identity, 'The existence of identity in the new segment is different than the source');\n                    if (segment.identity)\n                        merge(source.identity, segment.identity, mergeIndex);\n                }\n                DataViewMerger.mergeTables = mergeTables;\n                /**\n                 * Merge categories values and identities\n                 *\n                 * Note: Public for testability\n                 */\n                function mergeCategorical(source, segment) {\n                    debug.assertValue(source, 'source');\n                    debug.assertValue(segment, 'segment');\n                    // Merge categories values and identities\n                    if (source.categories && segment.categories) {\n                        var segmentCategoriesLength = segment.categories.length;\n                        debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\n                        for (var categoryIndex = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\n                            var segmentCategory = segment.categories[categoryIndex];\n                            var sourceCategory = source.categories[categoryIndex];\n                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\n                            debug.assert(_.isUndefined(sourceCategory.values) ? _.isUndefined(sourceCategory.identity) : true, 'Source category is missing values but has identities.');\n                            var mergeIndex = segment.lastMergeIndex + 1;\n                            if (segmentCategory.values) {\n                                merge(sourceCategory.values, segmentCategory.values, mergeIndex);\n                            }\n                            if (segmentCategory.identity) {\n                                merge(sourceCategory.identity, segmentCategory.identity, mergeIndex);\n                            }\n                        }\n                    }\n                    // Merge values for each value column\n                    if (source.values && segment.values) {\n                        var segmentValuesLength = segment.values.length;\n                        debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\n                        for (var valueIndex = 0; valueIndex < segmentValuesLength; valueIndex++) {\n                            var segmentValue = segment.values[valueIndex];\n                            var sourceValue = source.values[valueIndex];\n                            debug.assert(jsCommon.JsonComparer.equals(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\n                            if (!sourceValue.values && segmentValue.values) {\n                                sourceValue.values = [];\n                            }\n                            var mergeIndex = segment.lastMergeIndex + 1;\n                            if (segmentValue.values) {\n                                merge(sourceValue.values, segmentValue.values, mergeIndex);\n                            }\n                            if (segmentValue.highlights) {\n                                merge(sourceValue.highlights, segmentValue.highlights, mergeIndex);\n                            }\n                        }\n                    }\n                }\n                DataViewMerger.mergeCategorical = mergeCategorical;\n                /**\n                 * Merges the segment array starting at the specified index into the source array\n                 * and returns the segment slice that wasn't merged.\n                 * The segment array is spliced up to specified index in the process.\n                 */\n                function merge(source, segment, index) {\n                    if (index >= segment.length)\n                        return segment;\n                    var result = [];\n                    if (index !== undefined)\n                        result = segment.splice(0, index);\n                    Array.prototype.push.apply(source, segment);\n                    return result;\n                }\n                /** Note: Public for testability */\n                function mergeTreeNodes(sourceRoot, segmentRoot, allowDifferentStructure) {\n                    debug.assertValue(sourceRoot, 'sourceRoot');\n                    debug.assertValue(segmentRoot, 'segmentRoot');\n                    if (!segmentRoot.children || segmentRoot.children.length === 0)\n                        return;\n                    if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\n                        sourceRoot.children = segmentRoot.children;\n                        return;\n                    }\n                    debug.assert(sourceRoot.children && sourceRoot.children.length >= 0, \"Source tree has different structure than segment.\");\n                    var firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\n                    var lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\n                    var mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\n                    if (mergedChildren.length > 0)\n                        mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\n                }\n                DataViewMerger.mergeTreeNodes = mergeTreeNodes;\n                function findFirstAppendIndex(children) {\n                    if (children.length === 0)\n                        return 0;\n                    var i = 0;\n                    for (; i < children.length; i++) {\n                        var childSegment = children[i];\n                        if (!childSegment.isMerge)\n                            break;\n                    }\n                    return i;\n                }\n            })(DataViewMerger = segmentation.DataViewMerger || (segmentation.DataViewMerger = {}));\n        })(segmentation = data.segmentation || (data.segmentation = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Rewrites an expression tree, including all descendant nodes. */\n        var SQExprRewriter = (function () {\n            function SQExprRewriter() {\n            }\n            SQExprRewriter.prototype.visitColumnRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQColumnRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitMeasureRef = function (expr) {\n                var origArg = expr.source, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQMeasureRefExpr(rewrittenArg, expr.ref);\n            };\n            SQExprRewriter.prototype.visitAggr = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQAggregationExpr(rewrittenArg, expr.func);\n            };\n            SQExprRewriter.prototype.visitPercentile = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPercentileExpr(rewrittenArg, expr.k, expr.exclusive);\n            };\n            SQExprRewriter.prototype.visitHierarchy = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyExpr(rewrittenArg, expr.hierarchy);\n            };\n            SQExprRewriter.prototype.visitHierarchyLevel = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQHierarchyLevelExpr(rewrittenArg, expr.level);\n            };\n            SQExprRewriter.prototype.visitPropertyVariationSource = function (expr) {\n                var origArg = expr.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return expr;\n                return new data.SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\n            };\n            SQExprRewriter.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitAnd = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQAndExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitBetween = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this), origLower = orig.lower, rewrittenLower = origLower.accept(this), origUpper = orig.upper, rewrittenUpper = origUpper.accept(this);\n                if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\n                    return orig;\n                return new data.SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\n            };\n            SQExprRewriter.prototype.visitIn = function (orig) {\n                var origArgs = orig.args, rewrittenArgs = this.rewriteAll(origArgs), origValues = orig.values, rewrittenValues;\n                for (var i = 0, len = origValues.length; i < len; i++) {\n                    var origValueTuple = origValues[i], rewrittenValueTuple = this.rewriteAll(origValueTuple);\n                    if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\n                        rewrittenValues = ArrayExtensions.take(origValues, i);\n                    if (rewrittenValues)\n                        rewrittenValues.push(rewrittenValueTuple);\n                }\n                if (origArgs === rewrittenArgs && !rewrittenValues)\n                    return orig;\n                return new data.SQInExpr(rewrittenArgs, rewrittenValues || origValues);\n            };\n            SQExprRewriter.prototype.rewriteAll = function (origExprs) {\n                debug.assertValue(origExprs, 'origExprs');\n                var rewrittenResult;\n                for (var i = 0, len = origExprs.length; i < len; i++) {\n                    var origExpr = origExprs[i], rewrittenExpr = origExpr.accept(this);\n                    if (origExpr !== rewrittenExpr && !rewrittenResult)\n                        rewrittenResult = ArrayExtensions.take(origExprs, i);\n                    if (rewrittenResult)\n                        rewrittenResult.push(rewrittenExpr);\n                }\n                return rewrittenResult || origExprs;\n            };\n            SQExprRewriter.prototype.visitOr = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQOrExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitCompare = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitContains = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQContainsExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitExists = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQExistsExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNot = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQNotExpr(rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitStartsWith = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQStartsWithExpr(rewrittenLeft, rewrittenRight);\n            };\n            SQExprRewriter.prototype.visitConstant = function (expr) {\n                return expr;\n            };\n            SQExprRewriter.prototype.visitDateSpan = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateSpanExpr(orig.unit, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitDateAdd = function (orig) {\n                var origArg = orig.arg, rewrittenArg = origArg.accept(this);\n                if (origArg === rewrittenArg)\n                    return orig;\n                return new data.SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\n            };\n            SQExprRewriter.prototype.visitNow = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitDefaultValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitAnyValue = function (orig) {\n                return orig;\n            };\n            SQExprRewriter.prototype.visitArithmetic = function (orig) {\n                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);\n                if (origLeft === rewrittenLeft && origRight === rewrittenRight)\n                    return orig;\n                return new data.SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\n            };\n            SQExprRewriter.prototype.visitScopedEval = function (orig) {\n                var origExpression = orig.expression, rewrittenExpression = origExpression.accept(this), origScope = orig.scope, rewrittenScope = this.rewriteAll(origScope);\n                if (origExpression === rewrittenExpression && origScope === rewrittenScope)\n                    return orig;\n                return new data.SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\n            };\n            SQExprRewriter.prototype.visitFillRule = function (orig) {\n                var origInput = orig.input, rewrittenInput = origInput.accept(this);\n                var origRule = orig.rule;\n                var origGradient2 = origRule.linearGradient2, rewrittenGradient2 = origGradient2;\n                if (origGradient2) {\n                    rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\n                }\n                var origGradient3 = origRule.linearGradient3, rewrittenGradient3 = origGradient3;\n                if (origGradient3) {\n                    rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\n                }\n                if (origInput !== rewrittenInput ||\n                    origGradient2 !== rewrittenGradient2 ||\n                    origGradient3 !== rewrittenGradient3) {\n                    var rewrittenRule = {};\n                    if (rewrittenGradient2)\n                        rewrittenRule.linearGradient2 = rewrittenGradient2;\n                    if (rewrittenGradient3)\n                        rewrittenRule.linearGradient3 = rewrittenGradient3;\n                    return new data.SQFillRuleExpr(rewrittenInput, rewrittenRule);\n                }\n                return orig;\n            };\n            SQExprRewriter.prototype.visitLinearGradient2 = function (origGradient2) {\n                debug.assertValue(origGradient2, 'origGradient2');\n                var origMin = origGradient2.min, rewrittenMin = this.visitFillRuleStop(origMin), origMax = origGradient2.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient2;\n            };\n            SQExprRewriter.prototype.visitLinearGradient3 = function (origGradient3) {\n                debug.assertValue(origGradient3, 'origGradient3');\n                var origMin = origGradient3.min, rewrittenMin = this.visitFillRuleStop(origMin), origMid = origGradient3.mid, rewrittenMid = this.visitFillRuleStop(origMid), origMax = origGradient3.max, rewrittenMax = this.visitFillRuleStop(origMax);\n                if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\n                    return {\n                        min: rewrittenMin,\n                        mid: rewrittenMid,\n                        max: rewrittenMax,\n                    };\n                }\n                return origGradient3;\n            };\n            SQExprRewriter.prototype.visitFillRuleStop = function (stop) {\n                debug.assertValue(stop, 'stop');\n                var origColor = stop.color, rewrittenColor = stop.color.accept(this);\n                var origValue = stop.value, rewrittenValue = origValue;\n                if (origValue)\n                    rewrittenValue = origValue.accept(this);\n                if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\n                    var rewrittenStop = {\n                        color: rewrittenColor\n                    };\n                    if (rewrittenValue)\n                        rewrittenStop.value = rewrittenValue;\n                    return rewrittenStop;\n                }\n                return stop;\n            };\n            SQExprRewriter.prototype.visitResourcePackageItem = function (orig) {\n                return orig;\n            };\n            return SQExprRewriter;\n        }());\n        data.SQExprRewriter = SQExprRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Responsible for writing equality comparisons against a field to an SQInExpr. */\n        var EqualsToInRewriter;\n        (function (EqualsToInRewriter) {\n            function run(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(new Rewriter());\n            }\n            EqualsToInRewriter.run = run;\n            var Rewriter = (function (_super) {\n                __extends(Rewriter, _super);\n                function Rewriter() {\n                    _super.call(this);\n                }\n                Rewriter.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return this.visitUnsupported(expr);\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var leftIsComparand = this.isComparand(expr.left);\n                    var rightIsComparand = this.isComparand(expr.right);\n                    if (leftIsComparand === rightIsComparand)\n                        return this.visitUnsupported(expr);\n                    var operand = leftIsComparand\n                        ? expr.left\n                        : expr.right;\n                    var value = leftIsComparand\n                        ? expr.right\n                        : expr.left;\n                    var current = this.current;\n                    if (!current) {\n                        return data.SQExprBuilder.inExpr([operand], [[value]]);\n                    }\n                    current.add(operand, value);\n                    return expr;\n                };\n                Rewriter.prototype.visitOr = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current;\n                    if (!this.current) {\n                        current = this.current = new InBuilder();\n                    }\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                    if (current) {\n                        this.current = null;\n                        return current.complete() || expr;\n                    }\n                    return expr;\n                };\n                Rewriter.prototype.visitAnd = function (expr) {\n                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\n                        return this.visitUnsupported(expr);\n                    var current = this.current;\n                    if (current) {\n                        // NOTE: Composite keys are not supported by this algorithm.\n                        current.cancel();\n                        return expr;\n                    }\n                    return _super.prototype.visitAnd.call(this, expr);\n                };\n                Rewriter.prototype.visitUnsupported = function (expr) {\n                    var current = this.current;\n                    if (current)\n                        current.cancel();\n                    return expr;\n                };\n                Rewriter.prototype.isSupported = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return expr instanceof data.SQCompareExpr\n                        || expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQConstantExpr\n                        || expr instanceof data.SQHierarchyLevelExpr\n                        || expr instanceof data.SQOrExpr\n                        || expr instanceof data.SQAndExpr;\n                };\n                Rewriter.prototype.isComparand = function (expr) {\n                    return expr instanceof data.SQColumnRefExpr\n                        || expr instanceof data.SQHierarchyLevelExpr;\n                };\n                return Rewriter;\n            }(data.SQExprRewriter));\n            var InBuilder = (function () {\n                function InBuilder() {\n                }\n                InBuilder.prototype.add = function (operand, value) {\n                    debug.assertValue(operand, 'operand');\n                    debug.assertValue(value, 'value');\n                    if (this.cancelled)\n                        return;\n                    if (this.operand && !data.SQExpr.equals(operand, this.operand)) {\n                        this.cancel();\n                        return;\n                    }\n                    this.operand = operand;\n                    var values = this.values;\n                    if (!values)\n                        values = this.values = [];\n                    values.push(value);\n                };\n                InBuilder.prototype.cancel = function () {\n                    this.cancelled = true;\n                };\n                InBuilder.prototype.complete = function () {\n                    if (this.cancelled || !this.operand)\n                        return;\n                    return data.SQExprBuilder.inExpr([this.operand], _.map(this.values, function (v) { return [v]; }));\n                };\n                return InBuilder;\n            }());\n        })(EqualsToInRewriter = data.EqualsToInRewriter || (data.EqualsToInRewriter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExprConverter;\n        (function (SQExprConverter) {\n            function asScopeIdsContainer(filter, fieldSQExprs) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\n                var filterItems = filter.conditions();\n                debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\n                var filterItem = filterItems[0];\n                if (filterItem) {\n                    var visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\n                    if (filterItem.accept(visitor))\n                        return visitor.getResult();\n                }\n            }\n            SQExprConverter.asScopeIdsContainer = asScopeIdsContainer;\n            /** Gets a comparand value from the given DataViewScopeIdentity. */\n            function getFirstComparandValue(identity) {\n                debug.assertValue(identity, 'identity');\n                var comparandExpr = identity.expr.accept(new FindComparandVisitor());\n                if (comparandExpr)\n                    return comparandExpr.value;\n            }\n            SQExprConverter.getFirstComparandValue = getFirstComparandValue;\n        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));\n        /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\n        var FilterScopeIdsCollectorVisitor = (function (_super) {\n            __extends(FilterScopeIdsCollectorVisitor, _super);\n            function FilterScopeIdsCollectorVisitor(fieldSQExprs) {\n                _super.call(this);\n                this.isRoot = true;\n                this.isNot = false;\n                this.keyExprsCount = null;\n                this.valueExprs = [];\n                // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\n                // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\n                // need to drop it in order to use JsonComparer.\n                this.fieldExprs = [];\n                for (var _i = 0, fieldSQExprs_1 = fieldSQExprs; _i < fieldSQExprs_1.length; _i++) {\n                    var field = fieldSQExprs_1[_i];\n                    this.fieldExprs.push(data.SQExprBuilder.removeEntityVariables(field));\n                }\n            }\n            FilterScopeIdsCollectorVisitor.prototype.getResult = function () {\n                debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');\n                var valueExprs = this.valueExprs, scopeIds = [];\n                var valueCount = this.keyExprsCount || 1;\n                for (var startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\n                    var values = valueExprs.slice(startIndex, endIndex);\n                    var scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\n                    if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, powerbi.DataViewScopeIdentity.equals))\n                        scopeIds.push(scopeId);\n                    startIndex += valueCount;\n                    endIndex += valueCount;\n                }\n                return {\n                    isNot: this.isNot,\n                    scopeIds: scopeIds,\n                };\n            };\n            FilterScopeIdsCollectorVisitor.getScopeIdentity = function (fieldExprs, valueExprs) {\n                debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\n                debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\n                var compoundSQExpr;\n                for (var i = 0, len = fieldExprs.length; i < len; i++) {\n                    var equalsExpr = data.SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\n                    if (!compoundSQExpr)\n                        compoundSQExpr = equalsExpr;\n                    else\n                        compoundSQExpr = data.SQExprBuilder.and(compoundSQExpr, equalsExpr);\n                }\n                return data.createDataViewScopeIdentity(compoundSQExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitOr = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitNot = function (expr) {\n                if (!this.isRoot)\n                    return this.unsupportedSQExpr();\n                this.isNot = true;\n                return expr.arg.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitConstant = function (expr) {\n                if (this.isRoot && expr.type.primitiveType === powerbi.PrimitiveType.Null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitCompare = function (expr) {\n                if (this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.isRoot = false;\n                if (expr.comparison !== data.QueryComparisonKind.Equal)\n                    return this.unsupportedSQExpr();\n                return expr.left.accept(this) && expr.right.accept(this);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitIn = function (expr) {\n                this.keyExprsCount = 0;\n                var result;\n                this.isRoot = false;\n                for (var _i = 0, _a = expr.args; _i < _a.length; _i++) {\n                    var arg = _a[_i];\n                    result = arg.accept(this);\n                    if (!result)\n                        return this.unsupportedSQExpr();\n                    this.keyExprsCount++;\n                }\n                if (this.keyExprsCount !== this.fieldExprs.length)\n                    return this.unsupportedSQExpr();\n                var values = expr.values;\n                for (var _b = 0, values_1 = values; _b < values_1.length; _b++) {\n                    var valueTuple = values_1[_b];\n                    var jlen = valueTuple.length;\n                    debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\n                    for (var _c = 0, valueTuple_1 = valueTuple; _c < valueTuple_1.length; _c++) {\n                        var value = valueTuple_1[_c];\n                        result = value.accept(this);\n                        if (!result)\n                            return this.unsupportedSQExpr();\n                    }\n                }\n                return result;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitColumnRef = function (expr) {\n                if (this.isRoot)\n                    return this.unsupportedSQExpr();\n                var fixedExpr = data.SQExprBuilder.removeEntityVariables(expr);\n                if (this.keyExprsCount !== null)\n                    return data.SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\n                return data.SQExpr.equals(this.fieldExprs[0], fixedExpr);\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefaultValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitAnyValue = function (expr) {\n                if (this.isRoot || this.keyExprsCount !== null)\n                    return this.unsupportedSQExpr();\n                this.valueExprs.push(expr);\n                return true;\n            };\n            FilterScopeIdsCollectorVisitor.prototype.visitDefault = function (expr) {\n                return this.unsupportedSQExpr();\n            };\n            FilterScopeIdsCollectorVisitor.prototype.unsupportedSQExpr = function () {\n                return false;\n            };\n            return FilterScopeIdsCollectorVisitor;\n        }(data.DefaultSQExprVisitor));\n        var FindComparandVisitor = (function (_super) {\n            __extends(FindComparandVisitor, _super);\n            function FindComparandVisitor() {\n                _super.apply(this, arguments);\n            }\n            FindComparandVisitor.prototype.visitAnd = function (expr) {\n                return expr.left.accept(this) || expr.right.accept(this);\n            };\n            FindComparandVisitor.prototype.visitCompare = function (expr) {\n                if (expr.comparison === data.QueryComparisonKind.Equal) {\n                    if (expr.right instanceof data.SQConstantExpr)\n                        return expr.right;\n                    if (expr.left instanceof data.SQConstantExpr)\n                        return expr.left;\n                }\n            };\n            return FindComparandVisitor;\n        }(data.DefaultSQExprVisitor));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\n        var ScopeIdentityExtractor;\n        (function (ScopeIdentityExtractor) {\n            function getKeys(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return null;\n                return ArrayExtensions.emptyToNull(extractor.keys);\n            }\n            ScopeIdentityExtractor.getKeys = getKeys;\n            function getInExpr(expr) {\n                var extractor = new ScopeIdExtractorImpl();\n                expr.accept(extractor);\n                if (extractor.malformed)\n                    return;\n                var keys = ArrayExtensions.emptyToNull(extractor.keys);\n                var keyValues = ArrayExtensions.emptyToNull(extractor.values);\n                if (keys && keyValues)\n                    return data.SQExprBuilder.inExpr(keys, [keyValues]);\n            }\n            ScopeIdentityExtractor.getInExpr = getInExpr;\n            /**\n             * Recognizes expressions of the form:\n             * 1) Equals(ColRef, Constant)\n             * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\n             * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\n             */\n            var ScopeIdExtractorImpl = (function (_super) {\n                __extends(ScopeIdExtractorImpl, _super);\n                function ScopeIdExtractorImpl() {\n                    _super.apply(this, arguments);\n                    this.keys = [];\n                    this.values = [];\n                }\n                ScopeIdExtractorImpl.prototype.visitAnd = function (expr) {\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal) {\n                        this.visitDefault(expr);\n                        return;\n                    }\n                    debug.assert(expr.left instanceof data.SQExpr && expr.right instanceof data.SQConstantExpr, 'invalid compare expr operands');\n                    expr.left.accept(this);\n                    expr.right.accept(this);\n                };\n                ScopeIdExtractorImpl.prototype.visitColumnRef = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitHierarchyLevel = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitConstant = function (expr) {\n                    this.values.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitArithmetic = function (expr) {\n                    this.keys.push(expr);\n                };\n                ScopeIdExtractorImpl.prototype.visitDefault = function (expr) {\n                    this.malformed = true;\n                };\n                return ScopeIdExtractorImpl;\n            }(data.DefaultSQExprVisitor));\n        })(ScopeIdentityExtractor = data.ScopeIdentityExtractor || (data.ScopeIdentityExtractor = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var PrimitiveValueEncoding;\n        (function (PrimitiveValueEncoding) {\n            var SingleQuoteRegex = /'/g;\n            function decimal(value) {\n                debug.assertValue(value, 'value');\n                return value + 'M';\n            }\n            PrimitiveValueEncoding.decimal = decimal;\n            function double(value) {\n                debug.assertValue(value, 'value');\n                return value + 'D';\n            }\n            PrimitiveValueEncoding.double = double;\n            function integer(value) {\n                debug.assertValue(value, 'value');\n                return value + 'L';\n            }\n            PrimitiveValueEncoding.integer = integer;\n            function dateTime(value) {\n                debug.assertValue(value, 'value');\n                // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\n                // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\n                // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\n                var date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\n                var dateTimeString = date.toISOString();\n                // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\n                // we will drop it.\n                // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\n                if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\n                    dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\n                return \"datetime'\" + dateTimeString + \"'\";\n            }\n            PrimitiveValueEncoding.dateTime = dateTime;\n            function text(value) {\n                debug.assertValue(value, 'value');\n                return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\n            }\n            PrimitiveValueEncoding.text = text;\n            function nullEncoding() {\n                return 'null';\n            }\n            PrimitiveValueEncoding.nullEncoding = nullEncoding;\n            function boolean(value) {\n                return value ? 'true' : 'false';\n            }\n            PrimitiveValueEncoding.boolean = boolean;\n        })(PrimitiveValueEncoding = data.PrimitiveValueEncoding || (data.PrimitiveValueEncoding = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var Agg = powerbi.data.QueryAggregateFunction;\n        function createSQAggregationOperations(datetimeMinMaxSupported) {\n            return new SQAggregationOperations(datetimeMinMaxSupported);\n        }\n        data.createSQAggregationOperations = createSQAggregationOperations;\n        var SQAggregationOperations = (function () {\n            function SQAggregationOperations(datetimeMinMaxSupported) {\n                this.datetimeMinMaxSupported = datetimeMinMaxSupported;\n            }\n            SQAggregationOperations.prototype.getSupportedAggregates = function (expr, schema, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                debug.assertAnyValue(targetTypes, 'targetTypes');\n                var metadata = getMetadataForUnderlyingType(expr, schema);\n                // don't use expr.validate as validate will be using this function and we end up in a recursive loop\n                if (!metadata)\n                    return [];\n                var valueType = metadata.type, fieldKind = metadata.kind, isPropertyIdentity = metadata.idOnEntityKey;\n                if (!valueType)\n                    return [];\n                // Cannot aggregate on model measures\n                if (fieldKind === 1 /* Measure */)\n                    return [];\n                if (valueType.numeric || valueType.integer) {\n                    var aggregates_1 = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var currentSchema = schema.schema(fieldExprItem.schema);\n                    if (currentSchema.capabilities.supportsMedian)\n                        aggregates_1.push(Agg.Median);\n                    return aggregates_1;\n                }\n                var aggregates = [];\n                // Min/Max of DateTime\n                if (this.datetimeMinMaxSupported &&\n                    valueType.dateTime &&\n                    (_.isEmpty(targetTypes) || powerbi.ValueType.isCompatibleTo(valueType, targetTypes))) {\n                    aggregates.push(Agg.Min);\n                    aggregates.push(Agg.Max);\n                }\n                // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\n                // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\n                var distinctCountAggExists = data.SQExprInfo.getAggregate(expr) === Agg.Count;\n                if (!(isPropertyIdentity && !distinctCountAggExists))\n                    aggregates.push(Agg.Count);\n                aggregates.push(Agg.CountNonNull);\n                return aggregates;\n            };\n            SQAggregationOperations.prototype.isSupportedAggregate = function (expr, schema, aggregate, targetTypes) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\n                return _.contains(supportedAggregates, aggregate);\n            };\n            SQAggregationOperations.prototype.createExprWithAggregate = function (expr, schema, aggregateNonNumericFields, targetTypes, preferredAggregate) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var aggregate;\n                if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\n                    aggregate = preferredAggregate;\n                }\n                else {\n                    aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\n                }\n                if (aggregate !== undefined)\n                    expr = data.SQExprBuilder.aggregate(expr, aggregate);\n                return expr;\n            };\n            return SQAggregationOperations;\n        }());\n        function getMetadataForUnderlyingType(expr, schema) {\n            // Unwrap the aggregate (if the expr has one), and look at the underlying type.\n            var metadata = data.SQExprBuilder.removeAggregate(expr).getMetadata(schema);\n            if (!metadata)\n                metadata = expr.getMetadata(schema);\n            return metadata;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQHierarchyExprUtils;\n        (function (SQHierarchyExprUtils) {\n            function getConceptualHierarchyLevelFromExpr(conceptualSchema, fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                var hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\n                if (hierarchyLevel)\n                    return SQHierarchyExprUtils.getConceptualHierarchyLevel(conceptualSchema, fieldExprItem.schema, fieldExprItem.entity, hierarchyLevel.name, hierarchyLevel.level);\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr = getConceptualHierarchyLevelFromExpr;\n            function getConceptualHierarchyLevel(conceptualSchema, schemaName, entity, hierarchy, hierarchyLevel) {\n                var schema = conceptualSchema.schema(schemaName);\n                var conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\n                if (conceptualHierarchy) {\n                    return conceptualHierarchy.levels.withName(hierarchyLevel);\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchyLevel = getConceptualHierarchyLevel;\n            function getConceptualHierarchy(sqExpr, federatedSchema) {\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchy = sqExpr;\n                    if (sqExpr.arg instanceof data.SQEntityExpr) {\n                        var entityExpr = sqExpr.arg;\n                        return federatedSchema\n                            .schema(entityExpr.schema)\n                            .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\n                    }\n                    else if (sqExpr.arg instanceof data.SQPropertyVariationSourceExpr) {\n                        var variationExpr = sqExpr.arg;\n                        var sourceEntityExpr = variationExpr.arg;\n                        return federatedSchema\n                            .schema(sourceEntityExpr.schema)\n                            .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\n                    }\n                }\n            }\n            SQHierarchyExprUtils.getConceptualHierarchy = getConceptualHierarchy;\n            function expandExpr(schema, expr, suppressHierarchyLevelExpansion) {\n                return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\n                    SQExprVariationConverter.expand(expr, schema) ||\n                    // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\n                    (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\n                    expr;\n            }\n            SQHierarchyExprUtils.expandExpr = expandExpr;\n            function isHierarchyOrVariation(schema, expr) {\n                if (expr instanceof data.SQHierarchyExpr || expr instanceof data.SQHierarchyLevelExpr)\n                    return true;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0)\n                        return true;\n                }\n                return false;\n            }\n            SQHierarchyExprUtils.isHierarchyOrVariation = isHierarchyOrVariation;\n            // Return column reference expression for hierarchy level expression.\n            function getSourceVariationExpr(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                if (fieldExprPattern.columnHierarchyLevelVariation) {\n                    var entity = data.SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\n                    return data.SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceVariationExpr = getSourceVariationExpr;\n            // Return hierarchy expression for hierarchy level expression.\n            function getSourceHierarchy(hierarchyLevelExpr) {\n                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\n                var hierarchyLevel = fieldExprPattern.hierarchyLevel;\n                if (hierarchyLevel) {\n                    var entity = data.SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\n                    return data.SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\n                }\n            }\n            SQHierarchyExprUtils.getSourceHierarchy = getSourceHierarchy;\n            function getHierarchySourceAsVariationSource(hierarchyLevelExpr) {\n                // Make sure the hierarchy level source is a hierarchy\n                if (!(hierarchyLevelExpr.arg instanceof data.SQHierarchyExpr))\n                    return;\n                // Check if the hierarchy source if a variation\n                var hierarchyRef = hierarchyLevelExpr.arg;\n                if (hierarchyRef.arg instanceof data.SQPropertyVariationSourceExpr)\n                    return hierarchyRef.arg;\n            }\n            SQHierarchyExprUtils.getHierarchySourceAsVariationSource = getHierarchySourceAsVariationSource;\n            /**\n            * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\n            */\n            function areHierarchyLevelsOrdered(allLevels, firstExpr, secondExpr) {\n                // Validate that both items hierarchy levels\n                if (!(firstExpr instanceof data.SQHierarchyLevelExpr) || !(secondExpr instanceof data.SQHierarchyLevelExpr))\n                    return false;\n                var firstLevel = firstExpr;\n                var secondLevel = secondExpr;\n                // Validate that both items belong to the same hierarchy\n                if (!data.SQExpr.equals(firstLevel.arg, secondLevel.arg))\n                    return false;\n                // Determine the order\n                var firstIndex = data.SQExprUtils.indexOfExpr(allLevels, firstLevel);\n                var secondIndex = data.SQExprUtils.indexOfExpr(allLevels, secondLevel);\n                return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\n            }\n            SQHierarchyExprUtils.areHierarchyLevelsOrdered = areHierarchyLevelsOrdered;\n            /**\n             * Given an ordered set of levels and an ordered subset of those levels, returns the index where\n             * expr should be inserted into the subset to maintain the correct order.\n             */\n            function getInsertionIndex(allLevels, orderedSubsetOfLevels, expr) {\n                var insertIndex = 0;\n                // Loop through the supplied levels until the insertion would no longer be in the correct order\n                while (insertIndex < orderedSubsetOfLevels.length &&\n                    areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\n                    insertIndex++;\n                }\n                return insertIndex;\n            }\n            SQHierarchyExprUtils.getInsertionIndex = getInsertionIndex;\n        })(SQHierarchyExprUtils = data.SQHierarchyExprUtils || (data.SQHierarchyExprUtils = {}));\n        var SQExprHierarchyToHierarchyLevelConverter;\n        (function (SQExprHierarchyToHierarchyLevelConverter) {\n            function convert(sqExpr, federatedSchema) {\n                debug.assertValue(sqExpr, 'sqExpr');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                if (sqExpr instanceof data.SQHierarchyExpr) {\n                    var hierarchyExpr = sqExpr;\n                    var conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\n                    if (conceptualHierarchy)\n                        return _.map(conceptualHierarchy.levels, function (hierarchyLevel) { return data.SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name); });\n                }\n            }\n            SQExprHierarchyToHierarchyLevelConverter.convert = convert;\n        })(SQExprHierarchyToHierarchyLevelConverter = data.SQExprHierarchyToHierarchyLevelConverter || (data.SQExprHierarchyToHierarchyLevelConverter = {}));\n        var SQExprHierarchyLevelConverter;\n        (function (SQExprHierarchyLevelConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs = [];\n                if (expr instanceof data.SQHierarchyLevelExpr) {\n                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                    if (fieldExpr.hierarchyLevel) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        var hierarchy = schema\n                            .schema(fieldExprItem.schema)\n                            .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\n                        if (hierarchy) {\n                            var hierarchyLevels = hierarchy.levels;\n                            for (var _i = 0, hierarchyLevels_2 = hierarchyLevels; _i < hierarchyLevels_2.length; _i++) {\n                                var hierarchyLevel = hierarchyLevels_2[_i];\n                                if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\n                                    exprs.push(expr);\n                                    break;\n                                }\n                                else\n                                    exprs.push(data.SQExprBuilder.hierarchyLevel(data.SQExprBuilder.hierarchy(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), hierarchy.name), hierarchyLevel.name));\n                            }\n                        }\n                    }\n                }\n                if (!_.isEmpty(exprs))\n                    return exprs;\n            }\n            SQExprHierarchyLevelConverter.expand = expand;\n        })(SQExprHierarchyLevelConverter || (SQExprHierarchyLevelConverter = {}));\n        var SQExprVariationConverter;\n        (function (SQExprVariationConverter) {\n            function expand(expr, schema) {\n                debug.assertValue(expr, 'sqExpr');\n                debug.assertValue(schema, 'federatedSchema');\n                var exprs;\n                var conceptualProperty = expr.getConceptualProperty(schema);\n                if (conceptualProperty) {\n                    var column = conceptualProperty.column;\n                    if (column && column.variations && column.variations.length > 0) {\n                        var variations = column.variations;\n                        // for SU11, we support only one variation\n                        debug.assert(variations.length === 1, \"variations.length\");\n                        var variation = variations[0];\n                        var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                        exprs = [];\n                        if (variation.defaultHierarchy) {\n                            var hierarchyExpr = data.SQExprBuilder.hierarchy(data.SQExprBuilder.propertyVariationSource(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), variation.name, conceptualProperty.name), variation.defaultHierarchy.name);\n                            for (var _i = 0, _a = variation.defaultHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                exprs.push(data.SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\n                            }\n                        }\n                    }\n                }\n                return exprs;\n            }\n            SQExprVariationConverter.expand = expand;\n        })(SQExprVariationConverter || (SQExprVariationConverter = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        ;\n        var SQExprGroupUtils;\n        (function (SQExprGroupUtils) {\n            /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\n            function groupExprs(schema, exprs) {\n                var groups = [];\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i];\n                    debug.assertValue(expr, \"Expression not found\");\n                    if (!(expr instanceof data.SQHierarchyLevelExpr)) {\n                        groups.push({ expr: expr, children: null, selectQueryIndex: i });\n                    }\n                    else {\n                        addChildToGroup(schema, groups, expr, i);\n                    }\n                }\n                return groups;\n            }\n            SQExprGroupUtils.groupExprs = groupExprs;\n            function addChildToGroup(schema, groups, expr, selectQueryIndex) {\n                // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \n                // a new Group or to the last Group\n                var shouldAddExpressionToNewGroup = true;\n                var exprSource = data.SQHierarchyExprUtils.getSourceVariationExpr(expr) || data.SQHierarchyExprUtils.getSourceHierarchy(expr);\n                var lastGroup = _.last(groups);\n                // The relevant group is always the last added. If it has the same source hierarchy,\n                // and is properly ordered within that hierarchy, we will need to add to this group.\n                if (lastGroup && lastGroup.children && data.SQExpr.equals(lastGroup.expr, exprSource)) {\n                    var expandedExpr = data.SQHierarchyExprUtils.expandExpr(schema, expr.arg);\n                    if (expandedExpr instanceof Array) {\n                        var allHierarchyLevels = expandedExpr;\n                        shouldAddExpressionToNewGroup = !data.SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\n                    }\n                }\n                if (shouldAddExpressionToNewGroup)\n                    // Use the Sourcevariation as the expression for the group.\n                    groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\n                else {\n                    debug.assertValue(lastGroup, 'There should be a group to add the variation to');\n                    debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\n                    lastGroup.children.push(expr);\n                }\n            }\n        })(SQExprGroupUtils = data.SQExprGroupUtils || (data.SQExprGroupUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var StringExtensions = jsCommon.StringExtensions;\n        /** Represents an immutable expression within a SemanticQuery. */\n        var SQExpr = (function () {\n            function SQExpr(kind) {\n                debug.assertValue(kind, 'kind');\n                this._kind = kind;\n            }\n            SQExpr.equals = function (x, y, ignoreCase) {\n                return SQExprEqualityVisitor.run(x, y, ignoreCase);\n            };\n            SQExpr.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.accept(validator);\n                return validator.errors;\n            };\n            SQExpr.prototype.accept = function (visitor, arg) {\n                debug.assertFail('abstract method');\n                return;\n            };\n            Object.defineProperty(SQExpr.prototype, \"kind\", {\n                get: function () {\n                    return this._kind;\n                },\n                enumerable: true,\n                configurable: true\n            });\n            SQExpr.isColumn = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 1 /* ColumnRef */;\n            };\n            SQExpr.isConstant = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 16 /* Constant */;\n            };\n            SQExpr.isEntity = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 0 /* Entity */;\n            };\n            SQExpr.isHierarchy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 5 /* Hierarchy */;\n            };\n            SQExpr.isHierarchyLevel = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 6 /* HierarchyLevel */;\n            };\n            SQExpr.isAggregation = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 3 /* Aggregation */;\n            };\n            SQExpr.isMeasure = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 2 /* MeasureRef */;\n            };\n            SQExpr.isResourcePackageItem = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.kind === 24 /* ResourcePackageItem */;\n            };\n            SQExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                if (field.column || field.columnAggr || field.measure)\n                    return this.getMetadataForProperty(field, federatedSchema);\n                if (field.hierarchyLevel || field.hierarchyLevelAggr)\n                    return this.getMetadataForHierarchyLevel(field, federatedSchema);\n                if (field.columnHierarchyLevelVariation)\n                    return this.getMetadataForVariation(field, federatedSchema);\n                if (field.percentOfGrandTotal)\n                    return this.getMetadataForPercentOfGrandTotal();\n                return SQExpr.getMetadataForEntity(field, federatedSchema);\n            };\n            SQExpr.prototype.getDefaultAggregate = function (federatedSchema, forceAggregation) {\n                if (forceAggregation === void 0) { forceAggregation = false; }\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                var aggregate;\n                if (property && property.kind === 0 /* Column */) {\n                    var propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\n                    if ((property.type.integer || property.type.numeric) &&\n                        propertyDefaultAggregate !== 1 /* None */) {\n                        aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\n                        if (aggregate === undefined)\n                            aggregate = defaultAggregateForDataType(property.type);\n                    }\n                    // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \n                    // aggregate on CountNonNull.\n                    if (aggregate === undefined && forceAggregation) {\n                        aggregate = data.QueryAggregateFunction.CountNonNull;\n                    }\n                }\n                return aggregate;\n            };\n            /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\n            SQExpr.prototype.getKeyColumns = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keySQExprs = [];\n                var keys = this.getPropertyKeys(schema);\n                if (keys && keys.length > 0) {\n                    for (var i = 0, len = keys.length; i < len; i++) {\n                        keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\n                    }\n                }\n                else\n                    keySQExprs.push(columnRefExpr);\n                return keySQExprs;\n            };\n            /** Returns a value indicating whether the expression would group on keys other than itself.*/\n            SQExpr.prototype.hasGroupOnKeys = function (schema) {\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\n                if (!columnRefExpr)\n                    return;\n                var keys = this.getPropertyKeys(schema);\n                if (!keys || keys.length < 1)\n                    return false;\n                if (keys.length > 1)\n                    return true;\n                var keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\n                return !SQExpr.equals(keySqExpr, this);\n            };\n            SQExpr.prototype.getPropertyKeys = function (schema) {\n                var property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\n                if (!property)\n                    return;\n                return property.column ? property.column.keys : undefined;\n            };\n            SQExpr.prototype.getConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var propertyName = data.FieldExprPattern.getPropertyName(field);\n                if (propertyName)\n                    return federatedSchema\n                        .schema(fieldExprItem.schema)\n                        .findProperty(fieldExprItem.entity, propertyName);\n            };\n            SQExpr.prototype.getTargetEntityForVariation = function (federatedSchema, variationName) {\n                var property = this.getConceptualProperty(federatedSchema);\n                if (property && property.column && !_.isEmpty(property.column.variations)) {\n                    var variations = property.column.variations;\n                    for (var _i = 0, variations_2 = variations; _i < variations_2.length; _i++) {\n                        var variation = variations_2[_i];\n                        if (variation.name === variationName)\n                            return variation.navigationProperty.targetEntity.name;\n                    }\n                }\n            };\n            SQExpr.prototype.getTargetEntity = function (federatedSchema) {\n                return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\n            };\n            SQExpr.prototype.getHierarchyLevelConceptualProperty = function (federatedSchema) {\n                var field = data.SQExprConverter.asFieldPattern(this);\n                if (!field)\n                    return;\n                var fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\n                if (fieldExprHierachyLevel) {\n                    var fieldExprEntity = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                    var hierarchy = federatedSchema\n                        .schema(fieldExprEntity.schema)\n                        .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\n                    if (hierarchy) {\n                        var hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\n                        if (hierarchyLevel)\n                            return hierarchyLevel.column;\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForVariation = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var sourceProperty = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\n                if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\n                    for (var _i = 0, _a = sourceProperty.column.variations; _i < _a.length; _i++) {\n                        var variation = _a[_i];\n                        if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\n                            for (var _b = 0, _c = variation.defaultHierarchy.levels; _b < _c.length; _b++) {\n                                var level = _c[_b];\n                                if (level.name === columnHierarchyLevelVariation.level.level) {\n                                    var property = level.column;\n                                    return {\n                                        kind: (property.kind === 1 /* Measure */) ? 1 /* Measure */ : 0 /* Column */,\n                                        type: property.type,\n                                        format: property.format,\n                                        idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                                        defaultAggregate: property.column ? property.column.defaultAggregate : null\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n            SQExpr.prototype.getMetadataForHierarchyLevel = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getHierarchyLevelConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.prototype.getMetadataForPercentOfGrandTotal = function () {\n                return {\n                    kind: 1 /* Measure */,\n                    format: '#,##0.##%',\n                    type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double)\n                };\n            };\n            SQExpr.prototype.getPropertyMetadata = function (field, property) {\n                var format = property.format;\n                var type = property.type;\n                var columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\n                if (columnAggregate) {\n                    switch (columnAggregate.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer);\n                            format = undefined;\n                            break;\n                        case data.QueryAggregateFunction.Avg:\n                            if (type.integer)\n                                type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double);\n                            break;\n                    }\n                }\n                return {\n                    kind: (property.kind === 1 /* Measure */ || (columnAggregate && columnAggregate.aggregate !== undefined)) ? 1 /* Measure */ : 0 /* Column */,\n                    type: type,\n                    format: format,\n                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\n                    aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\n                    defaultAggregate: property.column ? property.column.defaultAggregate : null\n                };\n            };\n            SQExpr.prototype.getMetadataForProperty = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var property = this.getConceptualProperty(federatedSchema);\n                if (!property)\n                    return;\n                return this.getPropertyMetadata(field, property);\n            };\n            SQExpr.getMetadataForEntity = function (field, federatedSchema) {\n                debug.assertValue(field, 'field');\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var entity = federatedSchema\n                    .schema(fieldExprItem.schema)\n                    .entities\n                    .withName(fieldExprItem.entity);\n                if (!entity)\n                    return;\n                // We only support count and countnonnull for entity.\n                if (field.entityAggr) {\n                    switch (field.entityAggr.aggregate) {\n                        case data.QueryAggregateFunction.Count:\n                        case data.QueryAggregateFunction.CountNonNull:\n                            return {\n                                kind: 1 /* Measure */,\n                                type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer),\n                                format: undefined,\n                                idOnEntityKey: false,\n                                aggregate: field.entityAggr.aggregate\n                            };\n                    }\n                }\n            };\n            return SQExpr;\n        }());\n        data.SQExpr = SQExpr;\n        /** Note: Exported for testability */\n        function defaultAggregateForDataType(type) {\n            if (type.integer || type.numeric)\n                return data.QueryAggregateFunction.Sum;\n            return data.QueryAggregateFunction.Count;\n        }\n        data.defaultAggregateForDataType = defaultAggregateForDataType;\n        /** Note: Exported for testability */\n        function defaultAggregateToQueryAggregateFunction(aggregate) {\n            switch (aggregate) {\n                case 6 /* Average */:\n                    return data.QueryAggregateFunction.Avg;\n                case 3 /* Count */:\n                    return data.QueryAggregateFunction.CountNonNull;\n                case 7 /* DistinctCount */:\n                    return data.QueryAggregateFunction.Count;\n                case 5 /* Max */:\n                    return data.QueryAggregateFunction.Max;\n                case 4 /* Min */:\n                    return data.QueryAggregateFunction.Min;\n                case 2 /* Sum */:\n                    return data.QueryAggregateFunction.Sum;\n                default:\n                    return;\n            }\n        }\n        data.defaultAggregateToQueryAggregateFunction = defaultAggregateToQueryAggregateFunction;\n        var SQEntityExpr = (function (_super) {\n            __extends(SQEntityExpr, _super);\n            function SQEntityExpr(schema, entity, variable) {\n                debug.assertValue(entity, 'entity');\n                _super.call(this, 0 /* Entity */);\n                this.schema = schema;\n                this.entity = entity;\n                if (variable)\n                    this.variable = variable;\n            }\n            SQEntityExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitEntity(this, arg);\n            };\n            return SQEntityExpr;\n        }(SQExpr));\n        data.SQEntityExpr = SQEntityExpr;\n        var SQArithmeticExpr = (function (_super) {\n            __extends(SQArithmeticExpr, _super);\n            function SQArithmeticExpr(left, right, operator) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                debug.assertValue(operator, 'operator');\n                _super.call(this, 22 /* Arithmetic */);\n                this.left = left;\n                this.right = right;\n                this.operator = operator;\n            }\n            SQArithmeticExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitArithmetic(this, arg);\n            };\n            return SQArithmeticExpr;\n        }(SQExpr));\n        data.SQArithmeticExpr = SQArithmeticExpr;\n        var SQScopedEvalExpr = (function (_super) {\n            __extends(SQScopedEvalExpr, _super);\n            function SQScopedEvalExpr(expression, scope) {\n                debug.assertValue(expression, 'expression');\n                debug.assertValue(scope, 'scope');\n                _super.call(this, 25 /* ScopedEval */);\n                this.expression = expression;\n                this.scope = scope;\n            }\n            SQScopedEvalExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitScopedEval(this, arg);\n            };\n            SQScopedEvalExpr.prototype.getMetadata = function (federatedSchema) {\n                return this.expression.getMetadata(federatedSchema);\n            };\n            return SQScopedEvalExpr;\n        }(SQExpr));\n        data.SQScopedEvalExpr = SQScopedEvalExpr;\n        var SQPropRefExpr = (function (_super) {\n            __extends(SQPropRefExpr, _super);\n            function SQPropRefExpr(kind, source, ref) {\n                debug.assertValue(kind, 'kind');\n                debug.assertValue(source, 'source');\n                debug.assertValue(ref, 'ref');\n                _super.call(this, kind);\n                this.source = source;\n                this.ref = ref;\n            }\n            return SQPropRefExpr;\n        }(SQExpr));\n        data.SQPropRefExpr = SQPropRefExpr;\n        var SQColumnRefExpr = (function (_super) {\n            __extends(SQColumnRefExpr, _super);\n            function SQColumnRefExpr(source, ref) {\n                _super.call(this, 1 /* ColumnRef */, source, ref);\n            }\n            SQColumnRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitColumnRef(this, arg);\n            };\n            return SQColumnRefExpr;\n        }(SQPropRefExpr));\n        data.SQColumnRefExpr = SQColumnRefExpr;\n        var SQMeasureRefExpr = (function (_super) {\n            __extends(SQMeasureRefExpr, _super);\n            function SQMeasureRefExpr(source, ref) {\n                _super.call(this, 2 /* MeasureRef */, source, ref);\n            }\n            SQMeasureRefExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitMeasureRef(this, arg);\n            };\n            return SQMeasureRefExpr;\n        }(SQPropRefExpr));\n        data.SQMeasureRefExpr = SQMeasureRefExpr;\n        var SQAggregationExpr = (function (_super) {\n            __extends(SQAggregationExpr, _super);\n            function SQAggregationExpr(arg, func) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(func, 'func');\n                _super.call(this, 3 /* Aggregation */);\n                this.arg = arg;\n                this.func = func;\n            }\n            SQAggregationExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAggr(this, arg);\n            };\n            return SQAggregationExpr;\n        }(SQExpr));\n        data.SQAggregationExpr = SQAggregationExpr;\n        var SQPercentileExpr = (function (_super) {\n            __extends(SQPercentileExpr, _super);\n            function SQPercentileExpr(arg, k, exclusive) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(k, 'k');\n                debug.assert(0 <= k && k <= 1, '0 <= k && k <= 1');\n                debug.assertValue(exclusive, 'exclusive');\n                _super.call(this, 27 /* Percentile */);\n                this.arg = arg;\n                this.k = k;\n                this.exclusive = exclusive;\n            }\n            SQPercentileExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                var argMetadata = this.arg.getMetadata(federatedSchema);\n                if (argMetadata) {\n                    return {\n                        kind: 1 /* Measure */,\n                        type: argMetadata.type,\n                    };\n                }\n            };\n            SQPercentileExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPercentile(this, arg);\n            };\n            return SQPercentileExpr;\n        }(SQExpr));\n        data.SQPercentileExpr = SQPercentileExpr;\n        var SQPropertyVariationSourceExpr = (function (_super) {\n            __extends(SQPropertyVariationSourceExpr, _super);\n            function SQPropertyVariationSourceExpr(arg, name, property) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(name, 'name');\n                debug.assertValue(property, 'property');\n                _super.call(this, 4 /* PropertyVariationSource */);\n                this.arg = arg;\n                this.name = name;\n                this.property = property;\n            }\n            SQPropertyVariationSourceExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitPropertyVariationSource(this, arg);\n            };\n            return SQPropertyVariationSourceExpr;\n        }(SQExpr));\n        data.SQPropertyVariationSourceExpr = SQPropertyVariationSourceExpr;\n        var SQHierarchyExpr = (function (_super) {\n            __extends(SQHierarchyExpr, _super);\n            function SQHierarchyExpr(arg, hierarchy) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(hierarchy, 'hierarchy');\n                _super.call(this, 5 /* Hierarchy */);\n                this.arg = arg;\n                this.hierarchy = hierarchy;\n            }\n            SQHierarchyExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchy(this, arg);\n            };\n            return SQHierarchyExpr;\n        }(SQExpr));\n        data.SQHierarchyExpr = SQHierarchyExpr;\n        var SQHierarchyLevelExpr = (function (_super) {\n            __extends(SQHierarchyLevelExpr, _super);\n            function SQHierarchyLevelExpr(arg, level) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(level, 'level');\n                _super.call(this, 6 /* HierarchyLevel */);\n                this.arg = arg;\n                this.level = level;\n            }\n            SQHierarchyLevelExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitHierarchyLevel(this, arg);\n            };\n            return SQHierarchyLevelExpr;\n        }(SQExpr));\n        data.SQHierarchyLevelExpr = SQHierarchyLevelExpr;\n        var SQAndExpr = (function (_super) {\n            __extends(SQAndExpr, _super);\n            function SQAndExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 7 /* And */);\n                this.left = left;\n                this.right = right;\n            }\n            SQAndExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnd(this, arg);\n            };\n            return SQAndExpr;\n        }(SQExpr));\n        data.SQAndExpr = SQAndExpr;\n        var SQBetweenExpr = (function (_super) {\n            __extends(SQBetweenExpr, _super);\n            function SQBetweenExpr(arg, lower, upper) {\n                debug.assertValue(arg, 'arg');\n                debug.assertValue(lower, 'lower');\n                debug.assertValue(upper, 'upper');\n                _super.call(this, 8 /* Between */);\n                this.arg = arg;\n                this.lower = lower;\n                this.upper = upper;\n            }\n            SQBetweenExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitBetween(this, arg);\n            };\n            return SQBetweenExpr;\n        }(SQExpr));\n        data.SQBetweenExpr = SQBetweenExpr;\n        var SQInExpr = (function (_super) {\n            __extends(SQInExpr, _super);\n            function SQInExpr(args, values) {\n                debug.assertValue(args, 'args');\n                debug.assertValue(values, 'values');\n                _super.call(this, 9 /* In */);\n                this.args = args;\n                this.values = values;\n            }\n            SQInExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitIn(this, arg);\n            };\n            return SQInExpr;\n        }(SQExpr));\n        data.SQInExpr = SQInExpr;\n        var SQOrExpr = (function (_super) {\n            __extends(SQOrExpr, _super);\n            function SQOrExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 10 /* Or */);\n                this.left = left;\n                this.right = right;\n            }\n            SQOrExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitOr(this, arg);\n            };\n            return SQOrExpr;\n        }(SQExpr));\n        data.SQOrExpr = SQOrExpr;\n        var SQCompareExpr = (function (_super) {\n            __extends(SQCompareExpr, _super);\n            function SQCompareExpr(comparison, left, right) {\n                debug.assertValue(comparison, 'kind');\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 12 /* Compare */);\n                this.comparison = comparison;\n                this.left = left;\n                this.right = right;\n            }\n            SQCompareExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitCompare(this, arg);\n            };\n            return SQCompareExpr;\n        }(SQExpr));\n        data.SQCompareExpr = SQCompareExpr;\n        var SQContainsExpr = (function (_super) {\n            __extends(SQContainsExpr, _super);\n            function SQContainsExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 11 /* Contains */);\n                this.left = left;\n                this.right = right;\n            }\n            SQContainsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitContains(this, arg);\n            };\n            return SQContainsExpr;\n        }(SQExpr));\n        data.SQContainsExpr = SQContainsExpr;\n        var SQStartsWithExpr = (function (_super) {\n            __extends(SQStartsWithExpr, _super);\n            function SQStartsWithExpr(left, right) {\n                debug.assertValue(left, 'left');\n                debug.assertValue(right, 'right');\n                _super.call(this, 13 /* StartsWith */);\n                this.left = left;\n                this.right = right;\n            }\n            SQStartsWithExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitStartsWith(this, arg);\n            };\n            return SQStartsWithExpr;\n        }(SQExpr));\n        data.SQStartsWithExpr = SQStartsWithExpr;\n        var SQExistsExpr = (function (_super) {\n            __extends(SQExistsExpr, _super);\n            function SQExistsExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 14 /* Exists */);\n                this.arg = arg;\n            }\n            SQExistsExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitExists(this, arg);\n            };\n            return SQExistsExpr;\n        }(SQExpr));\n        data.SQExistsExpr = SQExistsExpr;\n        var SQNotExpr = (function (_super) {\n            __extends(SQNotExpr, _super);\n            function SQNotExpr(arg) {\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 15 /* Not */);\n                this.arg = arg;\n            }\n            SQNotExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNot(this, arg);\n            };\n            return SQNotExpr;\n        }(SQExpr));\n        data.SQNotExpr = SQNotExpr;\n        var SQConstantExpr = (function (_super) {\n            __extends(SQConstantExpr, _super);\n            function SQConstantExpr(type, value, valueEncoded) {\n                debug.assertValue(type, 'type');\n                _super.call(this, 16 /* Constant */);\n                this.type = type;\n                this.value = value;\n                this.valueEncoded = valueEncoded;\n            }\n            SQConstantExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitConstant(this, arg);\n            };\n            SQConstantExpr.prototype.getMetadata = function (federatedSchema) {\n                debug.assertValue(federatedSchema, 'federatedSchema');\n                return {\n                    // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\n                    // A getType or similiar function in the future would be more appropriate. \n                    kind: 1 /* Measure */,\n                    type: this.type,\n                };\n            };\n            return SQConstantExpr;\n        }(SQExpr));\n        data.SQConstantExpr = SQConstantExpr;\n        var SQDateSpanExpr = (function (_super) {\n            __extends(SQDateSpanExpr, _super);\n            function SQDateSpanExpr(unit, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 17 /* DateSpan */);\n                this.unit = unit;\n                this.arg = arg;\n            }\n            SQDateSpanExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateSpan(this, arg);\n            };\n            return SQDateSpanExpr;\n        }(SQExpr));\n        data.SQDateSpanExpr = SQDateSpanExpr;\n        var SQDateAddExpr = (function (_super) {\n            __extends(SQDateAddExpr, _super);\n            function SQDateAddExpr(unit, amount, arg) {\n                debug.assertValue(unit, 'unit');\n                debug.assertValue(amount, 'amount');\n                debug.assertValue(arg, 'arg');\n                _super.call(this, 18 /* DateAdd */);\n                this.unit = unit;\n                this.arg = arg;\n                this.amount = amount;\n            }\n            SQDateAddExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDateAdd(this, arg);\n            };\n            return SQDateAddExpr;\n        }(SQExpr));\n        data.SQDateAddExpr = SQDateAddExpr;\n        var SQNowExpr = (function (_super) {\n            __extends(SQNowExpr, _super);\n            function SQNowExpr() {\n                _super.call(this, 19 /* Now */);\n            }\n            SQNowExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitNow(this, arg);\n            };\n            return SQNowExpr;\n        }(SQExpr));\n        data.SQNowExpr = SQNowExpr;\n        var SQDefaultValueExpr = (function (_super) {\n            __extends(SQDefaultValueExpr, _super);\n            function SQDefaultValueExpr() {\n                _super.call(this, 21 /* DefaultValue */);\n            }\n            SQDefaultValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitDefaultValue(this, arg);\n            };\n            return SQDefaultValueExpr;\n        }(SQExpr));\n        data.SQDefaultValueExpr = SQDefaultValueExpr;\n        var SQAnyValueExpr = (function (_super) {\n            __extends(SQAnyValueExpr, _super);\n            function SQAnyValueExpr() {\n                _super.call(this, 20 /* AnyValue */);\n            }\n            SQAnyValueExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitAnyValue(this, arg);\n            };\n            return SQAnyValueExpr;\n        }(SQExpr));\n        data.SQAnyValueExpr = SQAnyValueExpr;\n        var SQFillRuleExpr = (function (_super) {\n            __extends(SQFillRuleExpr, _super);\n            function SQFillRuleExpr(input, fillRule) {\n                debug.assertValue(input, 'input');\n                debug.assertValue(fillRule, 'fillRule');\n                _super.call(this, 23 /* FillRule */);\n                this.input = input;\n                this.rule = fillRule;\n            }\n            SQFillRuleExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitFillRule(this, arg);\n            };\n            return SQFillRuleExpr;\n        }(SQExpr));\n        data.SQFillRuleExpr = SQFillRuleExpr;\n        var SQResourcePackageItemExpr = (function (_super) {\n            __extends(SQResourcePackageItemExpr, _super);\n            function SQResourcePackageItemExpr(packageName, packageType, itemName) {\n                debug.assertValue(packageName, 'packageName');\n                debug.assertValue(itemName, 'itemName');\n                _super.call(this, 24 /* ResourcePackageItem */);\n                this.packageName = packageName;\n                this.packageType = packageType;\n                this.itemName = itemName;\n            }\n            SQResourcePackageItemExpr.prototype.accept = function (visitor, arg) {\n                return visitor.visitResourcePackageItem(this, arg);\n            };\n            return SQResourcePackageItemExpr;\n        }(SQExpr));\n        data.SQResourcePackageItemExpr = SQResourcePackageItemExpr;\n        /** Provides utilities for creating & manipulating expressions. */\n        var SQExprBuilder;\n        (function (SQExprBuilder) {\n            function entity(schema, entity, variable) {\n                return new SQEntityExpr(schema, entity, variable);\n            }\n            SQExprBuilder.entity = entity;\n            function columnRef(source, prop) {\n                return new SQColumnRefExpr(source, prop);\n            }\n            SQExprBuilder.columnRef = columnRef;\n            function measureRef(source, prop) {\n                return new SQMeasureRefExpr(source, prop);\n            }\n            SQExprBuilder.measureRef = measureRef;\n            function aggregate(source, aggregate) {\n                return new SQAggregationExpr(source, aggregate);\n            }\n            SQExprBuilder.aggregate = aggregate;\n            function percentile(source, k, exclusive) {\n                return new SQPercentileExpr(source, k, exclusive);\n            }\n            SQExprBuilder.percentile = percentile;\n            function arithmetic(left, right, operator) {\n                return new SQArithmeticExpr(left, right, operator);\n            }\n            SQExprBuilder.arithmetic = arithmetic;\n            function scopedEval(expression, scope) {\n                return new SQScopedEvalExpr(expression, scope);\n            }\n            SQExprBuilder.scopedEval = scopedEval;\n            function hierarchy(source, hierarchy) {\n                return new SQHierarchyExpr(source, hierarchy);\n            }\n            SQExprBuilder.hierarchy = hierarchy;\n            function propertyVariationSource(source, name, property) {\n                return new SQPropertyVariationSourceExpr(source, name, property);\n            }\n            SQExprBuilder.propertyVariationSource = propertyVariationSource;\n            function hierarchyLevel(source, level) {\n                return new SQHierarchyLevelExpr(source, level);\n            }\n            SQExprBuilder.hierarchyLevel = hierarchyLevel;\n            function and(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                return new SQAndExpr(left, right);\n            }\n            SQExprBuilder.and = and;\n            function between(arg, lower, upper) {\n                return new SQBetweenExpr(arg, lower, upper);\n            }\n            SQExprBuilder.between = between;\n            function inExpr(args, values) {\n                return new SQInExpr(args, values);\n            }\n            SQExprBuilder.inExpr = inExpr;\n            function or(left, right) {\n                if (!left)\n                    return right;\n                if (!right)\n                    return left;\n                if (left instanceof SQInExpr && right instanceof SQInExpr) {\n                    var inExpr_1 = tryUseInExprs(left, right);\n                    if (inExpr_1)\n                        return inExpr_1;\n                }\n                return new SQOrExpr(left, right);\n            }\n            SQExprBuilder.or = or;\n            function tryUseInExprs(left, right) {\n                if (!left.args || !right.args)\n                    return;\n                var leftArgLen = left.args.length;\n                var rightArgLen = right.args.length;\n                if (leftArgLen !== rightArgLen)\n                    return;\n                for (var i = 0; i < leftArgLen; ++i) {\n                    if (!SQExpr.equals(left.args[i], right.args[i]))\n                        return;\n                }\n                var combinedValues = left.values.concat(right.values);\n                return SQExprBuilder.inExpr(left.args, combinedValues);\n            }\n            function compare(kind, left, right) {\n                return new SQCompareExpr(kind, left, right);\n            }\n            SQExprBuilder.compare = compare;\n            function contains(left, right) {\n                return new SQContainsExpr(left, right);\n            }\n            SQExprBuilder.contains = contains;\n            function exists(arg) {\n                return new SQExistsExpr(arg);\n            }\n            SQExprBuilder.exists = exists;\n            function equal(left, right) {\n                return compare(data.QueryComparisonKind.Equal, left, right);\n            }\n            SQExprBuilder.equal = equal;\n            function not(arg) {\n                return new SQNotExpr(arg);\n            }\n            SQExprBuilder.not = not;\n            function startsWith(left, right) {\n                return new SQStartsWithExpr(left, right);\n            }\n            SQExprBuilder.startsWith = startsWith;\n            function nullConstant() {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Null), null, data.PrimitiveValueEncoding.nullEncoding());\n            }\n            SQExprBuilder.nullConstant = nullConstant;\n            function now() {\n                return new SQNowExpr();\n            }\n            SQExprBuilder.now = now;\n            function defaultValue() {\n                return new SQDefaultValueExpr();\n            }\n            SQExprBuilder.defaultValue = defaultValue;\n            function anyValue() {\n                return new SQAnyValueExpr();\n            }\n            SQExprBuilder.anyValue = anyValue;\n            function boolean(value) {\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Boolean), value, data.PrimitiveValueEncoding.boolean(value));\n            }\n            SQExprBuilder.boolean = boolean;\n            function dateAdd(unit, amount, arg) {\n                return new SQDateAddExpr(unit, amount, arg);\n            }\n            SQExprBuilder.dateAdd = dateAdd;\n            function dateTime(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.dateTime(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.DateTime), value, valueEncoded);\n            }\n            SQExprBuilder.dateTime = dateTime;\n            function dateSpan(unit, arg) {\n                return new SQDateSpanExpr(unit, arg);\n            }\n            SQExprBuilder.dateSpan = dateSpan;\n            function decimal(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.decimal(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Decimal), value, valueEncoded);\n            }\n            SQExprBuilder.decimal = decimal;\n            function double(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.double(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double), value, valueEncoded);\n            }\n            SQExprBuilder.double = double;\n            function integer(value, valueEncoded) {\n                if (valueEncoded === undefined)\n                    valueEncoded = data.PrimitiveValueEncoding.integer(value);\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer), value, valueEncoded);\n            }\n            SQExprBuilder.integer = integer;\n            function text(value, valueEncoded) {\n                debug.assert(!valueEncoded || valueEncoded === data.PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\n                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Text), value, valueEncoded || data.PrimitiveValueEncoding.text(value));\n            }\n            SQExprBuilder.text = text;\n            /** Returns an SQExpr that evaluates to the constant value. */\n            function typedConstant(value, type) {\n                if (value == null)\n                    return nullConstant();\n                if (_.isBoolean(value)) {\n                    return boolean(value);\n                }\n                if (_.isString(value)) {\n                    return text(value);\n                }\n                if (_.isNumber(value)) {\n                    if (type.integer && powerbi.Double.isInteger(value))\n                        return integer(value);\n                    return double(value);\n                }\n                if (value instanceof Date) {\n                    return dateTime(value);\n                }\n            }\n            SQExprBuilder.typedConstant = typedConstant;\n            function setAggregate(expr, aggregate) {\n                return FieldExprChangeAggregateRewriter.rewrite(expr, aggregate);\n            }\n            SQExprBuilder.setAggregate = setAggregate;\n            function removeAggregate(expr) {\n                return SQExprRemoveAggregateRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeAggregate = removeAggregate;\n            function setPercentOfGrandTotal(expr) {\n                return SQExprSetPercentOfGrandTotalRewriter.rewrite(expr);\n            }\n            SQExprBuilder.setPercentOfGrandTotal = setPercentOfGrandTotal;\n            function removePercentOfGrandTotal(expr) {\n                return SQExprRemovePercentOfGrandTotalRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removePercentOfGrandTotal = removePercentOfGrandTotal;\n            function removeEntityVariables(expr) {\n                return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\n            }\n            SQExprBuilder.removeEntityVariables = removeEntityVariables;\n            function fillRule(expr, rule) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(rule, 'rule');\n                return new SQFillRuleExpr(expr, rule);\n            }\n            SQExprBuilder.fillRule = fillRule;\n            function resourcePackageItem(packageName, packageType, itemName) {\n                return new SQResourcePackageItemExpr(packageName, packageType, itemName);\n            }\n            SQExprBuilder.resourcePackageItem = resourcePackageItem;\n        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));\n        /** Provides utilities for obtaining information about expressions. */\n        var SQExprInfo;\n        (function (SQExprInfo) {\n            function getAggregate(expr) {\n                return SQExprAggregateInfoVisitor.getAggregate(expr);\n            }\n            SQExprInfo.getAggregate = getAggregate;\n        })(SQExprInfo = data.SQExprInfo || (data.SQExprInfo = {}));\n        var SQExprEqualityVisitor = (function () {\n            function SQExprEqualityVisitor(ignoreCase) {\n                this.ignoreCase = ignoreCase;\n            }\n            SQExprEqualityVisitor.run = function (x, y, ignoreCase) {\n                // Normalize falsy to null\n                x = x || null;\n                y = y || null;\n                if (x === y)\n                    return true;\n                if (!x !== !y)\n                    return false;\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                if (ignoreCase)\n                    return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\n                return x.accept(SQExprEqualityVisitor.instance, y);\n            };\n            SQExprEqualityVisitor.prototype.visitColumnRef = function (expr, comparand) {\n                return comparand instanceof SQColumnRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitMeasureRef = function (expr, comparand) {\n                return comparand instanceof SQMeasureRefExpr &&\n                    expr.ref === comparand.ref &&\n                    this.equals(expr.source, comparand.source);\n            };\n            SQExprEqualityVisitor.prototype.visitAggr = function (expr, comparand) {\n                return comparand instanceof SQAggregationExpr &&\n                    expr.func === comparand.func &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPercentile = function (expr, comparand) {\n                return comparand instanceof SQPercentileExpr &&\n                    expr.exclusive === comparand.exclusive &&\n                    expr.k === comparand.k &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchy = function (expr, comparand) {\n                return comparand instanceof SQHierarchyExpr &&\n                    expr.hierarchy === comparand.hierarchy &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitHierarchyLevel = function (expr, comparand) {\n                return comparand instanceof SQHierarchyLevelExpr &&\n                    expr.level === comparand.level &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitPropertyVariationSource = function (expr, comparand) {\n                return comparand instanceof SQPropertyVariationSourceExpr &&\n                    expr.name === comparand.name &&\n                    expr.property === comparand.property &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitBetween = function (expr, comparand) {\n                return comparand instanceof SQBetweenExpr &&\n                    this.equals(expr.arg, comparand.arg) &&\n                    this.equals(expr.lower, comparand.lower) &&\n                    this.equals(expr.upper, comparand.upper);\n            };\n            SQExprEqualityVisitor.prototype.visitIn = function (expr, comparand) {\n                if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, comparand.args))\n                    return false;\n                var values = expr.values, compareValues = comparand.values;\n                if (values.length !== compareValues.length)\n                    return false;\n                for (var i = 0, len = values.length; i < len; i++) {\n                    if (!this.equalsAll(values[i], compareValues[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.visitEntity = function (expr, comparand) {\n                return comparand instanceof SQEntityExpr &&\n                    expr.schema === comparand.schema &&\n                    expr.entity === comparand.entity &&\n                    this.optionalEqual(expr.variable, comparand.variable);\n            };\n            SQExprEqualityVisitor.prototype.visitAnd = function (expr, comparand) {\n                return comparand instanceof SQAndExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitOr = function (expr, comparand) {\n                return comparand instanceof SQOrExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitCompare = function (expr, comparand) {\n                return comparand instanceof SQCompareExpr &&\n                    expr.comparison === comparand.comparison &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitContains = function (expr, comparand) {\n                return comparand instanceof SQContainsExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitDateSpan = function (expr, comparand) {\n                return comparand instanceof SQDateSpanExpr &&\n                    expr.unit === comparand.unit &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitDateAdd = function (expr, comparand) {\n                return comparand instanceof SQDateAddExpr &&\n                    expr.unit === comparand.unit &&\n                    expr.amount === comparand.amount &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitExists = function (expr, comparand) {\n                return comparand instanceof SQExistsExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNot = function (expr, comparand) {\n                return comparand instanceof SQNotExpr &&\n                    this.equals(expr.arg, comparand.arg);\n            };\n            SQExprEqualityVisitor.prototype.visitNow = function (expr, comparand) {\n                return comparand instanceof SQNowExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitDefaultValue = function (expr, comparand) {\n                return comparand instanceof SQDefaultValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitAnyValue = function (expr, comparand) {\n                return comparand instanceof SQAnyValueExpr;\n            };\n            SQExprEqualityVisitor.prototype.visitResourcePackageItem = function (expr, comparand) {\n                return comparand instanceof SQResourcePackageItemExpr &&\n                    expr.packageName === comparand.packageName &&\n                    expr.packageType === comparand.packageType &&\n                    expr.itemName === comparand.itemName;\n            };\n            SQExprEqualityVisitor.prototype.visitStartsWith = function (expr, comparand) {\n                return comparand instanceof SQStartsWithExpr &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitConstant = function (expr, comparand) {\n                if (comparand instanceof SQConstantExpr && expr.type === comparand.type)\n                    return expr.type.text && this.ignoreCase ?\n                        StringExtensions.equalIgnoreCase(expr.valueEncoded, comparand.valueEncoded) :\n                        expr.valueEncoded === comparand.valueEncoded;\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitFillRule = function (expr, comparand) {\n                if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\n                    var leftRule = expr.rule, rightRule = comparand.rule;\n                    if (leftRule === rightRule)\n                        return true;\n                    var leftLinearGradient2 = leftRule.linearGradient2, rightLinearGradient2 = rightRule.linearGradient2;\n                    if (leftLinearGradient2 && rightLinearGradient2) {\n                        return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\n                    }\n                    var leftLinearGradient3 = leftRule.linearGradient3, rightLinearGradient3 = rightRule.linearGradient3;\n                    if (leftLinearGradient3 && rightLinearGradient3) {\n                        return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\n                    }\n                }\n                return false;\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient2 = function (left2, right2) {\n                debug.assertValue(left2, 'left2');\n                debug.assertValue(right2, 'right2');\n                return this.equalsFillRuleStop(left2.min, right2.min) &&\n                    this.equalsFillRuleStop(left2.max, right2.max);\n            };\n            SQExprEqualityVisitor.prototype.visitLinearGradient3 = function (left3, right3) {\n                debug.assertValue(left3, 'left3');\n                debug.assertValue(right3, 'right3');\n                return this.equalsFillRuleStop(left3.min, right3.min) &&\n                    this.equalsFillRuleStop(left3.mid, right3.mid) &&\n                    this.equalsFillRuleStop(left3.max, right3.max);\n            };\n            SQExprEqualityVisitor.prototype.equalsFillRuleStop = function (stop1, stop2) {\n                debug.assertValue(stop1, 'stop1');\n                debug.assertValue(stop2, 'stop2');\n                if (!this.equals(stop1.color, stop2.color))\n                    return false;\n                if (!stop1.value)\n                    return stop1.value === stop2.value;\n                return this.equals(stop1.value, stop2.value);\n            };\n            SQExprEqualityVisitor.prototype.visitArithmetic = function (expr, comparand) {\n                return comparand instanceof SQArithmeticExpr &&\n                    expr.operator === comparand.operator &&\n                    this.equals(expr.left, comparand.left) &&\n                    this.equals(expr.right, comparand.right);\n            };\n            SQExprEqualityVisitor.prototype.visitScopedEval = function (expr, comparand) {\n                return comparand instanceof SQScopedEvalExpr &&\n                    this.equals(expr.expression, comparand.expression) &&\n                    this.equalsAll(expr.scope, comparand.scope);\n            };\n            SQExprEqualityVisitor.prototype.optionalEqual = function (x, y) {\n                // Only check equality if both values are specified.\n                if (x && y)\n                    return x === y;\n                return true;\n            };\n            SQExprEqualityVisitor.prototype.equals = function (x, y) {\n                return x.accept(this, y);\n            };\n            SQExprEqualityVisitor.prototype.equalsAll = function (x, y) {\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!this.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            };\n            SQExprEqualityVisitor.instance = new SQExprEqualityVisitor(/* ignoreCase */ false);\n            SQExprEqualityVisitor.ignoreCaseInstance = new SQExprEqualityVisitor(true);\n            return SQExprEqualityVisitor;\n        }());\n        /** Rewrites a root-level expression. */\n        var SQExprRootRewriter = (function (_super) {\n            __extends(SQExprRootRewriter, _super);\n            function SQExprRootRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRootRewriter.prototype.visitDefault = function (expr) {\n                return expr;\n            };\n            return SQExprRootRewriter;\n        }(data.DefaultSQExprVisitor));\n        var SQExprValidationVisitor = (function (_super) {\n            __extends(SQExprValidationVisitor, _super);\n            function SQExprValidationVisitor(schema, aggrUtils, errors) {\n                debug.assertValue(schema, 'schema');\n                debug.assertValue(aggrUtils, 'aggrUtils');\n                _super.call(this);\n                this.schema = schema;\n                this.aggrUtils = aggrUtils;\n                if (errors)\n                    this.errors = errors;\n            }\n            SQExprValidationVisitor.prototype.visitIn = function (expr) {\n                var inExpr = _super.prototype.visitIn.call(this, expr);\n                var args = inExpr.args;\n                var values = inExpr.values;\n                for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {\n                    var valueTuple = values_2[_i];\n                    debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\n                    for (var i = 0, len = valueTuple.length; i < len; ++i)\n                        this.validateCompatibleType(args[i], valueTuple[i]);\n                }\n                return inExpr;\n            };\n            SQExprValidationVisitor.prototype.visitCompare = function (expr) {\n                var compareExpr = _super.prototype.visitCompare.call(this, expr);\n                this.validateCompatibleType(compareExpr.left, compareExpr.right);\n                return compareExpr;\n            };\n            SQExprValidationVisitor.prototype.visitColumnRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.column.name);\n                        if (!prop ||\n                            prop.kind !== 0 /* Column */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(3 /* invalidColumnReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitMeasureRef = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\n                    if (entity) {\n                        var prop = entity.properties.withName(fieldExpr.measure.name);\n                        if (!prop ||\n                            prop.kind !== 1 /* Measure */ ||\n                            !this.isQueryable(fieldExpr))\n                            this.register(4 /* invalidMeasureReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitAggr = function (expr) {\n                var aggregateExpr = _super.prototype.visitAggr.call(this, expr);\n                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\n                if (columnRefExpr) {\n                    if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/ null))\n                        this.register(0 /* invalidAggregateFunction */);\n                }\n                return aggregateExpr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchy = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var fieldExprItem = fieldExpr.hierarchy;\n                    if (fieldExprItem) {\n                        this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\n                    }\n                    else {\n                        this.register(5 /* invalidHierarchyReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr) {\n                    var hierarchyLevelFieldExprItem = fieldExpr.hierarchyLevel;\n                    if (hierarchyLevelFieldExprItem) {\n                        this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\n                    }\n                    else if (!fieldExpr.columnHierarchyLevelVariation) {\n                        this.register(6 /* invalidHierarchyLevelReference */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitPercentile = function (expr) {\n                expr.arg.accept(this);\n                if (_.isEmpty(this.errors)) {\n                    var argMetadata = expr.arg.getMetadata(this.schema);\n                    if (!argMetadata ||\n                        argMetadata.kind !== 0 /* Column */ ||\n                        !(argMetadata.type && (argMetadata.type.integer || argMetadata.type.numeric))) {\n                        this.register(10 /* invalidPercentileArgument */);\n                    }\n                }\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitEntity = function (expr) {\n                this.validateEntity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitContains = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitStartsWith = function (expr) {\n                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitArithmetic = function (expr) {\n                this.validateArithmeticTypes(expr.left, expr.right);\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.visitScopedEval = function (expr) {\n                // No validation necessary\n                return expr;\n            };\n            SQExprValidationVisitor.prototype.validateOperandsAndTypeForStartOrContains = function (left, right) {\n                if (left instanceof SQColumnRefExpr) {\n                    this.visitColumnRef(left);\n                }\n                else if (left instanceof SQHierarchyLevelExpr) {\n                    this.visitHierarchyLevel(left);\n                }\n                else {\n                    this.register(7 /* invalidLeftOperandType */);\n                }\n                if (!(right instanceof SQConstantExpr) || !right.type.text)\n                    this.register(8 /* invalidRightOperandType */);\n                else\n                    this.validateCompatibleType(left, right);\n            };\n            SQExprValidationVisitor.prototype.validateArithmeticTypes = function (left, right) {\n                if (!data.SQExprUtils.supportsArithmetic(left, this.schema))\n                    this.register(7 /* invalidLeftOperandType */);\n                if (!data.SQExprUtils.supportsArithmetic(right, this.schema))\n                    this.register(8 /* invalidRightOperandType */);\n            };\n            SQExprValidationVisitor.prototype.validateCompatibleType = function (left, right) {\n                var leftMetadata = left.getMetadata(this.schema), leftType = leftMetadata && leftMetadata.type, rightMetadata = right.getMetadata(this.schema), rightType = rightMetadata && rightMetadata.type;\n                if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\n                    this.register(9 /* invalidValueType */);\n            };\n            SQExprValidationVisitor.prototype.validateEntity = function (schemaName, entityName) {\n                var schema = this.schema.schema(schemaName);\n                if (schema) {\n                    var entity = schema.entities.withName(entityName);\n                    if (entity)\n                        return entity;\n                    this.register(2 /* invalidEntityReference */);\n                }\n                else {\n                    this.register(1 /* invalidSchemaReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchy = function (schemaName, entityName, hierarchyName) {\n                var entity = this.validateEntity(schemaName, entityName);\n                if (entity) {\n                    var hierarchy = entity.hierarchies.withName(hierarchyName);\n                    if (hierarchy)\n                        return hierarchy;\n                    this.register(5 /* invalidHierarchyReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.validateHierarchyLevel = function (schemaName, entityName, hierarchyName, levelName) {\n                var hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\n                if (hierarchy) {\n                    var hierarchyLevel = hierarchy.levels.withName(levelName);\n                    if (hierarchyLevel)\n                        return hierarchyLevel;\n                    this.register(6 /* invalidHierarchyLevelReference */);\n                }\n            };\n            SQExprValidationVisitor.prototype.register = function (error) {\n                if (!this.errors)\n                    this.errors = [];\n                this.errors.push(error);\n            };\n            SQExprValidationVisitor.prototype.isQueryable = function (fieldExpr) {\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\n                if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\n                    var hierarchyLevelConceptualProperty = data.SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\n                    return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== 1 /* Error */;\n                }\n                return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, data.FieldExprPattern.getPropertyName(fieldExpr)).queryable !== 1 /* Error */;\n            };\n            return SQExprValidationVisitor;\n        }(data.SQExprRewriter));\n        data.SQExprValidationVisitor = SQExprValidationVisitor;\n        /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\n        var SQExprAggregateInfoVisitor = (function (_super) {\n            __extends(SQExprAggregateInfoVisitor, _super);\n            function SQExprAggregateInfoVisitor() {\n                _super.apply(this, arguments);\n            }\n            SQExprAggregateInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.func;\n            };\n            SQExprAggregateInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprAggregateInfoVisitor.getAggregate = function (expr) {\n                var visitor = new SQExprAggregateInfoVisitor();\n                return expr.accept(visitor);\n            };\n            return SQExprAggregateInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQExprColumnRef expression or undefined.*/\n        var SQExprColumnRefInfoVisitor = (function (_super) {\n            __extends(SQExprColumnRefInfoVisitor, _super);\n            function SQExprColumnRefInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQExprColumnRefInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return expr;\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var ref = expr.level;\n                var hierarchy = (expr.arg);\n                var sourceExpr = hierarchy.accept(this);\n                if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\n                    var propertyVariationSource = hierarchy.arg;\n                    var targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\n                    if (sourceExpr && targetEntity) {\n                        var schemaName = (sourceExpr.source).schema;\n                        var targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\n                        var schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\n                        if (schemaHierarchy) {\n                            for (var _i = 0, _a = schemaHierarchy.levels; _i < _a.length; _i++) {\n                                var level = _a[_i];\n                                if (level.name === ref)\n                                    return new SQColumnRefExpr(targetEntityExpr, level.column.name);\n                            }\n                        }\n                    }\n                }\n                else {\n                    var entityExpr = (hierarchy.arg);\n                    var hierarchyLevelRef = data.SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema, entityExpr.schema, entityExpr.entity, hierarchy.hierarchy, expr.level);\n                    if (hierarchyLevelRef)\n                        return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\n                }\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var propertyName = expr.property;\n                return new SQColumnRefExpr(expr.arg, propertyName);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitAggr = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQExprColumnRefInfoVisitor.prototype.visitDefault = function (expr) {\n                return;\n            };\n            SQExprColumnRefInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQExprColumnRefInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        /** Returns a SQEntityExpr expression or undefined.*/\n        var SQEntityExprInfoVisitor = (function (_super) {\n            __extends(SQEntityExprInfoVisitor, _super);\n            function SQEntityExprInfoVisitor(schema) {\n                _super.call(this);\n                this.schema = schema;\n            }\n            SQEntityExprInfoVisitor.prototype.visitEntity = function (expr) {\n                return expr;\n            };\n            SQEntityExprInfoVisitor.prototype.visitColumnRef = function (expr) {\n                return SQEntityExprInfoVisitor.getEntity(expr);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchyLevel = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitHierarchy = function (expr) {\n                return expr.arg.accept(this);\n            };\n            SQEntityExprInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitAggr = function (expr) {\n                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\n                return SQEntityExprInfoVisitor.getEntity(columnRef);\n            };\n            SQEntityExprInfoVisitor.prototype.visitMeasureRef = function (expr) {\n                return expr.source.accept(this);\n            };\n            SQEntityExprInfoVisitor.getColumnRefSQExpr = function (schema, expr) {\n                var visitor = new SQExprColumnRefInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            SQEntityExprInfoVisitor.getEntity = function (columnRef) {\n                var field = data.SQExprConverter.asFieldPattern(columnRef);\n                var column = field.column;\n                return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\n            };\n            SQEntityExprInfoVisitor.getEntityExpr = function (schema, expr) {\n                var visitor = new SQEntityExprInfoVisitor(schema);\n                return expr.accept(visitor);\n            };\n            return SQEntityExprInfoVisitor;\n        }(data.DefaultSQExprVisitor));\n        var SQExprChangeAggregateRewriter = (function (_super) {\n            __extends(SQExprChangeAggregateRewriter, _super);\n            function SQExprChangeAggregateRewriter(func) {\n                debug.assertValue(func, 'func');\n                _super.call(this);\n                this.func = func;\n            }\n            SQExprChangeAggregateRewriter.prototype.visitAggr = function (expr) {\n                if (expr.func === this.func)\n                    return expr;\n                return new SQAggregationExpr(expr.arg, this.func);\n            };\n            SQExprChangeAggregateRewriter.prototype.visitColumnRef = function (expr) {\n                return new SQAggregationExpr(expr, this.func);\n            };\n            SQExprChangeAggregateRewriter.rewrite = function (expr, func) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(func, 'func');\n                var rewriter = new SQExprChangeAggregateRewriter(func);\n                return expr.accept(rewriter);\n            };\n            return SQExprChangeAggregateRewriter;\n        }(SQExprRootRewriter));\n        var FieldExprChangeAggregateRewriter = (function () {\n            function FieldExprChangeAggregateRewriter(sqExpr, aggregate) {\n                this.sqExpr = sqExpr;\n                this.aggregate = aggregate;\n            }\n            FieldExprChangeAggregateRewriter.rewrite = function (sqExpr, aggregate) {\n                return data.FieldExprPattern.visit(sqExpr, new FieldExprChangeAggregateRewriter(sqExpr, aggregate));\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitPercentOfGrandTotal = function (pattern) {\n                pattern.baseExpr = data.SQExprConverter.asFieldPattern(SQExprChangeAggregateRewriter.rewrite(SQExprBuilder.fieldExpr(pattern.baseExpr), this.aggregate));\n                return SQExprBuilder.fieldExpr({ percentOfGrandTotal: pattern });\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumn = function (column) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumnAggr = function (columnAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitEntity = function (entity) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitEntityAggr = function (entityAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchy = function (hierarchy) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevel = function (hierarchyLevel) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitMeasure = function (measure) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.visitPercentile = function (percentile) {\n                return this.defaultRewrite();\n            };\n            FieldExprChangeAggregateRewriter.prototype.defaultRewrite = function () {\n                return SQExprChangeAggregateRewriter.rewrite(this.sqExpr, this.aggregate);\n            };\n            return FieldExprChangeAggregateRewriter;\n        }());\n        var SQExprRemoveAggregateRewriter = (function (_super) {\n            __extends(SQExprRemoveAggregateRewriter, _super);\n            function SQExprRemoveAggregateRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveAggregateRewriter.prototype.visitAggr = function (expr) {\n                return expr.arg;\n            };\n            SQExprRemoveAggregateRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveAggregateRewriter.instance);\n            };\n            SQExprRemoveAggregateRewriter.instance = new SQExprRemoveAggregateRewriter();\n            return SQExprRemoveAggregateRewriter;\n        }(SQExprRootRewriter));\n        var SQExprRemoveEntityVariablesRewriter = (function (_super) {\n            __extends(SQExprRemoveEntityVariablesRewriter, _super);\n            function SQExprRemoveEntityVariablesRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemoveEntityVariablesRewriter.prototype.visitEntity = function (expr) {\n                if (expr.variable)\n                    return SQExprBuilder.entity(expr.schema, expr.entity);\n                return expr;\n            };\n            SQExprRemoveEntityVariablesRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\n            };\n            SQExprRemoveEntityVariablesRewriter.instance = new SQExprRemoveEntityVariablesRewriter();\n            return SQExprRemoveEntityVariablesRewriter;\n        }(data.SQExprRewriter));\n        var SQExprRemovePercentOfGrandTotalRewriter = (function (_super) {\n            __extends(SQExprRemovePercentOfGrandTotalRewriter, _super);\n            function SQExprRemovePercentOfGrandTotalRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprRemovePercentOfGrandTotalRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprRemovePercentOfGrandTotalRewriter.instance);\n            };\n            SQExprRemovePercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr && fieldExpr.percentOfGrandTotal)\n                    expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfGrandTotal.baseExpr);\n                return expr;\n            };\n            SQExprRemovePercentOfGrandTotalRewriter.instance = new SQExprRemovePercentOfGrandTotalRewriter();\n            return SQExprRemovePercentOfGrandTotalRewriter;\n        }(SQExprRootRewriter));\n        var SQExprSetPercentOfGrandTotalRewriter = (function (_super) {\n            __extends(SQExprSetPercentOfGrandTotalRewriter, _super);\n            function SQExprSetPercentOfGrandTotalRewriter() {\n                _super.apply(this, arguments);\n            }\n            SQExprSetPercentOfGrandTotalRewriter.rewrite = function (expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(SQExprSetPercentOfGrandTotalRewriter.instance);\n            };\n            SQExprSetPercentOfGrandTotalRewriter.prototype.visitDefault = function (expr) {\n                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);\n                if (fieldExpr && !fieldExpr.percentOfGrandTotal)\n                    expr = SQExprBuilder.fieldExpr({ percentOfGrandTotal: { baseExpr: data.SQExprConverter.asFieldPattern(expr) } });\n                return expr;\n            };\n            SQExprSetPercentOfGrandTotalRewriter.instance = new SQExprSetPercentOfGrandTotalRewriter();\n            return SQExprSetPercentOfGrandTotalRewriter;\n        }(SQExprRootRewriter));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        var StringExtensions = jsCommon.StringExtensions;\n        var SQExprUtils;\n        (function (SQExprUtils) {\n            function supportsArithmetic(expr, schema) {\n                var metadata = expr.getMetadata(schema), type = metadata && metadata.type;\n                if (!metadata || !type) {\n                    return false;\n                }\n                return type.numeric || type.dateTime || type.duration;\n            }\n            SQExprUtils.supportsArithmetic = supportsArithmetic;\n            function indexOfExpr(items, searchElement) {\n                debug.assertValue(items, 'items');\n                debug.assertValue(searchElement, 'searchElement');\n                for (var i = 0, len = items.length; i < len; i++) {\n                    if (data.SQExpr.equals(items[i], searchElement))\n                        return i;\n                }\n                return -1;\n            }\n            SQExprUtils.indexOfExpr = indexOfExpr;\n            function sequenceEqual(x, y) {\n                debug.assertValue(x, 'x');\n                debug.assertValue(y, 'y');\n                var len = x.length;\n                if (len !== y.length)\n                    return false;\n                for (var i = 0; i < len; i++) {\n                    if (!data.SQExpr.equals(x[i], y[i]))\n                        return false;\n                }\n                return true;\n            }\n            SQExprUtils.sequenceEqual = sequenceEqual;\n            function uniqueName(namedItems, expr, exprDefaultName) {\n                debug.assertValue(namedItems, 'namedItems');\n                // Determine all names\n                var names = {};\n                for (var i = 0, len = namedItems.length; i < len; i++)\n                    names[namedItems[i].name] = true;\n                return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\n            }\n            SQExprUtils.uniqueName = uniqueName;\n            /** Generates a default expression name  */\n            function defaultName(expr, fallback) {\n                if (fallback === void 0) { fallback = 'select'; }\n                if (!expr)\n                    return fallback;\n                return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\n            }\n            SQExprUtils.defaultName = defaultName;\n            /** Gets a value indicating whether the expr is a model measure or an aggregate. */\n            function isMeasure(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsMeasureVisitor.instance);\n            }\n            SQExprUtils.isMeasure = isMeasure;\n            /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\n            function isAnyValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsAnyValueVisitor.instance);\n            }\n            SQExprUtils.isAnyValue = isAnyValue;\n            /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\n            function isDefaultValue(expr) {\n                debug.assertValue(expr, 'expr');\n                return expr.accept(IsDefaultValueVisitor.instance);\n            }\n            SQExprUtils.isDefaultValue = isDefaultValue;\n            function discourageAggregation(expr, schema) {\n                var capabilities = getSchemaCapabilities(expr, schema);\n                return capabilities && capabilities.discourageQueryAggregateUsage;\n            }\n            SQExprUtils.discourageAggregation = discourageAggregation;\n            function getAggregateBehavior(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var column = getConceptualColumn(expr, schema);\n                if (column)\n                    return column.aggregateBehavior;\n            }\n            SQExprUtils.getAggregateBehavior = getAggregateBehavior;\n            function getSchemaCapabilities(expr, schema) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(schema, 'schema');\n                var field = data.SQExprConverter.asFieldPattern(expr);\n                if (!field)\n                    return;\n                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);\n                var conceptualSchema = schema.schema(fieldExprItem.schema);\n                if (conceptualSchema)\n                    return conceptualSchema.capabilities;\n            }\n            SQExprUtils.getSchemaCapabilities = getSchemaCapabilities;\n            function getKpiMetadata(expr, schema) {\n                var kpiStatusProperty = getKpiStatusProperty(expr, schema);\n                if (kpiStatusProperty)\n                    return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\n                var kpiTrendProperty = getKpiTrendProperty(expr, schema);\n                if (kpiTrendProperty)\n                    return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\n            }\n            SQExprUtils.getKpiMetadata = getKpiMetadata;\n            function getConceptualEntity(entityExpr, schema) {\n                debug.assertValue(entityExpr, 'entityExpr');\n                var conceptualEntity = schema\n                    .schema(entityExpr.schema)\n                    .entities\n                    .withName(entityExpr.entity);\n                return conceptualEntity;\n            }\n            SQExprUtils.getConceptualEntity = getConceptualEntity;\n            function getKpiStatusProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.status === property)\n                    return property;\n            }\n            function getKpiTrendProperty(expr, schema) {\n                var property = expr.getConceptualProperty(schema);\n                if (!property)\n                    return;\n                var kpiValue = property.kpiValue;\n                if (kpiValue && kpiValue.measure.kpi.trend === property)\n                    return property;\n            }\n            function getDefaultValue(fieldSQExpr, schema) {\n                var column = getConceptualColumn(fieldSQExpr, schema);\n                if (column)\n                    return column.defaultValue;\n            }\n            SQExprUtils.getDefaultValue = getDefaultValue;\n            function getConceptualColumn(fieldSQExpr, schema) {\n                if (!fieldSQExpr || !schema)\n                    return;\n                var sqField = data.SQExprConverter.asFieldPattern(fieldSQExpr);\n                if (!sqField)\n                    return;\n                var column = sqField.column;\n                if (column) {\n                    if (schema.schema(column.schema) && sqField.column.name) {\n                        var property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\n                        if (property)\n                            return property.column;\n                    }\n                }\n                else {\n                    var hierarchyLevelField = sqField.hierarchyLevel;\n                    if (hierarchyLevelField) {\n                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(sqField);\n                        var schemaName = fieldExprItem.schema;\n                        if (schema.schema(schemaName)) {\n                            var hierarchy = schema.schema(schemaName)\n                                .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\n                            if (hierarchy) {\n                                var hierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\n                                if (hierarchyLevel && hierarchyLevel.column)\n                                    return hierarchyLevel.column.column;\n                            }\n                        }\n                    }\n                }\n            }\n            function getDefaultValues(fieldSQExprs, schema) {\n                if (_.isEmpty(fieldSQExprs) || !schema)\n                    return;\n                var result = [];\n                for (var _i = 0, fieldSQExprs_2 = fieldSQExprs; _i < fieldSQExprs_2.length; _i++) {\n                    var sqExpr = fieldSQExprs_2[_i];\n                    var defaultValue = getDefaultValue(sqExpr, schema);\n                    if (defaultValue)\n                        result.push(defaultValue);\n                }\n                return result;\n            }\n            SQExprUtils.getDefaultValues = getDefaultValues;\n            /** Return compare or and expression for key value pairs. */\n            function getDataViewScopeIdentityComparisonExpr(fieldsExpr, values) {\n                debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\n                var compareExprs = [];\n                for (var i = 0; i < fieldsExpr.length; i++) {\n                    compareExprs.push(data.SQExprBuilder.compare(data.QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\n                }\n                if (_.isEmpty(compareExprs))\n                    return;\n                var resultExpr;\n                for (var _i = 0, compareExprs_1 = compareExprs; _i < compareExprs_1.length; _i++) {\n                    var compareExpr = compareExprs_1[_i];\n                    resultExpr = data.SQExprBuilder.and(resultExpr, compareExpr);\n                }\n                return resultExpr;\n            }\n            SQExprUtils.getDataViewScopeIdentityComparisonExpr = getDataViewScopeIdentityComparisonExpr;\n            function getActiveTablesNames(queryDefn) {\n                var tables = [];\n                if (queryDefn) {\n                    var selectedItems = queryDefn.from();\n                    if (selectedItems !== undefined) {\n                        for (var _i = 0, _a = selectedItems.keys(); _i < _a.length; _i++) {\n                            var key = _a[_i];\n                            var entityObj = selectedItems.entity(key);\n                            if (tables.indexOf(entityObj.entity) < 0)\n                                tables.push(entityObj.entity);\n                        }\n                    }\n                }\n                return tables;\n            }\n            SQExprUtils.getActiveTablesNames = getActiveTablesNames;\n            function isRelatedToMany(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 0 /* ZeroOrOne */, 2 /* Many */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 2 /* Many */, 0 /* ZeroOrOne */);\n            }\n            SQExprUtils.isRelatedToMany = isRelatedToMany;\n            function isRelatedToOne(schema, sourceExpr, targetExpr) {\n                return isRelated(schema, sourceExpr, targetExpr, 2 /* Many */, 0 /* ZeroOrOne */) ||\n                    isRelated(schema, targetExpr, sourceExpr, 0 /* ZeroOrOne */, 2 /* Many */);\n            }\n            SQExprUtils.isRelatedToOne = isRelatedToOne;\n            function isRelated(schema, sourceExpr, targetExpr, sourceMultiplicity, targetMultiplicity) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                if (_.isEmpty(source.navigationProperties))\n                    return false;\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var queue = [];\n                queue.push(source);\n                // walk the relationship path from source.\n                while (!_.isEmpty(queue)) {\n                    var current = queue.shift();\n                    var navProperties = current.navigationProperties;\n                    if (_.isEmpty(navProperties))\n                        continue;\n                    for (var _i = 0, navProperties_1 = navProperties; _i < navProperties_1.length; _i++) {\n                        var navProperty = navProperties_1[_i];\n                        if (!navProperty.isActive)\n                            continue;\n                        if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\n                            if (navProperty.targetEntity === target)\n                                return true;\n                            queue.push(navProperty.targetEntity);\n                        }\n                    }\n                }\n                return false;\n            }\n            function isRelatedOneToOne(schema, sourceExpr, targetExpr) {\n                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\n                debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\n                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);\n                debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\n                var sourceNavigations = source.navigationProperties;\n                var targetNavigations = target.navigationProperties;\n                if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\n                    return false;\n                return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\n            }\n            SQExprUtils.isRelatedOneToOne = isRelatedOneToOne;\n            function hasOneToOneNavigation(navigationProperties, targetEntity) {\n                if (_.isEmpty(navigationProperties))\n                    return false;\n                for (var _i = 0, navigationProperties_1 = navigationProperties; _i < navigationProperties_1.length; _i++) {\n                    var navigationProperty = navigationProperties_1[_i];\n                    if (!navigationProperty.isActive)\n                        continue;\n                    if (navigationProperty.targetEntity !== targetEntity)\n                        continue;\n                    if (navigationProperty.sourceMultiplicity === 0 /* ZeroOrOne */ &&\n                        navigationProperty.targetMultiplicity === 0 /* ZeroOrOne */) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\n                and returns a new array. When available, we should use _.unionWith from lodash. */\n            function concatUnique(leftExprs, rightExprs) {\n                debug.assertValue(leftExprs, 'leftExprs');\n                debug.assertValue(rightExprs, 'rightExprs');\n                var concatExprs = ArrayExtensions.copy(leftExprs);\n                for (var _i = 0, rightExprs_1 = rightExprs; _i < rightExprs_1.length; _i++) {\n                    var expr = rightExprs_1[_i];\n                    if (indexOfExpr(concatExprs, expr) === -1) {\n                        concatExprs.push(expr);\n                    }\n                }\n                return concatExprs;\n            }\n            SQExprUtils.concatUnique = concatUnique;\n            var SQExprDefaultNameGenerator = (function (_super) {\n                __extends(SQExprDefaultNameGenerator, _super);\n                function SQExprDefaultNameGenerator() {\n                    _super.apply(this, arguments);\n                }\n                SQExprDefaultNameGenerator.prototype.visitEntity = function (expr) {\n                    return expr.entity;\n                };\n                SQExprDefaultNameGenerator.prototype.visitColumnRef = function (expr) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitMeasureRef = function (expr, fallback) {\n                    return expr.source.accept(this) + '.' + expr.ref;\n                };\n                SQExprDefaultNameGenerator.prototype.visitAggr = function (expr, fallback) {\n                    return data.QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitPercentile = function (expr, fallback) {\n                    var func = expr.exclusive\n                        ? 'Percentile.Exc('\n                        : 'Percentile.Inc(';\n                    return func + expr.arg.accept(this) + ', ' + expr.k + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitArithmetic = function (expr, fallback) {\n                    return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\n                };\n                SQExprDefaultNameGenerator.prototype.visitConstant = function (expr) {\n                    return 'const';\n                };\n                SQExprDefaultNameGenerator.prototype.visitDefault = function (expr, fallback) {\n                    return fallback || 'expr';\n                };\n                SQExprDefaultNameGenerator.instance = new SQExprDefaultNameGenerator();\n                return SQExprDefaultNameGenerator;\n            }(data.DefaultSQExprVisitorWithArg));\n            var IsMeasureVisitor = (function (_super) {\n                __extends(IsMeasureVisitor, _super);\n                function IsMeasureVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsMeasureVisitor.prototype.visitMeasureRef = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitAggr = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitArithmetic = function (expr) {\n                    return true;\n                };\n                IsMeasureVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsMeasureVisitor.instance = new IsMeasureVisitor();\n                return IsMeasureVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsDefaultValueVisitor = (function (_super) {\n                __extends(IsDefaultValueVisitor, _super);\n                function IsDefaultValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsDefaultValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsDefaultValueVisitor.prototype.visitDefaultValue = function (expr) {\n                    return true;\n                };\n                IsDefaultValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsDefaultValueVisitor.instance = new IsDefaultValueVisitor();\n                return IsDefaultValueVisitor;\n            }(data.DefaultSQExprVisitor));\n            var IsAnyValueVisitor = (function (_super) {\n                __extends(IsAnyValueVisitor, _super);\n                function IsAnyValueVisitor() {\n                    _super.apply(this, arguments);\n                }\n                IsAnyValueVisitor.prototype.visitCompare = function (expr) {\n                    if (expr.comparison !== data.QueryComparisonKind.Equal)\n                        return false;\n                    return expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnd = function (expr) {\n                    return expr.left.accept(this) && expr.right.accept(this);\n                };\n                IsAnyValueVisitor.prototype.visitAnyValue = function (expr) {\n                    return true;\n                };\n                IsAnyValueVisitor.prototype.visitDefault = function (expr) {\n                    return false;\n                };\n                IsAnyValueVisitor.instance = new IsAnyValueVisitor();\n                return IsAnyValueVisitor;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprUtils = data.SQExprUtils || (data.SQExprUtils = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SemanticQueryRewriter = (function () {\n            function SemanticQueryRewriter(exprRewriter) {\n                this.exprRewriter = exprRewriter;\n            }\n            SemanticQueryRewriter.prototype.rewriteFrom = function (fromValue) {\n                var fromContents = {};\n                var originalFrom = fromValue, originalFromKeys = originalFrom.keys();\n                for (var i = 0, len = originalFromKeys.length; i < len; i++) {\n                    var keyName = originalFromKeys[i], originalEntityRef = originalFrom.entity(keyName), originalEntityExpr = data.SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName), updatedEntityExpr = originalEntityExpr.accept(this.exprRewriter);\n                    fromContents[keyName] = {\n                        schema: updatedEntityExpr.schema,\n                        entity: updatedEntityExpr.entity,\n                    };\n                }\n                return new data.SQFrom(fromContents);\n            };\n            SemanticQueryRewriter.prototype.rewriteSelect = function (selectItems, from) {\n                debug.assertValue(selectItems, 'selectItems');\n                debug.assertValue(from, 'from');\n                return this.rewriteNamedSQExpressions(selectItems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteGroupBy = function (groupByitems, from) {\n                debug.assertAnyValue(groupByitems, 'groupByitems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(groupByitems))\n                    return;\n                return this.rewriteNamedSQExpressions(groupByitems, from);\n            };\n            SemanticQueryRewriter.prototype.rewriteNamedSQExpressions = function (expressions, from) {\n                var _this = this;\n                debug.assertValue(expressions, 'expressions');\n                return _.map(expressions, function (item) {\n                    return {\n                        name: item.name,\n                        expr: data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(_this.exprRewriter), from)\n                    };\n                });\n            };\n            SemanticQueryRewriter.prototype.rewriteOrderBy = function (orderByItems, from) {\n                debug.assertAnyValue(orderByItems, 'orderByItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(orderByItems))\n                    return;\n                var orderBy = [];\n                for (var i = 0, len = orderByItems.length; i < len; i++) {\n                    var item = orderByItems[i], updatedExpr = data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\n                    orderBy.push({\n                        direction: item.direction,\n                        expr: updatedExpr,\n                    });\n                }\n                return orderBy;\n            };\n            SemanticQueryRewriter.prototype.rewriteWhere = function (whereItems, from) {\n                var _this = this;\n                debug.assertAnyValue(whereItems, 'whereItems');\n                debug.assertValue(from, 'from');\n                if (_.isEmpty(whereItems))\n                    return;\n                var where = [];\n                for (var i = 0, len = whereItems.length; i < len; i++) {\n                    var originalWhere = whereItems[i];\n                    var updatedWhere = {\n                        condition: data.SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\n                    };\n                    if (originalWhere.target)\n                        updatedWhere.target = _.map(originalWhere.target, function (e) { return data.SQExprRewriterWithSourceRenames.rewrite(e.accept(_this.exprRewriter), from); });\n                    where.push(updatedWhere);\n                }\n                return where;\n            };\n            return SemanticQueryRewriter;\n        }());\n        data.SemanticQueryRewriter = SemanticQueryRewriter;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var ArrayExtensions = jsCommon.ArrayExtensions;\n        /**\n         * Represents a semantic query that is:\n         * 1) Round-trippable with a JSON QueryDefinition.\n         * 2) Immutable\n         * 3) Long-lived and does not have strong references to a conceptual model (only names).\n         */\n        var SemanticQuery = (function () {\n            function SemanticQuery(from, where, orderBy, select, groupBy) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(select, 'select');\n                this.fromValue = from;\n                this.whereItems = where;\n                this.orderByItems = orderBy;\n                this.selectItems = select;\n                this.groupByItems = groupBy;\n            }\n            SemanticQuery.create = function () {\n                if (!SemanticQuery.empty)\n                    SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\n                return SemanticQuery.empty;\n            };\n            SemanticQuery.createWithTrimmedFrom = function (from, where, orderBy, select, groupBy) {\n                var unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\n                // Where\n                if (where) {\n                    for (var i = 0, len = where.length; i < len; i++) {\n                        var filter = where[i];\n                        filter.condition.accept(unreferencedKeyFinder);\n                        var filterTarget = filter.target;\n                        if (filterTarget) {\n                            for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                                if (filterTarget[j])\n                                    filterTarget[j].accept(unreferencedKeyFinder);\n                        }\n                    }\n                }\n                // OrderBy\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++)\n                        orderBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                // Select\n                for (var i = 0, len = select.length; i < len; i++)\n                    select[i].expr.accept(unreferencedKeyFinder);\n                // GroupBy\n                if (groupBy) {\n                    for (var i = 0, len = groupBy.length; i < len; i++)\n                        groupBy[i].expr.accept(unreferencedKeyFinder);\n                }\n                var unreferencedKeys = unreferencedKeyFinder.result();\n                for (var i = 0, len = unreferencedKeys.length; i < len; i++)\n                    from.remove(unreferencedKeys[i]);\n                return new SemanticQuery(from, where, orderBy, select, groupBy);\n            };\n            SemanticQuery.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticQuery.prototype.select = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getSelect();\n                return this.setSelect(values);\n            };\n            SemanticQuery.prototype.getSelect = function () {\n                return SemanticQuery.createNamedExpressionArray(this.selectItems);\n            };\n            SemanticQuery.createNamedExpressionArray = function (items) {\n                return ArrayExtensions.extendWithName(_.map(items, function (s) {\n                    return {\n                        name: s.name,\n                        expr: s.expr,\n                    };\n                }));\n            };\n            SemanticQuery.prototype.setSelect = function (values) {\n                var from = this.fromValue.clone();\n                var selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.rewriteExpressionsWithSourceRenames = function (values, from) {\n                var items = [];\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var value = values[i];\n                    items.push({\n                        name: value.name,\n                        expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\n                    });\n                }\n                return items;\n            };\n            /** Removes the given expression from the select. */\n            SemanticQuery.prototype.removeSelect = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var originalItems = this.selectItems, selectItems = [];\n                for (var i = 0, len = originalItems.length; i < len; i++) {\n                    var originalExpr = originalItems[i];\n                    if (data.SQExpr.equals(originalExpr.expr, expr))\n                        continue;\n                    selectItems.push(originalExpr);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            /** Removes the given expression from order by. */\n            SemanticQuery.prototype.removeOrderBy = function (expr) {\n                var sorts = this.orderBy();\n                for (var i = sorts.length - 1; i >= 0; i--) {\n                    if (data.SQExpr.equals(sorts[i].expr, expr))\n                        sorts.splice(i, 1);\n                }\n                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.selectNameOf = function (expr) {\n                var index = data.SQExprUtils.indexOfExpr(_.map(this.selectItems, function (s) { return s.expr; }), expr);\n                if (index >= 0)\n                    return this.selectItems[index].name;\n            };\n            SemanticQuery.prototype.setSelectAt = function (index, expr) {\n                debug.assertValue(expr, 'expr');\n                if (index >= this.selectItems.length)\n                    return;\n                var select = this.select(), from = this.fromValue.clone(), originalName = select[index].name;\n                select[index] = {\n                    name: originalName,\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\n            };\n            /** Adds a the expression to the select clause. */\n            SemanticQuery.prototype.addSelect = function (expr, exprName) {\n                debug.assertValue(expr, 'expr');\n                var selectItems = this.select(), from = this.fromValue.clone();\n                selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.createNamedExpr = function (currentNames, from, expr, exprName) {\n                return {\n                    name: data.SQExprUtils.uniqueName(currentNames, expr, exprName),\n                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\n                };\n            };\n            SemanticQuery.prototype.groupBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getGroupBy();\n                return this.setGroupBy(values);\n            };\n            SemanticQuery.prototype.getGroupBy = function () {\n                return SemanticQuery.createNamedExpressionArray(this.groupByItems);\n            };\n            SemanticQuery.prototype.setGroupBy = function (values) {\n                var from = this.fromValue.clone();\n                var groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.addGroupBy = function (expr) {\n                debug.assertValue(expr, 'expr');\n                var groupByItems = this.groupBy(), from = this.fromValue.clone();\n                groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\n            };\n            SemanticQuery.prototype.orderBy = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getOrderBy();\n                return this.setOrderBy(values);\n            };\n            SemanticQuery.prototype.getOrderBy = function () {\n                var result = [];\n                var orderBy = this.orderByItems;\n                if (orderBy) {\n                    for (var i = 0, len = orderBy.length; i < len; i++) {\n                        var clause = orderBy[i];\n                        result.push({\n                            expr: clause.expr,\n                            direction: clause.direction,\n                        });\n                    }\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setOrderBy = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedOrderBy = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var clause = values[i];\n                    updatedOrderBy.push({\n                        expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\n                        direction: clause.direction,\n                    });\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.where = function (values) {\n                if (_.isEmpty(arguments))\n                    return this.getWhere();\n                return this.setWhere(values);\n            };\n            SemanticQuery.prototype.getWhere = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                if (whereItems) {\n                    for (var i = 0, len = whereItems.length; i < len; i++)\n                        result.push(whereItems[i]);\n                }\n                return result;\n            };\n            SemanticQuery.prototype.setWhere = function (values) {\n                debug.assertValue(values, 'values');\n                var updatedWhere = [], from = this.fromValue.clone();\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var filter = values[i];\n                    var updatedFilter = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\n                    };\n                    var filterTarget = filter.target;\n                    if (filterTarget) {\n                        updatedFilter.target = [];\n                        for (var j = 0, jlen = filterTarget.length; j < jlen; j++)\n                            if (filterTarget[j]) {\n                                var updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\n                                updatedFilter.target.push(updatedTarget);\n                            }\n                    }\n                    updatedWhere.push(updatedFilter);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.addWhere = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedWhere = this.where(), incomingWhere = filter.where(), from = this.fromValue.clone();\n                for (var i = 0, len = incomingWhere.length; i < len; i++) {\n                    var clause = incomingWhere[i];\n                    var updatedClause = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\n                    };\n                    if (clause.target)\n                        updatedClause.target = _.map(clause.target, function (t) { return SQExprRewriterWithSourceRenames.rewrite(t, from); });\n                    updatedWhere.push(updatedClause);\n                }\n                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\n            };\n            SemanticQuery.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                var orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\n                var select = rewriter.rewriteSelect(this.selectItems, from);\n                var groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\n                return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\n            };\n            return SemanticQuery;\n        }());\n        data.SemanticQuery = SemanticQuery;\n        /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\n        var SemanticFilter = (function () {\n            function SemanticFilter(from, where) {\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                this.fromValue = from;\n                this.whereItems = where;\n            }\n            SemanticFilter.fromSQExpr = function (contract) {\n                debug.assertValue(contract, 'contract');\n                var from = new SQFrom();\n                var rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\n                // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\n                //         Thus not setting a target here.\n                var where = [{\n                        condition: rewrittenContract\n                    }];\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.getDefaultValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.defaultValue());\n            };\n            SemanticFilter.getAnyValueFilter = function (fieldSQExprs) {\n                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.anyValue());\n            };\n            SemanticFilter.getDataViewScopeIdentityComparisonFilters = function (fieldSQExprs, value) {\n                debug.assertValue(fieldSQExprs, 'fieldSQExprs');\n                debug.assertValue(value, 'value');\n                if (fieldSQExprs instanceof Array) {\n                    var values = Array.apply(null, Array(fieldSQExprs.length)).map(function () { return value; });\n                    return SemanticFilter.fromSQExpr(data.SQExprUtils.getDataViewScopeIdentityComparisonExpr(fieldSQExprs, values));\n                }\n                return SemanticFilter.fromSQExpr(data.SQExprBuilder.equal(fieldSQExprs, value));\n            };\n            SemanticFilter.prototype.from = function () {\n                return this.fromValue.clone();\n            };\n            SemanticFilter.prototype.conditions = function () {\n                var expressions = [];\n                var where = this.whereItems;\n                for (var i = 0, len = where.length; i < len; i++) {\n                    var filter = where[i];\n                    expressions.push(filter.condition);\n                }\n                return expressions;\n            };\n            SemanticFilter.prototype.where = function () {\n                var result = [];\n                var whereItems = this.whereItems;\n                for (var i = 0, len = whereItems.length; i < len; i++)\n                    result.push(whereItems[i]);\n                return result;\n            };\n            SemanticFilter.prototype.rewrite = function (exprRewriter) {\n                var rewriter = new data.SemanticQueryRewriter(exprRewriter);\n                var from = rewriter.rewriteFrom(this.fromValue);\n                var where = rewriter.rewriteWhere(this.whereItems, from);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.prototype.validate = function (schema, aggrUtils, errors) {\n                var validator = new data.SQExprValidationVisitor(schema, aggrUtils, errors);\n                this.rewrite(validator);\n                return validator.errors;\n            };\n            /** Merges a list of SemanticFilters into one. */\n            SemanticFilter.merge = function (filters) {\n                if (_.isEmpty(filters))\n                    return null;\n                if (filters.length === 1)\n                    return filters[0];\n                var firstFilter = filters[0];\n                var from = firstFilter.from(), where = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\n                for (var i = 1, len = filters.length; i < len; i++)\n                    SemanticFilter.applyFilter(filters[i], from, where);\n                return new SemanticFilter(from, where);\n            };\n            SemanticFilter.isDefaultFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isDefaultValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isAnyFilter = function (filter) {\n                if (!filter || filter.where().length !== 1)\n                    return false;\n                return data.SQExprUtils.isAnyValue(filter.where()[0].condition);\n            };\n            SemanticFilter.isSameFilter = function (leftFilter, rightFilter) {\n                if (jsCommon.JsonComparer.equals(leftFilter, rightFilter)) {\n                    return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\n                        || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\n                }\n                return false;\n            };\n            SemanticFilter.applyFilter = function (filter, from, where) {\n                debug.assertValue(filter, 'filter');\n                debug.assertValue(from, 'from');\n                debug.assertValue(where, 'where');\n                // Where\n                var filterWhereItems = filter.whereItems;\n                for (var i = 0; i < filterWhereItems.length; i++) {\n                    var filterWhereItem = filterWhereItems[i];\n                    var updatedWhereItem = {\n                        condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\n                    };\n                    if (filterWhereItem.target)\n                        updatedWhereItem.target = _.map(filterWhereItem.target, function (e) { return SQExprRewriterWithSourceRenames.rewrite(e, from); });\n                    where.push(updatedWhereItem);\n                }\n            };\n            return SemanticFilter;\n        }());\n        data.SemanticFilter = SemanticFilter;\n        /** Represents a SemanticQuery/SemanticFilter from clause. */\n        var SQFrom = (function () {\n            function SQFrom(items) {\n                this.items = items || {};\n            }\n            SQFrom.prototype.keys = function () {\n                return Object.keys(this.items);\n            };\n            SQFrom.prototype.entity = function (key) {\n                return this.items[key];\n            };\n            SQFrom.prototype.ensureEntity = function (entity, desiredVariableName) {\n                debug.assertValue(entity, 'entity');\n                // 1) Reuse a reference to the entity among the already referenced\n                var keys = this.keys();\n                for (var i_1 = 0, len = keys.length; i_1 < len; i_1++) {\n                    var key = keys[i_1], item = this.items[key];\n                    if (item && entity.entity === item.entity && entity.schema === item.schema)\n                        return { name: key };\n                }\n                // 2) Add a reference to the entity\n                var candidateName = desiredVariableName || this.candidateName(entity.entity), uniqueName = candidateName, i = 2;\n                while (this.items[uniqueName]) {\n                    uniqueName = candidateName + i++;\n                }\n                this.items[uniqueName] = entity;\n                return { name: uniqueName, new: true };\n            };\n            SQFrom.prototype.remove = function (key) {\n                delete this.items[key];\n            };\n            /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\n            SQFrom.prototype.candidateName = function (ref) {\n                debug.assertValue(ref, 'ref');\n                var idx = ref.lastIndexOf('.');\n                if (idx >= 0 && (idx !== ref.length - 1))\n                    ref = ref.substr(idx + 1);\n                return ref.substring(0, 1).toLowerCase();\n            };\n            SQFrom.prototype.clone = function () {\n                // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\n                var cloned = new SQFrom();\n                // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\n                $.extend(cloned.items, this.items);\n                return cloned;\n            };\n            return SQFrom;\n        }());\n        data.SQFrom = SQFrom;\n        var SQExprRewriterWithSourceRenames = (function (_super) {\n            __extends(SQExprRewriterWithSourceRenames, _super);\n            function SQExprRewriterWithSourceRenames(renames) {\n                debug.assertValue(renames, 'renames');\n                _super.call(this);\n                this.renames = renames;\n            }\n            SQExprRewriterWithSourceRenames.prototype.visitEntity = function (expr) {\n                var updatedName = this.renames[expr.entity];\n                if (updatedName)\n                    return new data.SQEntityExpr(expr.schema, expr.entity, updatedName);\n                return _super.prototype.visitEntity.call(this, expr);\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteFilter = function (filter) {\n                debug.assertValue(filter, 'filter');\n                var updatedTargets = undefined;\n                if (filter.target)\n                    updatedTargets = this.rewriteArray(filter.target);\n                var updatedCondition = filter.condition.accept(this);\n                if (filter.condition === updatedCondition && filter.target === updatedTargets)\n                    return filter;\n                var updatedFilter = {\n                    condition: updatedCondition,\n                };\n                if (updatedTargets)\n                    updatedFilter.target = updatedTargets;\n                return updatedFilter;\n            };\n            SQExprRewriterWithSourceRenames.prototype.rewriteArray = function (exprs) {\n                debug.assertValue(exprs, 'exprs');\n                var updatedExprs;\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    var expr = exprs[i], rewrittenExpr = expr.accept(this);\n                    if (expr !== rewrittenExpr && !updatedExprs)\n                        updatedExprs = ArrayExtensions.take(exprs, i);\n                    if (updatedExprs)\n                        updatedExprs.push(rewrittenExpr);\n                }\n                return updatedExprs || exprs;\n            };\n            SQExprRewriterWithSourceRenames.rewrite = function (expr, from) {\n                debug.assertValue(expr, 'expr');\n                debug.assertValue(from, 'from');\n                var renames = QuerySourceRenameDetector.run(expr, from);\n                var rewriter = new SQExprRewriterWithSourceRenames(renames);\n                return expr.accept(rewriter);\n            };\n            return SQExprRewriterWithSourceRenames;\n        }(data.SQExprRewriter));\n        data.SQExprRewriterWithSourceRenames = SQExprRewriterWithSourceRenames;\n        /** Responsible for updating a QueryFrom based on SQExpr references. */\n        var QuerySourceRenameDetector = (function (_super) {\n            __extends(QuerySourceRenameDetector, _super);\n            function QuerySourceRenameDetector(from) {\n                debug.assertValue(from, 'from');\n                _super.call(this);\n                this.from = from;\n                this.renames = {};\n            }\n            QuerySourceRenameDetector.run = function (expr, from) {\n                var detector = new QuerySourceRenameDetector(from);\n                expr.accept(detector);\n                return detector.renames;\n            };\n            QuerySourceRenameDetector.prototype.visitEntity = function (expr) {\n                // TODO: Renames must take the schema into account, not just entity set name.\n                var existingEntity = this.from.entity(expr.variable);\n                if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\n                    return;\n                var actualEntity = this.from.ensureEntity({\n                    schema: expr.schema,\n                    entity: expr.entity,\n                }, expr.variable);\n                this.renames[expr.entity] = actualEntity.name;\n            };\n            return QuerySourceRenameDetector;\n        }(data.DefaultSQExprVisitorWithTraversal));\n        /** Visitor for finding unreferenced sources. */\n        var UnreferencedKeyFinder = (function (_super) {\n            __extends(UnreferencedKeyFinder, _super);\n            function UnreferencedKeyFinder(keys) {\n                debug.assertValue(keys, 'keys');\n                _super.call(this);\n                this.keys = keys;\n            }\n            UnreferencedKeyFinder.prototype.visitEntity = function (expr) {\n                var index = this.keys.indexOf(expr.variable);\n                if (index >= 0)\n                    this.keys.splice(index, 1);\n            };\n            UnreferencedKeyFinder.prototype.result = function () {\n                return this.keys;\n            };\n            return UnreferencedKeyFinder;\n        }(data.DefaultSQExprVisitorWithTraversal));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data_4) {\n        var DataViewTransform = powerbi.data.DataViewTransform;\n        var SQExprBuilder = powerbi.data.SQExprBuilder;\n        function createCategoricalDataViewBuilder() {\n            return new CategoricalDataViewBuilder();\n        }\n        data_4.createCategoricalDataViewBuilder = createCategoricalDataViewBuilder;\n        var CategoricalDataViewBuilder = (function () {\n            function CategoricalDataViewBuilder() {\n                this.categories = [];\n                this.measureColumns = [];\n                this.columnIndex = 0;\n            }\n            CategoricalDataViewBuilder.prototype.withCategory = function (options) {\n                var categoryValues = options.values, identityFrom = options.identityFrom, type = options.source.type;\n                var categoryColumn = {\n                    source: options.source,\n                    identityFields: options.identityFrom.fields,\n                    identity: options.identityFrom.identities || [],\n                    values: categoryValues,\n                };\n                if (!options.identityFrom.identities) {\n                    for (var categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\n                        categoryColumn.identity.push(getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\n                    }\n                }\n                if (!this.categories)\n                    this.categories = [];\n                this.categories.push(categoryColumn);\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withCategories = function (categories) {\n                if (_.isEmpty(this.categories))\n                    this.categories = categories;\n                else\n                    Array.prototype.push.apply(this.categories, categories);\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withValues = function (options) {\n                debug.assertValue(options, 'options');\n                var columns = options.columns;\n                debug.assertValue(columns, 'columns');\n                for (var _i = 0, columns_8 = columns; _i < columns_8.length; _i++) {\n                    var column = columns_8[_i];\n                    this.measureColumns.push(column.source);\n                }\n                this.data = columns;\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.withGroupedValues = function (options) {\n                debug.assertValue(options, 'options');\n                this.hasDynamicSeries = true;\n                var groupColumn = options.groupColumn;\n                debug.assertValue(groupColumn, 'groupColumn');\n                this.dynamicSeriesMetadata = {\n                    column: groupColumn.source,\n                    identityFrom: groupColumn.identityFrom,\n                    values: groupColumn.values,\n                };\n                var valueColumns = options.valueColumns;\n                for (var _i = 0, valueColumns_1 = valueColumns; _i < valueColumns_1.length; _i++) {\n                    var valueColumn = valueColumns_1[_i];\n                    this.measureColumns.push(valueColumn.source);\n                }\n                this.data = options.data;\n                return this;\n            };\n            CategoricalDataViewBuilder.prototype.fillData = function (dataViewValues, groups) {\n                var categoryColumn = _.first(this.categories);\n                var categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 1;\n                if (this.hasDynamicSeries) {\n                    // Dynamic series\n                    var data_5 = this.data;\n                    for (var seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\n                        var seriesMeasures = data_5[seriesIndex];\n                        debug.assert(seriesMeasures.length === this.measureColumns.length, 'seriesMeasures.length === this.measureColumns.length');\n                        for (var measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                            var groupIndex = seriesIndex * measuresLen + measureIndex;\n                            applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\n                        }\n                    }\n                }\n                else {\n                    // Static series\n                    var data_6 = this.data;\n                    for (var measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\n                        applySeriesData(dataViewValues[measureIndex], data_6[measureIndex], categoryLength);\n                    }\n                }\n            };\n            CategoricalDataViewBuilder.prototype.build = function () {\n                var metadataColumns = [];\n                var categorical = {};\n                var groups;\n                var categoryMetadata = this.categories;\n                var dynamicSeriesMetadata = this.dynamicSeriesMetadata;\n                // --- Build metadata columns and value groups ---\n                for (var _i = 0, categoryMetadata_1 = categoryMetadata; _i < categoryMetadata_1.length; _i++) {\n                    var columnMetadata = categoryMetadata_1[_i];\n                    pushIfNotExists(metadataColumns, columnMetadata.source);\n                }\n                if (this.hasDynamicSeries) {\n                    pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\n                }\n                if (this.hasDynamicSeries) {\n                    // Dynamic series\n                    categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\n                    var measures = this.measureColumns;\n                    groups = [];\n                    // For each series value we will make one column per measure\n                    var seriesValues = dynamicSeriesMetadata.values;\n                    for (var seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\n                        var seriesValue = seriesValues[seriesIndex];\n                        var seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\n                        for (var _a = 0, measures_1 = measures; _a < measures_1.length; _a++) {\n                            var measure = measures_1[_a];\n                            var column = _.clone(measure);\n                            column.groupName = seriesValue;\n                            groups.push(column);\n                            pushIfNotExists(metadataColumns, column);\n                            categorical.values.push({\n                                source: column,\n                                values: [],\n                                identity: seriesIdentity,\n                            });\n                        }\n                    }\n                }\n                else {\n                    // Static series / no series\n                    categorical.values = DataViewTransform.createValueColumns();\n                    groups = this.measureColumns;\n                    for (var _b = 0, groups_2 = groups; _b < groups_2.length; _b++) {\n                        var measure = groups_2[_b];\n                        var column = measure;\n                        pushIfNotExists(metadataColumns, column);\n                        categorical.values.push({\n                            source: column,\n                            values: [],\n                        });\n                    }\n                }\n                var categories = this.categories;\n                if (!_.isEmpty(categories))\n                    categorical.categories = categories;\n                // --- Fill in data point values ---\n                this.fillData(categorical.values, groups);\n                return {\n                    metadata: {\n                        columns: metadataColumns,\n                    },\n                    categorical: categorical,\n                };\n            };\n            return CategoricalDataViewBuilder;\n        }());\n        function getScopeIdentity(source, index, value, valueType) {\n            var identities = source.identities;\n            if (identities) {\n                return identities[index];\n            }\n            debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\n            return data_4.createDataViewScopeIdentity(SQExprBuilder.equal(source.fields[0], SQExprBuilder.typedConstant(value, valueType)));\n        }\n        function pushIfNotExists(items, itemToAdd) {\n            if (_.contains(items, itemToAdd))\n                return;\n            items.push(itemToAdd);\n        }\n        function applySeriesData(target, source, categoryLength) {\n            debug.assertValue(target, 'target');\n            debug.assertValue(source, 'source');\n            debug.assertValue(categoryLength, 'categoryLength');\n            var values = source.values;\n            debug.assert(categoryLength === values.length, 'categoryLength === values.length');\n            target.values = values;\n            var highlights = source.highlights;\n            if (highlights) {\n                debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\n                target.highlights = highlights;\n            }\n            if (source.minLocal !== undefined)\n                target.minLocal = source.minLocal;\n            if (source.maxLocal !== undefined)\n                target.maxLocal = source.maxLocal;\n        }\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        var SQExpr = powerbi.data.SQExpr;\n        function createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n            return new StaticEvalContext(colorAllocatorCache || data.createColorAllocatorCache(), dataView || { metadata: { columns: [] } }, selectTransforms);\n        }\n        data.createStaticEvalContext = createStaticEvalContext;\n        /**\n         * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\n         * are supported.\n         */\n        var StaticEvalContext = (function () {\n            function StaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {\n                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\n                debug.assertValue(dataView, 'dataView');\n                debug.assertAnyValue(selectTransforms, 'selectTransforms');\n                this.colorAllocatorCache = colorAllocatorCache;\n                this.dataView = dataView;\n                this.selectTransforms = selectTransforms;\n            }\n            StaticEvalContext.prototype.getColorAllocator = function (expr) {\n                return this.colorAllocatorCache.get(expr);\n            };\n            StaticEvalContext.prototype.getExprValue = function (expr) {\n                var dataView = this.dataView, selectTransforms = this.selectTransforms;\n                if (dataView && dataView.table && selectTransforms)\n                    return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\n            };\n            StaticEvalContext.prototype.getRoleValue = function (roleName) {\n                return;\n            };\n            return StaticEvalContext;\n        }());\n        function getExprValueFromTable(expr, selectTransforms, table, rowIdx) {\n            debug.assertValue(expr, 'expr');\n            debug.assertValue(selectTransforms, 'selectTransforms');\n            debug.assertValue(table, 'table');\n            debug.assertValue(rowIdx, 'rowIdx');\n            var rows = table.rows;\n            if (_.isEmpty(rows) || rows.length <= rowIdx)\n                return;\n            var cols = table.columns;\n            for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\n                var selectTransform = selectTransforms[selectIdx];\n                if (!SQExpr.equals(selectTransform.expr, expr) || !selectTransform.queryName)\n                    continue;\n                for (var colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\n                    if (selectIdx !== cols[colIdx].index)\n                        continue;\n                    return rows[rowIdx][colIdx];\n                }\n            }\n        }\n        data.getExprValueFromTable = getExprValueFromTable;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        function createMatrixEvalContext(colorAllocatorProvider, dataViewMatrix) {\n            // NOTE: Matrix context-sensitive evaluation is not yet implemented.\n            return data.createStaticEvalContext(colorAllocatorProvider);\n        }\n        data.createMatrixEvalContext = createMatrixEvalContext;\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi_1) {\n    var StringExtensions = jsCommon.StringExtensions;\n    var Formatting = jsCommon.Formatting;\n    var RegExpExtensions = jsCommon.RegExpExtensions;\n    /** Formatting Encoder */\n    var FormattingEncoder;\n    (function (FormattingEncoder) {\n        function preserveEscaped(format, specialChars) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = \"\\\\\" + specialChars[i];\n                var newText = String.fromCharCode(0xE000 + i);\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveEscaped = preserveEscaped;\n        function restoreEscaped(format, specialChars) {\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\n            var length = specialChars.length;\n            for (var i = 0; i < length; i++) {\n                var oldText = String.fromCharCode(0xE000 + i);\n                var newText = specialChars[i];\n                format = StringExtensions.replaceAll(format, oldText, newText);\n            }\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\n        }\n        FormattingEncoder.restoreEscaped = restoreEscaped;\n        function preserveLiterals(format, literals) {\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            for (var i = 0;; i++) {\n                var fromIndex = format.indexOf(\"'\");\n                if (fromIndex < 0) {\n                    break;\n                }\n                var toIndex = format.indexOf(\"'\", fromIndex + 1);\n                if (toIndex < 0) {\n                    break;\n                }\n                var literal = format.substring(fromIndex, toIndex + 1);\n                literals.push(literal.substring(1, toIndex - fromIndex));\n                var token = String.fromCharCode(0xE100 + i);\n                format = format.replace(literal, token);\n            }\n            return format;\n        }\n        FormattingEncoder.preserveLiterals = preserveLiterals;\n        function restoreLiterals(format, literals) {\n            var count = literals.length;\n            for (var i = 0; i < count; i++) {\n                var token = String.fromCharCode(0xE100 + i);\n                var literal = literals[i];\n                format = format.replace(token, literal);\n            }\n            return format;\n        }\n        FormattingEncoder.restoreLiterals = restoreLiterals;\n    })(FormattingEncoder || (FormattingEncoder = {}));\n    var IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\n    var ZeroPlaceholder = '0';\n    var DigitPlaceholder = '#';\n    var ExponentialFormatChar = 'E';\n    var NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\n    var NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\n    /** Formatting Service */\n    var FormattingService = (function () {\n        function FormattingService() {\n        }\n        FormattingService.prototype.formatValue = function (value, format, culture) {\n            // Handle special cases\n            if (value === undefined || value === null) {\n                return '';\n            }\n            var gculture = this.getCulture(culture);\n            if (DateTimeFormat.canFormat(value)) {\n                // Dates\n                return DateTimeFormat.format(value, format, gculture);\n            }\n            else if (NumberFormat.canFormat(value)) {\n                // Numbers\n                return NumberFormat.format(value, format, gculture);\n            }\n            else {\n                // Other data types - return as string\n                return value.toString();\n            }\n        };\n        FormattingService.prototype.format = function (formatWithIndexedTokens, args, culture) {\n            var _this = this;\n            if (!formatWithIndexedTokens) {\n                return \"\";\n            }\n            var result = formatWithIndexedTokens.replace(IndexedTokensRegex, function (match, left, right, argToken) {\n                if (left) {\n                    return \"{\";\n                }\n                else if (right) {\n                    return \"}\";\n                }\n                else {\n                    var parts = argToken.split(\":\");\n                    var argIndex = parseInt(parts[0], 10);\n                    var argFormat = parts[1];\n                    return _this.formatValue(args[argIndex], argFormat, culture);\n                }\n            });\n            return result;\n        };\n        FormattingService.prototype.isStandardNumberFormat = function (format) {\n            return NumberFormat.isStandardFormat(format);\n        };\n        FormattingService.prototype.formatNumberWithCustomOverride = function (value, format, nonScientificOverrideFormat, culture) {\n            var gculture = this.getCulture(culture);\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\n        };\n        FormattingService.prototype.dateFormatString = function (unit) {\n            if (!this._dateTimeScaleFormatInfo)\n                this.initialize();\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\n        };\n        /**\n         * Sets the current localization culture\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         */\n        FormattingService.prototype.setCurrentCulture = function (cultureSelector) {\n            if (this._currentCultureSelector !== cultureSelector) {\n                this._currentCulture = this.getCulture(cultureSelector);\n                this._currentCultureSelector = cultureSelector;\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\n            }\n        };\n        /**\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\n         * Exposing this function for testability of unsupported cultures\n         */\n        FormattingService.prototype.getCulture = function (cultureSelector) {\n            if (cultureSelector == null) {\n                if (this._currentCulture == null) {\n                    this.initialize();\n                }\n                return this._currentCulture;\n            }\n            else {\n                var culture = Globalize.findClosestCulture(cultureSelector);\n                if (!culture)\n                    culture = Globalize.culture(\"en-US\");\n                return culture;\n            }\n        };\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\n        FormattingService.prototype.initialize = function () {\n            var cultureName = this.getCurrentCulture();\n            this.setCurrentCulture(cultureName);\n            var calendarName = this.getUrlParam(\"calendar\");\n            if (calendarName) {\n                var culture = this._currentCulture;\n                var c = culture.calendars[calendarName];\n                if (c) {\n                    culture.calendar = c;\n                }\n            }\n        };\n        /**\n         *  Exposing this function for testability\n         */\n        FormattingService.prototype.getCurrentCulture = function () {\n            var urlParam = this.getUrlParam(\"language\");\n            if (urlParam) {\n                return urlParam;\n            }\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\n                // Get cultureInfo set in powerbi\n                return powerbi.common.cultureInfo;\n            }\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\n        };\n        /**\n         *  Exposing this function for testability\n         *  @param name: queryString name\n         */\n        FormattingService.prototype.getUrlParam = function (name) {\n            var param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\n            return param ? param[1] : undefined;\n        };\n        return FormattingService;\n    }());\n    /**\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for dates.\n     */\n    var DateTimeFormat;\n    (function (DateTimeFormat) {\n        var _currentCachedFormat;\n        var _currentCachedProcessedFormat;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = value instanceof Date;\n            return result;\n        }\n        DateTimeFormat.canFormat = canFormat;\n        /** Formats the date using provided format and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            var isStandard = format.length === 1;\n            try {\n                if (isStandard) {\n                    return formatDateStandard(value, format, culture);\n                }\n                else {\n                    return formatDateCustom(value, format, culture);\n                }\n            }\n            catch (e) {\n                return formatDateStandard(value, \"G\", culture);\n            }\n        }\n        DateTimeFormat.format = format;\n        /** Formats the date using standard format expression */\n        function formatDateStandard(value, format, culture) {\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\n            var patterns = culture.calendar.patterns;\n            // Extend supported set of patterns\n            ensurePatterns(culture.calendar);\n            // Handle extended set of formats\n            var output = Formatting.findDateFormat(value, format, culture.name);\n            if (output.format.length === 1)\n                format = patterns[output.format];\n            else\n                format = output.format;\n            //need to revisit when globalization is enabled\n            culture = Globalize.culture(\"en-US\");\n            return Globalize.format(output.value, format, culture);\n        }\n        /** Formats the date using custom format expression */\n        function formatDateCustom(value, format, culture) {\n            var result;\n            var literals = [];\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            format = FormattingEncoder.preserveLiterals(format, literals);\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\n            if (format.indexOf(\"F\") > -1) {\n                // F is not supported so we need to replace the F with f based on the milliseconds\n                // Replace all sequences of F longer than 3 with \"FFF\"\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\n                // Based on milliseconds update the format to use fff\n                var milliseconds = value.getMilliseconds();\n                if (milliseconds % 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\n                if ((milliseconds % 100) / 10 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\n                }\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\n                if ((milliseconds % 1000) / 100 >= 1) {\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\n                }\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\n                if (format === \"\" || format === \"%\")\n                    return \"\";\n            }\n            format = processCustomDateTimeFormat(format);\n            result = Globalize.format(value, format, culture);\n            result = localize(result, culture.calendar);\n            result = FormattingEncoder.restoreLiterals(result, literals);\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\n            return result;\n        }\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\n        function processCustomDateTimeFormat(format) {\n            if (format === _currentCachedFormat) {\n                return _currentCachedProcessedFormat;\n            }\n            _currentCachedFormat = format;\n            format = Formatting.fixDateTimeFormat(format);\n            _currentCachedProcessedFormat = format;\n            return format;\n        }\n        /** Localizes the time separator symbol */\n        function localize(value, dictionary) {\n            var timeSeparator = dictionary[\":\"];\n            if (timeSeparator === \":\") {\n                return value;\n            }\n            var result = \"\";\n            var count = value.length;\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \":\":\n                        result += timeSeparator;\n                        break;\n                    default:\n                        result += char;\n                        break;\n                }\n            }\n            return result;\n        }\n        function ensurePatterns(calendar) {\n            var patterns = calendar.patterns;\n            if (patterns[\"g\"] === undefined) {\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, short time\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]); // Generic: Short date, long time\n            }\n        }\n    })(DateTimeFormat || (DateTimeFormat = {}));\n    /**\n     * NumberFormat module contains the static methods for formatting the numbers.\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\n     * formatting expressions for numeric types including custom formats.\n     */\n    var NumberFormat;\n    (function (NumberFormat) {\n        var NonScientificFormatRegex = /^\\{.+\\}.*/;\n        var NumericalPlaceHolderRegex = /\\{.+\\}/;\n        var ScientificFormatRegex = /e[+-]*[0#]+/i;\n        var StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\n        var TrailingZerosRegex = /0+$/;\n        var DecimalFormatRegex = /\\.([0#]*)/g;\n        var NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\n        var LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\n        var DecimalFormatCharacter = '.';\n        NumberFormat.NumberFormatComponentsDelimeter = ';';\n        function getNonScientificFormatWithPrecision(baseFormat, numericFormat) {\n            if (!numericFormat || baseFormat === undefined)\n                return baseFormat;\n            var newFormat = \"{0:\" + numericFormat + \"}\";\n            return baseFormat.replace(\"{0}\", newFormat);\n        }\n        function getNumericFormat(value, baseFormat) {\n            if (baseFormat == null)\n                return baseFormat;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                if (value > 0)\n                    return getNumericFormatFromComponent(value, positive);\n                else if (value === 0)\n                    return getNumericFormatFromComponent(value, zero);\n                return getNumericFormatFromComponent(value, negative);\n            }\n            return getNumericFormatFromComponent(value, baseFormat);\n        }\n        NumberFormat.getNumericFormat = getNumericFormat;\n        function getNumericFormatFromComponent(value, format) {\n            var match = RegExpExtensions.run(NumericFormatRegex, format);\n            if (match)\n                return match[0];\n            return format;\n        }\n        function addDecimalsToFormat(baseFormat, decimals, trailingZeros) {\n            if (decimals == null)\n                return baseFormat;\n            // Default format string\n            if (baseFormat == null)\n                baseFormat = ZeroPlaceholder;\n            if (hasFormatComponents(baseFormat)) {\n                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;\n                var formats = [positive, negative, zero];\n                for (var i = 0; i < formats.length; i++) {\n                    // Update format in formats array\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\n                }\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\n            }\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\n        }\n        NumberFormat.addDecimalsToFormat = addDecimalsToFormat;\n        function addDecimalsToFormatComponent(format, decimals, trailingZeros) {\n            decimals = Math.abs(decimals);\n            if (decimals >= 0) {\n                var placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\n                var decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\n                var match = RegExpExtensions.run(DecimalFormatRegex, format);\n                if (match) {\n                    var beforeDecimal = format.substr(0, match.index);\n                    var formatDecimal = format.substr(match.index + 1, match[1].length);\n                    var afterDecimal = format.substr(match.index + match[0].length);\n                    if (trailingZeros)\n                        // Use explicit decimals argument as placeholders\n                        formatDecimal = decimalPlaceholders;\n                    else {\n                        var decimalChange = decimalPlaceholders.length - formatDecimal.length;\n                        if (decimalChange > 0)\n                            // Append decimalPlaceholders to existing decimal portion of format string\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\n                        else if (decimalChange < 0)\n                            // Remove decimals from formatDecimal\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\n                    }\n                    if (formatDecimal.length > 0)\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\n                    return beforeDecimal + formatDecimal + afterDecimal;\n                }\n                else if (decimalPlaceholders.length > 0)\n                    // Replace last numeric placeholder with decimal portion\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\n            }\n            return format;\n        }\n        function hasFormatComponents(format) {\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\n        }\n        NumberFormat.hasFormatComponents = hasFormatComponents;\n        function getComponents(format) {\n            var signFormat = {\n                hasNegative: false,\n                positive: format,\n                negative: format,\n                zero: format,\n            };\n            var signSpecificFormats = format.split(NumberFormat.NumberFormatComponentsDelimeter);\n            var formatCount = signSpecificFormats.length;\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\n            if (formatCount > 1) {\n                signFormat.hasNegative = true;\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\n                signFormat.negative = signSpecificFormats[1];\n                if (formatCount > 2)\n                    signFormat.zero = signSpecificFormats[2];\n            }\n            return signFormat;\n        }\n        NumberFormat.getComponents = getComponents;\n        var _lastCustomFormatMeta;\n        /** Evaluates if the value can be formatted using the NumberFormat */\n        function canFormat(value) {\n            var result = typeof (value) === \"number\";\n            return result;\n        }\n        NumberFormat.canFormat = canFormat;\n        function isStandardFormat(format) {\n            debug.assertValue(format, 'format');\n            return StandardFormatRegex.test(format);\n        }\n        NumberFormat.isStandardFormat = isStandardFormat;\n        /** Formats the number using specified format expression and culture */\n        function format(value, format, culture) {\n            format = format || \"G\";\n            try {\n                if (isStandardFormat(format))\n                    return formatNumberStandard(value, format, culture);\n                return formatNumberCustom(value, format, culture);\n            }\n            catch (e) {\n                return Globalize.format(value, undefined, culture);\n            }\n        }\n        NumberFormat.format = format;\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\n        function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {\n            debug.assertValue(value, 'value');\n            debug.assertValue(format, 'format');\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\n            debug.assertValue(culture, 'culture');\n            debug.assert(!isStandardFormat(format), 'Standard format');\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\n        }\n        NumberFormat.formatWithCustomOverride = formatWithCustomOverride;\n        /** Formats the number using standard format expression */\n        function formatNumberStandard(value, format, culture) {\n            var result;\n            var precision = (format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\n            var numberFormatInfo = culture.numberFormat;\n            var formatChar = format.charAt(0);\n            switch (formatChar) {\n                case \"e\":\n                case \"E\":\n                    if (precision === undefined) {\n                        precision = 6;\n                    }\n                    var mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\n                    result = formatNumberCustom(value, format, culture);\n                    break;\n                case \"f\":\n                case \"F\":\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"g\":\n                case \"G\":\n                    var abs = Math.abs(value);\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\n                    }\n                    else {\n                        // Otherwise use exponential\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\n                        result = result.replace(\"e\", \"E\");\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"r\":\n                case \"R\":\n                    result = value.toString();\n                    result = localize(result, numberFormatInfo);\n                    break;\n                case \"x\":\n                case \"X\":\n                    result = value.toString(16);\n                    if (formatChar === \"X\") {\n                        result = result.toUpperCase();\n                    }\n                    if (precision !== undefined) {\n                        var actualPrecision = result.length;\n                        var isNegative = value < 0;\n                        if (isNegative) {\n                            actualPrecision--;\n                        }\n                        var paddingZerosCount = precision - actualPrecision;\n                        var paddingZeros = undefined;\n                        if (paddingZerosCount > 0) {\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\n                        }\n                        if (isNegative) {\n                            result = \"-\" + paddingZeros + result.substr(1);\n                        }\n                        else {\n                            result = paddingZeros + result;\n                        }\n                    }\n                    result = localize(result, numberFormatInfo);\n                    break;\n                default:\n                    result = Globalize.format(value, format, culture);\n            }\n            return result;\n        }\n        /** Formats the number using custom format expression */\n        function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {\n            var result;\n            var numberFormatInfo = culture.numberFormat;\n            if (isFinite(value)) {\n                // Split format by positive[;negative;zero] pattern\n                var formatComponents = getComponents(format);\n                // Pick a format based on the sign of value\n                if (value > 0) {\n                    format = formatComponents.positive;\n                }\n                else if (value === 0) {\n                    format = formatComponents.zero;\n                }\n                else {\n                    format = formatComponents.negative;\n                }\n                // Normalize value if we have an explicit negative format\n                if (formatComponents.hasNegative)\n                    value = Math.abs(value);\n                // Get format metadata\n                var formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\n                // Preserve literals and escaped chars\n                if (formatMeta.hasEscapes) {\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%\");\n                }\n                var literals = [];\n                if (formatMeta.hasQuotes) {\n                    format = FormattingEncoder.preserveLiterals(format, literals);\n                }\n                // Scientific format\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\n                    var scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\n                    if (scientificMatch) {\n                        // Case 2.1. Scientific custom format\n                        var formatM = format.substr(0, scientificMatch.index);\n                        var formatE = format.substr(scientificMatch.index + 2); // E(+|-)\n                        var precision = getCustomFormatPrecision(formatM, formatMeta);\n                        var scale = getCustomFormatScale(formatM, formatMeta);\n                        if (scale !== 1) {\n                            value = value * scale;\n                        }\n                        // Assert that value is a number and fall back on returning value if it is not\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                        if (typeof (value) !== \"number\")\n                            return String(value);\n                        var s = value.toExponential(precision);\n                        var indexOfE = s.indexOf(\"e\");\n                        var mantissa = s.substr(0, indexOfE);\n                        var exp = s.substr(indexOfE + 1);\n                        var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\n                        var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\n                            resultE = resultE.substr(1);\n                        }\n                        var e = scientificMatch[0].charAt(0);\n                        result = resultM + e + resultE;\n                    }\n                }\n                // Non scientific format\n                if (result === undefined) {\n                    var valueFormatted = void 0;\n                    var isValueGlobalized = false;\n                    var precision = getCustomFormatPrecision(format, formatMeta);\n                    var scale = getCustomFormatScale(format, formatMeta);\n                    if (scale !== 1)\n                        value = value * scale;\n                    // Rounding\n                    value = parseFloat(toNonScientific(value, precision));\n                    if (nonScientificOverrideFormat) {\n                        // Get numeric format from format string\n                        var numericFormat = NumberFormat.getNumericFormat(value, format);\n                        // Add separators and decimalFormat to nonScientificFormat\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\n                        // Format the value\n                        valueFormatted = powerbi_1.formattingService.format(nonScientificOverrideFormat, [value], culture.name);\n                        isValueGlobalized = true;\n                    }\n                    else\n                        valueFormatted = toNonScientific(value, precision);\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\n                }\n                if (formatMeta.hasQuotes) {\n                    result = FormattingEncoder.restoreLiterals(result, literals);\n                }\n                if (formatMeta.hasEscapes) {\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%\");\n                }\n                _lastCustomFormatMeta = formatMeta;\n            }\n            else {\n                return Globalize.format(value, undefined);\n            }\n            return result;\n        }\n        /** Returns string with the fixed point respresentation of the number */\n        function toNonScientific(value, precision) {\n            var result = \"\";\n            var precisionZeros = 0;\n            // Double precision numbers support actual 15-16 decimal digits of precision.\n            if (precision > 16) {\n                precisionZeros = precision - 16;\n                precision = 16;\n            }\n            var digitsBeforeDecimalPoint = powerbi_1.Double.log10(Math.abs(value));\n            if (digitsBeforeDecimalPoint < 16) {\n                if (digitsBeforeDecimalPoint > 0) {\n                    var maxPrecision = 16 - digitsBeforeDecimalPoint;\n                    if (precision > maxPrecision) {\n                        precisionZeros += precision - maxPrecision;\n                        precision = maxPrecision;\n                    }\n                }\n                result = value.toFixed(precision);\n            }\n            else if (digitsBeforeDecimalPoint === 16) {\n                result = value.toFixed(0);\n                precisionZeros += precision;\n                if (precisionZeros > 0) {\n                    result += \".\";\n                }\n            }\n            else {\n                // Different browsers have different implementations of the toFixed().\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\n                // So we need to check for range and convert the to exponential with the max precision.\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\n                // Assert that value is a number and fall back on returning value if it is not\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\n                if (typeof (value) !== \"number\")\n                    return String(value);\n                result = value.toExponential(15);\n                var indexOfE = result.indexOf(\"e\");\n                if (indexOfE > 0) {\n                    var indexOfDot = result.indexOf(\".\");\n                    var mantissa = result.substr(0, indexOfE);\n                    var exp = result.substr(indexOfE + 1);\n                    var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\n                    if (precision > 0) {\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\n                    }\n                }\n            }\n            if (precisionZeros > 0) {\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\n            }\n            return result;\n        }\n        /**\n         * Returns the formatMetadata of the format\n         * When calculating precision and scale, if format string of\n         * positive[;negative;zero] => positive format will be used\n         * @param (required) format - format string\n         * @param (optional) calculatePrecision - calculate precision of positive format\n         * @param (optional) calculateScale - calculate scale of positive format\n         */\n        function getCustomFormatMetadata(format, calculatePrecision, calculateScale) {\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\n                return _lastCustomFormatMeta;\n            }\n            var result = {\n                format: format,\n                hasEscapes: false,\n                hasQuotes: false,\n                hasE: false,\n                hasCommas: false,\n                hasDots: false,\n                hasPercent: false,\n                hasPermile: false,\n                precision: undefined,\n                scale: undefined,\n            };\n            for (var i = 0, length_1 = format.length; i < length_1; i++) {\n                var c = format.charAt(i);\n                switch (c) {\n                    case \"\\\\\":\n                        result.hasEscapes = true;\n                        break;\n                    case \"'\":\n                    case \"\\\"\":\n                        result.hasQuotes = true;\n                        break;\n                    case \"e\":\n                    case \"E\":\n                        result.hasE = true;\n                        break;\n                    case \",\":\n                        result.hasCommas = true;\n                        break;\n                    case \".\":\n                        result.hasDots = true;\n                        break;\n                    case \"%\":\n                        result.hasPercent = true;\n                        break;\n                    case \"\":\n                        result.hasPermile = true;\n                        break;\n                }\n            }\n            // Use positive format for calculating these values\n            var formatComponents = getComponents(format);\n            if (calculatePrecision)\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\n            if (calculateScale)\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\n            return result;\n        }\n        NumberFormat.getCustomFormatMetadata = getCustomFormatMetadata;\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\n        function getCustomFormatPrecision(format, formatMeta) {\n            if (formatMeta.precision > -1) {\n                return formatMeta.precision;\n            }\n            var result = 0;\n            if (formatMeta.hasDots) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex > -1) {\n                    var count = format.length;\n                    for (var i = dotIndex; i < count; i++) {\n                        var char = format.charAt(i);\n                        if (char.match(NumericPlaceholderRegex))\n                            result++;\n                        // 0.00E+0 :: Break before counting 0 in\n                        // exponential portion of format string\n                        if (char === ExponentialFormatChar)\n                            break;\n                    }\n                    result = Math.min(19, result);\n                }\n            }\n            formatMeta.precision = result;\n            return result;\n        }\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\n        function getCustomFormatScale(format, formatMeta) {\n            if (formatMeta.scale > -1) {\n                return formatMeta.scale;\n            }\n            var result = 1;\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\n                result = result * 100;\n            }\n            if (formatMeta.hasPermile && format.indexOf(\"\") > -1) {\n                result = result * 1000;\n            }\n            if (formatMeta.hasCommas) {\n                var dotIndex = format.indexOf(\".\");\n                if (dotIndex === -1) {\n                    dotIndex = format.length;\n                }\n                for (var i = dotIndex - 1; i > -1; i--) {\n                    var char = format.charAt(i);\n                    if (char === \",\") {\n                        result = result / 1000;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            formatMeta.scale = result;\n            return result;\n        }\n        function fuseNumberWithCustomFormat(value, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized) {\n            var suppressModifyValue = !!nonScientificOverrideFormat;\n            var formatParts = format.split(\".\", 2);\n            if (formatParts.length === 2) {\n                var wholeFormat = formatParts[0];\n                var fractionFormat = formatParts[1];\n                var displayUnit = \"\";\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\n                if (nonScientificOverrideFormat) {\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\n                    value = value.replace(displayUnit, \"\");\n                }\n                var globalizedDecimalSeparator = numberFormatInfo[\".\"];\n                var decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\n                var valueParts = value.split(decimalSeparator, 2);\n                var wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\n                var fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\n                var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\n                var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\n                    return wholeFormattedValue + fractionFormattedValue.value;\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\n            }\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\n        }\n        function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {\n            var groupSymbolIndex = format.indexOf(\",\");\n            var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\n            var groupDigitCount = 0;\n            var groupIndex = 0;\n            var groupSizes = numberFormatInfo.groupSizes || [3];\n            var groupSize = groupSizes[0];\n            var groupSeparator = numberFormatInfo[\",\"];\n            var sign = \"\";\n            var firstChar = value.charAt(0);\n            if (firstChar === \"+\" || firstChar === \"-\") {\n                sign = numberFormatInfo[firstChar];\n                value = value.substr(1);\n            }\n            var isZero = value === \"0\";\n            var result = \"\";\n            var leftBuffer = \"\";\n            var vi = value.length - 1;\n            var fmtOnly = true;\n            // Iterate through format chars and replace 0 and # with the digits from the value string\n            for (var fi = format.length - 1; fi > -1; fi--) {\n                var formatChar = format.charAt(fi);\n                switch (formatChar) {\n                    case ZeroPlaceholder:\n                    case DigitPlaceholder:\n                        fmtOnly = false;\n                        if (leftBuffer !== \"\") {\n                            result = leftBuffer + result;\n                            leftBuffer = \"\";\n                        }\n                        if (!suppressModifyValue) {\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\n                                if (enableGroups) {\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\n                                    if (groupDigitCount === groupSize) {\n                                        result = groupSeparator + result;\n                                        groupIndex++;\n                                        if (groupIndex < groupSizes.length) {\n                                            groupSize = groupSizes[groupIndex];\n                                        }\n                                        groupDigitCount = 1;\n                                    }\n                                    else {\n                                        groupDigitCount++;\n                                    }\n                                }\n                            }\n                            if (vi > -1) {\n                                if (isZero && formatChar === DigitPlaceholder) {\n                                }\n                                else {\n                                    result = value.charAt(vi) + result;\n                                }\n                                vi--;\n                            }\n                            else if (formatChar !== DigitPlaceholder) {\n                                result = formatChar + result;\n                            }\n                        }\n                        break;\n                    case \",\":\n                        // We should skip all the , chars\n                        break;\n                    default:\n                        leftBuffer = formatChar + leftBuffer;\n                        break;\n                }\n            }\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\n            if (!suppressModifyValue) {\n                if (vi > -1 && result !== \"\") {\n                    if (enableGroups) {\n                        while (vi > -1) {\n                            if (groupDigitCount === groupSize) {\n                                result = groupSeparator + result;\n                                groupIndex++;\n                                if (groupIndex < groupSizes.length) {\n                                    groupSize = groupSizes[groupIndex];\n                                }\n                                groupDigitCount = 1;\n                            }\n                            else {\n                                groupDigitCount++;\n                            }\n                            result = value.charAt(vi) + result;\n                            vi--;\n                        }\n                    }\n                    else {\n                        result = value.substr(0, vi + 1) + result;\n                    }\n                }\n                // Insert sign in front of the leftBuffer and result\n                return sign + leftBuffer + result;\n            }\n            if (fmtOnly)\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\n                return sign + leftBuffer + result;\n            return sign + leftBuffer + value + result;\n        }\n        function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {\n            var vi = 0;\n            var fCount = format.length;\n            var vCount = value.length;\n            if (suppressModifyValue) {\n                debug.assert(fCount > 0, \"Empty formatting string\");\n                var lastChar = format.charAt(fCount - 1);\n                if (!lastChar.match(NumericPlaceholderRegex))\n                    return {\n                        value: value + lastChar,\n                        fmtOnly: value === \"\",\n                    };\n                return {\n                    value: value,\n                    fmtOnly: value === \"\",\n                };\n            }\n            var result = \"\", fmtOnly = true;\n            for (var fi = 0; fi < fCount; fi++) {\n                var formatChar = format.charAt(fi);\n                if (vi < vCount) {\n                    switch (formatChar) {\n                        case ZeroPlaceholder:\n                        case DigitPlaceholder:\n                            result += value[vi++];\n                            fmtOnly = false;\n                            break;\n                        default:\n                            result += formatChar;\n                    }\n                }\n                else {\n                    if (formatChar !== DigitPlaceholder) {\n                        result += formatChar;\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\n                    }\n                }\n            }\n            return {\n                value: result,\n                fmtOnly: fmtOnly,\n            };\n        }\n        function localize(value, dictionary) {\n            var plus = dictionary[\"+\"];\n            var minus = dictionary[\"-\"];\n            var dot = dictionary[\".\"];\n            var comma = dictionary[\",\"];\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\n                return value;\n            }\n            var count = value.length;\n            var result = \"\";\n            for (var i = 0; i < count; i++) {\n                var char = value.charAt(i);\n                switch (char) {\n                    case \"+\":\n                        result = result + plus;\n                        break;\n                    case \"-\":\n                        result = result + minus;\n                        break;\n                    case \".\":\n                        result = result + dot;\n                        break;\n                    case \",\":\n                        result = result + comma;\n                        break;\n                    default:\n                        result = result + char;\n                        break;\n                }\n            }\n            return result;\n        }\n    })(NumberFormat = powerbi_1.NumberFormat || (powerbi_1.NumberFormat = {}));\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\n    var DateTimeScaleFormatInfo = (function () {\n        // Constructor\n        /**\n         * Creates new instance of the DateTimeScaleFormatInfo class.\n         * @param culture - culture which calendar info is going to be used to derive the formats.\n         */\n        function DateTimeScaleFormatInfo(culture) {\n            var calendar = culture.calendar;\n            var patterns = calendar.patterns;\n            var monthAbbreviations = calendar[\"months\"][\"namesAbbr\"];\n            var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];\n            var yearMonthPattern = patterns[\"Y\"];\n            var monthDayPattern = patterns[\"M\"];\n            var fullPattern = patterns[\"f\"];\n            var longTimePattern = patterns[\"T\"];\n            var shortTimePattern = patterns[\"t\"];\n            var separator = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\n            var hasYearSymbol = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\n            var yearPos = fullPattern.indexOf(\"yy\");\n            var monthPos = fullPattern.indexOf(\"MMMM\");\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\n            var minutePos = fullPattern.indexOf(\"mm\");\n            var pmPos = fullPattern.indexOf(\"tt\");\n            var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\n            this.MinutePattern = shortTimePattern;\n            this.SecondPattern = longTimePattern;\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\n            // Special cases\n            switch (culture.name) {\n                case \"fi-FI\":\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\n                    break;\n            }\n        }\n        // Methods\n        /**\n         * Returns the format string of the provided DateTimeUnit.\n         * @param unit - date or time unit\n         */\n        DateTimeScaleFormatInfo.prototype.getFormatString = function (unit) {\n            switch (unit) {\n                case powerbi_1.DateTimeUnit.Year:\n                    return this.YearPattern;\n                case powerbi_1.DateTimeUnit.Month:\n                    return this.MonthPattern;\n                case powerbi_1.DateTimeUnit.Week:\n                case powerbi_1.DateTimeUnit.Day:\n                    return this.DayPattern;\n                case powerbi_1.DateTimeUnit.Hour:\n                    return this.HourPattern;\n                case powerbi_1.DateTimeUnit.Minute:\n                    return this.MinutePattern;\n                case powerbi_1.DateTimeUnit.Second:\n                    return this.SecondPattern;\n                case powerbi_1.DateTimeUnit.Millisecond:\n                    return this.MillisecondPattern;\n            }\n            debug.assertFail('Unexpected unit: ' + unit);\n        };\n        return DateTimeScaleFormatInfo;\n    }());\n    powerbi_1.formattingService = new FormattingService();\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var data;\n    (function (data) {\n        /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\n        var SQExprShortSerializer;\n        (function (SQExprShortSerializer) {\n            function serialize(expr) {\n                return JSON.stringify(expr.accept(SQExprSerializer.instance));\n            }\n            SQExprShortSerializer.serialize = serialize;\n            function serializeArray(exprs) {\n                var str = '[';\n                for (var i = 0, len = exprs.length; i < len; i++) {\n                    if (i > 0)\n                        str += ',';\n                    str += SQExprShortSerializer.serialize(exprs[i]);\n                }\n                return str + ']';\n            }\n            SQExprShortSerializer.serializeArray = serializeArray;\n            /** Responsible for serializing an SQExpr into a comparable string. */\n            var SQExprSerializer = (function (_super) {\n                __extends(SQExprSerializer, _super);\n                function SQExprSerializer() {\n                    _super.apply(this, arguments);\n                }\n                SQExprSerializer.prototype.visitColumnRef = function (expr) {\n                    return {\n                        col: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitMeasureRef = function (expr) {\n                    return {\n                        measure: {\n                            s: expr.source.accept(this),\n                            r: expr.ref,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitAggr = function (expr) {\n                    return {\n                        agg: {\n                            a: expr.arg.accept(this),\n                            f: expr.func,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitEntity = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    debug.assertValue(expr.entity, 'expr.entity');\n                    return {\n                        e: expr.entity\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchyLevel = function (expr) {\n                    return {\n                        h: expr.arg.accept(this),\n                        l: expr.level,\n                    };\n                };\n                SQExprSerializer.prototype.visitHierarchy = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        h: expr.hierarchy,\n                    };\n                };\n                SQExprSerializer.prototype.visitPropertyVariationSource = function (expr) {\n                    return {\n                        e: expr.arg.accept(this),\n                        n: expr.name,\n                        p: expr.property,\n                    };\n                };\n                SQExprSerializer.prototype.visitAnd = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        and: {\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitCompare = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        comp: {\n                            k: expr.comparison,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this),\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitConstant = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        const: {\n                            t: expr.type.primitiveType,\n                            v: expr.value,\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitArithmetic = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        arithmetic: {\n                            o: expr.operator,\n                            l: expr.left.accept(this),\n                            r: expr.right.accept(this)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitScopedEval = function (expr) {\n                    debug.assertValue(expr, 'expr');\n                    return {\n                        scopedEval: {\n                            e: expr.expression.accept(this),\n                            s: serializeArray(expr.scope)\n                        }\n                    };\n                };\n                SQExprSerializer.prototype.visitDefault = function (expr) {\n                    debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\n                    return;\n                };\n                SQExprSerializer.instance = new SQExprSerializer();\n                return SQExprSerializer;\n            }(data.DefaultSQExprVisitor));\n        })(SQExprShortSerializer = data.SQExprShortSerializer || (data.SQExprShortSerializer = {}));\n    })(data = powerbi.data || (powerbi.data = {}));\n})(powerbi || (powerbi = {}));\n/*\n *  Power BI Visualizations\n *\n *  Copyright (c) Microsoft Corporation\n *  All rights reserved.\n *  MIT License\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in\n *  all copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *  THE SOFTWARE.\n */\nvar powerbi;\n(function (powerbi) {\n    var visuals;\n    (function (visuals) {\n        var Selector = powerbi.data.Selector;\n        /**\n         * A combination of identifiers used to uniquely identify\n         * data points and their bound geometry.\n         */\n        var SelectionId = (function () {\n            function SelectionId(selector, highlight) {\n                this.selector = selector;\n                this.highlight = highlight;\n                this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\n                this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\n            }\n            SelectionId.prototype.equals = function (other) {\n                if (!this.selector || !other.selector) {\n                    return (!this.selector === !other.selector) && this.highlight === other.highlight;\n                }\n                return this.highlight === other.highlight && Selector.equals(this.selector, other.selector);\n            };\n            /**\n             * Checks equality against other for all identifiers existing in this.\n             */\n            SelectionId.prototype.includes = function (other, ignoreHighlight) {\n                if (ignoreHighlight === void 0) { ignoreHighlight = false; }\n                var thisSelector = this.selector;\n                var otherSelector = other.selector;\n                if (!thisSelector || !otherSelector) {\n                    return false;\n                }\n                var thisData = thisSelector.data;\n                var otherData = otherSelector.data;\n                if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\n                    return false;\n                if (!ignoreHighlight && this.highlight !== other.highlight)\n                    return false;\n                if (thisData) {\n                    if (!otherData)\n                        return false;\n                    if (thisData.length > 0) {\n                        for (var i = 0, ilen = thisData.length; i < ilen; i++) {\n                            var thisValue = thisData[i];\n                            if (!otherData.some(function (otherValue) { return powerbi.DataViewScopeIdentity.equals(thisValue, otherValue); }))\n                                return false;\n                        }\n                    }\n                }\n                return true;\n            };\n            SelectionId.prototype.getKey = function () {\n                return this.key;\n            };\n            SelectionId.prototype.getKeyWithoutHighlight = function () {\n                return this.keyWithoutHighlight;\n            };\n            SelectionId.prototype.hasIdentity = function () {\n                return (this.selector && !!this.selector.data);\n            };\n            SelectionId.prototype.getSelector = function () {\n                return this.selector;\n            };\n            SelectionId.prototype.getSelectorsByColumn = function () {\n                return this.selectorsByColumn;\n            };\n            SelectionId.createNull = function (highlight) {\n                if (highlight === void 0) { highlight = false; }\n                return new SelectionId(null, highlight);\n            };\n            SelectionId.createWithId = function (id, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                if (id) {\n                    selector = {\n                        data: [id]\n                    };\n                }\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithMeasure = function (measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                debug.assertValue(measureId, 'measureId');\n                var selector = {\n                    metadata: measureId\n                };\n                var selectionId = new SelectionId(selector, highlight);\n                selectionId.selectorsByColumn = { metadata: measureId };\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasure = function (id, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                if (id) {\n                    selector.data = [id];\n                }\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id && !measureId)\n                    selector = null;\n                var selectionId = new SelectionId(selector, highlight);\n                return selectionId;\n            };\n            SelectionId.createWithIdAndMeasureAndCategory = function (id, measureId, queryName, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\n                if (selectionId.selector) {\n                    selectionId.selectorsByColumn = {};\n                    if (id && queryName) {\n                        selectionId.selectorsByColumn.dataMap = {};\n                        selectionId.selectorsByColumn.dataMap[queryName] = id;\n                    }\n                    if (measureId)\n                        selectionId.selectorsByColumn.metadata = measureId;\n                }\n                return selectionId;\n            };\n            SelectionId.createWithIds = function (id1, id2, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = null;\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector = { data: selectorData };\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithIdsAndMeasure = function (id1, id2, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selector = {};\n                var selectorData = SelectionId.idArray(id1, id2);\n                if (selectorData)\n                    selector.data = selectorData;\n                if (measureId)\n                    selector.metadata = measureId;\n                if (!id1 && !id2 && !measureId)\n                    selector = null;\n                return new SelectionId(selector, highlight);\n            };\n            SelectionId.createWithSelectorForColumnAndMeasure = function (dataMap, measureId, highlight) {\n                if (highlight === void 0) { highlight = false; }\n                var selectionId;\n                var keys = Object.keys(dataMap);\n                if (keys.length === 2) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], dataMap[keys[1]], measureId, highlight);\n                }\n                else if (keys.length === 1) {\n                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], null, measureId, highlight);\n                }\n                else {\n                    selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\n                }\n                var selectorsByColumn = {};\n                if (!_.isEmpty(dataMap))\n                    selectorsByColumn.dataMap = dataMap;\n                if (measureId)\n                    selectorsByColumn.metadata = measureId;\n                if (!dataMap && !measureId)\n                    selectorsByColumn = null;\n                selectionId.selectorsByColumn = selectorsByColumn;\n                return selectionId;\n            };\n            SelectionId.createWithHighlight = function (original) {\n                debug.assertValue(original, 'original');\n                debug.assert(!original.highlight, '!original.highlight');\n                var newId = new SelectionId(original.getSelector(), /*highlight*/ true);\n                newId.selectorsByColumn = original.selectorsByColumn;\n                return newId;\n            };\n            SelectionId.idArray = function (id1, id2) {\n                if (id1 || id2) {\n                    var data_7 = [];\n                    if (id1)\n                        data_7.push(id1);\n                    if (id2 && id2 !== id1)\n                        data_7.push(id2);\n                    return data_7;\n                }\n            };\n            return SelectionId;\n        }());\n        visuals.SelectionId = SelectionId;\n        /**\n         * This class is designed to simplify the creation of SelectionId objects\n         * It allows chaining to build up an object before calling 'create' to build a SelectionId\n         */\n        var SelectionIdBuilder = (function () {\n            function SelectionIdBuilder() {\n            }\n            SelectionIdBuilder.builder = function () {\n                return new SelectionIdBuilder();\n            };\n            SelectionIdBuilder.prototype.withCategory = function (categoryColumn, index) {\n                if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\n                    this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\n                return this;\n            };\n            SelectionIdBuilder.prototype.withSeries = function (seriesColumn, valueColumn) {\n                if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\n                    this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\n                return this;\n            };\n            SelectionIdBuilder.prototype.withMeasure = function (measureId) {\n                this.measure = measureId;\n                return this;\n            };\n            SelectionIdBuilder.prototype.createSelectionId = function () {\n                return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\n            };\n            SelectionIdBuilder.prototype.ensureDataMap = function () {\n                if (!this.dataMap)\n                    this.dataMap = {};\n                return this.dataMap;\n            };\n            return SelectionIdBuilder;\n        }());\n        visuals.SelectionIdBuilder = SelectionIdBuilder;\n    })(visuals = powerbi.visuals || (powerbi.visuals = {}));\n})(powerbi || (powerbi = {}));\n\n\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Allows generic traversal and type discovery for a SQExpr tree. */\r\n    export interface ISQExprVisitorWithArg<T, TArg> {\r\n        visitEntity(expr: SQEntityExpr, arg: TArg): T;\r\n        visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T;\r\n        visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T;\r\n        visitAggr(expr: SQAggregationExpr, arg: TArg): T;\r\n        visitPercentile(expr: SQPercentileExpr, arg: TArg): T;\r\n        visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T;\r\n        visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T;\r\n        visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T;\r\n        visitAnd(expr: SQAndExpr, arg: TArg): T;\r\n        visitBetween(expr: SQBetweenExpr, arg: TArg): T;\r\n        visitIn(expr: SQInExpr, arg: TArg): T;\r\n        visitOr(expr: SQOrExpr, arg: TArg): T;\r\n        visitCompare(expr: SQCompareExpr, arg: TArg): T;\r\n        visitContains(expr: SQContainsExpr, arg: TArg): T;\r\n        visitExists(expr: SQExistsExpr, arg: TArg): T;\r\n        visitNot(expr: SQNotExpr, arg: TArg): T;\r\n        visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T;\r\n        visitConstant(expr: SQConstantExpr, arg: TArg): T;\r\n        visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T;\r\n        visitDateAdd(expr: SQDateAddExpr, arg: TArg): T;\r\n        visitNow(expr: SQNowExpr, arg: TArg): T;\r\n        visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T;\r\n        visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T;\r\n        visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T;\r\n        visitFillRule(expr: SQFillRuleExpr, arg: TArg): T;\r\n        visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T;\r\n        visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T;\r\n    }\r\n\r\n    export interface ISQExprVisitor<T> extends ISQExprVisitorWithArg<T, void> {\r\n    }\r\n\r\n    /** Default IQueryExprVisitorWithArg implementation that others may derive from. */\r\n    export class DefaultSQExprVisitorWithArg<T, TArg> implements ISQExprVisitorWithArg<T, TArg> {\r\n        public visitEntity(expr: SQEntityExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, arg: TArg): T {\r\n            return this.visitDefault(expr, arg);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr, arg: TArg): T {\r\n            return;\r\n        }\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that others may derive from. */\r\n    export class DefaultSQExprVisitor<T> extends DefaultSQExprVisitorWithArg<T, void> implements ISQExprVisitor<T> {\r\n    }\r\n\r\n    /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */\r\n    export class DefaultSQExprVisitorWithTraversal implements ISQExprVisitor<void>, IFillRuleDefinitionVisitor<void, void> {\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): void {\r\n            expr.source.accept(this);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): void {\r\n            expr.arg.accept(this);\r\n        } \r\n\r\n        public visitPercentile(expr: SQPercentileExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr): void {\r\n            expr.arg.accept(this);\r\n            expr.lower.accept(this);\r\n            expr.upper.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): void {\r\n            let args = expr.args;\r\n            for (let i = 0, len = args.length; i < len; i++)\r\n                args[i].accept(this);\r\n\r\n            let values = expr.values;\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let valueTuple = values[i];\r\n                for (let j = 0, jlen = valueTuple.length; j < jlen; j++)\r\n                    valueTuple[j].accept(this);\r\n            }\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr): void {\r\n            expr.arg.accept(this);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): void {\r\n            expr.left.accept(this);\r\n            expr.right.accept(this);\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr): void {\r\n            expr.input.accept(this);\r\n\r\n            let rule = expr.rule,\r\n                gradient2 = rule.linearGradient2,\r\n                gradient3 = rule.linearGradient3;\r\n\r\n            if (gradient2) {\r\n                this.visitLinearGradient2(gradient2);\r\n            }\r\n\r\n            if (gradient3) {\r\n                this.visitLinearGradient3(gradient3);\r\n            }\r\n        }\r\n\r\n        public visitLinearGradient2(gradient2: LinearGradient2Definition): void {\r\n            debug.assertValue(gradient2, 'gradient2');\r\n\r\n            this.visitFillRuleStop(gradient2.min);\r\n            this.visitFillRuleStop(gradient2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(gradient3: LinearGradient3Definition): void {\r\n            debug.assertValue(gradient3, 'gradient3');\r\n\r\n            this.visitFillRuleStop(gradient3.min);\r\n            this.visitFillRuleStop(gradient3.mid);\r\n            this.visitFillRuleStop(gradient3.max);\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr): void {\r\n            this.visitDefault(expr);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): void {\r\n            expr.expression.accept(this);\r\n\r\n            for (let scopeExpr of expr.scope) {\r\n                scopeExpr.accept(this);\r\n            }\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): void {\r\n            return;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): void {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            stop.color.accept(this);\r\n\r\n            let value = stop.value;\r\n            if (value)\r\n                value.accept(this);\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Defines a custom enumeration data type, and its values. */\r\n    export interface IEnumType {\r\n        /** Gets the members of the enumeration, limited to the validMembers, if appropriate. */\r\n        members(validMembers?: EnumMemberValue[]): IEnumMember[];\r\n    }\r\n\r\n    export function createEnumType(members: IEnumMember[]): IEnumType {\r\n        return new EnumType(members);\r\n    }\r\n\r\n    class EnumType implements IEnumType {\r\n        private allMembers: IEnumMember[];\r\n\r\n        constructor(allMembers: IEnumMember[]) {\r\n            debug.assertValue(allMembers, 'allMembers');\r\n\r\n            this.allMembers = allMembers;\r\n        }\r\n\r\n        public members(validMembers?: EnumMemberValue[]): IEnumMember[] {\r\n            let allMembers = this.allMembers;\r\n            if (!validMembers)\r\n                return allMembers;\r\n\r\n            let membersToReturn: IEnumMember[] = [];\r\n            for (let member of allMembers) {\r\n                if (_.contains(validMembers, member.value))\r\n                    membersToReturn.push(member);\r\n            }\r\n            return membersToReturn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface FillDefinition {\r\n        solid?: {\r\n            color?: SQExpr;\r\n        };\r\n        gradient?: {\r\n            startColor?: SQExpr;\r\n            endColor?: SQExpr;\r\n        };\r\n        pattern?: {\r\n            patternKind?: SQExpr;\r\n            color?: SQExpr;\r\n        };\r\n    }\r\n\r\n    export module FillSolidColorTypeDescriptor {\r\n        /** Gets a value indicating whether the descriptor is nullable or not. */\r\n        export function nullable(descriptor: FillSolidColorTypeDescriptor): boolean {\r\n            debug.assertValue(descriptor, 'descriptor');\r\n\r\n            if (descriptor === true)\r\n                return false;\r\n\r\n            let advancedDescriptor = <FillSolidColorAdvancedTypeDescriptor>descriptor;\r\n            return !!advancedDescriptor.nullable;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ImageTypeDescriptor {\r\n    }\r\n\r\n    export type ImageDefinition = ImageDefinitionGeneric<SQExpr>;\r\n\r\n    export module ImageDefinition {\r\n        export const urlType: ValueTypeDescriptor = { misc: { imageUrl: true } };\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import SemanticFilter = powerbi.data.SemanticFilter;\r\n\r\n    export type StructuralObjectDefinition =\r\n        FillDefinition |\r\n        FillRuleDefinition |\r\n        SemanticFilter |\r\n        DefaultValueDefinition |\r\n        ImageDefinition |\r\n        ParagraphsDefinition;\r\n\r\n    export module StructuralTypeDescriptor {\r\n        export function isValid(type: StructuralTypeDescriptor): boolean {\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (type.fill ||\r\n                type.fillRule ||\r\n                type.filter ||\r\n                type.expression ||\r\n                type.image ||\r\n                type.paragraphs) {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n\r\n    export interface ValueTypeDescriptor {\r\n        extendedType?: ExtendedType;\r\n    }\r\n    \r\n    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */\r\n    export class ValueType implements ValueTypeDescriptor {\r\n        private static typeCache: { [id: string]: ValueType } = {};\r\n\r\n        private underlyingType: ExtendedType;\r\n        private category: string;\r\n\r\n        private temporalType: TemporalType;\r\n        private geographyType: GeographyType;\r\n        private miscType: MiscellaneousType;\r\n        private formattingType: FormattingType;\r\n        private enumType: IEnumType;\r\n        private scriptingType: ScriptType;\r\n\r\n        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */\r\n        constructor(type: ExtendedType, category?: string, enumType?: IEnumType) {\r\n            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');\r\n            debug.assert(!!category || category === null, 'category');\r\n            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');\r\n\r\n            this.underlyingType = type;\r\n            this.category = category;\r\n\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {\r\n                this.temporalType = new TemporalType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {\r\n                this.geographyType = new GeographyType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {\r\n                this.miscType = new MiscellaneousType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {\r\n                this.formattingType = new FormattingType(type);\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {\r\n                this.enumType = enumType;\r\n            }\r\n            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {\r\n                this.scriptingType = new ScriptType(type);\r\n            }\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */\r\n        public static fromDescriptor(descriptor: ValueTypeDescriptor): ValueType {\r\n            descriptor = descriptor || {};\r\n\r\n            // Simplified primitive types\r\n            if (descriptor.text) return ValueType.fromExtendedType(ExtendedType.Text);\r\n            if (descriptor.integer) return ValueType.fromExtendedType(ExtendedType.Integer);\r\n            if (descriptor.numeric) return ValueType.fromExtendedType(ExtendedType.Double);\r\n            if (descriptor.bool) return ValueType.fromExtendedType(ExtendedType.Boolean);\r\n            if (descriptor.dateTime) return ValueType.fromExtendedType(ExtendedType.DateTime);\r\n            if (descriptor.duration) return ValueType.fromExtendedType(ExtendedType.Duration);\r\n            if (descriptor.binary) return ValueType.fromExtendedType(ExtendedType.Binary);\r\n            if (descriptor.none) return ValueType.fromExtendedType(ExtendedType.None);\r\n\r\n            // Extended types\r\n            if (descriptor.scripting) {\r\n                if (descriptor.scripting.source) return ValueType.fromExtendedType(ExtendedType.ScriptSource);\r\n            }\r\n            if (descriptor.enumeration) return ValueType.fromEnum(descriptor.enumeration);\r\n            if (descriptor.temporal) {\r\n                if (descriptor.temporal.year) return ValueType.fromExtendedType(ExtendedType.Year_Integer);\r\n                if (descriptor.temporal.month) return ValueType.fromExtendedType(ExtendedType.Month_Integer);\r\n            }\r\n            if (descriptor.geography) {\r\n                if (descriptor.geography.address) return ValueType.fromExtendedType(ExtendedType.Address);\r\n                if (descriptor.geography.city) return ValueType.fromExtendedType(ExtendedType.City);\r\n                if (descriptor.geography.continent) return ValueType.fromExtendedType(ExtendedType.Continent);\r\n                if (descriptor.geography.country) return ValueType.fromExtendedType(ExtendedType.Country);\r\n                if (descriptor.geography.county) return ValueType.fromExtendedType(ExtendedType.County);\r\n                if (descriptor.geography.region) return ValueType.fromExtendedType(ExtendedType.Region);\r\n                if (descriptor.geography.postalCode) return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);\r\n                if (descriptor.geography.stateOrProvince) return ValueType.fromExtendedType(ExtendedType.StateOrProvince);\r\n                if (descriptor.geography.place) return ValueType.fromExtendedType(ExtendedType.Place);\r\n                if (descriptor.geography.latitude) return ValueType.fromExtendedType(ExtendedType.Latitude_Double);\r\n                if (descriptor.geography.longitude) return ValueType.fromExtendedType(ExtendedType.Longitude_Double);\r\n            }\r\n            if (descriptor.misc) {\r\n                if (descriptor.misc.image) return ValueType.fromExtendedType(ExtendedType.Image);\r\n                if (descriptor.misc.imageUrl) return ValueType.fromExtendedType(ExtendedType.ImageUrl);\r\n                if (descriptor.misc.webUrl) return ValueType.fromExtendedType(ExtendedType.WebUrl);\r\n                if (descriptor.misc.barcode) return ValueType.fromExtendedType(ExtendedType.Barcode_Text);\r\n            }\r\n            if (descriptor.formatting) {\r\n                if (descriptor.formatting.color) return ValueType.fromExtendedType(ExtendedType.Color);\r\n                if (descriptor.formatting.formatString) return ValueType.fromExtendedType(ExtendedType.FormatString);\r\n                if (descriptor.formatting.alignment) return ValueType.fromExtendedType(ExtendedType.Alignment);\r\n                if (descriptor.formatting.labelDisplayUnits) return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);\r\n                if (descriptor.formatting.fontSize) return ValueType.fromExtendedType(ExtendedType.FontSize);\r\n                if (descriptor.formatting.labelDensity) return ValueType.fromExtendedType(ExtendedType.LabelDensity);\r\n            }\r\n            if (descriptor.extendedType) {\r\n                return ValueType.fromExtendedType(descriptor.extendedType);\r\n            }\r\n\r\n            return ValueType.fromExtendedType(ExtendedType.Null);\r\n        }\r\n\r\n        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */\r\n        public static fromExtendedType(extendedType: ExtendedType): ValueType {\r\n            extendedType = extendedType || ExtendedType.Null;\r\n\r\n            let primitiveType = getPrimitiveType(extendedType),\r\n                category = getCategoryFromExtendedType(extendedType);\r\n            debug.assert(\r\n                primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null,\r\n                'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');\r\n            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);\r\n        }\r\n\r\n        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */\r\n        public static fromPrimitiveTypeAndCategory(primitiveType: PrimitiveType, category?: string): ValueType {\r\n            primitiveType = primitiveType || PrimitiveType.Null;\r\n            category = category || null;\r\n\r\n            let id = primitiveType.toString();\r\n            if (category)\r\n                id += '|' + category;\r\n\r\n            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));\r\n        }\r\n\r\n        /** Creates a ValueType to describe the given IEnumType. */\r\n        public static fromEnum(enumType: IEnumType): ValueType {\r\n            debug.assertValue(enumType, 'enumType');\r\n\r\n            return new ValueType(ExtendedType.Enumeration, null, enumType);\r\n        }\r\n\r\n        /** Determines if the specified type is compatible from at least one of the otherTypes. */\r\n        public static isCompatibleTo(type: ValueTypeDescriptor, otherTypes: ValueTypeDescriptor[]): boolean {\r\n            debug.assertValue(type, 'type');\r\n            debug.assertValue(otherTypes, 'otherTypes');\r\n\r\n            let valueType = ValueType.fromDescriptor(type);\r\n            for (let otherType of otherTypes) {\r\n                let otherValueType = ValueType.fromDescriptor(otherType);\r\n\r\n                if (otherValueType.isCompatibleFrom(valueType))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */\r\n        public isCompatibleFrom(other: ValueType): boolean {\r\n            debug.assertValue(other, 'other');\r\n\r\n            let otherPrimitiveType = other.primitiveType;\r\n            if (this === other ||\r\n                this.primitiveType === otherPrimitiveType ||\r\n                otherPrimitiveType === PrimitiveType.Null)\r\n                return true;\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * Determines if the instance ValueType is equal to the 'other' ValueType\r\n         * @param {ValueType} other the other ValueType to check equality against\r\n         * @returns True if the instance ValueType is equal to the 'other' ValueType\r\n         */\r\n        public equals(other: ValueType): boolean {\r\n            return _.isEqual(this, other);\r\n        }\r\n\r\n        /** Gets the exact primitive type of this ValueType. */\r\n        public get primitiveType(): PrimitiveType {\r\n            return getPrimitiveType(this.underlyingType);\r\n        }\r\n\r\n        /** Gets the exact extended type of this ValueType. */\r\n        public get extendedType(): ExtendedType {\r\n            return this.underlyingType;\r\n        }\r\n\r\n        /** Gets the data category string (if any) for this ValueType. */\r\n        public get categoryString(): string {\r\n            return this.category;\r\n        }\r\n\r\n        // Simplified primitive types\r\n\r\n        /** Indicates whether the type represents text values. */\r\n        public get text(): boolean {\r\n            return this.primitiveType === PrimitiveType.Text;\r\n        }\r\n\r\n        /** Indicates whether the type represents any numeric value. */\r\n        public get numeric(): boolean {\r\n            return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);\r\n        }\r\n\r\n        /** Indicates whether the type represents integer numeric values. */\r\n        public get integer(): boolean {\r\n            return this.primitiveType === PrimitiveType.Integer;\r\n        }\r\n\r\n        /** Indicates whether the type represents Boolean values. */\r\n        public get bool(): boolean {\r\n            return this.primitiveType === PrimitiveType.Boolean;\r\n        }\r\n\r\n        /** Indicates whether the type represents any date/time values. */\r\n        public get dateTime(): boolean {\r\n            return this.primitiveType === PrimitiveType.DateTime ||\r\n                this.primitiveType === PrimitiveType.Date ||\r\n                this.primitiveType === PrimitiveType.Time;\r\n        }\r\n\r\n        /** Indicates whether the type represents duration values. */\r\n        public get duration(): boolean {\r\n            return this.primitiveType === PrimitiveType.Duration;\r\n        }\r\n\r\n        /** Indicates whether the type represents binary values. */\r\n        public get binary(): boolean {\r\n            return this.primitiveType === PrimitiveType.Binary;\r\n        }\r\n\r\n        /** Indicates whether the type represents none values. */\r\n        public get none(): boolean {\r\n            return this.primitiveType === PrimitiveType.None;\r\n        }\r\n\r\n        // Extended types\r\n\r\n        /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */\r\n        public get temporal(): TemporalType {\r\n            return this.temporalType;\r\n        }\r\n\r\n        /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */\r\n        public get geography(): GeographyType {\r\n            return this.geographyType;\r\n        }\r\n\r\n        /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */\r\n        public get misc(): MiscellaneousType {\r\n            return this.miscType;\r\n        }\r\n\r\n        /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */\r\n        public get formatting(): FormattingType {\r\n            return this.formattingType;\r\n        }\r\n\r\n        /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */\r\n        public get enum(): IEnumType {\r\n            return this.enumType;\r\n        }\r\n\r\n        public get scripting(): ScriptType {\r\n            return this.scriptingType;\r\n        }\r\n    }\r\n\r\n    export class ScriptType implements ScriptTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get source(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);\r\n        }\r\n    }\r\n\r\n    export class TemporalType implements TemporalTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get year(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);\r\n        }\r\n        public get month(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);\r\n        }\r\n    }\r\n\r\n    export class GeographyType implements GeographyTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get address(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);\r\n        }\r\n        public get city(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);\r\n        }\r\n        public get continent(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);\r\n        }\r\n        public get country(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);\r\n        }\r\n        public get county(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);\r\n        }\r\n        public get region(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);\r\n        }\r\n        public get postalCode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);\r\n        }\r\n        public get stateOrProvince(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);\r\n        }\r\n        public get place(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);\r\n        }\r\n        public get latitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);\r\n        }\r\n        public get longitude(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);\r\n        }\r\n    }\r\n\r\n    export class MiscellaneousType implements MiscellaneousTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get image(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);\r\n        }\r\n        public get imageUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);\r\n        }\r\n        public get webUrl(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);\r\n        }\r\n        public get barcode(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Barcode);\r\n        }\r\n    }\r\n\r\n    export class FormattingType implements FormattingTypeDescriptor {\r\n        private underlyingType: ExtendedType;\r\n\r\n        constructor(type: ExtendedType) {\r\n            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');\r\n            this.underlyingType = type;\r\n        }\r\n\r\n        public get color(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);\r\n        }\r\n\r\n        public get formatString(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);\r\n        }\r\n\r\n        public get alignment(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);\r\n        }\r\n\r\n        public get labelDisplayUnits(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);\r\n        }\r\n\r\n        public get fontSize(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);\r\n        }\r\n\r\n        public get labelDensity(): boolean {\r\n            return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);\r\n        }\r\n    }\r\n\r\n    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */\r\n    export enum PrimitiveType {\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = 2,\r\n        Double = 3,\r\n        Integer = 4,\r\n        Boolean = 5,\r\n        Date = 6,\r\n        DateTime = 7,\r\n        DateTimeZone = 8,\r\n        Time = 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n    }\r\n\r\n    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */\r\n    export enum ExtendedType {\r\n        // Flags (1 << 8-15 range [0xFF00])\r\n        // Important: Enum members must be declared before they are used in TypeScript.\r\n        Numeric = 1 << 8,\r\n        Temporal = 1 << 9,\r\n        Geography = 1 << 10,\r\n        Miscellaneous = 1 << 11,\r\n        Formatting = 1 << 12,\r\n        Scripting = 1 << 13,        \r\n\r\n        // Primitive types (0-255 range [0xFF] | flags)\r\n        // The member names and base values must match those in PrimitiveType.\r\n        Null = 0,\r\n        Text = 1,\r\n        Decimal = Numeric | 2,\r\n        Double = Numeric | 3,\r\n        Integer = Numeric | 4,\r\n        Boolean = 5,\r\n        Date = Temporal | 6,\r\n        DateTime = Temporal | 7,\r\n        DateTimeZone = Temporal | 8,\r\n        Time = Temporal | 9,\r\n        Duration = 10,\r\n        Binary = 11,\r\n        None = 12,\r\n\r\n        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)\r\n        // Temporal\r\n        Year = Temporal | (1 << 16),\r\n        Year_Text = Year | Text,\r\n        Year_Integer = Year | Integer,\r\n        Year_Date = Year | Date,\r\n        Year_DateTime = Year | DateTime,\r\n        Month = Temporal | (2 << 16),\r\n        Month_Text = Month | Text,\r\n        Month_Integer = Month | Integer,\r\n        Month_Date = Month | Date,\r\n        Month_DateTime = Month | DateTime,\r\n        // Geography\r\n        Address = Text | Geography | (100 << 16),\r\n        City = Text | Geography | (101 << 16),\r\n        Continent = Text | Geography | (102 << 16),\r\n        Country = Text | Geography | (103 << 16),\r\n        County = Text | Geography | (104 << 16),\r\n        Region = Text | Geography | (105 << 16),\r\n        PostalCode = Geography | (106 << 16),\r\n        PostalCode_Text = PostalCode | Text,\r\n        PostalCode_Integer = PostalCode | Integer,\r\n        StateOrProvince = Text | Geography | (107 << 16),\r\n        Place = Text | Geography | (108 << 16),\r\n        Latitude = Geography | (109 << 16),\r\n        Latitude_Decimal = Latitude | Decimal,\r\n        Latitude_Double = Latitude | Double,\r\n        Longitude = Geography | (110 << 16),\r\n        Longitude_Decimal = Longitude | Decimal,\r\n        Longitude_Double = Longitude | Double,\r\n        // Miscellaneous\r\n        Image = Binary | Miscellaneous | (200 << 16),\r\n        ImageUrl = Text | Miscellaneous | (201 << 16),\r\n        WebUrl = Text | Miscellaneous | (202 << 16),\r\n        Barcode =  Miscellaneous | (203 << 16),\r\n        Barcode_Text = Barcode | Text,\r\n        Barcode_Integer = Barcode | Integer,\r\n\r\n        // Formatting\r\n        Color = Text | Formatting | (300 << 16),\r\n        FormatString = Text | Formatting | (301 << 16),\r\n        Alignment = Text | Formatting | (306 << 16),\r\n        LabelDisplayUnits = Text | Formatting | (307 << 16),\r\n        FontSize = Double | Formatting | (308 << 16),\r\n        LabelDensity = Double | Formatting | (309 << 16),\r\n        // Enumeration\r\n        Enumeration = Text | 400 << 16,\r\n        // Scripting\r\n        ScriptSource = Text | Scripting | (500 << 16),        \r\n        // NOTE: To avoid confusion, underscores should be used only to delimit primitive type variants of an extended type\r\n        // (e.g. Year_Integer or Latitude_Double above)\r\n    }\r\n\r\n    const PrimitiveTypeMask = 0xFF;\r\n    const PrimitiveTypeWithFlagsMask = 0xFFFF;\r\n    const PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;\r\n\r\n    function getPrimitiveType(extendedType: ExtendedType): PrimitiveType {\r\n        return extendedType & PrimitiveTypeMask;\r\n    }\r\n\r\n    function isPrimitiveType(extendedType: ExtendedType): boolean {\r\n        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;\r\n    }\r\n\r\n    function getCategoryFromExtendedType(extendedType: ExtendedType): string {\r\n        if (isPrimitiveType(extendedType))\r\n            return null;\r\n\r\n        let category = ExtendedType[extendedType];\r\n        if (category) {\r\n            // Check for ExtendedType declaration without a primitive type.\r\n            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)\r\n            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)\r\n            let delimIdx = category.lastIndexOf('_');\r\n            if (delimIdx > 0) {\r\n                let baseCategory = category.slice(0, delimIdx);\r\n                if (ExtendedType[baseCategory]) {\r\n                    debug.assert(\r\n                        (ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask),\r\n                        'Unexpected value for ExtendedType base member of ' + extendedType);\r\n                    category = baseCategory;\r\n                }\r\n            }\r\n        }\r\n        return category || null;\r\n    }\r\n\r\n    function toExtendedType(primitiveType: PrimitiveType, category?: string): ExtendedType {\r\n        let primitiveString = PrimitiveType[primitiveType];\r\n        let t = ExtendedType[primitiveString];\r\n        if (t == null) {\r\n            debug.assertFail('Unexpected primitiveType ' + primitiveType);\r\n            t = ExtendedType.Null;\r\n        }\r\n\r\n        if (primitiveType && category) {\r\n            let categoryType: ExtendedType = ExtendedType[category];\r\n            if (categoryType) {\r\n                let categoryPrimitiveType = getPrimitiveType(categoryType);\r\n                if (categoryPrimitiveType === PrimitiveType.Null) {\r\n                    // Category supports multiple primitive types, check if requested primitive type is supported\r\n                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)\r\n                    categoryType = t | categoryType;\r\n                    if (ExtendedType[categoryType]) {\r\n                        debug.assert(\r\n                            ExtendedType[categoryType] === (category + '_' + primitiveString),\r\n                            'Unexpected name for ExtendedType member ' + categoryType);\r\n                        t = categoryType;\r\n                    }\r\n                }\r\n                else if (categoryPrimitiveType === primitiveType) {\r\n                    // Primitive type matches the single supported type for the category\r\n                    t = categoryType;\r\n                }\r\n            }\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    function matchesExtendedTypeWithAnyPrimitive(a: ExtendedType, b: ExtendedType): boolean {\r\n        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /**\r\n     * Represents the versions of the data shape binding structure.\r\n     * NOTE Keep this file in sync with the Sql\\InfoNav\\src\\Data\\Contracts\\DsqGeneration\\DataShapeBindingVersions.cs\r\n     * file in the TFS Dev branch.\r\n     */\r\n    export const enum DataShapeBindingVersions {\r\n        /** The initial version of data shape binding */\r\n        Version0 = 0,\r\n        /** Explicit subtotal support for axis groupings. */\r\n        Version1 = 1,\r\n    }\r\n\r\n    export interface DataShapeBindingLimitTarget {\r\n        Primary?: number;\r\n    }\r\n\r\n    export enum DataShapeBindingLimitType {\r\n        Top = 0,\r\n        First = 1,\r\n        Last = 2,\r\n        Sample = 3,\r\n        Bottom = 4,\r\n    }\r\n\r\n    export interface DataShapeBindingLimit {\r\n        Count?: number;\r\n        Target: DataShapeBindingLimitTarget;\r\n        Type: DataShapeBindingLimitType;\r\n    }\r\n\r\n    export interface DataShapeBinding {\r\n        Version?: number;\r\n        Primary: DataShapeBindingAxis;\r\n        Secondary?: DataShapeBindingAxis;\r\n        Aggregates?: DataShapeBindingAggregate[];\r\n        Projections?: number[];\r\n        Limits?: DataShapeBindingLimit[];\r\n        Highlights?: FilterDefinition[];\r\n        DataReduction?: DataShapeBindingDataReduction;\r\n        IncludeEmptyGroups?: boolean;\r\n        SuppressedJoinPredicates?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingDataReduction {\r\n        Primary?: DataShapeBindingDataReductionAlgorithm;\r\n        Secondary?: DataShapeBindingDataReductionAlgorithm;\r\n        DataVolume?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionAlgorithm {\r\n        Top?: DataShapeBindingDataReductionTopLimit;\r\n        Sample?: DataShapeBindingDataReductionSampleLimit;\r\n        Bottom?: DataShapeBindingDataReductionBottomLimit;\r\n        Window?: DataShapeBindingDataReductionDataWindow;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionTopLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionSampleLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionBottomLimit {\r\n        Count?: number;\r\n    }\r\n\r\n    export interface DataShapeBindingDataReductionDataWindow {\r\n        Count?: number;\r\n        RestartTokens?: RestartToken;\r\n    }\r\n\r\n    export interface DataShapeBindingAxis {\r\n        Groupings: DataShapeBindingAxisGrouping[];\r\n    }\r\n\r\n    export enum SubtotalType {\r\n        None = 0,\r\n        Before = 1,\r\n        After = 2\r\n    }\r\n\r\n    export interface DataShapeBindingAxisGrouping {\r\n        Projections: number[];\r\n        GroupBy?: number[];\r\n        SuppressedProjections?: number[];\r\n        Subtotal?: SubtotalType;\r\n        ShowItemsWithNoData?: number[];\r\n    }\r\n\r\n    export interface DataShapeBindingAggregate {\r\n        Select: number;\r\n        Kind: DataShapeBindingAggregateKind;\r\n    }\r\n\r\n    export const enum DataShapeBindingAggregateKind {\r\n        None = 0,\r\n        Min = 1,\r\n        Max = 1 << 1,\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataShapeBindingDataReduction {\r\n\r\n        export function createFrom(reduction: ReductionAlgorithm): DataShapeBindingDataReductionAlgorithm {\r\n            if (!reduction)\r\n                return;\r\n\r\n            var result: DataShapeBindingDataReductionAlgorithm;\r\n            if (reduction.top) {\r\n                result = {\r\n                    Top: {}\r\n                };\r\n\r\n                if (reduction.top.count)\r\n                    result.Top.Count = reduction.top.count;\r\n            }\r\n\r\n            if (reduction.bottom) {\r\n                result = {\r\n                    Bottom: {}\r\n                };\r\n\r\n                if (reduction.bottom.count)\r\n                    result.Bottom.Count = reduction.bottom.count;\r\n            }\r\n\r\n            if (reduction.sample) {\r\n                result = {\r\n                    Sample: {}\r\n                };\r\n\r\n                if (reduction.sample.count)\r\n                    result.Sample.Count = reduction.sample.count;\r\n            }\r\n\r\n            if (reduction.window) {\r\n                result = {\r\n                    Window: {}\r\n                };\r\n\r\n                if (reduction.window.count)\r\n                    result.Window.Count = reduction.window.count;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface FederatedConceptualSchemaInitOptions {\r\n        schemas: { [name: string]: ConceptualSchema };\r\n        links?: ConceptualSchemaLink[];\r\n    }\r\n\r\n    /** Represents a federated conceptual schema. */\r\n    export class FederatedConceptualSchema {\r\n        private schemas: { [name: string]: ConceptualSchema };\r\n        private links: ConceptualSchemaLink[];\r\n\r\n        constructor(options: FederatedConceptualSchemaInitOptions) {\r\n            debug.assertValue(options, 'options');\r\n\r\n            this.schemas = options.schemas; \r\n            if (options.links)\r\n                this.links = options.links;\r\n        }\r\n\r\n        public schema(name: string): ConceptualSchema {\r\n            return this.schemas[name];\r\n        }\r\n    }\r\n\r\n    /** Describes a semantic relationship between ConceptualSchemas. */\r\n    export interface ConceptualSchemaLink {\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module Selector {\r\n        export function filterFromSelector(selectors: Selector[], isNot?: boolean): SemanticFilter {\r\n            if (_.isEmpty(selectors))\r\n                return;\r\n\r\n            let exprs: SQExpr[] = [];\r\n            for (let i = 0, ilen = selectors.length; i < ilen; i++) {\r\n                let identity = selectors[i];\r\n                let data = identity.data;\r\n                let exprToAdd: SQExpr = undefined;\r\n                if (data && data.length) {\r\n                    for (let j = 0, jlen = data.length; j < jlen; j++) {\r\n                        exprToAdd = SQExprBuilder.and(exprToAdd, <SQExpr>(<DataViewScopeIdentity>identity.data[j]).expr);\r\n                    }\r\n                }\r\n\r\n                if (exprToAdd)\r\n                    exprs.push(exprToAdd);\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return DataViewScopeIdentity.filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function matchesData(selector: Selector, identities: DataViewScopeIdentity[]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(identities, 'identities');\r\n\r\n            let selectorData = selector.data;\r\n            if (selectorData.length !== identities.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = selectorData.length; i < len; i++) {\r\n                let dataItem = selector.data[i];\r\n                let selectorDataItem = <DataViewScopeIdentity>dataItem;\r\n                if (selectorDataItem.expr) {\r\n                    if (!DataViewScopeIdentity.equals(selectorDataItem, identities[i]))\r\n                        return false;\r\n                }\r\n                else {\r\n                    if (!DataViewScopeWildcard.matches(<DataViewScopeWildcard>dataItem, identities[i]))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function matchesKeys(selector: Selector, keysList: SQExpr[][]): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(selector.data, 'selector.data');\r\n            debug.assertValue(keysList, 'keysList');\r\n\r\n            let selectorData = selector.data,\r\n                selectorDataLength = selectorData.length;\r\n            if (selectorDataLength !== keysList.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < selectorDataLength; i++) {\r\n                let selectorDataItem = selector.data[i],\r\n                    selectorDataExprs: SQExpr[];\r\n\r\n                if ((<DataViewScopeIdentity>selectorDataItem).expr) {\r\n                    selectorDataExprs = ScopeIdentityExtractor.getKeys(<SQExpr>(<DataViewScopeIdentity>selectorDataItem).expr);\r\n                }\r\n                else if ((<DataViewScopeWildcard>selectorDataItem).exprs) {\r\n                    selectorDataExprs = <SQExpr[]>(<DataViewScopeWildcard>selectorDataItem).exprs;\r\n                } else { \r\n                    // In case DataViewRoleWildcard\r\n                    return false;\r\n                }\r\n\r\n                if (!selectorDataExprs)\r\n                    continue;\r\n                if (!SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        /** Determines whether two selectors are equal. */\r\n        export function equals(x: Selector, y: Selector): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            if (x.id !== y.id)\r\n                return false;\r\n            if (x.metadata !== y.metadata)\r\n                return false;\r\n            if (!equalsDataArray(x.data, y.data))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsDataArray(x: DataRepetitionSelector[], y: DataRepetitionSelector[]): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            if (x.length !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = x.length; i < len; i++) {\r\n                if (!equalsData(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function equalsData(x: DataRepetitionSelector, y: DataRepetitionSelector): boolean {\r\n            let selector1 = <DataViewScopeIdentity & DataViewRoleWildcard & DataViewScopeWildcard>x;\r\n            let selector2 = <DataViewScopeIdentity & DataViewRoleWildcard & DataViewScopeWildcard>y;\r\n            if (selector1.expr && selector2.expr)\r\n                return DataViewScopeIdentity.equals(selector1, selector2);\r\n\r\n            if (selector1.exprs && selector2.exprs)\r\n                return DataViewScopeWildcard.equals(selector1, selector2);\r\n\r\n            if (selector1.roles && selector2.roles)\r\n                return DataViewRoleWildcard.equals(selector1, selector2);\r\n\r\n            return false;\r\n        }\r\n\r\n        export function getKey(selector: Selector): string {\r\n            let toStringify: any = {};\r\n            if (selector.data) {\r\n                let data = [];\r\n                for (let i = 0, ilen = selector.data.length; i < ilen; i++) {\r\n                    data.push(selector.data[i].key);\r\n                }\r\n                toStringify.data = data;\r\n            }\r\n            if (selector.metadata)\r\n                toStringify.metadata = selector.metadata;\r\n            if (selector.id)\r\n                toStringify.id = selector.id;\r\n            return JSON.stringify(toStringify);\r\n        }\r\n\r\n        export function containsWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (!dataItems)\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                let wildCard = <DataViewScopeWildcard & DataViewRoleWildcard>dataItem;\r\n                if (wildCard.exprs || wildCard.roles)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function hasRoleWildcard(selector: Selector): boolean {\r\n            debug.assertValue(selector, 'selector');\r\n\r\n            let dataItems = selector.data;\r\n            if (_.isEmpty(dataItems))\r\n                return false;\r\n\r\n            for (let dataItem of dataItems) {\r\n                if (isRoleWildcard(dataItem))\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRoleWildcard(dataItem: DataRepetitionSelector): dataItem is DataViewRoleWildcard {\r\n            return !_.isEmpty((<DataViewRoleWildcard>dataItem).roles);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface QueryDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where?: QueryFilter[];\r\n        OrderBy?: QuerySortClause[];\r\n        Select: QueryExpressionContainer[];\r\n        GroupBy?: QueryExpressionContainer[];\r\n    }\r\n\r\n    export interface FilterDefinition {\r\n        Version?: number;\r\n        From: EntitySource[];\r\n        Where: QueryFilter[];\r\n    }    \r\n\r\n    export enum EntitySourceType {\r\n        Table = 0,\r\n        Pod = 1,\r\n    }\r\n\r\n    export interface EntitySource {\r\n        Name: string;\r\n        EntitySet?: string; // TODO: Remove this when Q&A Silverlight is removed and make Entity required\r\n        Entity?: string;\r\n        Schema?: string;\r\n        Type?: EntitySourceType;\r\n    }\r\n\r\n    export interface QueryFilter {\r\n        Target?: QueryExpressionContainer[];\r\n        Condition: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QuerySortClause {\r\n        Expression: QueryExpressionContainer;\r\n        Direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryExpressionContainer {\r\n        Name?: string;\r\n\r\n        SourceRef?: QuerySourceRefExpression;\r\n        Column?: QueryColumnExpression;\r\n        Measure?: QueryMeasureExpression;\r\n        Aggregation?: QueryAggregationExpression;\r\n        Percentile?: QueryPercentileExpression;\r\n        Hierarchy?: QueryHierarchyExpression;\r\n        HierarchyLevel?: QueryHierarchyLevelExpression;\r\n        PropertyVariationSource?: QueryPropertyVariationSourceExpression;\r\n\r\n        // Logical\r\n        And?: QueryBinaryExpression;\r\n        Between?: QueryBetweenExpression;\r\n        In?: QueryInExpression;\r\n        Or?: QueryBinaryExpression;\r\n        Comparison?: QueryComparisonExpression;\r\n        Not?: QueryNotExpression;\r\n        Contains?: QueryContainsExpression;\r\n        StartsWith?: QueryStartsWithExpression;\r\n        Exists?: QueryExistsExpression;\r\n\r\n        // Constants\r\n        Boolean?: QueryBooleanExpression;\r\n        DateTime?: QueryDateTimeExpression;\r\n        DateTimeSecond?: QueryDateTimeSecondExpression;\r\n        Date?: QueryDateTimeExpression;\r\n        Decimal?: QueryDecimalExpression;\r\n        Integer?: QueryIntegerExpression;\r\n        Null?: QueryNullExpression;\r\n        Number?: QueryNumberExpression;\r\n        String?: QueryStringExpression;\r\n        Literal?: QueryLiteralExpression;\r\n\r\n        DateSpan?: QueryDateSpanExpression;\r\n        DateAdd?: QueryDateAddExpression;\r\n        Now?: QueryNowExpression;\r\n\r\n        // Default Values\r\n        DefaultValue?: QueryDefaultValueExpression;\r\n        AnyValue?: QueryAnyValueExpression;\r\n\r\n        Arithmetic?: QueryArithmeticExpression;\r\n\r\n        // Client-only expressions\r\n        FillRule?: QueryFillRuleExpression;\r\n        ResourcePackageItem?: QueryResourcePackageItem;\r\n\r\n        // Evaluation Expressions\r\n        ScopedEval?: QueryScopedEvalExpression;\r\n    }\r\n\r\n    export interface QueryPropertyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryColumnExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QueryMeasureExpression extends QueryPropertyExpression {\r\n    }\r\n\r\n    export interface QuerySourceRefExpression {\r\n        Source: string;\r\n    }\r\n\r\n    export interface QueryAggregationExpression {\r\n        Function: QueryAggregateFunction;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryPercentileExpression {\r\n        Expression: QueryExpressionContainer;\r\n        K: number;\r\n        Exclusive?: boolean;\r\n    }\r\n\r\n    export interface QueryHierarchyExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Hierarchy: string;\r\n    }\r\n\r\n    export interface QueryHierarchyLevelExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Level: string;\r\n    }\r\n\r\n    export interface QueryPropertyVariationSourceExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Name: string;\r\n        Property: string;\r\n    }\r\n\r\n    export interface QueryBinaryExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryBetweenExpression {\r\n        Expression: QueryExpressionContainer;\r\n        LowerBound: QueryExpressionContainer;\r\n        UpperBound: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryInExpression {\r\n        Expressions: QueryExpressionContainer[];\r\n        Values: QueryExpressionContainer[][];\r\n    }\r\n\r\n    export interface QueryComparisonExpression extends QueryBinaryExpression {\r\n        ComparisonKind: QueryComparisonKind;\r\n    }\r\n\r\n    export interface QueryContainsExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryNotExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryStartsWithExpression extends QueryBinaryExpression { }\r\n\r\n    export interface QueryExistsExpression {\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryConstantExpression<T> {\r\n        Value: T;\r\n    }\r\n\r\n    export interface QueryLiteralExpression {\r\n        Value: string;\r\n    }\r\n\r\n    export interface QueryBooleanExpression extends QueryConstantExpression<boolean> { }\r\n    export interface QueryDateTimeExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDateTimeSecondExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryDecimalExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryIntegerExpression extends QueryConstantExpression<number> { }\r\n    export interface QueryNumberExpression extends QueryConstantExpression<string> { }\r\n    export interface QueryNullExpression { }\r\n    export interface QueryStringExpression extends QueryConstantExpression<string> { }\r\n\r\n    export interface QueryDateSpanExpression {\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryDateAddExpression {\r\n        Amount: number;\r\n        TimeUnit: TimeUnit;\r\n        Expression: QueryExpressionContainer;\r\n    }\r\n\r\n    export interface QueryNowExpression { }\r\n\r\n    export interface QueryDefaultValueExpression { }\r\n\r\n    export interface QueryAnyValueExpression { }\r\n\r\n    export interface QueryArithmeticExpression {\r\n        Left: QueryExpressionContainer;\r\n        Right: QueryExpressionContainer;\r\n        Operator: ArithmeticOperatorKind;\r\n    }\r\n\r\n    export const enum ArithmeticOperatorKind {\r\n        Add = 0,\r\n        Subtract = 1,\r\n        Multiply = 2,\r\n        Divide = 3,\r\n    }\r\n\r\n    export function getArithmeticOperatorName(arithmeticOperatorKind: ArithmeticOperatorKind): string {\r\n        switch (arithmeticOperatorKind) {\r\n            case ArithmeticOperatorKind.Add:\r\n                return \"Add\";\r\n            case ArithmeticOperatorKind.Subtract:\r\n                return \"Subtract\";\r\n            case ArithmeticOperatorKind.Multiply:\r\n                return \"Multiply\";\r\n            case ArithmeticOperatorKind.Divide:\r\n                return \"Divide\";\r\n        }\r\n        throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);\r\n    }\r\n\r\n    export interface QueryFillRuleExpression {\r\n        Input: QueryExpressionContainer;\r\n        FillRule: FillRuleGeneric<QueryExpressionContainer, QueryExpressionContainer>;\r\n    }\r\n\r\n    export interface QueryResourcePackageItem {\r\n        PackageName: string;\r\n        PackageType: number;\r\n        ItemName: string;\r\n    }\r\n\r\n    export interface QueryScopedEvalExpression {\r\n        Expression: QueryExpressionContainer;\r\n        Scope: QueryExpressionContainer[];\r\n    }\r\n\r\n    export enum TimeUnit {\r\n        Day = 0,\r\n        Week = 1,\r\n        Month = 2,\r\n        Year = 3,\r\n        Decade = 4,\r\n        Second = 5,\r\n        Minute = 6,\r\n        Hour = 7,\r\n    }\r\n\r\n    export enum QueryAggregateFunction {\r\n        Sum = 0,\r\n        Avg = 1,\r\n        Count = 2,\r\n        Min = 3,\r\n        Max = 4,\r\n        CountNonNull = 5,\r\n        Median = 6,\r\n        StandardDeviation = 7,\r\n        Variance = 8,\r\n    }\r\n\r\n    export enum QueryComparisonKind {\r\n        Equal = 0,\r\n        GreaterThan = 1,\r\n        GreaterThanOrEqual = 2,\r\n        LessThan = 3,\r\n        LessThanOrEqual = 4,\r\n    }\r\n\r\n    /** Defines semantic data types. */\r\n    export enum SemanticType {\r\n        None = 0x0,\r\n        Number = 0x1,\r\n        Integer = Number + 0x2,\r\n        DateTime = 0x4,\r\n        Time = 0x08,\r\n        Date = DateTime + 0x10,\r\n        Month = Integer + 0x20,\r\n        Year = Integer + 0x40,\r\n        YearAndMonth = 0x80,\r\n        MonthAndDay = 0x100,\r\n        Decade = Integer + 0x200,\r\n        YearAndWeek = 0x400,\r\n        String = 0x800,\r\n        Boolean = 0x1000,\r\n        Table = 0x2000,\r\n        Range = 0x4000,\r\n    }\r\n\r\n    export interface QueryMetadata {\r\n        Select?: SelectMetadata[];\r\n        Filters?: FilterMetadata[];\r\n    }\r\n\r\n    // TODO: Stop using SemanticType and ConceptualDataCategory here (may need server contract changes)\r\n    export interface SelectMetadata {\r\n        Restatement: string;\r\n        \r\n        /* SemanticType or PrimitiveType. */\r\n        Type?: number; \r\n\r\n        Format?: string;\r\n        DataCategory?: ConceptualDataCategory;\r\n\r\n        /** The select projection name. */\r\n        Name?: string;\r\n\r\n        /* If defined, this indicates the KPI class*/\r\n        kpiStatusGraphic?: string; // old version of kpi data\r\n\r\n        /* If defined, this indicates the KPI metadata*/\r\n        kpi?: DataViewKpiColumnMetadata;\r\n    }\r\n\r\n    export interface FilterMetadata {\r\n        Restatement: string;\r\n        Kind?: FilterKind;\r\n        /** The expression being filtered.  This is reflected in the filter card UI. */\r\n        expression?: QueryExpressionContainer;\r\n    }\r\n\r\n    export enum FilterKind {\r\n        Default,\r\n        Period,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    /** Represents a projection from a query result. */\r\n    export interface QueryProjection {\r\n        /** Name of item in the semantic query Select clause. */\r\n        queryRef: string;\r\n\r\n        /** Optional format string. */\r\n        format?: string; // TODO: Deprecate this, and populate format string through objects instead.\r\n    }\r\n\r\n    /** A set of QueryProjections, grouped by visualization property, and ordered within that property. */\r\n    export interface QueryProjectionsByRole {\r\n        [roleName: string]: QueryProjectionCollection;\r\n    }\r\n\r\n    export class QueryProjectionCollection {\r\n        private items: QueryProjection[];\r\n\r\n        /* The activeProjectionReference is an array that contains all the items that we are grouping on in case of a drillable\r\n           role. For example, if you have a drill role with [Country, State, City] and the user drilled to state, the active items\r\n           will include [Country and State]. This means that the query will group on both country and state and the state \"last item\"\r\n           is the item that the user drilled to.\r\n        */\r\n        private _activeProjectionRefs: string[];\r\n        private _showAll: boolean;\r\n\r\n        public constructor(items: QueryProjection[], activeProjectionRefs?: string[], showAll?: boolean) {\r\n            debug.assertValue(items, 'items');\r\n\r\n            this.items = items;\r\n            this._activeProjectionRefs = activeProjectionRefs;\r\n            this._showAll = showAll;\r\n        }\r\n\r\n        /** Returns all projections in a mutable array. */\r\n        public all(): QueryProjection[] {\r\n            return this.items;\r\n        }\r\n\r\n        public get activeProjectionRefs(): string[] {\r\n            return this._activeProjectionRefs;\r\n        }\r\n\r\n        public set activeProjectionRefs(queryReferences: string[]) {\r\n            if (!_.isEmpty(queryReferences)) {\r\n                let queryRefs = this.items.map(val => val.queryRef);\r\n\r\n                for (let queryReference of queryReferences) {\r\n                    if (!_.contains(queryRefs, queryReference))\r\n                        return;\r\n                }\r\n\r\n                this._activeProjectionRefs = queryReferences;\r\n            }\r\n        }\r\n\r\n        public get showAll(): boolean {\r\n            return this._showAll;\r\n        }\r\n\r\n        public set showAll(value: boolean) {\r\n            this._showAll = value;\r\n        }\r\n\r\n        public addActiveQueryReference(queryRef: string): void {\r\n            if (!this._activeProjectionRefs)\r\n                this._activeProjectionRefs = [queryRef];\r\n            else\r\n                this._activeProjectionRefs.push(queryRef);\r\n        }\r\n\r\n        public getLastActiveQueryReference(): string {\r\n            if (!_.isEmpty(this._activeProjectionRefs)) {\r\n                return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];\r\n            }\r\n        }\r\n\r\n        /** Replaces the given oldQueryRef with newQueryRef in this QueryProjectionCollection. */\r\n        public replaceQueryRef(oldQueryRef: string, newQueryRef: string): void {\r\n            debug.assertValue(oldQueryRef, 'oldQueryRef');\r\n            debug.assertValue(newQueryRef, 'newQueryRef');\r\n            debug.assert(oldQueryRef !== newQueryRef, 'oldQueryRef !== newQueryRef');\r\n            debug.assert(_.isEmpty(this._activeProjectionRefs), 'replaceQueryRef(...) is not supported on the QueryProjectionCollection of a drillable role');\r\n\r\n            // Note: the same queryRef can get projected multiple times\r\n            for (let item of this.items) {\r\n                if (item.queryRef === oldQueryRef) {\r\n                    item.queryRef = newQueryRef;\r\n                }\r\n            }\r\n        }\r\n\r\n        public clone(): QueryProjectionCollection {\r\n            return new QueryProjectionCollection(_.cloneDeep(this.items), _.clone(this._activeProjectionRefs), this._showAll);\r\n        }\r\n    }\r\n\r\n    export module QueryProjectionsByRole {\r\n        /** Clones the QueryProjectionsByRole. */\r\n        export function clone(roles: QueryProjectionsByRole): QueryProjectionsByRole {\r\n            if (!roles)\r\n                return roles;\r\n\r\n            let clonedRoles: QueryProjectionsByRole = {};\r\n\r\n            for (let roleName in roles)\r\n                clonedRoles[roleName] = roles[roleName].clone();\r\n\r\n            return clonedRoles;\r\n        }\r\n\r\n        /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */\r\n        export function getRole(roles: QueryProjectionsByRole, name: string): QueryProjectionCollection {\r\n            debug.assertAnyValue(roles, 'roles');\r\n            debug.assertValue(name, 'name');\r\n\r\n            if (!roles)\r\n                return;\r\n\r\n            return roles[name];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export interface VisualElement {\r\n        DataRoles?: DataRole[];\r\n        Settings?: VisualElementSettings;\r\n    }\r\n\r\n    /** Defines common settings for a visual element. */\r\n    export interface VisualElementSettings {\r\n        DisplayUnitSystemType?: DisplayUnitSystemType;\r\n    }\r\n\r\n    export interface DataRole {\r\n        Name: string;\r\n        Projection: number;\r\n        isActive?: boolean;\r\n    }\r\n\r\n    /** The system used to determine display units used during formatting */\r\n    export enum DisplayUnitSystemType {\r\n        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */\r\n        Default,\r\n\r\n        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */\r\n        Verbose,\r\n\r\n        /**\r\n         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).\r\n         * Suitable for dashboard tile cards\r\n         */\r\n        WholeUnits,\r\n\r\n        /**A display unit system that also contains Auto and None units for data labels*/\r\n        DataLabels,\r\n    }\r\n}\r\n\r\nmodule powerbi.data.contracts {\r\n\r\n    export interface DataViewSource {\r\n        data: any;\r\n        type?: string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    /** Repreasents the sequence of the dates/times */\r\n    export class DateTimeSequence {\r\n        // Constants\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;        \r\n\r\n        // Fields\r\n        public min: Date;\r\n        public max: Date;\r\n        public unit: DateTimeUnit;\r\n        public sequence: Date[];\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n\r\n        // Constructors\r\n        /** Creates new instance of the DateTimeSequence */\r\n        constructor(unit: DateTimeUnit) { \r\n            this.unit = unit;\r\n            this.sequence = [];\r\n            this.min = new Date(\"9999-12-31T23:59:59.999\");\r\n            this.max = new Date(\"0001-01-01T00:00:00.000\");\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Add a new Date to a sequence.\r\n         * @param date - date to add\r\n         */\r\n        public add(date: Date) { \r\n            if (date < this.min) { \r\n                this.min = date;\r\n            }\r\n            if (date > this.max) { \r\n                this.max = date;\r\n            }\r\n            this.sequence.push(date);\r\n        }\r\n\r\n        // Methods\r\n        /** \r\n         * Extends the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public extendToCover(min: Date, max: Date): void {\r\n            let x: Date = this.min;\r\n            while (min < x) {\r\n                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);\r\n                this.sequence.splice(0, 0, x);\r\n            }\r\n            this.min = x;\r\n\r\n            x = this.max;\r\n            while (x < max) {\r\n                x = DateTimeSequence.addInterval(x, this.interval, this.unit);\r\n                this.sequence.push(x);\r\n            }\r\n            this.max = x;\r\n        }\r\n\r\n        /** \r\n         * Move the sequence to cover new date range\r\n         * @param min - new min to be covered by sequence\r\n         * @param max - new max to be covered by sequence\r\n         */\r\n        public moveToCover(min: Date, max: Date): void { \r\n            let delta: number = DateTimeSequence.getDelta(min, max, this.unit);\r\n            let count = Math.floor(delta / this.interval);\r\n            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);\r\n\r\n            this.sequence = [];            \r\n            this.sequence.push(this.min);\r\n            this.max = this.min;\r\n            while (this.max < max) {\r\n                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);\r\n                this.sequence.push(this.max);\r\n            }\r\n        }\r\n\r\n        // Static\r\n        /**\r\n         * Calculate a new DateTimeSequence\r\n         * @param dataMin - Date representing min of the data range\r\n         * @param dataMax - Date representing max of the data range\r\n         * @param expectedCount - expected number of intervals in the sequence\r\n         * @param unit - of the intervals in the sequence\r\n         */\r\n        public static calculate(dataMin: Date, dataMax: Date, expectedCount: number, unit?: DateTimeUnit): DateTimeSequence {\r\n            if (!unit) { \r\n                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);\r\n            }\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Month:\r\n                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Week:\r\n                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Day:\r\n                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Hour:\r\n                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Minute:\r\n                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Second:\r\n                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);\r\n                default:\r\n                    debug.assertFail(\"Unsupported DateTimeUnit\");\r\n            }\r\n        }\r\n\r\n        public static calculateYears(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"Expected count is out of range\");\r\n\r\n            // Calculate range and sequence\r\n            let yearsRange = NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);\r\n\r\n            // Calculate year sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);\r\n            let newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval; \r\n            let date = new Date(newMinYear, 0, 1);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Year);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMonths(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let minYear = dataMin.getFullYear();\r\n            let maxYear = dataMax.getFullYear();\r\n            let minMonth = dataMin.getMonth();\r\n            let maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();\r\n            let date = new Date(minYear, 0, 1);\r\n            \r\n            // Calculate month sequence\r\n            let sequence = NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Month);\r\n            return result;\r\n        }\r\n\r\n        public static calculateWeeks(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            let firstDayOfWeek = 0;\r\n            let minDayOfWeek = dataMin.getDay();\r\n            let dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;\r\n            let minDay = dataMin.getDate() - dayOffset;\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Week));\r\n\r\n            // Calculate week sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Week);\r\n            return result;\r\n        }\r\n\r\n        public static calculateDays(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = 0;\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, DateTimeUnit.Day));\r\n            \r\n            // Calculate day sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Day);\r\n            return result;\r\n        }\r\n\r\n        public static calculateHours(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Hour));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Hour));\r\n            \r\n            // Calculate hour sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Hour);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMinutes(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Minute));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Minute));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Minute);\r\n            return result;\r\n        }\r\n\r\n        public static calculateSeconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());\r\n            let min = Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Second));\r\n            let max = Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Second));\r\n\r\n            // Calculate minutes numeric sequence\r\n            let sequence = NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Second);\r\n            return result;\r\n        }\r\n\r\n        public static calculateMilliseconds(dataMin: Date, dataMax: Date, expectedCount: number): DateTimeSequence {\r\n            debug.assertValue(dataMin, \"dataMin\");\r\n            debug.assertValue(dataMax, \"dataMax\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), \"expected count is out of range\");\r\n\r\n            // Calculate range\r\n            let date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());\r\n            let min = DateTimeSequence.getDelta(date, dataMin, DateTimeUnit.Millisecond);\r\n            let max = DateTimeSequence.getDelta(date, dataMax, DateTimeUnit.Millisecond);\r\n            \r\n            // Calculate milliseconds numeric sequence\r\n            let sequence = NumericSequence.calculate(NumericSequenceRange.calculate(min, max), expectedCount, 0);\r\n\r\n            // Convert to date sequence\r\n            let result = DateTimeSequence.fromNumericSequence(date, sequence, DateTimeUnit.Millisecond);\r\n            return result;\r\n        }\r\n\r\n        private static fromNumericSequence(date: Date, sequence: NumericSequence, unit: DateTimeUnit) { \r\n            let result = new DateTimeSequence(unit);\r\n            for (let i = 0; i < sequence.sequence.length; i++) { \r\n                let x: number = sequence.sequence[i];\r\n                let d: Date = DateTimeSequence.addInterval(date, x, unit);\r\n                result.add(d);\r\n            }\r\n            result.interval = sequence.interval;\r\n            result.intervalOffset = sequence.intervalOffset;\r\n            return result;\r\n        }\r\n\r\n        private static addInterval(value: Date, interval: number, unit: DateTimeUnit): Date {\r\n            interval = Math.round(interval);\r\n            switch (unit)\r\n            {\r\n                case DateTimeUnit.Year:\r\n                    return DateUtils.addYears(value, interval);\r\n                case DateTimeUnit.Month:\r\n                    return DateUtils.addMonths(value, interval);\r\n                case DateTimeUnit.Week:\r\n                    return DateUtils.addWeeks(value, interval);\r\n                case DateTimeUnit.Day:\r\n                    return DateUtils.addDays(value, interval);\r\n                case DateTimeUnit.Hour:\r\n                    return DateUtils.addHours(value, interval);\r\n                case DateTimeUnit.Minute:\r\n                    return DateUtils.addMinutes(value, interval);\r\n                case DateTimeUnit.Second:\r\n                    return DateUtils.addSeconds(value, interval);\r\n                case DateTimeUnit.Millisecond:\r\n                    return DateUtils.addMilliseconds(value, interval);\r\n            }\r\n        }\r\n\r\n        private static getDelta(min: Date, max: Date, unit: DateTimeUnit): number {\r\n            let delta: number = 0;\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    delta = max.getFullYear() - min.getFullYear();\r\n                    break;\r\n                case DateTimeUnit.Month:\r\n                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();\r\n                    break;\r\n                case DateTimeUnit.Week:\r\n                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Day:\r\n                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);\r\n                    break;\r\n                case DateTimeUnit.Hour:\r\n                    delta = (max.getTime() - min.getTime()) / 3600000;\r\n                    break;\r\n                case DateTimeUnit.Minute:\r\n                    delta = (max.getTime() - min.getTime()) / 60000;\r\n                    break;\r\n                case DateTimeUnit.Second:\r\n                    delta = (max.getTime() - min.getTime()) / 1000;\r\n                    break;\r\n                case DateTimeUnit.Millisecond:\r\n                    delta = max.getTime() - min.getTime();\r\n                    break;\r\n            }\r\n            return delta;\r\n        }\r\n\r\n        public static getIntervalUnit(min:Date, max:Date, maxCount: number): DateTimeUnit {\r\n            maxCount = Math.max(maxCount, 2);\r\n            let totalDays = DateTimeSequence.getDelta(min, max, DateTimeUnit.Day);\r\n            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)\r\n                return DateTimeUnit.Year;\r\n            if (totalDays > 60 && totalDays > 7 * maxCount)\r\n                return DateTimeUnit.Month;\r\n            if (totalDays > 14 && totalDays > 2 * maxCount)\r\n                return DateTimeUnit.Week;\r\n            let totalHours = DateTimeSequence.getDelta(min, max, DateTimeUnit.Hour);\r\n            if (totalDays > 2 && totalHours > 12 * maxCount)\r\n                return DateTimeUnit.Day;\r\n            if (totalHours >= 24 && totalHours >= maxCount)\r\n                return DateTimeUnit.Hour;\r\n            let totalMinutes = DateTimeSequence.getDelta(min, max, DateTimeUnit.Minute);\r\n            if (totalMinutes > 2 && totalMinutes >= maxCount)\r\n                return DateTimeUnit.Minute;\r\n            let totalSeconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Second);\r\n            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)\r\n                return DateTimeUnit.Second;\r\n            let totalMilliseconds = DateTimeSequence.getDelta(min, max, DateTimeUnit.Millisecond);\r\n            if (totalMilliseconds > 0)\r\n                return DateTimeUnit.Millisecond;\r\n  \r\n            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds\r\n            let date = min;\r\n            if (date.getMilliseconds() !== 0)\r\n                return DateTimeUnit.Millisecond;\r\n            if (date.getSeconds() !== 0)\r\n                return DateTimeUnit.Second;\r\n            if (date.getMinutes() !== 0)\r\n                return DateTimeUnit.Minute;\r\n            if (date.getHours() !== 0)\r\n                return DateTimeUnit.Hour;\r\n            if (date.getDate() !== 1)\r\n                return DateTimeUnit.Day;\r\n            if (date.getMonth() !== 0)\r\n                return DateTimeUnit.Month;\r\n            \r\n            return DateTimeUnit.Year;\r\n        }\r\n    }\r\n\r\n    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */\r\n    export module DateUtils { \r\n        let MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n        let MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\r\n\r\n        /**\r\n         * Returns bool indicating weither the provided year is a leap year.\r\n         * @param year - year value\r\n         */\r\n        function isLeap(year: number): boolean { \r\n            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);\r\n        }\r\n\r\n        /** \r\n         * Returns number of days in the provided year/month.\r\n         * @param year - year value\r\n         * @param month - month value\r\n         */\r\n        function getMonthDays(year: number, month: number) { \r\n            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of years to the provided date.\r\n         * @param date - date value\r\n         * @param yearDelta - number of years to add\r\n         */\r\n        export function addYears(date: Date, yearDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n            let isLeapDay = month === 2 && day === 29;\r\n\r\n            let result = new Date(date.getTime());\r\n            year = year + yearDelta;\r\n            if (isLeapDay && !isLeap(year)) {\r\n                day = 28;\r\n            } \r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of months to the provided date.\r\n         * @param date - date value\r\n         * @param monthDelta - number of months to add\r\n         */\r\n        export function addMonths(date: Date, monthDelta: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();\r\n           \r\n            let result = new Date(date.getTime());\r\n            year += (monthDelta - (monthDelta % 12)) / 12;\r\n            month += monthDelta % 12;\r\n\r\n            // VSTS 1325771: Certain column charts don't display any data\r\n            // Wrap arround the month if is after december (value 11)\r\n            if (month > 11) {\r\n                month = month % 12;\r\n                year++;\r\n            }\r\n\r\n            day = Math.min(day, getMonthDays(year, month));\r\n            result.setFullYear(year, month, day);\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of weeks to the provided date.\r\n         * @param date - date value\r\n         * @param weeks - number of weeks to add\r\n         */\r\n        export function addWeeks(date: Date, weeks: number): Date { \r\n            return addDays(date, weeks * 7);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of days to the provided date.\r\n         * @param date - date value\r\n         * @param days - number of days to add\r\n         */\r\n        export function addDays(date: Date, days: number): Date { \r\n            let year = date.getFullYear();\r\n            let month = date.getMonth();\r\n            let day = date.getDate();           \r\n            let result = new Date(date.getTime());\r\n            result.setFullYear(year, month, day + days);\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of hours to the provided date.\r\n         * @param date - date value\r\n         * @param hours - number of hours to add\r\n         */\r\n        export function addHours(date: Date, hours: number): Date { \r\n            return new Date(date.getTime() + hours * 3600000);\r\n        }\r\n\r\n        /**\r\n         * Adds a specified number of minutes to the provided date.\r\n         * @param date - date value\r\n         * @param minutes - number of minutes to add\r\n         */\r\n        export function addMinutes(date: Date, minutes: number): Date { \r\n            return new Date(date.getTime() + minutes * 60000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of seconds to the provided date.\r\n         * @param date - date value\r\n         * @param seconds - number of seconds to add\r\n         */\r\n        export function addSeconds(date: Date, seconds: number): Date { \r\n            return new Date(date.getTime() + seconds * 1000);\r\n        }\r\n\r\n        /** \r\n         * Adds a specified number of milliseconds to the provided date.\r\n         * @param date - date value\r\n         * @param milliseconds - number of milliseconds to add\r\n         */\r\n        export function addMilliseconds(date: Date, milliseconds: number): Date { \r\n            return new Date(date.getTime() + milliseconds);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    // Constants\r\n    const maxExponent = 24;\r\n    const defaultScientificBigNumbersBoundary = 1E15;\r\n    const scientificSmallNumbersBoundary = 1E-4;\r\n    const PERCENTAGE_FORMAT = '%';\r\n    const SCIENTIFIC_FORMAT = 'E+0';\r\n    const DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;\r\n\r\n    // Regular expressions\r\n    /**\r\n     * This regex looks for strings that match one of the following conditions:\r\n     *   - Optionally contain \"0\", \"#\", followed by a period, followed by at least one \"0\" or \"#\" (Ex. ###,000.###)\r\n     *   - Contains at least one of \"0\", \"#\", or \",\" (Ex. ###,000)\r\n     *   - Contain a \"g\" (indicates to use the general .NET numeric format string)\r\n     * The entire string (start to end) must match, and the match is not case-sensitive.\r\n     */\r\n    const SUPPORTED_SCIENTIFIC_FORMATS = /^([0\\#,]*\\.[0\\#]+|[0\\#,]+|g)$/i;\r\n\r\n    export class DisplayUnit {\r\n        // Fields\r\n        public value: number;\r\n        public title: string;\r\n        public labelFormat: string;\r\n        public applicableRangeMin: number;\r\n        public applicableRangeMax: number;\r\n\r\n        // Methods\r\n        public project(value: number): number {\r\n            if (this.value) {\r\n                return Double.removeDecimalNoise(value / this.value);\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public reverseProject(value: number): number {\r\n            if (this.value) {\r\n                return value * this.value;\r\n            } else {\r\n                return value;\r\n            }\r\n        }\r\n\r\n        public isApplicableTo(value: number): boolean {\r\n            value = Math.abs(value);\r\n            let precision = Double.getPrecision(value, 3);\r\n            return Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && Double.lessWithPrecision(value, this.applicableRangeMax, precision);\r\n        }\r\n\r\n        public isScaling(): boolean {\r\n            return this.value > 1;\r\n        }\r\n    }\r\n\r\n    export class DisplayUnitSystem {\r\n        // Fields\r\n        public units: DisplayUnit[];\r\n        public displayUnit: DisplayUnit;\r\n        private unitBaseValue: number;\r\n        protected static UNSUPPORTED_FORMATS = /^(p\\d*)|(.*\\%)|(e\\d*)$/i;\r\n\r\n        // Constructor\r\n        constructor(units?: DisplayUnit[]) {\r\n            this.units = units ? units : [];\r\n        }\r\n\r\n        // Properties\r\n        public get title(): string {\r\n            return this.displayUnit ? this.displayUnit.title : undefined;\r\n        }\r\n\r\n        // Methods\r\n        public update(value: number): void {\r\n            if (value === undefined)\r\n                return;\r\n\r\n            this.unitBaseValue = value;\r\n            this.displayUnit = this.findApplicableDisplayUnit(value);\r\n        }\r\n\r\n        private findApplicableDisplayUnit(value: number): DisplayUnit {\r\n            for (let unit of this.units) {\r\n                if (unit.isApplicableTo(value))\r\n                    return unit;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        public format(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n            if (this.isFormatSupported(format)) {\r\n                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);\r\n\r\n                if (this.hasScientitifcFormat(format)) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {\r\n                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);\r\n                }\r\n                if (decimals != null) {\r\n                    return this.formatHelper(value, '', format, decimals, trailingZeros);\r\n                }\r\n            }\r\n            \r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        public isPercentageFormat(format: string): boolean {\r\n            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;\r\n        }\r\n\r\n        public shouldRespectScalingUnit(format: string): boolean {\r\n            return !this.isPercentageFormat(format);\r\n        }\r\n\r\n        public getNumberOfDecimalsForFormatting(format: string, decimals?: number) {\r\n            return decimals;\r\n        }\r\n\r\n        public isScalingUnit(): boolean {\r\n            return this.displayUnit && this.displayUnit.isScaling();\r\n        }\r\n\r\n        private formatHelper(value: number, nonScientificFormat: string, format: string, decimals?: number, trailingZeros?: boolean) {\r\n            // If the format is \"general\" and we want to override the number of decimal places then use the default numeric format string.\r\n            if ((format === 'g' || format === 'G') && decimals != null)\r\n                format = visuals.valueFormatter.DefaultNumericFormat;\r\n\r\n            format = NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);\r\n\r\n            if (format && !formattingService.isStandardNumberFormat(format))\r\n                return formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);\r\n\r\n            if (!format)\r\n                format = 'G';\r\n            if (!nonScientificFormat)\r\n                nonScientificFormat = '{0}';\r\n\r\n            let text = formattingService.formatValue(value, format);\r\n            return formattingService.format(nonScientificFormat, [text]);\r\n        }\r\n\r\n        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */\r\n        public formatSingleValue(value: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            // Change unit base to a value appropriate for this value\r\n            this.update(this.shouldUseValuePrecision(value) ? Double.getPrecision(value, 8) : value);\r\n\r\n            return this.format(value, format, decimals, trailingZeros);\r\n        }\r\n\r\n        private shouldUseValuePrecision(value: number): boolean {\r\n            if (this.units.length === 0)\r\n                return true;\r\n\r\n            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).\r\n            let applicableRangeMin: number = 0;\r\n            for (let i = 0; i < this.units.length; i++) {\r\n                if (this.units[i].isScaling()) {\r\n                    applicableRangeMin = this.units[i].applicableRangeMin;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return Math.abs(value) < applicableRangeMin;\r\n        }\r\n\r\n        protected isScientific(value: number): boolean {\r\n            return value < - defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||\r\n                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);\r\n        }\r\n\r\n        protected hasScientitifcFormat(format: string): boolean {\r\n            return format && format.toUpperCase().indexOf(\"E\") !== -1;\r\n        }\r\n\r\n        protected supportsScientificFormat(format: string): boolean {\r\n            if (format)\r\n                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);\r\n\r\n            return true;\r\n        }\r\n\r\n        protected shouldFallbackToScientific(value: number, format: string): boolean {\r\n            return !this.hasScientitifcFormat(format)\r\n                && this.supportsScientificFormat(format)\r\n                && this.isScientific(value);\r\n        }\r\n\r\n        protected getScientificFormat(data: number, format: string, decimals: number, trailingZeros: boolean): string {\r\n            // Use scientific format outside of the range\r\n            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {\r\n                let numericFormat = NumberFormat.getNumericFormat(data, format);\r\n                if (decimals)\r\n                    numericFormat = NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);\r\n\r\n                if (numericFormat)\r\n                    return numericFormat + SCIENTIFIC_FORMAT;\r\n                else\r\n                    return DEFAULT_SCIENTIFIC_FORMAT;\r\n            }\r\n\r\n            return format;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */\r\n    export class NoDisplayUnitSystem extends DisplayUnitSystem {\r\n        // Constructor\r\n        constructor() {\r\n            super([]);\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where\r\n        we are showing values (chart axes) and as such it is the default unit system. */\r\n    export class DefaultDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DefaultDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        // Methods\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n\r\n        public static reset(): void {\r\n            DefaultDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DefaultDisplayUnitSystem.units) {\r\n                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, (value: number, previousUnitValue: number, min: number) => {\r\n                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc\r\n                    if (value - previousUnitValue >= 1000) {\r\n                        return value / 10;\r\n                    }\r\n\r\n                    return min;\r\n                });\r\n\r\n                // Ensure last unit has max of infinity\r\n                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DefaultDisplayUnitSystem.units;\r\n        }\r\n    }\r\n\r\n    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least\r\n        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles\r\n        where we have restricted space but do not want to show partial units. */\r\n    export class WholeUnitsDisplayUnitSystem extends DisplayUnitSystem {\r\n        private static units: DisplayUnit[];\r\n\r\n        // Constructor\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(WholeUnitsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public static reset(): void {\r\n            WholeUnitsDisplayUnitSystem.units = null;\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!WholeUnitsDisplayUnitSystem.units) {\r\n                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);\r\n\r\n                // Ensure last unit has max of infinity\r\n                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n\r\n            return WholeUnitsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export class DataLabelsDisplayUnitSystem extends DisplayUnitSystem {\r\n\r\n        // Constants\r\n        private static AUTO_DISPLAYUNIT_VALUE = 0;\r\n        private static NONE_DISPLAYUNIT_VALUE = 1;\r\n        protected static UNSUPPORTED_FORMATS = /^(e\\d*)$/i;\r\n\r\n        private static units: DisplayUnit[];\r\n\r\n        constructor(unitLookup: (exponent: number) => DisplayUnitSystemNames) {\r\n            super(DataLabelsDisplayUnitSystem.getUnits(unitLookup));\r\n        }\r\n\r\n        public isFormatSupported(format: string): boolean {\r\n            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);\r\n        }\r\n\r\n        private static getUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames): DisplayUnit[] {\r\n            if (!DataLabelsDisplayUnitSystem.units) {\r\n                let units = [];\r\n                let adjustMinBasedOnPreviousUnit = (value: number, previousUnitValue: number, min: number): number => {\r\n                    // Never returns true, we are always ignoring\r\n                    // We do not early switch (e.g. 100K instead of 0.1M)\r\n                    // Intended? If so, remove this function, otherwise, remove if statement\r\n                    if (value === -1)\r\n                        if (value - previousUnitValue >= 1000) {\r\n                            return value / 10;\r\n                        }\r\n                    return min;\r\n                };\r\n\r\n                // Add Auto & None\r\n                let names = unitLookup(-1);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                names = unitLookup(0);\r\n                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n\r\n                // Add normal units\r\n                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));\r\n\r\n                // Ensure last unit has max of infinity\r\n                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;\r\n            }\r\n            return DataLabelsDisplayUnitSystem.units;\r\n        }\r\n\r\n        public format(data: number, format: string, decimals?: number, trailingZeros?: boolean): string {\r\n            format = this.getScientificFormat(data, format, decimals, trailingZeros);\r\n\r\n            return super.format(data, format, decimals, trailingZeros);\r\n        }\r\n    }\r\n\r\n    export interface DisplayUnitSystemNames {\r\n        title: string;\r\n        format: string;\r\n    }\r\n\r\n    function createDisplayUnits(unitLookup: (exponent: number) => DisplayUnitSystemNames, adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number) {\r\n        let units = [];\r\n        for (let i = 3; i < maxExponent; i++) {\r\n            let names = unitLookup(i);\r\n            if (names)\r\n                addUnitIfNonEmpty(units, Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);\r\n        }\r\n\r\n        return units;\r\n    }\r\n\r\n    function addUnitIfNonEmpty(\r\n        units: DisplayUnit[],\r\n        value: number,\r\n        title: string,\r\n        labelFormat: string,\r\n        adjustMinBasedOnPreviousUnit?: (value: number, previousUnitValue: number, min: number) => number): void {\r\n        if (title || labelFormat) {\r\n            let min = value;\r\n\r\n            if (units.length > 0) {\r\n                let previousUnit = units[units.length - 1];\r\n\r\n                if (adjustMinBasedOnPreviousUnit)\r\n                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);\r\n\r\n                previousUnit.applicableRangeMax = min;\r\n            }\r\n            let unit = new DisplayUnit();\r\n            unit.value = value;\r\n            unit.applicableRangeMin = min;\r\n            unit.applicableRangeMax = min * 1000;\r\n            unit.title = title;\r\n            unit.labelFormat = labelFormat;\r\n            units.push(unit);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequence {\r\n        private static MIN_COUNT: number = 1;\r\n        private static MAX_COUNT: number = 1000;\r\n\r\n        private maxAllowedMargin: number;\r\n        private canExtendMin: boolean;\r\n        private canExtendMax: boolean;\r\n\r\n        public interval: number;\r\n        public intervalOffset: number;\r\n        public min: number;\r\n        public max: number;\r\n        public precision: number;\r\n        public sequence: number[];\r\n\r\n        public static calculate (range: NumericSequenceRange, expectedCount: number, maxAllowedMargin?: number, minPower?: number, useZeroRefPoint?: boolean, steps?: number[]): NumericSequence {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), \"expectedCount\");\r\n            debug.assert(minPower === undefined|| (minPower >= Double.MIN_EXP && minPower <= Double.MAX_EXP), \"minPower\");\r\n            debug.assert(maxAllowedMargin === undefined|| (maxAllowedMargin >= 0), \"maxAllowedMargin\");\r\n\r\n            let result = new NumericSequence();\r\n\r\n            if (expectedCount === undefined)\r\n                expectedCount = 10;\r\n            else\r\n                expectedCount = Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (minPower === undefined)\r\n                minPower = Double.MIN_EXP;\r\n            if (useZeroRefPoint === undefined)\r\n                useZeroRefPoint = false;\r\n            if (maxAllowedMargin === undefined)\r\n                maxAllowedMargin = 1;\r\n            if (steps === undefined)\r\n                steps = [1, 2, 5];\r\n\r\n            // Handle single stop case\r\n            if (range.forcedSingleStop) {\r\n                result.interval = range.getSize();\r\n                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);\r\n                result.min = range.min;\r\n                result.max = range.max;\r\n                result.sequence = [range.forcedSingleStop];\r\n                return result;\r\n            }\r\n\r\n            let interval = 0;\r\n            let min = 0;\r\n            let max = 9;\r\n            let canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;\r\n            let canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;\r\n\r\n            let size = range.getSize();\r\n            let exp = Double.log10(size);\r\n\r\n            // Account for Exp of steps\r\n            let stepExp = Double.log10(steps[0]);\r\n            exp = exp - stepExp;\r\n\r\n            // Account for MaxCount\r\n            let expectedCountExp = Double.log10(expectedCount);\r\n            exp = exp - expectedCountExp;\r\n\r\n            // Account for MinPower\r\n            exp = Math.max(exp, minPower - stepExp + 1);\r\n            let count = undefined;\r\n            // Create array of \"good looking\" numbers\r\n            if (interval !== 0) {\r\n                // If explicit interval is defined - use it instead of the steps array.\r\n                let power = Double.pow10(exp);\r\n                let roundMin = Double.floorToPrecision(range.min, power);\r\n                let roundMax = Double.ceilToPrecision(range.max, power);\r\n                let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax);\r\n\r\n                roundRange.shrinkByStep(range, interval);\r\n                min = roundRange.min;\r\n                max = roundRange.max;\r\n                count = Math.floor(roundRange.getSize() / interval);\r\n            }\r\n            else {\r\n                // No interval defined -> find optimal interval\r\n                let dexp;\r\n                for (dexp = 0; dexp < 3; dexp++) {\r\n                    let e = exp + dexp;\r\n                    let power = Double.pow10(e);\r\n\r\n                    let roundMin = Double.floorToPrecision(range.min, power);\r\n                    let roundMax = Double.ceilToPrecision(range.max, power);\r\n\r\n                    // Go throught the steps array looking for the smallest step that produces the right interval count.\r\n                    let stepsCount = steps.length;\r\n                    let stepPower = Double.pow10(e - 1);\r\n                    for (let i = 0; i < stepsCount; i++) {\r\n                        let step = steps[i] * stepPower;\r\n                        let roundRange = NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);\r\n                        roundRange.shrinkByStep(range, step);\r\n\r\n                        // If the range is based on Data we might need to extend it to provide nice data margins.\r\n                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)\r\n                            roundRange.min -= step;\r\n                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)\r\n                            roundRange.max += step;\r\n\r\n                        // Count the intervals\r\n                        count = Double.ceilWithPrecision(roundRange.getSize() / step);\r\n\r\n                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {\r\n                            interval = step;\r\n                            min = roundRange.min;\r\n                            max = roundRange.max;\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                    // Increase the scale power until the interval is found\r\n                    if (interval !== 0)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Avoid extreme count cases (>1000 ticks)\r\n            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {\r\n                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);\r\n                interval = (max - min) / count;\r\n            }\r\n\r\n            result.min = min;\r\n            result.max = max;\r\n            result.interval = interval;\r\n            result.intervalOffset = min - range.min;\r\n            result.maxAllowedMargin = maxAllowedMargin;\r\n            result.canExtendMin = canExtendMin;\r\n            result.canExtendMax = canExtendMax;\r\n\r\n            // Fill in the Sequence\r\n            let precision = Double.getPrecision(interval, 0);\r\n            result.precision = precision;\r\n\r\n            let sequence = [];\r\n\r\n            let x = Double.roundToPrecision(min, precision);\r\n            sequence.push(x);\r\n            for (let i = 0; i < count; i++) {\r\n                x = Double.roundToPrecision(x + interval, precision);\r\n                sequence.push(x);\r\n            }\r\n            \r\n            result.sequence = sequence;\r\n\r\n            result.trimMinMax(range.min, range.max);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** \r\n         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid. \r\n         * @min - The minimum of the range.\r\n         * @max - The maximum of the range.\r\n         * @maxCount - The max count of intervals.\r\n         * @steps - array of intervals.\r\n         */\r\n        public static calculateUnits(min: number, max: number, maxCount: number, steps: number[]): NumericSequence {\r\n            // Initialization actions\r\n            maxCount = Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);\r\n            if (min === max) {\r\n                max = min + 1;\r\n            }\r\n            let stepCount = 0;\r\n            let step = 0;\r\n\r\n            // Calculate step\r\n            for (let i = 0; i < steps.length; i++)\r\n            {\r\n                step = steps[i];\r\n                let maxStepCount = Double.ceilWithPrecision(max / step);\r\n                let minStepCount = Double.floorWithPrecision(min / step);\r\n                stepCount = maxStepCount - minStepCount;\r\n                    \r\n                if (stepCount <= maxCount) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Calculate the offset\r\n            let offset = -min;\r\n            offset = offset % step;\r\n\r\n            // Create sequence\r\n            let result = new NumericSequence();\r\n            result.sequence = [];\r\n            for (let x = min + offset; ; x += step)\r\n            {\r\n                result.sequence.push(x);\r\n                if (x >= max)\r\n                    break;\r\n            }\r\n            result.interval = step;\r\n            result.intervalOffset = offset;\r\n            result.min = result.sequence[0];\r\n            result.max = result.sequence[result.sequence.length - 1];\r\n            return result;\r\n        }\r\n\r\n        public trimMinMax(min: number, max: number): void {        \r\n            let minMargin = (min - this.min) / this.interval;\r\n            let maxMargin = (this.max - max) / this.interval;\r\n            let marginPrecision = 0.001;\r\n\r\n            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {\r\n                this.min = min;\r\n            }\r\n\r\n            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {\r\n                this.max = max;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export class NumericSequenceRange {\r\n        private static DEFAULT_MAX: number = 10;\r\n        private static MIN_SUPPORTED_DOUBLE = -1E307;\r\n        private static MAX_SUPPORTED_DOUBLE = 1E307;\r\n\r\n        public min: number;\r\n        public max: number;\r\n        public includeZero: boolean;\r\n        public forcedSingleStop: number;\r\n        public hasDataRange: boolean;\r\n        public hasFixedMin: boolean;\r\n        public hasFixedMax: boolean;\r\n\r\n        private _ensureIncludeZero(): void { \r\n            if (this.includeZero) {\r\n                // fixed min and max has higher priority than includeZero\r\n                if (this.min > 0 && !this.hasFixedMin) {\r\n                    this.min = 0;\r\n                }\r\n                if (this.max < 0 && !this.hasFixedMax) {\r\n                    this.max = 0;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureNotEmpty(): void { \r\n            if (this.min === this.max) {\r\n                if (!this.min) {\r\n                    this.min = 0;\r\n                    this.max = NumericSequenceRange.DEFAULT_MAX;\r\n                    this.hasFixedMin = true;\r\n                    this.hasFixedMax = true;\r\n                } else {\r\n                    // We are dealing with a single data value (includeZero is not set)\r\n                    // In order to fix the range we need to extend it in both directions by half of the interval.\r\n                    // Interval is calculated based on the number:\r\n                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006\r\n                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.\r\n                    let value = this.min;\r\n                    let exp = Double.log10(Math.abs(value));\r\n                    let step: number;\r\n                    if (exp >= 0 && exp < 4) {\r\n                        step = 0.5;\r\n                        this.forcedSingleStop = value;\r\n                    } else {\r\n                        step = Double.pow10(exp) / 2;\r\n                        this.forcedSingleStop = null;\r\n                    }\r\n                    this.min = value - step;\r\n                    this.max = value + step;\r\n                }\r\n            }\r\n        }\r\n\r\n        private _ensureDirection() { \r\n            if (this.min > this.max) { \r\n                let temp = this.min;\r\n                this.min = this.max;\r\n                this.max = temp;\r\n            }\r\n        }\r\n\r\n        public getSize(): number {\r\n            return this.max - this.min;\r\n        }\r\n\r\n        public shrinkByStep(range: NumericSequenceRange, step: number) {\r\n            debug.assertValue(range, \"range\");\r\n            debug.assert(step > 0, \"step\");\r\n\r\n            let oldCount = this.min / step;\r\n            let newCount = range.min / step;\r\n            let deltaCount = Math.floor(newCount - oldCount);\r\n            this.min += deltaCount * step;\r\n\r\n            oldCount = this.max / step;\r\n            newCount = range.max / step;\r\n            deltaCount = Math.ceil(newCount - oldCount);\r\n            this.max += deltaCount * step;\r\n        }\r\n\r\n        public static calculate(dataMin: number, dataMax: number, fixedMin?:number, fixedMax?:number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assert(dataMin <= dataMax, \"dataMin should be less or equal to dataMax.\");\r\n            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, \"fixedMin should be less or equal to fixedMax.\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.includeZero = includeZero ? true : false;\r\n            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);\r\n            result.hasFixedMin = ValueUtil.hasValue(fixedMin);\r\n            result.hasFixedMax = ValueUtil.hasValue(fixedMax);\r\n\r\n            dataMin = Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n            dataMax = Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);\r\n\r\n            // Calculate the range using the min, max, dataRange\r\n            if (result.hasFixedMin && result.hasFixedMax) {\r\n                result.min = fixedMin;\r\n                result.max = fixedMax;\r\n            } else if (result.hasFixedMin) {\r\n                result.min = fixedMin;\r\n                result.max = dataMax > fixedMin ? dataMax : fixedMin;\r\n            } else if (result.hasFixedMax) {\r\n                result.min = dataMin < fixedMax ? dataMin : fixedMax;\r\n                result.max = fixedMax;\r\n            } else if (result.hasDataRange) {\r\n                result.min = dataMin;\r\n                result.max = dataMax;\r\n            } else {\r\n                result.min = 0;\r\n                result.max = 0;\r\n            }\r\n\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            \r\n            if (result.min === 0) {\r\n                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range\r\n            } else if (result.max === 0) {\r\n                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public static calculateDataRange(dataMin: number, dataMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {\r\n                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);\r\n            } else {\r\n                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);\r\n            }\r\n        }\r\n\r\n        public static calculateFixedRange(fixedMin: number, fixedMax: number, includeZero?: boolean): NumericSequenceRange { \r\n            debug.assertValue(fixedMin, \"fixedMin\");\r\n            debug.assertValue(fixedMax, \"fixedMax\");\r\n\r\n            let result = new NumericSequenceRange(); \r\n            result.hasDataRange = false;\r\n            result.includeZero = includeZero;\r\n            result.min = fixedMin;\r\n            result.max = fixedMax;\r\n            result._ensureIncludeZero();\r\n            result._ensureNotEmpty();\r\n            result._ensureDirection();\r\n            result.hasFixedMin = true;\r\n            result.hasFixedMax = true;\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export module ValueUtil {\r\n        export function hasValue(value: any): boolean {\r\n            return value !== undefined && value !== null;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n\r\n    /**\r\n     * Formats the value using provided format expression\r\n     * @param value - value to be formatted and converted to string.\r\n     * @param format - format to be applied if the number shouldn't be abbreviated.\r\n     * If the number should be abbreviated this string is checked for special characters like $ or % if any\r\n     */\r\n    export interface ICustomValueFormatter {\r\n        (value: any, format?: string): string;\r\n    }\r\n\r\n    export interface ICustomValueColumnFormatter {\r\n        (value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier): string;\r\n    }\r\n\r\n    export interface ValueFormatterOptions {\r\n        /** The format string to use. */\r\n        format?: string;\r\n\r\n        /** The data value. */\r\n        value?: any;\r\n\r\n        /** The data value. */\r\n        value2?: any;\r\n\r\n        /** The number of ticks. */\r\n        tickCount?: any;\r\n\r\n        /** The display unit system to use */\r\n        displayUnitSystemType?: DisplayUnitSystemType;\r\n\r\n        /** True if we are formatting single values in isolation (e.g. card), as opposed to multiple values with a common base (e.g. chart axes) */\r\n        formatSingleValues?: boolean;\r\n\r\n        /** True if we want to trim off unnecessary zeroes after the decimal and remove a space before the % symbol */\r\n        allowFormatBeautification?: boolean;\r\n\r\n        /** Specifies the maximum number of decimal places to show*/\r\n        precision?: number;\r\n\r\n        /** Detect axis precision based on value */\r\n        detectAxisPrecision?: boolean;\r\n\r\n        /** Specifies the column type of the data value */\r\n        columnType?: ValueTypeDescriptor;\r\n    }\r\n\r\n    export interface IValueFormatter {\r\n        format(value: any): string;\r\n        displayUnit?: DisplayUnit;\r\n        options?: ValueFormatterOptions;\r\n    }\r\n\r\n    /** Captures all locale-specific options used by the valueFormatter. */\r\n    export interface ValueFormatterLocalizationOptions {\r\n        null: string;\r\n        true: string;\r\n        false: string;\r\n        NaN: string;\r\n        infinity: string;\r\n        negativeInfinity: string;\r\n\r\n        /** Returns a beautified form the given format string. */\r\n        beautify(format: string): string;\r\n\r\n        /** Returns an object describing the given exponent in the current language. */\r\n        describe(exponent: number): DisplayUnitSystemNames;\r\n        restatementComma: string;\r\n        restatementCompoundAnd: string;\r\n        restatementCompoundOr: string;\r\n    }\r\n\r\n    export module valueFormatter {\r\n        import StringExtensions = jsCommon.StringExtensions;\r\n        const BeautifiedFormat: { [x: string]: string } = {\r\n            '0.00 %;-0.00 %;0.00 %': 'Percentage',\r\n            '0.0 %;-0.0 %;0.0 %': 'Percentage1',\r\n        };\r\n\r\n        export const DefaultIntegerFormat = 'g';\r\n        export const DefaultNumericFormat = '#,0.00';\r\n        export const DefaultDateFormat = 'd';\r\n\r\n        const defaultLocalizedStrings = {\r\n            'NullValue': '(Blank)',\r\n            'BooleanTrue': 'True',\r\n            'BooleanFalse': 'False',\r\n            'NaNValue': 'NaN',\r\n            'InfinityValue': '+Infinity',\r\n            'NegativeInfinityValue': '-Infinity',\r\n            'RestatementComma': '{0}, {1}',\r\n            'RestatementCompoundAnd': '{0} and {1}',\r\n            'RestatementCompoundOr': '{0} or {1}',\r\n            'DisplayUnitSystem_EAuto_Title': 'Auto',\r\n            'DisplayUnitSystem_E0_Title': 'None',\r\n            'DisplayUnitSystem_E3_LabelFormat': '{0}K',\r\n            'DisplayUnitSystem_E3_Title': 'Thousands',\r\n            'DisplayUnitSystem_E6_LabelFormat': '{0}M',\r\n            'DisplayUnitSystem_E6_Title': 'Millions',\r\n            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',\r\n            'DisplayUnitSystem_E9_Title': 'Billions',\r\n            'DisplayUnitSystem_E12_LabelFormat': '{0}T',\r\n            'DisplayUnitSystem_E12_Title': 'Trillions',\r\n            'Percentage': '#,0.##%',\r\n            'Percentage1': '#,0.#%',\r\n            'TableTotalLabel': 'Total',\r\n            'Tooltip_HighlightedValueDisplayName': 'Highlighted',\r\n            'Funnel_PercentOfFirst': 'Percent of first',\r\n            'Funnel_PercentOfPrevious': 'Percent of previous',\r\n            'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlight)',\r\n            'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlight)',\r\n            // Geotagging strings\r\n            'GeotaggingString_Continent': 'continent',\r\n            'GeotaggingString_Continents': 'continents',\r\n            'GeotaggingString_Country': 'country',\r\n            'GeotaggingString_Countries': 'countries',\r\n            'GeotaggingString_State': 'state',\r\n            'GeotaggingString_States': 'states',\r\n            'GeotaggingString_City': 'city',\r\n            'GeotaggingString_Cities': 'cities',\r\n            'GeotaggingString_Town': 'town',\r\n            'GeotaggingString_Towns': 'towns',\r\n            'GeotaggingString_Province': 'province',\r\n            'GeotaggingString_Provinces': 'provinces',\r\n            'GeotaggingString_County': 'county',\r\n            'GeotaggingString_Counties': 'counties',\r\n            'GeotaggingString_Village': 'village',\r\n            'GeotaggingString_Villages': 'villages',\r\n            'GeotaggingString_Post': 'post',\r\n            'GeotaggingString_Zip': 'zip',\r\n            'GeotaggingString_Code': 'code',\r\n            'GeotaggingString_Place': 'place',\r\n            'GeotaggingString_Places': 'places',\r\n            'GeotaggingString_Address': 'address',\r\n            'GeotaggingString_Addresses': 'addresses',\r\n            'GeotaggingString_Street': 'street',\r\n            'GeotaggingString_Streets': 'streets',\r\n            'GeotaggingString_Longitude': 'longitude',\r\n            'GeotaggingString_Longitude_Short': 'lon',\r\n            'GeotaggingString_Latitude': 'latitude',\r\n            'GeotaggingString_Latitude_Short': 'lat',\r\n            'GeotaggingString_PostalCode': 'postal code',\r\n            'GeotaggingString_PostalCodes': 'postal codes',\r\n            'GeotaggingString_ZipCode': 'zip code',\r\n            'GeotaggingString_ZipCodes': 'zip codes',\r\n            'GeotaggingString_Territory': 'territory',\r\n            'GeotaggingString_Territories': 'territories',\r\n        };\r\n\r\n        function beautify(format: string): string {\r\n            let key = BeautifiedFormat[format];\r\n            if (key)\r\n                return defaultLocalizedStrings[key] || format;\r\n            return format;\r\n        }\r\n\r\n        function describeUnit(exponent: number): DisplayUnitSystemNames {\r\n            let exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();\r\n\r\n            let title: string = defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_Title\"];\r\n            let format: string = (exponent <= 0) ? '{0}' : defaultLocalizedStrings[\"DisplayUnitSystem_E\" + exponentLookup + \"_LabelFormat\"];\r\n\r\n            if (title || format)\r\n                return { title: title, format: format };\r\n        }\r\n\r\n        export function getLocalizedString(stringId: string): string {\r\n            return defaultLocalizedStrings[stringId];\r\n        }\r\n\r\n        // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.\r\n        let locale: ValueFormatterLocalizationOptions = {\r\n            null: defaultLocalizedStrings['NullValue'],\r\n            true: defaultLocalizedStrings['BooleanTrue'],\r\n            false: defaultLocalizedStrings['BooleanFalse'],\r\n            NaN: defaultLocalizedStrings['NaNValue'],\r\n            infinity: defaultLocalizedStrings['InfinityValue'],\r\n            negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],\r\n            beautify: format => beautify(format),\r\n            describe: exponent => describeUnit(exponent),\r\n            restatementComma: defaultLocalizedStrings['RestatementComma'],\r\n            restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],\r\n            restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],\r\n        };\r\n\r\n        const MaxScaledDecimalPlaces = 2;\r\n        const MaxValueForDisplayUnitRounding = 1000;\r\n        const MinIntegerValueForDisplayUnits = 10000;\r\n        const MinPrecisionForDisplayUnits = 2;\r\n\r\n        const DateTimeMetadataColumn: DataViewMetadataColumn = {\r\n            displayName: '',\r\n            type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.DateTime),\r\n        };\r\n\r\n        export function getFormatMetadata(format: string): powerbi.NumberFormat.NumericFormatMetadata {\r\n            return powerbi.NumberFormat.getCustomFormatMetadata(format);\r\n        }\r\n\r\n        export function setLocaleOptions(options: ValueFormatterLocalizationOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            locale = options;\r\n\r\n            DefaultDisplayUnitSystem.reset();\r\n            WholeUnitsDisplayUnitSystem.reset();\r\n        }\r\n\r\n        export function createDefaultFormatter(formatString: string, allowFormatBeautification: boolean = false): IValueFormatter {\r\n            let formatBeaut: string = allowFormatBeautification ? locale.beautify(formatString) : formatString;\r\n            return {\r\n                format: function (value: any): string {\r\n                    if (value == null)\r\n                        return locale.null;\r\n\r\n                    return formatCore(value, formatBeaut);\r\n                }\r\n            };\r\n        }\r\n\r\n        /** Creates an IValueFormatter to be used for a range of values. */\r\n        export function create(options: ValueFormatterOptions): IValueFormatter {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;\r\n\r\n            if (shouldUseNumericDisplayUnits(options)) {\r\n                let displayUnitSystem = createDisplayUnitSystem(options.displayUnitSystemType);\r\n\r\n                let singleValueFormattingMode = !!options.formatSingleValues;\r\n\r\n                displayUnitSystem.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));\r\n\r\n                let forcePrecision = options.precision != null;\r\n\r\n                let decimals: number;\r\n\r\n                if (forcePrecision)\r\n                    decimals = -options.precision;\r\n                else if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 1)\r\n                    decimals = -MaxScaledDecimalPlaces;\r\n\r\n                // Detect axis precision\r\n                if (options.detectAxisPrecision) {\r\n                    // Trailing zeroes\r\n                    forcePrecision = true;\r\n\r\n                    let axisValue = options.value;\r\n                    if (displayUnitSystem.displayUnit && displayUnitSystem.displayUnit.value > 0)\r\n                        axisValue = axisValue / displayUnitSystem.displayUnit.value;\r\n\r\n                    if (Double.isInteger(axisValue))\r\n                        decimals = 0;\r\n                    else\r\n                        decimals = Double.log10(axisValue);\r\n                }\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        let formattedValue: string = getStringFormat(value, true /*nullsAreBlank*/);\r\n                        if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                            return formattedValue;\r\n\r\n                        // Round to Double.DEFAULT_PRECISION\r\n                        if (value && !displayUnitSystem.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision)\r\n                            value = Double.roundToPrecision(value);\r\n\r\n                        return singleValueFormattingMode ?\r\n                            displayUnitSystem.formatSingleValue(value, format, decimals, forcePrecision) :\r\n                            displayUnitSystem.format(value, format, decimals, forcePrecision);\r\n                    },\r\n                    displayUnit: displayUnitSystem.displayUnit,\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {\r\n                let unit = DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);\r\n\r\n                return {\r\n                    format: function (value: any): string {\r\n                        if (value == null)\r\n                            return locale.null;\r\n\r\n                        let formatString = formattingService.dateFormatString(unit);\r\n                        return formatCore(value, formatString);\r\n                    },\r\n                    options: options\r\n                };\r\n            }\r\n\r\n            return createDefaultFormatter(format);\r\n        }\r\n\r\n        export function format(value: any, format?: string, allowFormatBeautification?: boolean): string {\r\n            if (value == null)\r\n                return locale.null;\r\n\r\n            return formatCore(\r\n                value,\r\n                !!allowFormatBeautification ? locale.beautify(format) : format);\r\n        }\r\n\r\n        function getValueFormat(value: any, columnType: ValueTypeDescriptor): string {\r\n            // If column type not defined or is not datetime\r\n            // ...and the value is of time datetime,\r\n            // then use the default date format string\r\n            if ((!columnType || !columnType.dateTime) && value instanceof Date)\r\n                return getFormatString(DateTimeMetadataColumn, null, false);\r\n        }\r\n\r\n        export function formatValueColumn(value: any, column: DataViewMetadataColumn, formatStringProp: DataViewObjectPropertyIdentifier): string {\r\n            let valueFormat = getValueFormat(value, column.type);\r\n            if (valueFormat)\r\n                return formatCore(value, valueFormat);\r\n            else\r\n                return formatCore(value, getFormatString(column, formatStringProp));\r\n        }\r\n\r\n        function createDisplayUnitSystem(displayUnitSystemType?: DisplayUnitSystemType): DisplayUnitSystem {\r\n            if (displayUnitSystemType == null)\r\n                return new DefaultDisplayUnitSystem(locale.describe);\r\n\r\n            switch (displayUnitSystemType) {\r\n                case DisplayUnitSystemType.Default:\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.WholeUnits:\r\n                    return new WholeUnitsDisplayUnitSystem(locale.describe);\r\n                case DisplayUnitSystemType.Verbose:\r\n                    return new NoDisplayUnitSystem();\r\n                case DisplayUnitSystemType.DataLabels:\r\n                    return new DataLabelsDisplayUnitSystem(locale.describe);\r\n                default:\r\n                    debug.assertFail('Unknown display unit system type');\r\n                    return new DefaultDisplayUnitSystem(locale.describe);\r\n            }\r\n        }\r\n\r\n        function shouldUseNumericDisplayUnits(options: ValueFormatterOptions): boolean {\r\n            let value = options.value;\r\n            let value2 = options.value2;\r\n            let format = options.format;\r\n            // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units\r\n            if (options.formatSingleValues && format) {\r\n\r\n                if (Math.abs(value) < MinIntegerValueForDisplayUnits) {\r\n\r\n                    let isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);\r\n\r\n                    if (isCustomFormat) {\r\n                        let precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;\r\n\r\n                        if (precision < MinPrecisionForDisplayUnits)\r\n                            return false;\r\n                    }\r\n                    else if (Double.isInteger(value))\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            if ((typeof value === 'number') || (typeof value2 === 'number')) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        function shouldUseDateUnits(value: any, value2?: any, tickCount?: number): boolean {\r\n            // must check both value and value2 because we'll need to get an interval for date units\r\n            return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);\r\n        }\r\n\r\n        /*\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Column format\r\n         *  2. Default PowerView policy for column type\r\n         */\r\n        export function getFormatString(column: DataViewMetadataColumn, formatStringProperty: DataViewObjectPropertyIdentifier, suppressTypeFallback?: boolean): string {\r\n            if (column) {\r\n                if (formatStringProperty) {\r\n                    let propertyValue = DataViewObjects.getValue<string>(column.objects, formatStringProperty);\r\n                    if (propertyValue)\r\n                        return propertyValue;\r\n                }\r\n\r\n                if (!suppressTypeFallback) {\r\n                    let columnType = column.type;\r\n                    if (columnType) {\r\n                        if (columnType.dateTime)\r\n                            return DefaultDateFormat;\r\n                        if (columnType.integer)\r\n                            return DefaultIntegerFormat;\r\n                        if (columnType.numeric)\r\n                            return DefaultNumericFormat;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function formatListCompound(strings: string[], conjunction: string): string {\r\n            let result: string;\r\n\r\n            if (!strings) {\r\n                return null;\r\n            }\r\n\r\n            let length = strings.length;\r\n            if (length > 0) {\r\n                result = strings[0];\r\n                let lastIndex = length - 1;\r\n                for (let i = 1, len = lastIndex; i < len; i++) {\r\n                    let value = strings[i];\r\n                    result = StringExtensions.format(locale.restatementComma, result, value);\r\n                }\r\n\r\n                if (length > 1) {\r\n                    let value = strings[lastIndex];\r\n                    result = StringExtensions.format(conjunction, result, value);\r\n                }\r\n            }\r\n            else {\r\n                result = null;\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., and C'  */\r\n        export function formatListAnd(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundAnd);\r\n        }\r\n\r\n        /** The returned string will look like 'A, B, ..., or C' */\r\n        export function formatListOr(strings: string[]): string {\r\n            return formatListCompound(strings, locale.restatementCompoundOr);\r\n        }\r\n\r\n        function formatCore(value: any, format: string): string {\r\n            let formattedValue = getStringFormat(value, false /*nullsAreBlank*/);\r\n\r\n            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))\r\n                return formattedValue;\r\n\r\n            return formattingService.formatValue(value, format);\r\n        }\r\n\r\n        function getStringFormat(value: any, nullsAreBlank: boolean): string {\r\n            if (value == null && nullsAreBlank)\r\n                return locale.null;\r\n\r\n            if (value === true)\r\n                return locale.true;\r\n\r\n            if (value === false)\r\n                return locale.false;\r\n\r\n            if (typeof value === 'number' && isNaN(value))\r\n                return locale.NaN;\r\n\r\n            if (value === Number.NEGATIVE_INFINITY)\r\n                return locale.negativeInfinity;\r\n\r\n            if (value === Number.POSITIVE_INFINITY)\r\n                return locale.infinity;\r\n\r\n            return '';\r\n        }\r\n\r\n        export function getDisplayUnits(displayUnitSystemType: DisplayUnitSystemType): DisplayUnit[] {\r\n            let displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);\r\n            return displayUnitSystem.units;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataRoleHelper {\r\n        export function getMeasureIndexOfRole(grouped: DataViewValueColumnGroup[], roleName: string): number {\r\n            if (!_.isEmpty(grouped)) {\r\n                let firstGroup = grouped[0];\r\n                if (firstGroup.values && firstGroup.values.length > 0) {\r\n                    for (let i = 0, len = firstGroup.values.length; i < len; ++i) {\r\n                        let value = firstGroup.values[i];\r\n                        if (value && value.source) {\r\n                            if (hasRole(value.source, roleName))\r\n                                return i;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function getCategoryIndexOfRole(categories: DataViewCategoryColumn[], roleName: string): number {\r\n            if (!_.isEmpty(categories)) {\r\n                for (let i = 0, ilen = categories.length; i < ilen; i++) {\r\n                    if (hasRole(categories[i].source, roleName))\r\n                        return i;\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function hasRole(column: DataViewMetadataColumn, name: string): boolean {\r\n            let roles = column.roles;\r\n            return roles && roles[name];\r\n        }\r\n\r\n        export function hasRoleInDataView(dataView: DataView, name: string): boolean {\r\n            return dataView != null\r\n                && dataView.metadata != null\r\n                && dataView.metadata.columns\r\n                && _.any(dataView.metadata.columns, c => c.roles && c.roles[name] !== undefined);\r\n        }\r\n        \r\n        export function hasRoleInValueColumn(valueColumn: DataViewValueColumn, name: string): boolean {\r\n            return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataRoleHelper = powerbi.data.DataRoleHelper;\r\n\r\n    export function createIDataViewCategoricalReader(dataView: DataView): IDataViewCategoricalReader {\r\n        return new DataViewCategoricalReader(dataView);\r\n    }\r\n\r\n    export interface IDataViewCategoricalReader {\r\n        // Category functions\r\n        hasCategories(): boolean;\r\n        getCategoryCount(): number;\r\n        getCategoryValues(roleName: string): any;\r\n        getCategoryValue(roleName: string, categoryIndex: number): any;\r\n        getCategoryColumn(roleName: string): DataViewCategoryColumn;\r\n        getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn;\r\n        getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[];\r\n        getCategoryDisplayName(roleName: string): string;\r\n        hasCompositeCategories(): boolean;\r\n        hasCategoryWithRole(roleName: string): boolean;\r\n        getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects;\r\n        // Value functions\r\n        hasValues(roleName: string): boolean;\r\n        /**\r\n         * Obtains the value for the given role name, category index, and series index.\r\n         *\r\n         * Note: in cases where have multiple values in a role where the multiple values\r\n         * are not being used to create a static series, the first is obtained.\r\n         */\r\n        getValue(roleName: string, categoryIndex: number, seriesIndex?: number): any;\r\n        /**\r\n         * Obtains all the values for the given role name, category index, and series index, drawing\r\n         * from each of the value columns at that intersection.  Used when you have multiple\r\n         * values in a role that are not conceptually a static series.\r\n         */\r\n        getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex?: number): any[];\r\n        /**\r\n         * Obtains the first non-null value for the given role name and category index.\r\n         * It should mainly be used for values that are expected to be the same across\r\n         * series, but avoids false nulls when the data is sparse.\r\n         */\r\n        getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any;\r\n        getMeasureQueryName(roleName: string): string;\r\n        getValueColumn(roleName: string, seriesIndex?: number): DataViewValueColumn;\r\n        getValueMetadataColumn(roleName: string, seriesIndex?: number): DataViewMetadataColumn;\r\n        getValueDisplayName(roleName: string, seriesIndex?: number): string;\r\n        // Series Methods\r\n        hasDynamicSeries(): boolean;\r\n        getSeriesCount(): number;\r\n        getSeriesObjects(seriesIndex: number): DataViewObjects;\r\n        getSeriesValueColumns(): DataViewValueColumns;\r\n        getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup;\r\n        getSeriesMetadataColumn(): DataViewMetadataColumn;\r\n        getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[];\r\n        getSeriesName(seriesIndex: number): PrimitiveValue;\r\n        getSeriesDisplayName(): string;\r\n    }\r\n\r\n    /**\r\n     * A mapping used to map indeces within a specific roleName to an index into the values\r\n     * of a grouped.  This is used so that you can iterate over values within a role without\r\n     * expensive filtering or extra traversal.\r\n     */ \r\n    interface RoleIndexMapping {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    class DataViewCategoricalReader implements IDataViewCategoricalReader {\r\n        private dataView: DataView;\r\n        private categories: DataViewCategoryColumn[];\r\n        private grouped: DataViewValueColumnGroup[];\r\n        private dataHasDynamicSeries: boolean;\r\n        private valueRoleIndexMapping: RoleIndexMapping;\r\n        \r\n        // Validation variables\r\n        private hasValidCategories: boolean;\r\n        private hasAnyValidValues: boolean;\r\n\r\n        constructor(dataView: DataView) {\r\n            debug.assertValue(dataView, 'dataView');\r\n            this.dataView = dataView;\r\n            // Validate categories\r\n            let categorical: DataViewCategorical;\r\n            if (dataView)\r\n                categorical = dataView.categorical;\r\n            let categories: DataViewCategoryColumn[];\r\n            if (categorical)\r\n                categories = this.categories = categorical.categories;\r\n            this.hasValidCategories = !_.isEmpty(categories);\r\n\r\n            // Validate values\r\n            let values: DataViewValueColumns;\r\n            if (categorical)\r\n                values = categorical.values;\r\n            // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff\r\n            // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something\r\n            this.hasAnyValidValues = false;\r\n            if (values != null) {\r\n                let grouped = dataView.categorical.values.grouped();\r\n\r\n                if (grouped.length > 0) {\r\n                    this.hasAnyValidValues = true;\r\n                    this.grouped = grouped;\r\n\r\n                    // Iterate through the first group's values to populate the valueRoleIndexMapping\r\n                    let valueRoleIndexMapping: RoleIndexMapping = {};\r\n                    let firstGroupValues = grouped[0].values;\r\n                    for (let valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {\r\n                        let valueRoles = firstGroupValues[valueIndex].source.roles;\r\n                        for (let role in valueRoles) {\r\n                            if (valueRoles[role]) {\r\n                                if (!valueRoleIndexMapping[role])\r\n                                    valueRoleIndexMapping[role] = [];\r\n                                valueRoleIndexMapping[role].push(valueIndex);\r\n                            }\r\n                        }\r\n                    }\r\n                    this.valueRoleIndexMapping = valueRoleIndexMapping;\r\n                }\r\n            }\r\n\r\n            if (this.hasAnyValidValues)\r\n                this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;\r\n        }\r\n\r\n        // Category methods\r\n        \r\n        public hasCategories(): boolean {\r\n            return this.hasValidCategories;\r\n        }\r\n\r\n        public getCategoryCount(): number {\r\n            if (this.hasValidCategories)\r\n                return this.categories[0].values.length;\r\n            else\r\n                return 0;\r\n        }\r\n\r\n        public getCategoryValues(roleName: string): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryValue(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.values[categoryIndex] : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumn(roleName: string): DataViewCategoryColumn {\r\n            if (this.hasValidCategories)\r\n                return this.getCategoryFromRole(roleName);\r\n        }\r\n\r\n        public getCategoryMetadataColumn(roleName: string): DataViewMetadataColumn {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.source : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryColumnIdentityFields(roleName: string): powerbi.data.ISQExpr[] {\r\n            if (this.hasValidCategories) {\r\n                let categories = this.getCategoryFromRole(roleName);\r\n                return categories ? categories.identityFields : undefined;\r\n            }\r\n        }\r\n\r\n        public getCategoryDisplayName(roleName: string): string {\r\n            if (this.hasValidCategories) {\r\n                let targetColumn = this.getCategoryColumn(roleName);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        public hasCompositeCategories(): boolean {\r\n            if (this.hasValidCategories)\r\n                return this.categories.length > 1;\r\n        }\r\n\r\n        public hasCategoryWithRole(roleName: string): boolean {\r\n            return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;\r\n        }\r\n\r\n        public getCategoryObjects(roleName: string, categoryIndex: number): DataViewObjects {\r\n            if (this.hasValidCategories) {\r\n                let category = this.getCategoryFromRole(roleName);\r\n                if (category && category.objects) {\r\n                    return category.objects[categoryIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        private getCategoryFromRole(roleName: string): DataViewCategoryColumn {\r\n            let categories = this.categories;\r\n            return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];\r\n        }\r\n\r\n        // Value and measure methods\r\n\r\n        public hasValues(roleName: string): boolean {\r\n            return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);\r\n        }\r\n\r\n        public getValue(roleName: string, categoryIndex: number, seriesIndex: number = 0): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (this.dataHasDynamicSeries) {\r\n                    // For dynamic series, we only ever obtain the first value column from a role\r\n                    return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0);\r\n                }\r\n                else {\r\n                    // For static series or single series, we obtain value columns from the first series\r\n                    //    and use the seriesIndex to index into the value columns within the role\r\n                    return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex);\r\n                }\r\n            }\r\n        }\r\n\r\n        public getAllValuesForRole(roleName: string, categoryIndex: number, seriesIndex: number = 0): any[] {\r\n            if (this.hasValues(roleName)) {\r\n                let valuesInRole = [];\r\n                for (let roleValueIndex, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {\r\n                    valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex));\r\n                }\r\n                return valuesInRole;\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Obtains the value from grouped.\r\n         *\r\n         * Grouped:             [0] [1] [2] [3] (seriesIndex)\r\n         *                         /   \\\r\n         * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)\r\n         *                    /    \\ \\  \\           \r\n         * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)\r\n         * \r\n         *--------------------------------|\r\n         *                      |Category |\r\n         * Series|Value Columns |A B C D E|\r\n         *--------------------------------|\r\n         *      0|col0 (tooltip)|         |\r\n         *       |col1 (value)  |         |\r\n         *       |col2 (value)  |         |\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      1|col0 (tooltip)|         |\r\n         *       |col1 (value)  |0 1 2 3 4|\r\n         *       |col2 (value)  |5 6 7 8 9|\r\n         *       |col3 (tooltip)|         |\r\n         *       |col4 (value)  |         |\r\n         *--------------------------------|\r\n         *      2|col0 (tooltip)|...      |\r\n         * \r\n         * valueColumnIndexInRole is for indexing into the values for a single role\r\n         * valueColumnIndex is for indexing into the entire value array including\r\n         * all roles\r\n         * \r\n         * The valueRoleIndexMapping converts roleValueIndex and role (value role\r\n         * with an index of 1) into groupedValueIndex (2)\r\n         *\r\n         * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,\r\n         * the second value column with role \"value\" (which is converted to a\r\n         * groupedValueIndex of 2) and the fourth value within that value column.\r\n         */\r\n        private getValueInternal(roleName: string, categoryIndex: number, groupIndex: number, valueColumnIndexInRole: number): any {\r\n            if (this.hasValues(roleName)) {\r\n                let valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];\r\n                return this.grouped[groupIndex].values[valueColumnIndex].values[categoryIndex];\r\n            }\r\n        }\r\n\r\n        public getFirstNonNullValueForCategory(roleName: string, categoryIndex: number): any {\r\n            if (this.hasValues(roleName)) {\r\n                if (!this.dataHasDynamicSeries) {\r\n                    debug.assert(this.grouped.length === 1, \"getFirstNonNullValueForCategory shouldn't be called if you have a static series\");\r\n                    return this.getValue(roleName, categoryIndex);\r\n                }\r\n                for (let seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {\r\n                    let value = this.getValue(roleName, categoryIndex, seriesIndex);\r\n                    if (value != null) {\r\n                        return value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        public getMeasureQueryName(roleName: string): string {\r\n            if (this.hasValues(roleName))\r\n                return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;\r\n        }\r\n\r\n        public getValueColumn(roleName: string, seriesIndex: number = 0): DataViewValueColumn {\r\n            if (this.hasValues(roleName))\r\n                return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];\r\n        }\r\n\r\n        public getValueMetadataColumn(roleName: string, seriesIndex: number = 0): DataViewMetadataColumn {\r\n            if (this.hasValues(roleName))\r\n                return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]].source;\r\n        }\r\n\r\n        public getValueDisplayName(roleName: string, seriesIndex?: number): string {\r\n            if (this.hasValues(roleName)) {\r\n                let targetColumn = this.getValueColumn(roleName, seriesIndex);\r\n                if (targetColumn && targetColumn.source) {\r\n                    return targetColumn.source.displayName;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Series methods\r\n\r\n        public hasDynamicSeries(): boolean {\r\n            return this.dataHasDynamicSeries;\r\n        }\r\n\r\n        public getSeriesCount(): number {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped.length;\r\n        }\r\n\r\n        public getSeriesObjects(seriesIndex: number): DataViewObjects {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].objects;\r\n        }\r\n\r\n        public getSeriesValueColumns(): DataViewValueColumns {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values;\r\n        }\r\n\r\n        public getSeriesValueColumnGroup(seriesIndex: number): DataViewValueColumnGroup {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex];\r\n        }\r\n\r\n        public getSeriesMetadataColumn(): DataViewMetadataColumn {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.source;\r\n        }\r\n\r\n        public getSeriesColumnIdentityFields(): powerbi.data.ISQExpr[] {\r\n            if (this.hasAnyValidValues)\r\n                return this.dataView.categorical.values.identityFields;\r\n        }\r\n\r\n        public getSeriesName(seriesIndex: number): PrimitiveValue {\r\n            if (this.hasAnyValidValues)\r\n                return this.grouped[seriesIndex].name;\r\n        }\r\n\r\n        public getSeriesDisplayName(): string {\r\n            if (this.hasAnyValidValues && this.dataHasDynamicSeries)\r\n                return this.dataView.categorical.values.source.displayName;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n    import valueFormatter = powerbi.visuals.valueFormatter;\r\n\r\n    export module DataViewConcatenateCategoricalColumns {\r\n\r\n        /* Represents a collection of DataViewCategoryColumn that are tied to the same role. */\r\n        interface CategoryColumnsByRole {\r\n            /* The name of the role shared by all the objects in the categories property. */\r\n            roleName: string;\r\n\r\n            /**\r\n             * The list of columns that are tied to roleName, in the same order as they appear\r\n             * in the categories property of their owner DataViewCategorical object.\r\n             */\r\n            categories: DataViewCategoryColumn[];\r\n        }\r\n\r\n        export function detectAndApply(\r\n            dataView: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            selects: DataViewSelectTransform[],\r\n            projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n\r\n            let result = dataView;\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            if (dataViewCategorical) {\r\n                let concatenationSource: CategoryColumnsByRole = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);\r\n\r\n                if (concatenationSource) {\r\n                    // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?\r\n                    let columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);\r\n                    if (columnsSortedByProjectionOrdering.length >= 2) {\r\n                        let activeItemsToIgnoreInConcatenation =\r\n                            _.chain(projectionActiveItems[concatenationSource.roleName])\r\n                                .filter((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.suppressConcat)\r\n                                .map((activeItemInfo: DataViewProjectionActiveItemInfo) => activeItemInfo.queryRef)\r\n                                .value();\r\n\r\n                        result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */\r\n        export function applyToPlayChartCategorical(\r\n            metadata: DataViewMetadata,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            categoryRoleName: string,\r\n            categorical: DataViewCategorical): DataView {\r\n            debug.assertValue(metadata, 'metadata');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let result: DataView;\r\n            if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {\r\n                // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.\r\n                // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.\r\n                // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),\r\n                // use inherit() rather than inheritSingle() here.\r\n                let transformingColumns = inherit(metadata.columns);\r\n                let transformingMetadata = inherit(metadata, m => { m.columns = transformingColumns; });\r\n\r\n                let transformingDataView = { metadata: transformingMetadata, categorical: categorical };\r\n                result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);\r\n            }\r\n            else {\r\n                result = { metadata: metadata, categorical: categorical };\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the role and its assocated category columns (from dataViewCategorical.categories)\r\n         * that should be concatenated for the case of hierarchical group.\r\n         *\r\n         * Note: In the future if we support sibling hierarchical groups in categorical,\r\n         * change the return type to CategoryColumnsByRole[] and update detection logic.\r\n         */\r\n        function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical: DataViewCategorical, metadata: DataViewMetadata, dataViewMappings: DataViewMapping[], selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): CategoryColumnsByRole {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertAnyValue(dataViewMappings, 'dataViewMappings');\r\n\r\n            let result: CategoryColumnsByRole;\r\n\r\n            // For now, just handle the case where roleMappings.length === 1.\r\n            // In the future, if there is more than 1, we might want to proceed if, \r\n            // for example, all role mappings map category to the same role name and they all have { max: 1 } conditions.\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);\r\n            let projections = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let roleMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            let roleMappingForCategorical: DataViewMapping = (roleMappings && roleMappings.length === 1 && !!roleMappings[0].categorical) ? roleMappings[0] : undefined;\r\n            if (roleMappingForCategorical) {\r\n                let roleNamesForCategory: string[] = getAllRolesInCategories(roleMappingForCategorical.categorical);\r\n\r\n                // With \"list\" in role mapping, is it possible to have multiple role names for category.\r\n                // For now, proceed to concatenate category columns only when categories are bound to 1 Role.\r\n                // We can change this if we want to support independent (sibling) group hierarchies in categorical.\r\n                if (roleNamesForCategory && roleNamesForCategory.length === 1) {\r\n                    let targetRoleName = roleNamesForCategory[0];\r\n\r\n                    let isVisualExpectingMaxOneCategoryColumn: boolean =\r\n                        !_.isEmpty(roleMappingForCategorical.conditions) &&\r\n                        _.every(roleMappingForCategorical.conditions, condition => condition[targetRoleName] && condition[targetRoleName].max === 1);\r\n\r\n                    if (isVisualExpectingMaxOneCategoryColumn) {\r\n                        let categoriesForTargetRole: DataViewCategoryColumn[] = _.filter(\r\n                            dataViewCategorical.categories,\r\n                            (categoryColumn: DataViewCategoryColumn) => categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName]);\r\n\r\n                        // At least for now, we expect all category columns for the same role to have the same number of value entries.\r\n                        // If that's not the case, we won't run the concatenate logic for that role at all...\r\n                        let areValuesCountsEqual: boolean = _.every(\r\n                            categoriesForTargetRole,\r\n                            (categoryColumn: DataViewCategoryColumn) => categoryColumn.values.length === categoriesForTargetRole[0].values.length);\r\n\r\n                        // Also, there is no need to concatenate columns unless there is actually more than one column\r\n                        if (areValuesCountsEqual &&\r\n                            categoriesForTargetRole.length >= 2) {\r\n                            result = {\r\n                                roleName: targetRoleName,\r\n                                categories: categoriesForTargetRole\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n        \r\n        /**\r\n         * Returns the array of role names that are mapped to categorical categories.\r\n         * Returns an empty array if none exists.\r\n         */\r\n        function getAllRolesInCategories(categoricalRoleMapping: DataViewCategoricalMapping): string[] {\r\n            debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');\r\n\r\n            let roleNames: string[] = [];\r\n            DataViewMapping.visitCategoricalCategories(\r\n                categoricalRoleMapping.categories,\r\n                {\r\n                    visitRole: (roleName: string) => {\r\n                        roleNames.push(roleName);\r\n                    }\r\n                });\r\n\r\n            return roleNames;\r\n        }\r\n\r\n        function applyConcatenation(dataView: DataView, objectDescriptors: DataViewObjectDescriptors, roleName: string, columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let formatStringPropId: DataViewObjectPropertyIdentifier = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            let concatenatedValues: string[] = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);\r\n\r\n            let columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, categoryColumn => categoryColumn.source);\r\n            let concatenatedColumnMetadata: DataViewMetadataColumn = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);\r\n            let transformedDataView = inheritSingle(dataView);\r\n            addToMetadata(transformedDataView, concatenatedColumnMetadata);\r\n\r\n            let concatenatedCategoryColumn: DataViewCategoryColumn = createConcatenatedCategoryColumn(\r\n                columnsSortedByProjectionOrdering,\r\n                concatenatedColumnMetadata,\r\n                concatenatedValues);\r\n\r\n            let dataViewCategorical: DataViewCategorical = dataView.categorical;\r\n\r\n            let transformedCategoricalCategories: DataViewCategoryColumn[] = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);\r\n            transformedCategoricalCategories.push(concatenatedCategoryColumn);\r\n\r\n            let transformedCategorical: DataViewCategorical = inheritSingle(dataViewCategorical);\r\n            transformedCategorical.categories = transformedCategoricalCategories;\r\n            transformedDataView.categorical = transformedCategorical;\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        function concatenateValues(columnsSortedByProjectionOrdering: DataViewCategoryColumn[], queryRefsToIgnore: string[], formatStringPropId: DataViewObjectPropertyIdentifier): string[] {\r\n            debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');\r\n            debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');\r\n            debug.assertAnyValue(formatStringPropId, 'formatStringPropId');\r\n\r\n            let concatenatedValues: string[] = [];\r\n\r\n            // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]\r\n            for (let categoryColumn of columnsSortedByProjectionOrdering) {\r\n                let formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);\r\n\r\n                for (let i = 0, len = categoryColumn.values.length; i < len; i++) {\r\n                    if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {\r\n                        let value = categoryColumn.values && categoryColumn.values[i];\r\n                        let formattedValue = valueFormatter.format(value, formatString);\r\n                        concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return concatenatedValues;\r\n        }\r\n\r\n        /**\r\n        * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.\r\n        */\r\n        function sortColumnsByProjectionOrdering(projectionOrdering: DataViewProjectionOrdering, roleName: string, columns: DataViewCategoryColumn[]): DataViewCategoryColumn[] {\r\n            debug.assertAnyValue(projectionOrdering, 'projectionOrdering');\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            let columnsInProjectionOrdering: DataViewCategoryColumn[];\r\n\r\n            if (projectionOrdering) {\r\n                // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn\r\n                let columnsByIndex: { [index: number]: DataViewCategoricalColumn } = {};\r\n                for (let column of columns) {\r\n                    if (column.source.roles[roleName]) {\r\n                        debug.assert(!columnsByIndex[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);\r\n                        columnsByIndex[column.source.index] = column;\r\n                    }\r\n                }\r\n\r\n                let columnIndicesInProjectionOrdering: number[] = projectionOrdering[roleName];\r\n\r\n                columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)\r\n                    .map(columnIndex => columnsByIndex[columnIndex])\r\n                    .filter((column: DataViewCategoricalColumn) => !!column)\r\n                    .value();\r\n            }\r\n            else {\r\n                // If projectionOrder is unspecified, just return the columns for the specified role in their current order\r\n                columnsInProjectionOrdering = _.filter(columns, column => column.source.roles[roleName]);\r\n            }\r\n\r\n            return columnsInProjectionOrdering;\r\n        }\r\n\r\n        /**\r\n         * Creates the column metadata that will back the column with the concatenated values. \r\n         */\r\n        function createConcatenatedColumnMetadata(roleName: string, sourceColumnsSortedByProjectionOrdering: DataViewMetadataColumn[], queryRefsToIgnore?: string[]): DataViewMetadataColumn {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');\r\n            debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(c => c.isMeasure).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');\r\n\r\n            let concatenatedDisplayName: string;\r\n\r\n            for (let columnSource of sourceColumnsSortedByProjectionOrdering) {\r\n                if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {\r\n                    concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);\r\n                }\r\n            }\r\n\r\n            let newRoles: { [name: string]: boolean } = {};\r\n            newRoles[roleName] = true;\r\n\r\n            let newColumnMetadata: DataViewMetadataColumn = {\r\n                displayName: concatenatedDisplayName,\r\n                roles: newRoles,\r\n                type: ValueType.fromPrimitiveTypeAndCategory(PrimitiveType.Text)\r\n            };\r\n\r\n            let columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);\r\n            if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {\r\n                newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;\r\n            }\r\n\r\n            // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.\r\n            // If queryName is not set at all, the column chart visual will only render column for the first group instance.\r\n            // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).\r\n            newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;\r\n\r\n            return newColumnMetadata;\r\n        }\r\n\r\n        function addToMetadata(transformedDataView: DataView, newColumn: DataViewMetadataColumn): void {\r\n            debug.assertValue(transformedDataView, 'transformedDataView');\r\n            debug.assertValue(newColumn, 'newColumn');\r\n\r\n            let transformedColumns = inheritSingle(transformedDataView.metadata.columns);\r\n            transformedColumns.push(newColumn);\r\n\r\n            let transformedMetadata = inheritSingle(transformedDataView.metadata);\r\n            transformedMetadata.columns = transformedColumns;\r\n\r\n            transformedDataView.metadata = transformedMetadata;\r\n        }\r\n\r\n        function createConcatenatedCategoryColumn(\r\n            sourceColumnsSortedByProjectionOrdering: DataViewCategoryColumn[],\r\n            columnMetadata: DataViewMetadataColumn,\r\n            concatenatedValues: string[]): DataViewCategoryColumn {\r\n            debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');\r\n\r\n            let newCategoryColumn: DataViewCategoryColumn = {\r\n                source: columnMetadata,\r\n                values: concatenatedValues\r\n            };\r\n\r\n            // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.\r\n            // So, we'll just take the identities and identityFields from the first column\r\n            let firstColumn = sourceColumnsSortedByProjectionOrdering[0];\r\n\r\n            if (firstColumn.identity) {\r\n                newCategoryColumn.identity = firstColumn.identity;\r\n            }\r\n\r\n            if (firstColumn.identityFields) {\r\n                newCategoryColumn.identityFields = firstColumn.identityFields;\r\n            }\r\n\r\n            // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn\r\n            if (firstColumn.objects) {\r\n                newCategoryColumn.objects = firstColumn.objects;\r\n            }\r\n\r\n            return newCategoryColumn;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export const enum RoleItemContext {\r\n        CategoricalValue,\r\n        CategoricalValueGroup,\r\n    }\r\n\r\n    export interface IDataViewMappingVisitor {\r\n        visitRole(role: string, context?: RoleItemContext): void;\r\n        visitReduction?(reductionAlgorithm?: ReductionAlgorithm): void;\r\n    }\r\n\r\n    export module DataViewMapping {\r\n        export function visitMapping(mapping: DataViewMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let categorical = mapping.categorical;\r\n            if (categorical)\r\n                visitCategorical(categorical, visitor);\r\n\r\n            let table = mapping.table;\r\n            if (table)\r\n                visitTable(table, visitor);\r\n\r\n            let matrix = mapping.matrix;\r\n            if (matrix)\r\n                visitMatrix(matrix, visitor);\r\n\r\n            let tree = mapping.tree;\r\n            if (tree)\r\n                visitTree(tree, visitor);\r\n            \r\n            let single = mapping.single;\r\n            if (single)\r\n                visitSingle(single, visitor);\r\n        }\r\n\r\n        export function visitCategorical(mapping: DataViewCategoricalMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitCategoricalCategories(mapping.categories, visitor);\r\n\r\n            visitCategoricalValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitCategoricalCategories(mapping: DataViewRoleMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitCategoricalValues(mapping: DataViewRoleMapping | DataViewGroupedRoleMapping | DataViewListRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitBind(<DataViewRoleBindMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor, RoleItemContext.CategoricalValue);\r\n\r\n                let groupedRoleMapping = <DataViewGroupedRoleMapping>mapping;\r\n                visitGrouped(groupedRoleMapping, visitor);\r\n\r\n                let group = groupedRoleMapping.group;\r\n                if (group) {\r\n                    for (let item of group.select) {\r\n                        visitBind(<DataViewRoleBindMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                        visitFor(<DataViewRoleForMapping>item, visitor, RoleItemContext.CategoricalValueGroup);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitTable(mapping: DataViewTableMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let rows = mapping.rows;\r\n            visitBind(<DataViewRoleBindMapping>rows, visitor);\r\n            visitFor(<DataViewRoleForMapping>rows, visitor);\r\n            visitList(<DataViewListRoleMapping>rows, visitor);\r\n\r\n            visitReduction(rows, visitor);\r\n        }\r\n\r\n        function visitMatrix(mapping: DataViewMatrixMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitMatrixItems(mapping.rows, visitor);\r\n            visitMatrixItems(mapping.columns, visitor);\r\n            visitMatrixItems(mapping.values, visitor);\r\n        }\r\n\r\n        /**\r\n         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         *\r\n         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.\r\n         * @param visitor The visitor.\r\n         */\r\n        export function visitMatrixItems(mapping: DataViewRoleForMappingWithReduction | DataViewListRoleMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(<DataViewRoleForMapping>mapping, visitor);\r\n                visitList(<DataViewListRoleMapping>mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitTree(mapping: DataViewTreeMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitTreeNodes(mapping.nodes, visitor);\r\n            visitTreeValues(mapping.values, visitor);\r\n        }\r\n\r\n        export function visitTreeNodes(mapping: DataViewRoleForMappingWithReduction, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n\r\n                visitReduction(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        export function visitTreeValues(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (mapping) {\r\n                visitFor(mapping, visitor);\r\n            }\r\n        }\r\n\r\n        function visitBind(mapping: DataViewRoleBindMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let bind = mapping.bind;\r\n            if (bind) {\r\n                if (context != null)\r\n                    visitor.visitRole(bind.to, context);\r\n                else\r\n                    visitor.visitRole(bind.to);\r\n            }\r\n        }\r\n\r\n        function visitFor(mapping: DataViewRoleForMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let forValue = mapping.for;\r\n            if (forValue) {\r\n                if (context != null)\r\n                    visitor.visitRole(forValue.in, context);\r\n                else\r\n                    visitor.visitRole(forValue.in);\r\n            }\r\n        }\r\n\r\n        function visitList(mapping: DataViewListRoleMapping, visitor: IDataViewMappingVisitor, context?: RoleItemContext): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let select = mapping.select;\r\n            if (select) {\r\n                for (let item of select) {\r\n                    visitBind(<DataViewRoleBindMapping>item, visitor, context);\r\n                    visitFor(<DataViewRoleForMapping>item, visitor, context);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function visitGrouped(mapping: DataViewGroupedRoleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertAnyValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (!mapping)\r\n                return;\r\n\r\n            let group = mapping.group;\r\n            if (group) {\r\n                visitor.visitRole(group.by);\r\n\r\n                visitReduction(group, visitor);\r\n            }\r\n        }\r\n\r\n        function visitReduction(mapping: HasReductionAlgorithm, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            if (visitor.visitReduction) {\r\n                let reductionAlgorithm = mapping.dataReductionAlgorithm;\r\n                if (reductionAlgorithm) {\r\n                    visitor.visitReduction(reductionAlgorithm);\r\n                }\r\n            }\r\n        }\r\n\r\n        function visitSingle(mapping: DataViewSingleMapping, visitor: IDataViewMappingVisitor): void {\r\n            debug.assertValue(mapping, 'mapping');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            visitor.visitRole(mapping.role);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inheritSingle = Prototype.inheritSingle;\r\n\r\n    export interface DataViewNormalizeValuesApplyOptions {\r\n        dataview: DataView;\r\n        dataViewMappings: DataViewMapping[];\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a column is tied to any role that has required type(s).\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns true iff the column in the specified columnIndex is tied to any role that has required type(s), i.e. if the value in that column potentially needs to get normalized.\r\n     */\r\n    export interface IMetadataColumnFilter {\r\n        (columnIndex: number): boolean;\r\n    }\r\n\r\n    /**\r\n     * Returns true iff the specified value is of matching type as required by the role assigned to the column associated with this filter object.\r\n     */\r\n    export interface IColumnValueFilter {\r\n        (value: any): boolean;\r\n    }\r\n\r\n    /**\r\n     * Interface of a function for deciding whether a value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     *\r\n     * @param columnIndex the position of the column in the select statement, i.e. the same semantic as the index property on the DataViewMetadataColumn interface.\r\n     * @returns false iff the specified value needs to be normalized due to not having a matching type as required by a role tied to the column associated with the specified columnIndex.\r\n     */\r\n    export interface IValueFilter {\r\n        (columnIndex: number, value: any): boolean;\r\n    }\r\n\r\n    export module DataViewNormalizeValues {\r\n        export function apply(options: DataViewNormalizeValuesApplyOptions): void {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let rolesToNormalize = _.filter(options.dataRoles, role => !_.isEmpty(role.requiredTypes));\r\n\r\n            filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);\r\n        }\r\n\r\n        export function filterVariantMeasures(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[]): void {\r\n            debug.assertValue(dataview, 'dataview');\r\n\r\n            // Don't perform this unless we actually have dataViewMappings and variant measures to suppress\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))\r\n                return;\r\n\r\n            let columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);\r\n            let valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);\r\n\r\n            let usedMappings = {};\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                // Get dataview specified in mappings which are also in dataview\r\n                for (let dataViewMappingProp in dataViewMapping) {\r\n                    if (dataview[dataViewMappingProp] != null)\r\n                        usedMappings[dataViewMappingProp] = true;\r\n                }\r\n            }\r\n\r\n            if (usedMappings['categorical'])\r\n                filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);\r\n            if (usedMappings['table'])\r\n                filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);\r\n            if (usedMappings['tree'])\r\n                filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);\r\n            if (usedMappings['matrix'])\r\n                filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);\r\n            if (usedMappings['single'])\r\n                filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);\r\n        }\r\n\r\n        export function generateMetadataColumnFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IMetadataColumnFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => false;\r\n\r\n            let columnsToNormalize = {};\r\n            for (let column of columns) {\r\n                let roles = column.roles;\r\n                if (!roles)\r\n                    continue;\r\n                for (let role of rolesToNormalize) {\r\n                    if (!roles[role.name])\r\n                        continue;\r\n                    columnsToNormalize[column.index] = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return (columnIndex: number) => {\r\n                if (isNaN(columnIndex))\r\n                    return false;\r\n\r\n                return !!columnsToNormalize[columnIndex];\r\n            };\r\n        }\r\n\r\n        export function generateValueFilter(columns: DataViewMetadataColumn[], rolesToNormalize: VisualDataRole[]): IValueFilter {\r\n            if (!columns || !rolesToNormalize)\r\n                return () => true;\r\n\r\n            let columnValueFilters: IColumnValueFilter[] = [];\r\n\r\n            // Build columnValueFilters based on role requiredTypes\r\n            for (let column of columns) {\r\n                let columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);\r\n\r\n                if (columnValueFilter)\r\n                    columnValueFilters[column.index] = columnValueFilter;\r\n            }\r\n\r\n            return <IValueFilter>(columnIndex: number, value: any) => {\r\n                if (columnValueFilters[columnIndex])\r\n                    return columnValueFilters[columnIndex](value);\r\n\r\n                return true;\r\n            };\r\n        }\r\n\r\n        function generateColumnValueFilter(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): IColumnValueFilter {\r\n            let requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);\r\n\r\n            if (_.isEmpty(requiredTypes))\r\n                return;\r\n\r\n            return (value: any): boolean => {\r\n                return doesValueMatchTypes(value, requiredTypes);\r\n            };\r\n        }\r\n\r\n        export function getColumnRequiredTypes(column: DataViewMetadataColumn, rolesToNormalize: VisualDataRole[]): ValueType[] {\r\n            let requiredTypes = [];\r\n            let columnRoles = column && column.roles;\r\n\r\n            if (!columnRoles)\r\n                return requiredTypes;\r\n\r\n            for (let role of rolesToNormalize) {\r\n                if (!columnRoles[role.name])\r\n                    continue;\r\n                for (let typeDescriptor of role.requiredTypes) {\r\n                    let type = ValueType.fromDescriptor(typeDescriptor);\r\n                    requiredTypes.push(type);\r\n                }\r\n            }\r\n\r\n            return requiredTypes;\r\n        }\r\n\r\n        function filterVariantMeasuresCategorical(dataview: DataViewCategorical, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let values = dataview && dataview.values;\r\n            if (!values)\r\n                return;\r\n\r\n            let valuesGrouped = values.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            for (let valueGroup of valuesGrouped) {\r\n                let valuesInGroup = valueGroup.values;\r\n                for (let valueColumn of valuesInGroup) {\r\n                    let columnIndex = valueColumn.source.index;\r\n                    if (!columnFilter(columnIndex))\r\n                        continue;\r\n\r\n                    for (let i = 0, ilen = valueColumn.values.length; i < ilen; i++) {\r\n                        valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTable(dataview: DataViewTable, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let columns = dataview && dataview.columns;\r\n\r\n            if (!columns)\r\n                return;\r\n\r\n            let filteredColumns = [];\r\n            for (let column of columns) {\r\n                if (columnFilter(column.index))\r\n                    filteredColumns.push(column.index);\r\n            }\r\n\r\n            let rows = dataview.rows;\r\n            for (let i = 0, ilen = rows.length; i < ilen; i++) {\r\n                for (let index of filteredColumns) {\r\n                    rows[i] = normalizeVariant(rows[i], index, index, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresTreeNode(node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let columnIndex in node.values) {\r\n                    // In dataView.tree, the keys in node.values correspond to columnIndex of the node value\r\n                    if (columnFilter(<any>columnIndex)) {\r\n                        // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.\r\n                        if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))\r\n                            node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', <any>columnIndex, valueFilter);\r\n                        else // if node.values[columnIndex] is a primitive value\r\n                            node.values = normalizeVariant(node.values, columnIndex, <any>columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresMatrix(dataview: DataViewMatrix, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            let root = dataview && dataview.rows && dataview.rows.root;\r\n\r\n            if (!root)\r\n                return;\r\n\r\n            // Recurse into rows.children\r\n            // e.g. rows.children -> .children -> .children.values\r\n            filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);\r\n        }\r\n\r\n        function filterVariantMeasuresMatrixRecursive(dataviewMatrix: DataViewMatrix, node: DataViewTreeNode, columnFilter: IMetadataColumnFilter, valueFilter: IValueFilter): void {\r\n            if (node.values) {\r\n                for (let id in node.values) {\r\n                    // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.\r\n                    let nodeValue: DataViewMatrixNodeValue = node.values[id];\r\n\r\n                    // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value\r\n                    let valueSourceIndex: number = nodeValue.valueSourceIndex || 0;\r\n\r\n                    // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata\r\n                    let columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;\r\n\r\n                    if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {\r\n                        node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);\r\n                    }\r\n                }\r\n            }\r\n            else if (node.children) {\r\n                for (let child of node.children) {\r\n                    filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);\r\n                }\r\n            }\r\n        }\r\n\r\n        function filterVariantMeasuresSingle(dataview: DataView, dataViewMappings: DataViewMapping[], rolesToNormalize: VisualDataRole[], valueFilter: IValueFilter): void {\r\n            if (!dataview.single)\r\n                return;\r\n\r\n            let roleNames: string[] = [];\r\n            for (let role of rolesToNormalize) {\r\n                if (role.name)\r\n                    roleNames.push(role.name);\r\n            }\r\n\r\n            let columns = dataview.metadata.columns;\r\n            for (let dataViewMapping of dataViewMappings) {\r\n                let roleName = dataViewMapping.single.role;\r\n                if (roleNames.indexOf(roleName) !== -1) {\r\n                    let column = firstColumnByRoleName(columns, roleName);\r\n                    if (column)\r\n                        dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        export function normalizeVariant<T>(object: T, key: string|number, columnIndex: number, valueFilter: IValueFilter): T {\r\n            if (!object)\r\n                return;\r\n\r\n            let value = object[key];\r\n            if (value !== null && !valueFilter(columnIndex, value)) {\r\n                object = inheritSingle(object);\r\n                object[key] = null;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        function doesValueMatchTypes<T>(value: T, types: ValueType[]): boolean {\r\n            for (let type of types) {\r\n                if (type.numeric || type.integer)\r\n                    return typeof (value) === 'number';\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function firstColumnByRoleName(columns: DataViewMetadataColumn[], roleName: string): DataViewMetadataColumn {\r\n            for (let column of columns) {\r\n                let columnRoles = column && column.roles;\r\n                if (columnRoles && columnRoles[roleName])\r\n                    return column;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewObjects {\r\n        /** Gets the value of the given object/property pair. */\r\n        export function getValue<T>(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultValue?: T): T {\r\n            debug.assertAnyValue(objects, 'objects');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            if (!objects)\r\n                return defaultValue;\r\n\r\n            let objectOrMap = objects[propertyId.objectName];\r\n            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');\r\n\r\n            let object = <DataViewObject>objectOrMap;\r\n            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);\r\n        }\r\n\r\n        /** Gets an object from objects. */\r\n        export function getObject(objects: DataViewObjects, objectName: string, defaultValue?: DataViewObject): DataViewObject {\r\n            if (objects && objects[objectName]) {\r\n                let object = <DataViewObject>objects[objectName];\r\n                debug.assert(!isUserDefined(object), 'expected DataViewObject');\r\n                return object;\r\n            }\r\n            else {\r\n                return defaultValue;\r\n            }\r\n        }\r\n\r\n        /** Gets a map of user-defined objects. */\r\n        export function getUserDefinedObjects(objects: DataViewObjects, objectName: string): DataViewObjectMap {\r\n            if (objects && objects[objectName]) {\r\n                let map = <DataViewObjectMap>objects[objectName];\r\n                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');\r\n                return map;\r\n            }\r\n        }\r\n\r\n        /** Gets the solid color from a fill property. */\r\n        export function getFillColor(objects: DataViewObjects, propertyId: DataViewObjectPropertyIdentifier, defaultColor?: string): string {\r\n            let value: Fill = getValue(objects, propertyId);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n\r\n        /** Returns true if the given object represents a collection of user-defined objects */\r\n        export function isUserDefined(objectOrMap: DataViewObject | DataViewObjectMap): boolean {\r\n            return _.isArray(objectOrMap);\r\n        }\r\n    }\r\n\r\n    export module DataViewObject {\r\n        export function getValue<T>(object: DataViewObject, propertyName: string, defaultValue?: T): T {\r\n            debug.assertAnyValue(object, 'object');\r\n            debug.assertValue(propertyName, 'propertyName');\r\n\r\n            if (!object)\r\n                return defaultValue;\r\n\r\n            let propertyValue = <T>object[propertyName];\r\n            if (propertyValue === undefined)\r\n                return defaultValue;\r\n\r\n            return propertyValue;\r\n        }\r\n\r\n        /** Gets the solid color from a fill property using only a propertyName */\r\n        export function getFillColorByPropertyName(objects: DataViewObjects, propertyName: string, defaultColor?: string): string {\r\n            let value: Fill = DataViewObject.getValue(objects, propertyName);\r\n            if (!value || !value.solid)\r\n                return defaultColor;\r\n\r\n            return value.solid.color;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import JsonComparer = jsCommon.JsonComparer;\r\n\r\n    /** Defines the values for particular objects. */\r\n    export interface DataViewObjectDefinitions {\r\n        [objectName: string]: DataViewObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinition {\r\n        selector?: Selector;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export interface DataViewObjectPropertyDefinitions {\r\n        [name: string]: DataViewObjectPropertyDefinition;\r\n    }\r\n\r\n    export type DataViewObjectPropertyDefinition = SQExpr | StructuralObjectDefinition;\r\n\r\n    export module DataViewObjectDefinitions {\r\n\r\n        /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */\r\n        export function ensure(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                defns[objectName] = defnsForObject = [];\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n\r\n            let newDefn: DataViewObjectDefinition = {\r\n                selector: selector,\r\n                properties: {},\r\n            };\r\n            defnsForObject.push(newDefn);\r\n\r\n            return newDefn;\r\n        }\r\n\r\n        export function deleteProperty(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector,\r\n            propertyName: string): void {\r\n            debug.assertValue(defns, 'defns');\r\n\r\n            let defn = getObjectDefinition(defns, objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);\r\n        }\r\n        \r\n        export function setValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n            debug.assertValue(defns, 'defns');\r\n            debug.assertValue(propertyId, 'propertyId');\r\n\r\n            ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        export function getValue(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinition {\r\n\r\n            let properties = getPropertyContainer(defns, propertyId, selector);\r\n            if (!properties)\r\n                return;\r\n\r\n            return properties[propertyId.propertyName];\r\n        }\r\n\r\n        export function getPropertyContainer(\r\n            defns: DataViewObjectDefinitions,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector): DataViewObjectPropertyDefinitions {\r\n\r\n            let defn = getObjectDefinition(defns, propertyId.objectName, selector);\r\n            if (!defn)\r\n                return;\r\n\r\n            return defn.properties;\r\n        }\r\n\r\n        export function getObjectDefinition(\r\n            defns: DataViewObjectDefinitions,\r\n            objectName: string,\r\n            selector: Selector): DataViewObjectDefinition {\r\n            debug.assertAnyValue(defns, 'defns');\r\n            debug.assertValue(objectName, 'objectName');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!defns)\r\n                return;\r\n\r\n            let defnsForObject = defns[objectName];\r\n            if (!defnsForObject)\r\n                return;\r\n\r\n            for (let i = 0, len = defnsForObject.length; i < len; i++) {\r\n                let defn = defnsForObject[i];\r\n                if (Selector.equals(defn.selector, selector))\r\n                    return defn;\r\n            }\r\n        }\r\n\r\n        export function propertiesAreEqual(a: DataViewObjectPropertyDefinition, b: DataViewObjectPropertyDefinition): boolean {\r\n            if (a instanceof SemanticFilter && b instanceof SemanticFilter) {\r\n                return SemanticFilter.isSameFilter(<SemanticFilter>a, <SemanticFilter>b);\r\n            }\r\n\r\n            return JsonComparer.equals(a, b);\r\n        }\r\n\r\n        export function allPropertiesAreEqual(a: DataViewObjectPropertyDefinitions, b: DataViewObjectPropertyDefinitions): boolean {\r\n            debug.assertValue(a, 'a');\r\n            debug.assertValue(b, 'b');\r\n\r\n            if (Object.keys(a).length !== Object.keys(b).length)\r\n                return false;\r\n\r\n            for (let property in a) {\r\n                if (!propertiesAreEqual(a[property], b[property]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        export function encodePropertyValue(value: DataViewPropertyValue, valueTypeDescriptor: ValueTypeDescriptor): DataViewObjectPropertyDefinition {\r\n            debug.assertAnyValue(value, 'value');\r\n            debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');\r\n\r\n            if (valueTypeDescriptor.bool) {\r\n                if (typeof (value) !== 'boolean')\r\n                    value = false; // This is fallback, which doesn't really belong here.\r\n\r\n                return SQExprBuilder.boolean(<boolean>value);\r\n            }\r\n            else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {\r\n                return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.numeric) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).fill) {\r\n                if (value) {\r\n                    return {\r\n                        solid: { color: SQExprBuilder.text(<string>value) }\r\n                    };\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.formatting) {\r\n                if (valueTypeDescriptor.formatting.labelDisplayUnits) {\r\n                    return SQExprBuilder.double(+value);\r\n                }\r\n                else {\r\n                    return SQExprBuilder.text(<string>value);\r\n                }\r\n            }\r\n            else if (valueTypeDescriptor.enumeration) {\r\n                if ($.isNumeric(value))\r\n                    return SQExprBuilder.double(+value);\r\n                else\r\n                    return SQExprBuilder.text(<string>value);\r\n            }\r\n            else if (valueTypeDescriptor.misc) {\r\n                if (value) {\r\n                    value = SQExprBuilder.text(<string>value);\r\n                } else {\r\n                    value = null;\r\n                }\r\n            }\r\n            else if ((<StructuralTypeDescriptor>valueTypeDescriptor).image) {\r\n                if (value) {\r\n                    let imageValue = <ImageValue>value;\r\n                    let imageDefinition: ImageDefinition = {\r\n                        name: SQExprBuilder.text(imageValue.name),\r\n                        url: SQExprBuilder.text(imageValue.url),\r\n                    };\r\n\r\n                    if (imageValue.scaling)\r\n                        imageDefinition.scaling = SQExprBuilder.text(imageValue.scaling);\r\n\r\n                    return imageDefinition;\r\n                }\r\n            }\r\n\r\n            return value;\r\n        }\r\n\r\n        export function clone(original: DataViewObjectDefinitions): DataViewObjectDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            let cloned: DataViewObjectDefinitions = {};\r\n\r\n            for (let objectName in original) {\r\n                let originalDefns = original[objectName];\r\n                if (_.isEmpty(originalDefns))\r\n                    continue;\r\n\r\n                let clonedDefns: DataViewObjectDefinition[] = [];\r\n                for (let originalDefn of originalDefns) {\r\n                    clonedDefns.push({\r\n                        properties: cloneProperties(originalDefn.properties),\r\n                        selector: originalDefn.selector,\r\n                    });\r\n                }\r\n                cloned[objectName] = clonedDefns;\r\n            }\r\n\r\n            return cloned;\r\n        }\r\n\r\n        function cloneProperties(original: DataViewObjectPropertyDefinitions): DataViewObjectPropertyDefinitions {\r\n            debug.assertValue(original, 'original');\r\n\r\n            // NOTE: properties are considered atomic, so a shallow clone is appropriate here.\r\n            return _.clone(original);\r\n        }\r\n    }\r\n\r\n    export module DataViewObjectDefinition {\r\n\r\n        export function deleteSingleProperty(\r\n            defn: DataViewObjectDefinition,\r\n            propertyName: string): void {\r\n\r\n            //note: We decided that delete is acceptable here and that we don't need optimization here\r\n            delete defn.properties[propertyName];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module DataViewObjectDescriptors {\r\n        /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */\r\n        export function findFormatString(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let formattingTypeDesc = ValueType.fromDescriptor(propDesc.type).formatting;\r\n                    return formattingTypeDesc && formattingTypeDesc.formatString;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */\r\n        export function findFilterOutput(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.filter;\r\n                });\r\n        }\r\n\r\n        /** Attempts to find the default value property.  This can be useful for propagating schema default value. */\r\n        export function findDefaultValue(descriptors: DataViewObjectDescriptors): DataViewObjectPropertyIdentifier {\r\n            return findProperty(\r\n                descriptors,\r\n                (propDesc: DataViewObjectPropertyDescriptor) => {\r\n                    let propType: StructuralTypeDescriptor = propDesc.type;\r\n                    return propType && !!propType.expression && propType.expression.defaultValue;\r\n                });\r\n        }\r\n\r\n        function findProperty(descriptors: DataViewObjectDescriptors, propPredicate: (propDesc: DataViewObjectPropertyDescriptor) => boolean): DataViewObjectPropertyIdentifier {\r\n            debug.assertAnyValue(descriptors, 'descriptors');\r\n            debug.assertAnyValue(propPredicate, 'propPredicate');\r\n\r\n            if (!descriptors)\r\n                return;\r\n\r\n            for (let objectName in descriptors) {\r\n                let objPropDescs = descriptors[objectName].properties;\r\n\r\n                for (let propertyName in objPropDescs) {\r\n                    if (propPredicate(objPropDescs[propertyName])) {\r\n                        return {\r\n                            objectName: objectName,\r\n                            propertyName: propertyName,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n*  Power BI Visualizations\r\n*\r\n*  Copyright (c) Microsoft Corporation\r\n*  All rights reserved. \r\n *  MIT License\r\n*\r\n*  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n*  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n*  in the Software without restriction, including without limitation the rights\r\n*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n*  copies of the Software, and to permit persons to whom the Software is\r\n*  furnished to do so, subject to the following conditions:\r\n*   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n*   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n*  THE SOFTWARE.\r\n*/\r\n\r\nmodule powerbi.data {\r\n    export interface DataViewObjectDefinitionsByRepetition {\r\n        metadataOnce?: DataViewObjectDefinitionsForSelector;\r\n        userDefined?: DataViewObjectDefinitionsForSelector[];\r\n        metadata?: DataViewObjectDefinitionsForSelector[];\r\n        data: DataViewObjectDefinitionsForSelectorWithRule[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelector {\r\n        selector?: Selector;\r\n        objects: DataViewNamedObjectDefinition[];\r\n    }\r\n\r\n    export interface DataViewObjectDefinitionsForSelectorWithRule extends DataViewObjectDefinitionsForSelector {\r\n        rules?: RuleEvaluation[];\r\n    }\r\n\r\n    export interface DataViewNamedObjectDefinition {\r\n        name: string;\r\n        properties: DataViewObjectPropertyDefinitions;\r\n    }\r\n\r\n    export module DataViewObjectEvaluationUtils {\r\n        export function evaluateDataViewObjects(\r\n            evalContext: IEvalContext,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewObjects {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let objects: DataViewObjects;\r\n\r\n            for (let j = 0, jlen = objectDefns.length; j < jlen; j++) {\r\n                let objectDefinition = objectDefns[j],\r\n                    objectName = objectDefinition.name;\r\n\r\n                let evaluatedObject: DataViewObject = DataViewObjectEvaluator.run(\r\n                    evalContext,\r\n                    objectDescriptors[objectName],\r\n                    objectDefinition.properties);\r\n\r\n                if (!evaluatedObject)\r\n                    continue;\r\n\r\n                if (!objects)\r\n                    objects = {};\r\n\r\n                // NOTE: this currently has last-object-wins semantics.\r\n                objects[objectName] = evaluatedObject;\r\n            }\r\n\r\n            return objects;\r\n        }\r\n\r\n        export function groupObjectsBySelector(objectDefinitions: DataViewObjectDefinitions): DataViewObjectDefinitionsByRepetition {\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n\r\n            let grouped: DataViewObjectDefinitionsByRepetition = {\r\n                data: [],\r\n            };\r\n\r\n            if (objectDefinitions) {\r\n                for (let objectName in objectDefinitions) {\r\n                    let objectDefnList = objectDefinitions[objectName];\r\n\r\n                    for (let i = 0, len = objectDefnList.length; i < len; i++) {\r\n                        let objectDefn = objectDefnList[i];\r\n\r\n                        ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({\r\n                            name: objectName,\r\n                            properties: objectDefn.properties,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return grouped;\r\n        }\r\n\r\n        function ensureDefinitionListForSelector(grouped: DataViewObjectDefinitionsByRepetition, selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(grouped, 'grouped');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            if (!selector) {\r\n                if (!grouped.metadataOnce)\r\n                    grouped.metadataOnce = { objects: [] };\r\n                return grouped.metadataOnce;\r\n            }\r\n\r\n            let groupedObjects: DataViewObjectDefinitionsForSelector[];\r\n            if (selector.data) {\r\n                groupedObjects = grouped.data;\r\n            }\r\n            else if (selector.metadata) {\r\n                if (!grouped.metadata)\r\n                    grouped.metadata = [];\r\n                groupedObjects = grouped.metadata;\r\n            }\r\n            else if (selector.id) {\r\n                if (!grouped.userDefined)\r\n                    grouped.userDefined = [];\r\n                groupedObjects = grouped.userDefined;\r\n            }\r\n\r\n            debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');\r\n\r\n            for (let item of groupedObjects) {\r\n                if (Selector.equals(selector, item.selector))\r\n                    return item;\r\n            }\r\n\r\n            let item: DataViewObjectDefinitionsForSelector = {\r\n                selector: selector,\r\n                objects: [],\r\n            };\r\n            groupedObjects.push(item);\r\n\r\n            return item;\r\n        }\r\n\r\n        export function addImplicitObjects(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            if (selectTransforms) {\r\n                addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n                addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);\r\n            }\r\n        }\r\n\r\n        function addDefaultFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let formatStringProp = DataViewObjectDescriptors.findFormatString(objectDescriptors);\r\n            if (!formatStringProp)\r\n                return;\r\n\r\n            for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n                let selectTransform = selectTransforms[selectIdx];\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyFormatString(\r\n                    objectsForAllSelectors,\r\n                    formatStringProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.format || getColumnFormatForIndex(columns, selectIdx));\r\n            }\r\n        }\r\n\r\n        /** Registers properties for default value, if the properties are not explicitly provided. */\r\n        function addDefaultValue (\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            columns: DataViewMetadataColumn[],\r\n            selectTransforms: DataViewSelectTransform[]): void {\r\n            debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            let defaultValueProp = DataViewObjectDescriptors.findDefaultValue(objectDescriptors);\r\n            if (!defaultValueProp)\r\n                return;\r\n\r\n            for (let selectTransform of selectTransforms) {\r\n                if (!selectTransform)\r\n                    continue;\r\n                debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');\r\n\r\n                applyDefaultValue(\r\n                    objectsForAllSelectors,\r\n                    defaultValueProp,\r\n                    selectTransform.queryName,\r\n                    selectTransform.defaultValue);\r\n            }\r\n        }\r\n\r\n        function getColumnFormatForIndex(columns: DataViewMetadataColumn[], selectIdx: number): string {\r\n            for (let columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {\r\n                let column = columns[columnIdx];\r\n                if (!column || column.index !== selectIdx)\r\n                    continue;\r\n\r\n                return column.format;\r\n            }\r\n        }\r\n\r\n        function applyFormatString(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            formatStringProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            formatStringValue: string): void {\r\n            if (!formatStringValue)\r\n                return;\r\n\r\n            // There is a format string specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                formatStringProp,\r\n                { metadata: queryName },\r\n                SQExprBuilder.text(formatStringValue));\r\n        }\r\n\r\n        function applyDefaultValue(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            defaultValueProp: DataViewObjectPropertyIdentifier,\r\n            queryName: string,\r\n            defaultValue: DefaultValueDefinition): void {\r\n            if (!defaultValue)\r\n                return;\r\n\r\n            // There is a default value specified -- apply it as an object property, if there is not already one specified.\r\n            applyMetadataProperty(\r\n                objectsForAllSelectors,\r\n                defaultValueProp,\r\n                { metadata: queryName },\r\n                defaultValue);\r\n        }\r\n\r\n        function applyMetadataProperty(\r\n            objectsForAllSelectors: DataViewObjectDefinitionsByRepetition,\r\n            propertyId: DataViewObjectPropertyIdentifier,\r\n            selector: Selector,\r\n            value: DataViewObjectPropertyDefinition): void {\r\n\r\n            let objectDefns: DataViewObjectDefinitionsForSelector[];\r\n            if (selector) {\r\n                let metadataObjects = objectsForAllSelectors.metadata;\r\n                if (!metadataObjects)\r\n                    metadataObjects = objectsForAllSelectors.metadata = [];\r\n                objectDefns = metadataObjects;\r\n            }\r\n            else {\r\n                let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n                if (!metadataOnce)\r\n                    metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };\r\n                objectDefns = [metadataOnce];\r\n            }\r\n\r\n            let targetMetadataObject = findWithMatchingSelector(objectDefns, selector);\r\n            let targetObjectDefn: DataViewNamedObjectDefinition;\r\n            if (targetMetadataObject) {\r\n                let targetObjectDefns = targetMetadataObject.objects;\r\n                targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);\r\n                if (targetObjectDefn) {\r\n                    if (targetObjectDefn.properties[propertyId.propertyName])\r\n                        return;\r\n                }\r\n                else {\r\n                    targetObjectDefn = {\r\n                        name: propertyId.objectName,\r\n                        properties: {},\r\n                    };\r\n                    targetObjectDefns.push(targetObjectDefn);\r\n                }\r\n            }\r\n            else {\r\n                targetObjectDefn = {\r\n                    name: propertyId.objectName,\r\n                    properties: {}\r\n                };\r\n\r\n                objectDefns.push({\r\n                    selector: selector,\r\n                    objects: [targetObjectDefn],\r\n                });\r\n            }\r\n\r\n            targetObjectDefn.properties[propertyId.propertyName] = value;\r\n        }\r\n\r\n        function findWithMatchingSelector(objects: DataViewObjectDefinitionsForSelector[], selector: Selector): DataViewObjectDefinitionsForSelector {\r\n            debug.assertValue(objects, 'objects');\r\n            debug.assertAnyValue(selector, 'selector');\r\n\r\n            for (let i = 0, len = objects.length; i < len; i++) {\r\n                let object = objects[i];\r\n                if (Selector.equals(object.selector, selector))\r\n                    return object;\r\n            }\r\n        }\r\n\r\n        function findExistingObject(objectDefns: DataViewNamedObjectDefinition[], objectName: string): DataViewNamedObjectDefinition {\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(objectName, 'objectName');\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefn = objectDefns[i];\r\n\r\n                if (objectDefn.name === objectName)\r\n                    return objectDefn;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n \r\n\r\nmodule powerbi.data {\r\n    /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */\r\n    export module DataViewObjectEvaluator {\r\n        const colorValueType: ValueType = ValueType.fromDescriptor({ formatting: { color: true } });\r\n        const numericType: ValueType = ValueType.fromDescriptor({ numeric: true });\r\n        const textType: ValueType = ValueType.fromDescriptor({ text: true });\r\n\r\n        export function run(\r\n            evalContext: IEvalContext,\r\n            objectDescriptor: DataViewObjectDescriptor,\r\n            propertyDefinitions: DataViewObjectPropertyDefinitions): DataViewObject {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(objectDescriptor, 'objectDescriptor');\r\n            debug.assertValue(propertyDefinitions, 'propertyDefinitions');\r\n\r\n            if (!objectDescriptor)\r\n                return;\r\n\r\n            let object: DataViewObject,\r\n                propertyDescriptors = objectDescriptor.properties;\r\n            for (let propertyName in propertyDefinitions) {\r\n                let propertyDefinition = propertyDefinitions[propertyName],\r\n                    propertyDescriptor = propertyDescriptors[propertyName];\r\n\r\n                if (!propertyDescriptor)\r\n                    continue;\r\n\r\n                let propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);\r\n                if (propertyValue === undefined)\r\n                    continue;\r\n\r\n                if (!object)\r\n                    object = {};\r\n                object[propertyName] = propertyValue;\r\n            }\r\n\r\n            return object;\r\n        }\r\n\r\n        /** Note: Exported for testability */\r\n        export function evaluateProperty(\r\n            evalContext: IEvalContext,\r\n            propertyDescriptor: DataViewObjectPropertyDescriptor,\r\n            propertyDefinition: DataViewObjectPropertyDefinition): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(propertyDescriptor, 'propertyDescriptor');\r\n            debug.assertValue(propertyDefinition, 'propertyDefinition');\r\n\r\n            let structuralType = <StructuralTypeDescriptor>propertyDescriptor.type;\r\n            if (structuralType && structuralType.expression)\r\n                return propertyDefinition;\r\n\r\n            let value = evaluateValue(evalContext, <any>propertyDefinition, ValueType.fromDescriptor(propertyDescriptor.type));\r\n            if (value !== undefined || (propertyDefinition instanceof RuleEvaluation))\r\n                return value;\r\n\r\n            return evaluateFill(evalContext, <FillDefinition>propertyDefinition, structuralType)\r\n                || evaluateFillRule(evalContext, <FillRuleDefinition>propertyDefinition, structuralType)\r\n                || evaluateImage(evalContext, <ImageDefinition>propertyDefinition, structuralType)\r\n                || evaluateParagraphs(evalContext, <ParagraphsDefinition>propertyDefinition, structuralType)\r\n                || propertyDefinition;\r\n        }\r\n\r\n        function evaluateFill(evalContext: IEvalContext, fillDefn: FillDefinition, type: StructuralTypeDescriptor): Fill {\r\n            let fillType = type.fill;\r\n            if (!fillType)\r\n                return;\r\n\r\n            if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {\r\n                return {\r\n                    solid: {\r\n                        color: evaluateValue(evalContext, fillDefn.solid.color, ValueType.fromExtendedType(ExtendedType.Color)),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateFillRule(evalContext: IEvalContext, fillRuleDefn: FillRuleDefinition, type: StructuralTypeDescriptor): FillRule {\r\n            if (!type.fillRule)\r\n                return;\r\n\r\n            if (fillRuleDefn.linearGradient2) {\r\n                let linearGradient2 = fillRuleDefn.linearGradient2;\r\n                return {\r\n                    linearGradient2: {\r\n                        min: evaluateColorStop(evalContext, linearGradient2.min),\r\n                        max: evaluateColorStop(evalContext, linearGradient2.max),\r\n                    }\r\n                };\r\n            }\r\n\r\n            if (fillRuleDefn.linearGradient3) {\r\n                let linearGradient3 = fillRuleDefn.linearGradient3;\r\n                return {\r\n                    linearGradient3: {\r\n                        min: evaluateColorStop(evalContext, linearGradient3.min),\r\n                        mid: evaluateColorStop(evalContext, linearGradient3.mid),\r\n                        max: evaluateColorStop(evalContext, linearGradient3.max),\r\n                    }\r\n                };\r\n            }\r\n        }\r\n\r\n        function evaluateColorStop(evalContext: IEvalContext, colorStop: RuleColorStopDefinition): RuleColorStop {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(colorStop, 'colorStop');\r\n\r\n            let step: RuleColorStop = {\r\n                color: evaluateValue(evalContext, colorStop.color, colorValueType),\r\n            };\r\n\r\n            let value = evaluateValue(evalContext, colorStop.value, numericType);\r\n            if (value != null)\r\n                step.value = value;\r\n\r\n            return step;\r\n        }\r\n\r\n        function evaluateImage(evalContext: IEvalContext, definition: ImageDefinition, type: StructuralTypeDescriptor): ImageValue {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.image || !definition)\r\n                return;\r\n\r\n            let value: ImageValue = {\r\n                name: evaluateValue(evalContext, definition.name, textType),\r\n                url: evaluateValue(evalContext, definition.url, ValueType.fromDescriptor(ImageDefinition.urlType)),\r\n            };\r\n\r\n            if (definition.scaling)\r\n                value.scaling = evaluateValue(evalContext, definition.scaling, textType);\r\n\r\n            return value;\r\n        }\r\n\r\n        function evaluateParagraphs(evalContext: IEvalContext, definition: ParagraphsDefinition, type: StructuralTypeDescriptor): Paragraphs {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertAnyValue(definition, 'definition');\r\n            debug.assertValue(type, 'type');\r\n\r\n            if (!type.paragraphs || !definition)\r\n                return;\r\n\r\n            return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);\r\n        }\r\n\r\n        function evaluateParagraph(evalContext: IEvalContext, definition: ParagraphDefinition): Paragraph {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: Paragraph;\r\n\r\n            let definitionTextRuns = definition.textRuns;\r\n            let evaluatedTextRuns: TextRun[] = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);\r\n            if (definitionTextRuns !== evaluatedTextRuns) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.textRuns = evaluatedTextRuns;\r\n            }\r\n\r\n            return evaluated || <Paragraph>definition;\r\n        }\r\n\r\n        function evaluateTextRun(evalContext: IEvalContext, definition: TextRunDefinition): TextRun {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definition, 'definition');\r\n\r\n            let evaluated: TextRun;\r\n\r\n            let definitionValue = definition.value;\r\n            let evaluatedValue = evaluateValue(evalContext, <any> definitionValue, textType);\r\n            if (evaluatedValue !== undefined) {\r\n                evaluated = _.clone(<any>definition);\r\n                evaluated.value = evaluatedValue;\r\n            }\r\n\r\n            return evaluated || <TextRun>definition;\r\n        }\r\n\r\n        /**\r\n         * Evaluates an array, and lazily copies on write whenever the evaluator function returns something\r\n         * other than the input to it.\r\n         */\r\n        function evaluateArrayCopyOnChange<TDefinition, TEvaluated>(\r\n            evalContext: IEvalContext,\r\n            definitions: TDefinition[],\r\n            evaluator: (ctx: IEvalContext, defn: TDefinition) => TEvaluated): TEvaluated[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(definitions, 'definitions');\r\n            debug.assertValue(evaluator, 'evaluator');\r\n\r\n            let evaluatedValues: TEvaluated[];\r\n\r\n            for (let i = 0, len = definitions.length; i < len; i++) {\r\n                let definition = definitions[i];\r\n                let evaluated: TEvaluated = evaluator(evalContext, definition);\r\n\r\n                // NOTE: the any casts here are necessary due to the compiler not knowing the relationship\r\n                // between TEvaluated & TDefinition\r\n                if (!evaluatedValues && <any>definition !== evaluated) {\r\n                    evaluatedValues = _.take(<TEvaluated[]><any>definitions, i);\r\n                }\r\n\r\n                if (evaluatedValues) {\r\n                    evaluatedValues.push(evaluated);\r\n                }\r\n            }\r\n\r\n            return evaluatedValues || <TEvaluated[]><any>definitions;\r\n        }\r\n\r\n        function evaluateValue(evalContext: IEvalContext, definition: SQExpr | RuleEvaluation, valueType: ValueType): any {\r\n            if (definition instanceof SQExpr)\r\n                return ExpressionEvaluator.evaluate(<SQExpr>definition, evalContext);\r\n\r\n            if (definition instanceof RuleEvaluation)\r\n                return (<RuleEvaluation>definition).evaluate(evalContext);\r\n        }\r\n\r\n        /** Responsible for evaluating SQExprs into values. */\r\n        class ExpressionEvaluator extends DefaultSQExprVisitorWithArg<PrimitiveValue, IEvalContext> {\r\n            private static instance: ExpressionEvaluator = new ExpressionEvaluator();\r\n\r\n            public static evaluate(expr: SQExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                if (expr == null)\r\n                    return;\r\n\r\n                return expr.accept(ExpressionEvaluator.instance, evalContext);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return expr.value;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                return evalContext.getExprValue(expr);\r\n            }\r\n\r\n            public visitFillRule(expr: SQFillRuleExpr, evalContext: IEvalContext): PrimitiveValue {\r\n                let inputValue = expr.input.accept(this, evalContext);\r\n                if (inputValue !== undefined) {\r\n                    let colorAllocator = evalContext.getColorAllocator(expr);\r\n                    if (colorAllocator) {\r\n                        return colorAllocator.color(inputValue);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n} \r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n\r\n    export module DataViewPivotCategorical {\r\n        /**\r\n         * Pivots categories in a categorical DataView into valueGroupings.\r\n         * This is akin to a mathematical matrix transpose.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return null;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return null;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values) || values.source)\r\n                return null;\r\n\r\n            let category = categories[0],\r\n                categoryIdentities = category.identity,\r\n                categoryValues = category.values,\r\n                pivotedColumns: DataViewMetadataColumn[] = [],\r\n                pivotedValues: DataViewValueColumn[] = [];\r\n            for (let rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {\r\n                let categoryValue = categoryValues[rowIdx],\r\n                    categoryIdentity = categoryIdentities[rowIdx];\r\n                for (let colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {\r\n                    let value = values[colIdx],\r\n                        pivotedColumn = inherit(value.source);\r\n\r\n                    // A value has a series group, which is not implemented for pivoting -- just give up.\r\n                    if (value.identity)\r\n                        return null;\r\n\r\n                    pivotedColumn.groupName = categoryValue;\r\n                    let pivotedValue: DataViewValueColumn = {\r\n                        source: pivotedColumn,\r\n                        values: [value.values[rowIdx]],\r\n                        identity: categoryIdentity,\r\n                        min: value.min,\r\n                        max: value.max,\r\n                        subtotal: value.subtotal\r\n                    };\r\n\r\n                    let highlights = value.highlights;\r\n                    if (highlights) {\r\n                        pivotedValue.highlights = [highlights[rowIdx]];\r\n                    }\r\n\r\n                    pivotedColumns.push(pivotedColumn);\r\n                    pivotedValues.push(pivotedValue);\r\n                }\r\n            }\r\n\r\n            let pivotedMetadata = inherit(dataView.metadata);\r\n            pivotedMetadata.columns = pivotedColumns;\r\n\r\n            values = DataViewTransform.createValueColumns(pivotedValues, <SQExpr[]>category.identityFields, category.source);\r\n            return {\r\n                metadata: pivotedMetadata,\r\n                categorical: {\r\n                    values: values,\r\n                },\r\n                matrix: dataView.matrix\r\n            };\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewPivotMatrix {\r\n        /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */\r\n        export function apply(dataViewMatrix: DataViewMatrix, context: MatrixTransformationContext): void {\r\n            debug.assertValue(dataViewMatrix, 'dataViewMatrix');\r\n\r\n            if (!context.columnHierarchyRewritten)\r\n                dataViewMatrix.columns = Prototype.inherit(dataViewMatrix.columns);\r\n            let columns = dataViewMatrix.columns;\r\n\r\n            if (!context.rowHierarchyRewritten)\r\n                dataViewMatrix.rows = Prototype.inherit(dataViewMatrix.rows);\r\n            let rows = dataViewMatrix.rows;\r\n\r\n            if (columns.levels.length > 1)\r\n                return;\r\n\r\n            let pivotedRowNode: DataViewMatrixNode = {\r\n                level: 0\r\n            };\r\n\r\n            let columnLeafNodes: DataViewMatrixNode[] = columns.root.children;\r\n            let measureCount = columnLeafNodes.length;\r\n\r\n            // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.\r\n            // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))\r\n            // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' \r\n            // in a matrix with 2+ column fields and 2+ measure fields.\r\n            // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result\r\n            // is just (1 + the level of the deepest row node's level), which === rows.levels.length.\r\n            let pivotResultMeasureHeaderLevel = rows.levels.length;\r\n\r\n            if (measureCount > 0) {\r\n                let index = 0;\r\n                let callback = function (node: DataViewMatrixNode) {\r\n                    // Collect values and remove them from row leaves\r\n                    if (node.values) {\r\n                        if (!pivotedRowNode.values)\r\n                            pivotedRowNode.values = {};\r\n\r\n                        for (let i = 0; i < measureCount; i++)\r\n                            pivotedRowNode.values[index++] = node.values[i];\r\n\r\n                        delete node.values;\r\n                    }\r\n\r\n                    // Create measure headers if there are more than one measures\r\n                    if (measureCount > 1) {\r\n                        if (!node.children)\r\n                            node.children = [];\r\n\r\n                        for (let j = 0; j < measureCount; j++) {\r\n                            let measureHeaderLeaf: DataViewMatrixNode = { level: pivotResultMeasureHeaderLevel };\r\n\r\n                            // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)\r\n                            let columnLeafNode = columnLeafNodes[j];\r\n                            measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;\r\n\r\n                            if (node.isSubtotal)\r\n                                measureHeaderLeaf.isSubtotal = true;\r\n\r\n                            node.children.push(measureHeaderLeaf);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                if (context.hierarchyTreesRewritten) {\r\n                    forEachLeaf(rows.root, callback);\r\n                }\r\n                else {\r\n                    dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);\r\n                }\r\n            }\r\n            else {\r\n                if (!context.hierarchyTreesRewritten) {\r\n                    dataViewMatrix.columns.root = cloneTree(rows.root);\r\n                }\r\n            }\r\n\r\n            if (measureCount > 1) {\r\n                // Keep measure headers, but move them to the innermost level\r\n                let level: DataViewHierarchyLevel = { sources: columns.levels[0].sources };\r\n                rows.levels.push(level);\r\n\r\n                columns.levels.length = 0;\r\n            }\r\n\r\n            if (context.hierarchyTreesRewritten) {\r\n                dataViewMatrix.columns.root = rows.root;\r\n                dataViewMatrix.rows.root = {\r\n                    children: [pivotedRowNode]\r\n                };\r\n            }\r\n            else {\r\n                let updatedRowRoot = Prototype.inherit(dataViewMatrix.rows.root);\r\n                updatedRowRoot.children = [pivotedRowNode];\r\n                dataViewMatrix.rows.root = updatedRowRoot;\r\n            }\r\n\r\n            dataViewMatrix.columns.levels = rows.levels;\r\n            dataViewMatrix.rows.levels = [];\r\n        }\r\n\r\n        function forEachLeaf(root: DataViewMatrixNode, callback: (node: DataViewMatrixNode) => void): void {\r\n            let children = root.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachLeaf(children[i], callback);\r\n\r\n                return;\r\n            }\r\n\r\n            callback(root);\r\n        }\r\n\r\n        export function cloneTree(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            return cloneTreeExecuteOnLeaf(node);\r\n        }\r\n\r\n        export function cloneTreeExecuteOnLeaf(node: DataViewMatrixNode, callback?: (node: DataViewMatrixNode) => void): DataViewMatrixNode {\r\n            let updatedNode = Prototype.inherit(node);\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                let newChildren: DataViewTreeNode[] = [];\r\n\r\n                for (let i = 0, ilen = children.length; i < ilen; i++) {\r\n                    let updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);\r\n                    newChildren.push(updatedChild);\r\n                }\r\n                updatedNode.children = newChildren;\r\n            }\r\n            else {\r\n                if (callback)\r\n                    callback(updatedNode);\r\n            }\r\n\r\n            return updatedNode;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module DataViewSelfCrossJoin {\r\n        /**\r\n         * Returns a new DataView based on the original, with a single DataViewCategorical category that is \"cross joined\"\r\n         * to itself as a value grouping.\r\n         * This is the mathematical equivalent of taking an array and turning it into an identity matrix.\r\n         */\r\n        export function apply(dataView: DataView): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            if (!dataView.categorical)\r\n                return;\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)\r\n                return;\r\n            if (dataViewCategorical.values && dataViewCategorical.values.source)\r\n                return;\r\n\r\n            return applyCategorical(dataView.metadata, dataViewCategorical);\r\n        }\r\n\r\n        function applyCategorical(dataViewMetadata: DataViewMetadata, dataViewCategorical: DataViewCategorical): DataView {\r\n            debug.assertValue(dataViewMetadata, 'dataViewMetadata');\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');\r\n\r\n            let category = dataViewCategorical.categories[0],\r\n                categoryValues = category.values,\r\n                categoryLength = categoryValues.length;\r\n\r\n            if (categoryLength === 0)\r\n                return;\r\n\r\n            let valuesArray: DataViewValueColumn[] = dataViewCategorical.values\r\n                ? dataViewCategorical.values.grouped()[0].values\r\n                : [];\r\n            let transformedDataView = createCategoricalDataViewBuilder()\r\n                .withCategories(dataViewCategorical.categories)\r\n                .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))\r\n                .build();\r\n\r\n            dataViewMetadata = Prototype.inherit(dataViewMetadata);\r\n            dataViewMetadata.columns = transformedDataView.metadata.columns;\r\n\r\n            return {\r\n                metadata: dataViewMetadata,\r\n                categorical: transformedDataView.categorical,\r\n            };\r\n        }\r\n\r\n        function createGroupedValues(\r\n            category: DataViewCategoryColumn,\r\n            categoryValues: any[],\r\n            categoryLength: number,\r\n            valuesArray: DataViewValueColumn[]): DataViewBuilderGroupedValuesOptions {\r\n            debug.assertValue(category, 'category');\r\n            debug.assertValue(categoryValues, 'categoryValues');\r\n            debug.assertValue(categoryLength, 'categoryLength');\r\n            debug.assertValue(valuesArray, 'valuesArray');\r\n\r\n            let nullValuesArray: any[] = createNullValues(categoryLength),\r\n                valuesArrayLen = valuesArray.length,\r\n                seriesData: DataViewBuilderSeriesData[][] = [];\r\n\r\n            for (let i = 0; i < categoryLength; i++) {\r\n                let seriesDataItem: DataViewBuilderSeriesData[] = [];\r\n\r\n                for (let j = 0; j < valuesArrayLen; j++) {\r\n                    let originalValueColumn = valuesArray[j],\r\n                        originalHighlightValues = originalValueColumn.highlights;\r\n\r\n                    let seriesDataItemCategory: DataViewBuilderSeriesData = {\r\n                        values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),\r\n                    };\r\n                    if (originalHighlightValues)\r\n                        seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);\r\n\r\n                    seriesDataItem.push(seriesDataItemCategory);\r\n                }\r\n\r\n                seriesData.push(seriesDataItem);\r\n            }\r\n\r\n            return {\r\n                groupColumn: {\r\n                    source: category.source,\r\n                    identityFrom: { fields: <SQExpr[]>category.identityFields, identities: category.identity },\r\n                    values: category.values,\r\n                },\r\n                valueColumns: _.map(valuesArray, v => <DataViewBuilderColumnOptions>{ source: v.source }),\r\n                data: seriesData,\r\n            };\r\n        }\r\n    }\r\n\r\n    function createNullValues(length: number): any[] {\r\n        debug.assertValue(length, 'length');\r\n\r\n        let array = new Array(length);\r\n        for (let i = 0; i < length; i++)\r\n            array[i] = null;\r\n        return array;\r\n    }\r\n\r\n    function inheritArrayWithValue(nullValues: any[], original: any[], index: number): any[] {\r\n        let inherited = Prototype.inherit(nullValues);\r\n        inherited[index] = original[index];\r\n\r\n        return inherited;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;\r\n    import inheritSingle = powerbi.Prototype.inheritSingle;\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export module DataViewPivotCategoricalToPrimaryGroups {\r\n\r\n        /**\r\n         * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to\r\n         * pivot the secondary before the primary.\r\n         */\r\n        export function pivotBinding(binding: DataShapeBinding, allMappings: CompiledDataViewMapping[], finalMapping: CompiledDataViewMapping, defaultDataVolume: number): void {\r\n            // unpivot is inferred from result in DataViewTransform.apply but it does not have the\r\n            // compiled mappings available, let alone the merged mapping, only the original\r\n            // DataViewMappings. to keep that inference easy, only apply pivot when there's\r\n            // only one matching mapping\r\n            if (!allMappings || allMappings.length !== 1)\r\n                return;\r\n\r\n            if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)\r\n                return;\r\n\r\n            if (!binding)\r\n                return;\r\n\r\n            if (!canPivotCategorical(binding, finalMapping))\r\n                return;\r\n\r\n            // pivot secondary onto front of primary\r\n            binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];\r\n\r\n            binding.Secondary = undefined;\r\n        \r\n            // set primary to pivot reduction\r\n            binding.DataReduction = {\r\n                Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),\r\n                DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,\r\n            };\r\n        }\r\n\r\n        /** narrowly targets scatter chart scenario for now to keep code simple */\r\n        function isPivotableAxis(axis: powerbi.data.DataShapeBindingAxis): boolean {\r\n            return axis\r\n                && axis.Groupings\r\n                && axis.Groupings.length === 1\r\n                && !_.isEmpty(axis.Groupings[0].Projections)\r\n                && !axis.Groupings[0].Subtotal\r\n                && _.isEmpty(axis.Groupings[0].SuppressedProjections);\r\n        }\r\n\r\n        function canPivotCategorical(binding: DataShapeBinding, mapping: CompiledDataViewMapping): boolean {\r\n            if (!isPivotableAxis(binding.Primary))\r\n                return false;\r\n            if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)\r\n                return false;\r\n\r\n            // don't pivot if either axis has a data reduction\r\n            if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        export function unpivotResult(oldDataView: DataView, selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], projectionActiveItems: DataViewProjectionActiveItems): DataView {\r\n            if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))\r\n                return oldDataView;\r\n\r\n            // This returns a subsetted version of the DataView rather than using prototypal inheritance because\r\n            // any dataviews in the old one (including ones invented after this code is written) will correspond\r\n            // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the\r\n            // querying code made.\r\n            let newDataView: DataView = {\r\n                metadata: {\r\n                    columns: ArrayExtensions.copy(oldDataView.metadata.columns),\r\n                },\r\n            };\r\n            \r\n            // preserve view types that aren't affected by pivoting\r\n            if (oldDataView.single)\r\n                newDataView.single = oldDataView.single;\r\n            if (oldDataView.table)\r\n                newDataView.table = oldDataView.table;\r\n\r\n            // other views are derived from matrix\r\n            if (oldDataView.matrix) {\r\n                let newDataViewMatrix = unpivotMatrix(oldDataView.matrix);\r\n\r\n                // categorical only if there's data\r\n                if (!_.isEmpty(newDataViewMatrix.valueSources)) {\r\n                    // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is \r\n                    // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.\r\n                    // this.canPivotCategorical() would have returned false in the first place for this query.\r\n                    let hasCompositeGroupInSeries = utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);\r\n                    if (!hasCompositeGroupInSeries) {\r\n                        newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return newDataView;\r\n        }\r\n\r\n        /**\r\n         * Infer from the query result and the visual mappings whether the query was pivoted.\r\n         * Narrowly targets scatter chart scenario for now to keep code simple\r\n         */\r\n        function inferUnpivotTransform(selects: DataViewSelectTransform[], dataViewMappings: DataViewMapping[], dataView: DataView, projectionActiveItems: DataViewProjectionActiveItems): boolean {\r\n            if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)\r\n                return false;\r\n\r\n            // select applicable mappings based on select roles\r\n            let roleKinds: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);\r\n            let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);\r\n            let supportedDataViewMappings = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;\r\n\r\n            // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical\r\n            if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)\r\n                return false;\r\n\r\n            let categoricalMapping = supportedDataViewMappings[0].categorical;\r\n            if (!categoricalMapping)\r\n                return false;\r\n\r\n            // pivoted query will have produced a matrix\r\n            let matrixDataview = dataView.matrix;\r\n            if (!matrixDataview)\r\n                return false;\r\n\r\n            // matrix must have two levels of grouping\r\n            if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)\r\n                return false;\r\n            \r\n            // get category and value grouping roles\r\n            let categoryGroups: string[] = [];\r\n            let valueGroups: string[] = [];\r\n\r\n            let addGroupingRole = (roleName: string, groups: string[]) => {\r\n                let roleProjections: QueryProjectionCollection = projections[roleName];\r\n                if (!roleProjections)\r\n                    return;\r\n\r\n                for (let roleProjection of roleProjections.all()) {\r\n                    if (roleKinds[roleProjection.queryRef] === VisualDataRoleKind.Grouping)\r\n                        groups.push(roleProjection.queryRef);\r\n                }\r\n            };\r\n\r\n            DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, categoryGroups); }\r\n            });\r\n\r\n            DataViewMapping.visitCategoricalValues(categoricalMapping.values, {\r\n                visitRole: (roleName: string) => { addGroupingRole(roleName, valueGroups); }\r\n            });\r\n\r\n            // need both for pivot to have been done\r\n            if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))\r\n                return false;\r\n\r\n            // if there was a pivot, there won't be any measures left in the columns\r\n            for (let level of matrixDataview.columns.levels) {\r\n                for (let source of level.sources) {\r\n                    if (!source.isMeasure)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        interface DataViewMatrixNodeValues {\r\n            [id: number]: DataViewMatrixNodeValue;\r\n        }\r\n\r\n        /**\r\n         * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.\r\n         * this function changes that so that the categories become the rows and the series the columns.\r\n         */\r\n        function unpivotMatrix(oldMatrix: DataViewMatrix): DataViewMatrix {\r\n            let oldRows = oldMatrix.rows;\r\n            let oldRoot = oldRows.root;\r\n            let oldChildren = <DataViewMatrixNode[]>oldRoot.children;\r\n\r\n            // series are the outer grouping\r\n            let series: DataViewMatrixNode[] = [];\r\n            let seriesIdLevel = oldRows.levels[0];\r\n            let seriesIdFields = oldRoot.childIdentityFields;\r\n\r\n            // categories are the inner grouping. \r\n            let categoryIndex: _.Dictionary<number> = {};\r\n            let categories: DataViewMatrixNode[] = [];\r\n            let categoryIdLevel = oldRows.levels[1];\r\n            let categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;\r\n\r\n            let measureCount = oldMatrix.valueSources.length;\r\n\r\n            // within each series value, the category list may not be complete so cannot simply use the inner loop index\r\n            // to reference it.\r\n            let findCategory = (identity: DataViewScopeIdentity) => {\r\n                let index = categoryIndex[identity.key];\r\n\r\n                debug.assert(index !== undefined, \"findcat() !== undefined\");\r\n\r\n                return index;\r\n            };\r\n\r\n            // collect series and categories from the row hierarchy\r\n            if (oldChildren) {\r\n                let addCategory = (categoryNode: DataViewMatrixNode) => {\r\n                    let key = categoryNode.identity.key;\r\n                    let index = categoryIndex[key];\r\n                    if (index === undefined) {\r\n                        index = categories.length;\r\n                        categoryIndex[key] = index;\r\n                        categories.push(categoryNode);\r\n                    }\r\n                };\r\n\r\n                for (let seriesNode of oldChildren) {\r\n                    series.push(seriesNode);\r\n\r\n                    for (let categoryNode of <DataViewMatrixNode[]>seriesNode.children) {\r\n                        addCategory(categoryNode);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // extract intersection values from pivoted matrix\r\n            // values will be indexed by categories then series\r\n            let matrixValues: DataViewMatrixNodeValues[][] = new Array<DataViewMatrixNodeValues[]>(categories.length);\r\n            for (let j = 0; j < series.length; ++j) { // outer is series\r\n                let seriesNode = oldChildren[j];\r\n                for (let categoryNode of seriesNode.children) { // inner is categories but maybe a subset\r\n                    let i = findCategory(categoryNode.identity); // must lookup actual category index\r\n\r\n                    if (!matrixValues[i])\r\n                        matrixValues[i] = new Array<DataViewMatrixNodeValues>(series.length);\r\n\r\n                    matrixValues[i][j] = categoryNode.values;\r\n                }\r\n            }\r\n\r\n            // columns of the unpivoted matrix are the series\r\n            let newColumns: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(series, s => {\r\n                        let inheritedNode = inheritSingle(s);\r\n                        inheritedNode.level = 0; // s.level should already be 0, but just in case...\r\n                        inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function\r\n                        inheritedNode.childIdentityFields = undefined;\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: seriesIdFields,\r\n                },\r\n                levels: [\r\n                    seriesIdLevel,\r\n                    \r\n                ],\r\n            };\r\n\r\n            // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns\r\n            if (measureCount > 0) {\r\n                let newColChildren: DataViewMatrixNode[] = _.map(oldMatrix.columns.root.children, (srcnode: DataViewMatrixNode) => {\r\n                    let dstnode: DataViewMatrixNode = { level: 1 };\r\n                    if (srcnode.levelSourceIndex)\r\n                        dstnode.levelSourceIndex = srcnode.levelSourceIndex;\r\n                    return dstnode;\r\n                });\r\n\r\n                for (let i = 0; i < newColumns.root.children.length; ++i)\r\n                    newColumns.root.children[i].children = newColChildren;\r\n\r\n                newColumns.levels.push(oldMatrix.columns.levels[0]);\r\n            }\r\n\r\n            // rows of the unpivoted matrix are the categories\r\n            let newRows: DataViewHierarchy = {\r\n                root: {\r\n                    children: _.map(categories, c => {\r\n                        let inheritedNode = inheritSingle(c);\r\n                        inheritedNode.level = 0;\r\n                        inheritedNode.children = undefined; // c.children should already be undefined, but just in case...\r\n                        inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...\r\n                        return inheritedNode;\r\n                    }),\r\n                    childIdentityFields: categoryIdFields,\r\n                },\r\n                levels: [\r\n                    categoryIdLevel,\r\n                ],\r\n            };\r\n\r\n            // put values into rows\r\n            if (measureCount > 0) {\r\n                for (let i = 0; i < categories.length; ++i) {\r\n                    let row = newRows.root.children[i];\r\n                    let rowValues: DataViewMatrixNodeValues = {};\r\n\r\n                    for (let j = 0; j < series.length; ++j) {\r\n                        let mvalues = matrixValues[i] && matrixValues[i][j];\r\n                        for (let k = 0; k < measureCount; ++k) {\r\n                            let l = j * measureCount + k;\r\n                            rowValues[l] = !mvalues\r\n                                ? ( k === 0 ? { value: null } : { value: null, valueSourceIndex: k } )\r\n                                : mvalues[k];\r\n                        }\r\n                    }\r\n\r\n                    row.values = rowValues;\r\n                }\r\n            }\r\n\r\n            let newMatrix: DataViewMatrix = {\r\n                rows: newRows,\r\n                columns: newColumns,\r\n                valueSources: oldMatrix.valueSources,\r\n            };\r\n\r\n            return newMatrix;\r\n        }\r\n\r\n        /** build a categorical data view from an unpivoted matrix. */\r\n        function categoricalFromUnpivotedMatrix(matrix: DataViewMatrix, columnMetadata: DataViewMetadataColumn[]): DataViewCategorical {\r\n            let seriesCount = matrix.columns.root.children.length;\r\n            let measureMetadata = matrix.valueSources;\r\n            let measureCount = measureMetadata.length;\r\n\r\n            let categories: DataViewCategoryColumn[] = createCategoryColumnsFromUnpivotedMatrix(matrix);\r\n\r\n            // create grouped values\r\n            let groups: DataViewValueColumnGroup[] = [];\r\n            for (let j = 0; j < seriesCount; ++j) {\r\n                let seriesColumn = matrix.columns.root.children[j];\r\n                let group: DataViewValueColumnGroup = {\r\n                    values: [],\r\n                    identity: seriesColumn.identity,\r\n                    name: seriesColumn.value || null,\r\n                };\r\n\r\n                groups.push(group);\r\n\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    let valueColumnMetadataSrc = measureMetadata[k];\r\n                    let valueColumnMetadataDst: DataViewMetadataColumn = <DataViewMetadataColumn>{};\r\n                    for (let key in valueColumnMetadataSrc)\r\n                        valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];\r\n                    valueColumnMetadataDst.groupName = group.name;\r\n\r\n                    columnMetadata.push(valueColumnMetadataDst);\r\n\r\n                    let valueColumn: DataViewValueColumn = {\r\n                        source: valueColumnMetadataDst,\r\n                        values: [],\r\n                        identity: group.identity,\r\n                    };\r\n\r\n                    group.values.push(valueColumn);\r\n\r\n                    // grab measure values in the group from across rows of matrix\r\n                    let index = k + j * measureCount;\r\n\r\n                    for (let categoryNode of matrix.rows.root.children) {\r\n                        let value = categoryNode.values[index].value;\r\n\r\n                        valueColumn.values.push(value);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // and now ungrouped\r\n            let values: DataViewValueColumns = <DataViewValueColumns>[];\r\n            for (let group of groups) {\r\n                for (let k = 0; k < measureCount; ++k) {\r\n                    values.push(group.values[k]);\r\n                }\r\n            }\r\n\r\n            values.grouped = () => groups;\r\n            values.identityFields = matrix.columns.root.childIdentityFields;\r\n            values.source = matrix.columns.levels[0].sources[0];\r\n\r\n            // final assembly\r\n            let categorical: DataViewCategorical = {\r\n                categories: categories,\r\n                values: values,\r\n            };\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix: DataViewMatrix): DataViewCategoryColumn[] {\r\n            debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');\r\n            debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1),\r\n                'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');\r\n\r\n            // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the \r\n            // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the \r\n            // same amongst the resulting DataViewCategoryColumns.\r\n            let categoryIdentity = _.map(unpivotedMatrix.rows.root.children, x => x.identity);\r\n            let categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;\r\n            let categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;\r\n\r\n            let categories: DataViewCategoryColumn[] = [];\r\n            for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {\r\n                let groupLevelValues = _.map(unpivotedMatrix.rows.root.children, (categoryNode: DataViewMatrixNode) => {\r\n                    let levelValues: DataViewMatrixGroupValue[] = categoryNode.levelValues;\r\n\r\n                    // Please refer to the interface comments on when this is undefined... But in today's code\r\n                    // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. \r\n                    if (levelValues !== undefined) {\r\n                        debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i),\r\n                            'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');\r\n                        return levelValues[i].value;\r\n                    }\r\n                });\r\n\r\n                categories.push({\r\n                    source: categorySourceColumns[i],\r\n                    values: groupLevelValues,\r\n                    identity: categoryIdentity,\r\n                    identityFields: categoryIdentityFields,\r\n                });\r\n            }\r\n\r\n            return categories;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import EnumExtensions = jsCommon.EnumExtensions;\r\n    import INumberDictionary = jsCommon.INumberDictionary;\r\n\r\n    export interface DataViewTransformApplyOptions {\r\n        prototype: DataView;\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        dataViewMappings?: DataViewMapping[];\r\n        transforms: DataViewTransformActions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        dataRoles: VisualDataRole[];\r\n    }\r\n\r\n    /** Describes the Transform actions to be done to a prototype DataView. */\r\n    export interface DataViewTransformActions {\r\n        /** Describes transform metadata for each semantic query select item, as the arrays align, by index. */\r\n        selects?: DataViewSelectTransform[];\r\n\r\n        /** Describes the DataViewObject definitions. */\r\n        objects?: DataViewObjectDefinitions;\r\n\r\n        /** Describes the splitting of a single input DataView into multiple DataViews. */\r\n        splits?: DataViewSplitTransform[];\r\n\r\n        /** Describes the projection metadata which includes projection ordering and active items. */\r\n        roles?: DataViewRoleTransformMetadata;\r\n    }\r\n\r\n    export interface DataViewSplitTransform {\r\n        selects: INumberDictionary<boolean>;\r\n    }\r\n\r\n    export interface DataViewProjectionOrdering {\r\n        [roleName: string]: number[];\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItemInfo {\r\n        queryRef: string;\r\n\r\n        /** Describes if the active item should be ignored in concatenation.\r\n            If the active item has a drill filter, it will not be used in concatenation.\r\n            If the value of suppressConcat is true, the activeItem will be ommitted from concatenation. */\r\n        suppressConcat?: boolean;\r\n    }\r\n\r\n    export interface DataViewProjectionActiveItems {\r\n        [roleName: string]: DataViewProjectionActiveItemInfo[];\r\n    }\r\n\r\n    export interface DataViewRoleTransformMetadata {\r\n        /** Describes the order of selects (referenced by query index) in each role. */\r\n        ordering?: DataViewProjectionOrdering;\r\n\r\n        /** Describes the active items in each role. */\r\n        activeItems?: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export interface MatrixTransformationContext {\r\n        rowHierarchyRewritten: boolean;\r\n        columnHierarchyRewritten: boolean;\r\n        hierarchyTreesRewritten: boolean;\r\n    }\r\n\r\n    interface ValueRewrite<T> {\r\n        from: T;\r\n        to: T;\r\n    }\r\n\r\n    interface NumberToNumberMapping {\r\n        [position: number]: number;\r\n    }\r\n\r\n    const enum CategoricalDataViewTransformation {\r\n        None,\r\n        Pivot,\r\n        SelfCrossJoin,\r\n    }\r\n\r\n    export const enum StandardDataViewKinds {\r\n        None = 0,\r\n        Categorical = 1,\r\n        Matrix = 1 << 1,\r\n        Single = 1 << 2,\r\n        Table = 1 << 3,\r\n        Tree = 1 << 4,\r\n    }\r\n\r\n    // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.\r\n    export module DataViewTransform {\r\n        const fillRulePropertyDescriptor: DataViewObjectPropertyDescriptor = { type: { fillRule: {} } };\r\n\r\n        const enum ColumnIdentifierKind {\r\n            QueryName,\r\n            Role,\r\n        }\r\n\r\n        export function apply(options: DataViewTransformApplyOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.\r\n\r\n            let prototype = options.prototype,\r\n                objectDescriptors = options.objectDescriptors,\r\n                dataViewMappings = options.dataViewMappings,\r\n                transforms = options.transforms,\r\n                projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems,\r\n                colorAllocatorFactory = options.colorAllocatorFactory,\r\n                dataRoles = options.dataRoles;\r\n\r\n            if (!prototype)\r\n                return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);\r\n\r\n            if (!transforms)\r\n                return [prototype];\r\n\r\n            // Transform Query DataView\r\n            prototype = DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);\r\n            let visualDataViews: DataView[] = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);\r\n\r\n            // Transform and generate derived visual DataViews\r\n            visualDataViews = DataViewRegression.run({\r\n                dataViewMappings: dataViewMappings,\r\n                visualDataViews: visualDataViews,\r\n                dataRoles: dataRoles,\r\n                objectDescriptors: objectDescriptors,\r\n                objectDefinitions: transforms.objects,\r\n                colorAllocatorFactory: colorAllocatorFactory,\r\n                transformSelects: transforms.selects,\r\n                metadata: prototype.metadata,\r\n                projectionActiveItems: projectionActiveItems,\r\n            });\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        function transformQueryToVisualDataView(\r\n            prototype: DataView,\r\n            transforms: DataViewTransformActions,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            dataViewMappings: DataViewMapping[],\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[]): DataView[] {\r\n            let transformedDataViews: DataView[] = [];\r\n            let splits = transforms.splits;\r\n            if (_.isEmpty(splits)) {\r\n                transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));\r\n            } else {\r\n                for (let split of splits) {\r\n                    let transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);\r\n                    transformedDataViews.push(transformed);\r\n                }\r\n            }\r\n            return transformedDataViews;\r\n        }\r\n\r\n        function transformEmptyDataView(objectDescriptors: DataViewObjectDescriptors, transforms: DataViewTransformActions, colorAllocatorFactory: IColorAllocatorFactory): DataView[] {\r\n            if (transforms && transforms.objects) {\r\n                let emptyDataView: DataView = {\r\n                    metadata: {\r\n                        columns: [],\r\n                    }\r\n                };\r\n\r\n                transformObjects(\r\n                    emptyDataView,\r\n                    StandardDataViewKinds.None,\r\n                    objectDescriptors,\r\n                    transforms.objects,\r\n                    transforms.selects,\r\n                    colorAllocatorFactory);\r\n\r\n                return [emptyDataView];\r\n            }\r\n\r\n            return [];\r\n        }\r\n\r\n        function transformDataView(\r\n            prototype: DataView,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            roleMappings: DataViewMapping[],\r\n            transforms: DataViewTransformActions,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            dataRoles: VisualDataRole[],\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(transforms, 'transforms');\r\n            debug.assert(!selectsToInclude ||\r\n                _.filter(\r\n                    Object.keys(selectsToInclude),\r\n                    (selectIndex) => selectsToInclude[selectIndex] && (!transforms.selects || !transforms.selects[selectIndex]))\r\n                    .length === 0, // asserts that the number of select indices in selectsToInclude without a corresponding Select Transform === 0\r\n                'If selectsToInclude is specified, every Select Index in it must have a corresponding Select Transform.');\r\n\r\n            let targetKinds = getTargetKinds(roleMappings);\r\n            let transformed = inherit(prototype);\r\n            transformed.metadata = inherit(prototype.metadata);\r\n\r\n            let projectionOrdering = transforms.roles && transforms.roles.ordering;\r\n            let projectionActiveItems = transforms.roles && transforms.roles.activeItems;\r\n            transformed = transformSelects(transformed, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);\r\n            transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);\r\n\r\n            // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated\r\n            transformed = DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);\r\n\r\n            DataViewNormalizeValues.apply({\r\n                dataview: transformed,\r\n                dataViewMappings: roleMappings,\r\n                dataRoles: dataRoles,\r\n            });\r\n\r\n            return transformed;\r\n        }\r\n\r\n        function getTargetKinds(roleMappings: DataViewMapping[]): StandardDataViewKinds {\r\n            debug.assertAnyValue(roleMappings, 'roleMappings');\r\n\r\n            if (!roleMappings)\r\n                return StandardDataViewKinds.None;\r\n\r\n            let result = StandardDataViewKinds.None;\r\n            for (let roleMapping of roleMappings) {\r\n                if (roleMapping.categorical)\r\n                    result |= StandardDataViewKinds.Categorical;\r\n                if (roleMapping.matrix)\r\n                    result |= StandardDataViewKinds.Matrix;\r\n                if (roleMapping.single)\r\n                    result |= StandardDataViewKinds.Single;\r\n                if (roleMapping.table)\r\n                    result |= StandardDataViewKinds.Table;\r\n                if (roleMapping.tree)\r\n                    result |= StandardDataViewKinds.Tree;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function transformSelects(\r\n            dataView: DataView,\r\n            roleMappings: DataViewMapping[],\r\n            selectTransforms: DataViewSelectTransform[],\r\n            projectionOrdering?: DataViewProjectionOrdering,\r\n            selectsToInclude?: INumberDictionary<boolean>): DataView {\r\n\r\n            let columnRewrites: ValueRewrite<DataViewMetadataColumn>[] = [];\r\n            if (selectTransforms) {\r\n                dataView.metadata.columns = applyTransformsToColumns(\r\n                    dataView.metadata.columns,\r\n                    selectTransforms,\r\n                    columnRewrites);\r\n            }\r\n\r\n            // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)\r\n            if (dataView.categorical) {\r\n                dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                // NOTE: This is slightly DSR-specific.\r\n                dataView = pivotIfNecessary(dataView, roleMappings);\r\n            }\r\n\r\n            if (dataView.matrix) {\r\n                let matrixTransformationContext: MatrixTransformationContext = {\r\n                    rowHierarchyRewritten: false,\r\n                    columnHierarchyRewritten: false,\r\n                    hierarchyTreesRewritten: false\r\n                };\r\n                dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);\r\n\r\n                // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)\r\n                if (shouldPivotMatrix(dataView.matrix, roleMappings))\r\n                    DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);\r\n            }\r\n\r\n            if (dataView.table)\r\n                dataView.table = applyRewritesToTable(dataView.table, columnRewrites, roleMappings, projectionOrdering);\r\n\r\n            return dataView;\r\n        }\r\n\r\n        function applyTransformsToColumns(\r\n            prototypeColumns: DataViewMetadataColumn[],\r\n            selects: DataViewSelectTransform[],\r\n            rewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn[] {\r\n            debug.assertValue(prototypeColumns, 'columns');\r\n\r\n            if (!selects)\r\n                return prototypeColumns;\r\n\r\n            //column may contain undefined entries\r\n            let columns = inherit(prototypeColumns);\r\n\r\n            for (let i = 0, len = prototypeColumns.length; i < len; i++) {\r\n                let prototypeColumn = prototypeColumns[i];\r\n                let select = selects[prototypeColumn.index];\r\n                if (!select)\r\n                    continue;\r\n\r\n                let column: DataViewMetadataColumn = columns[i] = inherit(prototypeColumn);\r\n\r\n                if (select.roles)\r\n                    column.roles = select.roles;\r\n                if (select.type)\r\n                    column.type = select.type;\r\n                column.format = getFormatForColumn(select, column);\r\n\r\n                if (select.displayName)\r\n                    column.displayName = select.displayName;\r\n                if (select.queryName)\r\n                    column.queryName = select.queryName;\r\n                if (select.kpi)\r\n                    column.kpi = select.kpi;\r\n                if (select.sort)\r\n                    column.sort = select.sort;\r\n                if (select.discourageAggregationAcrossGroups)\r\n                    column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;\r\n\r\n                rewrites.push({\r\n                    from: prototypeColumn,\r\n                    to: column,\r\n                });\r\n            }\r\n\r\n            return columns;\r\n        }\r\n\r\n        /**\r\n         * Get the column format. Order of precendence is:\r\n         *  1. Select format\r\n         *  2. Column format\r\n         */\r\n        function getFormatForColumn(select: DataViewSelectTransform, column: DataViewMetadataColumn): string {\r\n            // TODO: we already copied the select.Format to column.format, we probably don't need this check\r\n            return select.format || column.format;\r\n        }\r\n\r\n        function applyRewritesToCategorical(prototype: DataViewCategorical, columnRewrites: ValueRewrite<DataViewMetadataColumn>[], selectsToInclude?: INumberDictionary<boolean>): DataViewCategorical {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            let categorical = inherit(prototype);\r\n\r\n            function override(value: { source?: DataViewMetadataColumn }) {\r\n                let rewrittenSource = findOverride(value.source, columnRewrites);\r\n                if (rewrittenSource) {\r\n                    let rewritten = inherit(value);\r\n                    rewritten.source = rewrittenSource;\r\n                    return rewritten;\r\n                }\r\n            }\r\n\r\n            let categories = Prototype.overrideArray(prototype.categories, override);\r\n            if (categories)\r\n                categorical.categories = categories;\r\n\r\n            let valuesOverride = Prototype.overrideArray(prototype.values, override);\r\n            let values = valuesOverride || prototype.values;\r\n\r\n            if (values) {\r\n                let grouped = inherit(values.grouped());\r\n                for (let i = 0, ilen = grouped.length; i < ilen; i++) {\r\n                    grouped[i] = inherit(grouped[i]);\r\n                }\r\n                if (selectsToInclude) {\r\n                    // Apply selectsToInclude to values by removing value columns not included\r\n                    for (let i = values.length - 1; i >= 0; i--) {\r\n                        if (!selectsToInclude[values[i].source.index]) {\r\n                            values.splice(i, 1);\r\n                        }\r\n                    }\r\n\r\n                    // Apply selectsToInclude to grouped()\r\n                    if (values.length > 0 && values[0].identity) {\r\n                        // We have a dynamic series, so we should remove any value columns not included in the split from each\r\n                        //    valueColumnGroup\r\n                        for (let i = 0, ilen = grouped.length ; i < ilen; i++) {\r\n                            let currentGroupValues = grouped[i].values;\r\n                            for (let j = currentGroupValues.length - 1; j >= 0; j--) {\r\n                                if (!selectsToInclude[currentGroupValues[j].source.index])\r\n                                    currentGroupValues.splice(i, 1);\r\n                            }\r\n                        }\r\n                    }\r\n                    else {\r\n                        // We are in a static series, so we should throw away the grouped and recreate it using the static values\r\n                        //   which have already been filtered\r\n                        grouped = [];\r\n                        grouped[0] = {\r\n                            values: values,\r\n                        };\r\n                    }\r\n                }\r\n\r\n                if (values.source) {\r\n                    if (selectsToInclude && !selectsToInclude[values.source.index]) {\r\n                        values.source = undefined;\r\n                    }\r\n                    else {\r\n                        let rewrittenValuesSource = findOverride(values.source, columnRewrites);\r\n                        if (rewrittenValuesSource)\r\n                            values.source = rewrittenValuesSource;\r\n                    }\r\n                }\r\n\r\n                let currentGroupIndex = 0;\r\n                let group: DataViewValueColumnGroup;\r\n                for (let i = 0, ilen = values.length; i < ilen; i++) {\r\n                    let currentValue = values[i];\r\n                    if (!group || (currentValue.identity !== group.identity)) {\r\n                        debug.assert(!_.isUndefined(grouped[currentGroupIndex]) && currentValue.identity === grouped[currentGroupIndex].identity,\r\n                            'The input Categorical has at least one values column whose identity does not belong to any of the Series groups. ' + \r\n                            'This query DataView Categorical is most likely containing the data across multiple splits, and the caller code is expected to ' +\r\n                            'specify the select indices for one of the splits in the parameter selectsToInclude.  ' +\r\n                            'Actual selectsToInclude=' + JSON.stringify(selectsToInclude));\r\n                        group = inherit(grouped[currentGroupIndex]);\r\n                        grouped[currentGroupIndex] = group;\r\n                        group.values = [];\r\n                        currentGroupIndex++;\r\n                    }\r\n                    group.values.push(currentValue);\r\n                }\r\n\r\n                categorical.values = values;\r\n                setGrouped(values, grouped);\r\n            }\r\n\r\n            return categorical;\r\n        }\r\n\r\n        function applyRewritesToTable(\r\n            prototype: DataViewTable,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering): DataViewTable {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a table.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (!roleMappings || roleMappings.length !== 1 || !roleMappings[0].table)\r\n                return prototype;\r\n\r\n            let table = inherit(prototype);\r\n\r\n            // Copy the rewritten columns into the table view\r\n            let override = (metadata: DataViewMetadataColumn) => findOverride(metadata, columnRewrites);\r\n            let columns = Prototype.overrideArray(prototype.columns, override);\r\n            if (columns)\r\n                table.columns = columns;\r\n\r\n            if (!projectionOrdering)\r\n                return table;\r\n\r\n            let newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);\r\n            if (!newToOldPositions)\r\n                return table;\r\n\r\n            // Reorder the columns\r\n            let columnsClone = columns.slice(0);\r\n            let keys = Object.keys(newToOldPositions);\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let sourceColumn = columnsClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === columns.length)\r\n                    columns.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < columns.length, 'The column index is out of range for reordering.');\r\n                    columns[i] = sourceColumn;\r\n                }\r\n            }\r\n\r\n            // Reorder the rows\r\n            let rows = Prototype.overrideArray(table.rows,\r\n                (row: any[]) => {\r\n                    let newRow: any[] = [];\r\n                    for (let i = 0, len = keys.length; i < len; ++i)\r\n                        newRow[i] = row[newToOldPositions[keys[i]]];\r\n\r\n                    return newRow;\r\n                });\r\n\r\n            if (rows)\r\n                table.rows = rows;\r\n\r\n            return table;\r\n        }\r\n\r\n        /** Creates a mapping of new position to original position. */\r\n        function createTableColumnPositionMapping(\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n            let roles = Object.keys(projectionOrdering);\r\n\r\n            // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.\r\n            if (roles.length !== 1)\r\n                return;\r\n\r\n            let role = roles[0],\r\n                originalOrder = _.map(columnRewrites, (rewrite: ValueRewrite<DataViewMetadataColumn>) => rewrite.from.index),\r\n                newOrder = projectionOrdering[role];\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        function applyRewritesToMatrix(\r\n            prototype: DataViewMatrix,\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[],\r\n            roleMappings: DataViewMapping[],\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            context: MatrixTransformationContext): DataViewMatrix {\r\n            debug.assertValue(prototype, 'prototype');\r\n            debug.assertValue(columnRewrites, 'columnRewrites');\r\n\r\n            // Don't perform this potentially expensive transform unless we actually have a matrix.\r\n            // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.\r\n            if (!roleMappings || roleMappings.length < 1 || !(roleMappings[0].matrix || (roleMappings[1] && roleMappings[1].matrix)))\r\n                return prototype;\r\n\r\n            let matrixMapping = roleMappings[0].matrix || roleMappings[1].matrix;\r\n            let matrix = inherit(prototype);\r\n\r\n            function override(metadata: DataViewMetadataColumn) {\r\n                return findOverride(metadata, columnRewrites);\r\n            }\r\n\r\n            function overrideHierarchy(hierarchy: DataViewHierarchy): DataViewHierarchy {\r\n                let rewrittenHierarchy: DataViewHierarchy = null;\r\n\r\n                let newLevels = Prototype.overrideArray(\r\n                    hierarchy.levels,\r\n                    (level: DataViewHierarchyLevel) => {\r\n                        let newLevel: DataViewHierarchyLevel = null;\r\n                        let levelSources = Prototype.overrideArray(level.sources, override);\r\n                        if (levelSources)\r\n                            newLevel = ensureRewritten<DataViewHierarchyLevel>(newLevel, level, h => h.sources = levelSources);\r\n\r\n                        return newLevel;\r\n                    });\r\n                if (newLevels)\r\n                    rewrittenHierarchy = ensureRewritten<DataViewHierarchy>(rewrittenHierarchy, hierarchy, r => r.levels = newLevels);\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n\r\n            let rows = overrideHierarchy(matrix.rows);\r\n            if (rows) {\r\n                matrix.rows = rows;\r\n                context.rowHierarchyRewritten = true;\r\n            }\r\n\r\n            let columns = overrideHierarchy(matrix.columns);\r\n            if (columns) {\r\n                matrix.columns = columns;\r\n                context.columnHierarchyRewritten = true;\r\n            }\r\n\r\n            let valueSources = Prototype.overrideArray(matrix.valueSources, override);\r\n            if (valueSources) {\r\n                matrix.valueSources = valueSources;\r\n\r\n                // Only need to reorder if we have more than one value source, and they are all bound to the same role\r\n                let matrixValues = <DataViewRoleForMapping>matrixMapping.values;\r\n                if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {\r\n                    let columnLevels = columns.levels.length;\r\n                    if (columnLevels > 0) {\r\n                        let newToOldPositions = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);\r\n                        if (newToOldPositions) {\r\n                            let keys = Object.keys(newToOldPositions);\r\n                            let numKeys = keys.length;\r\n\r\n                            // Reorder the value columns\r\n                            columns.root = DataViewPivotMatrix.cloneTree(columns.root);\r\n                            if (columnLevels === 1)\r\n                                reorderChildNodes(columns.root, newToOldPositions);\r\n                            else\r\n                                forEachNodeAtLevel(columns.root, columnLevels - 2, (node: DataViewMatrixNode) => reorderChildNodes(node, newToOldPositions));\r\n\r\n                            // Reorder the value rows\r\n                            matrix.rows.root = DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, (node: DataViewMatrixNode) => {\r\n\r\n                                if (!node.values)\r\n                                    return;\r\n\r\n                                let newValues: { [id: number]: DataViewTreeNodeValue } = {};\r\n\r\n                                let iterations = Object.keys(node.values).length / numKeys;\r\n                                for (let i = 0, len = iterations; i < len; i++) {\r\n                                    let offset = i * numKeys;\r\n                                    for (let keysIndex = 0; keysIndex < numKeys; keysIndex++)\r\n                                        newValues[offset + keysIndex] = node.values[offset + newToOldPositions[keys[keysIndex]]];\r\n                                }\r\n\r\n                                node.values = newValues;\r\n                            });\r\n\r\n                            context.hierarchyTreesRewritten = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);\r\n\r\n            return matrix;\r\n        }\r\n\r\n        function reorderChildNodes(node: DataViewMatrixNode, newToOldPositions: NumberToNumberMapping): void {\r\n            let keys = Object.keys(newToOldPositions);\r\n            let numKeys = keys.length;\r\n            let children = node.children;\r\n\r\n            let childrenClone = children.slice(0);\r\n            for (let i = 0, len = numKeys; i < len; i++) {\r\n                let sourceColumn = childrenClone[newToOldPositions[keys[i]]];\r\n\r\n                // In the case we've hit the end of our columns array, but still have position reordering keys,\r\n                // there is a duplicate column so we will need to add a new column for the duplicate data\r\n                if (i === children.length)\r\n                    children.push(sourceColumn);\r\n                else {\r\n                    debug.assert(i < children.length, 'The column index is out of range for reordering.');\r\n                    children[i] = sourceColumn;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels\r\n         * and values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified prototype is necessary.\r\n         */\r\n        function reorderMatrixCompositeGroups(\r\n            prototype: DataViewMatrix,\r\n            supportedDataViewMapping: DataViewMatrixMapping,\r\n            projection: DataViewProjectionOrdering): DataViewMatrix {\r\n\r\n            let transformedDataView: DataViewMatrix;\r\n\r\n            if (prototype && supportedDataViewMapping && projection) {\r\n\r\n                // reorder levelValues in any composite groups in rows hierarchy\r\n                let transformedRowsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedRowsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedRowsHierarchy || prototype.rows,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                // reorder levelValues in any composite groups in columns hierarchy\r\n                let transformedColumnsHierarchy: DataViewHierarchy;\r\n                DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {\r\n                    visitRole: (role: string, context?: RoleItemContext): void => {\r\n                        transformedColumnsHierarchy = reorderMatrixHierarchyCompositeGroups(\r\n                            transformedColumnsHierarchy || prototype.columns,\r\n                            role,\r\n                            projection);\r\n                    }\r\n                });\r\n\r\n                if (transformedRowsHierarchy || transformedColumnsHierarchy) {\r\n                    transformedDataView = inheritSingle(prototype);\r\n                    transformedDataView.rows = transformedRowsHierarchy || transformedDataView.rows;\r\n                    transformedDataView.columns = transformedColumnsHierarchy || transformedDataView.columns;\r\n                }\r\n            }\r\n\r\n            return transformedDataView;\r\n        }\r\n\r\n        /**\r\n         * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and\r\n         * values re-ordered by projection ordering.\r\n         * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.\r\n         */\r\n        function reorderMatrixHierarchyCompositeGroups(\r\n            matrixHierarchy: DataViewHierarchy,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): DataViewHierarchy {\r\n            debug.assertValue(matrixHierarchy, 'matrixHierarchy');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n\r\n            let transformedHierarchy: DataViewHierarchy;\r\n            let selectIndicesInProjectionOrder: number[] = projection[hierarchyRole];\r\n\r\n            // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection\r\n            let hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;\r\n            if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {\r\n                for (let i = matrixHierarchy.levels.length - 1; i >= 0; i--) {\r\n                    var hierarchyLevel: DataViewHierarchyLevel = matrixHierarchy.levels[i];\r\n\r\n                    // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering\r\n                    let newToOldLevelSourceIndicesMapping: NumberToNumberMapping =\r\n                        createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);\r\n\r\n                    if (newToOldLevelSourceIndicesMapping) {\r\n                        if (_.isUndefined(transformedHierarchy)) {\r\n                            // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,\r\n                            // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...\r\n                            transformedHierarchy = inheritSingle(matrixHierarchy);\r\n                            transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);\r\n\r\n                            // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,\r\n                            // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to\r\n                            // happen in other hierarchy levels in the later iterations of this for-loop.\r\n                            transformedHierarchy.root = utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);\r\n                        }\r\n\r\n                        // reorder the metadata columns in the sources array at that level\r\n                        let transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...\r\n                        transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);\r\n\r\n                        // reorder the level values in the composite group nodes at the current hierarchy level\r\n                        reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return transformedHierarchy;\r\n        }\r\n\r\n        /**\r\n         * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),\r\n         * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.\r\n         *\r\n         * The returned value maps level source indices from the new target order (calculated from projection order)\r\n         * back to the original order as they appear in the specified hierarchyLevel's sources.\r\n         * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.\r\n         *\r\n         * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.\r\n         *\r\n         * @param hierarchyLevel The hierarchy level that contains the metadata column sources.\r\n         * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.\r\n         * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.\r\n         */\r\n        function createMatrixHierarchyLevelSourcesPositionMapping(\r\n            hierarchyLevel: DataViewHierarchyLevel,\r\n            hierarchyRole: string,\r\n            projection: DataViewProjectionOrdering): NumberToNumberMapping {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(hierarchyRole, 'hierarchyRole');\r\n            debug.assertValue(projection, 'projection');\r\n            debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');\r\n\r\n            let newToOldLevelSourceIndicesMapping: NumberToNumberMapping;\r\n            let levelSourceColumns = hierarchyLevel.sources;\r\n\r\n            if (levelSourceColumns && levelSourceColumns.length >= 2) {\r\n                // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...\r\n\r\n                let columnsForHierarchyRoleOrderedByLevelSourceIndex = utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(\r\n                    levelSourceColumns,\r\n                    projection,\r\n                    hierarchyRole);\r\n\r\n                if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {\r\n                    // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...\r\n                    let columnsForHierarchyRoleOrderedByProjection = _.sortBy(\r\n                        columnsForHierarchyRoleOrderedByLevelSourceIndex,\r\n                        columnInfo => columnInfo.projectionOrderIndex);\r\n\r\n                    newToOldLevelSourceIndicesMapping = createOrderMapping(\r\n                        _.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, columnInfo => columnInfo.sourceIndex),\r\n                        _.map(columnsForHierarchyRoleOrderedByProjection, columnInfo => columnInfo.sourceIndex));\r\n                }\r\n            }\r\n\r\n            return newToOldLevelSourceIndicesMapping;\r\n        }\r\n\r\n        /**\r\n         * Applies re-ordering on the specified transformingHierarchyLevel's sources.\r\n         * Returns the same object as the specified transformingHierarchyLevel.\r\n         */\r\n        function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel: DataViewHierarchyLevel, newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewHierarchyLevel {\r\n            debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let originalLevelSources = transformingHierarchyLevel.sources;\r\n\r\n            transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.\r\n\r\n            let newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);\r\n            for (let i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {\r\n                let newLevelSourceIndex = newLevelSourceIndices[i];\r\n                let oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];\r\n\r\n                debug.assert(oldLevelSourceIndex < originalLevelSources.length,\r\n                    'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');\r\n\r\n                transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];\r\n            }\r\n\r\n            return transformingHierarchyLevel;\r\n        }\r\n\r\n        /**\r\n         * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,\r\n         * and updates their DataViewMatrixGroupValue.levelSourceIndex property.\r\n         *\r\n         * Returns the same object as the specified transformingHierarchyRootNode.\r\n         */\r\n        function reorderMatrixHierarchyLevelValues(\r\n            transformingHierarchyRootNode: DataViewMatrixNode,\r\n            transformingHierarchyLevelIndex: number,\r\n            newToOldLevelSourceIndicesMapping: NumberToNumberMapping): DataViewMatrixNode {\r\n            debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');\r\n            debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');\r\n\r\n            let oldToNewLevelSourceIndicesMapping: NumberToNumberMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);\r\n\r\n            forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, (transformingMatrixNode: DataViewMatrixNode) => {\r\n                let originalLevelValues = transformingMatrixNode.levelValues;\r\n\r\n                // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really\r\n                // the \"projection for this composite group\", a concept that isn't yet implemented in DataViewProjectionOrdering.\r\n                // The following code isn't correct in the special case where a column is projected twice in this composite group,\r\n                // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.\r\n                // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.\r\n\r\n                if (!_.isEmpty(originalLevelValues)) {\r\n                    // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.\r\n                    // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)\r\n                    // because we don't want to accidentally modify the array AND its value references in Query DataView\r\n                    let newlyOrderedLevelValues = _.sortBy(originalLevelValues, levelValue => oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]);\r\n\r\n                    for (let i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {\r\n                        let transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);\r\n                        transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];\r\n                        newlyOrderedLevelValues[i] = transformingLevelValue;\r\n                    }\r\n\r\n                    transformingMatrixNode.levelValues = newlyOrderedLevelValues;\r\n\r\n                    // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,\r\n                    // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.\r\n                    let newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);\r\n                    if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {\r\n                        transformingMatrixNode.value = newlyOrderedLastLevelValue.value;\r\n                    }\r\n                    if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {\r\n                        transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;\r\n                    }\r\n                }\r\n            });\r\n\r\n            return transformingHierarchyRootNode;\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of new position to original position.\r\n         *\r\n         * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:\r\n         * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)\r\n         * - the value in the key-value pair is the index of the particular column in the original order\r\n         */\r\n        function createMatrixValuesPositionMapping(\r\n            matrixValues: DataViewRoleForMapping,\r\n            projectionOrdering: DataViewProjectionOrdering,\r\n            valueSources: DataViewMetadataColumn[],\r\n            columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): NumberToNumberMapping {\r\n\r\n            let role = matrixValues.for.in;\r\n            let newOrder = projectionOrdering[role];\r\n\r\n            let originalOrder = _.chain(columnRewrites)\r\n                .filter(rewrite => _.contains(valueSources, rewrite.to))\r\n                .map(rewrite => rewrite.from.index)\r\n                .value();\r\n\r\n            return createOrderMapping(originalOrder, newOrder);\r\n        }\r\n\r\n        /**\r\n         * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified\r\n         * originalOrder array.\r\n         * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue\r\n         * under the context of the caller code), e.g. the Select Index in projection ordering array.\r\n         * Also, the specified originalOrder must contain every value that exists in newOrder.\r\n         *\r\n         * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of\r\n         * key-value pair, each of which represents the new and old indices of a particular column:\r\n         * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array\r\n         * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array\r\n         *\r\n         * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).\r\n         *\r\n         * If the specified originalOrder and newOrder are same, then this function returns undefined.\r\n         *\r\n         * @param originalOrder E.g. an array of metadata column \"select indices\", in the original order as they exist in Query DataView.\r\n         * @param newOrder E.g. an array of metadata column \"select indices\", in rojection ordering.\r\n         */\r\n        function createOrderMapping(originalOrder: number[], newOrder: number[]): NumberToNumberMapping {\r\n            // Optimization: avoid rewriting if the current order is correct\r\n            if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, (x: number, y: number) => x === y))\r\n                return;\r\n\r\n            let mapping: NumberToNumberMapping = {};\r\n            for (let i = 0, len = newOrder.length; i < len; ++i) {\r\n                let newPosition = newOrder[i];\r\n                mapping[i] = originalOrder.indexOf(newPosition);\r\n            }\r\n\r\n            return mapping;\r\n        }\r\n\r\n        function createReversedMapping(mapping: NumberToNumberMapping): NumberToNumberMapping {\r\n            debug.assertValue(mapping, 'mapping');\r\n\r\n            let reversed: NumberToNumberMapping = {};\r\n\r\n            for (let key in mapping) {\r\n                // Note: key is a string after we get it out from mapping, thus we need to parse it\r\n                // back into a number before putting it as the value in the reversed mapping\r\n                let value = mapping[key];\r\n                let keyAsNumber = parseInt(key, 10);\r\n                reversed[value] = keyAsNumber;\r\n            }\r\n\r\n            debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length,\r\n                'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');\r\n\r\n            return reversed;\r\n        }\r\n\r\n        export function forEachNodeAtLevel(node: DataViewMatrixNode, targetLevel: number, callback: (node: DataViewMatrixNode) => void): void {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(targetLevel >= 0, 'argetLevel >= 0');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            if (node.level === targetLevel) {\r\n                callback(node);\r\n                return;\r\n            }\r\n\r\n            let children = node.children;\r\n            if (children && children.length > 0) {\r\n                for (let i = 0, ilen = children.length; i < ilen; i++)\r\n                    forEachNodeAtLevel(children[i], targetLevel, callback);\r\n            }\r\n        }\r\n\r\n        function findOverride(source: DataViewMetadataColumn, columnRewrites: ValueRewrite<DataViewMetadataColumn>[]): DataViewMetadataColumn {\r\n            for (let i = 0, len = columnRewrites.length; i < len; i++) {\r\n                let columnRewrite = columnRewrites[i];\r\n                if (columnRewrite.from === source)\r\n                    return columnRewrite.to;\r\n            }\r\n        }\r\n\r\n        function ensureRewritten<T>(rewritten: T, prototype: T, callback?: (rewritten: T) => void): T {\r\n            if (!rewritten)\r\n                rewritten = inherit(prototype);\r\n\r\n            if (callback)\r\n                callback(rewritten);\r\n\r\n            return rewritten;\r\n        }\r\n\r\n        export function transformObjects(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertAnyValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!objectDescriptors)\r\n                return;\r\n\r\n            let objectsForAllSelectors = DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);\r\n            DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);\r\n\r\n            let metadataOnce = objectsForAllSelectors.metadataOnce;\r\n            let dataObjects = objectsForAllSelectors.data;\r\n            if (metadataOnce)\r\n                evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);\r\n\r\n            let metadataObjects = objectsForAllSelectors.metadata;\r\n            if (metadataObjects) {\r\n                for (let i = 0, len = metadataObjects.length; i < len; i++) {\r\n                    let metadataObject = metadataObjects[i];\r\n                    let objectDefns = metadataObject.objects;\r\n                    let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                    evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);\r\n                }\r\n            }\r\n\r\n            for (let i = 0, len = dataObjects.length; i < len; i++) {\r\n                let dataObject = dataObjects[i];\r\n                let objectDefns = dataObject.objects;\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n                evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);\r\n            }\r\n\r\n            let userDefined = objectsForAllSelectors.userDefined;\r\n            if (userDefined) {\r\n                // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.\r\n                evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);\r\n            }\r\n        }\r\n\r\n        function evaluateUserDefinedObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewObjectDefinitionsForSelector[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let dataViewObjects: DataViewObjects = dataView.metadata.objects;\r\n            if (!dataViewObjects) {\r\n                dataViewObjects = dataView.metadata.objects = {};\r\n            }\r\n\r\n            for (let objectDefn of objectDefns) {\r\n                let id = objectDefn.selector.id;\r\n\r\n                let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);\r\n                let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n                let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName];\r\n\r\n                    let map = <DataViewObjectMap>dataViewObjects[objectName];\r\n                    if (!map)\r\n                        map = dataViewObjects[objectName] = [];\r\n                    debug.assert(DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');\r\n\r\n                    // NOTE: We do not check for duplicate ids.\r\n                    map.push({ id: id, object: object });\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Evaluates and sets properties on the DataView metadata. */\r\n        function evaluateMetadataObjects(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            dataObjects: DataViewObjectDefinitionsForSelectorWithRule[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(dataObjects, 'dataObjects');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);\r\n            let evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n            if (objects) {\r\n                dataView.metadata.objects = objects;\r\n\r\n                for (let objectName in objects) {\r\n                    let object = <DataViewObject>objects[objectName],\r\n                        objectDesc = objectDescriptors[objectName];\r\n\r\n                    for (let propertyName in object) {\r\n                        let propertyDesc = objectDesc.properties[propertyName],\r\n                            ruleDesc = propertyDesc.rule;\r\n                        if (!ruleDesc)\r\n                            continue;\r\n\r\n                        let definition = createRuleEvaluationInstance(\r\n                            dataView,\r\n                            colorAllocatorFactory,\r\n                            ruleDesc,\r\n                            objectName,\r\n                            object[propertyName],\r\n                            propertyDesc.type);\r\n                        if (!definition)\r\n                            continue;\r\n\r\n                        dataObjects.push(definition);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstance(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            objectName: string,\r\n            propertyValue: DataViewPropertyValue,\r\n            ruleType: StructuralTypeDescriptor): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n            debug.assertValue(ruleType, 'ruleType');\r\n\r\n            let ruleOutput = ruleDesc.output;\r\n            if (!ruleOutput)\r\n                return;\r\n\r\n            let selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);\r\n            if (!selectorToCreate)\r\n                return;\r\n\r\n            if (ruleType.fillRule) {\r\n                return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, <FillRule>propertyValue);\r\n            }\r\n        }\r\n\r\n        function createRuleEvaluationInstanceFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            ruleDesc: DataViewObjectPropertyRuleDescriptor,\r\n            selectorToCreate: Selector,\r\n            objectName: string,\r\n            propertyValue: FillRule): DataViewObjectDefinitionsForSelectorWithRule {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(ruleDesc, 'ruleDesc');\r\n            debug.assertValue(selectorToCreate, 'selectorToCreate');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, ColumnIdentifierKind.Role, propertyValue);\r\n\r\n            if (!colorAllocator)\r\n                return;\r\n\r\n            let rule = new ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);\r\n            let fillRuleProperties: DataViewObjectPropertyDefinitions = {};\r\n            fillRuleProperties[ruleDesc.output.property] = {\r\n                solid: { color: rule }\r\n            };\r\n\r\n            return {\r\n                selector: selectorToCreate,\r\n                rules: [rule],\r\n                objects: [{\r\n                    name: objectName,\r\n                    properties: fillRuleProperties,\r\n                }]\r\n            };\r\n        }\r\n\r\n        function tryCreateColorAllocatorForFillRule(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValue: FillRule): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(propertyValue, 'propertyValue');\r\n\r\n            if (propertyValue.linearGradient2)\r\n                return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);\r\n\r\n            if (propertyValue.linearGradient3)\r\n                return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient2(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient2: LinearGradient2): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient2, 'linearGradient2');\r\n\r\n            linearGradient2 = propertyValueFillRule.linearGradient2;\r\n            if (linearGradient2.min.value === undefined ||\r\n                linearGradient2.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                if (linearGradient2.min.value === undefined)\r\n                    linearGradient2.min.value = inputRange.min;\r\n                if (linearGradient2.max.value === undefined)\r\n                    linearGradient2.max.value = inputRange.max;\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);\r\n        }\r\n\r\n        function createColorAllocatorLinearGradient3(\r\n            dataView: DataView,\r\n            colorAllocatorFactory: IColorAllocatorFactory,\r\n            identifier: string,\r\n            identifierKind: ColumnIdentifierKind,\r\n            propertyValueFillRule: FillRule,\r\n            linearGradient3: LinearGradient3): IColorAllocator {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n            debug.assertValue(linearGradient3, 'linearGradient3');\r\n\r\n            let splitScales: boolean;\r\n            linearGradient3 = propertyValueFillRule.linearGradient3;\r\n            if (linearGradient3.min.value === undefined ||\r\n                linearGradient3.mid.value === undefined ||\r\n                linearGradient3.max.value === undefined) {\r\n                let inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);\r\n                if (!inputRange)\r\n                    return;\r\n\r\n                splitScales =\r\n                linearGradient3.min.value === undefined &&\r\n                linearGradient3.max.value === undefined &&\r\n                linearGradient3.mid.value !== undefined;\r\n\r\n                if (linearGradient3.min.value === undefined) {\r\n                    linearGradient3.min.value = inputRange.min;\r\n                }\r\n                if (linearGradient3.max.value === undefined) {\r\n                    linearGradient3.max.value = inputRange.max;\r\n                }\r\n                if (linearGradient3.mid.value === undefined) {\r\n                    let midValue: number = (linearGradient3.max.value + linearGradient3.min.value) / 2;\r\n                    linearGradient3.mid.value = midValue;\r\n                }\r\n            }\r\n\r\n            return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);\r\n        }\r\n\r\n        function populateColorAllocatorCache(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorFactory: IColorAllocatorFactory): IColorAllocatorCache {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            let cache = createColorAllocatorCache();\r\n            let staticEvalContext = createStaticEvalContext();\r\n\r\n            for (let i = 0, len = objectDefns.length; i < len; i++) {\r\n                let objectDefnProperties = objectDefns[i].properties;\r\n\r\n                for (let propertyName in objectDefnProperties) {\r\n                    let fillProperty = <FillDefinition>objectDefnProperties[propertyName];\r\n                    if (fillProperty &&\r\n                        fillProperty.solid &&\r\n                        fillProperty.solid.color &&\r\n                        fillProperty.solid.color.kind === SQExprKind.FillRule) {\r\n\r\n                        let fillRuleExpr = <SQFillRuleExpr>fillProperty.solid.color;\r\n\r\n                        let inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);\r\n                        if (!inputExprQueryName)\r\n                            continue;\r\n\r\n                        let fillRule = DataViewObjectEvaluator.evaluateProperty(\r\n                            staticEvalContext,\r\n                            fillRulePropertyDescriptor,\r\n                            fillRuleExpr.rule);\r\n\r\n                        let colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, ColumnIdentifierKind.QueryName, fillRule);\r\n                        if (colorAllocator)\r\n                            cache.register(fillRuleExpr, colorAllocator);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return cache;\r\n        }\r\n\r\n        function evaluateDataRepetition(\r\n            dataView: DataView,\r\n            targetDataViewKinds: StandardDataViewKinds,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');\r\n\r\n            let containsWildcard = Selector.containsWildcard(selector);\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Categorical)) {\r\n                // 1) Match against categories\r\n                evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // 2) Match against valueGrouping\r\n                evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewMatrix = dataView.matrix;\r\n            if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Matrix)) {\r\n                let rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenMatrix) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.matrix = rewrittenMatrix;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n\r\n            let dataViewTable = dataView.table;\r\n            if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, StandardDataViewKinds.Table)) {\r\n                let rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);\r\n                let rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);\r\n                if (rewrittenTable) {\r\n                    // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                    // revisit this, likely when we do lazy evaluation of DataView.\r\n                    dataView.table = rewrittenTable;\r\n                }\r\n\r\n                // Consider capturing diagnostics for unmatched selectors to help debugging.\r\n            }\r\n        }\r\n\r\n        function rewriteTableRoleSelector(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            if (Selector.hasRoleWildcard(selector)) {\r\n                selector = findSelectorForRoleWildcard(dataViewTable, selector);\r\n            }\r\n\r\n            return selector;\r\n        }\r\n\r\n        function findSelectorForRoleWildcard(dataViewTable: DataViewTable, selector: Selector): Selector {\r\n            let resultingSelector: Selector = {\r\n                data: [],\r\n                id: selector.id,\r\n                metadata: selector.metadata\r\n            };\r\n\r\n            for (let dataSelector of selector.data) {\r\n                if (Selector.isRoleWildcard(dataSelector)) {\r\n                    let selectorRoles = dataSelector.roles;\r\n                    let allColumnsBelongToSelectorRole: boolean = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);\r\n                    let exprs = dataViewTable.identityFields;\r\n                    if (allColumnsBelongToSelectorRole && exprs) {\r\n                        resultingSelector.data.push(DataViewScopeWildcard.fromExprs(<SQExpr[]>exprs));\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {\r\n                    resultingSelector.data.push(dataSelector);\r\n                }\r\n            }\r\n\r\n            return resultingSelector;\r\n        }\r\n\r\n        function isUniqueDataSelector(dataSelectors: DataRepetitionSelector[], newSelector: DataRepetitionSelector): boolean {\r\n            if (_.isEmpty(dataSelectors))\r\n                return true;\r\n\r\n            return !_.any(dataSelectors, (dataSelector: DataRepetitionSelector) => dataSelector.key === newSelector.key);\r\n        }\r\n\r\n        function allColumnsBelongToRole(columns: DataViewMetadataColumn[], selectorRoles: string[]): boolean {\r\n            for (let column of columns) {\r\n                var roles = column.roles;\r\n                if (!roles || !_.any(selectorRoles, (selectorRole) => roles[selectorRole]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalCategory(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)\r\n                return;\r\n\r\n            let targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);\r\n            if (!targetColumn)\r\n                return;\r\n\r\n            let identities = targetColumn.identities,\r\n                foundMatch: boolean,\r\n                evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            if (!identities)\r\n                return;\r\n\r\n            debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');\r\n\r\n            for (let i = 0, len = identities.length; i < len; i++) {\r\n                let identity = identities[i];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(i);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n                        if (!targetColumn.column.objects) {\r\n                            targetColumn.column.objects = [];\r\n                            targetColumn.column.objects.length = len;\r\n                        }\r\n                        targetColumn.column.objects[i] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n\r\n                    foundMatch = true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionCategoricalValueGrouping(\r\n            dataViewCategorical: DataViewCategorical,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): boolean {\r\n            debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(containsWildcard, 'containsWildcard');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let dataViewCategoricalValues = dataViewCategorical.values;\r\n            if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)\r\n                return;\r\n\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[dataViewCategoricalValues.identityFields]))\r\n                return;\r\n\r\n            let valuesGrouped = dataViewCategoricalValues.grouped();\r\n            if (!valuesGrouped)\r\n                return;\r\n\r\n            // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).\r\n            // This should be enhanced in the future.\r\n            let evalContext = createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);\r\n\r\n            let foundMatch: boolean;\r\n            for (let i = 0, len = valuesGrouped.length; i < len; i++) {\r\n                let valueGroup = valuesGrouped[i];\r\n                let selectorMetadata = selector.metadata;\r\n                let valuesInGroup = valueGroup.values;\r\n                if (containsWildcard || Selector.matchesData(selector, [valueGroup.identity])) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n                        // revisit this, likely when we do lazy evaluation of DataView.\r\n\r\n                        if (selectorMetadata) {\r\n                            for (let j = 0, jlen = valuesInGroup.length; j < jlen; j++) {\r\n                                let valueColumn = valuesInGroup[j],\r\n                                    valueSource = valueColumn.source;\r\n                                if (valueSource.queryName === selectorMetadata) {\r\n                                    let valueSourceOverwrite = Prototype.inherit(valueSource);\r\n                                    valueSourceOverwrite.objects = objects;\r\n                                    valueColumn.source = valueSourceOverwrite;\r\n\r\n                                    foundMatch = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        else {\r\n                            valueGroup.objects = objects;\r\n                            setGrouped(dataViewCategoricalValues, valuesGrouped);\r\n\r\n                            foundMatch = true;\r\n                        }\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        return true;\r\n                }\r\n            }\r\n\r\n            return foundMatch;\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrix(\r\n            dataViewMatrix: DataViewMatrix,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewMatrix {\r\n\r\n            let evalContext = createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);\r\n            let rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            let rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n\r\n            if (rewrittenRows || rewrittenCols) {\r\n                let rewrittenMatrix = inheritSingle(dataViewMatrix);\r\n\r\n                if (rewrittenRows)\r\n                    rewrittenMatrix.rows = rewrittenRows;\r\n                if (rewrittenCols)\r\n                    rewrittenMatrix.columns = rewrittenCols;\r\n\r\n                return rewrittenMatrix;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixHierarchy(\r\n            evalContext: IEvalContext,\r\n            dataViewMatrixHierarchy: DataViewHierarchy,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewHierarchy {\r\n            debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (!dataViewMatrixHierarchy)\r\n                return;\r\n\r\n            let root = dataViewMatrixHierarchy.root;\r\n            if (!root)\r\n                return;\r\n\r\n            let rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);\r\n            if (rewrittenRoot) {\r\n                let rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);\r\n                rewrittenHierarchy.root = rewrittenRoot;\r\n\r\n                return rewrittenHierarchy;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionMatrixNode(\r\n            evalContext: IEvalContext,\r\n            dataViewNode: DataViewMatrixNode,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewMatrixNode {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(dataViewNode, 'dataViewNode');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            let childNodes = dataViewNode.children;\r\n            if (!childNodes)\r\n                return;\r\n\r\n            let rewrittenNode: DataViewMatrixNode;\r\n            let shouldSearchChildren: boolean;\r\n            let childIdentityFields = dataViewNode.childIdentityFields;\r\n            if (childIdentityFields) {\r\n                // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.\r\n                shouldSearchChildren = Selector.matchesKeys(selector, <SQExpr[][]>[childIdentityFields]);\r\n            }\r\n\r\n            for (let i = 0, len = childNodes.length; i < len; i++) {\r\n                let childNode = childNodes[i],\r\n                    identity = childNode.identity,\r\n                    rewrittenChildNode: DataViewMatrixNode = null;\r\n\r\n                if (shouldSearchChildren) {\r\n                    if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                        // TODO: Need to initialize context for rule-based properties.  Rule-based properties\r\n                        // (such as fillRule/gradients) are not currently implemented.\r\n\r\n                        let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                        if (objects) {\r\n                            rewrittenChildNode = inheritSingle(childNode);\r\n                            rewrittenChildNode.objects = objects;\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    rewrittenChildNode = evaluateDataRepetitionMatrixNode(\r\n                        evalContext,\r\n                        childNode,\r\n                        objectDescriptors,\r\n                        selector,\r\n                        rules,\r\n                        containsWildcard,\r\n                        objectDefns);\r\n                }\r\n\r\n                if (rewrittenChildNode) {\r\n                    if (!rewrittenNode)\r\n                        rewrittenNode = inheritNodeAndChildren(dataViewNode);\r\n                    rewrittenNode.children[i] = rewrittenChildNode;\r\n\r\n                    if (!containsWildcard) {\r\n                        // NOTE: once we find a match for a non-wildcard selector, stop looking.\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return rewrittenNode;\r\n        }\r\n\r\n        function inheritNodeAndChildren(node: DataViewMatrixNode): DataViewMatrixNode {\r\n            if (Object.getPrototypeOf(node) !== Object.prototype) {\r\n                return node;\r\n            }\r\n\r\n            let inherited = inheritSingle(node);\r\n            inherited.children = inherit(node.children);\r\n            return inherited;\r\n        }\r\n\r\n        function evaluateDataRepetitionTable(\r\n            dataViewTable: DataViewTable,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): DataViewTable {\r\n            debug.assertValue(dataViewTable, 'dataViewTable');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            let evalContext = createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);\r\n            let rewrittenRows = evaluateDataRepetitionTableRows(\r\n                evalContext,\r\n                dataViewTable.columns,\r\n                dataViewTable.rows,\r\n                dataViewTable.identity,\r\n                dataViewTable.identityFields,\r\n                objectDescriptors,\r\n                selector,\r\n                rules,\r\n                containsWildcard,\r\n                objectDefns);\r\n\r\n            if (rewrittenRows) {\r\n                let rewrittenTable = inheritSingle(dataViewTable);\r\n                rewrittenTable.rows = rewrittenRows;\r\n\r\n                return rewrittenTable;\r\n            }\r\n        }\r\n\r\n        function evaluateDataRepetitionTableRows(\r\n            evalContext: ITableEvalContext,\r\n            columns: DataViewMetadataColumn[],\r\n            rows: DataViewTableRow[],\r\n            identities: DataViewScopeIdentity[],\r\n            identityFields: ISQExpr[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            rules: RuleEvaluation[],\r\n            containsWildcard: boolean,\r\n            objectDefns: DataViewNamedObjectDefinition[]): DataViewTableRow[] {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n            debug.assertValue(columns, 'columns');\r\n            debug.assertValue(rows, 'rows');\r\n            debug.assertAnyValue(identities, 'identities');\r\n            debug.assertAnyValue(identityFields, 'identityFields');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertAnyValue(rules, 'rules');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n\r\n            if (_.isEmpty(identities) || _.isEmpty(identityFields))\r\n                return;\r\n\r\n            if (!selector.metadata ||\r\n                !Selector.matchesKeys(selector, <SQExpr[][]>[identityFields]))\r\n                return;\r\n\r\n            let colIdx = _.findIndex(columns, col => col.queryName === selector.metadata);\r\n            if (colIdx < 0)\r\n                return;\r\n\r\n            debug.assert(rows.length === identities.length, 'row length mismatch');\r\n            let colLen = columns.length;\r\n            let inheritedRows: DataViewTableRow[];\r\n\r\n            for (let rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {\r\n                let identity = identities[rowIdx];\r\n\r\n                if (containsWildcard || Selector.matchesData(selector, [identity])) {\r\n                    evalContext.setCurrentRowIndex(rowIdx);\r\n\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects) {\r\n                        if (!inheritedRows)\r\n                            inheritedRows = inheritSingle(rows);\r\n\r\n                        let inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);\r\n                        let objectsForColumns = inheritedRow.objects;\r\n                        if (!objectsForColumns)\r\n                            inheritedRow.objects = objectsForColumns = new Array(colLen);\r\n\r\n                        objectsForColumns[colIdx] = objects;\r\n                    }\r\n\r\n                    if (!containsWildcard)\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return inheritedRows;\r\n        }\r\n\r\n        function evaluateMetadataRepetition(\r\n            dataView: DataView,\r\n            selectTransforms: DataViewSelectTransform[],\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            selector: Selector,\r\n            objectDefns: DataViewNamedObjectDefinition[],\r\n            colorAllocatorCache: IColorAllocatorCache): void {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(selector, 'selector');\r\n            debug.assertValue(objectDefns, 'objectDefns');\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n\r\n            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should\r\n            // revisit this, likely when we do lazy evaluation of DataView.\r\n            let columns = dataView.metadata.columns,\r\n                metadataId = selector.metadata,\r\n                evalContext = createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                let column = columns[i];\r\n                if (column.queryName === metadataId) {\r\n                    let objects = DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);\r\n                    if (objects)\r\n                        column.objects = objects;\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Attempts to find a column that can possibly match the selector. */\r\n        function findSelectedCategoricalColumn(dataViewCategorical: DataViewCategorical, selector: Selector) {\r\n            debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');\r\n\r\n            let categoricalColumn = dataViewCategorical.categories[0];\r\n            if (!categoricalColumn.identityFields)\r\n                return;\r\n            if (!Selector.matchesKeys(selector, <SQExpr[][]>[categoricalColumn.identityFields]))\r\n                return;\r\n\r\n            let identities = categoricalColumn.identity,\r\n                targetColumn: DataViewCategoricalColumn = categoricalColumn;\r\n\r\n            let selectedMetadataId = selector.metadata;\r\n            if (selectedMetadataId) {\r\n                let valueColumns = dataViewCategorical.values;\r\n                if (valueColumns) {\r\n                    for (let i = 0, len = valueColumns.length; i < len; i++) {\r\n                        let valueColumn = valueColumns[i];\r\n                        if (valueColumn.source.queryName === selectedMetadataId) {\r\n                            targetColumn = valueColumn;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                column: targetColumn,\r\n                identities: identities,\r\n            };\r\n        }\r\n\r\n        function findSelectorForRuleInput(dataView: DataView, selectorRoles: string[]): Selector {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectorRoles, 'selectorRoles');\r\n\r\n            if (selectorRoles.length !== 1)\r\n                return;\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return;\r\n\r\n            let categories = dataViewCategorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let categoryColumn = categories[0],\r\n                categoryRoles = categoryColumn.source.roles,\r\n                categoryIdentityFields = categoryColumn.identityFields;\r\n            if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])\r\n                return;\r\n\r\n            return { data: [DataViewScopeWildcard.fromExprs(<SQExpr[]>categoryIdentityFields)] };\r\n        }\r\n\r\n        function findFirstQueryNameForExpr(selectTransforms: DataViewSelectTransform[], expr: SQExpr): string {\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (!selectTransforms)\r\n                return;\r\n\r\n            for (let i = 0, len = selectTransforms.length; i < len; i++) {\r\n                let select = selectTransforms[i],\r\n                    columnExpr = select.expr;\r\n\r\n                if (!columnExpr || !SQExpr.equals(expr, select.expr))\r\n                    continue;\r\n\r\n                return select.queryName;\r\n            }\r\n        }\r\n\r\n        /** Attempts to find the value range for the single column with the given identifier/identifierKind. */\r\n        function findRuleInputColumnNumberRange(dataView: DataView, identifier: string, identifierKind: ColumnIdentifierKind): NumberRange {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(identifier, 'identifier');\r\n            debug.assertValue(identifierKind, 'identifierKind');\r\n\r\n            // NOTE: This implementation currently only supports categorical DataView, becuase that's the\r\n            // only scenario that has custom colors, as of this writing.  This would be rewritten to be more generic\r\n            // as required, when needed.\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return;\r\n\r\n            let values = dataViewCategorical.values;\r\n            if (!values)\r\n                return;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let valueCol = values[i];\r\n\r\n                if (identifierKind === ColumnIdentifierKind.Role) {\r\n                    let valueColRoles = valueCol.source.roles;\r\n\r\n                    if (!valueColRoles || !valueColRoles[identifier])\r\n                        continue;\r\n                }\r\n                else {\r\n                    debug.assert(identifierKind === ColumnIdentifierKind.QueryName, 'identifierKind === ColumnIdentifierKind.QueryName');\r\n\r\n                    if (valueCol.source.queryName !== identifier)\r\n                        continue;\r\n                }\r\n\r\n                let min = valueCol.min;\r\n                if (min === undefined)\r\n                    min = valueCol.minLocal;\r\n                if (min === undefined)\r\n                    continue;\r\n\r\n                let max = valueCol.max;\r\n                if (max === undefined)\r\n                    max = valueCol.maxLocal;\r\n                if (max === undefined)\r\n                    continue;\r\n\r\n                return { min: min, max: max };\r\n            }\r\n        }\r\n\r\n        // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product\r\n        export function createValueColumns(\r\n            values: DataViewValueColumn[] = [],\r\n            valueIdentityFields?: SQExpr[],\r\n            source?: DataViewMetadataColumn): DataViewValueColumns {\r\n            let result = <DataViewValueColumns>values;\r\n            setGrouped(<DataViewValueColumns>values);\r\n\r\n            if (valueIdentityFields)\r\n                result.identityFields = valueIdentityFields;\r\n\r\n            if (source)\r\n                result.source = source;\r\n\r\n            return result;\r\n        }\r\n\r\n        export function setGrouped(values: DataViewValueColumns, groupedResult?: DataViewValueColumnGroup[]): void {\r\n            values.grouped = groupedResult\r\n                ? () => groupedResult\r\n                : () => groupValues(values);\r\n        }\r\n\r\n        /** Group together the values with a common identity. */\r\n        function groupValues(values: DataViewValueColumn[]): DataViewValueColumnGroup[] {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let groups: DataViewValueColumnGroup[] = [],\r\n                currentGroup: DataViewValueColumnGroup;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n\r\n                if (!currentGroup || currentGroup.identity !== value.identity) {\r\n                    currentGroup = {\r\n                        values: []\r\n                    };\r\n\r\n                    if (value.identity) {\r\n                        currentGroup.identity = value.identity;\r\n\r\n                        let source = value.source;\r\n\r\n                        // allow null, which will be formatted as (Blank).\r\n                        if (source.groupName !== undefined)\r\n                            currentGroup.name = source.groupName;\r\n                        else if (source.displayName)\r\n                            currentGroup.name = source.displayName;\r\n                    }\r\n\r\n                    groups.push(currentGroup);\r\n                }\r\n\r\n                currentGroup.values.push(value);\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function pivotIfNecessary(dataView: DataView, dataViewMappings: DataViewMapping[]): DataView {\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            let transformedDataView: DataView;\r\n            switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {\r\n                case CategoricalDataViewTransformation.Pivot:\r\n                    transformedDataView = DataViewPivotCategorical.apply(dataView);\r\n                    break;\r\n\r\n                case CategoricalDataViewTransformation.SelfCrossJoin:\r\n                    transformedDataView = DataViewSelfCrossJoin.apply(dataView);\r\n                    break;\r\n            }\r\n\r\n            return transformedDataView || dataView;\r\n        }\r\n\r\n        function determineCategoricalTransformation(categorical: DataViewCategorical, dataViewMappings: DataViewMapping[]): CategoricalDataViewTransformation {\r\n            if (!categorical || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let categories = categorical.categories;\r\n            if (!categories || categories.length !== 1)\r\n                return;\r\n\r\n            let values = categorical.values;\r\n            if (_.isEmpty(values))\r\n                return;\r\n\r\n            if (values.grouped().some(vg => !!vg.identity))\r\n                return;\r\n\r\n            // If we made it here, the DataView has a single category and no valueGrouping.\r\n            let categoryRoles = categories[0].source.roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingCategorical = dataViewMappings[i].categorical;\r\n                if (!roleMappingCategorical)\r\n                    continue;\r\n\r\n                if (!hasRolesGrouped(categoryRoles, <DataViewGroupedRoleMapping>roleMappingCategorical.values))\r\n                    continue;\r\n\r\n                // If we made it here, the DataView's single category has the value grouping role.\r\n                let categoriesMapping = roleMappingCategorical.categories;\r\n                let hasCategoryRole =\r\n                    hasRolesBind(categoryRoles, <DataViewRoleBindMappingWithReduction>categoriesMapping) ||\r\n                    hasRolesFor(categoryRoles, <DataViewRoleForMappingWithReduction>categoriesMapping);\r\n\r\n                if (hasCategoryRole)\r\n                    return CategoricalDataViewTransformation.SelfCrossJoin;\r\n\r\n                return CategoricalDataViewTransformation.Pivot;\r\n            }\r\n        }\r\n\r\n        function shouldPivotMatrix(matrix: DataViewMatrix, dataViewMappings: DataViewMapping[]): boolean {\r\n            if (!matrix || _.isEmpty(dataViewMappings))\r\n                return;\r\n\r\n            let rowLevels = matrix.rows.levels;\r\n            if (rowLevels.length < 1)\r\n                return;\r\n\r\n            let rows = matrix.rows.root.children;\r\n            if (!rows || rows.length === 0)\r\n                return;\r\n\r\n            let rowRoles = rowLevels[0].sources[0].roles;\r\n\r\n            for (let i = 0, len = dataViewMappings.length; i < len; i++) {\r\n                let roleMappingMatrix = dataViewMappings[i].matrix;\r\n                if (!roleMappingMatrix)\r\n                    continue;\r\n\r\n                if (!hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.rows) &&\r\n                    hasRolesFor(rowRoles, <DataViewRoleForMappingWithReduction>roleMappingMatrix.columns)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        function hasRolesBind(roles: { [name: string]: boolean }, roleMapping: DataViewRoleBindMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.bind)\r\n                return roles[roleMapping.bind.to];\r\n        }\r\n\r\n        function hasRolesFor(roles: { [name: string]: boolean }, roleMapping: DataViewRoleForMappingWithReduction): boolean {\r\n            if (roles && roleMapping && roleMapping.for)\r\n                return roles[roleMapping.for.in];\r\n        }\r\n\r\n        function hasRolesGrouped(roles: { [name: string]: boolean }, roleMapping: DataViewGroupedRoleMapping): boolean {\r\n            if (roles && roleMapping && roleMapping.group)\r\n                return roles[roleMapping.group.by];\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import IStringResourceProvider = jsCommon.IStringResourceProvider;\r\n\r\n    export function createDisplayNameGetter(displayNameKey: string): (IStringResourceProvider) => string {\r\n        return (resourceProvider: IStringResourceProvider) => resourceProvider.get(displayNameKey);\r\n    }\r\n\r\n    export function getDisplayName(displayNameGetter: data.DisplayNameGetter, resourceProvider: jsCommon.IStringResourceProvider): string {\r\n        if (typeof displayNameGetter === 'function')\r\n            return displayNameGetter(resourceProvider);\r\n\r\n        if (typeof displayNameGetter === 'string')\r\n            return displayNameGetter;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    /** Enumeration of DateTimeUnits */\r\n    export enum DateTimeUnit {\r\n        Year,\r\n        Month,\r\n        Week,\r\n        Day,\r\n        Hour,\r\n        Minute,\r\n        Second,\r\n        Millisecond,\r\n    }\r\n\r\n    export interface IFormattingService {\r\n        /** \r\n         * Formats the value using provided format expression and culture\r\n         * @param value - value to be formatted and converted to string.\r\n         * @param format - format to be applied. If undefined or empty then generic format is used.        \r\n         */\r\n        formatValue(value: any, format?: string): string;\r\n\r\n        /** \r\n         * Replaces the indexed format tokens (for example {0:c2}) in the format string with the localized formatted arguments.\r\n         * @param formatWithIndexedTokens - format string with a set of indexed format tokens.\r\n         * @param args - array of values which should replace the tokens in the format string.\r\n         * @param culture - localization culture. If undefined then the current culture is used.\r\n         */\r\n        format(formatWithIndexedTokens: string, args: any[], culture?: string): string;\r\n\r\n        /** Gets a value indicating whether the specified format a standard numeric format specifier. */\r\n        isStandardNumberFormat(format: string): boolean;\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string): string;\r\n\r\n        /** Gets the format string to use for dates in particular units. */\r\n        dateFormatString(unit: DateTimeUnit): string;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Represents common expression patterns for 'field' expressions such as columns, column aggregates, measures, etc. */\r\n    export interface FieldExprPattern {\r\n        column?: FieldExprColumnPattern;\r\n        columnAggr?: FieldExprColumnAggrPattern;\r\n        columnHierarchyLevelVariation?: FieldExprColumnHierarchyLevelVariationPattern;\r\n        entity?: FieldExprEntityPattern;\r\n        entityAggr?: FieldExprEntityAggrPattern;\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        hierarchyLevel?: FieldExprHierarchyLevelPattern;\r\n        hierarchyLevelAggr?: FieldExprHierarchyLevelAggrPattern;\r\n        measure?: FieldExprMeasurePattern;\r\n        percentile?: FieldExprPercentilePattern;\r\n        percentOfGrandTotal?: FieldExprPercentOfGrandTotalPattern;\r\n    }\r\n\r\n    /** By design there is no default, no-op visitor. Components concerned with patterns need to be aware of all patterns as they are added. */\r\n    export interface IFieldExprPatternVisitor<T> {\r\n        visitColumn(column: FieldExprColumnPattern): T;\r\n        visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): T;\r\n        visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): T;\r\n        visitEntity(entity: FieldExprEntityPattern): T;\r\n        visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): T;\r\n        visitHierarchy(hierarchy: FieldExprHierarchyPattern): T;\r\n        visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): T;\r\n        visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): T;\r\n        visitMeasure(measure: FieldExprMeasurePattern): T;\r\n        visitPercentile(percentile: FieldExprPercentilePattern): T;\r\n        visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): T;\r\n    }\r\n\r\n    export interface FieldExprEntityPattern {\r\n        schema: string;\r\n        entity: string;\r\n        entityVar?: string;\r\n    }\r\n\r\n    export interface FieldExprEntityItemPattern extends FieldExprEntityPattern {\r\n    }\r\n\r\n    export interface FieldExprEntityPropertyPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n    }\r\n\r\n    export type FieldExprColumnPattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprMeasurePattern = FieldExprEntityPropertyPattern;\r\n    export type FieldExprHierarchyPattern = FieldExprEntityPropertyPattern;\r\n\r\n    export type FieldExprPropertyPattern = FieldExprColumnPattern | FieldExprMeasurePattern | FieldExprHierarchyPattern;\r\n\r\n    export interface FieldExprEntityAggrPattern extends FieldExprEntityPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnAggrPattern extends FieldExprColumnPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelPattern extends FieldExprEntityItemPattern {\r\n        name: string;\r\n        level: string;\r\n    }\r\n\r\n    export interface FieldExprHierarchyLevelAggrPattern extends FieldExprHierarchyLevelPattern {\r\n        aggregate: QueryAggregateFunction;\r\n    }\r\n\r\n    export interface FieldExprColumnHierarchyLevelVariationPattern {\r\n        source: FieldExprColumnPattern;\r\n        level: FieldExprHierarchyLevelPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    export interface FieldExprPercentilePattern {\r\n        arg: FieldExprPattern;\r\n        k: number;\r\n        exclusive: boolean;\r\n    }\r\n\r\n    export interface FieldExprPercentOfGrandTotalPattern {\r\n        baseExpr: FieldExprPattern;\r\n    }\r\n\r\n    export module SQExprBuilder {\r\n        export function fieldExpr(fieldExpr: FieldExprPattern): SQExpr {\r\n            let sqExpr = FieldExprPattern.visit<SQExpr>(fieldExpr, FieldExprToSQExprVisitor.instance);\r\n            debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');\r\n            return sqExpr;\r\n        }\r\n\r\n        export function fromColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromColumn(columnAggr), columnAggr.aggregate);\r\n        }\r\n\r\n        export function fromColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return columnRef(fromEntity(column), column.name);\r\n        }\r\n\r\n        export function fromEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n            return entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);\r\n        }\r\n\r\n        export function fromEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromEntity(entityAggr), entityAggr.aggregate);\r\n        }\r\n\r\n        export function fromHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n            return aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);\r\n        }\r\n\r\n        export function fromHierarchyLevel(hierarchyLevelPattern: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n            return hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);\r\n        }\r\n\r\n        export function fromHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n            return hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);\r\n        }\r\n\r\n        class FieldExprToSQExprVisitor implements IFieldExprPatternVisitor<SQExpr> {\r\n            public static instance: FieldExprToSQExprVisitor = new FieldExprToSQExprVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): SQColumnRefExpr {\r\n                return fromColumn(column);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQAggregationExpr {\r\n                return fromColumnAggr(columnAggr);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariationPattern: FieldExprColumnHierarchyLevelVariationPattern): SQPropertyVariationSourceExpr {\r\n                return propertyVariationSource(\r\n                    this.visitEntity(columnHierarchyLevelVariationPattern.source),\r\n                    columnHierarchyLevelVariationPattern.source.name,\r\n                    columnHierarchyLevelVariationPattern.level.name);\r\n            }\r\n\r\n            public visitEntity(entityPattern: FieldExprEntityPattern): SQEntityExpr {\r\n                return fromEntity(entityPattern);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQAggregationExpr {\r\n                return fromEntityAggr(entityAggr);\r\n            }\r\n\r\n            public visitHierarchy(hierarchyPattern: FieldExprHierarchyPattern): SQHierarchyExpr {\r\n                return fromHierarchy(hierarchyPattern);\r\n            }\r\n\r\n            public visitHierarchyLevel(level: FieldExprHierarchyLevelPattern): SQHierarchyLevelExpr {\r\n                return fromHierarchyLevel(level);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQAggregationExpr {\r\n                return fromHierarchyLevelAggr(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): SQMeasureRefExpr {\r\n                return measureRef(this.visitEntity(measure), measure.name);\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): SQPercentileExpr {\r\n                let arg = SQExprBuilder.fieldExpr(percentile.arg);\r\n                return SQExprBuilder.percentile(arg, percentile.k, percentile.exclusive);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): SQArithmeticExpr {\r\n                let baseSQExpr = SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr);\r\n                return arithmetic(\r\n                    baseSQExpr,\r\n                    SQExprBuilder.scopedEval(baseSQExpr, []),\r\n                    ArithmeticOperatorKind.Divide);\r\n            }\r\n        }\r\n    }\r\n\r\n    export module SQExprConverter {\r\n        export function asFieldPattern(sqExpr: SQExpr): FieldExprPattern {\r\n            return sqExpr.accept(FieldExprPatternBuilder.instance);\r\n        }\r\n    }\r\n\r\n    interface FieldExprSourceVariationPattern {\r\n        column: FieldExprColumnPattern;\r\n        variationName: string;\r\n    }\r\n\r\n    interface SourceExprPattern {\r\n        entity?: FieldExprEntityPattern;\r\n\r\n        // TODO: Change FieldExprHierarchyPattern to FieldExprHierarchyLevelPattern\r\n        hierarchy?: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    interface HierarchySourceExprPattern {\r\n        hierarchy: FieldExprHierarchyPattern;\r\n        variation?: FieldExprSourceVariationPattern;\r\n    }\r\n\r\n    class FieldExprPatternBuilder extends DefaultSQExprVisitor<FieldExprPattern> {\r\n        public static instance: FieldExprPatternBuilder = new FieldExprPatternBuilder();\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let columnRef = <FieldExprColumnPattern>sourceRef.entity;\r\n                columnRef.name = expr.ref;\r\n\r\n                return { column: columnRef };\r\n            }\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): FieldExprPattern {\r\n            let sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);\r\n            if (!sourceRef)\r\n                return;\r\n\r\n            if (sourceRef.entity) {\r\n                let measureRef = <FieldExprMeasurePattern>sourceRef.entity;\r\n                measureRef.name = expr.ref;\r\n\r\n                return { measure: measureRef };\r\n            }\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): FieldExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): FieldExprPattern {\r\n            let fieldPattern: FieldExprPattern = expr.arg.accept(this);\r\n            if (fieldPattern && fieldPattern.column) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.column;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.columnAggr) {\r\n                let argAggr = <FieldExprColumnAggrPattern>fieldPattern.columnAggr;\r\n                argAggr.aggregate = expr.func;\r\n                return { columnAggr: argAggr };\r\n            } else if (fieldPattern && fieldPattern.hierarchyLevel) {\r\n                let argAggr = <FieldExprHierarchyLevelAggrPattern>fieldPattern.hierarchyLevel;\r\n                argAggr.aggregate = expr.func;\r\n                return { hierarchyLevelAggr: argAggr };\r\n            }\r\n\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let argAggr = <FieldExprEntityAggrPattern>sourcePattern.entity;\r\n                argAggr.aggregate = expr.func;\r\n\r\n                return { entityAggr: argAggr };\r\n            }\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): FieldExprPattern {\r\n            return {\r\n                percentile: {\r\n                    arg: expr.arg.accept(this),\r\n                    k: expr.k,\r\n                    exclusive: expr.exclusive,\r\n                }\r\n            };\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): FieldExprPattern {\r\n            let sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n\r\n            if (sourcePattern && sourcePattern.entity) {\r\n                let hierarchyRef = <FieldExprHierarchyPattern>(sourcePattern.entity);\r\n                hierarchyRef.name = expr.hierarchy;\r\n                return { hierarchy: hierarchyRef };\r\n            }\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): FieldExprPattern {\r\n            let hierarchySourceExprPattern: HierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);\r\n            if (!hierarchySourceExprPattern)\r\n                return;\r\n\r\n            let hierarchyLevel: FieldExprHierarchyLevelPattern;\r\n            if (hierarchySourceExprPattern.hierarchy) {\r\n                hierarchyLevel = {\r\n                    entity: hierarchySourceExprPattern.hierarchy.entity,\r\n                    schema: hierarchySourceExprPattern.hierarchy.schema,\r\n                    name: hierarchySourceExprPattern.hierarchy.name,\r\n                    level: expr.level,\r\n                };\r\n            }\r\n\r\n            if (hierarchySourceExprPattern.variation) {\r\n                return {\r\n                    columnHierarchyLevelVariation: {\r\n                        source: {\r\n                            entity: hierarchySourceExprPattern.variation.column.entity,\r\n                            schema: hierarchySourceExprPattern.variation.column.schema,\r\n                            name: hierarchySourceExprPattern.variation.column.name,\r\n                        },\r\n                        level: hierarchyLevel,\r\n                        variationName: hierarchySourceExprPattern.variation.variationName,\r\n                    }\r\n                };\r\n            }\r\n\r\n            return { hierarchyLevel: hierarchyLevel };\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): FieldExprPattern {\r\n            let percentOfGrandTotalPattern: FieldExprPattern = {\r\n                percentOfGrandTotal: {\r\n                    baseExpr: expr.left.accept(this)\r\n                }\r\n            };\r\n\r\n            if (SQExpr.equals(expr, SQExprBuilder.fieldExpr(percentOfGrandTotalPattern))) {\r\n                return percentOfGrandTotalPattern;\r\n            }\r\n        }\r\n    }\r\n\r\n    class SourceExprPatternBuilder extends DefaultSQExprVisitor<SourceExprPattern> {\r\n        public static instance: SourceExprPatternBuilder = new SourceExprPatternBuilder();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SourceExprPattern {\r\n            let entityRef: FieldExprEntityPattern = {\r\n                schema: expr.schema,\r\n                entity: expr.entity\r\n            };\r\n            if (expr.variable)\r\n                entityRef.entityVar = expr.variable;\r\n\r\n            return { entity: entityRef };\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SourceExprPattern {\r\n            let entityExpr = <SQEntityExpr>expr.arg;\r\n\r\n            if (entityExpr instanceof SQEntityExpr) {\r\n                let propertyVariationSource: FieldExprColumnPattern = {\r\n                    schema: entityExpr.schema,\r\n                    entity: entityExpr.entity,\r\n                    name: expr.property,\r\n                };\r\n\r\n                if (entityExpr.variable)\r\n                    propertyVariationSource.entityVar = entityExpr.variable;\r\n\r\n                return {\r\n                    variation: {\r\n                        column: propertyVariationSource,\r\n                        variationName: expr.name,\r\n                    }\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    class HierarchyExprPatternBuiler extends DefaultSQExprVisitor<HierarchySourceExprPattern> {\r\n        public static instance: HierarchyExprPatternBuiler = new HierarchyExprPatternBuiler();\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): HierarchySourceExprPattern {\r\n            let exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);\r\n            let hierarchyRef: FieldExprHierarchyPattern;\r\n            let variationRef: FieldExprSourceVariationPattern;\r\n\r\n            if (exprPattern.variation) {\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.variation.column.schema,\r\n                    entity: exprPattern.variation.column.entity,\r\n                };\r\n                variationRef = exprPattern.variation;\r\n            }\r\n            else\r\n                hierarchyRef = {\r\n                    name: expr.hierarchy,\r\n                    schema: exprPattern.entity.schema,\r\n                    entity: exprPattern.entity.entity,\r\n                };\r\n\r\n            return {\r\n                hierarchy: hierarchyRef,\r\n                variation: variationRef\r\n            };\r\n        }\r\n    }\r\n\r\n    export module FieldExprPattern {\r\n\r\n        export function visit<T>(expr: SQExpr | FieldExprPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            let fieldExprPattern = expr instanceof SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;\r\n            debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');\r\n\r\n            if (fieldExprPattern.column)\r\n                return visitColumn(fieldExprPattern.column, visitor);\r\n            if (fieldExprPattern.columnAggr)\r\n                return visitColumnAggr(fieldExprPattern.columnAggr, visitor);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation)\r\n                return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);\r\n            if (fieldExprPattern.entity)\r\n                return visitEntity(fieldExprPattern.entity, visitor);\r\n            if (fieldExprPattern.entityAggr)\r\n                return visitEntityAggr(fieldExprPattern.entityAggr, visitor);\r\n            if (fieldExprPattern.hierarchy)\r\n                return visitHierarchy(fieldExprPattern.hierarchy, visitor);\r\n            if (fieldExprPattern.hierarchyLevel)\r\n                return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);\r\n            if (fieldExprPattern.hierarchyLevelAggr)\r\n                return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);\r\n            if (fieldExprPattern.measure)\r\n                return visitMeasure(fieldExprPattern.measure, visitor);\r\n            if (fieldExprPattern.percentile)\r\n                return visitPercentile(fieldExprPattern.percentile, visitor);\r\n            if (fieldExprPattern.percentOfGrandTotal)\r\n                return visitPercentOfGrandTotal(fieldExprPattern.percentOfGrandTotal, visitor);\r\n\r\n            debug.assertFail('failed to visit a fieldExprPattern.');\r\n            return;\r\n        }\r\n\r\n        function visitColumn<T>(column: FieldExprColumnPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(column, 'column');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumn(column);\r\n        }\r\n\r\n        function visitColumnAggr<T>(columnAggr: FieldExprColumnAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(columnAggr, 'columnAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnAggr(columnAggr);\r\n        }\r\n\r\n        function visitColumnHierarchyLevelVariation<T>(\r\n            columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern,\r\n            visitor: IFieldExprPatternVisitor<T>): T {\r\n\r\n            debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);\r\n        }\r\n\r\n        function visitEntity<T>(entity: FieldExprEntityPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(entity, 'entity');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntity(entity);\r\n        }\r\n\r\n        function visitEntityAggr<T>(entityAggr: FieldExprEntityAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(entityAggr, 'entityAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitEntityAggr(entityAggr);\r\n        }\r\n\r\n        function visitHierarchy<T>(hierarchy: FieldExprHierarchyPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchy(hierarchy);\r\n        }\r\n\r\n        function visitHierarchyLevel<T>(hierarchyLevel: FieldExprHierarchyLevelPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchyLevel, 'hierarchyLevel');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevel(hierarchyLevel);\r\n        }\r\n\r\n        function visitHierarchyLevelAggr<T>(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);\r\n        }\r\n\r\n        function visitMeasure<T>(measure: FieldExprMeasurePattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(measure, 'measure');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitMeasure(measure);\r\n        }\r\n\r\n        function visitPercentile<T>(percentile: FieldExprPercentilePattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(percentile, 'percentile');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitPercentile(percentile);\r\n        }\r\n\r\n        function visitPercentOfGrandTotal<T>(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern, visitor: IFieldExprPatternVisitor<T>): T {\r\n            debug.assertValue(percentOfGrandTotal, 'percentOfGrandTotal');\r\n            debug.assertValue(visitor, 'visitor');\r\n\r\n            return visitor.visitPercentOfGrandTotal(percentOfGrandTotal);\r\n        }\r\n\r\n        export function toColumnRefSQExpr(columnPattern: FieldExprColumnPattern): SQColumnRefExpr {\r\n            return SQExprBuilder.columnRef(\r\n                SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar),\r\n                columnPattern.name);\r\n        }\r\n\r\n        export function getAggregate(fieldExpr: FieldExprPattern): QueryAggregateFunction {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n\r\n            return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);\r\n        }\r\n\r\n        export function isAggregation(fieldExpr: FieldExprPattern): boolean {\r\n            debug.assertValue(fieldExpr, 'fieldExpr');\r\n\r\n            return visit(fieldExpr, FieldExprPatternIsAggregationVisitor.instance);\r\n        }\r\n\r\n        export function hasFieldExprName(fieldExpr: FieldExprPattern): boolean {\r\n            return (fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.measure) !== undefined;\r\n        }\r\n\r\n        export function getPropertyName(fieldExpr: FieldExprPattern): string {\r\n            let column = (fieldExpr.column ||\r\n                fieldExpr.columnAggr ||\r\n                fieldExpr.measure);\r\n\r\n            if (column)\r\n                return column.name;\r\n        }\r\n\r\n        export function getHierarchyName(fieldExpr: FieldExprPattern): string {\r\n            let hierarchy = fieldExpr.hierarchy;\r\n            if (hierarchy)\r\n                return hierarchy.name;\r\n        }\r\n\r\n        export function getColumnRef(fieldExpr: FieldExprPattern): FieldExprPropertyPattern {\r\n            if (fieldExpr.columnHierarchyLevelVariation)\r\n                return fieldExpr.columnHierarchyLevelVariation.source;\r\n\r\n            return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;\r\n        }\r\n\r\n        export function getFieldExprName(fieldExpr: FieldExprPattern): string {\r\n            let name = getPropertyName(fieldExpr);\r\n\r\n            if (name)\r\n                return name;\r\n\r\n            // In case it is an entity\r\n            return toFieldExprEntityPattern(fieldExpr).entity;\r\n        }\r\n\r\n        export function toFieldExprEntityPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        export function toFieldExprEntityItemPattern(fieldExpr: FieldExprPattern): FieldExprEntityPattern {\r\n            return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);\r\n        }\r\n\r\n        class FieldExprPatternAggregateVisitor implements IFieldExprPatternVisitor<QueryAggregateFunction> {\r\n            public static instance: FieldExprPatternAggregateVisitor = new FieldExprPatternAggregateVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): QueryAggregateFunction {\r\n                return columnAggr.aggregate;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): QueryAggregateFunction {\r\n                return entityAggr.aggregate;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): QueryAggregateFunction {\r\n                return hierarchyLevelAggr.aggregate;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): QueryAggregateFunction {\r\n                return;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): QueryAggregateFunction {\r\n                // NOTE: Percentile behaves like an aggregate (i.e., can be performed over numeric columns like a SUM), but\r\n                // this function can't really convey that because percentile (intentionally) isn't in QueryAggregateFunction enum.\r\n                // This should be revisited when we have UI support for the Percentile aggregate.\r\n                return;\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): QueryAggregateFunction {\r\n                return SQExprInfo.getAggregate(SQExprBuilder.fieldExpr(percentOfGrandTotal.baseExpr));\r\n            }\r\n        }\r\n\r\n        class FieldExprPatternIsAggregationVisitor implements IFieldExprPatternVisitor<boolean> {\r\n            public static instance: FieldExprPatternIsAggregationVisitor = new FieldExprPatternIsAggregationVisitor();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): boolean {\r\n                return false;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): boolean {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        class FieldExprToEntityExprPatternBuilder implements IFieldExprPatternVisitor<FieldExprEntityItemPattern> {\r\n            public static instance: FieldExprToEntityExprPatternBuilder = new FieldExprToEntityExprPatternBuilder();\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): FieldExprEntityItemPattern {\r\n                return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): FieldExprEntityItemPattern {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): FieldExprEntityItemPattern {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n\r\n            private static toEntityItemExprPattern(exprPattern: FieldExprEntityItemPattern): FieldExprEntityItemPattern {\r\n                debug.assertValue(exprPattern, 'exprPattern');\r\n\r\n                let pattern: FieldExprEntityItemPattern = { schema: exprPattern.schema, entity: exprPattern.entity };\r\n\r\n                if (exprPattern.entityVar) {\r\n                    pattern.entityVar = exprPattern.entityVar;\r\n                }\r\n\r\n                return pattern;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    export module DataViewAnalysis {\r\n        import ArrayExtensions = jsCommon.ArrayExtensions;\r\n        import QueryProjectionsByRole = powerbi.data.QueryProjectionsByRole;\r\n        import DataViewObjectDescriptors = powerbi.data.DataViewObjectDescriptors;\r\n        import DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;\r\n\r\n        export interface ValidateAndReshapeResult {\r\n            dataView?: DataView;\r\n            isValid: boolean;\r\n        }\r\n\r\n        export interface RoleKindByQueryRef {\r\n            [queryRef: string]: VisualDataRoleKind;\r\n        }\r\n\r\n        export interface DataViewMappingResult {\r\n            supportedMappings: DataViewMapping[];\r\n\r\n            /** A set of mapping errors if there are no supported mappings */\r\n            mappingErrors: DataViewMappingMatchError[];\r\n        }\r\n\r\n        export enum DataViewMappingMatchErrorCode {\r\n            conditionRangeTooLarge,\r\n            conditionRangeTooSmall,\r\n            conditionKindExpectedMeasure,\r\n            conditionKindExpectedGrouping,\r\n            conditionKindExpectedGroupingOrMeasure,\r\n        }\r\n\r\n        export interface DataViewMappingMatchError {\r\n            code: DataViewMappingMatchErrorCode;\r\n            roleName: string;\r\n            mappingIndex?: number;\r\n            conditionIndex?: number;\r\n        }\r\n\r\n        /** Reshapes the data view to match the provided schema if possible. If not, returns null */\r\n        export function validateAndReshape(dataView: DataView, dataViewMappings: DataViewMapping[]): ValidateAndReshapeResult {\r\n            if (!dataViewMappings || dataViewMappings.length === 0)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            if (dataView) {\r\n                for (let dataViewMapping of dataViewMappings) {\r\n                    // Keep the original when possible.\r\n                    if (supports(dataView, dataViewMapping))\r\n                        return { dataView: dataView, isValid: true };\r\n\r\n                    if (dataViewMapping.categorical && dataView.categorical)\r\n                        return reshapeCategorical(dataView, dataViewMapping);\r\n\r\n                    if (dataViewMapping.tree && dataView.tree)\r\n                        return reshapeTree(dataView, dataViewMapping.tree);\r\n\r\n                    if (dataViewMapping.single && dataView.single)\r\n                        return reshapeSingle(dataView, dataViewMapping.single);\r\n\r\n                    if (dataViewMapping.table && dataView.table)\r\n                        return reshapeTable(dataView, dataViewMapping.table);\r\n                }\r\n            }\r\n            else if (ScriptResultUtil.findScriptResult(dataViewMappings)) {\r\n                // Currently, PBI Service treats R Script Visuals as static images.\r\n                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,\r\n                // to support the PBI Desktop scenario.\r\n                // This code will be removed once PBI Service fully supports R Script Visuals.\r\n                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings\r\n                return { dataView: dataView, isValid: true };\r\n            }\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeCategorical(dataView: DataView, dataViewMapping: DataViewMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataViewMapping, 'dataViewMapping');\r\n\r\n            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.\r\n            let categoryRoleMapping = dataViewMapping.categorical;\r\n            let categorical = dataView.categorical;\r\n            if (!categorical)\r\n                return { isValid: false };\r\n\r\n            let rowCount;\r\n            if (categoryRoleMapping.rowCount) {\r\n                rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (rowCount && rowCount.max) {\r\n                    let updated: DataViewCategorical;\r\n                    let categories = categorical.categories;\r\n                    let maxRowCount = rowCount.max;\r\n                    let originalLength = undefined;\r\n                    if (categories) {\r\n                        for (let i = 0, len = categories.length; i < len; i++) {\r\n                            let category = categories[i];\r\n                            originalLength = category.values.length;\r\n                            if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n\r\n                                // Row count too large: Trim it to fit.\r\n                                let updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);\r\n\r\n                                updated = updated || { categories: [] };\r\n                                updated.categories.push({\r\n                                    source: category.source,\r\n                                    values: updatedCategories\r\n                                });\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {\r\n                        if (!originalLength)\r\n                            originalLength = categorical.values[0].values.length;\r\n\r\n                        if (maxRowCount !== undefined && originalLength > maxRowCount) {\r\n                            updated = updated || {};\r\n                            updated.values = data.DataViewTransform.createValueColumns();\r\n\r\n                            for (let i = 0, len = categorical.values.length; i < len; i++) {\r\n                                let column = categorical.values[i],\r\n                                    updatedColumn: DataViewValueColumn = {\r\n                                        source: column.source,\r\n                                        values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)\r\n                                    };\r\n\r\n                                if (column.min !== undefined)\r\n                                    updatedColumn.min = column.min;\r\n                                if (column.max !== undefined)\r\n                                    updatedColumn.max = column.max;\r\n                                if (column.subtotal !== undefined)\r\n                                    updatedColumn.subtotal = column.subtotal;\r\n\r\n                                updated.values.push(updatedColumn);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (updated) {\r\n                        dataView = {\r\n                            metadata: dataView.metadata,\r\n                            categorical: updated,\r\n                        };\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (supportsCategorical(dataView, dataViewMapping))\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return null;\r\n        }\r\n\r\n        function reshapeSingle(dataView: DataView, singleRoleMapping: DataViewSingleMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (dataView.single)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            // TODO: Need to implement the reshaping of Tree\r\n            let metadata = dataView.metadata;\r\n            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        function reshapeTable(dataView: DataView, tableRoleMapping: DataViewTableMapping): ValidateAndReshapeResult {\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (dataView.table)\r\n                return { dataView: dataView, isValid: true };\r\n\r\n            return { isValid: false };\r\n        }\r\n\r\n        export function countGroups(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (!columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        export function countMeasures(columns: DataViewMetadataColumn[]): number {\r\n            let count = 0;\r\n\r\n            for (let i = 0, len = columns.length; i < len; i++) {\r\n                if (columns[i].isMeasure)\r\n                    ++count;\r\n            }\r\n\r\n            return count;\r\n        }\r\n\r\n        /** Indicates whether the dataView conforms to the specified schema. */\r\n        export function supports(dataView: DataView, roleMapping: DataViewMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            if (!roleMapping || !dataView)\r\n                return false;\r\n\r\n            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))\r\n                return false;\r\n\r\n            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))\r\n                return false;\r\n\r\n            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))\r\n                return false;\r\n\r\n            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsCategorical(dataView: DataView, categoryRoleMapping: DataViewCategoricalMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');\r\n\r\n            let dataViewCategorical = dataView.categorical;\r\n            if (!dataViewCategorical)\r\n                return false;\r\n\r\n            // TODO: Disabling this implementation isn't right.\r\n            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))\r\n            //    return false;\r\n\r\n            if (categoryRoleMapping.rowCount) {\r\n                let rowCount = categoryRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)\r\n                    rowCount = categoryRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewCategorical.values && dataViewCategorical.values.length)\r\n                        len = dataViewCategorical.values[0].values.length;\r\n                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)\r\n                        len = dataViewCategorical.categories[0].values.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsSingle(dataViewSingle: DataViewSingle, singleRoleMapping: DataViewSingleMapping): boolean {\r\n            debug.assertValue(singleRoleMapping, 'singleRoleMapping');\r\n\r\n            if (!dataViewSingle)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsTree(dataView: DataView, treeRoleMapping: DataViewTreeMapping): boolean {\r\n            debug.assertValue(treeRoleMapping, 'treeRoleMapping');\r\n\r\n            let metadata = dataView.metadata;\r\n            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;\r\n        }\r\n\r\n        function supportsTable(dataViewTable: DataViewTable, tableRoleMapping: DataViewTableMapping, usePreferredDataViewSchema?: boolean): boolean {\r\n            debug.assertValue(tableRoleMapping, 'tableRoleMapping');\r\n\r\n            if (!dataViewTable)\r\n                return false;\r\n\r\n            if (tableRoleMapping.rowCount) {\r\n                let rowCount = tableRoleMapping.rowCount.supported;\r\n                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)\r\n                    rowCount = tableRoleMapping.rowCount.preferred;\r\n\r\n                if (rowCount) {\r\n                    let len: number = 0;\r\n                    if (dataViewTable.rows && dataViewTable.rows.length)\r\n                        len = dataViewTable.rows.length;\r\n\r\n                    if (validateRange(len, rowCount) != null)\r\n                        return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function supportsScriptResult(dataView: DataViewScriptResultData, scriptResultRoleMapping: DataViewScriptResultMapping): boolean {\r\n            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');\r\n\r\n            if (!dataView)\r\n                return false;\r\n\r\n            if (!dataView.imageBase64)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the range in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        export function validateRange(value: number, roleCondition: RoleCondition, ignoreMin?: boolean): DataViewMappingMatchErrorCode {\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (!roleCondition)\r\n                return;\r\n\r\n            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;\r\n\r\n            if (roleCondition.max !== undefined && roleCondition.max < value)\r\n                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;\r\n        }\r\n\r\n        /** \r\n         * Determines whether the value conforms to the kind in the role condition, returning undefined\r\n         * if so or an appropriate error code if not.\r\n         */\r\n        function validateKind(roleCondition: RoleCondition, roleName: string, projections: QueryProjectionsByRole, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchErrorCode {\r\n            if (!roleCondition || roleCondition.kind === undefined) {\r\n                return;\r\n            }\r\n            let expectedKind = roleCondition.kind;\r\n            let roleCollection = projections[roleName];\r\n            if (roleCollection) {\r\n                let roleProjections = roleCollection.all();\r\n                for (let roleProjection of roleProjections) {\r\n                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {\r\n                        switch (expectedKind) {\r\n                            case VisualDataRoleKind.Measure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;\r\n                            case VisualDataRoleKind.Grouping:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;\r\n                            case VisualDataRoleKind.GroupingOrMeasure:\r\n                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /** Determines the appropriate DataViewMappings for the projections. */\r\n        export function chooseDataViewMappings(\r\n            projections: QueryProjectionsByRole,\r\n            mappings: DataViewMapping[],\r\n            roleKindByQueryRef: RoleKindByQueryRef,\r\n            objectDescriptors?: DataViewObjectDescriptors,\r\n            objectDefinitions?: DataViewObjectDefinitions): DataViewMappingResult {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertAnyValue(mappings, 'mappings');\r\n\r\n            let supportedMappings: DataViewMapping[] = [];\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            if (!_.isEmpty(mappings)) {\r\n                for (let mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {\r\n                    let mapping = mappings[mappingIndex],\r\n                        mappingConditions = mapping.conditions,\r\n                        requiredProperties = mapping.requiredProperties;\r\n                    let allPropertiesValid: boolean = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);\r\n                    let conditionsMet: DataViewMappingCondition[] = [];\r\n\r\n                    if (!_.isEmpty(mappingConditions)) {\r\n                        for (let conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {\r\n                            let condition = mappingConditions[conditionIndex];\r\n                            let currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);\r\n                            if (!_.isEmpty(currentConditionErrors)) {\r\n                                for (let error of currentConditionErrors) {\r\n                                    error.mappingIndex = mappingIndex;\r\n                                    error.conditionIndex = conditionIndex;\r\n                                    errors.push(error);\r\n                                }\r\n                            }\r\n                            else\r\n                                conditionsMet.push(condition);\r\n                        }\r\n                    }\r\n                    else {\r\n                        conditionsMet.push({});\r\n                    }\r\n\r\n                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {\r\n                        let supportedMapping = _.cloneDeep(mapping);\r\n\r\n                        let updatedConditions = _.filter(conditionsMet, (condition) => Object.keys(condition).length > 0);\r\n                        if (!_.isEmpty(updatedConditions))\r\n                            supportedMapping.conditions = updatedConditions;\r\n                        supportedMappings.push(supportedMapping);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),\r\n                mappingErrors: ArrayExtensions.emptyToNull(errors),\r\n            };\r\n        }\r\n\r\n        function checkForConditionErrors(projections: QueryProjectionsByRole, condition: DataViewMappingCondition, roleKindByQueryRef: RoleKindByQueryRef): DataViewMappingMatchError[] {\r\n            debug.assertValue(projections, 'projections');\r\n            debug.assertValue(condition, 'condition');\r\n\r\n            let conditionRoles = Object.keys(condition);\r\n            let errors: DataViewMappingMatchError[] = [];\r\n\r\n            for (let i = 0, len = conditionRoles.length; i < len; i++) {\r\n                let roleName: string = conditionRoles[i],\r\n                    isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs),\r\n                    roleCondition = condition[roleName];\r\n\r\n                let roleCount = getPropertyCount(roleName, projections, isDrillable);\r\n                let rangeError = validateRange(roleCount, roleCondition);\r\n                if (rangeError != null) {\r\n                    errors.push({\r\n                        code: rangeError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n                let kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);\r\n                if (kindError != null) {\r\n                    errors.push({\r\n                        code: kindError,\r\n                        roleName: roleName,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return errors;\r\n        }\r\n\r\n        function areAllPropertiesValid(requiredProperties: DataViewObjectPropertyIdentifier[], objectDescriptors: DataViewObjectDescriptors, objectDefinitions?: DataViewObjectDefinitions): boolean {\r\n            if (_.isEmpty(requiredProperties))\r\n                return true;\r\n\r\n            if (!objectDescriptors || !objectDefinitions)\r\n                return false;\r\n\r\n            let staticEvalContext: data.IEvalContext = data.createStaticEvalContext();\r\n\r\n            return _.every(requiredProperties, (requiredProperty) => {\r\n                let objectDescriptorValue = null;\r\n                let objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];\r\n                if (objectDescriptorProperty)\r\n                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];\r\n                let objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);\r\n\r\n                if (!objectDescriptorValue || !objectDefinitionValue)\r\n                    return false;\r\n\r\n                return data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);\r\n            });\r\n        }\r\n\r\n        export function getPropertyCount(roleName: string, projections: QueryProjectionsByRole, useActiveIfAvailable?: boolean): number {\r\n            debug.assertValue(roleName, 'roleName');\r\n            debug.assertValue(projections, 'projections');\r\n\r\n            let projectionsForRole = projections[roleName];\r\n            if (projectionsForRole) {\r\n                if (useActiveIfAvailable)\r\n                    return 1;\r\n                return projectionsForRole.all().length;\r\n            }\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function hasSameCategoryIdentity(dataView1: DataView, dataView2: DataView): boolean {\r\n            if (dataView1\r\n                && dataView2\r\n                && dataView1.categorical\r\n                && dataView2.categorical) {\r\n                let dv1Categories = dataView1.categorical.categories;\r\n                let dv2Categories = dataView2.categorical.categories;\r\n                if (dv1Categories\r\n                    && dv2Categories\r\n                    && dv1Categories.length === dv2Categories.length) {\r\n                    for (let i = 0, len = dv1Categories.length; i < len; i++) {\r\n                        let dv1Identity = dv1Categories[i].identity;\r\n                        let dv2Identity = dv2Categories[i].identity;\r\n\r\n                        let dv1Length = getLengthOptional(dv1Identity);\r\n                        if (dv1Length !== getLengthOptional(dv2Identity))\r\n                            return false;\r\n\r\n                        for (let j = 0; j < dv1Length; j++) {\r\n                            if (!DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))\r\n                                return false;\r\n                        }\r\n                    }\r\n\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        function getLengthOptional(identity: DataViewScopeIdentity[]): number {\r\n            if (identity)\r\n                return identity.length;\r\n\r\n            return 0;\r\n        }\r\n\r\n        export function areMetadataColumnsEquivalent(column1: DataViewMetadataColumn, column2: DataViewMetadataColumn): boolean {\r\n            if (!column1 && !column2)\r\n                return true;\r\n\r\n            if (!column1 || !column2)\r\n                return false;\r\n\r\n            if (column1.displayName !== column2.displayName)\r\n                return false;\r\n\r\n            if (column1.queryName !== column2.queryName)\r\n                return false;\r\n\r\n            if (column1.isMeasure !== column2.isMeasure)\r\n                return false;\r\n\r\n            if (column1.type !== column2.type)\r\n                return false;\r\n\r\n            if (column1.sort !== column2.sort)\r\n                return false;\r\n\r\n            return true;\r\n        }\r\n\r\n        /* Returns true if the metadata columns at the same positions in the array are equivalent. */\r\n        export function isMetadataEquivalent(metadata1: DataViewMetadata, metadata2: DataViewMetadata): boolean {\r\n            if (!metadata1 && !metadata2)\r\n                return true;\r\n\r\n            if (!metadata1 || !metadata2)\r\n                return false;\r\n\r\n            let previousColumnsLength = metadata1.columns.length;\r\n            let newColumnsLength = metadata2.columns.length;\r\n\r\n            if (previousColumnsLength !== newColumnsLength)\r\n                return false;\r\n\r\n            for (let i: number = 0; i < newColumnsLength; i++) {\r\n                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewRoleWildcard {\r\n        export function fromRoles(roles: string[]): DataViewRoleWildcard {\r\n            return new DataViewRoleWildcardImpl(roles);\r\n        }\r\n\r\n        export function equals(firstRoleWildcard: DataViewRoleWildcard, secondRoleWildcard: DataViewRoleWildcard): boolean {\r\n            return firstRoleWildcard.key &&\r\n                secondRoleWildcard.key &&\r\n                firstRoleWildcard.key === secondRoleWildcard.key &&\r\n                ArrayExtensions.sequenceEqual<string>(\r\n                    firstRoleWildcard.roles,\r\n                    secondRoleWildcard.roles,\r\n                    (role1: string, role2: string) => role1 === role2);\r\n        }\r\n\r\n        class DataViewRoleWildcardImpl implements DataViewRoleWildcard {\r\n            private _roles: string[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(roles: string[]) {\r\n                debug.assertNonEmpty(roles, 'roles');\r\n\r\n                this._roles = roles;\r\n                this._key = new Lazy<string>(() => JSON.stringify(this.roles));\r\n            }\r\n\r\n            public get roles(): string[] {\r\n                return this._roles;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    export module DataViewScopeIdentity {\r\n        /** Compares the two DataViewScopeIdentity values for equality. */\r\n        export function equals(x: DataViewScopeIdentity, y: DataViewScopeIdentity, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            return data.SQExpr.equals(<data.SQExpr>x.expr, <data.SQExpr>y.expr, ignoreCase);\r\n        }\r\n\r\n        export function filterFromIdentity(identities: DataViewScopeIdentity[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(identities))\r\n                return;\r\n            \r\n            let exprs: data.SQExpr[] = [];\r\n            for (let identity of identities) {\r\n                exprs.push(<data.SQExpr>identity.expr);\r\n            }\r\n\r\n            return filterFromExprs(exprs, isNot);\r\n        }\r\n\r\n        export function filterFromExprs(orExprs: data.SQExpr[], isNot?: boolean): data.SemanticFilter {\r\n            if (_.isEmpty(orExprs))\r\n                return;\r\n\r\n            let resultExpr: data.SQExpr;\r\n            for (let orExpr of orExprs) {\r\n                let inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);\r\n                if (resultExpr)\r\n                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);\r\n                else\r\n                    resultExpr = inExpr || orExpr;\r\n            }\r\n            \r\n            if (resultExpr) {\r\n                if (isNot)\r\n                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);\r\n            }\r\n\r\n            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);\r\n        }\r\n    }\r\n\r\n    export module data {\r\n        import Lazy = jsCommon.Lazy;\r\n\r\n        export function createDataViewScopeIdentity(expr: SQExpr): DataViewScopeIdentity {\r\n            return new DataViewScopeIdentityImpl(expr);\r\n        }\r\n\r\n        class DataViewScopeIdentityImpl implements DataViewScopeIdentity {\r\n            private _expr: SQExpr;\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(expr: SQExpr) {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                this._expr = expr;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serialize(expr));\r\n            }\r\n\r\n            public get expr(): SQExpr {\r\n                return this._expr;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Lazy = jsCommon.Lazy;\r\n\r\n    export module DataViewScopeWildcard {\r\n        export function matches(wildcard: DataViewScopeWildcard, instance: DataViewScopeIdentity): boolean {\r\n            let instanceExprs = ScopeIdentityExtractor.getKeys(<SQExpr>instance.expr);\r\n            if (!instanceExprs)\r\n                return false;\r\n\r\n            return SQExprUtils.sequenceEqual(<SQExpr[]>wildcard.exprs, instanceExprs);\r\n        }\r\n\r\n        export function equals(firstScopeWildcard: DataViewScopeWildcard, secondScopeWildcard: DataViewScopeWildcard): boolean {\r\n            return firstScopeWildcard.key === secondScopeWildcard.key &&\r\n                SQExprUtils.sequenceEqual(<SQExpr[]>firstScopeWildcard.exprs, <SQExpr[]>secondScopeWildcard.exprs);\r\n        }\r\n\r\n        export function fromExprs(exprs: SQExpr[]): DataViewScopeWildcard {\r\n            return new DataViewScopeWildcardImpl(exprs);\r\n        }\r\n\r\n        class DataViewScopeWildcardImpl implements DataViewScopeWildcard {\r\n            private _exprs: SQExpr[];\r\n            private _key: Lazy<string>;\r\n\r\n            public constructor(exprs: SQExpr[]) {\r\n                debug.assertValue(exprs, 'exprs');\r\n\r\n                this._exprs = exprs;\r\n                this._key = new Lazy(() => SQExprShortSerializer.serializeArray(exprs));\r\n            }\r\n\r\n            public get exprs(): SQExpr[] {\r\n                return this._exprs;\r\n            }\r\n\r\n            public get key(): string {\r\n                return this._key.getValue();\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface IColorAllocatorCache {\r\n        get(key: SQFillRuleExpr): IColorAllocator;\r\n        register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this;\r\n    }\r\n\r\n    export function createColorAllocatorCache(): IColorAllocatorCache {\r\n        return new ColorAllocatorProvider();\r\n    }\r\n\r\n    interface ColorAllocatorCacheEntry {\r\n        key: SQFillRuleExpr;\r\n        allocator: IColorAllocator;\r\n    }\r\n\r\n    class ColorAllocatorProvider implements IColorAllocatorCache {\r\n        private cache: ColorAllocatorCacheEntry[];\r\n\r\n        constructor() {\r\n            this.cache = [];\r\n        }\r\n\r\n        public get(key: SQFillRuleExpr): IColorAllocator {\r\n            debug.assertValue(key, 'key');\r\n\r\n            for (let entry of this.cache) {\r\n                if (entry.key === key)\r\n                    return entry.allocator;\r\n            }\r\n        }\r\n\r\n        public register(key: SQFillRuleExpr, colorAllocator: IColorAllocator): this {\r\n            debug.assertValue(key, 'key');\r\n            debug.assertValue(colorAllocator, 'colorAllocator');\r\n            debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');\r\n\r\n            this.cache.push({\r\n                key: key,\r\n                allocator: colorAllocator,\r\n            });\r\n\r\n            return this;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewRegressionRunOptions {\r\n        dataViewMappings: DataViewMapping[];\r\n        visualDataViews: DataView[];\r\n        dataRoles: VisualDataRole[];\r\n        objectDescriptors: DataViewObjectDescriptors;\r\n        objectDefinitions: DataViewObjectDefinitions;\r\n        colorAllocatorFactory: IColorAllocatorFactory;\r\n        transformSelects: DataViewSelectTransform[];\r\n        metadata: DataViewMetadata;\r\n        projectionActiveItems: DataViewProjectionActiveItems;\r\n    }\r\n\r\n    export module DataViewRegression {\r\n        // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate\r\n        // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.\r\n        const regressionXQueryName: string = 'RegressionX';\r\n        const regressionSeriesQueryName: string = 'RegressionSeries';\r\n        export const regressionYQueryName: string = 'RegressionY';\r\n\r\n        export function run(options: DataViewRegressionRunOptions): DataView[] {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let dataViewMappings: DataViewMapping[] = options.dataViewMappings;\r\n            let visualDataViews: DataView[] = options.visualDataViews;\r\n            let dataRoles: VisualDataRole[] = options.dataRoles;\r\n            let objectDescriptors: DataViewObjectDescriptors = options.objectDescriptors;\r\n            let objectDefinitions: DataViewObjectDefinitions = options.objectDefinitions;\r\n            let colorAllocatorFactory: IColorAllocatorFactory = options.colorAllocatorFactory;\r\n            let transformSelects: DataViewSelectTransform[] = options.transformSelects;\r\n            let projectionActiveItems = options.projectionActiveItems;\r\n            let metadata: DataViewMetadata = options.metadata;\r\n\r\n            if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {\r\n                // compute linear regression line if applicable\r\n                let roleKindByQueryRef: RoleKindByQueryRef = DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);\r\n                let projections: QueryProjectionsByRole = DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);\r\n                if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)\r\n                    return visualDataViews;\r\n\r\n                let applicableDataViewMappings: DataViewMapping[] = DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;\r\n\r\n                if (applicableDataViewMappings) {\r\n                    let regressionDataViewMapping: DataViewMapping = _.find(applicableDataViewMappings, (dataViewMapping) => {\r\n                        return dataViewMapping.usage && dataViewMapping.usage.regression;\r\n                    });\r\n\r\n                    if (regressionDataViewMapping) {\r\n                        let regressionDataViews: DataView[] = [];\r\n                        for (let visualDataView of visualDataViews) {\r\n                            let regressionDataView: DataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);\r\n\r\n                            if (regressionDataView)\r\n                                regressionDataViews.push(regressionDataView);\r\n                        }\r\n\r\n                        if (!_.isEmpty(regressionDataViews))\r\n                            visualDataViews.push(...regressionDataViews);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return visualDataViews;\r\n        }\r\n\r\n        /**\r\n         * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.\r\n         * It works on scalar axis only.\r\n         * The algorithm is as follows\r\n         *\r\n         * 1. Find the cartesian X and Y roles and the columns that correspond to those roles\r\n         * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.\r\n         * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept\r\n         * If highlights values are present, repeat steps 2 & 3 using highlight values.\r\n         * 4. Create the new dataView using the points computed above\r\n         */\r\n        export function linearRegressionTransform(\r\n            sourceDataView: DataView,\r\n            dataRoles: VisualDataRole[],\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');\r\n            debug.assertValue(dataRoles, 'dataRoles');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n\r\n            if (!sourceDataView.categorical)\r\n                return;\r\n\r\n            // Step 1\r\n            let xColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.X, sourceDataView.categorical, dataRoles);\r\n            let yColumns: DataViewCategoricalColumn[] = getColumnsForCartesianRoleKind(CartesianRoleKind.Y, sourceDataView.categorical, dataRoles);\r\n\r\n            if (_.isEmpty(xColumns) || _.isEmpty(yColumns))\r\n                return;\r\n\r\n            let xColumnSource = xColumns[0].source;\r\n            let yColumnSource = yColumns[0].source;\r\n\r\n            let combineSeries = true;\r\n            if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {\r\n                let regressionUsage = regressionDataViewMapping.usage.regression;\r\n\r\n                let combineSeriesPropertyId = regressionUsage['combineSeries'];\r\n                if (combineSeriesPropertyId) {\r\n                    combineSeries = DataViewObjects.getValue<boolean>(sourceDataView.metadata.objects, combineSeriesPropertyId, true);\r\n                }\r\n            }\r\n\r\n            // Step 2\r\n            let dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);\r\n            let lineDefSet = calculateLineDefinitions(dataPointsBySeries);\r\n            let xMin = lineDefSet.xMin;\r\n            let xMax = lineDefSet.xMax;\r\n\r\n            let shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);\r\n            let highlightsLineDefSet: LineDefinitionSet;\r\n            if (shouldComputeHightlights) {\r\n                let highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);\r\n                highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);\r\n                if (highlightsLineDefSet) {\r\n                    xMin = _.min([xMin, highlightsLineDefSet.xMin]);\r\n                    xMax = _.max([xMax, highlightsLineDefSet.xMax]);\r\n                }\r\n                else {\r\n                    shouldComputeHightlights = false;\r\n                }\r\n            }\r\n\r\n            // Step 3\r\n            let valuesByTrend: number[][] = [];\r\n            for (let trend of lineDefSet.lineDefs) {\r\n                valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n            }\r\n\r\n            let highlightsByTrend: number[][];\r\n            if (shouldComputeHightlights) {\r\n                highlightsByTrend = [];\r\n                for (let trend of highlightsLineDefSet.lineDefs) {\r\n                    highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));\r\n                }\r\n            }\r\n\r\n            // Step 4\r\n            let groupValues: PrimitiveValue[];\r\n            if (combineSeries) {\r\n                groupValues = ['combinedRegressionSeries'];\r\n            }\r\n            else {\r\n                // If we are producing a trend line per series we need to maintain the group identities so that we can map between the \r\n                // trend line and the original series (to match the color for example).\r\n                if (sourceDataView.categorical.values.source) {\r\n                    // Source data view has dynamic series.\r\n                    let groups = sourceDataView.categorical.values.grouped();\r\n                    groupValues = _.map(groups, (group) => group.name);\r\n                }\r\n                else {\r\n                    // Source data view has static or no series.\r\n                    groupValues = _.map(yColumns, (column) => column.source.queryName);\r\n                }\r\n            }\r\n\r\n            // Step 5\r\n            let regressionDataView: DataView = createRegressionDataView(\r\n                xColumnSource,\r\n                yColumnSource,\r\n                groupValues,\r\n                [xMin, xMax],\r\n                valuesByTrend,\r\n                highlightsByTrend,\r\n                sourceDataView,\r\n                regressionDataViewMapping,\r\n                objectDescriptors,\r\n                objectDefinitions,\r\n                colorAllocatorFactory);\r\n\r\n            return regressionDataView;\r\n        }\r\n\r\n        function calculateLineDefinitions(dataPointsBySeries: DataPointSet[]): LineDefinitionSet {\r\n            let xMin: PrimitiveValue;\r\n            let xMax: PrimitiveValue;\r\n            let lineDefs: LineDefinition[] = [];\r\n            for (let dataPointSet of dataPointsBySeries) {\r\n                let unsortedXValues: PrimitiveValue[] = dataPointSet.xValues;\r\n                let unsortedYValues: PrimitiveValue[] = dataPointSet.yValues;\r\n\r\n                if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))\r\n                    return;\r\n\r\n                // get the data type for each column; we will have null type when dataPoints have different type or if a value is null\r\n                let xDataType: string = getDataType(unsortedXValues);\r\n                if (!xDataType)\r\n                    return;\r\n                let yDataType: string = getDataType(unsortedYValues);\r\n                if (!yDataType)\r\n                    return;\r\n\r\n                let sortedDataPointSet: DataPointSet = sortValues(unsortedXValues, unsortedYValues);\r\n                let minCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[0];\r\n                let maxCategoryValue: PrimitiveValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];\r\n\r\n                let lineDef: LineDefinition = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);\r\n\r\n                xMin = _.min([xMin, minCategoryValue]);\r\n                xMax = _.max([xMax, maxCategoryValue]);\r\n\r\n                lineDefs.push(lineDef);\r\n            }\r\n\r\n            return {\r\n                lineDefs: lineDefs,\r\n                xMin: xMin,\r\n                xMax: xMax,\r\n            };\r\n        }\r\n\r\n        function getColumnsForCartesianRoleKind(roleKind: CartesianRoleKind, categorical: DataViewCategorical, roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            debug.assertValue(roleKind, 'roleKind');\r\n            debug.assertValue(categorical, 'categorical');\r\n\r\n            let columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n\r\n            let categories = categorical.categories;\r\n            if (_.isEmpty(categories))\r\n                return;\r\n\r\n            debug.assert(categories.length === 1, 'composite category columns not supported');\r\n            let categoryColumn = categories[0];\r\n            columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);\r\n            if (!_.isEmpty(columns))\r\n                return columns;\r\n        }\r\n\r\n        function getColumnsWithRoleKind(roleKind: CartesianRoleKind, columns: DataViewCategoricalColumn[], roles: VisualDataRole[]): DataViewCategoricalColumn[] {\r\n            if (_.isEmpty(columns))\r\n                return;\r\n\r\n            return _.filter(columns, (column) => {\r\n                for (let roleName in column.source.roles) {\r\n                    if (!column.source.roles[roleName])\r\n                        continue;\r\n\r\n                    let role = _.find(roles, (role) => role.name === roleName);\r\n                    if (role && role.cartesianKind === roleKind)\r\n                        return true;\r\n                }\r\n\r\n                return false;\r\n            });\r\n        }\r\n\r\n        function getDataType(values: PrimitiveValue[]): string {\r\n            let firstNonNull: PrimitiveValue = _.find(values, (value) => value != null);\r\n            if (firstNonNull == null)\r\n                return;\r\n\r\n            let dataType: string = typeof firstNonNull;\r\n\r\n            if (_.some(values, (value) => value != null && typeof value !== dataType))\r\n                return;\r\n\r\n            return dataType;\r\n        }\r\n\r\n        function sortValues(unsortedXValues: PrimitiveValue[], unsortedYValues: PrimitiveValue[]): DataPointSet {\r\n            debug.assertValue(unsortedXValues, 'unsortedXValues');\r\n            debug.assertValue(unsortedYValues, 'unsortedYValues');\r\n\r\n            let zippedValues = _.zip(unsortedXValues, unsortedYValues);\r\n            let [xValues, yValues] = _.chain(zippedValues)\r\n                .filter((valuePair) => valuePair[0] != null && valuePair[1] != null)\r\n                .sortBy((valuePair) => valuePair[0])\r\n                .unzip()\r\n                .value();\r\n\r\n            return {\r\n                xValues: xValues,\r\n                yValues: yValues\r\n            };\r\n        }\r\n\r\n        /**\r\n         * Computes a line definition using linear regression.\r\n         *   xBar: average of X values, yBar: average of Y values\r\n         *   ssXX: sum of squares of X values = Sum(xi - xBar)^2\r\n         *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)\r\n         *   Slope: ssXY / ssXX\r\n         *   Intercept: yBar - xBar * slope\r\n         */\r\n        function computeRegressionLine(xValues: number[], yValues: number[]): LineDefinition {\r\n            debug.assertValue(xValues, 'xValues');\r\n            debug.assertValue(yValues, 'yValues');\r\n\r\n            let xBar = _.sum(xValues) / xValues.length;\r\n            let yBar = _.sum(yValues) / yValues.length;\r\n\r\n            let ssXX = _.chain(xValues)\r\n                .map((x) => {\r\n                    return (x - xBar) ** 2;\r\n                })\r\n                .sum();\r\n\r\n            let ssXY = _.chain(xValues)\r\n                .map((x, i) => {\r\n                    return (x - xBar) * (yValues[i] - yBar);\r\n                })\r\n                .sum();\r\n\r\n            let slope = ssXY / ssXX;\r\n            let intercept = yBar - (xBar * slope);\r\n\r\n            return {\r\n                slope: slope,\r\n                intercept: intercept\r\n            };\r\n        }\r\n\r\n        function computeLineYValues(lineDef: LineDefinition, x1: number, x2: number): number[] {\r\n            return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];\r\n        }\r\n\r\n        function getValuesFromColumn(column: DataViewCategoricalColumn, preferHighlights: boolean): PrimitiveValue[] {\r\n            if (preferHighlights) {\r\n                // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                if (valueColumn.highlights) {\r\n                    return valueColumn.highlights;\r\n                }\r\n            }\r\n\r\n            return column.values;\r\n        }\r\n\r\n        function getDataPointsBySeries(xColumns: DataViewCategoricalColumn[], yColumns: DataViewCategoricalColumn[], combineSeries: boolean, preferHighlights: boolean): DataPointSet[] {\r\n            let dataPointsBySeries: DataPointSet[] = [];\r\n            let xValueArray: PrimitiveValue[][] = _.map(xColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n            let seriesYValues: PrimitiveValue[][] = _.map(yColumns, (column) => getValuesFromColumn(column, preferHighlights));\r\n\r\n            let multipleXValueColumns: boolean = xColumns.length > 1;\r\n            for (let i = 0; i < seriesYValues.length; i++) {\r\n                let xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];\r\n                let yValues = seriesYValues[i];\r\n\r\n                if (combineSeries && dataPointsBySeries.length > 0) {\r\n                    dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);\r\n                    dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);\r\n                }\r\n                else {\r\n                    dataPointsBySeries.push({\r\n                        xValues: xValues,\r\n                        yValues: yValues,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return dataPointsBySeries;\r\n        }\r\n\r\n        function createRegressionDataView(\r\n            xColumnSource: DataViewMetadataColumn,\r\n            yColumnSource: DataViewMetadataColumn,\r\n            groupValues: PrimitiveValue[],\r\n            categories: PrimitiveValue[],\r\n            values: PrimitiveValue[][],\r\n            highlights: PrimitiveValue[][],\r\n            sourceDataView: DataView,\r\n            regressionDataViewMapping: DataViewMapping,\r\n            objectDescriptors: DataViewObjectDescriptors,\r\n            objectDefinitions: DataViewObjectDefinitions,\r\n            colorAllocatorFactory: IColorAllocatorFactory): DataView {\r\n            debug.assertValue(xColumnSource, 'xColumnSource');\r\n            debug.assertValue(yColumnSource, 'yColumnSource');\r\n            debug.assertValue(categories, 'categories');\r\n            debug.assertValue(values, 'values');\r\n            debug.assertValue(sourceDataView, 'sourceDataView');\r\n            debug.assertValue(objectDescriptors, 'objectDescriptors');\r\n            debug.assertValue(objectDefinitions, 'objectDefinitions');\r\n            debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');\r\n            debug.assertAnyValue(highlights, 'highlights');\r\n            debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');\r\n\r\n            let xRole: string = (<DataViewRoleForMapping>regressionDataViewMapping.categorical.categories).for.in;\r\n            let grouped = (<DataViewGroupedRoleMapping>regressionDataViewMapping.categorical.values).group;\r\n            let yRole: string;\r\n            let seriesRole: string;\r\n            if (grouped && !_.isEmpty(grouped.select)) {\r\n                yRole = (<DataViewRoleForMapping>grouped.select[0]).for ?\r\n                    (<DataViewRoleForMapping>grouped.select[0]).for.in :\r\n                    (<DataViewRoleBindMapping>grouped.select[0]).bind.to;\r\n                seriesRole = grouped.by;\r\n            }\r\n            if (!yRole || !seriesRole)\r\n                return;\r\n\r\n            let categoricalRoles: { [name: string]: boolean } = {[xRole]: true};\r\n            let valueRoles: { [name: string]: boolean } = {[yRole]: true};\r\n            let seriesRoles: { [name: string]: boolean } = {[seriesRole]: true};\r\n\r\n            let valuesBySeries: DataViewBuilderSeriesData[][] = [];\r\n            for (let index in values) {\r\n                let seriesData: DataViewBuilderSeriesData = {\r\n                    values: values[index],\r\n                };\r\n\r\n                if (highlights)\r\n                    seriesData.highlights = highlights[index];\r\n\r\n                valuesBySeries.push([seriesData]);\r\n            }\r\n\r\n            let regressionDataView: DataView = createCategoricalDataViewBuilder()\r\n                .withCategory({\r\n                    source: {\r\n                        displayName: xColumnSource.displayName,\r\n                        queryName: regressionXQueryName,\r\n                        type: xColumnSource.type,\r\n                        isMeasure: false,\r\n                        roles: categoricalRoles\r\n                    },\r\n                    values: categories,\r\n                    identityFrom: {\r\n                        fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],\r\n                    },\r\n                })\r\n                .withGroupedValues({\r\n                    groupColumn: {\r\n                        source: {\r\n                            displayName: yColumnSource.displayName + 'Regression',\r\n                            queryName: regressionSeriesQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: seriesRoles\r\n                        },\r\n                        values: groupValues,\r\n                        identityFrom: {\r\n                            fields: [SQExprBuilder.columnRef(SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],\r\n                        }\r\n                    },\r\n                    valueColumns: [{\r\n                        source: {\r\n                            displayName: yColumnSource.displayName,\r\n                            queryName: regressionYQueryName,\r\n                            type: yColumnSource.type,\r\n                            isMeasure: yColumnSource.isMeasure,\r\n                            roles: valueRoles\r\n                        },\r\n                    }],\r\n                    data: valuesBySeries\r\n                })\r\n                .build();\r\n            DataViewTransform.transformObjects(regressionDataView, data.StandardDataViewKinds.Categorical, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);\r\n            return regressionDataView;\r\n        }\r\n\r\n        function hasHighlightValues(columns: DataViewCategoricalColumn[]): boolean {\r\n            return _.any(columns, (column) => {\r\n                let valueColumn = <DataViewValueColumn>column;\r\n                return valueColumn.highlights != null;\r\n            });\r\n        }\r\n    }\r\n\r\n    interface DataPointSet {\r\n        xValues: any[];\r\n        yValues: any[];\r\n    }\r\n\r\n    interface LineDefinition {\r\n        slope: number;\r\n        intercept: number;\r\n    }\r\n\r\n    interface LineDefinitionSet {\r\n        lineDefs: LineDefinition[];\r\n        xMin: PrimitiveValue;\r\n        xMax: PrimitiveValue;\r\n    }\r\n}\r\n","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import RoleKindByQueryRef = DataViewAnalysis.RoleKindByQueryRef;\r\n\r\n    export interface DataViewSelectTransform {\r\n        displayName?: string;\r\n        queryName?: string;\r\n        format?: string;\r\n        type?: ValueType;\r\n        roles?: { [roleName: string]: boolean };\r\n        kpi?: DataViewKpiColumnMetadata;\r\n        sort?: SortDirection;\r\n        expr?: SQExpr;\r\n        discourageAggregationAcrossGroups?: boolean;\r\n\r\n        /** Describes the default value applied to a column, if any. */\r\n        defaultValue?: DefaultValueDefinition;\r\n    }\r\n\r\n    export module DataViewSelectTransform {\r\n        /** Convert selection info to projections */\r\n        export function projectionsFromSelects(selects: DataViewSelectTransform[], projectionActiveItems: DataViewProjectionActiveItems): QueryProjectionsByRole {\r\n            debug.assertAnyValue(selects, \"selects\");\r\n            debug.assertAnyValue(projectionActiveItems, \"projectionActiveItems\");\r\n\r\n            let projections: QueryProjectionsByRole = {};\r\n            for (let select of selects) {\r\n                let roles = select.roles;\r\n                if (!roles)\r\n                    continue;\r\n\r\n                for (let roleName in roles) {\r\n                    if (roles[roleName]) {\r\n                        let qp = projections[roleName];\r\n                        if (!qp)\r\n                            qp = projections[roleName] = new QueryProjectionCollection([]);\r\n                        qp.all().push({ queryRef: select.queryName });\r\n\r\n                        if (projectionActiveItems && projectionActiveItems[roleName])\r\n                            qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], (activeItem: DataViewProjectionActiveItemInfo) => activeItem.queryRef);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return projections;\r\n        }\r\n\r\n        /** Use selections and metadata to fashion query role kinds */\r\n        export function createRoleKindFromMetadata(selects: DataViewSelectTransform[], metadata: DataViewMetadata): RoleKindByQueryRef {\r\n            let roleKindByQueryRef: DataViewAnalysis.RoleKindByQueryRef = {};\r\n            for (let column of metadata.columns) {\r\n                if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)\r\n                    continue;\r\n\r\n                let select = selects[column.index];\r\n                if (select) {\r\n                    let queryRef = select.queryName;\r\n                    if (queryRef && roleKindByQueryRef[queryRef] === undefined) {\r\n                        roleKindByQueryRef[queryRef] = column.isMeasure ? VisualDataRoleKind.Measure : VisualDataRoleKind.Grouping;\r\n                    }\r\n                }\r\n            }\r\n            return roleKindByQueryRef;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export interface ICategoricalEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createCategoricalEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewCategorical: DataViewCategorical): ICategoricalEvalContext {\r\n        return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);\r\n    }\r\n\r\n    class CategoricalEvalContext implements ICategoricalEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewCategorical;\r\n        private columnsByRole: { [name: string]: DataViewCategoricalColumn };\r\n        private index: number;\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewCategorical) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.columnsByRole = {};\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            let columnsByRole = this.columnsByRole;\r\n            let column = columnsByRole[roleName];\r\n            if (!column)\r\n                column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);\r\n            \r\n            if (!column)\r\n                return;\r\n\r\n            let index = this.index;\r\n            if (index != null)\r\n                return column.values[this.index];\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.index = index;\r\n        }\r\n    }\r\n\r\n    function findRuleInputColumn(dataViewCategorical: DataViewCategorical, inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertValue(dataViewCategorical, 'dataViewCategorical');\r\n\r\n        return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||\r\n            findRuleInputInColumns(dataViewCategorical.categories, inputRole);\r\n    }\r\n\r\n    function findRuleInputInColumns(columns: DataViewCategoricalColumn[], inputRole: string): DataViewCategoricalColumn {\r\n        debug.assertAnyValue(columns, 'columns');\r\n\r\n        if (!columns)\r\n            return;\r\n\r\n        for (let column of columns) {\r\n            let roles = column.source.roles;\r\n            if (!roles || !roles[inputRole])\r\n                continue;\r\n\r\n            return column;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export interface ITableEvalContext extends IEvalContext {\r\n        setCurrentRowIndex(index: number): void;\r\n    }\r\n\r\n    export function createTableEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewTable: DataViewTable, selectTransforms: DataViewSelectTransform[]): ITableEvalContext {\r\n        return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);\r\n    }\r\n\r\n    class TableEvalContext implements ITableEvalContext {\r\n        private colorAllocatorProvider: IColorAllocatorCache;\r\n        private dataView: DataViewTable;\r\n        private rowIdx: number;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorProvider: IColorAllocatorCache, dataView: DataViewTable, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorProvider = colorAllocatorProvider;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorProvider.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let rowIdx = this.rowIdx;\r\n            if (rowIdx == null)\r\n                return;\r\n\r\n            return getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n\r\n        public setCurrentRowIndex(index: number): void {\r\n            debug.assertValue(index, 'index');\r\n\r\n            this.rowIdx = index;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class RuleEvaluation {\r\n        // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export class ColorRuleEvaluation extends RuleEvaluation {\r\n        private inputRole: string;\r\n        private allocator: IColorAllocator;\r\n\r\n        constructor(inputRole: string, allocator: IColorAllocator) {\r\n            debug.assertValue(inputRole, 'inputRole');\r\n            debug.assertValue(allocator, 'allocator');\r\n\r\n            super();\r\n            this.inputRole = inputRole;\r\n            this.allocator = allocator;\r\n        }\r\n\r\n        public evaluate(evalContext: IEvalContext): any {\r\n            debug.assertValue(evalContext, 'evalContext');\r\n\r\n            let value: any = evalContext.getRoleValue(this.inputRole);\r\n            if (value !== undefined)\r\n                return this.allocator.color(value);\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    import inherit = Prototype.inherit;\r\n    import inheritSingle = Prototype.inheritSingle;\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    export module DataViewMatrixUtils {\r\n\r\n        /**\r\n         * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the \r\n         * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the \r\n         * particular leaf node in the context of this forEachLeafNode(...) invocation.\r\n         *\r\n         * If rootNodes is null or undefined or empty, the specified callback will not get invoked.\r\n         *\r\n         * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified \r\n         * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,\r\n         * then treePath will be an array of length 1 containing that very node.\r\n         *\r\n         * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!\r\n         * If your callback needs to retain a copy of the treePath, please clone the array before returning.\r\n         */\r\n        export function forEachLeafNode(\r\n            rootNodes: DataViewMatrixNode | DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): void {\r\n            debug.assertAnyValue(rootNodes, 'rootNodes');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // Note: Don't do \"if (!_.isEmpty(rootNodes))\" for checking whether rootNodes is an empty array DataViewMatrixNode[],\r\n            // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, \r\n            // for the fact that all the properties on DataViewMatrixNode are optional...\r\n            if (rootNodes) {\r\n                if (isNodeArray(rootNodes)) {\r\n                    let index = 0;\r\n                    for (let rootNode of rootNodes) {\r\n                        if (rootNode) {\r\n                            index = forEachLeafNodeRecursive(rootNode, index, [], callback);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    forEachLeafNodeRecursive(rootNodes, 0, [], callback);\r\n                }\r\n            }\r\n        }\r\n\r\n        function isNodeArray(nodeOrNodeArray: DataViewMatrixNode | DataViewMatrixNode[]): nodeOrNodeArray is DataViewMatrixNode[] {\r\n            return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);\r\n        }\r\n\r\n        /**\r\n         * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.\r\n         * Returns the index for the next node after the last node that this function invokes callback with.\r\n         *\r\n         * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).\r\n         */\r\n        function forEachLeafNodeRecursive(\r\n            matrixNode: DataViewMatrixNode,\r\n            nextIndex: number,\r\n            treePath: DataViewMatrixNode[],\r\n            callback: (leafNode: DataViewMatrixNode, index?: number, treePath?: DataViewMatrixNode[]) => void): number {\r\n            debug.assertValue(matrixNode, 'matrixNode');\r\n            debug.assertValue(treePath, 'treePath');\r\n            debug.assertValue(callback, 'callback');\r\n\r\n            // If treePath already contains matrixNode, then either one of the following errors has happened:\r\n            // 1. the caller code mistakenly added matrixNode to treePath, or\r\n            // 2. the callback modified treePath by adding a node to it, or\r\n            // 3. the matrix hierarchy contains a cyclical node reference.');\r\n            debug.assert(!_.contains(treePath, matrixNode),\r\n                'pre-condition: treePath must not already contain matrixNode');\r\n\r\n            treePath.push(matrixNode);\r\n\r\n            if (_.isEmpty(matrixNode.children)) { // if it is a leaf node\r\n                callback(matrixNode, nextIndex, treePath);\r\n                nextIndex++;\r\n            }\r\n            else {\r\n                let children = matrixNode.children;\r\n                for (let nextChild of children) {\r\n                    if (nextChild) {\r\n                        nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);\r\n                    }\r\n                }\r\n            }\r\n\r\n            debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');\r\n            treePath.pop();\r\n\r\n            return nextIndex;\r\n        }\r\n\r\n        /**\r\n         * Returned an object tree where each node and its children property are inherited from the specified node \r\n         * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.\r\n         *\r\n         * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array \r\n         * property, i.e. its children property is the same array object referenced in the input node's object tree.\r\n         *\r\n         * @param node The input node with the hierarchy object tree.\r\n         * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.\r\n         * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is \r\n         * not already an inherited object. Same goes for the node's children property.  This is useful for creating \r\n         * \"visual DataView\" objects from \"query DataView\" objects, as object inheritance is the mechanism for \r\n         * \"visual DataView\" to override properties in \"query DataView\", and that \"query DataView\" never contains \r\n         * inherited objects.\r\n         */\r\n        export function inheritMatrixNodeHierarchy(\r\n            node: DataViewMatrixNode,\r\n            deepestLevelToInherit: number,\r\n            useInheritSingle: boolean): DataViewMatrixNode {\r\n            debug.assertValue(node, 'node');\r\n            debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');\r\n            debug.assertValue(useInheritSingle, 'useInheritSingle');\r\n\r\n            let returnNode = node;\r\n\r\n            // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.\r\n            // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode\r\n            // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):\r\n            //  {\r\n            //    \"level\": 0,\r\n            //    \"isSubtotal\": true,\r\n            //    \"children\": [\r\n            //      { \"level\": 2, \"isSubtotal\": true },\r\n            //      { \"level\": 2, \"levelSourceIndex\": 1, \"isSubtotal\": true }\r\n            //    ]\r\n            //  }\r\n            let isRootNode = _.isUndefined(node.level);\r\n            let shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);\r\n            if (shouldInheritCurrentNode) {\r\n                let inheritFunc = useInheritSingle ? inheritSingle : inherit;\r\n                let inheritedNode: DataViewMatrixNode = inheritFunc(node);\r\n\r\n                let shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);\r\n                if (shouldInheritChildNodes && !_.isEmpty(node.children)) {\r\n                    inheritedNode.children = inheritFunc(node.children); // first, make an inherited array\r\n                    for (let i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {\r\n                        inheritedNode.children[i] =\r\n                            inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);\r\n                    }\r\n                }\r\n\r\n                returnNode = inheritedNode;\r\n            }\r\n\r\n            return returnNode;\r\n        }\r\n\r\n        /**\r\n         * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.\r\n         * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have\r\n         * Year === 2016, Quarter === 'Qtr 1', Month === 1.\r\n         *\r\n         * Returns false if the specified matrixOrHierarchy does not contain any composite group, \r\n         * or if matrixOrHierarchy is null or undefined.\r\n         */\r\n        export function containsCompositeGroup(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): boolean {\r\n            debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');\r\n\r\n            let hasCompositeGroup = false;\r\n\r\n            if (matrixOrHierarchy) {\r\n                if (isMatrix(matrixOrHierarchy)) {\r\n                    hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||\r\n                        containsCompositeGroup(matrixOrHierarchy.columns);\r\n                }\r\n                else {\r\n                    let hierarchyLevels = matrixOrHierarchy.levels;\r\n                    if (!_.isEmpty(hierarchyLevels)) {\r\n                        for (var level of hierarchyLevels) {\r\n                            // it takes at least 2 columns at the same hierarchy level to form a composite group...\r\n                            if (level.sources && (level.sources.length >= 2)) {\r\n\r\n                                debug.assert(_.all(level.sources, sourceColumn => sourceColumn.isMeasure === level.sources[0].isMeasure),\r\n                                    'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');\r\n\r\n                                // Measure headers are not group\r\n                                let isMeasureHeadersLevel = level.sources[0].isMeasure;\r\n                                if (!isMeasureHeadersLevel) {\r\n                                    hasCompositeGroup = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            return hasCompositeGroup;\r\n        }\r\n\r\n        function isMatrix(matrixOrHierarchy: DataViewMatrix | DataViewHierarchy): matrixOrHierarchy is DataViewMatrix {\r\n            return 'rows' in matrixOrHierarchy &&\r\n                'columns' in matrixOrHierarchy &&\r\n                'valueSources' in matrixOrHierarchy;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.utils {\r\n    export module DataViewMetadataColumnUtils {\r\n\r\n        export interface MetadataColumnAndProjectionIndex {\r\n            /**\r\n            * A metadata column taken from a source collection, e.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n            */\r\n            metadataColumn: DataViewMetadataColumn;\r\n\r\n            /**\r\n             * The index of this.metadataColumn in its sources collection.\r\n             *\r\n             * E.g.1 This can be the value of the property DataViewMatrixGroupValue.levelSourceIndex which is the index of this.metadataColumn in DataViewHierarchyLevel.sources.\r\n             * E.g.2 This can be the value of the property DataViewMatrixNodeValue.valueSourceIndex which refer to columns in DataViewMatrix.valueSources.\r\n             */\r\n            sourceIndex: number;\r\n\r\n            /**\r\n            * The index of this.metadataColumn in the projection ordering of a given role.\r\n            */\r\n            projectionOrderIndex: number;\r\n        }\r\n\r\n        /**\r\n         * Returns true iff the specified metadataColumn is assigned to the specified targetRole.\r\n         */\r\n        export function isForRole(metadataColumn: DataViewMetadataColumn, targetRole: string): boolean {\r\n            debug.assertValue(metadataColumn, 'metadataColumn');\r\n            debug.assertValue(targetRole, 'targetRole');\r\n\r\n            let roles = metadataColumn.roles;\r\n            return roles && roles[targetRole];\r\n        }\r\n\r\n        /**\r\n         * Joins each column in the specified columnSources with projection ordering index into a wrapper object.\r\n         *\r\n         * Note: In order for this function to reliably calculate the \"source index\" of a particular column, the \r\n         * specified columnSources must be a non-filtered array of column sources from the DataView, such as\r\n         * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.\r\n         *\r\n         * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...\r\n         * @param projection The projection ordering.  It must contain an ordering for the specified role.\r\n         * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.\r\n         */\r\n        export function joinMetadataColumnsAndProjectionOrder(\r\n            columnSources: DataViewMetadataColumn[],\r\n            projection: DataViewProjectionOrdering,\r\n            role: string): MetadataColumnAndProjectionIndex[] {\r\n            debug.assertAnyValue(columnSources, 'columnSources');\r\n            debug.assert(_.all(columnSources, column => _.isNumber(column.index)),\r\n                'pre-condition: Every value in columnSources must already have its Select Index property initialized.');\r\n            debug.assertNonEmpty(projection[role], 'projection[role]');\r\n            debug.assert(_.all(columnSources, column => !isForRole(column, role) || _.contains(projection[role], column.index)),\r\n                'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');\r\n\r\n            let jointResult: MetadataColumnAndProjectionIndex[] = [];\r\n\r\n            if (!_.isEmpty(columnSources)) {\r\n                let projectionOrderSelectIndices = projection[role];\r\n                let selectIndexToProjectionIndexMap: { [selectIndex: number]: number } = {};\r\n                for (let i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {\r\n                    let selectIndex = projectionOrderSelectIndices[i];\r\n                    selectIndexToProjectionIndexMap[selectIndex] = i;\r\n                }\r\n\r\n                for (let j = 0, jlen = columnSources.length; j < jlen; j++) {\r\n                    var column = columnSources[j];\r\n                    if (isForRole(column, role)) {\r\n                        let jointColumnInfo: MetadataColumnAndProjectionIndex = {\r\n                            metadataColumn: column,\r\n                            sourceIndex: j,\r\n                            projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]\r\n                        };\r\n\r\n                        jointResult.push(jointColumnInfo);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return jointResult;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export class ConceptualSchema {\r\n        public entities: ArrayNamedItems<ConceptualEntity>;\r\n        public capabilities: ConceptualCapabilities;\r\n\r\n        /** Indicates whether the user can edit this ConceptualSchema.  This is used to enable/disable model authoring UX. */\r\n        public canEdit: boolean;\r\n\r\n        public findProperty(entityName: string, propertyName: string): ConceptualProperty {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            return entity.properties.withName(propertyName);\r\n        }\r\n\r\n        public findHierarchy(entityName: string, name: string): ConceptualHierarchy {\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.hierarchies))\r\n                return;\r\n\r\n            return entity.hierarchies.withName(name);\r\n        }\r\n\r\n        public findHierarchyByVariation(\r\n            variationEntityName: string,\r\n            variationColumnName: string,\r\n            variationName: string,\r\n            hierarchyName: string): ConceptualHierarchy {\r\n\r\n            let variationEntity = this.entities.withName(variationEntityName);\r\n            if (!variationEntity || _.isEmpty(variationEntity.properties))\r\n                return;\r\n\r\n            let variationProperty = variationEntity.properties.withName(variationColumnName);\r\n            if (!variationProperty)\r\n                return;\r\n\r\n            let variationColumn = variationProperty.column;\r\n            if (!variationColumn || _.isEmpty(variationColumn.variations))\r\n                return;\r\n\r\n            let variation = variationColumn.variations.withName(variationName);\r\n            if (variation) {\r\n                let targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;\r\n                if (!targetEntity || _.isEmpty(targetEntity.hierarchies))\r\n                    return;\r\n\r\n                return targetEntity.hierarchies.withName(hierarchyName);\r\n            }\r\n        }\r\n\r\n        /**\r\n        * Returns the first property of the entity whose kpi is tied to kpiProperty\r\n        */\r\n        public findPropertyWithKpi(entityName: string, kpiProperty: ConceptualProperty): ConceptualProperty {\r\n            debug.assertValue(kpiProperty, 'kpiProperty');\r\n\r\n            let entity = this.entities.withName(entityName);\r\n            if (!entity || _.isEmpty(entity.properties))\r\n                return;\r\n\r\n            for (let prop of entity.properties) {\r\n                if (prop &&\r\n                    prop.measure &&\r\n                    prop.measure.kpi &&\r\n                    (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))\r\n                    return prop;\r\n            }\r\n\r\n            return;\r\n        }\r\n    }\r\n\r\n    export interface ConceptualCapabilities {\r\n        discourageQueryAggregateUsage: boolean;\r\n        normalizedFiveStateKpiRange: boolean;\r\n        supportsMedian: boolean;\r\n        supportsPercentile: boolean;\r\n    }\r\n\r\n    export interface ConceptualPropertyItemContainer {\r\n        properties: ArrayNamedItems<ConceptualProperty>;\r\n        hierarchies?: ArrayNamedItems<ConceptualHierarchy>;\r\n        displayFolders?: ArrayNamedItems<ConceptualDisplayFolder>;\r\n    }\r\n\r\n    export interface ConceptualPropertyItem {\r\n        name: string;\r\n        displayName: string;\r\n        hidden?: boolean;\r\n    }\r\n\r\n    export interface ConceptualEntity extends ConceptualPropertyItemContainer {\r\n        name: string;\r\n        displayName: string;\r\n        visibility?: ConceptualVisibility;\r\n        calculated?: boolean;\r\n        queryable?: ConceptualQueryableState;\r\n        navigationProperties?: ArrayNamedItems<ConceptualNavigationProperty>;\r\n    }\r\n\r\n    export interface ConceptualDisplayFolder extends ConceptualPropertyItem, ConceptualPropertyItemContainer {\r\n    }\r\n\r\n    export interface ConceptualProperty extends ConceptualPropertyItem {\r\n        type: ValueType;\r\n        kind: ConceptualPropertyKind;\r\n        format?: string;\r\n        column?: ConceptualColumn;\r\n        queryable?: ConceptualQueryableState;\r\n        measure?: ConceptualMeasure;\r\n        kpiValue?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualHierarchy extends ConceptualPropertyItem {\r\n        levels: ArrayNamedItems<ConceptualHierarchyLevel>;\r\n    }\r\n\r\n    export interface ConceptualHierarchyLevel extends ConceptualPropertyItem {\r\n        column: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualNavigationProperty {\r\n        name: string;\r\n        isActive: boolean;\r\n        sourceColumn?: ConceptualColumn;\r\n        targetEntity: ConceptualEntity;\r\n        sourceMultiplicity: ConceptualMultiplicity;\r\n        targetMultiplicity: ConceptualMultiplicity;\r\n    }\r\n\r\n    export interface ConceptualVariationSource {\r\n        name: string;\r\n        isDefault: boolean;\r\n        navigationProperty?: ConceptualNavigationProperty;\r\n        defaultHierarchy?: ConceptualHierarchy;\r\n        defaultProperty?: ConceptualProperty;\r\n    }\r\n\r\n    export interface ConceptualColumn {\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n        keys?: ArrayNamedItems<ConceptualProperty>;\r\n        idOnEntityKey?: boolean;\r\n        calculated?: boolean;\r\n        defaultValue?: SQConstantExpr;\r\n        variations?: ArrayNamedItems<ConceptualVariationSource>;\r\n        aggregateBehavior?: ConceptualAggregateBehavior;\r\n    }\r\n\r\n    export interface ConceptualMeasure {\r\n        kpi?: ConceptualPropertyKpi;\r\n    }\r\n\r\n    export interface ConceptualPropertyKpi {\r\n        statusMetadata: DataViewKpiColumnMetadata;\r\n        trendMetadata?: DataViewKpiColumnMetadata;\r\n        status?: ConceptualProperty;\r\n        goal?: ConceptualProperty;\r\n        trend?: ConceptualProperty;\r\n    }\r\n\r\n    export const enum ConceptualVisibility {\r\n        Visible = 0,\r\n        Hidden = 1,\r\n        ShowAsVariationsOnly = 2,\r\n        IsPrivate = 4,\r\n    }\r\n\r\n    export const enum ConceptualQueryableState {\r\n        Queryable = 0,\r\n        Error = 1,\r\n    }\r\n\r\n    export const enum ConceptualMultiplicity {\r\n        ZeroOrOne = 0,\r\n        One = 1,\r\n        Many = 2,\r\n    }\r\n\r\n    export const enum ConceptualPropertyKind {\r\n        Column,\r\n        Measure,\r\n        Kpi,\r\n    }\r\n\r\n    export const enum ConceptualDefaultAggregate {\r\n        Default,\r\n        None,\r\n        Sum,\r\n        Count,\r\n        Min,\r\n        Max,\r\n        Average,\r\n        DistinctCount,\r\n    }\r\n\r\n    // TODO: Remove this (replaced by ValueType)\r\n    export enum ConceptualDataCategory {\r\n        None,\r\n        Address,\r\n        City,\r\n        Company,\r\n        Continent,\r\n        Country,\r\n        County,\r\n        Date,\r\n        Image,\r\n        ImageUrl,\r\n        Latitude,\r\n        Longitude,\r\n        Organization,\r\n        Place,\r\n        PostalCode,\r\n        Product,\r\n        StateOrProvince,\r\n        WebUrl,\r\n    }\r\n\r\n    export const enum ConceptualAggregateBehavior {\r\n        Default,\r\n        DiscourageAcrossGroups,\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import FederatedConceptualSchema = powerbi.data.FederatedConceptualSchema;\r\n    import FieldExprColumnPattern = powerbi.data.FieldExprColumnPattern;\r\n    import FieldExprColumnAggrPattern = powerbi.data.FieldExprColumnAggrPattern;\r\n    import FieldExprColumnHierarchyLevelVariationPattern = powerbi.data.FieldExprColumnHierarchyLevelVariationPattern;\r\n    import FieldExprEntityPattern = powerbi.data.FieldExprEntityPattern;\r\n    import FieldExprEntityAggrPattern = powerbi.data.FieldExprEntityAggrPattern;\r\n    import FieldExprHierarchyPattern = powerbi.data.FieldExprHierarchyPattern;\r\n    import FieldExprHierarchyLevelPattern = powerbi.data.FieldExprHierarchyLevelPattern;\r\n    import FieldExprHierarchyLevelAggrPattern = powerbi.data.FieldExprHierarchyLevelAggrPattern;\r\n    import FieldExprMeasurePattern = powerbi.data.FieldExprMeasurePattern;\r\n    import FieldExprPattern = powerbi.data.FieldExprPattern;\r\n    import FieldExprPercentilePattern = powerbi.data.FieldExprPercentilePattern;\r\n    import FieldExprPercentOfGrandTotalPattern = powerbi.data.FieldExprPercentOfGrandTotalPattern;\r\n    import IFieldExprPatternVisitor = powerbi.data.IFieldExprPatternVisitor;\r\n    import QueryProjectionsByRole = data.QueryProjectionsByRole;\r\n\r\n    export interface ScriptResult {\r\n        source: string;\r\n        provider: string;\r\n    }\r\n\r\n    export module ScriptResultUtil {\r\n\r\n        export function findScriptResult(dataViewMappings: DataViewMapping[] | data.CompiledDataViewMapping[]): DataViewScriptResultMapping | data.CompiledDataViewScriptResultMapping {\r\n            if (dataViewMappings && dataViewMappings.length === 1) {\r\n                return dataViewMappings[0].scriptResult;\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResult(dataViewMappings: data.CompiledDataViewMapping[]): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult) {\r\n                let objects = dataViewMappings[0].metadata.objects;\r\n                let source: string = DataViewObjects.getValue<string>(objects, scriptResult.script.source);\r\n                let provider: string = DataViewObjects.getValue<string>(objects, scriptResult.script.provider);\r\n                return {\r\n                    source: source,\r\n                    provider: provider\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function extractScriptResultFromVisualConfig(dataViewMappings: DataViewMapping[], objects: powerbi.data.DataViewObjectDefinitions): ScriptResult {\r\n            let scriptResult = findScriptResult(dataViewMappings);\r\n            if (scriptResult && objects) {\r\n                let scriptSource = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);\r\n                let provider = <data.SQConstantExpr>data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);\r\n                return {\r\n                    source: scriptSource ? scriptSource.value : null,\r\n                    provider: provider ? provider.value : null\r\n                };\r\n            }\r\n\r\n            return undefined;\r\n        }\r\n\r\n        export function getScriptInput(projections: QueryProjectionsByRole, selects: ArrayNamedItems<data.NamedSQExpr>, schema: FederatedConceptualSchema): data.ScriptInput {\r\n            let scriptInput: data.ScriptInput = {\r\n                VariableName: \"dataset\",\r\n                Columns: []\r\n            };\r\n\r\n            // Go over all the projections, and create an input column according to the order\r\n            // of the projections (including duplicate expressions)\r\n            if (projections && selects && !_.isEmpty(selects)) {\r\n                let scriptInputColumnNames: string[] = [];\r\n                let scriptInputColumns: data.ScriptInputColumn[] = [];\r\n                for (let role in projections) {\r\n                    for (let projection of projections[role].all()) {\r\n                        let select = selects.withName(projection.queryRef);\r\n                        if (select) {\r\n                            let scriptInputColumn = <data.ScriptInputColumn>{\r\n                                QueryName: select.name,\r\n                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))\r\n                            };\r\n\r\n                            scriptInputColumns.push(scriptInputColumn);\r\n                            scriptInputColumnNames.push(scriptInputColumn.Name);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Make sure the names of the columns are unique\r\n                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);\r\n\r\n                // Update the names of the columns\r\n                for (let i = 0; i < scriptInputColumnNames.length; i++) {\r\n                    let scriptInputColumn = scriptInputColumns[i];\r\n                    scriptInputColumn.Name = scriptInputColumnNames[i];\r\n                }\r\n\r\n                scriptInput.Columns = scriptInputColumns;\r\n            }\r\n\r\n            return scriptInput;\r\n        }\r\n\r\n        class ScriptInputColumnNameVisitor implements IFieldExprPatternVisitor<string>\r\n        {\r\n            private federatedSchema: FederatedConceptualSchema;\r\n\r\n            constructor(federatedSchema: FederatedConceptualSchema) {\r\n                this.federatedSchema = federatedSchema;\r\n            }\r\n\r\n            public visitColumn(column: FieldExprColumnPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): string {\r\n                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);\r\n            }\r\n\r\n            public visitEntity(entity: FieldExprEntityPattern): string {\r\n                return entity.entity;\r\n            }\r\n\r\n            public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): string {\r\n                return entityAggr.entity;\r\n            }\r\n\r\n            public visitHierarchy(hierarchy: FieldExprHierarchyPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);\r\n            }\r\n\r\n            public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): string {\r\n                /*Hierarchy levels are not supported yet*/\r\n                return;\r\n            }\r\n\r\n            public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);\r\n            }\r\n\r\n            public visitMeasure(measure: FieldExprMeasurePattern): string {\r\n                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);\r\n            }\r\n\r\n            public visitPercentile(percentile: FieldExprPercentilePattern): string {\r\n                return FieldExprPattern.visit(percentile.arg, this);\r\n            }\r\n\r\n            public visitPercentOfGrandTotal(percentOfGrandTotal: FieldExprPercentOfGrandTotalPattern): string {\r\n                return FieldExprPattern.visit(percentOfGrandTotal.baseExpr, this);\r\n            }\r\n\r\n            private static getNameForHierarchy(pattern: FieldExprHierarchyPattern, federatedScheam: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedScheam.schema(pattern.schema),\r\n                    hierarchy = schema.findHierarchy(pattern.entity, pattern.name);\r\n\r\n                if (hierarchy)\r\n                    return hierarchy.name;\r\n            }\r\n\r\n            private static getNameForProperty(pattern: data.FieldExprPropertyPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let schema = federatedSchema.schema(pattern.schema),\r\n                    property = schema.findProperty(pattern.entity, pattern.name);\r\n\r\n                if (property)\r\n                    return property.name;\r\n            }\r\n\r\n            private static getVariationLevelName(pattern: FieldExprColumnHierarchyLevelVariationPattern, federatedSchema: FederatedConceptualSchema): string {\r\n                debug.assertValue(pattern, 'pattern');\r\n\r\n                let source = pattern.source;\r\n                let prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);\r\n                if (!prop)\r\n                    return;\r\n\r\n                let variations = prop.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === pattern.variationName)\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            if (level.name === pattern.level.level)\r\n                                return level.column.name;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data.segmentation {\r\n\r\n    export interface DataViewTableSegment extends DataViewTable {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewTreeSegmentNode extends DataViewTreeNode {\r\n        /** Indicates whether the node is a duplicate of a node from a previous segment. */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export interface DataViewCategoricalSegment extends DataViewCategorical {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        lastMergeIndex?: number;\r\n    }\r\n\r\n    export interface DataViewMatrixSegmentNode extends DataViewMatrixNode {\r\n        /**\r\n         * Index of the last item that had a merge flag in the underlying data.\r\n         * We assume merge flags are not random but adjacent to each other.\r\n         */\r\n        isMerge?: boolean;\r\n    }\r\n\r\n    export module DataViewMerger {\r\n\r\n        export function mergeDataViews(source: DataView, segment: DataView): void {\r\n\r\n            if (!DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {\r\n                debug.assertFail(\"Cannot merge data views with different metadata columns\");\r\n            }\r\n\r\n            // The last segment is complete. We mark the source as complete.\r\n            if (!segment.metadata.segment)\r\n                delete source.metadata.segment;\r\n\r\n            if (source.table && segment.table)\r\n                mergeTables(source.table, <DataViewTableSegment>segment.table);\r\n\r\n            if (source.categorical && segment.categorical)\r\n                mergeCategorical(source.categorical, <DataViewCategoricalSegment>segment.categorical);\r\n\r\n            // Tree cannot support subtotals hence we can get into situations\r\n            // where a node has no children in one segment and more than 1 child\r\n            // in another segment.\r\n            if (source.tree && segment.tree)\r\n                mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);\r\n\r\n            if (source.matrix && segment.matrix)\r\n                mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTables(source: DataViewTable, segment: DataViewTableSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            if (_.isEmpty(segment.rows))\r\n                return;\r\n\r\n            let mergeIndex = segment.lastMergeIndex + 1;\r\n            merge(source.rows, segment.rows, mergeIndex);\r\n\r\n            debug.assert(!source.identity === !segment.identity, 'The existence of identity in the new segment is different than the source');\r\n            if (segment.identity)\r\n                merge(source.identity, segment.identity, mergeIndex);\r\n        }\r\n\r\n        /**\r\n         * Merge categories values and identities\r\n         *\r\n         * Note: Public for testability\r\n         */\r\n        export function mergeCategorical(source: DataViewCategorical, segment: DataViewCategoricalSegment): void {\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(segment, 'segment');\r\n\r\n            // Merge categories values and identities\r\n            if (source.categories && segment.categories) {\r\n                let segmentCategoriesLength = segment.categories.length;\r\n                debug.assert(source.categories.length === segmentCategoriesLength, \"Source and segment categories have different lengths.\");\r\n\r\n                for (let categoryIndex: number = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {\r\n                    let segmentCategory = segment.categories[categoryIndex];\r\n                    let sourceCategory = source.categories[categoryIndex];\r\n\r\n                    debug.assert(DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), \"Source and segment category have different sources.\");\r\n                    debug.assert(_.isUndefined(sourceCategory.values) ? _.isUndefined(sourceCategory.identity) : true, 'Source category is missing values but has identities.');\r\n\r\n                    let mergeIndex = segment.lastMergeIndex + 1;\r\n                    if (segmentCategory.values) {\r\n                        merge(sourceCategory.values, segmentCategory.values, mergeIndex);\r\n                    }\r\n\r\n                    if (segmentCategory.identity) {\r\n                        merge(sourceCategory.identity, segmentCategory.identity, mergeIndex);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Merge values for each value column\r\n            if (source.values && segment.values) {\r\n                let segmentValuesLength = segment.values.length;\r\n                debug.assert(source.values.length === segmentValuesLength, \"Source and segment values have different lengths.\");\r\n\r\n                for (let valueIndex: number = 0; valueIndex < segmentValuesLength; valueIndex++) {\r\n                    let segmentValue = segment.values[valueIndex];\r\n                    let sourceValue = source.values[valueIndex];\r\n\r\n                    debug.assert(jsCommon.JsonComparer.equals(sourceValue.source, segmentValue.source), \"Source and segment value have different sources.\");\r\n\r\n                    if (!sourceValue.values && segmentValue.values) {\r\n                        sourceValue.values = [];\r\n                    }\r\n\r\n                    let mergeIndex = segment.lastMergeIndex + 1;\r\n                    if (segmentValue.values) {\r\n                        merge(sourceValue.values, segmentValue.values, mergeIndex);\r\n                    }\r\n\r\n                    if (segmentValue.highlights) {\r\n                        merge(sourceValue.highlights, segmentValue.highlights, mergeIndex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Merges the segment array starting at the specified index into the source array\r\n         * and returns the segment slice that wasn't merged.\r\n         * The segment array is spliced up to specified index in the process.\r\n         */\r\n        function merge(source: any[], segment: any[], index?: number): any[] {\r\n            if (index >= segment.length)\r\n                return segment;\r\n\r\n            let result: any[] = [];\r\n            if (index !== undefined)\r\n                result = segment.splice(0, index);\r\n\r\n            Array.prototype.push.apply(source, segment);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Note: Public for testability */\r\n        export function mergeTreeNodes(sourceRoot: DataViewTreeNode, segmentRoot: DataViewTreeNode, allowDifferentStructure: boolean): void {\r\n            debug.assertValue(sourceRoot, 'sourceRoot');\r\n            debug.assertValue(segmentRoot, 'segmentRoot');\r\n\r\n            if (!segmentRoot.children || segmentRoot.children.length === 0)\r\n                return;\r\n\r\n            if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {\r\n                sourceRoot.children = segmentRoot.children;\r\n                return;\r\n            }\r\n\r\n            debug.assert(sourceRoot.children && sourceRoot.children.length >= 0,\r\n                \"Source tree has different structure than segment.\");\r\n\r\n            let firstAppendIndex = findFirstAppendIndex(segmentRoot.children);\r\n            let lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];\r\n            let mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);\r\n\r\n            if (mergedChildren.length > 0)\r\n                mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);\r\n        }\r\n\r\n        function findFirstAppendIndex(children: DataViewTreeNode[]): number {\r\n            if (children.length === 0)\r\n                return 0;\r\n\r\n            let i: number = 0;\r\n            for (; i < children.length; i++) {\r\n                let childSegment: DataViewTreeSegmentNode = <DataViewTreeSegmentNode>children[i];\r\n                if (!childSegment.isMerge)\r\n                    break;\r\n            }\r\n\r\n            return i;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Rewrites an expression tree, including all descendant nodes. */\r\n    export class SQExprRewriter implements ISQExprVisitor<SQExpr>, IFillRuleDefinitionVisitor<LinearGradient2Definition, LinearGradient3Definition> {\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQColumnRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let origArg = expr.source,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQMeasureRefExpr(rewrittenArg, expr.ref);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(rewrittenArg, expr.func);\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPercentileExpr(rewrittenArg, expr.k, expr.exclusive);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyExpr(rewrittenArg, expr.hierarchy);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQHierarchyLevelExpr(rewrittenArg, expr.level);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQExpr {\r\n            let origArg = expr.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return expr;\r\n\r\n            return new SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitAnd(orig: SQAndExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQAndExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitBetween(orig: SQBetweenExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this),\r\n                origLower = orig.lower,\r\n                rewrittenLower = origLower.accept(this),\r\n                origUpper = orig.upper,\r\n                rewrittenUpper = origUpper.accept(this);\r\n\r\n            if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)\r\n                return orig;\r\n\r\n            return new SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);\r\n        }\r\n\r\n        public visitIn(orig: SQInExpr): SQExpr {\r\n            let origArgs = orig.args,\r\n                rewrittenArgs = this.rewriteAll(origArgs),\r\n                origValues: SQExpr[][] = orig.values,\r\n                rewrittenValues: SQExpr[][];\r\n\r\n            for (let i = 0, len = origValues.length; i < len; i++) {\r\n                let origValueTuple = origValues[i],\r\n                    rewrittenValueTuple = this.rewriteAll(origValueTuple);\r\n\r\n                if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)\r\n                    rewrittenValues = ArrayExtensions.take(origValues, i);\r\n\r\n                if (rewrittenValues)\r\n                    rewrittenValues.push(rewrittenValueTuple);\r\n            }\r\n\r\n            if (origArgs === rewrittenArgs && !rewrittenValues)\r\n                return orig;\r\n\r\n            return new SQInExpr(rewrittenArgs, rewrittenValues || origValues);\r\n        }\r\n\r\n        private rewriteAll(origExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(origExprs, 'origExprs');\r\n\r\n            let rewrittenResult: SQExpr[];\r\n            for (let i = 0, len = origExprs.length; i < len; i++) {\r\n                let origExpr = origExprs[i],\r\n                    rewrittenExpr = origExpr.accept(this);\r\n\r\n                if (origExpr !== rewrittenExpr && !rewrittenResult)\r\n                    rewrittenResult = ArrayExtensions.take(origExprs, i);\r\n\r\n                if (rewrittenResult)\r\n                    rewrittenResult.push(rewrittenExpr);\r\n            }\r\n\r\n            return rewrittenResult || origExprs;\r\n        }\r\n\r\n        public visitOr(orig: SQOrExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQOrExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitCompare(orig: SQCompareExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitContains(orig: SQContainsExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQContainsExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitExists(orig: SQExistsExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQExistsExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitNot(orig: SQNotExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQNotExpr(rewrittenArg);\r\n        }\r\n\r\n        public visitStartsWith(orig: SQStartsWithExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQStartsWithExpr(rewrittenLeft, rewrittenRight);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): SQExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitDateSpan(orig: SQDateSpanExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateSpanExpr(orig.unit, rewrittenArg);\r\n        }\r\n\r\n        public visitDateAdd(orig: SQDateAddExpr): SQExpr {\r\n            let origArg = orig.arg,\r\n                rewrittenArg = origArg.accept(this);\r\n\r\n            if (origArg === rewrittenArg)\r\n                return orig;\r\n\r\n            return new SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);\r\n        }\r\n\r\n        public visitNow(orig: SQNowExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitDefaultValue(orig: SQDefaultValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitAnyValue(orig: SQAnyValueExpr): SQExpr {\r\n            return orig;\r\n        }\r\n\r\n        public visitArithmetic(orig: SQArithmeticExpr): SQExpr {\r\n            let origLeft = orig.left,\r\n                rewrittenLeft = origLeft.accept(this),\r\n                origRight = orig.right,\r\n                rewrittenRight = origRight.accept(this);\r\n\r\n            if (origLeft === rewrittenLeft && origRight === rewrittenRight)\r\n                return orig;\r\n\r\n            return new SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);\r\n        }\r\n\r\n        public visitScopedEval(orig: SQScopedEvalExpr): SQExpr {\r\n            let origExpression = orig.expression,\r\n                rewrittenExpression = origExpression.accept(this),\r\n                origScope = orig.scope,\r\n                rewrittenScope = this.rewriteAll(origScope);\r\n\r\n            if (origExpression === rewrittenExpression && origScope === rewrittenScope)\r\n                return orig;\r\n\r\n            return new SQScopedEvalExpr(rewrittenExpression, rewrittenScope);\r\n        }\r\n\r\n        public visitFillRule(orig: SQFillRuleExpr): SQExpr {\r\n            let origInput = orig.input,\r\n                rewrittenInput = origInput.accept(this);\r\n\r\n            let origRule = orig.rule;\r\n\r\n            let origGradient2 = origRule.linearGradient2,\r\n                rewrittenGradient2 = origGradient2;\r\n            if (origGradient2) {\r\n                rewrittenGradient2 = this.visitLinearGradient2(origGradient2);\r\n            }\r\n\r\n            let origGradient3 = origRule.linearGradient3,\r\n                rewrittenGradient3 = origGradient3;\r\n            if (origGradient3) {\r\n                rewrittenGradient3 = this.visitLinearGradient3(origGradient3);\r\n            }\r\n\r\n            if (origInput !== rewrittenInput ||\r\n                origGradient2 !== rewrittenGradient2 ||\r\n                origGradient3 !== rewrittenGradient3) {\r\n                let rewrittenRule: FillRuleDefinition = {};\r\n                if (rewrittenGradient2)\r\n                    rewrittenRule.linearGradient2 = rewrittenGradient2;\r\n                if (rewrittenGradient3)\r\n                    rewrittenRule.linearGradient3 = rewrittenGradient3;\r\n\r\n                return new SQFillRuleExpr(rewrittenInput, rewrittenRule);\r\n            }\r\n\r\n            return orig;\r\n        }\r\n\r\n        public visitLinearGradient2(origGradient2: LinearGradient2Definition): LinearGradient2Definition {\r\n            debug.assertValue(origGradient2, 'origGradient2');\r\n\r\n            let origMin = origGradient2.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMax = origGradient2.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient2;\r\n        }\r\n\r\n        public visitLinearGradient3(origGradient3: LinearGradient3Definition): LinearGradient3Definition {\r\n            debug.assertValue(origGradient3, 'origGradient3');\r\n\r\n            let origMin = origGradient3.min,\r\n                rewrittenMin = this.visitFillRuleStop(origMin),\r\n                origMid = origGradient3.mid,\r\n                rewrittenMid = this.visitFillRuleStop(origMid),\r\n                origMax = origGradient3.max,\r\n                rewrittenMax = this.visitFillRuleStop(origMax);\r\n\r\n            if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {\r\n                return {\r\n                    min: rewrittenMin,\r\n                    mid: rewrittenMid,\r\n                    max: rewrittenMax,\r\n                };\r\n            }\r\n\r\n            return origGradient3;\r\n        }\r\n\r\n        private visitFillRuleStop(stop: RuleColorStopDefinition): RuleColorStopDefinition {\r\n            debug.assertValue(stop, 'stop');\r\n\r\n            let origColor = stop.color,\r\n                rewrittenColor = stop.color.accept(this);\r\n\r\n            let origValue = stop.value,\r\n                rewrittenValue = origValue;\r\n            if (origValue)\r\n                rewrittenValue = origValue.accept(this);\r\n\r\n            if (origColor !== rewrittenColor || origValue !== rewrittenValue) {\r\n                let rewrittenStop: RuleColorStopDefinition = {\r\n                    color: rewrittenColor\r\n                };\r\n\r\n                if (rewrittenValue)\r\n                    rewrittenStop.value = rewrittenValue;\r\n\r\n                return rewrittenStop;\r\n            }\r\n\r\n            return stop;\r\n        }\r\n\r\n        public visitResourcePackageItem(orig: SQResourcePackageItemExpr): SQExpr {\r\n            return orig;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Responsible for writing equality comparisons against a field to an SQInExpr. */\r\n    export module EqualsToInRewriter {\r\n        export function run(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(new Rewriter());\r\n        }\r\n\r\n        class Rewriter extends SQExprRewriter {\r\n            private current: InBuilder;\r\n\r\n            constructor() {\r\n                super();\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): SQExpr {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return this.visitUnsupported(expr);\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let leftIsComparand = this.isComparand(expr.left);\r\n                let rightIsComparand = this.isComparand(expr.right);\r\n                if (leftIsComparand === rightIsComparand)\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let operand: SQExpr = leftIsComparand\r\n                    ? expr.left\r\n                    : expr.right;\r\n                let value: SQExpr = leftIsComparand\r\n                    ? expr.right\r\n                    : expr.left;\r\n\r\n                let current = this.current;\r\n                if (!current) {\r\n                    return SQExprBuilder.inExpr([operand], [[value]]);\r\n                }\r\n\r\n                current.add(operand, value);\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitOr(expr: SQOrExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current: InBuilder;\r\n                if (!this.current) {\r\n                    current = this.current = new InBuilder();\r\n                }\r\n\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n\r\n                if (current) {\r\n                    this.current = null;\r\n                    return current.complete() || expr;\r\n                }\r\n\r\n                return expr;\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): SQExpr {\r\n                if (!this.isSupported(expr.left) || !this.isSupported(expr.right))\r\n                    return this.visitUnsupported(expr);\r\n\r\n                let current = this.current;\r\n                if (current) {\r\n                    // NOTE: Composite keys are not supported by this algorithm.\r\n                    current.cancel();\r\n                    return expr;\r\n                }\r\n\r\n                return super.visitAnd(expr);\r\n            }\r\n\r\n            private visitUnsupported(expr: SQExpr): SQExpr {\r\n                let current = this.current;\r\n                if (current)\r\n                    current.cancel();\r\n\r\n                return expr;\r\n            }\r\n\r\n            private isSupported(expr: SQExpr): boolean {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return expr instanceof SQCompareExpr\r\n                    || expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQConstantExpr\r\n                    || expr instanceof SQHierarchyLevelExpr\r\n                    || expr instanceof SQOrExpr\r\n                    || expr instanceof SQAndExpr;\r\n            }\r\n\r\n            private isComparand(expr: SQExpr): boolean {\r\n                return expr instanceof SQColumnRefExpr\r\n                    || expr instanceof SQHierarchyLevelExpr;\r\n            }\r\n        }\r\n\r\n        class InBuilder {\r\n            private operand: SQExpr;\r\n            private values: SQExpr[];\r\n            private cancelled: boolean;\r\n\r\n            public add(operand: SQExpr, value: SQExpr): void {\r\n                debug.assertValue(operand, 'operand');\r\n                debug.assertValue(value, 'value');\r\n\r\n                if (this.cancelled)\r\n                    return;\r\n\r\n                if (this.operand && !SQExpr.equals(operand, this.operand)) {\r\n                    this.cancel();\r\n                    return;\r\n                }\r\n\r\n                this.operand = operand;\r\n\r\n                let values = this.values;\r\n                if (!values)\r\n                    values = this.values = [];\r\n\r\n                values.push(value);\r\n            }\r\n\r\n            public cancel(): void {\r\n                this.cancelled = true;\r\n            }\r\n\r\n            public complete(): SQInExpr {\r\n                if (this.cancelled || !this.operand)\r\n                    return;\r\n\r\n                return SQExprBuilder.inExpr([this.operand], _.map(this.values, v => [v]));\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export interface FilterValueScopeIdsContainer {\r\n            isNot: boolean;\r\n            scopeIds: DataViewScopeIdentity[];\r\n        }\r\n\r\n    export module SQExprConverter {\r\n        export function asScopeIdsContainer(filter: SemanticFilter, fieldSQExprs: SQExpr[]): FilterValueScopeIdsContainer {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');\r\n\r\n            let filterItems = filter.conditions();\r\n            debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');\r\n            let filterItem = filterItems[0];\r\n            if (filterItem) {\r\n                let visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);\r\n                if (filterItem.accept(visitor))\r\n                    return visitor.getResult();\r\n            }\r\n        }\r\n\r\n        /** Gets a comparand value from the given DataViewScopeIdentity. */\r\n        export function getFirstComparandValue(identity: DataViewScopeIdentity): any {\r\n            debug.assertValue(identity, 'identity');\r\n\r\n            let comparandExpr = (<SQExpr>identity.expr).accept(new FindComparandVisitor());\r\n            if (comparandExpr)\r\n                return comparandExpr.value;\r\n        }\r\n    }\r\n\r\n    /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/\r\n    class FilterScopeIdsCollectorVisitor extends DefaultSQExprVisitor<boolean>{\r\n        private isRoot: boolean;\r\n        private isNot: boolean;\r\n        private keyExprsCount: number;\r\n        private valueExprs: SQExpr[];\r\n        private fieldExprs: SQExpr[];\r\n\r\n        constructor(fieldSQExprs:SQExpr[]) {\r\n            super();\r\n            this.isRoot = true;\r\n            this.isNot = false;\r\n            this.keyExprsCount = null;\r\n            this.valueExprs = [];\r\n\r\n            // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to\r\n            // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will\r\n            // need to drop it in order to use JsonComparer.\r\n            this.fieldExprs = [];\r\n            for (let field of fieldSQExprs) {\r\n                this.fieldExprs.push(SQExprBuilder.removeEntityVariables(field));\r\n            }\r\n        }\r\n\r\n        public getResult(): FilterValueScopeIdsContainer {\r\n            debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');            \r\n\r\n            let valueExprs = this.valueExprs,\r\n                scopeIds: DataViewScopeIdentity[] = [];\r\n            let valueCount: number = this.keyExprsCount || 1;\r\n\r\n            for (let startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {\r\n                let values = valueExprs.slice(startIndex, endIndex);\r\n                let scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);\r\n\r\n                if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, DataViewScopeIdentity.equals))\r\n                    scopeIds.push(scopeId);\r\n\r\n                startIndex += valueCount;\r\n                endIndex += valueCount;\r\n            }\r\n\r\n            return {\r\n                isNot: this.isNot,\r\n                scopeIds: scopeIds,\r\n            };\r\n        }\r\n\r\n        private static getScopeIdentity(fieldExprs: SQExpr[], valueExprs: SQExpr[]): DataViewScopeIdentity {\r\n            debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');\r\n            debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');\r\n\r\n            let compoundSQExpr: SQExpr;\r\n            for (let i = 0, len = fieldExprs.length; i < len; i++) {\r\n                let equalsExpr = SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);\r\n                if (!compoundSQExpr)\r\n                    compoundSQExpr = equalsExpr;\r\n                else\r\n                    compoundSQExpr = SQExprBuilder.and(compoundSQExpr, equalsExpr);\r\n            }\r\n\r\n            return createDataViewScopeIdentity(compoundSQExpr);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr): boolean {\r\n            if (!this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isNot = true;\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr): boolean {\r\n            if (this.isRoot && expr.type.primitiveType === PrimitiveType.Null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);            \r\n            return true;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): boolean {\r\n            if (this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.isRoot = false;\r\n\r\n            if (expr.comparison !== QueryComparisonKind.Equal)\r\n                return this.unsupportedSQExpr();\r\n\r\n            return expr.left.accept(this) && expr.right.accept(this);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): boolean {\r\n            this.keyExprsCount = 0;\r\n            let result: boolean;\r\n            this.isRoot = false;\r\n            for (let arg of expr.args) {\r\n                result = arg.accept(this);\r\n                if (!result)\r\n                    return this.unsupportedSQExpr();\r\n\r\n                this.keyExprsCount++;\r\n            }\r\n\r\n            if (this.keyExprsCount !== this.fieldExprs.length)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let values = expr.values;\r\n            for (let valueTuple of values) {\r\n                let jlen = valueTuple.length;\r\n                debug.assert(jlen === this.keyExprsCount, \"keys count and values count should match\");\r\n\r\n                for (let value of valueTuple) {\r\n                    result = value.accept(this);\r\n                    if (!result)\r\n                        return this.unsupportedSQExpr();\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): boolean {\r\n            if (this.isRoot)\r\n                return this.unsupportedSQExpr();\r\n\r\n            let fixedExpr = SQExprBuilder.removeEntityVariables(expr);\r\n            if (this.keyExprsCount !== null)\r\n                return SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);\r\n\r\n            return SQExpr.equals(this.fieldExprs[0], fixedExpr);\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n            if (this.isRoot || this.keyExprsCount !== null)\r\n                return this.unsupportedSQExpr();\r\n\r\n            this.valueExprs.push(expr);\r\n            return true;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): boolean {\r\n            return this.unsupportedSQExpr();\r\n        }\r\n\r\n        private unsupportedSQExpr(): boolean {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    class FindComparandVisitor extends DefaultSQExprVisitor<SQConstantExpr> {\r\n        public visitAnd(expr: SQAndExpr): SQConstantExpr {\r\n            return expr.left.accept(this) || expr.right.accept(this);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQConstantExpr {\r\n            if (expr.comparison === QueryComparisonKind.Equal) {\r\n                if (expr.right instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.right;\r\n                if (expr.left instanceof SQConstantExpr)\r\n                    return <SQConstantExpr>expr.left;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n\r\n    /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */\r\n    export module ScopeIdentityExtractor {\r\n        export function getKeys(expr: SQExpr): SQExpr[] {\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return null;\r\n\r\n            return ArrayExtensions.emptyToNull(extractor.keys);\r\n        }\r\n\r\n        export function getInExpr(expr: SQExpr): SQInExpr{\r\n            let extractor = new ScopeIdExtractorImpl();\r\n            expr.accept(extractor);\r\n\r\n            if (extractor.malformed)\r\n                return;\r\n            \r\n            let keys = ArrayExtensions.emptyToNull(extractor.keys);\r\n            let keyValues = ArrayExtensions.emptyToNull(extractor.values);\r\n\r\n            if (keys && keyValues)\r\n                return data.SQExprBuilder.inExpr(keys, [keyValues]);\r\n        }\r\n\r\n        /**\r\n         * Recognizes expressions of the form:\r\n         * 1) Equals(ColRef, Constant)\r\n         * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))\r\n         * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..\r\n         */\r\n        class ScopeIdExtractorImpl extends DefaultSQExprVisitor<void> {\r\n            public keys: SQExpr[] = [];\r\n            public values: SQConstantExpr[] = [];\r\n            public malformed: boolean;\r\n\r\n            public visitAnd(expr: SQAndExpr): void {\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): void {\r\n                if (expr.comparison !== QueryComparisonKind.Equal) {\r\n                    this.visitDefault(expr);\r\n                    return;\r\n                }\r\n                debug.assert(expr.left instanceof SQExpr && expr.right instanceof SQConstantExpr, 'invalid compare expr operands');\r\n                expr.left.accept(this);\r\n                expr.right.accept(this);\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): void {\r\n                this.values.push(expr);\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): void {\r\n                this.keys.push(expr);\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): void {\r\n                this.malformed = true;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export module PrimitiveValueEncoding {\r\n        const SingleQuoteRegex = /'/g;\r\n\r\n        export function decimal(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'M';\r\n        }\r\n\r\n        export function double(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'D';\r\n        }\r\n\r\n        export function integer(value: number): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return value + 'L';\r\n        }\r\n\r\n        export function dateTime(value: Date): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.\r\n            // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.\r\n            // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.\r\n            let date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));\r\n            let dateTimeString = date.toISOString();\r\n\r\n            // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so\r\n            // we will drop it.\r\n            // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.\r\n            if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))\r\n                dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);\r\n            return \"datetime'\" + dateTimeString + \"'\";\r\n        }\r\n\r\n        export function text(value: string): string {\r\n            debug.assertValue(value, 'value');\r\n\r\n            return \"'\" + value.replace(SingleQuoteRegex, \"''\") + \"'\";\r\n        }\r\n\r\n        export function nullEncoding(): string {\r\n            return 'null';\r\n        }\r\n\r\n        export function boolean(value: boolean): string {\r\n            return value ? 'true' : 'false';\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import Agg = powerbi.data.QueryAggregateFunction;\r\n\r\n    export interface ISQAggregationOperations {\r\n        /** Returns an array of supported aggregates for a given expr and role type. */\r\n        getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[];\r\n\r\n        isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean;\r\n\r\n        createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr;\r\n    }\r\n\r\n    export function createSQAggregationOperations(datetimeMinMaxSupported: boolean): ISQAggregationOperations {\r\n        return new SQAggregationOperations(datetimeMinMaxSupported);\r\n    }\r\n\r\n    class SQAggregationOperations implements ISQAggregationOperations {\r\n        constructor(private datetimeMinMaxSupported: boolean) {\r\n        }\r\n\r\n        public getSupportedAggregates(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            targetTypes: ValueTypeDescriptor[]): QueryAggregateFunction[] {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertAnyValue(targetTypes, 'targetTypes');\r\n\r\n            let metadata = getMetadataForUnderlyingType(expr, schema);\r\n\r\n            // don't use expr.validate as validate will be using this function and we end up in a recursive loop\r\n            if (!metadata)\r\n                return [];\r\n\r\n            let valueType = metadata.type,\r\n                fieldKind = metadata.kind,\r\n                isPropertyIdentity = metadata.idOnEntityKey;\r\n\r\n            if (!valueType)\r\n                return [];\r\n\r\n            // Cannot aggregate on model measures\r\n            if (fieldKind === FieldKind.Measure)\r\n                return [];\r\n\r\n            if (valueType.numeric || valueType.integer) {\r\n                let aggregates = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                let currentSchema = schema.schema(fieldExprItem.schema);\r\n                if (currentSchema.capabilities.supportsMedian)\r\n                    aggregates.push(Agg.Median);\r\n\r\n                return aggregates;\r\n            }\r\n\r\n            let aggregates: QueryAggregateFunction[] = [];\r\n\r\n            // Min/Max of DateTime\r\n            if (this.datetimeMinMaxSupported &&\r\n                valueType.dateTime &&\r\n                (_.isEmpty(targetTypes) || ValueType.isCompatibleTo(valueType, targetTypes))) {\r\n                aggregates.push(Agg.Min);\r\n                aggregates.push(Agg.Max);\r\n            }\r\n\r\n            // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)\r\n            // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)\r\n            let distinctCountAggExists = SQExprInfo.getAggregate(expr) === Agg.Count;\r\n            if (!(isPropertyIdentity && !distinctCountAggExists))\r\n                aggregates.push(Agg.Count);\r\n\r\n            aggregates.push(Agg.CountNonNull);\r\n\r\n            return aggregates;\r\n        }\r\n\r\n        public isSupportedAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregate: QueryAggregateFunction,\r\n            targetTypes: ValueTypeDescriptor[]): boolean {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);\r\n            return _.contains(supportedAggregates, aggregate);\r\n        }\r\n\r\n        public createExprWithAggregate(\r\n            expr: SQExpr,\r\n            schema: FederatedConceptualSchema,\r\n            aggregateNonNumericFields: boolean,\r\n            targetTypes: ValueTypeDescriptor[],\r\n            preferredAggregate?: QueryAggregateFunction): SQExpr {\r\n\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n            if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {\r\n                aggregate = preferredAggregate;\r\n            }\r\n            else {\r\n                aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);\r\n            }\r\n            if (aggregate !== undefined)\r\n                expr = SQExprBuilder.aggregate(expr, aggregate);\r\n\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    function getMetadataForUnderlyingType(expr: SQExpr, schema: FederatedConceptualSchema): SQExprMetadata {\r\n        // Unwrap the aggregate (if the expr has one), and look at the underlying type.\r\n        let metadata = SQExprBuilder.removeAggregate(expr).getMetadata(schema);\r\n\r\n        if (!metadata)\r\n            metadata = expr.getMetadata(schema);\r\n\r\n        return metadata;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export module SQHierarchyExprUtils {\r\n        export function getConceptualHierarchyLevelFromExpr(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            fieldExpr: FieldExprPattern): ConceptualHierarchyLevel {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            let hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;\r\n            if (hierarchyLevel)\r\n                return SQHierarchyExprUtils.getConceptualHierarchyLevel(\r\n                    conceptualSchema,\r\n                    fieldExprItem.schema,\r\n                    fieldExprItem.entity,\r\n                    hierarchyLevel.name,\r\n                    hierarchyLevel.level);\r\n        }\r\n\r\n        export function getConceptualHierarchyLevel(\r\n            conceptualSchema: FederatedConceptualSchema,\r\n            schemaName: string,\r\n            entity: string,\r\n            hierarchy: string,\r\n            hierarchyLevel: string): ConceptualHierarchyLevel {\r\n\r\n            let schema = conceptualSchema.schema(schemaName);\r\n            let conceptualHierarchy = schema.findHierarchy(entity, hierarchy);\r\n            if (conceptualHierarchy) {\r\n                return conceptualHierarchy.levels.withName(hierarchyLevel);\r\n            }\r\n        }\r\n\r\n        export function getConceptualHierarchy(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): ConceptualHierarchy {\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchy = <SQHierarchyExpr>sqExpr;\r\n\r\n                if (sqExpr.arg instanceof SQEntityExpr) {\r\n                    let entityExpr = <SQEntityExpr>sqExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(entityExpr.schema)\r\n                        .findHierarchy(entityExpr.entity, hierarchy.hierarchy);\r\n                } else if (sqExpr.arg instanceof SQPropertyVariationSourceExpr) {\r\n                    let variationExpr = <SQPropertyVariationSourceExpr>sqExpr.arg;\r\n                    let sourceEntityExpr = <SQEntityExpr>variationExpr.arg;\r\n                    return federatedSchema\r\n                        .schema(sourceEntityExpr.schema)\r\n                        .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);\r\n                }\r\n            }\r\n        }\r\n\r\n        export function expandExpr(schema: FederatedConceptualSchema, expr: SQExpr, suppressHierarchyLevelExpansion?: boolean): SQExpr | SQExpr[] {\r\n            return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||\r\n                SQExprVariationConverter.expand(expr, schema) ||\r\n                // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels\r\n                (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||\r\n                expr;\r\n        }\r\n\r\n        export function isHierarchyOrVariation(schema: FederatedConceptualSchema, expr: SQExpr): boolean {\r\n            if (expr instanceof SQHierarchyExpr || expr instanceof SQHierarchyLevelExpr)\r\n                return true;\r\n\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0)\r\n                    return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // Return column reference expression for hierarchy level expression.\r\n        export function getSourceVariationExpr(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            if (fieldExprPattern.columnHierarchyLevelVariation) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);\r\n\r\n                return SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);\r\n            }\r\n        }\r\n\r\n        // Return hierarchy expression for hierarchy level expression.\r\n        export function getSourceHierarchy(hierarchyLevelExpr: data.SQHierarchyLevelExpr): SQHierarchyExpr {\r\n            let fieldExprPattern: data.FieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);\r\n            let hierarchyLevel = fieldExprPattern.hierarchyLevel;\r\n            if (hierarchyLevel) {\r\n                let entity: data.SQExpr = SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);\r\n                return SQExprBuilder.hierarchy(entity, hierarchyLevel.name);\r\n            }\r\n        }\r\n\r\n        export function getHierarchySourceAsVariationSource(hierarchyLevelExpr: SQHierarchyLevelExpr): SQPropertyVariationSourceExpr {\r\n\r\n            // Make sure the hierarchy level source is a hierarchy\r\n            if (!(hierarchyLevelExpr.arg instanceof SQHierarchyExpr))\r\n                return;\r\n                        \r\n            // Check if the hierarchy source if a variation\r\n            let hierarchyRef = <SQHierarchyExpr>hierarchyLevelExpr.arg;\r\n            if (hierarchyRef.arg instanceof SQPropertyVariationSourceExpr)\r\n                return <SQPropertyVariationSourceExpr>hierarchyRef.arg;\r\n        }\r\n\r\n        /**\r\n        * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.\r\n        */\r\n        export function areHierarchyLevelsOrdered(allLevels: SQHierarchyLevelExpr[], firstExpr: SQExpr, secondExpr: SQExpr): boolean {\r\n\r\n            // Validate that both items hierarchy levels\r\n            if (!(firstExpr instanceof SQHierarchyLevelExpr) || !(secondExpr instanceof SQHierarchyLevelExpr))\r\n                return false;\r\n\r\n            let firstLevel = <SQHierarchyLevelExpr>firstExpr;\r\n            let secondLevel = <SQHierarchyLevelExpr>secondExpr;\r\n\r\n            // Validate that both items belong to the same hierarchy\r\n            if (!SQExpr.equals(firstLevel.arg, secondLevel.arg))\r\n                return false;\r\n\r\n            // Determine the order\r\n            let firstIndex = SQExprUtils.indexOfExpr(allLevels, firstLevel);\r\n            let secondIndex = SQExprUtils.indexOfExpr(allLevels, secondLevel);\r\n\r\n            return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;\r\n        }\r\n\r\n        /**\r\n         * Given an ordered set of levels and an ordered subset of those levels, returns the index where\r\n         * expr should be inserted into the subset to maintain the correct order.\r\n         */\r\n        export function getInsertionIndex(allLevels: SQHierarchyLevelExpr[], orderedSubsetOfLevels: SQHierarchyLevelExpr[], expr: SQHierarchyLevelExpr): number {\r\n\r\n            let insertIndex = 0;\r\n\r\n            // Loop through the supplied levels until the insertion would no longer be in the correct order\r\n            while (insertIndex < orderedSubsetOfLevels.length &&\r\n                areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {\r\n                insertIndex++;\r\n            }\r\n\r\n            return insertIndex;\r\n        }\r\n    }\r\n\r\n    export module SQExprHierarchyToHierarchyLevelConverter {\r\n        export function convert(sqExpr: SQExpr, federatedSchema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(sqExpr, 'sqExpr');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            if (sqExpr instanceof SQHierarchyExpr) {\r\n                let hierarchyExpr = <SQHierarchyExpr>sqExpr;\r\n\r\n                let conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);\r\n                if (conceptualHierarchy)\r\n                    return _.map(conceptualHierarchy.levels, hierarchyLevel => SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name));\r\n            }\r\n        }\r\n    }\r\n\r\n    module SQExprHierarchyLevelConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n            let exprs: SQExpr[] = [];\r\n\r\n            if (expr instanceof SQHierarchyLevelExpr) {\r\n                let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                if (fieldExpr.hierarchyLevel) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                    let hierarchy = schema\r\n                        .schema(fieldExprItem.schema)\r\n                        .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);\r\n\r\n                    if (hierarchy) {\r\n                        let hierarchyLevels = hierarchy.levels;\r\n                        for (let hierarchyLevel of hierarchyLevels) {\r\n                            if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {\r\n                                exprs.push(expr);\r\n                                break;\r\n                            }\r\n                            else\r\n                                exprs.push(\r\n                                    SQExprBuilder.hierarchyLevel(\r\n                                        SQExprBuilder.hierarchy(\r\n                                            SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                            hierarchy.name),\r\n                                        hierarchyLevel.name)\r\n                                );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (!_.isEmpty(exprs))\r\n                return exprs;\r\n        }\r\n    }\r\n\r\n    module SQExprVariationConverter {\r\n        export function expand(expr: SQExpr, schema: FederatedConceptualSchema): SQExpr[] {\r\n            debug.assertValue(expr, 'sqExpr');\r\n            debug.assertValue(schema, 'federatedSchema');\r\n\r\n            let exprs: SQExpr[];\r\n            let conceptualProperty = expr.getConceptualProperty(schema);\r\n\r\n            if (conceptualProperty) {\r\n                let column = conceptualProperty.column;\r\n                if (column && column.variations && column.variations.length > 0) {\r\n                    let variations = column.variations;\r\n\r\n                    // for SU11, we support only one variation\r\n                    debug.assert(variations.length === 1, \"variations.length\");\r\n                    let variation = variations[0];\r\n\r\n                    let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n\r\n                    exprs = [];\r\n                    if (variation.defaultHierarchy) {\r\n                        let hierarchyExpr = SQExprBuilder.hierarchy(\r\n                            SQExprBuilder.propertyVariationSource(\r\n                                SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar),\r\n                                variation.name, conceptualProperty.name),\r\n                            variation.defaultHierarchy.name);\r\n\r\n                        for (let level of variation.defaultHierarchy.levels)\r\n                            exprs.push(SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));\r\n                    }\r\n                }\r\n            }\r\n\r\n            return exprs;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    // A group can consist of either a single expression, or a collection of hierarchy expressions\r\n    export interface SQExprGroup {\r\n        expr: SQExpr;\r\n        children: SQHierarchyLevelExpr[];\r\n\r\n        /** Index of expression in the query. */\r\n        selectQueryIndex: number;\r\n    };\r\n\r\n    export module SQExprGroupUtils {\r\n        /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */\r\n        export function groupExprs(schema: FederatedConceptualSchema, exprs: SQExpr[]): SQExprGroup[] {\r\n            let groups: SQExprGroup[] = [];\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i];\r\n                debug.assertValue(expr, \"Expression not found\");\r\n\r\n                if (!(expr instanceof SQHierarchyLevelExpr)) {\r\n                    groups.push({ expr: expr, children: null, selectQueryIndex: i });\r\n                }\r\n                else {\r\n                    addChildToGroup(schema, groups, expr, i);\r\n                }\r\n            }\r\n\r\n            return groups;\r\n        }\r\n\r\n        function addChildToGroup(\r\n            schema: FederatedConceptualSchema,\r\n            groups: SQExprGroup[],\r\n            expr: SQHierarchyLevelExpr,\r\n            selectQueryIndex: number): void {\r\n\r\n            // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to \r\n            // a new Group or to the last Group\r\n            let shouldAddExpressionToNewGroup = true;\r\n            let exprSource = SQHierarchyExprUtils.getSourceVariationExpr(expr) || SQHierarchyExprUtils.getSourceHierarchy(expr);\r\n            let lastGroup = _.last(groups);\r\n\r\n            // The relevant group is always the last added. If it has the same source hierarchy,\r\n            // and is properly ordered within that hierarchy, we will need to add to this group.\r\n            if (lastGroup && lastGroup.children && SQExpr.equals(lastGroup.expr, exprSource)) {\r\n                let expandedExpr = SQHierarchyExprUtils.expandExpr(schema, expr.arg);\r\n                if (expandedExpr instanceof Array) {\r\n                    let allHierarchyLevels = <SQHierarchyLevelExpr[]>expandedExpr;\r\n                    shouldAddExpressionToNewGroup = !SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);\r\n                }\r\n            }\r\n\r\n            if (shouldAddExpressionToNewGroup)\r\n                // Use the Sourcevariation as the expression for the group.\r\n                groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });\r\n            else {\r\n                debug.assertValue(lastGroup, 'There should be a group to add the variation to');\r\n                debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');\r\n                lastGroup.children.push(expr);\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    /** Represents an immutable expression within a SemanticQuery. */\r\n    export abstract class SQExpr implements ISQExpr {\r\n        private _kind: SQExprKind;\r\n\r\n        constructor(kind: SQExprKind) {\r\n            debug.assertValue(kind, 'kind');\r\n\r\n            this._kind = kind;\r\n        }\r\n\r\n        public static equals(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            return SQExprEqualityVisitor.run(x, y, ignoreCase);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.accept(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            debug.assertFail('abstract method');\r\n            return;\r\n        }\r\n\r\n        public get kind(): SQExprKind {\r\n            return this._kind;\r\n        }\r\n\r\n        public static isColumn(expr: SQExpr): expr is SQColumnRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ColumnRef;\r\n        }\r\n\r\n        public static isConstant(expr: SQExpr): expr is SQConstantExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Constant;\r\n        }\r\n\r\n        public static isEntity(expr: SQExpr): expr is SQEntityExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Entity;\r\n        }\r\n\r\n        public static isHierarchy(expr: SQExpr): expr is SQHierarchyExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Hierarchy;\r\n        }\r\n\r\n        public static isHierarchyLevel(expr: SQExpr): expr is SQHierarchyLevelExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.HierarchyLevel;\r\n        }\r\n\r\n        public static isAggregation(expr: SQExpr): expr is SQAggregationExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.Aggregation;\r\n        }\r\n\r\n        public static isMeasure(expr: SQExpr): expr is SQMeasureRefExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.MeasureRef;\r\n        }\r\n\r\n        public static isResourcePackageItem(expr: SQExpr): expr is SQResourcePackageItemExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.kind === SQExprKind.ResourcePackageItem;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            if (field.column || field.columnAggr || field.measure)\r\n                return this.getMetadataForProperty(field, federatedSchema);\r\n\r\n            if (field.hierarchyLevel || field.hierarchyLevelAggr)\r\n                return this.getMetadataForHierarchyLevel(field, federatedSchema);\r\n\r\n            if (field.columnHierarchyLevelVariation)\r\n                return this.getMetadataForVariation(field, federatedSchema);\r\n\r\n            if (field.percentOfGrandTotal)\r\n                return this.getMetadataForPercentOfGrandTotal();\r\n\r\n            return SQExpr.getMetadataForEntity(field, federatedSchema);\r\n        }\r\n\r\n        public getDefaultAggregate(federatedSchema: FederatedConceptualSchema, forceAggregation: boolean = false): QueryAggregateFunction {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            let aggregate: QueryAggregateFunction;\r\n\r\n            if (property && property.kind === ConceptualPropertyKind.Column) {\r\n                let propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;\r\n\r\n                if ((property.type.integer || property.type.numeric) &&\r\n                    propertyDefaultAggregate !== ConceptualDefaultAggregate.None) {\r\n                    aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);\r\n                    if (aggregate === undefined)\r\n                        aggregate = defaultAggregateForDataType(property.type);\r\n                }\r\n\r\n                // If we haven't found an appropriate aggregate, and want to force aggregation anyway, \r\n                // aggregate on CountNonNull.\r\n                if (aggregate === undefined && forceAggregation) {\r\n                    aggregate = QueryAggregateFunction.CountNonNull;\r\n                }\r\n            }\r\n\r\n            return aggregate;\r\n        }\r\n\r\n        /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/\r\n        public getKeyColumns(schema: FederatedConceptualSchema): SQExpr[] {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n\r\n            let keySQExprs: SQExpr[] = [];\r\n            let keys = this.getPropertyKeys(schema);\r\n            if (keys && keys.length > 0) {\r\n                for (let i = 0, len = keys.length; i < len; i++) {\r\n                    keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));\r\n                }\r\n            }\r\n            else\r\n                keySQExprs.push(columnRefExpr);\r\n\r\n            return keySQExprs;\r\n        }\r\n\r\n        /** Returns a value indicating whether the expression would group on keys other than itself.*/\r\n        public hasGroupOnKeys(schema: FederatedConceptualSchema): boolean {\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);\r\n            if (!columnRefExpr)\r\n                return;\r\n            let keys = this.getPropertyKeys(schema);\r\n\r\n            if (!keys || keys.length < 1)\r\n                return false;\r\n\r\n            if (keys.length > 1)\r\n                return true;\r\n\r\n            let keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);\r\n            return !SQExpr.equals(keySqExpr, this);\r\n        }\r\n\r\n        private getPropertyKeys(schema: FederatedConceptualSchema): jsCommon.ArrayNamedItems<ConceptualProperty> {\r\n            let property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            return property.column ? property.column.keys : undefined;\r\n        }\r\n\r\n        public getConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let propertyName = FieldExprPattern.getPropertyName(field);\r\n\r\n            if (propertyName)\r\n                return federatedSchema\r\n                    .schema(fieldExprItem.schema)\r\n                    .findProperty(fieldExprItem.entity, propertyName);\r\n        }\r\n\r\n        public getTargetEntityForVariation(federatedSchema: FederatedConceptualSchema, variationName: string): string {\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (property && property.column && !_.isEmpty(property.column.variations)) {\r\n                let variations = property.column.variations;\r\n                for (let variation of variations)\r\n                    if (variation.name === variationName)\r\n                        return variation.navigationProperty.targetEntity.name;\r\n            }\r\n        }\r\n\r\n        public getTargetEntity(federatedSchema: FederatedConceptualSchema): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);\r\n        }\r\n\r\n        private getHierarchyLevelConceptualProperty(federatedSchema: FederatedConceptualSchema): ConceptualProperty {\r\n            let field = SQExprConverter.asFieldPattern(this);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;\r\n            if (fieldExprHierachyLevel) {\r\n                let fieldExprEntity = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n\r\n                let hierarchy = federatedSchema\r\n                    .schema(fieldExprEntity.schema)\r\n                    .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);\r\n\r\n                if (hierarchy) {\r\n                    let hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);\r\n                    if (hierarchyLevel)\r\n                        return hierarchyLevel.column;\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForVariation(field: data.FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let sourceProperty = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);\r\n\r\n            if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {\r\n                for (let variation of sourceProperty.column.variations) {\r\n                    if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {\r\n                        for (let level of variation.defaultHierarchy.levels) {\r\n                            if (level.name === columnHierarchyLevelVariation.level.level) {\r\n                                let property = level.column;\r\n                                return {\r\n                                    kind: (property.kind === ConceptualPropertyKind.Measure) ? FieldKind.Measure : FieldKind.Column,\r\n                                    type: property.type,\r\n                                    format: property.format,\r\n                                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                                    defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n                                };\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        private getMetadataForHierarchyLevel(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getHierarchyLevelConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private getMetadataForPercentOfGrandTotal(): SQExprMetadata {\r\n            return {\r\n                kind: FieldKind.Measure,\r\n                format: '#,##0.##%',\r\n                type: ValueType.fromExtendedType(ExtendedType.Double)\r\n            };\r\n        }\r\n\r\n        private getPropertyMetadata(field: FieldExprPattern, property: ConceptualProperty): SQExprMetadata {\r\n            let format = property.format;\r\n            let type = property.type;\r\n            let columnAggregate = field.columnAggr || field.hierarchyLevelAggr;\r\n\r\n            if (columnAggregate) {\r\n                switch (columnAggregate.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        type = ValueType.fromExtendedType(ExtendedType.Integer);\r\n                        format = undefined;\r\n                        break;\r\n                    case QueryAggregateFunction.Avg:\r\n                        if (type.integer)\r\n                            type = ValueType.fromExtendedType(ExtendedType.Double);\r\n                        break;\r\n                }\r\n            }\r\n\r\n            return {\r\n                kind: (property.kind === ConceptualPropertyKind.Measure || (columnAggregate && columnAggregate.aggregate !== undefined)) ? FieldKind.Measure : FieldKind.Column,\r\n                type: type,\r\n                format: format,\r\n                idOnEntityKey: property.column ? property.column.idOnEntityKey : false,\r\n                aggregate: columnAggregate ? columnAggregate.aggregate : undefined,\r\n                defaultAggregate: property.column ? property.column.defaultAggregate : null\r\n            };\r\n        }\r\n\r\n        private getMetadataForProperty(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let property = this.getConceptualProperty(federatedSchema);\r\n            if (!property)\r\n                return;\r\n\r\n            return this.getPropertyMetadata(field, property);\r\n        }\r\n\r\n        private static getMetadataForEntity(field: FieldExprPattern, federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(field, 'field');\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let entity = federatedSchema\r\n                .schema(fieldExprItem.schema)\r\n                .entities\r\n                .withName(fieldExprItem.entity);\r\n\r\n            if (!entity)\r\n                return;\r\n\r\n            // We only support count and countnonnull for entity.\r\n            if (field.entityAggr) {\r\n                switch (field.entityAggr.aggregate) {\r\n                    case QueryAggregateFunction.Count:\r\n                    case QueryAggregateFunction.CountNonNull:\r\n                        return {\r\n                            kind: FieldKind.Measure,\r\n                            type: ValueType.fromExtendedType(ExtendedType.Integer),\r\n                            format: undefined,\r\n                            idOnEntityKey: false,\r\n                            aggregate: field.entityAggr.aggregate\r\n                        };\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    export const enum SQExprKind {\r\n        Entity,\r\n        ColumnRef,\r\n        MeasureRef,\r\n        Aggregation,\r\n        PropertyVariationSource,\r\n        Hierarchy,\r\n        HierarchyLevel,\r\n        And,\r\n        Between,\r\n        In,\r\n        Or,\r\n        Contains,\r\n        Compare,\r\n        StartsWith,\r\n        Exists,\r\n        Not,\r\n        Constant,\r\n        DateSpan,\r\n        DateAdd,\r\n        Now,\r\n        AnyValue,\r\n        DefaultValue,\r\n        Arithmetic,\r\n        FillRule,\r\n        ResourcePackageItem,\r\n        ScopedEval,\r\n        Scope,\r\n        Percentile,\r\n    }\r\n\r\n    export interface SQExprMetadata {\r\n        kind: FieldKind;\r\n        type: ValueType;\r\n        format?: string;\r\n        idOnEntityKey?: boolean;\r\n        aggregate?: QueryAggregateFunction;\r\n        defaultAggregate?: ConceptualDefaultAggregate;\r\n    }\r\n\r\n    export const enum FieldKind {\r\n        /** Indicates the field references a column, which evaluates to a distinct set of values (e.g., Year, Name, SalesQuantity, etc.). */\r\n        Column,\r\n\r\n        /** Indicates the field references a measure, which evaluates to a single value (e.g., SalesYTD, Sum(Sales), etc.). */\r\n        Measure,\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateForDataType(type: ValueType): QueryAggregateFunction {\r\n        if (type.integer || type.numeric)\r\n            return QueryAggregateFunction.Sum;\r\n\r\n        return QueryAggregateFunction.Count;\r\n    }\r\n\r\n    /** Note: Exported for testability */\r\n    export function defaultAggregateToQueryAggregateFunction(aggregate: ConceptualDefaultAggregate): QueryAggregateFunction {\r\n        switch (aggregate) {\r\n            case ConceptualDefaultAggregate.Average:\r\n                return QueryAggregateFunction.Avg;\r\n            case ConceptualDefaultAggregate.Count:\r\n                return QueryAggregateFunction.CountNonNull;\r\n            case ConceptualDefaultAggregate.DistinctCount:\r\n                return QueryAggregateFunction.Count;\r\n            case ConceptualDefaultAggregate.Max:\r\n                return QueryAggregateFunction.Max;\r\n            case ConceptualDefaultAggregate.Min:\r\n                return QueryAggregateFunction.Min;\r\n            case ConceptualDefaultAggregate.Sum:\r\n                return QueryAggregateFunction.Sum;\r\n            default:\r\n                return;\r\n        }\r\n    }\r\n\r\n    export class SQEntityExpr extends SQExpr {\r\n        public schema: string;\r\n        public entity: string;\r\n        public variable: string;\r\n\r\n        constructor(schema: string, entity: string, variable?: string) {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            super(SQExprKind.Entity);\r\n            this.schema = schema;\r\n            this.entity = entity;\r\n            if (variable)\r\n                this.variable = variable;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitEntity(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQArithmeticExpr extends SQExpr {\r\n        public left: SQExpr;\r\n        public right: SQExpr;\r\n        public operator: ArithmeticOperatorKind;\r\n\r\n        constructor(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n            debug.assertValue(operator, 'operator');\r\n\r\n            super(SQExprKind.Arithmetic);\r\n            this.left = left;\r\n            this.right = right;\r\n            this.operator = operator;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitArithmetic(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQScopedEvalExpr extends SQExpr {\r\n        public expression: SQExpr;\r\n        public scope: SQExpr[];\r\n\r\n        constructor(expression: SQExpr, scope: SQExpr[]) {\r\n            debug.assertValue(expression, 'expression');\r\n            debug.assertValue(scope, 'scope');\r\n\r\n            super(SQExprKind.ScopedEval);\r\n            this.expression = expression;\r\n            this.scope = scope;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitScopedEval(this, arg);\r\n        }\r\n        \r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            return this.expression.getMetadata(federatedSchema);\r\n        }\r\n    }\r\n\r\n    export abstract class SQPropRefExpr extends SQExpr {\r\n        public ref: string;\r\n        public source: SQExpr;\r\n\r\n        constructor(kind: SQExprKind, source: SQExpr, ref: string) {\r\n            debug.assertValue(kind, 'kind');\r\n            debug.assertValue(source, 'source');\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            super(kind);\r\n            this.source = source;\r\n            this.ref = ref;\r\n        }\r\n    }\r\n\r\n    export class SQColumnRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.ColumnRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitColumnRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQMeasureRefExpr extends SQPropRefExpr {\r\n        constructor(source: SQExpr, ref: string) {\r\n            super(SQExprKind.MeasureRef, source, ref);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitMeasureRef(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAggregationExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public func: QueryAggregateFunction;\r\n\r\n        constructor(arg: SQExpr, func: QueryAggregateFunction) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(func, 'func');\r\n\r\n            super(SQExprKind.Aggregation);\r\n            this.arg = arg;\r\n            this.func = func;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAggr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPercentileExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public k: number;\r\n        public exclusive: boolean;\r\n\r\n        constructor(arg: SQExpr, k: number, exclusive: boolean) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(k, 'k');\r\n            debug.assert(0 <= k && k <= 1, '0 <= k && k <= 1');\r\n            debug.assertValue(exclusive, 'exclusive');\r\n\r\n            super(SQExprKind.Percentile);\r\n            this.arg = arg;\r\n            this.k = k;\r\n            this.exclusive = exclusive;\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            let argMetadata = this.arg.getMetadata(federatedSchema);\r\n            if (argMetadata) {\r\n                return {\r\n                    kind: FieldKind.Measure,\r\n                    type: argMetadata.type,\r\n                };\r\n            }\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPercentile(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQPropertyVariationSourceExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public name: string;\r\n        public property: string;\r\n\r\n        constructor(arg: SQExpr, name: string, property: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(name, 'name');\r\n            debug.assertValue(property, 'property');\r\n\r\n            super(SQExprKind.PropertyVariationSource);\r\n            this.arg = arg;\r\n            this.name = name;\r\n            this.property = property;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitPropertyVariationSource(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public hierarchy: string;\r\n\r\n        constructor(arg: SQExpr, hierarchy: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(hierarchy, 'hierarchy');\r\n\r\n            super(SQExprKind.Hierarchy);\r\n            this.arg = arg;\r\n            this.hierarchy = hierarchy;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchy(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQHierarchyLevelExpr extends SQExpr {\r\n        public arg: SQExpr;\r\n        public level: string;\r\n\r\n        constructor(arg: SQExpr, level: string) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(level, 'level');\r\n\r\n            super(SQExprKind.HierarchyLevel);\r\n            this.arg = arg;\r\n            this.level = level;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitHierarchyLevel(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAndExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.And);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQBetweenExpr extends SQExpr {\r\n        arg: SQExpr;\r\n        lower: SQExpr;\r\n        upper: SQExpr;\r\n\r\n        constructor(arg: SQExpr, lower: SQExpr, upper: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n            debug.assertValue(lower, 'lower');\r\n            debug.assertValue(upper, 'upper');\r\n\r\n            super(SQExprKind.Between);\r\n            this.arg = arg;\r\n            this.lower = lower;\r\n            this.upper = upper;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitBetween(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQInExpr extends SQExpr {\r\n        args: SQExpr[];\r\n        values: SQExpr[][];\r\n\r\n        constructor(args: SQExpr[], values: SQExpr[][]) {\r\n            debug.assertValue(args, 'args');\r\n            debug.assertValue(values, 'values');\r\n\r\n            super(SQExprKind.In);\r\n            this.args = args;\r\n            this.values = values;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitIn(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQOrExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Or);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitOr(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQCompareExpr extends SQExpr {\r\n        comparison: QueryComparisonKind;\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(comparison: QueryComparisonKind, left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(comparison, 'kind');\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Compare);\r\n            this.comparison = comparison;\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitCompare(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQContainsExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.Contains);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitContains(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQStartsWithExpr extends SQExpr {\r\n        left: SQExpr;\r\n        right: SQExpr;\r\n\r\n        constructor(left: SQExpr, right: SQExpr) {\r\n            debug.assertValue(left, 'left');\r\n            debug.assertValue(right, 'right');\r\n\r\n            super(SQExprKind.StartsWith);\r\n            this.left = left;\r\n            this.right = right;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitStartsWith(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQExistsExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Exists);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitExists(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNotExpr extends SQExpr {\r\n        arg: SQExpr;\r\n\r\n        constructor(arg: SQExpr) {\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.Not);\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNot(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQConstantExpr extends SQExpr implements ISQConstantExpr {\r\n        public type: ValueType;\r\n\r\n        /** The native JavaScript representation of the value. */\r\n        public value: any;\r\n\r\n        /** The string encoded, lossless representation of the value. */\r\n        public valueEncoded: string;\r\n\r\n        constructor(type: ValueType, value: any, valueEncoded: string) {\r\n            debug.assertValue(type, 'type');\r\n\r\n            super(SQExprKind.Constant);\r\n            this.type = type;\r\n            this.value = value;\r\n            this.valueEncoded = valueEncoded;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitConstant(this, arg);\r\n        }\r\n\r\n        public getMetadata(federatedSchema: FederatedConceptualSchema): SQExprMetadata {\r\n            debug.assertValue(federatedSchema, 'federatedSchema');\r\n\r\n            return {\r\n                // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.\r\n                // A getType or similiar function in the future would be more appropriate. \r\n                kind: FieldKind.Measure,\r\n                type: this.type,\r\n            };\r\n        }\r\n    }\r\n\r\n    export class SQDateSpanExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateSpan);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateSpan(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDateAddExpr extends SQExpr {\r\n        public unit: TimeUnit;\r\n        public amount: number;\r\n        public arg: SQExpr;\r\n\r\n        constructor(unit: TimeUnit, amount: number, arg: SQExpr) {\r\n            debug.assertValue(unit, 'unit');\r\n            debug.assertValue(amount, 'amount');\r\n            debug.assertValue(arg, 'arg');\r\n\r\n            super(SQExprKind.DateAdd);\r\n            this.unit = unit;\r\n            this.arg = arg;\r\n            this.amount = amount;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDateAdd(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQNowExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.Now);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitNow(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQDefaultValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.DefaultValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitDefaultValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQAnyValueExpr extends SQExpr {\r\n        constructor() {\r\n            super(SQExprKind.AnyValue);\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitAnyValue(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQFillRuleExpr extends SQExpr {\r\n        public input: SQExpr;\r\n        public rule: FillRuleDefinition;\r\n\r\n        constructor(\r\n            input: SQExpr,\r\n            fillRule: FillRuleDefinition) {\r\n            debug.assertValue(input, 'input');\r\n            debug.assertValue(fillRule, 'fillRule');\r\n\r\n            super(SQExprKind.FillRule);\r\n            this.input = input;\r\n            this.rule = fillRule;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitFillRule(this, arg);\r\n        }\r\n    }\r\n\r\n    export class SQResourcePackageItemExpr extends SQExpr {\r\n        public packageName: string;\r\n        public packageType: number;\r\n        public itemName: string;\r\n\r\n        constructor(packageName: string, packageType: number, itemName: string) {\r\n            debug.assertValue(packageName, 'packageName');\r\n            debug.assertValue(itemName, 'itemName');\r\n\r\n            super(SQExprKind.ResourcePackageItem);\r\n            this.packageName = packageName;\r\n            this.packageType = packageType;\r\n            this.itemName = itemName;\r\n        }\r\n\r\n        public accept<T, TArg>(visitor: ISQExprVisitorWithArg<T, TArg>, arg?: TArg): T {\r\n            return visitor.visitResourcePackageItem(this, arg);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for creating & manipulating expressions. */\r\n    export module SQExprBuilder {\r\n        export function entity(schema: string, entity: string, variable?: string): SQEntityExpr {\r\n            return new SQEntityExpr(schema, entity, variable);\r\n        }\r\n\r\n        export function columnRef(source: SQExpr, prop: string): SQColumnRefExpr {\r\n            return new SQColumnRefExpr(source, prop);\r\n        }\r\n\r\n        export function measureRef(source: SQExpr, prop: string): SQMeasureRefExpr {\r\n            return new SQMeasureRefExpr(source, prop);\r\n        }\r\n\r\n        export function aggregate(source: SQExpr, aggregate: QueryAggregateFunction): SQAggregationExpr {\r\n            return new SQAggregationExpr(source, aggregate);\r\n        }\r\n\r\n        export function percentile(source: SQExpr, k: number, exclusive: boolean): SQPercentileExpr {\r\n            return new SQPercentileExpr(source, k, exclusive);\r\n        }\r\n\r\n        export function arithmetic(left: SQExpr, right: SQExpr, operator: ArithmeticOperatorKind): SQArithmeticExpr {\r\n            return new SQArithmeticExpr(left, right, operator);\r\n        }\r\n\r\n        export function scopedEval(expression: SQExpr, scope: SQExpr[]): SQScopedEvalExpr {\r\n            return new SQScopedEvalExpr(expression, scope);\r\n        }\r\n\r\n        export function hierarchy(source: SQExpr, hierarchy: string): SQHierarchyExpr {\r\n            return new SQHierarchyExpr(source, hierarchy);\r\n        }\r\n\r\n        export function propertyVariationSource(source: SQExpr, name: string, property: string): SQPropertyVariationSourceExpr {\r\n            return new SQPropertyVariationSourceExpr(source, name, property);\r\n        }\r\n\r\n        export function hierarchyLevel(source: SQExpr, level: string): SQHierarchyLevelExpr {\r\n            return new SQHierarchyLevelExpr(source, level);\r\n        }\r\n\r\n        export function and(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n\r\n            return new SQAndExpr(left, right);\r\n        }\r\n\r\n        export function between(arg: SQExpr, lower: SQExpr, upper: SQExpr): SQBetweenExpr {\r\n            return new SQBetweenExpr(arg, lower, upper);\r\n        }\r\n\r\n        export function inExpr(args: SQExpr[], values: SQExpr[][]): SQInExpr {\r\n            return new SQInExpr(args, values);\r\n        }\r\n\r\n        export function or(left: SQExpr, right: SQExpr): SQExpr {\r\n            if (!left)\r\n                return right;\r\n            if (!right)\r\n                return left;\r\n            if (left instanceof SQInExpr && right instanceof SQInExpr) {\r\n                let inExpr = tryUseInExprs(<SQInExpr>left, <SQInExpr>right);\r\n                if (inExpr)\r\n                    return inExpr;\r\n            }\r\n\r\n            return new SQOrExpr(left, right);\r\n        }\r\n\r\n        function tryUseInExprs(left: SQInExpr, right: SQInExpr): SQInExpr {\r\n            if (!left.args || !right.args)\r\n                return;\r\n\r\n            let leftArgLen = left.args.length;\r\n            let rightArgLen = right.args.length;\r\n            if (leftArgLen !== rightArgLen)\r\n                return;\r\n\r\n            for (let i = 0; i < leftArgLen; ++i) {\r\n                if (!SQExpr.equals(left.args[i], right.args[i]))\r\n                    return;\r\n            }\r\n\r\n            let combinedValues = left.values.concat(right.values);\r\n            return SQExprBuilder.inExpr(left.args, combinedValues);\r\n        }\r\n\r\n        export function compare(kind: QueryComparisonKind, left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return new SQCompareExpr(kind, left, right);\r\n        }\r\n\r\n        export function contains(left: SQExpr, right: SQExpr): SQContainsExpr {\r\n            return new SQContainsExpr(left, right);\r\n        }\r\n\r\n        export function exists(arg: SQExpr): SQExistsExpr {\r\n            return new SQExistsExpr(arg);\r\n        }\r\n\r\n        export function equal(left: SQExpr, right: SQExpr): SQCompareExpr {\r\n            return compare(QueryComparisonKind.Equal, left, right);\r\n        }\r\n\r\n        export function not(arg: SQExpr): SQNotExpr {\r\n            return new SQNotExpr(arg);\r\n        }\r\n\r\n        export function startsWith(left: SQExpr, right: SQExpr): SQStartsWithExpr {\r\n            return new SQStartsWithExpr(left, right);\r\n        }\r\n\r\n        export function nullConstant(): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Null),\r\n                null,\r\n                PrimitiveValueEncoding.nullEncoding());\r\n        }\r\n\r\n        export function now(): SQNowExpr {\r\n            return new SQNowExpr();\r\n        }\r\n\r\n        export function defaultValue(): SQDefaultValueExpr {\r\n            return new SQDefaultValueExpr();\r\n        }\r\n\r\n        export function anyValue(): SQAnyValueExpr {\r\n            return new SQAnyValueExpr();\r\n        }\r\n\r\n        export function boolean(value: boolean): SQConstantExpr {\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Boolean),\r\n                value,\r\n                PrimitiveValueEncoding.boolean(value));\r\n        }\r\n\r\n        export function dateAdd(unit: TimeUnit, amount: number, arg: SQExpr): SQDateAddExpr {\r\n            return new SQDateAddExpr(unit, amount, arg);\r\n        }\r\n\r\n        export function dateTime(value: Date, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.dateTime(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.DateTime), value, valueEncoded);\r\n        }\r\n\r\n        export function dateSpan(unit: TimeUnit, arg: SQExpr): SQDateSpanExpr {\r\n            return new SQDateSpanExpr(unit, arg);\r\n        }\r\n\r\n        export function decimal(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.decimal(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Decimal), value, valueEncoded);\r\n        }\r\n\r\n        export function double(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.double(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Double), value, valueEncoded);\r\n        }\r\n\r\n        export function integer(value: number, valueEncoded?: string): SQConstantExpr {\r\n            if (valueEncoded === undefined)\r\n                valueEncoded = PrimitiveValueEncoding.integer(value);\r\n\r\n            return new SQConstantExpr(ValueType.fromExtendedType(ExtendedType.Integer), value, valueEncoded);\r\n        }\r\n\r\n        export function text(value: string, valueEncoded?: string): SQConstantExpr {\r\n            debug.assert(!valueEncoded || valueEncoded === PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');\r\n\r\n            return new SQConstantExpr(\r\n                ValueType.fromExtendedType(ExtendedType.Text),\r\n                value,\r\n                valueEncoded || PrimitiveValueEncoding.text(value));\r\n        }\r\n\r\n        /** Returns an SQExpr that evaluates to the constant value. */\r\n        export function typedConstant(value: PrimitiveValue, type: ValueTypeDescriptor): SQConstantExpr {\r\n            if (value == null)\r\n                return nullConstant();\r\n\r\n            if (_.isBoolean(value)) {\r\n                return boolean(<boolean>value);\r\n            }\r\n\r\n            if (_.isString(value)) {\r\n                return text(<string>value);\r\n            }\r\n\r\n            if (_.isNumber(value)) {\r\n                if (type.integer && Double.isInteger(<number>value))\r\n                    return integer(<number>value);\r\n\r\n                return double(<number>value);\r\n            }\r\n\r\n            if (value instanceof Date) {\r\n                return dateTime(value);\r\n            }\r\n        }\r\n\r\n        export function setAggregate(expr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return FieldExprChangeAggregateRewriter.rewrite(expr, aggregate);\r\n        }\r\n\r\n        export function removeAggregate(expr: SQExpr): SQExpr {\r\n            return SQExprRemoveAggregateRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function setPercentOfGrandTotal(expr: SQExpr): SQExpr {\r\n            return SQExprSetPercentOfGrandTotalRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removePercentOfGrandTotal(expr: SQExpr): SQExpr {\r\n            return SQExprRemovePercentOfGrandTotalRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function removeEntityVariables(expr: SQExpr): SQExpr {\r\n            return SQExprRemoveEntityVariablesRewriter.rewrite(expr);\r\n        }\r\n\r\n        export function fillRule(expr: SQExpr, rule: FillRuleDefinition): SQFillRuleExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(rule, 'rule');\r\n\r\n            return new SQFillRuleExpr(expr, rule);\r\n        }\r\n\r\n        export function resourcePackageItem(packageName: string, packageType: number, itemName: string): SQResourcePackageItemExpr {\r\n            return new SQResourcePackageItemExpr(packageName, packageType, itemName);\r\n        }\r\n    }\r\n\r\n    /** Provides utilities for obtaining information about expressions. */\r\n    export module SQExprInfo {\r\n        export function getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            return SQExprAggregateInfoVisitor.getAggregate(expr);\r\n        }\r\n    }\r\n\r\n    class SQExprEqualityVisitor implements ISQExprVisitorWithArg<boolean, SQExpr>, IFillRuleDefinitionVisitor<boolean, boolean> {\r\n        private static instance: SQExprEqualityVisitor = new SQExprEqualityVisitor(/* ignoreCase */ false);\r\n        private static ignoreCaseInstance: SQExprEqualityVisitor = new SQExprEqualityVisitor(true);\r\n        private ignoreCase: boolean;\r\n\r\n        public static run(x: SQExpr, y: SQExpr, ignoreCase?: boolean): boolean {\r\n            // Normalize falsy to null\r\n            x = x || null;\r\n            y = y || null;\r\n\r\n            if (x === y)\r\n                return true;\r\n\r\n            if (!x !== !y)\r\n                return false;\r\n\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n            if (ignoreCase)\r\n                return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);\r\n\r\n            return x.accept(SQExprEqualityVisitor.instance, y);\r\n        }\r\n\r\n        constructor(ignoreCase: boolean) {\r\n            this.ignoreCase = ignoreCase;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr, comparand: SQColumnRefExpr): boolean {\r\n            return comparand instanceof SQColumnRefExpr &&\r\n                expr.ref === (<SQColumnRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQColumnRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr, comparand: SQMeasureRefExpr): boolean {\r\n            return comparand instanceof SQMeasureRefExpr &&\r\n                expr.ref === (<SQMeasureRefExpr>comparand).ref &&\r\n                this.equals(expr.source, (<SQMeasureRefExpr>comparand).source);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAggregationExpr &&\r\n                expr.func === (<SQAggregationExpr>comparand).func &&\r\n                this.equals(expr.arg, (<SQAggregationExpr>comparand).arg);\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQPercentileExpr &&\r\n                expr.exclusive === comparand.exclusive &&\r\n                expr.k === comparand.k &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr, comparand: SQHierarchyExpr): boolean {\r\n            return comparand instanceof SQHierarchyExpr &&\r\n                expr.hierarchy === comparand.hierarchy &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr, comparand: SQHierarchyLevelExpr): boolean {\r\n            return comparand instanceof SQHierarchyLevelExpr &&\r\n                expr.level === comparand.level &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr, comparand: SQPropertyVariationSourceExpr): boolean {\r\n            return comparand instanceof SQPropertyVariationSourceExpr &&\r\n                expr.name === comparand.name &&\r\n                expr.property === comparand.property &&\r\n                this.equals(expr.arg, comparand.arg);\r\n        }\r\n\r\n        public visitBetween(expr: SQBetweenExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQBetweenExpr &&\r\n                this.equals(expr.arg, (<SQBetweenExpr>comparand).arg) &&\r\n                this.equals(expr.lower, (<SQBetweenExpr>comparand).lower) &&\r\n                this.equals(expr.upper, (<SQBetweenExpr>comparand).upper);\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr, comparand: SQExpr): boolean {\r\n            if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, (<SQInExpr>comparand).args))\r\n                return false;\r\n\r\n            let values = expr.values,\r\n                compareValues = (<SQInExpr>comparand).values;\r\n            if (values.length !== compareValues.length)\r\n                return false;\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                if (!this.equalsAll(values[i], compareValues[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQEntityExpr &&\r\n                expr.schema === (<SQEntityExpr>comparand).schema &&\r\n                expr.entity === (<SQEntityExpr>comparand).entity &&\r\n                this.optionalEqual(expr.variable, (<SQEntityExpr>comparand).variable);\r\n        }\r\n\r\n        public visitAnd(expr: SQAndExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAndExpr &&\r\n                this.equals(expr.left, (<SQAndExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQAndExpr>comparand).right);\r\n        }\r\n\r\n        public visitOr(expr: SQOrExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQOrExpr &&\r\n                this.equals(expr.left, (<SQOrExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQOrExpr>comparand).right);\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQCompareExpr &&\r\n                expr.comparison === (<SQCompareExpr>comparand).comparison &&\r\n                this.equals(expr.left, (<SQCompareExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQCompareExpr>comparand).right);\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQContainsExpr &&\r\n                this.equals(expr.left, (<SQContainsExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQContainsExpr>comparand).right);\r\n        }\r\n\r\n        public visitDateSpan(expr: SQDateSpanExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateSpanExpr &&\r\n                expr.unit === (<SQDateSpanExpr>comparand).unit &&\r\n                this.equals(expr.arg, (<SQDateSpanExpr>comparand).arg);\r\n        }\r\n\r\n        public visitDateAdd(expr: SQDateAddExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDateAddExpr &&\r\n                expr.unit === (<SQDateAddExpr>comparand).unit &&\r\n                expr.amount === (<SQDateAddExpr>comparand).amount &&\r\n                this.equals(expr.arg, (<SQDateAddExpr>comparand).arg);\r\n        }\r\n\r\n        public visitExists(expr: SQExistsExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQExistsExpr &&\r\n                this.equals(expr.arg, (<SQExistsExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNot(expr: SQNotExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNotExpr &&\r\n                this.equals(expr.arg, (<SQNotExpr>comparand).arg);\r\n        }\r\n\r\n        public visitNow(expr: SQNowExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQNowExpr;\r\n        }\r\n\r\n        public visitDefaultValue(expr: SQDefaultValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQDefaultValueExpr;\r\n        }\r\n\r\n        public visitAnyValue(expr: SQAnyValueExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQAnyValueExpr;\r\n        }\r\n\r\n        public visitResourcePackageItem(expr: SQResourcePackageItemExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQResourcePackageItemExpr &&\r\n                expr.packageName === comparand.packageName &&\r\n                expr.packageType === comparand.packageType &&\r\n                expr.itemName === comparand.itemName;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQStartsWithExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQStartsWithExpr &&\r\n                this.equals(expr.left, (<SQStartsWithExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQStartsWithExpr>comparand).right);\r\n        }\r\n\r\n        public visitConstant(expr: SQConstantExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQConstantExpr && expr.type === (<SQConstantExpr>comparand).type)\r\n                return expr.type.text && this.ignoreCase ?\r\n                    StringExtensions.equalIgnoreCase(expr.valueEncoded, (<SQConstantExpr>comparand).valueEncoded) :\r\n                    expr.valueEncoded === (<SQConstantExpr>comparand).valueEncoded;\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitFillRule(expr: SQFillRuleExpr, comparand: SQExpr): boolean {\r\n            if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {\r\n                let leftRule = expr.rule,\r\n                    rightRule = comparand.rule;\r\n\r\n                if (leftRule === rightRule)\r\n                    return true;\r\n\r\n                let leftLinearGradient2 = leftRule.linearGradient2,\r\n                    rightLinearGradient2 = rightRule.linearGradient2;\r\n                if (leftLinearGradient2 && rightLinearGradient2) {\r\n                    return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);\r\n                }\r\n\r\n                let leftLinearGradient3 = leftRule.linearGradient3,\r\n                    rightLinearGradient3 = rightRule.linearGradient3;\r\n                if (leftLinearGradient3 && rightLinearGradient3) {\r\n                    return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        public visitLinearGradient2(left2: LinearGradient2Definition, right2: LinearGradient2Definition): boolean {\r\n            debug.assertValue(left2, 'left2');\r\n            debug.assertValue(right2, 'right2');\r\n\r\n            return this.equalsFillRuleStop(left2.min, right2.min) &&\r\n                this.equalsFillRuleStop(left2.max, right2.max);\r\n        }\r\n\r\n        public visitLinearGradient3(left3: LinearGradient3Definition, right3: LinearGradient3Definition): boolean {\r\n            debug.assertValue(left3, 'left3');\r\n            debug.assertValue(right3, 'right3');\r\n\r\n            return this.equalsFillRuleStop(left3.min, right3.min) &&\r\n                this.equalsFillRuleStop(left3.mid, right3.mid) &&\r\n                this.equalsFillRuleStop(left3.max, right3.max);\r\n        }\r\n\r\n        private equalsFillRuleStop(stop1: RuleColorStopDefinition, stop2: RuleColorStopDefinition): boolean {\r\n            debug.assertValue(stop1, 'stop1');\r\n            debug.assertValue(stop2, 'stop2');\r\n\r\n            if (!this.equals(stop1.color, stop2.color))\r\n                return false;\r\n\r\n            if (!stop1.value)\r\n                return stop1.value === stop2.value;\r\n\r\n            return this.equals(stop1.value, stop2.value);\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQArithmeticExpr &&\r\n                expr.operator === (<SQArithmeticExpr>comparand).operator &&\r\n                this.equals(expr.left, (<SQArithmeticExpr>comparand).left) &&\r\n                this.equals(expr.right, (<SQArithmeticExpr>comparand).right);\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr, comparand: SQExpr): boolean {\r\n            return comparand instanceof SQScopedEvalExpr &&\r\n                this.equals(expr.expression, comparand.expression) &&\r\n                this.equalsAll(expr.scope, comparand.scope);\r\n        }\r\n\r\n        private optionalEqual(x: string, y: string) {\r\n            // Only check equality if both values are specified.\r\n            if (x && y)\r\n                return x === y;\r\n\r\n            return true;\r\n        }\r\n\r\n        private equals(x: SQExpr, y: SQExpr): boolean {\r\n            return x.accept(this, y);\r\n        }\r\n\r\n        private equalsAll(x: SQExpr[], y: SQExpr[]): boolean {\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!this.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /** Rewrites a root-level expression. */\r\n    class SQExprRootRewriter extends DefaultSQExprVisitor<SQExpr> {\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    export const enum SQExprValidationError {\r\n        invalidAggregateFunction,\r\n        invalidSchemaReference,\r\n        invalidEntityReference,\r\n        invalidColumnReference,\r\n        invalidMeasureReference,\r\n        invalidHierarchyReference,\r\n        invalidHierarchyLevelReference,\r\n        invalidLeftOperandType,\r\n        invalidRightOperandType,\r\n        invalidValueType,\r\n        invalidPercentileArgument,\r\n    }\r\n\r\n    export class SQExprValidationVisitor extends SQExprRewriter {\r\n        public errors: SQExprValidationError[];\r\n        private schema: FederatedConceptualSchema;\r\n        private aggrUtils: ISQAggregationOperations;\r\n\r\n        constructor(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]) {\r\n            debug.assertValue(schema, 'schema');\r\n            debug.assertValue(aggrUtils, 'aggrUtils');\r\n\r\n            super();\r\n            this.schema = schema;\r\n            this.aggrUtils = aggrUtils;\r\n            if (errors)\r\n                this.errors = errors;\r\n        }\r\n\r\n        public visitIn(expr: SQInExpr): SQExpr {\r\n            let inExpr = <SQInExpr>super.visitIn(expr);\r\n            let args = inExpr.args;\r\n            let values = inExpr.values;\r\n            for (let valueTuple of values) {\r\n                debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');\r\n                for (let i = 0, len = valueTuple.length; i < len; ++i)\r\n                    this.validateCompatibleType(args[i], valueTuple[i]);\r\n            }\r\n\r\n            return inExpr;\r\n        }\r\n\r\n        public visitCompare(expr: SQCompareExpr): SQExpr {\r\n            let compareExpr = <SQCompareExpr>super.visitCompare(expr);\r\n            this.validateCompatibleType(compareExpr.left, compareExpr.right);\r\n\r\n            return compareExpr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.column.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Column ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidColumnReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n                let entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);\r\n                if (entity) {\r\n                    let prop = entity.properties.withName(fieldExpr.measure.name);\r\n                    if (!prop ||\r\n                        prop.kind !== ConceptualPropertyKind.Measure ||\r\n                        !this.isQueryable(fieldExpr))\r\n                        this.register(SQExprValidationError.invalidMeasureReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            let aggregateExpr = <SQAggregationExpr>super.visitAggr(expr);\r\n\r\n            let columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);\r\n            if (columnRefExpr) {\r\n                if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/null))\r\n                    this.register(SQExprValidationError.invalidAggregateFunction);\r\n            }\r\n\r\n            return aggregateExpr;\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let fieldExprItem: FieldExprHierarchyPattern = <FieldExprHierarchyPattern>fieldExpr.hierarchy;\r\n                if (fieldExprItem) {\r\n                    this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);\r\n                } else {\r\n                    this.register(SQExprValidationError.invalidHierarchyReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr) {\r\n                let hierarchyLevelFieldExprItem: FieldExprHierarchyLevelPattern = <FieldExprHierarchyLevelPattern>fieldExpr.hierarchyLevel;\r\n                if (hierarchyLevelFieldExprItem) {\r\n                    this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);\r\n                } else if (!fieldExpr.columnHierarchyLevelVariation) {\r\n                    this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n                }\r\n            }\r\n            return expr;\r\n        }\r\n\r\n        public visitPercentile(expr: SQPercentileExpr): SQExpr {\r\n            expr.arg.accept(this);\r\n\r\n            if (_.isEmpty(this.errors)) {\r\n                let argMetadata = expr.arg.getMetadata(this.schema);\r\n                if (!argMetadata ||\r\n                    argMetadata.kind !== FieldKind.Column ||\r\n                    !(argMetadata.type && (argMetadata.type.integer || argMetadata.type.numeric))) {\r\n                    this.register(SQExprValidationError.invalidPercentileArgument);\r\n                }\r\n            }\r\n\r\n            return expr;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            this.validateEntity(expr.schema, expr.entity);\r\n            return expr;\r\n        }\r\n\r\n        public visitContains(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitStartsWith(expr: SQContainsExpr): SQExpr {\r\n            this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitArithmetic(expr: SQArithmeticExpr): SQExpr {\r\n            this.validateArithmeticTypes(expr.left, expr.right);\r\n            return expr;\r\n        }\r\n\r\n        public visitScopedEval(expr: SQScopedEvalExpr): SQExpr {\r\n            // No validation necessary\r\n            return expr;\r\n        }\r\n\r\n        private validateOperandsAndTypeForStartOrContains(left: SQExpr, right: SQExpr): void {\r\n            if (left instanceof SQColumnRefExpr) {\r\n                this.visitColumnRef(<SQColumnRefExpr>left);\r\n            } else if (left instanceof SQHierarchyLevelExpr) {\r\n                this.visitHierarchyLevel(<SQHierarchyLevelExpr>left);\r\n            } else {\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            }\r\n\r\n            if (!(right instanceof SQConstantExpr) || !(<SQConstantExpr>right).type.text)\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n            else\r\n                this.validateCompatibleType(left, right);\r\n        }\r\n\r\n        private validateArithmeticTypes(left: SQExpr, right: SQExpr): void {\r\n            if (!SQExprUtils.supportsArithmetic(left, this.schema))\r\n                this.register(SQExprValidationError.invalidLeftOperandType);\r\n            if (!SQExprUtils.supportsArithmetic(right, this.schema))\r\n                this.register(SQExprValidationError.invalidRightOperandType);\r\n        }\r\n\r\n        private validateCompatibleType(left: SQExpr, right: SQExpr): void {\r\n            let leftMetadata = left.getMetadata(this.schema),\r\n                leftType = leftMetadata && leftMetadata.type,\r\n                rightMetadata = right.getMetadata(this.schema),\r\n                rightType = rightMetadata && rightMetadata.type;\r\n\r\n            if (leftType && rightType && !leftType.isCompatibleFrom(rightType))\r\n                this.register(SQExprValidationError.invalidValueType);\r\n        }\r\n\r\n        private validateEntity(schemaName: string, entityName: string): ConceptualEntity {\r\n            let schema = this.schema.schema(schemaName);\r\n            if (schema) {\r\n                let entity = schema.entities.withName(entityName);\r\n                if (entity)\r\n                    return entity;\r\n\r\n                this.register(SQExprValidationError.invalidEntityReference);\r\n            }\r\n            else {\r\n                this.register(SQExprValidationError.invalidSchemaReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchy(schemaName: string, entityName: string, hierarchyName: string): ConceptualHierarchy {\r\n            let entity = this.validateEntity(schemaName, entityName);\r\n            if (entity) {\r\n                let hierarchy = entity.hierarchies.withName(hierarchyName);\r\n                if (hierarchy)\r\n                    return hierarchy;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyReference);\r\n            }\r\n        }\r\n\r\n        private validateHierarchyLevel(schemaName: string, entityName: string, hierarchyName: string, levelName: string): ConceptualHierarchyLevel {\r\n            let hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);\r\n            if (hierarchy) {\r\n                let hierarchyLevel = hierarchy.levels.withName(levelName);\r\n                if (hierarchyLevel)\r\n                    return hierarchyLevel;\r\n\r\n                this.register(SQExprValidationError.invalidHierarchyLevelReference);\r\n            }\r\n        }\r\n\r\n        private register(error: SQExprValidationError) {\r\n            if (!this.errors)\r\n                this.errors = [];\r\n            this.errors.push(error);\r\n        }\r\n\r\n        private isQueryable(fieldExpr: FieldExprPattern): boolean {\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);\r\n            if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {\r\n                let hierarchyLevelConceptualProperty = SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);\r\n                return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== ConceptualQueryableState.Error;\r\n            }\r\n\r\n            return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, FieldExprPattern.getPropertyName(fieldExpr)).queryable !== ConceptualQueryableState.Error;\r\n        }\r\n    }\r\n\r\n    /** Returns an expression's aggregate function, or undefined if it doesn't have one. */\r\n    class SQExprAggregateInfoVisitor extends DefaultSQExprVisitor<QueryAggregateFunction> {\r\n        public visitAggr(expr: SQAggregationExpr): QueryAggregateFunction {\r\n            return expr.func;\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): QueryAggregateFunction {\r\n            return;\r\n        }\r\n\r\n        public static getAggregate(expr: SQExpr): QueryAggregateFunction {\r\n            let visitor = new SQExprAggregateInfoVisitor();\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQExprColumnRef expression or undefined.*/\r\n    class SQExprColumnRefInfoVisitor extends DefaultSQExprVisitor<SQColumnRefExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQColumnRefExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQColumnRefExpr {\r\n            let ref: string = expr.level;\r\n            let hierarchy = <SQHierarchyExpr>(expr.arg);\r\n            let sourceExpr: SQColumnRefExpr = hierarchy.accept(this);\r\n\r\n            if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {\r\n                let propertyVariationSource = <SQPropertyVariationSourceExpr>hierarchy.arg;\r\n                let targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);\r\n\r\n                if (sourceExpr && targetEntity) {\r\n                    let schemaName = (<SQEntityExpr>(sourceExpr.source)).schema;\r\n                    let targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);\r\n                    let schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);\r\n\r\n                    if (schemaHierarchy) {\r\n                        for (let level of schemaHierarchy.levels)\r\n                            if (level.name === ref)\r\n                                return new SQColumnRefExpr(targetEntityExpr, level.column.name);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let entityExpr = <SQEntityExpr>(hierarchy.arg);\r\n                let hierarchyLevelRef = SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema,\r\n                    entityExpr.schema,\r\n                    entityExpr.entity,\r\n                    hierarchy.hierarchy,\r\n                    expr.level);\r\n\r\n                if (hierarchyLevelRef)\r\n                    return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);\r\n            }\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQColumnRefExpr {\r\n            let propertyName = expr.property;\r\n            return new SQColumnRefExpr(expr.arg, propertyName);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQColumnRefExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQColumnRefExpr {\r\n            return;\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    /** Returns a SQEntityExpr expression or undefined.*/\r\n    class SQEntityExprInfoVisitor extends DefaultSQExprVisitor<SQEntityExpr> {\r\n        private schema: FederatedConceptualSchema;\r\n\r\n        constructor(schema: FederatedConceptualSchema) {\r\n            super();\r\n            this.schema = schema;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQEntityExpr {\r\n            return expr;\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQEntityExpr {\r\n            return SQEntityExprInfoVisitor.getEntity(expr);\r\n        }\r\n\r\n        public visitHierarchyLevel(expr: SQHierarchyLevelExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitHierarchy(expr: SQHierarchyExpr): SQEntityExpr {\r\n            return expr.arg.accept(this);\r\n        }\r\n\r\n        public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQEntityExpr {\r\n            let columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);\r\n            return SQEntityExprInfoVisitor.getEntity(columnRef);\r\n        }\r\n\r\n        public visitMeasureRef(expr: SQMeasureRefExpr): SQEntityExpr {\r\n            return expr.source.accept(this);\r\n        }\r\n\r\n        public static getColumnRefSQExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQColumnRefExpr {\r\n            let visitor = new SQExprColumnRefInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n\r\n        public static getEntity(columnRef: SQColumnRefExpr): SQEntityExpr {\r\n            let field = SQExprConverter.asFieldPattern(columnRef);\r\n            let column = field.column;\r\n            return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);\r\n        }\r\n\r\n        public static getEntityExpr(schema: FederatedConceptualSchema, expr: SQExpr): SQEntityExpr {\r\n            let visitor = new SQEntityExprInfoVisitor(schema);\r\n            return expr.accept(visitor);\r\n        }\r\n    }\r\n\r\n    class SQExprChangeAggregateRewriter extends SQExprRootRewriter {\r\n        private func: QueryAggregateFunction;\r\n\r\n        constructor(func: QueryAggregateFunction) {\r\n            debug.assertValue(func, 'func');\r\n\r\n            super();\r\n            this.func = func;\r\n        }\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            if (expr.func === this.func)\r\n                return expr;\r\n\r\n            return new SQAggregationExpr(expr.arg, this.func);\r\n        }\r\n\r\n        public visitColumnRef(expr: SQColumnRefExpr): SQExpr {\r\n            return new SQAggregationExpr(expr, this.func);\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, func: QueryAggregateFunction): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(func, 'func');\r\n\r\n            let rewriter = new SQExprChangeAggregateRewriter(func);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    class FieldExprChangeAggregateRewriter implements IFieldExprPatternVisitor<SQExpr> {\r\n        private sqExpr: SQExpr;\r\n        private aggregate: QueryAggregateFunction;\r\n\r\n        constructor(sqExpr: SQExpr, aggregate: QueryAggregateFunction) {\r\n            this.sqExpr = sqExpr;\r\n            this.aggregate = aggregate;\r\n        }\r\n\r\n        public static rewrite(sqExpr: SQExpr, aggregate: QueryAggregateFunction): SQExpr {\r\n            return FieldExprPattern.visit(sqExpr, new FieldExprChangeAggregateRewriter(sqExpr, aggregate));\r\n        }\r\n\r\n        public visitPercentOfGrandTotal(pattern: FieldExprPercentOfGrandTotalPattern): SQExpr {\r\n            pattern.baseExpr = SQExprConverter.asFieldPattern(\r\n                SQExprChangeAggregateRewriter.rewrite(\r\n                    SQExprBuilder.fieldExpr(pattern.baseExpr),\r\n                    this.aggregate));\r\n            return SQExprBuilder.fieldExpr({ percentOfGrandTotal: pattern });\r\n        }\r\n\r\n        public visitColumn(column: FieldExprColumnPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnAggr(columnAggr: FieldExprColumnAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation: FieldExprColumnHierarchyLevelVariationPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntity(entity: FieldExprEntityPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitEntityAggr(entityAggr: FieldExprEntityAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchy(hierarchy: FieldExprHierarchyPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevel(hierarchyLevel: FieldExprHierarchyLevelPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitHierarchyLevelAggr(hierarchyLevelAggr: FieldExprHierarchyLevelAggrPattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitMeasure(measure: FieldExprMeasurePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        public visitPercentile(percentile: FieldExprPercentilePattern): SQExpr {\r\n            return this.defaultRewrite();\r\n        }\r\n\r\n        private defaultRewrite(): SQExpr {\r\n            return SQExprChangeAggregateRewriter.rewrite(this.sqExpr, this.aggregate);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveAggregateRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemoveAggregateRewriter = new SQExprRemoveAggregateRewriter();\r\n\r\n        public visitAggr(expr: SQAggregationExpr): SQExpr {\r\n            return expr.arg;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveAggregateRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemoveEntityVariablesRewriter extends SQExprRewriter {\r\n        private static instance: SQExprRemoveEntityVariablesRewriter = new SQExprRemoveEntityVariablesRewriter();\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            if (expr.variable)\r\n                return SQExprBuilder.entity(expr.schema, expr.entity);\r\n\r\n            return expr;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);\r\n        }\r\n    }\r\n\r\n    class SQExprRemovePercentOfGrandTotalRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprRemovePercentOfGrandTotalRewriter = new SQExprRemovePercentOfGrandTotalRewriter();\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            return expr.accept(SQExprRemovePercentOfGrandTotalRewriter.instance);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr && fieldExpr.percentOfGrandTotal)\r\n                expr = SQExprBuilder.fieldExpr(fieldExpr.percentOfGrandTotal.baseExpr);\r\n\r\n            return expr;\r\n        }\r\n    }\r\n\r\n    class SQExprSetPercentOfGrandTotalRewriter extends SQExprRootRewriter {\r\n        private static instance: SQExprSetPercentOfGrandTotalRewriter = new SQExprSetPercentOfGrandTotalRewriter();\r\n\r\n        public static rewrite(expr: SQExpr): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            return expr.accept(SQExprSetPercentOfGrandTotalRewriter.instance);\r\n        }\r\n\r\n        public visitDefault(expr: SQExpr): SQExpr {\r\n            let fieldExpr = SQExprConverter.asFieldPattern(expr);\r\n            if (fieldExpr && !fieldExpr.percentOfGrandTotal)\r\n                expr = SQExprBuilder.fieldExpr({ percentOfGrandTotal: { baseExpr: SQExprConverter.asFieldPattern(expr) } });\r\n\r\n            return expr;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n    import ConceptualEntity = powerbi.data.ConceptualEntity;\r\n    import ConceptualMultiplicity = powerbi.data.ConceptualMultiplicity;\r\n    import SQEntityExpr = powerbi.data.SQEntityExpr;\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n\r\n    export module SQExprUtils {\r\n        export function supportsArithmetic(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let metadata = expr.getMetadata(schema),\r\n                type = metadata && metadata.type;\r\n\r\n            if (!metadata || !type) {\r\n                return false;\r\n            }\r\n            \r\n            return type.numeric || type.dateTime || type.duration;\r\n        }\r\n\r\n        export function indexOfExpr(items: SQExpr[], searchElement: SQExpr): number {\r\n            debug.assertValue(items, 'items');\r\n            debug.assertValue(searchElement, 'searchElement');\r\n\r\n            for (let i = 0, len = items.length; i < len; i++) {\r\n                if (SQExpr.equals(items[i], searchElement))\r\n                    return i;\r\n            }\r\n            return -1;\r\n        }\r\n\r\n        export function sequenceEqual(x: SQExpr[], y: SQExpr[]): boolean {\r\n            debug.assertValue(x, 'x');\r\n            debug.assertValue(y, 'y');\r\n\r\n            let len = x.length;\r\n            if (len !== y.length)\r\n                return false;\r\n\r\n            for (let i = 0; i < len; i++) {\r\n                if (!SQExpr.equals(x[i], y[i]))\r\n                    return false;\r\n            }\r\n\r\n            return true;\r\n        }\r\n        \r\n        export function uniqueName(namedItems: NamedSQExpr[], expr: SQExpr, exprDefaultName?: string): string {\r\n            debug.assertValue(namedItems, 'namedItems');\r\n\r\n            // Determine all names\r\n            let names: { [name: string]: boolean } = {};\r\n            for (let i = 0, len = namedItems.length; i < len; i++)\r\n                names[namedItems[i].name] = true;\r\n\r\n            return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));\r\n        }\r\n\r\n        /** Generates a default expression name  */\r\n        export function defaultName(expr: SQExpr, fallback: string = 'select'): string {\r\n            if (!expr)\r\n                return fallback;\r\n\r\n            return expr.accept(SQExprDefaultNameGenerator.instance, fallback);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a model measure or an aggregate. */\r\n        export function isMeasure(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsMeasureVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/\r\n        export function isAnyValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsAnyValueVisitor.instance);\r\n        }\r\n\r\n        /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/\r\n        export function isDefaultValue(expr: SQExpr): boolean {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            return expr.accept(IsDefaultValueVisitor.instance);\r\n        }\r\n\r\n        export function discourageAggregation(expr: SQExpr, schema: FederatedConceptualSchema): boolean {\r\n            let capabilities = getSchemaCapabilities(expr, schema);\r\n            return capabilities && capabilities.discourageQueryAggregateUsage;\r\n        }\r\n\r\n        export function getAggregateBehavior(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualAggregateBehavior {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let column = getConceptualColumn(expr, schema);\r\n            if (column)\r\n                return column.aggregateBehavior;\r\n        }\r\n\r\n        export function getSchemaCapabilities(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualCapabilities {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(schema, 'schema');\r\n\r\n            let field = SQExprConverter.asFieldPattern(expr);\r\n            if (!field)\r\n                return;\r\n\r\n            let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(field);\r\n            let conceptualSchema = schema.schema(fieldExprItem.schema);\r\n            if (conceptualSchema)\r\n                return conceptualSchema.capabilities;\r\n        }\r\n\r\n        export function getKpiMetadata(expr: SQExpr, schema: FederatedConceptualSchema): DataViewKpiColumnMetadata {\r\n            let kpiStatusProperty = getKpiStatusProperty(expr, schema);\r\n            if (kpiStatusProperty)\r\n                return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;\r\n\r\n            let kpiTrendProperty = getKpiTrendProperty(expr, schema);\r\n            if (kpiTrendProperty)\r\n                return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;\r\n        }\r\n\r\n        export function getConceptualEntity(entityExpr: SQEntityExpr, schema: FederatedConceptualSchema): ConceptualEntity {\r\n            debug.assertValue(entityExpr, 'entityExpr');\r\n\r\n            let conceptualEntity = schema\r\n                .schema(entityExpr.schema)\r\n                .entities\r\n                .withName(entityExpr.entity);\r\n            return conceptualEntity;\r\n        }\r\n\r\n        function getKpiStatusProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.status === property)\r\n                return property;\r\n        }\r\n\r\n        function getKpiTrendProperty(expr: SQExpr, schema: FederatedConceptualSchema): ConceptualProperty {\r\n            let property = expr.getConceptualProperty(schema);\r\n            if (!property)\r\n                return;\r\n\r\n            let kpiValue = property.kpiValue;\r\n            if (kpiValue && kpiValue.measure.kpi.trend === property)\r\n                return property;\r\n        }\r\n\r\n        export function getDefaultValue(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): SQConstantExpr {\r\n            let column = getConceptualColumn(fieldSQExpr, schema);\r\n            if (column)\r\n                return column.defaultValue;\r\n        }\r\n\r\n        function getConceptualColumn(fieldSQExpr: SQExpr, schema: FederatedConceptualSchema): ConceptualColumn {\r\n            if (!fieldSQExpr || !schema)\r\n                return;\r\n\r\n            let sqField = SQExprConverter.asFieldPattern(fieldSQExpr);\r\n            if (!sqField)\r\n                return;\r\n\r\n            let column: FieldExprPropertyPattern = sqField.column;\r\n\r\n            if (column) {\r\n                if (schema.schema(column.schema) && sqField.column.name) {\r\n                    let property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);\r\n\r\n                    if (property)\r\n                        return property.column;\r\n                }\r\n            }\r\n            else {\r\n                let hierarchyLevelField: FieldExprHierarchyLevelPattern = sqField.hierarchyLevel;\r\n                if (hierarchyLevelField) {\r\n                    let fieldExprItem = FieldExprPattern.toFieldExprEntityItemPattern(sqField);\r\n                    let schemaName = fieldExprItem.schema;\r\n                    if (schema.schema(schemaName)) {\r\n                        let hierarchy = schema.schema(schemaName)\r\n                            .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);\r\n\r\n                        if (hierarchy) {\r\n                            let hierarchyLevel: ConceptualHierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);\r\n                            if (hierarchyLevel && hierarchyLevel.column)\r\n                                return hierarchyLevel.column.column;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        export function getDefaultValues(fieldSQExprs: SQExpr[], schema: FederatedConceptualSchema): SQConstantExpr[] {\r\n            if (_.isEmpty(fieldSQExprs) || !schema)\r\n                return;\r\n            let result: SQConstantExpr[] = [];\r\n            for (let sqExpr of fieldSQExprs) {\r\n                let defaultValue = getDefaultValue(sqExpr, schema);\r\n                if (defaultValue)\r\n                    result.push(defaultValue);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Return compare or and expression for key value pairs. */\r\n        export function getDataViewScopeIdentityComparisonExpr(fieldsExpr: SQExpr[], values: SQConstantExpr[]): SQExpr {\r\n            debug.assert(fieldsExpr.length === values.length, \"fileds and values need to be the same size\");\r\n\r\n            let compareExprs: SQCompareExpr[] = [];\r\n            for (let i = 0; i < fieldsExpr.length; i++) {\r\n                compareExprs.push(SQExprBuilder.compare(QueryComparisonKind.Equal, fieldsExpr[i], values[i]));\r\n            }\r\n\r\n            if (_.isEmpty(compareExprs))\r\n                return;\r\n\r\n            let resultExpr: SQExpr;\r\n            for (let compareExpr of compareExprs) {\r\n                resultExpr = SQExprBuilder.and(resultExpr, compareExpr);\r\n            }\r\n\r\n            return resultExpr;\r\n        }\r\n\r\n        export function getActiveTablesNames(queryDefn: data.SemanticQuery): string[] {\r\n            let tables: string[] = [];\r\n            if (queryDefn) {\r\n                let selectedItems = queryDefn.from();\r\n                if (selectedItems !== undefined) {\r\n                    for (let key of selectedItems.keys()) {\r\n                        let entityObj = selectedItems.entity(key);\r\n                        if (tables.indexOf(entityObj.entity) < 0)\r\n                            tables.push(entityObj.entity);\r\n                    }\r\n                }\r\n            }\r\n            return tables;\r\n        }\r\n\r\n        export function isRelatedToMany(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne);\r\n        }\r\n\r\n        export function isRelatedToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            return isRelated(schema, sourceExpr, targetExpr, ConceptualMultiplicity.Many, ConceptualMultiplicity.ZeroOrOne) ||\r\n                isRelated(schema, targetExpr, sourceExpr, ConceptualMultiplicity.ZeroOrOne, ConceptualMultiplicity.Many);\r\n        }\r\n\r\n        function isRelated(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr,\r\n            sourceMultiplicity: ConceptualMultiplicity,\r\n            targetMultiplicity: ConceptualMultiplicity): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n\r\n            if (_.isEmpty(source.navigationProperties))\r\n                return false;\r\n\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let queue: ConceptualEntity[] = [];\r\n            queue.push(source);\r\n\r\n            // walk the relationship path from source.\r\n            while (!_.isEmpty(queue)) {\r\n                let current = queue.shift();\r\n\r\n                let navProperties = current.navigationProperties;\r\n                if (_.isEmpty(navProperties))\r\n                    continue;\r\n\r\n                for (let navProperty of navProperties) {\r\n                    if (!navProperty.isActive)\r\n                        continue;\r\n\r\n                    if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {\r\n                        if (navProperty.targetEntity === target)\r\n                            return true;\r\n                        queue.push(navProperty.targetEntity);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        export function isRelatedOneToOne(\r\n            schema: FederatedConceptualSchema,\r\n            sourceExpr: SQEntityExpr,\r\n            targetExpr: SQEntityExpr): boolean {\r\n\r\n            let source = SQExprUtils.getConceptualEntity(sourceExpr, schema);\r\n            debug.assertValue(source, \"could not resolve conceptual entity form sourceExpr.\");\r\n            let target = SQExprUtils.getConceptualEntity(targetExpr, schema);\r\n            debug.assertValue(target, \"could not resolve conceptual entity form targetExpr.\");\r\n\r\n            let sourceNavigations = source.navigationProperties;\r\n            let targetNavigations = target.navigationProperties;\r\n\r\n            if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))\r\n                return false;\r\n\r\n            return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);\r\n        }\r\n\r\n        function hasOneToOneNavigation(navigationProperties: ArrayNamedItems<ConceptualNavigationProperty>, targetEntity: ConceptualEntity): boolean {\r\n            if (_.isEmpty(navigationProperties))\r\n                return false;\r\n\r\n            for (let navigationProperty of navigationProperties) {\r\n                if (!navigationProperty.isActive)\r\n                    continue;\r\n\r\n                if (navigationProperty.targetEntity !== targetEntity)\r\n                    continue;\r\n\r\n                if (navigationProperty.sourceMultiplicity === ConceptualMultiplicity.ZeroOrOne &&\r\n                    navigationProperty.targetMultiplicity === ConceptualMultiplicity.ZeroOrOne) {\r\n                    return true;\r\n                }\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,\r\n            and returns a new array. When available, we should use _.unionWith from lodash. */\r\n        export function concatUnique(leftExprs: SQExpr[], rightExprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(leftExprs, 'leftExprs');\r\n            debug.assertValue(rightExprs, 'rightExprs');\r\n\r\n            let concatExprs = ArrayExtensions.copy(leftExprs);\r\n            for (let expr of rightExprs) {\r\n                if (indexOfExpr(concatExprs, expr) === -1) {\r\n                    concatExprs.push(expr);\r\n                }\r\n            }\r\n\r\n            return concatExprs;\r\n        }\r\n\r\n        class SQExprDefaultNameGenerator extends DefaultSQExprVisitorWithArg<string, string> {\r\n            public static instance: SQExprDefaultNameGenerator = new SQExprDefaultNameGenerator();\r\n\r\n            public visitEntity(expr: SQEntityExpr): string {\r\n                return expr.entity;\r\n            }\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr, fallback: string): string {\r\n                return expr.source.accept(this) + '.' + expr.ref;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr, fallback: string): string {\r\n                return QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';\r\n            }\r\n\r\n            public visitPercentile(expr: SQPercentileExpr, fallback: string): string {\r\n                let func = expr.exclusive\r\n                    ? 'Percentile.Exc('\r\n                    : 'Percentile.Inc(';\r\n\r\n                return func + expr.arg.accept(this) + ', ' + expr.k + ')';\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr, fallback: string): string {\r\n                return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): string {\r\n                return 'const';\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr, fallback: string): string {\r\n                return fallback || 'expr';\r\n            }\r\n        }\r\n\r\n        class IsMeasureVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsMeasureVisitor = new IsMeasureVisitor();\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsDefaultValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsDefaultValueVisitor = new IsDefaultValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitDefaultValue(expr: SQDefaultValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        class IsAnyValueVisitor extends DefaultSQExprVisitor<boolean> {\r\n            public static instance: IsAnyValueVisitor = new IsAnyValueVisitor();\r\n\r\n            public visitCompare(expr: SQCompareExpr): boolean {\r\n                if (expr.comparison !== QueryComparisonKind.Equal)\r\n                    return false;\r\n\r\n                return expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): boolean {\r\n                return expr.left.accept(this) && expr.right.accept(this);\r\n            }\r\n\r\n            public visitAnyValue(expr: SQAnyValueExpr): boolean {\r\n                return true;\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): boolean {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n\r\n    export class SemanticQueryRewriter {\r\n        private exprRewriter: ISQExprVisitor<SQExpr>;\r\n\r\n        constructor(exprRewriter: ISQExprVisitor<SQExpr>) {\r\n            this.exprRewriter = exprRewriter;\r\n        }\r\n\r\n        public rewriteFrom(fromValue: SQFrom): SQFrom {\r\n            let fromContents: { [name: string]: SQFromEntitySource } = {};\r\n            let originalFrom = fromValue,\r\n                originalFromKeys = originalFrom.keys();\r\n            for (let i = 0, len = originalFromKeys.length; i < len; i++) {\r\n                let keyName = originalFromKeys[i],\r\n                    originalEntityRef = originalFrom.entity(keyName),\r\n                    originalEntityExpr = SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName),\r\n                    updatedEntityExpr = <SQEntityExpr>originalEntityExpr.accept(this.exprRewriter);\r\n                \r\n                fromContents[keyName] = {\r\n                    schema: updatedEntityExpr.schema,\r\n                    entity: updatedEntityExpr.entity,\r\n                };\r\n            }\r\n            return new SQFrom(fromContents);\r\n        }\r\n\r\n        public rewriteSelect(selectItems: NamedSQExpr[], from: SQFrom): NamedSQExpr[]{\r\n            debug.assertValue(selectItems, 'selectItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            return this.rewriteNamedSQExpressions(selectItems, from);\r\n        }\r\n\r\n        public rewriteGroupBy(groupByitems: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertAnyValue(groupByitems, 'groupByitems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(groupByitems))\r\n                return;\r\n\r\n            return this.rewriteNamedSQExpressions(groupByitems, from);\r\n        }\r\n\r\n        private rewriteNamedSQExpressions(expressions: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            debug.assertValue(expressions, 'expressions');\r\n\r\n            return _.map(expressions, item => {\r\n                return {\r\n                    name: item.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from)\r\n                };\r\n            });\r\n        }\r\n\r\n        public rewriteOrderBy(orderByItems: SQSortDefinition[], from: SQFrom): SQSortDefinition[]{\r\n            debug.assertAnyValue(orderByItems, 'orderByItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(orderByItems))\r\n                return;\r\n\r\n            let orderBy: SQSortDefinition[] = [];\r\n            for (let i = 0, len = orderByItems.length; i < len; i++) {\r\n                let item = orderByItems[i],\r\n                    updatedExpr = SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);\r\n                orderBy.push({\r\n                        direction: item.direction,\r\n                        expr: updatedExpr,\r\n                    });\r\n            }\r\n\r\n            return orderBy;\r\n        }\r\n\r\n        public rewriteWhere(whereItems: SQFilter[], from: SQFrom): SQFilter[]{\r\n            debug.assertAnyValue(whereItems, 'whereItems');\r\n            debug.assertValue(from, 'from');\r\n\r\n            if (_.isEmpty(whereItems))\r\n                return;\r\n\r\n            let where: SQFilter[] = [];\r\n            for (let i = 0, len = whereItems.length; i < len; i++) {\r\n                let originalWhere = whereItems[i];\r\n\r\n                let updatedWhere: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),\r\n                };\r\n\r\n                if (originalWhere.target)\r\n                    updatedWhere.target = _.map(originalWhere.target, e => SQExprRewriterWithSourceRenames.rewrite(e.accept(this.exprRewriter), from));\r\n\r\n                where.push(updatedWhere);\r\n            }\r\n\r\n            return where;\r\n        }\r\n    }\r\n} ","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import ArrayExtensions = jsCommon.ArrayExtensions;\r\n    import ArrayNamedItems = jsCommon.ArrayNamedItems;\r\n\r\n    export interface NamedSQExpr {\r\n        name: string;\r\n        expr: SQExpr;\r\n    }\r\n\r\n    export interface SQFilter {\r\n        target?: SQExpr[];\r\n        condition: SQExpr;\r\n    }\r\n\r\n    /** Represents an entity reference in SemanticQuery from. */\r\n    export interface SQFromEntitySource {\r\n        entity: string;\r\n        schema: string;\r\n    }\r\n\r\n    /** Represents a sort over an expression. */\r\n    export interface SQSortDefinition {\r\n        expr: SQExpr;\r\n        direction: SortDirection;\r\n    }\r\n\r\n    export interface QueryFromEnsureEntityResult {\r\n        name: string;\r\n        new?: boolean;\r\n    }\r\n\r\n    export interface SQSourceRenames {\r\n        [from: string]: string;\r\n    }\r\n\r\n    /**\r\n     * Represents a semantic query that is:\r\n     * 1) Round-trippable with a JSON QueryDefinition.\r\n     * 2) Immutable\r\n     * 3) Long-lived and does not have strong references to a conceptual model (only names).\r\n     */\r\n    export class SemanticQuery {\r\n        private static empty: SemanticQuery;\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n        private orderByItems: SQSortDefinition[];\r\n        private selectItems: NamedSQExpr[];\r\n        private groupByItems: NamedSQExpr[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[], orderBy: SQSortDefinition[], select: NamedSQExpr[], groupBy: NamedSQExpr[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(select, 'select');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n            this.orderByItems = orderBy;\r\n            this.selectItems = select;\r\n            this.groupByItems = groupBy;\r\n        }\r\n\r\n        public static create(): SemanticQuery {\r\n            if (!SemanticQuery.empty)\r\n                SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);\r\n\r\n            return SemanticQuery.empty;\r\n        }\r\n\r\n        private static createWithTrimmedFrom(\r\n            from: SQFrom,\r\n            where: SQFilter[],\r\n            orderBy: SQSortDefinition[],\r\n            select: NamedSQExpr[],\r\n            groupBy: NamedSQExpr[]): SemanticQuery {\r\n\r\n            let unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());\r\n\r\n            // Where\r\n            if (where) {\r\n                for (let i = 0, len = where.length; i < len; i++) {\r\n                    let filter = where[i];\r\n\r\n                    filter.condition.accept(unreferencedKeyFinder);\r\n\r\n                    let filterTarget = filter.target;\r\n                    if (filterTarget) {\r\n                        for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                            if (filterTarget[j])\r\n                                filterTarget[j].accept(unreferencedKeyFinder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // OrderBy\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++)\r\n                    orderBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            // Select\r\n            for (let i = 0, len = select.length; i < len; i++)\r\n                select[i].expr.accept(unreferencedKeyFinder);\r\n\r\n            // GroupBy\r\n            if (groupBy) {\r\n                for (let i = 0, len = groupBy.length; i < len; i++)\r\n                    groupBy[i].expr.accept(unreferencedKeyFinder);\r\n            }\r\n\r\n            let unreferencedKeys = unreferencedKeyFinder.result();\r\n            for (let i = 0, len = unreferencedKeys.length; i < len; i++)\r\n                from.remove(unreferencedKeys[i]);\r\n\r\n            return new SemanticQuery(from, where, orderBy, select, groupBy);\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        /** Returns a query equivalent to this, with the specified selected items. */\r\n        select(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the items being selected in this query. */\r\n        select(): ArrayNamedItems<NamedSQExpr>;\r\n        public select(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getSelect();\r\n\r\n            return this.setSelect(values);\r\n        }\r\n\r\n        private getSelect(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.selectItems);\r\n        }\r\n\r\n        private static createNamedExpressionArray(items: NamedSQExpr[]): ArrayNamedItems<NamedSQExpr> {\r\n            return ArrayExtensions.extendWithName<NamedSQExpr>(_.map(items, s => {\r\n                return {\r\n                    name: s.name,\r\n                    expr: s.expr,\r\n                };\r\n            }));\r\n        }\r\n\r\n        private setSelect(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private static rewriteExpressionsWithSourceRenames(values: NamedSQExpr[], from: SQFrom): NamedSQExpr[] {\r\n            let items: NamedSQExpr[] = [];\r\n\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let value = values[i];\r\n                items.push({\r\n                    name: value.name,\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)\r\n                });\r\n            }\r\n\r\n            return items;\r\n        } \r\n\r\n        /** Removes the given expression from the select. */\r\n        public removeSelect(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let originalItems = this.selectItems,\r\n                selectItems: NamedSQExpr[] = [];\r\n            for (let i = 0, len = originalItems.length; i < len; i++) {\r\n                let originalExpr = originalItems[i];\r\n                if (SQExpr.equals(originalExpr.expr, expr))\r\n                    continue;\r\n\r\n                selectItems.push(originalExpr);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Removes the given expression from order by. */\r\n        public removeOrderBy(expr: SQExpr): SemanticQuery {\r\n            let sorts = this.orderBy();\r\n            for (let i = sorts.length - 1; i >= 0; i--) {\r\n                if (SQExpr.equals(sorts[i].expr, expr))\r\n                    sorts.splice(i, 1);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public selectNameOf(expr: SQExpr): string {\r\n            let index = SQExprUtils.indexOfExpr(_.map(this.selectItems, s => s.expr), expr);\r\n            if (index >= 0)\r\n                return this.selectItems[index].name;\r\n        }\r\n\r\n        public setSelectAt(index: number, expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            if (index >= this.selectItems.length)\r\n                return;\r\n\r\n            let select = this.select(),\r\n                from = this.fromValue.clone(),\r\n                originalName = select[index].name;\r\n            select[index] = {\r\n                name: originalName,\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);\r\n        }\r\n\r\n        /** Adds a the expression to the select clause. */\r\n        public addSelect(expr: SQExpr, exprName?: string): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let selectItems = this.select(),\r\n                from = this.fromValue.clone();\r\n            selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);\r\n        }\r\n\r\n        private createNamedExpr(currentNames: ArrayNamedItems<NamedSQExpr>, from: SQFrom, expr: SQExpr, exprName?: string): NamedSQExpr{\r\n            return {\r\n                name: SQExprUtils.uniqueName(currentNames, expr, exprName),\r\n                expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)\r\n            };\r\n        } \r\n\r\n        /** Returns a query equivalent to this, with the specified groupBy items. */\r\n        groupBy(values: NamedSQExpr[]): SemanticQuery;\r\n        /** Gets the groupby items in this query. */\r\n        groupBy(): ArrayNamedItems<NamedSQExpr>;\r\n        public groupBy(values?: NamedSQExpr[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getGroupBy();\r\n\r\n            return this.setGroupBy(values);\r\n        }\r\n\r\n        private getGroupBy(): ArrayNamedItems<NamedSQExpr> {\r\n            return SemanticQuery.createNamedExpressionArray(this.groupByItems);\r\n        }\r\n\r\n        private setGroupBy(values: NamedSQExpr[]): SemanticQuery {\r\n            let from = this.fromValue.clone();\r\n            let groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        public addGroupBy(expr: SQExpr): SemanticQuery {\r\n            debug.assertValue(expr, 'expr');\r\n\r\n            let groupByItems = this.groupBy(),\r\n                from = this.fromValue.clone();\r\n            groupByItems.push(this.createNamedExpr(groupByItems, from, expr));\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the sorting for this query. */\r\n        orderBy(values: SQSortDefinition[]): SemanticQuery;\r\n        orderBy(): SQSortDefinition[];\r\n\r\n        public orderBy(values?: SQSortDefinition[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getOrderBy();\r\n\r\n            return this.setOrderBy(values);\r\n        }\r\n\r\n        private getOrderBy(): SQSortDefinition[] {\r\n            let result: SQSortDefinition[] = [];\r\n\r\n            let orderBy = this.orderByItems;\r\n            if (orderBy) {\r\n                for (let i = 0, len = orderBy.length; i < len; i++) {\r\n                    let clause = orderBy[i];\r\n\r\n                    result.push({\r\n                        expr: clause.expr,\r\n                        direction: clause.direction,\r\n                    });\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setOrderBy(values: SQSortDefinition[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedOrderBy: SQSortDefinition[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let clause = values[i];\r\n                updatedOrderBy.push({\r\n                    expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),\r\n                    direction: clause.direction,\r\n                });\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        /** Gets or sets the filters for this query. */\r\n        where(values: SQFilter[]): SemanticQuery;\r\n        where(): SQFilter[];\r\n\r\n        public where(values?: SQFilter[]): any {\r\n            if (_.isEmpty(arguments))\r\n                return this.getWhere();\r\n\r\n            return this.setWhere(values);\r\n        }\r\n\r\n        private getWhere(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            if (whereItems) {\r\n                for (let i = 0, len = whereItems.length; i < len; i++)\r\n                    result.push(whereItems[i]);\r\n            }\r\n\r\n            return result;\r\n        }\r\n\r\n        private setWhere(values: SQFilter[]): SemanticQuery {\r\n            debug.assertValue(values, 'values');\r\n\r\n            let updatedWhere: SQFilter[] = [],\r\n                from = this.fromValue.clone();\r\n            for (let i = 0, len = values.length; i < len; i++) {\r\n                let filter = values[i];\r\n                let updatedFilter: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),\r\n                };\r\n\r\n                let filterTarget = filter.target;\r\n                if (filterTarget) {\r\n                    updatedFilter.target = [];\r\n                    for (let j = 0, jlen = filterTarget.length; j < jlen; j++)\r\n                        if (filterTarget[j]) {\r\n                            let updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);\r\n                            updatedFilter.target.push(updatedTarget);\r\n                        }\r\n                }\r\n\r\n                updatedWhere.push(updatedFilter);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public addWhere(filter: SemanticFilter): SemanticQuery {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedWhere: SQFilter[] = this.where(),\r\n                incomingWhere: SQFilter[] = filter.where(),\r\n                from = this.fromValue.clone();\r\n\r\n            for (let i = 0, len = incomingWhere.length; i < len; i++) {\r\n                let clause = incomingWhere[i];\r\n\r\n                let updatedClause: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),\r\n                };\r\n\r\n                if (clause.target)\r\n                    updatedClause.target = _.map(clause.target, t => SQExprRewriterWithSourceRenames.rewrite(t, from));\r\n\r\n                updatedWhere.push(updatedClause);\r\n            }\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticQuery {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n            let orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);\r\n            let select = rewriter.rewriteSelect(this.selectItems, from);\r\n            let groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);\r\n\r\n            return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);\r\n        }\r\n    }\r\n\r\n    /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */\r\n    export class SemanticFilter implements ISemanticFilter {\r\n        private fromValue: SQFrom;\r\n        private whereItems: SQFilter[];\r\n\r\n        constructor(from: SQFrom, where: SQFilter[]) {\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            this.fromValue = from;\r\n            this.whereItems = where;\r\n        }\r\n\r\n        public static fromSQExpr(contract: SQExpr): SemanticFilter {\r\n            debug.assertValue(contract, 'contract');\r\n\r\n            let from = new SQFrom();\r\n\r\n            let rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);\r\n            // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.\r\n            //         Thus not setting a target here.\r\n            let where: SQFilter[] = [{\r\n                condition: rewrittenContract\r\n            }];\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static getDefaultValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.defaultValue());\r\n        }\r\n\r\n        public static getAnyValueFilter(fieldSQExprs: SQExpr | SQExpr[]): SemanticFilter {\r\n            return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, SQExprBuilder.anyValue());\r\n        }\r\n\r\n        private static getDataViewScopeIdentityComparisonFilters(fieldSQExprs: SQExpr | SQExpr[], value: SQExpr): SemanticFilter {\r\n            debug.assertValue(fieldSQExprs, 'fieldSQExprs');\r\n            debug.assertValue(value, 'value');\r\n\r\n            if (fieldSQExprs instanceof Array) {\r\n                let values: SQConstantExpr[] = Array.apply(null, Array(fieldSQExprs.length)).map(() => { return value; });\r\n                return SemanticFilter.fromSQExpr(SQExprUtils.getDataViewScopeIdentityComparisonExpr(<SQExpr[]>fieldSQExprs, values));\r\n            }\r\n\r\n            return SemanticFilter.fromSQExpr(SQExprBuilder.equal(<SQExpr>fieldSQExprs, value));\r\n        }\r\n\r\n        public from(): SQFrom {\r\n            return this.fromValue.clone();\r\n        }\r\n\r\n        public conditions(): SQExpr[] {\r\n            let expressions: SQExpr[] = [];\r\n\r\n            let where = this.whereItems;\r\n            for (let i = 0, len = where.length; i < len; i++) {\r\n                let filter = where[i];\r\n                expressions.push(filter.condition);\r\n            }\r\n            return expressions;\r\n        }\r\n\r\n        public where(): SQFilter[] {\r\n            let result: SQFilter[] = [];\r\n\r\n            let whereItems = this.whereItems;\r\n            for (let i = 0, len = whereItems.length; i < len; i++)\r\n                result.push(whereItems[i]);\r\n\r\n            return result;\r\n        }\r\n\r\n        public rewrite(exprRewriter: ISQExprVisitor<SQExpr>): SemanticFilter {\r\n            let rewriter = new SemanticQueryRewriter(exprRewriter);\r\n            let from = rewriter.rewriteFrom(this.fromValue);\r\n            let where = rewriter.rewriteWhere(this.whereItems, from);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public validate(schema: FederatedConceptualSchema, aggrUtils: ISQAggregationOperations, errors?: SQExprValidationError[]): SQExprValidationError[] {\r\n            let validator = new SQExprValidationVisitor(schema, aggrUtils, errors);\r\n            this.rewrite(validator);\r\n            return validator.errors;\r\n        }\r\n\r\n        /** Merges a list of SemanticFilters into one. */\r\n        public static merge(filters: SemanticFilter[]): SemanticFilter {\r\n            if (_.isEmpty(filters))\r\n                return null;\r\n\r\n            if (filters.length === 1)\r\n                return filters[0];\r\n\r\n            let firstFilter = filters[0];\r\n            let from = firstFilter.from(),\r\n                where: SQFilter[] = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);\r\n\r\n            for (let i = 1, len = filters.length; i < len; i++)\r\n                SemanticFilter.applyFilter(filters[i], from, where);\r\n\r\n            return new SemanticFilter(from, where);\r\n        }\r\n\r\n        public static isDefaultFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isDefaultValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isAnyFilter(filter: SemanticFilter): boolean {\r\n            if (!filter || filter.where().length !== 1)\r\n                return false;\r\n\r\n            return SQExprUtils.isAnyValue(filter.where()[0].condition);\r\n        }\r\n\r\n        public static isSameFilter(leftFilter: SemanticFilter, rightFilter: SemanticFilter): boolean {\r\n            if (jsCommon.JsonComparer.equals<SemanticFilter>(leftFilter, rightFilter)) {\r\n                return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))\r\n                    || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));\r\n            }\r\n            return false;\r\n        }\r\n\r\n        private static applyFilter(filter: SemanticFilter, from: SQFrom, where: SQFilter[]): void {\r\n            debug.assertValue(filter, 'filter');\r\n            debug.assertValue(from, 'from');\r\n            debug.assertValue(where, 'where');\r\n\r\n            // Where\r\n            let filterWhereItems = filter.whereItems;\r\n            for (let i = 0; i < filterWhereItems.length; i++) {\r\n                let filterWhereItem = filterWhereItems[i];\r\n\r\n                let updatedWhereItem: SQFilter = {\r\n                    condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),\r\n                };\r\n\r\n                if (filterWhereItem.target)\r\n                    updatedWhereItem.target = _.map(filterWhereItem.target, e => SQExprRewriterWithSourceRenames.rewrite(e, from));\r\n\r\n                where.push(updatedWhereItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Represents a SemanticQuery/SemanticFilter from clause. */\r\n    export class SQFrom {\r\n        private items: { [name: string]: SQFromEntitySource };\r\n\r\n        constructor(items?: { [name: string]: SQFromEntitySource }) {\r\n            this.items = items || {};\r\n        }\r\n\r\n        public keys(): string[] {\r\n            return Object.keys(this.items);\r\n        }\r\n\r\n        public entity(key: string): SQFromEntitySource {\r\n            return this.items[key];\r\n        }\r\n\r\n        public ensureEntity(entity: SQFromEntitySource, desiredVariableName?: string): QueryFromEnsureEntityResult {\r\n            debug.assertValue(entity, 'entity');\r\n\r\n            // 1) Reuse a reference to the entity among the already referenced\r\n            let keys = this.keys();\r\n            for (let i = 0, len = keys.length; i < len; i++) {\r\n                let key = keys[i],\r\n                    item = this.items[key];\r\n                if (item && entity.entity === item.entity && entity.schema === item.schema)\r\n                    return { name: key };\r\n            }\r\n\r\n            // 2) Add a reference to the entity\r\n            let candidateName = desiredVariableName || this.candidateName(entity.entity),\r\n                uniqueName: string = candidateName,\r\n                i = 2;\r\n            while (this.items[uniqueName]) {\r\n                uniqueName = candidateName + i++;\r\n            }\r\n\r\n            this.items[uniqueName] = entity;\r\n            return { name: uniqueName, new: true };\r\n        }\r\n\r\n        public remove(key: string): void {\r\n            delete this.items[key];\r\n        }\r\n\r\n        /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */\r\n        private candidateName(ref: string): string {\r\n            debug.assertValue(ref, 'ref');\r\n\r\n            let idx = ref.lastIndexOf('.');\r\n            if (idx >= 0 && (idx !== ref.length - 1))\r\n                ref = ref.substr(idx + 1);\r\n\r\n            return ref.substring(0, 1).toLowerCase();\r\n        }\r\n\r\n        public clone(): SQFrom {\r\n            // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).\r\n            let cloned = new SQFrom();\r\n\r\n            // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.\r\n            $.extend(cloned.items, this.items);\r\n\r\n            return cloned;\r\n        }\r\n    }\r\n\r\n    export class SQExprRewriterWithSourceRenames extends SQExprRewriter {\r\n        private renames: SQSourceRenames;\r\n\r\n        constructor(renames: SQSourceRenames) {\r\n            debug.assertValue(renames, 'renames');\r\n\r\n            super();\r\n            this.renames = renames;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): SQExpr {\r\n            let updatedName = this.renames[expr.entity];\r\n\r\n            if (updatedName)\r\n                return new SQEntityExpr(expr.schema, expr.entity, updatedName);\r\n\r\n            return super.visitEntity(expr);\r\n        }\r\n\r\n        public rewriteFilter(filter: SQFilter): SQFilter {\r\n            debug.assertValue(filter, 'filter');\r\n\r\n            let updatedTargets = undefined;\r\n            if (filter.target)\r\n                updatedTargets = this.rewriteArray(filter.target);\r\n\r\n            let updatedCondition = filter.condition.accept(this);\r\n\r\n            if (filter.condition === updatedCondition && filter.target === updatedTargets)\r\n                return filter;\r\n\r\n            let updatedFilter: SQFilter = {\r\n                condition: updatedCondition,\r\n            };\r\n\r\n            if (updatedTargets)\r\n                updatedFilter.target = updatedTargets;\r\n\r\n            return updatedFilter;\r\n        }\r\n\r\n        public rewriteArray(exprs: SQExpr[]): SQExpr[] {\r\n            debug.assertValue(exprs, 'exprs');\r\n\r\n            let updatedExprs: SQExpr[];\r\n\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                let expr = exprs[i],\r\n                    rewrittenExpr = expr.accept(this);\r\n\r\n                if (expr !== rewrittenExpr && !updatedExprs)\r\n                    updatedExprs = ArrayExtensions.take(exprs, i);\r\n\r\n                if (updatedExprs)\r\n                    updatedExprs.push(rewrittenExpr);\r\n            }\r\n\r\n            return updatedExprs || exprs;\r\n        }\r\n\r\n        public static rewrite(expr: SQExpr, from: SQFrom): SQExpr {\r\n            debug.assertValue(expr, 'expr');\r\n            debug.assertValue(from, 'from');\r\n\r\n            let renames = QuerySourceRenameDetector.run(expr, from);\r\n            let rewriter = new SQExprRewriterWithSourceRenames(renames);\r\n            return expr.accept(rewriter);\r\n        }\r\n    }\r\n\r\n    /** Responsible for updating a QueryFrom based on SQExpr references. */\r\n    class QuerySourceRenameDetector extends DefaultSQExprVisitorWithTraversal {\r\n        private from: SQFrom;\r\n        private renames: SQSourceRenames;\r\n\r\n        public static run(expr: SQExpr, from: SQFrom): SQSourceRenames {\r\n            let detector = new QuerySourceRenameDetector(from);\r\n            expr.accept(detector);\r\n\r\n            return detector.renames;\r\n        }\r\n\r\n        constructor(from: SQFrom) {\r\n            debug.assertValue(from, 'from');\r\n            super();\r\n\r\n            this.from = from;\r\n            this.renames = {};\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            // TODO: Renames must take the schema into account, not just entity set name.\r\n            let existingEntity = this.from.entity(expr.variable);\r\n            if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)\r\n                return;\r\n\r\n            let actualEntity = this.from.ensureEntity(\r\n                {\r\n                    schema: expr.schema,\r\n                    entity: expr.entity,\r\n                },\r\n                expr.variable);\r\n\r\n            this.renames[expr.entity] = actualEntity.name;\r\n        }\r\n    }\r\n\r\n    /** Visitor for finding unreferenced sources. */\r\n    class UnreferencedKeyFinder extends DefaultSQExprVisitorWithTraversal {\r\n        private keys: string[];\r\n\r\n        constructor(keys: string[]) {\r\n            debug.assertValue(keys, 'keys');\r\n\r\n            super();\r\n            this.keys = keys;\r\n        }\r\n\r\n        public visitEntity(expr: SQEntityExpr): void {\r\n            let index = this.keys.indexOf(expr.variable);\r\n            if (index >= 0)\r\n                this.keys.splice(index, 1);\r\n        }\r\n\r\n        public result(): string[] {\r\n            return this.keys;\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import DataViewTransform = powerbi.data.DataViewTransform;\r\n    import SQExprBuilder = powerbi.data.SQExprBuilder;\r\n\r\n    /** Utility for creating a DataView from columns of data. */\r\n    export interface IDataViewBuilderCategorical {\r\n        withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical;\r\n        withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical;\r\n        withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical;\r\n        withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical;\r\n\r\n        build(): DataView;\r\n    }\r\n\r\n    export interface DataViewBuilderColumnOptions {\r\n        source: DataViewMetadataColumn;\r\n    }\r\n\r\n    export interface DataViewBuilderCategoryColumnOptions extends DataViewBuilderColumnOptions {\r\n        values: PrimitiveValue[];\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n    }\r\n\r\n    export interface DataViewBuilderValuesOptions {\r\n        columns: DataViewBuilderValuesColumnOptions[];\r\n    }\r\n\r\n    export interface DataViewBuilderGroupedValuesOptions {\r\n        groupColumn: DataViewBuilderCategoryColumnOptions;\r\n        valueColumns: DataViewBuilderColumnOptions[];\r\n        data: DataViewBuilderSeriesData[][];\r\n    }\r\n\r\n    /** Indicates the source set of identities. */\r\n    export interface DataViewBuilderColumnIdentitySource {\r\n        fields: SQExpr[];\r\n        identities?: DataViewScopeIdentity[];\r\n    }\r\n\r\n    export interface DataViewBuilderValuesColumnOptions extends DataViewBuilderColumnOptions, DataViewBuilderSeriesData {\r\n    }\r\n\r\n    export interface DataViewBuilderSeriesData {\r\n        values: PrimitiveValue[];\r\n        highlights?: PrimitiveValue[];\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        maxLocal?: any;\r\n\r\n        /** Client-computed maximum value for a column. */\r\n        minLocal?: any;\r\n    }\r\n\r\n    export function createCategoricalDataViewBuilder(): IDataViewBuilderCategorical {\r\n        return new CategoricalDataViewBuilder();\r\n    }\r\n\r\n    interface ColumnMetadata {\r\n        column: DataViewMetadataColumn;\r\n        identityFrom: DataViewBuilderColumnIdentitySource;\r\n        values: PrimitiveValue[];\r\n    }\r\n\r\n    class CategoricalDataViewBuilder implements IDataViewBuilderCategorical {\r\n        private categories: DataViewCategoryColumn[];\r\n        private measureColumns: DataViewMetadataColumn[];\r\n        private hasDynamicSeries: boolean;\r\n        private dynamicSeriesMetadata: ColumnMetadata;\r\n        private columnIndex: number;\r\n        private data: DataViewBuilderValuesColumnOptions[]| DataViewBuilderSeriesData[][];\r\n\r\n        constructor() {\r\n            this.categories = [];\r\n            this.measureColumns = [];\r\n            this.columnIndex = 0;\r\n        }\r\n\r\n        public withCategory(options: DataViewBuilderCategoryColumnOptions): IDataViewBuilderCategorical {\r\n            let categoryValues = options.values,\r\n                identityFrom = options.identityFrom,\r\n                type = options.source.type;\r\n\r\n            let categoryColumn: DataViewCategoryColumn = {\r\n                source: options.source,\r\n                identityFields: options.identityFrom.fields,\r\n                identity: options.identityFrom.identities || [],\r\n                values: categoryValues,\r\n            };\r\n\r\n            if (!options.identityFrom.identities) {\r\n                for (let categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {\r\n                    categoryColumn.identity.push(\r\n                        getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));\r\n                }\r\n            }\r\n\r\n            if (!this.categories)\r\n                this.categories = [];\r\n\r\n            this.categories.push(categoryColumn);\r\n\r\n            return this;\r\n        }\r\n\r\n        public withCategories(categories: DataViewCategoryColumn[]): IDataViewBuilderCategorical {\r\n            if (_.isEmpty(this.categories))\r\n                this.categories = categories;\r\n            else\r\n                Array.prototype.push.apply(this.categories, categories);\r\n\r\n            return this;\r\n        }\r\n\r\n        public withValues(options: DataViewBuilderValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            let columns = options.columns;\r\n            debug.assertValue(columns, 'columns');\r\n\r\n            for (let column of columns) {\r\n                this.measureColumns.push(column.source);\r\n            }\r\n\r\n            this.data = columns;\r\n\r\n            return this;\r\n        }\r\n\r\n        public withGroupedValues(options: DataViewBuilderGroupedValuesOptions): IDataViewBuilderCategorical {\r\n            debug.assertValue(options, 'options');\r\n\r\n            this.hasDynamicSeries = true;\r\n\r\n            let groupColumn = options.groupColumn;\r\n            debug.assertValue(groupColumn, 'groupColumn');\r\n\r\n            this.dynamicSeriesMetadata = {\r\n                column: groupColumn.source,\r\n                identityFrom: groupColumn.identityFrom,\r\n                values: groupColumn.values,\r\n            };\r\n\r\n            let valueColumns = options.valueColumns;\r\n            for (let valueColumn of valueColumns) {\r\n                this.measureColumns.push(valueColumn.source);\r\n            }\r\n\r\n            this.data = options.data;\r\n\r\n            return this;\r\n        }\r\n\r\n        private fillData(dataViewValues: DataViewValueColumns, groups: DataViewMetadataColumn[]) {\r\n            let categoryColumn = _.first(this.categories);\r\n            let categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 1;\r\n\r\n            if (this.hasDynamicSeries) {\r\n                // Dynamic series\r\n                let data = <DataViewBuilderSeriesData[][]>this.data;\r\n                for (let seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {\r\n                    let seriesMeasures = data[seriesIndex];\r\n                    debug.assert(seriesMeasures.length === this.measureColumns.length, 'seriesMeasures.length === this.measureColumns.length');\r\n\r\n                    for (let measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                        let groupIndex = seriesIndex * measuresLen + measureIndex;\r\n\r\n                        applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Static series\r\n                let data = <DataViewBuilderValuesColumnOptions[]>this.data;\r\n                for (let measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {\r\n                    applySeriesData(dataViewValues[measureIndex], data[measureIndex], categoryLength);\r\n                }\r\n            }\r\n        }\r\n\r\n        public build(): DataView {\r\n            let metadataColumns: DataViewMetadataColumn[] = [];\r\n            let categorical: DataViewCategorical = {};\r\n            let groups: DataViewMetadataColumn[];\r\n\r\n            let categoryMetadata = this.categories;\r\n            let dynamicSeriesMetadata = this.dynamicSeriesMetadata;\r\n\r\n            // --- Build metadata columns and value groups ---\r\n            for (let columnMetadata of categoryMetadata) {\r\n                pushIfNotExists(metadataColumns, columnMetadata.source);\r\n            }\r\n\r\n            if (this.hasDynamicSeries) {\r\n                pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);\r\n            }\r\n\r\n            if (this.hasDynamicSeries) {\r\n                // Dynamic series\r\n                categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);\r\n\r\n                let measures = this.measureColumns;\r\n                groups = [];\r\n\r\n                // For each series value we will make one column per measure\r\n                let seriesValues = dynamicSeriesMetadata.values;\r\n                for (let seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {\r\n                    let seriesValue = seriesValues[seriesIndex];\r\n                    let seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);\r\n\r\n                    for (let measure of measures) {\r\n                        let column = _.clone(measure);\r\n                        column.groupName = <string>seriesValue;\r\n                        groups.push(column);\r\n\r\n                        pushIfNotExists(metadataColumns, column);\r\n                        categorical.values.push({\r\n                            source: column,\r\n                            values: [],\r\n                            identity: seriesIdentity,\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // Static series / no series\r\n                categorical.values = DataViewTransform.createValueColumns();\r\n                groups = this.measureColumns;\r\n                for (let measure of groups) {\r\n                    let column = measure;\r\n                    pushIfNotExists(metadataColumns, column);\r\n                    categorical.values.push({\r\n                        source: column,\r\n                        values: [],\r\n                    });\r\n                }\r\n            }\r\n\r\n            let categories = this.categories;\r\n            if (!_.isEmpty(categories))\r\n                categorical.categories = categories;\r\n\r\n            // --- Fill in data point values ---\r\n            this.fillData(categorical.values, groups);\r\n\r\n            return {\r\n                metadata: {\r\n                    columns: metadataColumns,\r\n                },\r\n                categorical: categorical,\r\n            };\r\n        }\r\n    }\r\n\r\n    function getScopeIdentity(\r\n        source: DataViewBuilderColumnIdentitySource,\r\n        index: number,\r\n        value: PrimitiveValue,\r\n        valueType: ValueTypeDescriptor): DataViewScopeIdentity {\r\n        let identities = source.identities;\r\n        if (identities) {\r\n            return identities[index];\r\n        }\r\n\r\n        debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');\r\n\r\n        return createDataViewScopeIdentity(\r\n            SQExprBuilder.equal(\r\n                source.fields[0],\r\n                SQExprBuilder.typedConstant(value, valueType)));\r\n    }\r\n\r\n    function pushIfNotExists(items: DataViewMetadataColumn[], itemToAdd: DataViewMetadataColumn): void {\r\n        if (_.contains(items, itemToAdd))\r\n            return;\r\n\r\n        items.push(itemToAdd);\r\n    }\r\n\r\n    function applySeriesData(target: DataViewValueColumn, source: DataViewBuilderSeriesData, categoryLength: number): void {\r\n        debug.assertValue(target, 'target');\r\n        debug.assertValue(source, 'source');\r\n        debug.assertValue(categoryLength, 'categoryLength');\r\n\r\n        let values = source.values;\r\n        debug.assert(categoryLength === values.length, 'categoryLength === values.length');\r\n\r\n        target.values = values;\r\n\r\n        let highlights = source.highlights;\r\n        if (highlights) {\r\n            debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');\r\n\r\n            target.highlights = highlights;\r\n        }\r\n\r\n        if (source.minLocal !== undefined)\r\n            target.minLocal = source.minLocal;\r\n\r\n        if (source.maxLocal !== undefined)\r\n            target.maxLocal = source.maxLocal;\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    import SQExpr = powerbi.data.SQExpr;\r\n\r\n    export function createStaticEvalContext(colorAllocatorCache?: IColorAllocatorCache): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]): IEvalContext;\r\n    export function createStaticEvalContext(colorAllocatorCache: IColorAllocatorCache, dataView?: DataView, selectTransforms?: DataViewSelectTransform[]): IEvalContext {\r\n        return new StaticEvalContext(\r\n            colorAllocatorCache || createColorAllocatorCache(),\r\n            dataView || { metadata: { columns: [] } },\r\n            selectTransforms);\r\n    }\r\n\r\n    /**\r\n     * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects\r\n     * are supported.\r\n     */\r\n    class StaticEvalContext implements IEvalContext {\r\n        private colorAllocatorCache: IColorAllocatorCache;\r\n        private dataView: DataView;\r\n        private selectTransforms: DataViewSelectTransform[];\r\n\r\n        constructor(colorAllocatorCache: IColorAllocatorCache, dataView: DataView, selectTransforms: DataViewSelectTransform[]) {\r\n            debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');\r\n            debug.assertValue(dataView, 'dataView');\r\n            debug.assertAnyValue(selectTransforms, 'selectTransforms');\r\n\r\n            this.colorAllocatorCache = colorAllocatorCache;\r\n            this.dataView = dataView;\r\n            this.selectTransforms = selectTransforms;\r\n        }\r\n\r\n        public getColorAllocator(expr: SQFillRuleExpr): IColorAllocator {\r\n            return this.colorAllocatorCache.get(expr);\r\n        }\r\n\r\n        public getExprValue(expr: SQExpr): PrimitiveValue {\r\n            let dataView = this.dataView,\r\n                selectTransforms = this.selectTransforms;\r\n            if (dataView && dataView.table && selectTransforms)\r\n                return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);\r\n        }\r\n\r\n        public getRoleValue(roleName: string): PrimitiveValue {\r\n            return;\r\n        }\r\n    }\r\n\r\n    export function getExprValueFromTable(expr: SQExpr, selectTransforms: DataViewSelectTransform[], table: DataViewTable, rowIdx: number): PrimitiveValue {\r\n        debug.assertValue(expr, 'expr');\r\n        debug.assertValue(selectTransforms, 'selectTransforms');\r\n        debug.assertValue(table, 'table');\r\n        debug.assertValue(rowIdx, 'rowIdx');\r\n\r\n        let rows = table.rows;\r\n        if (_.isEmpty(rows) || rows.length <= rowIdx)\r\n            return;\r\n\r\n        let cols = table.columns;\r\n        for (let selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {\r\n            let selectTransform = selectTransforms[selectIdx];\r\n            if (!SQExpr.equals(selectTransform.expr, expr) || !selectTransform.queryName)\r\n                continue;\r\n\r\n            for (let colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {\r\n                if (selectIdx !== cols[colIdx].index)\r\n                    continue;\r\n\r\n                return rows[rowIdx][colIdx];\r\n            }\r\n        }\r\n\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    export function createMatrixEvalContext(colorAllocatorProvider: IColorAllocatorCache, dataViewMatrix: DataViewMatrix): IEvalContext {\r\n        // NOTE: Matrix context-sensitive evaluation is not yet implemented.\r\n        return createStaticEvalContext(colorAllocatorProvider);\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved.\r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *\r\n *  The above copyright notice and this permission notice shall be included in\r\n *  all copies or substantial portions of the Software.\r\n *\r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi {\r\n\r\n    import StringExtensions = jsCommon.StringExtensions;\r\n    import Formatting = jsCommon.Formatting;\r\n    import RegExpExtensions = jsCommon.RegExpExtensions;\r\n\r\n    /** Culture interfaces. These match the Globalize library interfaces intentionally. */\r\n    export interface Culture {\r\n        name: string;\r\n        calendar: Calendar;\r\n        calendars: CalendarDictionary;\r\n        numberFormat: NumberFormatInfo;\r\n    }\r\n\r\n    export interface Calendar {\r\n        patterns: any;\r\n        firstDay: number;\r\n    }\r\n\r\n    export interface CalendarDictionary {\r\n        [key: string]: Calendar;\r\n    }\r\n\r\n    export interface NumberFormatInfo {\r\n        decimals: number;\r\n        groupSizes: number[];\r\n        negativeInfinity: string;\r\n        positiveInfinity: string;\r\n    }\r\n\r\n    /**\r\n     *  Creating a dummy module to declare cultureInfo string, so we could do a strongly typed usage in Visuals\r\n     */\r\n    declare module powerbi.common {\r\n        let cultureInfo: string;\r\n    }\r\n\r\n    /** Formatting Encoder */\r\n    module FormattingEncoder {\r\n        export function preserveEscaped(format: string, specialChars: string): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = \"\\\\\" + specialChars[i];\r\n                let newText = String.fromCharCode(0xE000 + i);\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreEscaped(format: string, specialChars: string): string {\r\n            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars\r\n            let length = specialChars.length;\r\n            for (let i = 0; i < length; i++) {\r\n                let oldText = String.fromCharCode(0xE000 + i);\r\n                let newText = specialChars[i];\r\n                format = StringExtensions.replaceAll(format, oldText, newText);\r\n            }\r\n            return StringExtensions.replaceAll(format, \"\\\\\", \"\");\r\n        }\r\n\r\n        export function preserveLiterals(format: string, literals: string[]): string {\r\n            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            for (let i = 0; ; i++) {\r\n                let fromIndex = format.indexOf(\"'\");\r\n                if (fromIndex < 0) {\r\n                    break;\r\n                }\r\n                let toIndex = format.indexOf(\"'\", fromIndex + 1);\r\n                if (toIndex < 0) {\r\n                    break;\r\n                }\r\n                let literal = format.substring(fromIndex, toIndex + 1);\r\n                literals.push(literal.substring(1, toIndex - fromIndex));\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                format = format.replace(literal, token);\r\n            }\r\n            return format;\r\n        }\r\n\r\n        export function restoreLiterals(format: string, literals: string[]): string {\r\n            let count = literals.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let token = String.fromCharCode(0xE100 + i);\r\n                let literal = literals[i];\r\n                format = format.replace(token, literal);\r\n            }\r\n            return format;\r\n        }\r\n    }\r\n\r\n    const IndexedTokensRegex = /({{)|(}})|{(\\d+[^}]*)}/g;\r\n    const ZeroPlaceholder = '0';\r\n    const DigitPlaceholder = '#';\r\n    const ExponentialFormatChar = 'E';\r\n    const NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];\r\n    const NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');\r\n\r\n    /** Formatting Service */\r\n    class FormattingService implements IFormattingService {\r\n\r\n        _currentCultureSelector: string;\r\n        _currentCulture: Culture;\r\n        _dateTimeScaleFormatInfo: DateTimeScaleFormatInfo;\r\n\r\n        public formatValue(value: any, format?: string, culture?: string): string {\r\n            // Handle special cases\r\n            if (value === undefined || value === null) {\r\n                return '';\r\n            }\r\n            let gculture = this.getCulture(culture);\r\n\r\n            if (DateTimeFormat.canFormat(value)) {\r\n                // Dates\r\n                return DateTimeFormat.format(value, format, gculture);\r\n            } else if (NumberFormat.canFormat(value)) {\r\n                // Numbers\r\n                return NumberFormat.format(value, format, gculture);\r\n            } else {\r\n                // Other data types - return as string\r\n                return value.toString();\r\n            }\r\n        }\r\n\r\n        public format(formatWithIndexedTokens: string, args: any[], culture?: string): string {\r\n            if (!formatWithIndexedTokens) {\r\n                return \"\";\r\n            }\r\n            let result = formatWithIndexedTokens.replace(IndexedTokensRegex, (match: string, left: string, right: string, argToken: string) => {\r\n                if (left) {\r\n                    return \"{\";\r\n                } else if (right) {\r\n                    return \"}\";\r\n                } else {\r\n                    let parts = argToken.split(\":\");\r\n                    let argIndex = parseInt(parts[0], 10);\r\n                    let argFormat = parts[1];\r\n                    return this.formatValue(args[argIndex], argFormat, culture);\r\n                }\r\n            });\r\n\r\n            return result;\r\n        }\r\n\r\n        public isStandardNumberFormat(format: string): boolean {\r\n            return NumberFormat.isStandardFormat(format);\r\n        }\r\n\r\n        public formatNumberWithCustomOverride(value: number, format: string, nonScientificOverrideFormat: string, culture?: string): string {\r\n            let gculture = this.getCulture(culture);\r\n\r\n            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);\r\n        }\r\n\r\n        public dateFormatString(unit: DateTimeUnit): string {\r\n            if (!this._dateTimeScaleFormatInfo)\r\n                this.initialize();\r\n            return this._dateTimeScaleFormatInfo.getFormatString(unit);\r\n        }\r\n\r\n        /**\r\n         * Sets the current localization culture\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         */\r\n        private setCurrentCulture(cultureSelector: string): void {\r\n            if (this._currentCultureSelector !== cultureSelector) {\r\n                this._currentCulture = this.getCulture(cultureSelector);\r\n                this._currentCultureSelector = cultureSelector;\r\n                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Gets the culture assotiated with the specified cultureSelector (\"en\", \"en-US\", \"fr-FR\" etc).\r\n         * @param cultureSelector - name of a culture: \"en\", \"en-UK\", \"fr-FR\" etc. (See National Language Support (NLS) for full lists. Use \"default\" for invariant culture).\r\n         * Exposing this function for testability of unsupported cultures\r\n         */\r\n        public getCulture(cultureSelector?: string): Culture {\r\n            if (cultureSelector == null) {\r\n                if (this._currentCulture == null) {\r\n                    this.initialize();\r\n                }\r\n                return this._currentCulture;\r\n            } else {\r\n                let culture = Globalize.findClosestCulture(cultureSelector);\r\n                if (!culture)\r\n                    culture = Globalize.culture(\"en-US\");\r\n                return culture;\r\n            }\r\n        }\r\n\r\n        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */\r\n        private initialize() {\r\n            let cultureName = this.getCurrentCulture();\r\n            this.setCurrentCulture(cultureName);\r\n            let calendarName = this.getUrlParam(\"calendar\");\r\n            if (calendarName) {\r\n                let culture = this._currentCulture;\r\n                let c = culture.calendars[calendarName];\r\n                if (c) {\r\n                    culture.calendar = c;\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability \r\n         */\r\n        public getCurrentCulture(): string {\r\n            let urlParam = this.getUrlParam(\"language\");\r\n\r\n            if (urlParam) {\r\n                return urlParam;\r\n            }\r\n\r\n            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {\r\n                // Get cultureInfo set in powerbi\r\n                return powerbi.common.cultureInfo;\r\n            }\r\n\r\n            return window.navigator.userLanguage || window.navigator[\"language\"] || Globalize.culture().name;\r\n        }\r\n\r\n        /**\r\n         *  Exposing this function for testability\r\n         *  @param name: queryString name\r\n         */\r\n        public getUrlParam(name: string): string {\r\n            let param = window.location.search.match(RegExp(\"[?&]\" + name + \"=([^&]*)\"));\r\n            return param ? param[1] : undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * DateTimeFormat module contains the static methods for formatting the DateTimes.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for dates.\r\n     */\r\n    module DateTimeFormat {\r\n\r\n        let _currentCachedFormat: string;\r\n        let _currentCachedProcessedFormat: string;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = value instanceof Date;\r\n            return result;\r\n        }\r\n\r\n        /** Formats the date using provided format and culture */\r\n        export function format(value: Date, format: string, culture: Culture): string {\r\n            format = format || \"G\";\r\n            let isStandard = format.length === 1;\r\n            try {\r\n                if (isStandard) {\r\n                    return formatDateStandard(value, format, culture);\r\n                } else {\r\n                    return formatDateCustom(value, format, culture);\r\n                }\r\n            } catch (e) {\r\n                return formatDateStandard(value, \"G\", culture);\r\n            }\r\n        }\r\n\r\n        /** Formats the date using standard format expression */\r\n        function formatDateStandard(value: Date, format: string, culture: Culture) {\r\n            // In order to provide parity with .NET we have to support additional set of DateTime patterns.\r\n            let patterns = culture.calendar.patterns;\r\n            // Extend supported set of patterns\r\n            ensurePatterns(culture.calendar);\r\n            // Handle extended set of formats\r\n            let output = Formatting.findDateFormat(value, format, culture.name);\r\n            if (output.format.length === 1)\r\n                format = patterns[output.format];\r\n            else\r\n                format = output.format;\r\n            //need to revisit when globalization is enabled\r\n            culture = Globalize.culture(\"en-US\");\r\n            return Globalize.format(output.value, format, culture);\r\n        }\r\n\r\n        /** Formats the date using custom format expression */\r\n        function formatDateCustom(value: Date, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let literals: string[] = [];\r\n            format = FormattingEncoder.preserveEscaped(format, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            format = FormattingEncoder.preserveLiterals(format, literals);\r\n            format = StringExtensions.replaceAll(format, \"\\\"\", \"'\");\r\n            if (format.indexOf(\"F\") > -1) {\r\n                // F is not supported so we need to replace the F with f based on the milliseconds\r\n                // Replace all sequences of F longer than 3 with \"FFF\"\r\n                format = StringExtensions.replaceAll(format, \"FFFF\", \"FFF\");\r\n                // Based on milliseconds update the format to use fff\r\n                let milliseconds = value.getMilliseconds();\r\n                if (milliseconds % 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FFF\", \"fff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FFF\", \"FF\");\r\n                if ((milliseconds % 100) / 10 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"FF\", \"ff\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"FF\", \"F\");\r\n                if ((milliseconds % 1000) / 100 >= 1) {\r\n                    format = StringExtensions.replaceAll(format, \"F\", \"f\");\r\n                }\r\n                format = StringExtensions.replaceAll(format, \"F\", \"\");\r\n                if (format === \"\" || format === \"%\")\r\n                    return \"\";\r\n            }\r\n            format = processCustomDateTimeFormat(format);\r\n            result = Globalize.format(value, format, culture);\r\n            result = localize(result, culture.calendar);\r\n            result = FormattingEncoder.restoreLiterals(result, literals);\r\n            result = FormattingEncoder.restoreEscaped(result, \"\\\\dfFghHKmstyz:/%'\\\"\");\r\n            return result;\r\n        }\r\n\r\n        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */\r\n        function processCustomDateTimeFormat(format: string): string {\r\n            if (format === _currentCachedFormat) {\r\n                return _currentCachedProcessedFormat;\r\n            }\r\n            _currentCachedFormat = format;\r\n            format = Formatting.fixDateTimeFormat(format);\r\n            _currentCachedProcessedFormat = format;\r\n            return format;\r\n        }\r\n\r\n        /** Localizes the time separator symbol */\r\n        function localize(value: string, dictionary: any): string {\r\n            let timeSeparator = dictionary[\":\"];\r\n            if (timeSeparator === \":\") {\r\n                return value;\r\n            }\r\n            let result = \"\";\r\n            let count = value.length;\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \":\":\r\n                        result += timeSeparator;\r\n                        break;\r\n                    default:\r\n                        result += char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function ensurePatterns(calendar: GlobalizeCalendar) {\r\n            let patterns = calendar.patterns;\r\n            if (patterns[\"g\"] === undefined) {\r\n                patterns[\"g\"] = patterns[\"f\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, short time\r\n                patterns[\"G\"] = patterns[\"F\"].replace(patterns[\"D\"], patterns[\"d\"]);  // Generic: Short date, long time\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * NumberFormat module contains the static methods for formatting the numbers.\r\n     * It extends the JQuery.Globalize functionality to support complete set of .NET\r\n     * formatting expressions for numeric types including custom formats.\r\n     */\r\n    export module NumberFormat {\r\n\r\n        const NonScientificFormatRegex = /^\\{.+\\}.*/;\r\n        const NumericalPlaceHolderRegex = /\\{.+\\}/;\r\n        const ScientificFormatRegex = /e[+-]*[0#]+/i;\r\n        const StandardFormatRegex = /^[a-z]\\d{0,2}$/i; // a letter + up to 2 digits for precision specifier\r\n        const TrailingZerosRegex = /0+$/;\r\n        const DecimalFormatRegex = /\\.([0#]*)/g;\r\n        const NumericFormatRegex = /[0#,\\.]+[0,#]*/g;\r\n        const LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;\r\n        const DecimalFormatCharacter = '.';\r\n\r\n        export const NumberFormatComponentsDelimeter = ';';\r\n\r\n        export interface NumericFormatMetadata {\r\n            format: string;\r\n            hasEscapes: boolean;\r\n            hasQuotes: boolean;\r\n            hasE: boolean;\r\n            hasCommas: boolean;\r\n            hasDots: boolean;\r\n            hasPercent: boolean;\r\n            hasPermile: boolean;\r\n            precision: number;\r\n            scale: number;\r\n        }\r\n\r\n        export interface NumberFormatComponents {\r\n            hasNegative: boolean;\r\n            positive: string;\r\n            negative: string;\r\n            zero: string;\r\n        }\r\n\r\n        function getNonScientificFormatWithPrecision(baseFormat: string, numericFormat: string): string {\r\n            if (!numericFormat || baseFormat === undefined)\r\n                return baseFormat;\r\n\r\n            let newFormat = \"{0:\" + numericFormat + \"}\";\r\n\r\n            return baseFormat.replace(\"{0}\", newFormat);\r\n        }\r\n\r\n        export function getNumericFormat(value: number, baseFormat: string): string {\r\n            if (baseFormat == null)\r\n                return baseFormat;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n\r\n                if (value > 0)\r\n                    return getNumericFormatFromComponent(value, positive);\r\n                else if (value === 0)\r\n                    return getNumericFormatFromComponent(value, zero);\r\n\r\n                return getNumericFormatFromComponent(value, negative);\r\n            }\r\n\r\n            return getNumericFormatFromComponent(value, baseFormat);\r\n        }\r\n\r\n        function getNumericFormatFromComponent(value: number, format: string): string {\r\n            let match = RegExpExtensions.run(NumericFormatRegex, format);\r\n            if (match)\r\n                return match[0];\r\n\r\n            return format;\r\n        }\r\n\r\n        export function addDecimalsToFormat(baseFormat: string, decimals: number, trailingZeros: boolean): string {\r\n            if (decimals == null)\r\n                return baseFormat;\r\n\r\n            // Default format string\r\n            if (baseFormat == null)\r\n                baseFormat = ZeroPlaceholder;\r\n\r\n            if (hasFormatComponents(baseFormat)) {\r\n                let {positive, negative, zero} = NumberFormat.getComponents(baseFormat);\r\n                let formats = [positive, negative, zero];\r\n                for (let i = 0; i < formats.length; i++) {\r\n                    // Update format in formats array\r\n                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);\r\n                }\r\n\r\n                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);\r\n            }\r\n\r\n            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);\r\n        }\r\n\r\n        function addDecimalsToFormatComponent(format: string, decimals: number, trailingZeros: boolean): string {\r\n            decimals = Math.abs(decimals);\r\n\r\n            if (decimals >= 0) {\r\n                let placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;\r\n                let decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));\r\n\r\n                let match = RegExpExtensions.run(DecimalFormatRegex, format);\r\n                if (match) {\r\n                    let beforeDecimal = format.substr(0, match.index);\r\n                    let formatDecimal = format.substr(match.index + 1, match[1].length);\r\n                    let afterDecimal = format.substr(match.index + match[0].length);\r\n\r\n                    if (trailingZeros)\r\n                        // Use explicit decimals argument as placeholders\r\n                        formatDecimal = decimalPlaceholders;\r\n                    else {\r\n                        let decimalChange = decimalPlaceholders.length - formatDecimal.length;\r\n                        if (decimalChange > 0)\r\n                            // Append decimalPlaceholders to existing decimal portion of format string\r\n                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);\r\n                        else if (decimalChange < 0)\r\n                            // Remove decimals from formatDecimal\r\n                            formatDecimal = formatDecimal.slice(0, decimalChange);\r\n                    }\r\n\r\n                    if (formatDecimal.length > 0)\r\n                        formatDecimal = DecimalFormatCharacter + formatDecimal;\r\n\r\n                    return beforeDecimal + formatDecimal + afterDecimal;\r\n                }\r\n                else if (decimalPlaceholders.length > 0)\r\n                    // Replace last numeric placeholder with decimal portion\r\n                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);\r\n            }\r\n\r\n            return format;\r\n        }\r\n\r\n        export function hasFormatComponents(format: string): boolean {\r\n            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;\r\n        }\r\n\r\n        export function getComponents(format: string): NumberFormatComponents {\r\n            let signFormat: NumberFormatComponents = {\r\n                hasNegative: false,\r\n                positive: format,\r\n                negative: format,\r\n                zero: format,\r\n            };\r\n\r\n            let signSpecificFormats = format.split(NumberFormatComponentsDelimeter);\r\n            let formatCount = signSpecificFormats.length;\r\n            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');\r\n\r\n            if (formatCount > 1) {\r\n                signFormat.hasNegative = true;\r\n\r\n                signFormat.positive = signFormat.zero = signSpecificFormats[0];\r\n                signFormat.negative = signSpecificFormats[1];\r\n\r\n                if (formatCount > 2)\r\n                    signFormat.zero = signSpecificFormats[2];\r\n            }\r\n\r\n            return signFormat;\r\n        }\r\n\r\n        let _lastCustomFormatMeta: NumericFormatMetadata;\r\n\r\n        /** Evaluates if the value can be formatted using the NumberFormat */\r\n        export function canFormat(value: any) {\r\n            let result = typeof (value) === \"number\";\r\n            return result;\r\n        }\r\n\r\n        export function isStandardFormat(format: string): boolean {\r\n            debug.assertValue(format, 'format');\r\n            return StandardFormatRegex.test(format);\r\n        }\r\n\r\n        /** Formats the number using specified format expression and culture */\r\n        export function format(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture): string {\r\n            format = format || \"G\";\r\n            try {\r\n                if (isStandardFormat(format))\r\n                    return formatNumberStandard(value, format, culture);\r\n\r\n                return formatNumberCustom(value, format, culture);\r\n            } catch (e) {\r\n                return Globalize.format(value, undefined, culture);\r\n            }\r\n        }\r\n\r\n        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */\r\n        export function formatWithCustomOverride(\r\n            value: number,\r\n            format: string,\r\n            nonScientificOverrideFormat: string,\r\n            culture: Culture): string {\r\n            debug.assertValue(value, 'value');\r\n            debug.assertValue(format, 'format');\r\n            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');\r\n            debug.assertValue(culture, 'culture');\r\n            debug.assert(!isStandardFormat(format), 'Standard format');\r\n\r\n            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);\r\n        }\r\n\r\n        /** Formats the number using standard format expression */\r\n        function formatNumberStandard(value: number, format: string, culture: Culture): string {\r\n            let result: string;\r\n            let precision = <number>(format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);\r\n            let numberFormatInfo = culture.numberFormat;\r\n            let formatChar = format.charAt(0);\r\n            switch (formatChar) {\r\n                case \"e\":\r\n                case \"E\":\r\n                    if (precision === undefined) {\r\n                        precision = 6;\r\n                    }\r\n                    let mantissaDecimalDigits = StringExtensions.repeat(\"0\", precision);\r\n                    format = \"0.\" + mantissaDecimalDigits + formatChar + \"+000\";\r\n                    result = formatNumberCustom(value, format, culture);\r\n                    break;\r\n                case \"f\":\r\n                case \"F\":\r\n                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"g\":\r\n                case \"G\":\r\n                    let abs = Math.abs(value);\r\n                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {\r\n                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form\r\n                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();\r\n                    } else {\r\n                        // Otherwise use exponential\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();\r\n                        result = result.replace(\"e\", \"E\");\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"r\":\r\n                case \"R\":\r\n                    result = value.toString();\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                case \"x\":\r\n                case \"X\":\r\n                    result = value.toString(16);\r\n                    if (formatChar === \"X\") {\r\n                        result = result.toUpperCase();\r\n                    }\r\n                    if (precision !== undefined) {\r\n                        let actualPrecision = result.length;\r\n                        let isNegative = value < 0;\r\n                        if (isNegative) {\r\n                            actualPrecision--;\r\n                        }\r\n                        let paddingZerosCount = precision - actualPrecision;\r\n                        let paddingZeros = undefined;\r\n                        if (paddingZerosCount > 0) {\r\n                            paddingZeros = StringExtensions.repeat(\"0\", paddingZerosCount);\r\n                        }\r\n                        if (isNegative) {\r\n                            result = \"-\" + paddingZeros + result.substr(1);\r\n                        } else {\r\n                            result = paddingZeros + result;\r\n                        }\r\n                    }\r\n                    result = localize(result, numberFormatInfo);\r\n                    break;\r\n                default:\r\n                    result = Globalize.format(value, format, culture);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Formats the number using custom format expression */\r\n        function formatNumberCustom(\r\n            value: number,\r\n            format: string,\r\n            culture: Culture,\r\n            nonScientificOverrideFormat?: string): string {\r\n            let result: string;\r\n            let numberFormatInfo = culture.numberFormat;\r\n            if (isFinite(value)) {\r\n                // Split format by positive[;negative;zero] pattern\r\n                let formatComponents = getComponents(format);\r\n\r\n                // Pick a format based on the sign of value\r\n                if (value > 0) {\r\n                    format = formatComponents.positive;\r\n                } else if (value === 0) {\r\n                    format = formatComponents.zero;\r\n                } else {\r\n                    format = formatComponents.negative;\r\n                }\r\n\r\n                // Normalize value if we have an explicit negative format\r\n                if (formatComponents.hasNegative)\r\n                    value = Math.abs(value);\r\n\r\n                // Get format metadata\r\n                let formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);\r\n\r\n                // Preserve literals and escaped chars\r\n                if (formatMeta.hasEscapes) {\r\n                    format = FormattingEncoder.preserveEscaped(format, \"\\\\0#.,%\");\r\n                }\r\n                let literals: string[] = [];\r\n                if (formatMeta.hasQuotes) {\r\n                    format = FormattingEncoder.preserveLiterals(format, literals);\r\n                }\r\n\r\n                // Scientific format\r\n                if (formatMeta.hasE && !nonScientificOverrideFormat) {\r\n                    let scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);\r\n                    if (scientificMatch) {\r\n                        // Case 2.1. Scientific custom format\r\n                        let formatM = format.substr(0, scientificMatch.index);\r\n                        let formatE = format.substr(scientificMatch.index + 2); // E(+|-)\r\n                        let precision = getCustomFormatPrecision(formatM, formatMeta);\r\n                        let scale = getCustomFormatScale(formatM, formatMeta);\r\n                        if (scale !== 1) {\r\n                            value = value * scale;\r\n                        }\r\n                        // Assert that value is a number and fall back on returning value if it is not\r\n                        debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                        if (typeof (value) !== \"number\")\r\n                            return String(value);\r\n                        let s = value.toExponential(precision);\r\n                        let indexOfE = s.indexOf(\"e\");\r\n                        let mantissa = s.substr(0, indexOfE);\r\n                        let exp = s.substr(indexOfE + 1);\r\n                        let resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);\r\n                        let resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);\r\n                        if (resultE.charAt(0) === \"+\" && scientificMatch[0].charAt(1) !== \"+\") {\r\n                            resultE = resultE.substr(1);\r\n                        }\r\n                        let e = scientificMatch[0].charAt(0);\r\n                        result = resultM + e + resultE;\r\n                    }\r\n                }\r\n\r\n                // Non scientific format\r\n                if (result === undefined) {\r\n                    let valueFormatted: string;\r\n                    let isValueGlobalized: boolean = false;\r\n                    let precision = getCustomFormatPrecision(format, formatMeta);\r\n                    let scale = getCustomFormatScale(format, formatMeta);\r\n\r\n                    if (scale !== 1)\r\n                        value = value * scale;\r\n\r\n                    // Rounding\r\n                    value = parseFloat(toNonScientific(value, precision));\r\n\r\n                    if (nonScientificOverrideFormat) {\r\n                        // Get numeric format from format string\r\n                        let numericFormat = NumberFormat.getNumericFormat(value, format);\r\n\r\n                        // Add separators and decimalFormat to nonScientificFormat\r\n                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);\r\n\r\n                        // Format the value\r\n                        valueFormatted = formattingService.format(nonScientificOverrideFormat, [value], culture.name);\r\n                        isValueGlobalized = true;\r\n                    }\r\n                    else\r\n                        valueFormatted = toNonScientific(value, precision);\r\n\r\n                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);\r\n                }\r\n                if (formatMeta.hasQuotes) {\r\n                    result = FormattingEncoder.restoreLiterals(result, literals);\r\n                }\r\n                if (formatMeta.hasEscapes) {\r\n                    result = FormattingEncoder.restoreEscaped(result, \"\\\\0#.,%\");\r\n                }\r\n\r\n                _lastCustomFormatMeta = formatMeta;\r\n            } else {\r\n                return Globalize.format(value, undefined);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /** Returns string with the fixed point respresentation of the number */\r\n        function toNonScientific(value: number, precision: number): string {\r\n            let result = \"\";\r\n            let precisionZeros = 0;\r\n            // Double precision numbers support actual 15-16 decimal digits of precision.\r\n            if (precision > 16) {\r\n                precisionZeros = precision - 16;\r\n                precision = 16;\r\n            }\r\n            let digitsBeforeDecimalPoint = Double.log10(Math.abs(value));\r\n            if (digitsBeforeDecimalPoint < 16) {\r\n                if (digitsBeforeDecimalPoint > 0) {\r\n                    let maxPrecision = 16 - digitsBeforeDecimalPoint;\r\n                    if (precision > maxPrecision) {\r\n                        precisionZeros += precision - maxPrecision;\r\n                        precision = maxPrecision;\r\n                    }\r\n                }\r\n                result = value.toFixed(precision);\r\n            } else if (digitsBeforeDecimalPoint === 16) {\r\n                result = value.toFixed(0);\r\n                precisionZeros += precision;\r\n                if (precisionZeros > 0) {\r\n                    result += \".\";\r\n                }\r\n            } else { // digitsBeforeDecimalPoint > 16\r\n                // Different browsers have different implementations of the toFixed().\r\n                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.\r\n                // So we need to check for range and convert the to exponential with the max precision.\r\n                // Then we convert exponential string to fixed by removing the dot and padding with \"power\" zeros.\r\n                // Assert that value is a number and fall back on returning value if it is not\r\n                debug.assert(typeof (value) === \"number\", \"value must be a number\");\r\n                if (typeof (value) !== \"number\")\r\n                    return String(value);\r\n                result = value.toExponential(15);\r\n                let indexOfE = result.indexOf(\"e\");\r\n                if (indexOfE > 0) {\r\n                    let indexOfDot = result.indexOf(\".\");\r\n                    let mantissa = result.substr(0, indexOfE);\r\n                    let exp = result.substr(indexOfE + 1);\r\n                    let powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);\r\n                    result = mantissa.replace(\".\", \"\") + StringExtensions.repeat(\"0\", powerZeros);\r\n                    if (precision > 0) {\r\n                        result = result + \".\" + StringExtensions.repeat(\"0\", precision);\r\n                    }\r\n                }\r\n            }\r\n            if (precisionZeros > 0) {\r\n                result = result + StringExtensions.repeat(\"0\", precisionZeros);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        /**\r\n         * Returns the formatMetadata of the format\r\n         * When calculating precision and scale, if format string of\r\n         * positive[;negative;zero] => positive format will be used\r\n         * @param (required) format - format string\r\n         * @param (optional) calculatePrecision - calculate precision of positive format\r\n         * @param (optional) calculateScale - calculate scale of positive format\r\n         */\r\n        export function getCustomFormatMetadata(format: string, calculatePrecision?: boolean, calculateScale?: boolean): NumericFormatMetadata {\r\n            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {\r\n                return _lastCustomFormatMeta;\r\n            }\r\n\r\n            let result = {\r\n                format: format,\r\n                hasEscapes: false,\r\n                hasQuotes: false,\r\n                hasE: false,\r\n                hasCommas: false,\r\n                hasDots: false,\r\n                hasPercent: false,\r\n                hasPermile: false,\r\n                precision: undefined,\r\n                scale: undefined,\r\n            };\r\n\r\n            for (let i = 0, length = format.length; i < length; i++) {\r\n                let c = format.charAt(i);\r\n                switch (c) {\r\n                    case \"\\\\\":\r\n                        result.hasEscapes = true;\r\n                        break;\r\n                    case \"'\":\r\n                    case \"\\\"\":\r\n                        result.hasQuotes = true;\r\n                        break;\r\n                    case \"e\":\r\n                    case \"E\":\r\n                        result.hasE = true;\r\n                        break;\r\n                    case \",\":\r\n                        result.hasCommas = true;\r\n                        break;\r\n                    case \".\":\r\n                        result.hasDots = true;\r\n                        break;\r\n                    case \"%\":\r\n                        result.hasPercent = true;\r\n                        break;\r\n                    case \"\":\r\n                        result.hasPermile = true;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // Use positive format for calculating these values\r\n            let formatComponents = getComponents(format);\r\n\r\n            if (calculatePrecision)\r\n                result.precision = getCustomFormatPrecision(formatComponents.positive, result);\r\n            if (calculateScale)\r\n                result.scale = getCustomFormatScale(formatComponents.positive, result);\r\n\r\n            return result;\r\n        }\r\n\r\n        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point\r\n          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */\r\n        function getCustomFormatPrecision(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.precision > -1) {\r\n                return formatMeta.precision;\r\n            }\r\n            let result = 0;\r\n            if (formatMeta.hasDots) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex > -1) {\r\n                    let count = format.length;\r\n                    for (let i = dotIndex; i < count; i++) {\r\n                        let char = format.charAt(i);\r\n                        if (char.match(NumericPlaceholderRegex))\r\n                            result++;\r\n                        // 0.00E+0 :: Break before counting 0 in\r\n                        // exponential portion of format string\r\n                        if (char === ExponentialFormatChar)\r\n                            break;\r\n                    }\r\n                    result = Math.min(19, result);\r\n                }\r\n            }\r\n\r\n            formatMeta.precision = result;\r\n            return result;\r\n        }\r\n\r\n        /** Returns the scale factor of the format based on the \"%\" and scaling \",\" chars in the format */\r\n        function getCustomFormatScale(format: string, formatMeta: NumericFormatMetadata): number {\r\n            if (formatMeta.scale > -1) {\r\n                return formatMeta.scale;\r\n            }\r\n            let result = 1;\r\n            if (formatMeta.hasPercent && format.indexOf(\"%\") > -1) {\r\n                result = result * 100;\r\n            }\r\n            if (formatMeta.hasPermile && format.indexOf(\"\") > -1) {\r\n                result = result * 1000;\r\n            }\r\n            if (formatMeta.hasCommas) {\r\n                let dotIndex = format.indexOf(\".\");\r\n                if (dotIndex === -1) {\r\n                    dotIndex = format.length;\r\n                }\r\n                for (let i = dotIndex - 1; i > -1; i--) {\r\n                    let char = format.charAt(i);\r\n                    if (char === \",\") {\r\n                        result = result / 1000;\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            formatMeta.scale = result;\r\n            return result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormat(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, nonScientificOverrideFormat?: string, isValueGlobalized?: boolean): string {\r\n            let suppressModifyValue = !!nonScientificOverrideFormat;\r\n            let formatParts = format.split(\".\", 2);\r\n            if (formatParts.length === 2) {\r\n                let wholeFormat = formatParts[0];\r\n                let fractionFormat = formatParts[1];\r\n                let displayUnit = \"\";\r\n\r\n                // Remove display unit from value before splitting on \".\" as localized display units sometimes end with \".\"\r\n                if (nonScientificOverrideFormat) {\r\n                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), \"Number should always precede the display unit\");\r\n                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, \"\");\r\n                    value = value.replace(displayUnit, \"\");\r\n                }\r\n\r\n                let globalizedDecimalSeparator = numberFormatInfo[\".\"];\r\n                let decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : \".\";\r\n                let valueParts = value.split(decimalSeparator, 2);\r\n                let wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];\r\n                let fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : \"\";\r\n                fractionValue = fractionValue.replace(TrailingZerosRegex, \"\");\r\n\r\n                let wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);\r\n                let fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);\r\n\r\n                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === \"\")\r\n                    return wholeFormattedValue + fractionFormattedValue.value;\r\n\r\n                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;\r\n            }\r\n            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatLeft(value: string, format: string, numberFormatInfo: GlobalizeNumberFormat, suppressModifyValue?: boolean): string {\r\n            let groupSymbolIndex = format.indexOf(\",\");\r\n            let enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf(\"0\"), format.lastIndexOf(\"#\")) && numberFormatInfo[\",\"];\r\n            let groupDigitCount = 0;\r\n            let groupIndex = 0;\r\n            let groupSizes = numberFormatInfo.groupSizes || [3];\r\n            let groupSize = groupSizes[0];\r\n            let groupSeparator = numberFormatInfo[\",\"];\r\n            let sign = \"\";\r\n            let firstChar = value.charAt(0);\r\n            if (firstChar === \"+\" || firstChar === \"-\") {\r\n                sign = numberFormatInfo[firstChar];\r\n                value = value.substr(1);\r\n            }\r\n            let isZero = value === \"0\";\r\n            let result = \"\";\r\n            let leftBuffer = \"\";\r\n            let vi = value.length - 1;\r\n            let fmtOnly = true;\r\n            // Iterate through format chars and replace 0 and # with the digits from the value string\r\n            for (let fi = format.length - 1; fi > -1; fi--) {\r\n                let formatChar = format.charAt(fi);\r\n                switch (formatChar) {\r\n                    case ZeroPlaceholder:\r\n                    case DigitPlaceholder:\r\n                        fmtOnly = false;\r\n                        if (leftBuffer !== \"\") {\r\n                            result = leftBuffer + result;\r\n                            leftBuffer = \"\";\r\n                        }\r\n                        if (!suppressModifyValue) {\r\n                            if (vi > -1 || formatChar === ZeroPlaceholder) {\r\n                                if (enableGroups) {\r\n                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,\r\n                                    if (groupDigitCount === groupSize) {\r\n                                        result = groupSeparator + result;\r\n                                        groupIndex++;\r\n                                        if (groupIndex < groupSizes.length) {\r\n                                            groupSize = groupSizes[groupIndex];\r\n                                        }\r\n                                        groupDigitCount = 1;\r\n                                    } else {\r\n                                        groupDigitCount++;\r\n                                    }\r\n                                }\r\n                            }\r\n                            if (vi > -1) {\r\n                                if (isZero && formatChar === DigitPlaceholder) {\r\n                                    // Special case - if we need to format a zero value and the # symbol is used - we don't copy it into the result)\r\n                                } else {\r\n                                    result = value.charAt(vi) + result;\r\n                                }\r\n                                vi--;\r\n                            } else if (formatChar !== DigitPlaceholder) {\r\n                                result = formatChar + result;\r\n                            }\r\n                        }\r\n                        break;\r\n                    case \",\":\r\n                        // We should skip all the , chars\r\n                        break;\r\n                    default:\r\n                        leftBuffer = formatChar + leftBuffer;\r\n                        break;\r\n                }\r\n            }\r\n\r\n            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result\r\n            if (!suppressModifyValue) {\r\n                if (vi > -1 && result !== \"\") {\r\n                    if (enableGroups) {\r\n                        while (vi > -1) {\r\n                            if (groupDigitCount === groupSize) {\r\n                                result = groupSeparator + result;\r\n                                groupIndex++;\r\n                                if (groupIndex < groupSizes.length) {\r\n                                    groupSize = groupSizes[groupIndex];\r\n                                }\r\n                                groupDigitCount = 1;\r\n                            } else {\r\n                                groupDigitCount++;\r\n                            }\r\n                            result = value.charAt(vi) + result;\r\n                            vi--;\r\n                        }\r\n                    } else {\r\n                        result = value.substr(0, vi + 1) + result;\r\n                    }\r\n                }\r\n                // Insert sign in front of the leftBuffer and result\r\n                return sign + leftBuffer + result;\r\n            }\r\n\r\n            if (fmtOnly)\r\n                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.\r\n                return sign + leftBuffer + result;\r\n\r\n            return sign + leftBuffer + value + result;\r\n        }\r\n\r\n        function fuseNumberWithCustomFormatRight(value: string, format: string, suppressModifyValue?: boolean): { value: string; fmtOnly?: boolean } {\r\n            let vi = 0;\r\n            let fCount = format.length;\r\n            let vCount = value.length;\r\n\r\n            if (suppressModifyValue) {\r\n                debug.assert(fCount > 0, \"Empty formatting string\");\r\n\r\n                let lastChar = format.charAt(fCount - 1);\r\n                if (!lastChar.match(NumericPlaceholderRegex))\r\n                    return {\r\n                        value: value + lastChar,\r\n                        fmtOnly: value === \"\",\r\n                    };\r\n\r\n                return {\r\n                    value: value,\r\n                    fmtOnly: value === \"\",\r\n                };\r\n            }\r\n\r\n            let result = \"\",\r\n                fmtOnly: boolean = true;\r\n            for (let fi = 0; fi < fCount; fi++) {\r\n                let formatChar = format.charAt(fi);\r\n                if (vi < vCount) {\r\n                    switch (formatChar) {\r\n                        case ZeroPlaceholder:\r\n                        case DigitPlaceholder:\r\n                            result += value[vi++];\r\n                            fmtOnly = false;\r\n                            break;\r\n                        default:\r\n                            result += formatChar;\r\n                    }\r\n                } else {\r\n                    if (formatChar !== DigitPlaceholder) {\r\n                        result += formatChar;\r\n                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);\r\n                    }\r\n                }\r\n            }\r\n\r\n            return {\r\n                value: result,\r\n                fmtOnly: fmtOnly,\r\n            };\r\n        }\r\n\r\n        function localize(value: string, dictionary: any): string {\r\n            let plus = dictionary[\"+\"];\r\n            let minus = dictionary[\"-\"];\r\n            let dot = dictionary[\".\"];\r\n            let comma = dictionary[\",\"];\r\n            if (plus === \"+\" && minus === \"-\" && dot === \".\" && comma === \",\") {\r\n                return value;\r\n            }\r\n            let count = value.length;\r\n            let result = \"\";\r\n            for (let i = 0; i < count; i++) {\r\n                let char = value.charAt(i);\r\n                switch (char) {\r\n                    case \"+\":\r\n                        result = result + plus;\r\n                        break;\r\n                    case \"-\":\r\n                        result = result + minus;\r\n                        break;\r\n                    case \".\":\r\n                        result = result + dot;\r\n                        break;\r\n                    case \",\":\r\n                        result = result + comma;\r\n                        break;\r\n                    default:\r\n                        result = result + char;\r\n                        break;\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n\r\n    }\r\n\r\n    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */\r\n    class DateTimeScaleFormatInfo {\r\n\r\n        // Fields\r\n        public YearPattern: string;\r\n        public MonthPattern: string;\r\n        public DayPattern: string;\r\n        public HourPattern: string;\r\n        public MinutePattern: string;\r\n        public SecondPattern: string;\r\n        public MillisecondPattern: string;\r\n\r\n        // Constructor\r\n        /**\r\n         * Creates new instance of the DateTimeScaleFormatInfo class.\r\n         * @param culture - culture which calendar info is going to be used to derive the formats.\r\n         */\r\n        constructor(culture: Culture) {\r\n            let calendar: Calendar = culture.calendar;\r\n            let patterns: any = calendar.patterns;\r\n            let monthAbbreviations: any = calendar[\"months\"][\"namesAbbr\"];\r\n            let cultureHasMonthAbbr: boolean = monthAbbreviations && monthAbbreviations[0];\r\n            let yearMonthPattern: string = patterns[\"Y\"];\r\n            let monthDayPattern: string = patterns[\"M\"];\r\n            let fullPattern: string = patterns[\"f\"];\r\n            let longTimePattern: string = patterns[\"T\"];\r\n            let shortTimePattern: string = patterns[\"t\"];\r\n            let separator: string = fullPattern.indexOf(\",\") > -1 ? \", \" : \" \";\r\n\r\n            let hasYearSymbol: boolean = yearMonthPattern.indexOf(\"yyyy'\") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\\'';\r\n            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : \"yyyy\";\r\n\r\n            let yearPos: number = fullPattern.indexOf(\"yy\");\r\n            let monthPos: number = fullPattern.indexOf(\"MMMM\");\r\n            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? \"MMM yyyy\" : \"yyyy MMM\") : yearMonthPattern;\r\n\r\n            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace(\"MMMM\", \"MMM\") : monthDayPattern;\r\n\r\n            let minutePos: number = fullPattern.indexOf(\"mm\");\r\n            let pmPos: number = fullPattern.indexOf(\"tt\");\r\n            let shortHourPattern: string = pmPos > -1 ? shortTimePattern.replace(\":mm \", \"\") : shortTimePattern;\r\n            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;\r\n\r\n            this.MinutePattern = shortTimePattern;\r\n\r\n            this.SecondPattern = longTimePattern;\r\n\r\n            this.MillisecondPattern = longTimePattern.replace(\"ss\", \"ss.fff\");\r\n\r\n            // Special cases\r\n            switch (culture.name) {\r\n                case \"fi-FI\":\r\n                    this.DayPattern = this.DayPattern.replace(\"'ta'\", \"\"); // Fix for finish 'ta' suffix for month names.\r\n                    this.HourPattern = this.HourPattern.replace(\"'ta'\", \"\");\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Methods\r\n\r\n        /**\r\n         * Returns the format string of the provided DateTimeUnit.\r\n         * @param unit - date or time unit\r\n         */\r\n        public getFormatString(unit: DateTimeUnit): string {\r\n            switch (unit) {\r\n                case DateTimeUnit.Year:\r\n                    return this.YearPattern;\r\n                case DateTimeUnit.Month:\r\n                    return this.MonthPattern;\r\n                case DateTimeUnit.Week:\r\n                case DateTimeUnit.Day:\r\n                    return this.DayPattern;\r\n                case DateTimeUnit.Hour:\r\n                    return this.HourPattern;\r\n                case DateTimeUnit.Minute:\r\n                    return this.MinutePattern;\r\n                case DateTimeUnit.Second:\r\n                    return this.SecondPattern;\r\n                case DateTimeUnit.Millisecond:\r\n                    return this.MillisecondPattern;\r\n            }\r\n\r\n            debug.assertFail('Unexpected unit: ' + unit);\r\n        }\r\n    }\r\n\r\n    export var formattingService: IFormattingService = new FormattingService();\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.data {\r\n    /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */\r\n    export module SQExprShortSerializer {\r\n        export function serialize(expr: SQExpr): string {\r\n            return JSON.stringify(expr.accept(SQExprSerializer.instance));\r\n        }\r\n\r\n        export function serializeArray(exprs: SQExpr[]): string {\r\n            let str = '[';\r\n            for (let i = 0, len = exprs.length; i < len; i++) {\r\n                if (i > 0)\r\n                    str += ',';\r\n                str += SQExprShortSerializer.serialize(exprs[i]);\r\n            }\r\n            return str + ']';\r\n        }\r\n\r\n        /** Responsible for serializing an SQExpr into a comparable string. */\r\n        class SQExprSerializer extends DefaultSQExprVisitor<{}> {\r\n            public static instance: SQExprSerializer = new SQExprSerializer();\r\n\r\n            public visitColumnRef(expr: SQColumnRefExpr): {} {\r\n                return {\r\n                    col: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitMeasureRef(expr: SQMeasureRefExpr): {} {\r\n                return {\r\n                    measure: {\r\n                        s: expr.source.accept(this),\r\n                        r: expr.ref,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitAggr(expr: SQAggregationExpr): {} {\r\n                return {\r\n                    agg: {\r\n                        a: expr.arg.accept(this),\r\n                        f: expr.func,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitEntity(expr: SQEntityExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n                debug.assertValue(expr.entity, 'expr.entity');\r\n\r\n                return {\r\n                    e: expr.entity\r\n                };\r\n            }\r\n\r\n            public visitHierarchyLevel(expr: SQHierarchyLevelExpr): {} {\r\n                return {\r\n                    h: expr.arg.accept(this),\r\n                    l: expr.level,\r\n                };\r\n            }\r\n\r\n            public visitHierarchy(expr: SQHierarchyExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    h: expr.hierarchy,\r\n                };\r\n            }\r\n\r\n            public visitPropertyVariationSource(expr: SQPropertyVariationSourceExpr): {} {\r\n                return {\r\n                    e: expr.arg.accept(this),\r\n                    n: expr.name,\r\n                    p: expr.property,\r\n                };\r\n            }\r\n\r\n            public visitAnd(expr: SQAndExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    and: {\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitCompare(expr: SQCompareExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    comp: {\r\n                        k: expr.comparison,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this),\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitConstant(expr: SQConstantExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    const: {\r\n                        t: expr.type.primitiveType,\r\n                        v: expr.value,\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitArithmetic(expr: SQArithmeticExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    arithmetic: {\r\n                        o: expr.operator,\r\n                        l: expr.left.accept(this),\r\n                        r: expr.right.accept(this)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitScopedEval(expr: SQScopedEvalExpr): {} {\r\n                debug.assertValue(expr, 'expr');\r\n\r\n                return {\r\n                    scopedEval: {\r\n                        e: expr.expression.accept(this),\r\n                        s: serializeArray(expr.scope)\r\n                    }\r\n                };\r\n            }\r\n\r\n            public visitDefault(expr: SQExpr): {} {\r\n                debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');\r\n\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}","/*\r\n *  Power BI Visualizations\r\n *\r\n *  Copyright (c) Microsoft Corporation\r\n *  All rights reserved. \r\n *  MIT License\r\n *\r\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\r\n *  of this software and associated documentation files (the \"\"Software\"\"), to deal\r\n *  in the Software without restriction, including without limitation the rights\r\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n *  copies of the Software, and to permit persons to whom the Software is\r\n *  furnished to do so, subject to the following conditions:\r\n *   \r\n *  The above copyright notice and this permission notice shall be included in \r\n *  all copies or substantial portions of the Software.\r\n *   \r\n *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR \r\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE \r\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n *  THE SOFTWARE.\r\n */\r\n\r\nmodule powerbi.visuals {\r\n    import Selector = powerbi.data.Selector;\r\n    import SelectorsByColumn = powerbi.SelectorsByColumn;\r\n    import SelectorForColumn = powerbi.SelectorForColumn;\r\n\r\n    /**\r\n     * A combination of identifiers used to uniquely identify\r\n     * data points and their bound geometry.\r\n     */\r\n    export class SelectionId implements ISelectionId {\r\n        private selector: Selector;\r\n        // This is a new data structure to support drilling -- in the long term it should replace the 'selector' field\r\n        private selectorsByColumn: SelectorsByColumn;\r\n        private key: string;\r\n        private keyWithoutHighlight: string;\r\n\r\n        public highlight: boolean;\r\n\r\n        constructor(selector: Selector, highlight: boolean) {\r\n            this.selector = selector;\r\n            this.highlight = highlight;\r\n            this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });\r\n            this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });\r\n        }\r\n\r\n        public equals(other: SelectionId): boolean {\r\n            if (!this.selector || !other.selector) {\r\n                return (!this.selector === !other.selector) && this.highlight === other.highlight;\r\n            }\r\n            return this.highlight === other.highlight &&  Selector.equals(this.selector, other.selector);\r\n        }\r\n        \r\n        /**\r\n         * Checks equality against other for all identifiers existing in this.\r\n         */\r\n        public includes(other: SelectionId, ignoreHighlight: boolean = false): boolean {\r\n            let thisSelector = this.selector;\r\n            let otherSelector = other.selector;\r\n            if (!thisSelector || !otherSelector) {\r\n                return false;\r\n            }\r\n            let thisData = thisSelector.data;\r\n            let otherData = otherSelector.data;\r\n            if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))\r\n                return false;\r\n            if (!ignoreHighlight && this.highlight !== other.highlight)\r\n                return false;\r\n            if (thisData) {\r\n                if (!otherData)\r\n                    return false;\r\n                if (thisData.length > 0) {\r\n                    for (let i = 0, ilen = thisData.length; i < ilen; i++) {\r\n                        var thisValue = <DataViewScopeIdentity>thisData[i];\r\n                        if (!otherData.some((otherValue: DataViewScopeIdentity) => DataViewScopeIdentity.equals(thisValue, otherValue)))\r\n                            return false;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        public getKey(): string {\r\n            return this.key;\r\n        }\r\n\r\n        public getKeyWithoutHighlight(): string {\r\n            return this.keyWithoutHighlight;\r\n        }\r\n        \r\n        public hasIdentity(): boolean {\r\n            return (this.selector && !!this.selector.data);\r\n        }\r\n\r\n        public getSelector(): Selector {\r\n            return this.selector;\r\n        }\r\n\r\n        public getSelectorsByColumn(): Selector {\r\n            return this.selectorsByColumn;\r\n        }\r\n\r\n        public static createNull(highlight: boolean = false): SelectionId {\r\n            return new SelectionId(null, highlight);\r\n        }\r\n\r\n        public static createWithId(id: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            if (id) {\r\n                selector = {\r\n                    data: [id]\r\n                };\r\n            }\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithMeasure(measureId: string, highlight: boolean = false): SelectionId {\r\n            debug.assertValue(measureId, 'measureId');\r\n\r\n            let selector: Selector = {\r\n                metadata: measureId\r\n            };\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n            selectionId.selectorsByColumn = { metadata: measureId };\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasure(id: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: powerbi.data.Selector = {};\r\n            if (id) {\r\n                selector.data = [id];\r\n            }\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id && !measureId)\r\n                selector = null;\r\n\r\n            let selectionId = new SelectionId(selector, highlight);\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIdAndMeasureAndCategory(id: DataViewScopeIdentity, measureId: string, queryName: string, highlight: boolean = false): SelectionId {\r\n            let selectionId = this.createWithIdAndMeasure(id, measureId, highlight);\r\n\r\n            if (selectionId.selector) {\r\n                selectionId.selectorsByColumn = {};\r\n                if (id && queryName) {\r\n                    selectionId.selectorsByColumn.dataMap = {};\r\n                    selectionId.selectorsByColumn.dataMap[queryName] = id;\r\n                }\r\n                if (measureId)\r\n                    selectionId.selectorsByColumn.metadata = measureId;\r\n            }\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithIds(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = null;\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector = { data: selectorData };\r\n            \r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithIdsAndMeasure(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity, measureId: string, highlight: boolean = false): SelectionId {\r\n            let selector: Selector = {};\r\n            let selectorData = SelectionId.idArray(id1, id2);\r\n            if (selectorData)\r\n                selector.data = selectorData;\r\n\r\n            if (measureId)\r\n                selector.metadata = measureId;\r\n            if (!id1 && !id2 && !measureId)\r\n                selector = null;\r\n            return new SelectionId(selector, highlight);\r\n        }\r\n\r\n        public static createWithSelectorForColumnAndMeasure(dataMap: SelectorForColumn, measureId: string, highlight: boolean = false): SelectionId {\r\n\r\n            let selectionId: visuals.SelectionId;\r\n            let keys = Object.keys(dataMap);\r\n            if (keys.length === 2) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], <DataViewScopeIdentity>dataMap[keys[1]], measureId, highlight);\r\n            } else if (keys.length === 1) {\r\n                selectionId = this.createWithIdsAndMeasure(<DataViewScopeIdentity>dataMap[keys[0]], null, measureId, highlight);\r\n            } else {\r\n                selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);\r\n            }\r\n\r\n            let selectorsByColumn: SelectorsByColumn = {};\r\n            if (!_.isEmpty(dataMap))\r\n                selectorsByColumn.dataMap = dataMap;\r\n            if (measureId)\r\n                selectorsByColumn.metadata = measureId;\r\n            if (!dataMap && !measureId)\r\n                selectorsByColumn = null;\r\n\r\n            selectionId.selectorsByColumn = selectorsByColumn;\r\n\r\n            return selectionId;\r\n        }\r\n\r\n        public static createWithHighlight(original: SelectionId): SelectionId {\r\n            debug.assertValue(original, 'original');\r\n            debug.assert(!original.highlight, '!original.highlight');\r\n\r\n            let newId = new SelectionId(original.getSelector(), /*highlight*/ true);\r\n            newId.selectorsByColumn = original.selectorsByColumn;\r\n\r\n            return newId;\r\n        }\r\n\r\n        private static idArray(id1: DataViewScopeIdentity, id2: DataViewScopeIdentity): DataViewScopeIdentity[] {\r\n            if (id1 || id2) {\r\n                let data = [];\r\n                if (id1)\r\n                    data.push(id1);\r\n                if (id2 && id2 !== id1)\r\n                    data.push(id2);\r\n                return data;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This class is designed to simplify the creation of SelectionId objects\r\n     * It allows chaining to build up an object before calling 'create' to build a SelectionId\r\n     */\r\n    export class SelectionIdBuilder implements ISelectionIdBuilder {\r\n        private dataMap: SelectorForColumn;\r\n        private measure: string;\r\n\r\n        public static builder(): SelectionIdBuilder {\r\n            return new SelectionIdBuilder();\r\n        }\r\n\r\n        public withCategory(categoryColumn: DataViewCategoryColumn, index: number): this{\r\n            if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)\r\n                this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];\r\n            \r\n            return this;\r\n        }\r\n\r\n        public withSeries(seriesColumn: DataViewValueColumns, valueColumn: DataViewValueColumn | DataViewValueColumnGroup): this {\r\n            if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)\r\n                this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;\r\n\r\n            return this;\r\n        }\r\n\r\n        public withMeasure(measureId: string): this {\r\n            this.measure = measureId;\r\n\r\n            return this;\r\n        }\r\n\r\n        public createSelectionId(): SelectionId {\r\n            return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);\r\n        }\r\n\r\n        private ensureDataMap(): SelectorForColumn {\r\n            if (!this.dataMap)\r\n                this.dataMap = {};\r\n\r\n            return this.dataMap;\r\n        }\r\n    }\r\n}\r\n"],"sourceRoot":"/source/"}